.  Otherwise
        // the other thread could wake up when the event is set and immediately
        // block on the critical section.
        //

        LeaveCriticalSection(&pwp->csWrite);

        // avoid setting the event twice
        if(!fDelay) {
            SetEvent(pwp->hWriteEvent);
        }

    } else {
        LeaveCriticalSection(&pwp->csWrite);
    }

    // this gives the writer thread a chance to write out "AT+FCLASS=1" strings
    if(fDelay) {
        SetEvent(pwp->hWriteEvent);
        Sleep(1000);
    }

    return cbWritten;
}



//
// WOWCommWriteThread created for COM ports only.  This thread dequeues
// characters from the write buffer and writes them to the COM port.
// This thread uses pwp->hWriteEvent for two purposes:
//
//   1. The event is signalled by EnqueueCommWrite when the write
//      buffer had been empty but is not now.  This wakes us up
//      so we can write to the port.  Note that we will always
//      be in the WaitForSingleObject at the top of the function
//      in this case, since that's where we sleep when the buffer
//      is empty.
//
//   2. DeletePortTabEntry signals the event after setting
//      pwp->fClose to tell us the port is closing and we
//      need to clean up and terminate this thread.  This
//      thread might be doing anything in this case, but
//      it is careful to check pwp->fClose before sleeping
//      again.
//
//   3. wu32FlushComm() signals the event and marks the queue empty

ULONG WOWCommWriterThread(LPVOID pWOWPortStruct)
{
    PWOWPORT   pwp = (PWOWPORT)pWOWPortStruct;
    HANDLE     ah[2];

    //
    // Copy event handles into array for WaitForMultipleObjects.
    //

    ah[0] = pwp->hWriteEvent;
    ah[1] = pwp->olWrite.hEvent;

WaitForWriteOrder:

    //
    // pwp->fClose is TRUE when the port is closed.
    //

    while (!pwp->fClose) {

        //
        // First wait for something to be written to the buffer.
        //

        WaitForSingleObject(pwp->hWriteEvent, INFINITE);

        //
        // Critical section protects write buffer.
        //

        EnterCriticalSection(&pwp->csWrite);

        //
        // The buffer is empty when head == tail.
        //

        while (pwp->pchWriteHead != pwp->pchWriteTail) {

            //
            // pwp->cbWritePending will be nonzero if
            // the application thread queued a write to
            // an empty buffer and then issued the first
            // WriteFile call.
            //

            if (pwp->cbWritePending) {
                if (!pwp->fWriteDone) {
                    LeaveCriticalSection(&pwp->csWrite);
                    goto WaitForWriteCompletion;
                } else {
                    goto CleanupAfterWriteComplete;
                }
            }

            pwp->cbWritePending = CALC_COMM_WRITE_SIZE(pwp);

            //
            // Leave the critical section before writing.  This is
            // safe because the app thread doesn't change the
            // head pointer.   (Not true if wu32FlushComm was called)
            //

            LeaveCriticalSection(&pwp->csWrite);

            if (!WriteFile(pwp->h32, pwp->pchWriteHead, pwp->cbWritePending,
                           &pwp->cbWritten, &pwp->olWrite)) {

                if (ERROR_IO_PENDING == GetLastError() ) {

WaitForWriteCompletion:
                    //
                    // Wait for the write to complete or for us to
                    // be alerted that the port is closing.
                    //

                    while (WAIT_OBJECT_0 == WaitForMultipleObjects(2, ah, FALSE, INFINITE)) {

                        //
                        // pwp->hWriteEvent was signaled.  This probably
                        // means that the port was closed.
                        //

                        if (pwp->fClose) {
                            goto PortClosed;
                        }
                    }

                    if (GetOverlappedResult(pwp->h32,
                                             &pwp->olWrite,
                                             &pwp->cbWritten,
                                             TRUE
                                             ) )
                       {
                        goto WriteSuccess;
                     }
                }


                LOGDEBUG(0, ("WOWCommWriterThread: WriteFile to id %u fails (error %u)\n",
                             pwp->idComDev, GetLastError()));
                pwp->cbWritePending = 0;
                goto WaitForWriteOrder;

            }


WriteSuccess:

            //
            // Update head pointer to reflect portion written.
            //

            EnterCriticalSection(&pwp->csWrite);

CleanupAfterWriteComplete:
            WOW32ASSERT(pwp->cbWritten == (WORD)pwp->cbWritten);

            pwp->pchWriteHead += pwp->cbWritten;
            pwp->cbWriteFree += (WORD)pwp->cbWritten;
            pwp->cbWritePending = 0;

            //
            // The following is a sanity check on our buffer manipulations.
            //

#ifdef DEBUG
            if (pwp->pchWriteHead >= pwp->pchWriteBuf + pwp->cbWriteBuf) {
                WOW32ASSERT(pwp->pchWriteHead == pwp->pchWriteBuf + pwp->cbWriteBuf);
            }
#endif

            if (pwp->pchWriteHead == pwp->pchWriteBuf + pwp->cbWriteBuf) {
                pwp->pchWriteHead = pwp->pchWriteBuf;
            }
        }

        //
        // We have exhausted the write buffer, leave the critical section
        // and loop back to the wait for the buffer to become non-empty.
        //

        LeaveCriticalSection(&pwp->csWrite);
    }

PortClosed:
    CloseHandle(pwp->olWrite.hEvent);

    return 0;
}



// Checks status on RLSD, CTS, and DSR for timeout support
// see MSRWait() in win3.1 comm.drv code
BOOL MSRWait(PWOWPORT pwp)
{
    DWORD dwStartTime, dwElapsedTime, dwLineStatus;
    DWORD dwErr = 0;


    // start the timeout clock (returns msec)
    dwStartTime = GetTickCount();

    // loop until either all lines are high or a timeout occurs
    while(!dwErr) {

        // get the current status of the lines
        if ( !GetCommModemStatus(pwp->h32, &dwLineStatus) ) {
             //can't rely on third party drivers not to mess with dwLineStatus on failure
             dwLineStatus = 0;
        }

        // if all the required lines are up -- we're done
        if((pwp->lpComDEB16->MSRMask & LOBYTE(dwLineStatus)) == pwp->lpComDEB16->MSRMask)
            break;

        // get the elapsed time
        dwElapsedTime = GetTickCount() - dwStartTime;

        if(pwp->RLSDTimeout != IGNORE_TIMEOUT) {
            // if line is low
            if(!(dwLineStatus & MS_RLSD_ON)) {
                if(dwElapsedTime > UINT32(pwp->RLSDTimeout))
                    dwErr |= CE_RLSDTO;
            }
        }

        if(pwp->CTSTimeout != IGNORE_TIMEOUT) {
            // if line is low
            if(!(dwLineStatus & MS_CTS_ON)) {
                if(dwElapsedTime > UINT32(pwp->CTSTimeout))
                    dwErr |= CE_CTSTO;
            }
        }

        if(pwp->DSRTimeout != IGNORE_TIMEOUT) {
            // if line is low
            if(!(dwLineStatus & MS_DSR_ON)) {
                if(dwElapsedTime > UINT32(pwp->DSRTimeout))
                    dwErr |= CE_DSRTO;
            }
        }
    }

    pwp->dwErrCode |= dwErr;
    pwp->lpComDEB16->ComErr |= LOWORD(dwErr);

    if(dwErr)
       return(TRUE);
    else
       return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuclip.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUCLIP.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


ULONG FASTCALL   WU32ChangeClipboardChain(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CloseClipboard(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CountClipboardFormats(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EmptyClipboard(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EnumClipboardFormats(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetClipboardData(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetClipboardFormatName(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetClipboardOwner(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetClipboardViewer(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetPriorityClipboardFormat(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsClipboardFormatAvailable(PVDMFRAME pFrame);
ULONG FASTCALL   WU32OpenClipboard(PVDMFRAME pFrame);
ULONG FASTCALL   WU32RegisterClipboardFormat(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetClipboardData(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetClipboardViewer(PVDMFRAME pFrame);

ULONG   WU32ICBRenderFormat (WORD wFormat);
HMEM16  WU32ICBGetHandle(WORD wFormat);
VOID    WU32ICBStoreHandle(WORD wFormat, HMEM16 hMem16);
VOID    W32EmptyClipboard (void);
VOID    InitCBFormats (void);
HGLOBAL W32ConvertObjDescriptor(HANDLE hMem, UINT flag);

typedef struct _CBNODE {
    WORD    Id;
    HMEM16  hMem16;
    struct _CBNODE *Next;
} CBNODE, *PCBNODE;


typedef struct _CBFORMATS {
    WORD    Pre1[13];
    WORD    Pre2[4];
    WORD    hmem16Drop;   // for the CF_HDROP support
    struct _CBNODE  *NewFormats;
} CBFORMATS;


#define CFOLE_UNICODE_TO_ANSI           0
#define CFOLE_ANSI_TO_UNICODE           1

#define WOW_OLE_STRINGCONVERSION        0
#define WOW_OLESTRINGCONVERSION_COUNT   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wucomm.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUCOMM.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *  Updated    Dec-1992 by Craig Jones (v-cjones)
--*/

#include "wowcomm.h"

// these limits set as doc'd in Win3.1 Prog. ref. for OpenComm()
#define NUMCOMS        9          // max avail COM's
#define NUMLPTS        3          // max available LPT's
#define NUMPORTS  NUMCOMS+NUMLPTS // max # of entries in PortTab[]

// com port indicies into PortTab[]
#define COM1           0
#define COM2           1
#define COM3           2
#define COM4           3
#define COM5           4
#define COM6           5
#define COM7           6
#define COM8           7
#define COM9           8
#define LPT1           NUMCOMS
#define LPT2           LPT1+1
#define LPT3           LPT1+2
#define AUX            COM1
#define PRN            LPT1

// DOS comm IRQ assignments
#define IRQ3   3
#define IRQ4   4
#define IRQ5   5
#define IRQ7   7

// LPT assignments a la Win3.1
#define LPTFIRST       0x80                   // 0x80 == LPT1
#define LPTLAST        LPTFIRST + NUMLPTS - 1 // 0x82 == LPT3

// other useful deinitions & macros
#define COMMASK        0x00FF                    // strip garbage from idComDev
#define LPTMASK        0x007F                    // get 0-based LPT #
#define GETLPTID(id)   ((id & LPTMASK) + LPT1)   // 0x80 LPT to PortTab[] index
#define TABIDTOLPT(id) (id + LPTFIRST - NUMCOMS) // PortTab[] index to LPT 0x80
#define VALIDCOM(id)   ((id <  NUMCOMS) ? TRUE : FALSE)
#define VALIDLPT(id)   (((id >= LPTFIRST) && (id <= LPTLAST)) ? TRUE : FALSE)

#define GETPWOWPTR(id) (VALIDCOM(id) ? PortTab[id].pWOWPort : (VALIDLPT(id) ? PortTab[GETLPTID(id)].pWOWPort : NULL))

#define RM_BIOS_DATA   0x00400000                // bios data real mode seg:0

// for Win3.1 compatibility in EscapeCommFunction() API thunk support
#define RESETDEV      7
#define GETMAXLPT     8
#define GETMAXCOM     9
#define GETBASEIRQ   10

// notifications for EnableCommNotification() support
#define CN_RECEIVE    0x0001
#define CN_TRANSMIT   0x0002
#define CN_EVENT      0x0004
#define CN_RECEIVEHI  0x0100
#define CN_TRANSMITHI 0x0200
#define CN_NOTIFYHI   0x0400

#define WOW_WM_COMMNOTIFY 0x0044

// set all the events that can be masked on NT (a sub-set of Win3.1)
#define EV_NTEVENTS (EV_BREAK | EV_CTS    | EV_DSR    | EV_ERR  | EV_TXEMPTY | \
                     EV_RLSD  | EV_RXCHAR | EV_RXFLAG | EV_RING)

// constants for how Win3.1 expects to see the MSR
#define MSR_DELTAONLY   0x0000000F // strip off MSR state bits
#define MSR_STATEONLY   0x000000F0 // strip off MSR delta bits
#define MSR_DCTS        0x01       // bit for delta CTS
#define MSR_DDSR        0x02       // bit for delta DSR
#define MSR_TERI        0x04       // bit for TERI
#define MSR_DDCD        0x08       // bit for delta DCD
#define MSR_CTS         0x10       // bit for CTS
#define MSR_DSR         0x20       // bit for DSR
#define MSR_RI          0x40       // bit for RI
#define MSR_DCD         0x80       // bit for DCD

// Win3.1 constants for RLSD, CTS, and DSR timeout support
#define CE_RLSDTO       0x0080
#define CE_CTSTO        0x0020
#define CE_DSRTO        0x0040

// constants for the Event Word
#define EV_CTSS     0x00000400 // bit for Win3.1 showing CTS state
#define EV_DSRS     0x00000800 // bit for Win3.1 showing DSR state
#define EV_RLSDS    0x00001000 // bit for Win3.1 showing RLSD state
#define EV_RingTe   0x00002000 // bit for Win3.1 showing RingTe state

#define ERR_XMIT         0x4000 // can't xmit a char Win3.1
#define INFINITE_TIMEOUT 0xFFFF // infinite timeout Win3.1
#define IGNORE_TIMEOUT   0x0000 // Win3.1 ignore RLSD, CTS, & DSR timeouts

#define COMBUF 2 // max. # of bytes we'll queue for WriteComm()

#define MAXCOMNAME     4             // max length of a comm device name
#define MAXCOMNAMENULL MAXCOMNAME+1  // length of a comm device name + NULL

// for 16-bit to 32-bit comm support
typedef struct _WOWPORT {
    UINT       idComDev;       // idComDev returned to app as handle of port
    HANDLE     h32;            // NT file handle used instead of idComDev
    HANDLE     hREvent;        // structure for overlapped reads
    CRITICAL_SECTION csWrite;  // critsect controls following 4 variables.
    PUCHAR     pchWriteHead;   // oldest byte not yet written to port.
    PUCHAR     pchWriteTail;   // first byte available in buffer.
    WORD       cbWriteFree;    // number of bytes available in write buffer.
    WORD       cbWritePending; // number of bytes now in WriteFile()
    PUCHAR     pchWriteBuf;    // write buffer
    WORD       cbWriteBuf;     // size of the write buffer.  One byte unused.
    HANDLE     hWriteThread;   // thread handle for COM writer.
    HANDLE     hWriteEvent;    // signalled by app thread when empty buffer
                               // made non-empty to wake up writer thread.
    OVERLAPPED olWrite;        // Overlapped structure used for writes.
    BOOL       fWriteDone;     // Indicates app thread completed first write.
    DWORD      cbWritten;      // Valid when fWriteDone == TRUE.
    DWORD      dwThreadID;     // app's thread id for crashed/hung app support
    DWORD      dwErrCode;      // most recent error for this idComDev
    COMSTAT    cs;             // struct for error handling
    BOOL       fChEvt;         // TRUE if app set fChEvt in DCB struct
  // 16-bit DCB for LPT support only
    PDCB16     pdcb16;         // save DCB for LPT ports
  // for UngetCommChar() support
    BOOL       fUnGet;         // flag specifying an ungot char is pending
    UCHAR      cUnGet;         // ungot char in "buffer" only if fUnGet is set
  // for SetCommEventMask()/EnableCommNotification() support
    HANDLE     hMiThread;      // thread handle for Modem interrupt support
    BOOL       fClose;         // flag to close auxiliary threads
  // for SetCommEventMask() support only
    DWORD      dwComDEB16;     // DWORD obtained by call to GlobalDosAlloc()
    PCOMDEB16  lpComDEB16;     // flat address to above
  // for XonLim & XoffLim checking in SetCommState
    DWORD      cbInQ;          // Actual size of in Queue set in WU32OpenComm
  // for RLSD, CTS, DSR timeout support
    WORD       RLSDTimeout;    // max time in msec to wait for RLSD (0->ignore)
    WORD       CTSTimeout;     // max time in msec to wait for CTS (0->ignore)
    WORD       DSRTimeout;     // max time in msec to wait for DSR (0->ignore)
    DWORD      QLStackSeg;     // Quicklink 1.3 hack See bug #398011
                               // save the seg val of COMDEB16 in low word, &
                               // the QuickLink stack selector in the high word
} WOWPORT, *PWOWPORT;

// Table of above structs, one entry needed for each comm port
typedef struct _PORTTAB {
    CHAR      szPort[MAXCOMNAMENULL]; // port name
    PWOWPORT  pWOWPort;               // pointer to Comm Mapping struct
} PORTTAB, *PPORTTAB;

//
// Macro to calculate the size of chunk to write from the write
// to the filesystem.
//
// This is either the entire pending part of the
// buffer, or, if the buffer wraps, it is the portion
// between the head and the end of the buffer.
//
// In order to keep COMSTAT.cbOutQue moving at a reasonable
// pace, we restrict ourselves to writing at most 1024 bytes
// at a time.  This is because ProComm for Windows uses the
// cbOutQue value in displaying its progress, so if we allow
// larger writes it will only update every 5-10k (assuming
// ProComm's default 16k write buffer),
//

#define CALC_COMM_WRITE_SIZE(pwp)                            \
                min(1024,                                      \
                    (pwp->pchWriteHead < pwp->pchWriteTail)    \
                     ? pwp->pchWriteTail - pwp->pchWriteHead   \
                     : (pwp->pchWriteBuf + pwp->cbWriteBuf) -  \
                        pwp->pchWriteHead                      \
                   );


// Win3.1 timesout Tx after approx. 65000 msec (65 sec)
#define WRITE_TIMEOUT 65000

// bitfields of the 16-bit COMSTAT.status
#define W31CS_fCtsHold       0x01
#define W31CS_fDsrHold       0x02
#define W31CS_fRlsdHold      0x04
#define W31CS_fXoffHold      0x08
#define W31CS_fSentHold      0x10
#define W31CS_fEof           0x20
#define W31CS_fTxim          0x40

// Win3.1 Baud Rate constants
#define W31CBR_110       0xFF10
#define W31CBR_300       0xFF11
#define W31CBR_600       0xFF12
#define W31CBR_1200      0xFF13
#define W31CBR_2400      0xFF14
#define W31CBR_4800      0xFF15
#define W31CBR_9600      0xFF16
#define W31CBR_14400     0xFF17
#define W31CBR_19200     0xFF18
#define W31CBR_reserved1 0xFF19
#define W31CBR_reserved2 0xFF1A
#define W31CBR_38400     0xFF1B
#define W31CBR_reserved3 0xFF1C
#define W31CBR_reserved4 0xFF1D
#define W31CBR_reserved5 0xFF1E
#define W31CBR_56000     0xFF1F

// these are defined in Win3.1 windows.h but aren't supported in comm.drv
#define W31CBR_128000    0xFF23
#define W31CBR_256000    0xFF27

// special way to say 115200
#define W31CBR_115200    0xFEFF

// constants for conversions from Win3.1 baud specifications to 32-bit baud
#define W31_DLATCH_110      1047
#define W31_DLATCH_300       384
#define W31_DLATCH_600       192
#define W31_DLATCH_1200       96
#define W31_DLATCH_2400       48
#define W31_DLATCH_4800       24
#define W31_DLATCH_9600       12
#define W31_DLATCH_14400       8
#define W31_DLATCH_19200       6
#define W31_DLATCH_38400       3
#define W31_DLATCH_56000       2
#define W31_DLATCH_115200      1

// Win3.1 flags for DCB structure
#define W31DCB_fBinary       0x0001
#define W31DCB_fRtsDisable   0x0002
#define W31DCB_fParity       0x0004
#define W31DCB_fOutxCtsFlow  0x0008
#define W31DCB_fOutxDsrFlow  0x0010
#define W31DCB_fDummy       (0x0020 | 0x0040)
#define W31DCB_fDtrDisable   0x0080
#define W31DCB_fOutX         0x0100
#define W31DCB_fInX          0x0200
#define W31DCB_fPeChar       0x0400
#define W31DCB_fNull         0x0800
#define W31DCB_fChEvt        0x1000
#define W31DCB_fDtrFlow      0x2000
#define W31DCB_fRtsFlow      0x4000
#define W31DCB_fDummy2       0x8000



//+++ DEBUG SUPPORT

#ifdef DEBUG

#define COMMDEBUG(lpszformat) LOGDEBUG(1, lpszformat)

// for watching the modem events
#define DEBUGWATCHMODEMEVENTS(dwE, dwM, dwS, pcE16, pcM16) {    \
    if(dwS) {                                                   \
        if((dwE != (DWORD)pcE16) || (dwM != (DWORD)pcM16)) {    \
            dwE = (DWORD)pcE16;                                 \
            dwM = (DWORD)pcM16;                                 \
            COMMDEBUG(("\nEvt:0x%4X  MSR:0x%2X\n", dwE, dwM));  \
        }                                                       \
        else {                                                  \
         COMMDEBUG(("."));                                      \
        }                                                       \
    }                                                           \
}

// prototype for real-time debug output
void CommIODebug(ULONG fhCommIO, HANDLE hCommIO, LPSZ lpsz, ULONG cb, LPSZ lpszFile);


#else  // endif DEBUG

#define COMMDEBUG(lpszFormat)
#define DEBUGWATCHMODEMEVENTS(dwE, dwM, dwS, pcE16, pcM16)
#define CommIODebug(fhCommIO, hCommIO, lpsz, cb, lpszFile)

#endif // endif !DEBUG

//--- DEBUG SUPPORT




// API support function prototypes
ULONG FASTCALL   WU32BuildCommDCB(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ClearCommBreak(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CloseComm(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EnableCommNotification(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EscapeCommFunction(PVDMFRAME pFrame);
ULONG FASTCALL   WU32FlushComm(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetCommError(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetCommEventMask(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetCommState(PVDMFRAME pFrame);
ULONG FASTCALL   WU32OpenComm(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ReadComm(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetCommBreak(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetCommEventMask(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetCommState(PVDMFRAME pFrame);
ULONG FASTCALL   WU32TransmitCommChar(PVDMFRAME pFrame);
ULONG FASTCALL   WU32UngetCommChar(PVDMFRAME pFrame);
ULONG FASTCALL   WU32WriteComm(PVDMFRAME pFrame);

// prototypes for functions exported to the VDM
BYTE    GetCommShadowMSR(WORD idComDev);
HANDLE  GetCommHandle(WORD idComDev);

// prototype for crashed/hung app cleanup support
VOID FreeCommSupportResources(DWORD dwThreadID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wucursor.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUCURSOR.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WU32ClipCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32DestroyCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32LoadCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetCursorPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32ShowCursor(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wucursor.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUCURSOR.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop


MODNAME(wucursor.c);

/*++
    void ClipCursor(<lpRect>)
    LPRECT <lpRect>;

    The %ClipCursor% function confines the cursor to the rectangle on the
    display screen given by the <lpRect> parameter. If a subsequent cursor
    position, given with the %SetCursorPos% function or the mouse, lies outside
    the rectangle, Windows automatically adjusts the position to keep the cursor
    inside. If <lpRect> is NULL, the cursor is free to move anywhere on the
    display screen.

    <lpRect>
        Points to a %RECT% structure that contains the screen coordinates
        of the upper-left and lower-right corners of the confining rectangle.

    This function does not return a value.

    The cursor is a shared resource. An application that has confined the cursor
    to a given rectangle must free it before relinquishing control to another
    application.
--*/

ULONG FASTCALL WU32ClipCursor(PVDMFRAME pFrame)
{
    RECT t1, *p1;
    register PCLIPCURSOR16 parg16;

    GETARGPTR(pFrame, sizeof(CLIPCURSOR16), parg16);
    p1 = GETRECT16(parg16->f1, &t1);

    ClipCursor(
        p1
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    HCURSOR CreateCursor(<hInstance>, <nXhotspot>, <nYhotspot>, <nWidth>,
        <nHeight>, <lpANDbitPlane>, <lpXORbitPlane>)
    HANDLE <hInstance>;
    int <nXhotspot>;
    int <nYhotspot>;
    int <nWidth>;
    int <nHeight>;
    LPSTR <lpANDbitPlane>;
    LPSTR <lpXORbitPlane>;

    The %CreateCursor% function creates a cursor that has specified width,
    height, and bit patterns.

    <hInstance>
        Identifies an instance of the module creating the cursor.

    <nXhotspot>
        Specifies the horizontal position of the cursor hotspot.

    <nYhotspot>
        Specifies the vertical position of the cursor hotspot.

    <nWidth>
        Specifies the width in pixels of the cursor.

    <nHeight>
        Specifies the height in pixels of the cursor.

    <lpANDbitPlane>
        Points to an array of bytes containing the bit values for the AND mask
        of the cursor. This can be the bits of a device-dependent monochrome
        bitmap.

    <lpXORbitPlane>
        Points to an array of bytes containing the bit values for the XOR mask
        of the cursor. This can be the bits of a device-dependent monochrome
        bitmap.

    The return value identifies the cursor if the function was successful.
    Otherwise, it is NULL.
--*/

ULONG FASTCALL WU32CreateCursor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PCREATECURSOR16 parg16;
    int     nWidth;
    int     nHeight;
    int     nPlanes;
    int     nBitsPixel;
    DWORD   nBytesAND;
    DWORD   nBytesXOR;
    LPBYTE  lpBitsAND;
    LPBYTE  lpBitsXOR;
    int     ScanLen16;

    HANDLE  h32;
    HAND16  h16;
    HAND16  hInst16;

    GETARGPTR(pFrame, sizeof(CREATECURSOR16), parg16);
    hInst16    = parg16->f1;
    nWidth     = INT32(parg16->f4);
    nHeight    = INT32(parg16->f5);

    nPlanes    = 1;     /* MONOCHROME BITMAP */
    nBitsPixel = 1;     /* MONOCHROME BITMAP */

    /*
    ** Convert the AND mask bits
    */
    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
    nBytesAND = ScanLen16*nHeight*nPlanes;

    GETVDMPTR(parg16->f6, nBytesAND, lpBitsAND);


    /*
    ** Convert the XOR mask bits
    */
    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
    nBytesXOR = ScanLen16*nHeight*nPlanes;

    GETVDMPTR(parg16->f7, nBytesXOR, lpBitsXOR);


    h32 = (HANDLE)CreateCursor(HMODINST32(hInst16),INT32(parg16->f2),
                              INT32(parg16->f3),
                      nWidth, nHeight, lpBitsAND, lpBitsXOR);

    if (h32) {
        h16 = (HAND16)W32Create16BitCursorIcon(hInst16,
                                       INT32(parg16->f2), INT32(parg16->f3),
                                       nWidth, nHeight, nPlanes, nBitsPixel,
                                       lpBitsAND, lpBitsXOR,
                                       nBytesAND, nBytesXOR);

        ul  = SetupCursorIconAlias(hInst16, h32, h16,
                                   HANDLE_TYPE_CURSOR, NULL, (WORD)NULL);
    } else {
        ul = 0;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DestroyCursor(<hCursor>)
    HCURSOR <hCursor>;

    The %DestroyCursor% function destroys a cursor that was previously created
    by the %CreateCursor% function and frees any memory that the cursor
    occupied. It should not be used to destroy any cursor that was not created
    with the %CreateCursor% function.

    <hCursor>
        Identifies the cursor to be destroyed. The cursor must not be in current
        use.

    The return value is TRUE if the function was successful. It is FALSE if
    the function failed.
--*/

ULONG FASTCALL WU32DestroyCursor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDESTROYCURSOR16 parg16;

    GETARGPTR(pFrame, sizeof(DESTROYCURSOR16), parg16);

    if (ul = GETBOOL16(DestroyCursor(HCURSOR32(parg16->f1))))
        FREEHCURSOR16(parg16->f1);

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HCURSOR SetCursor(<hCursor>)
    HCURSOR <hCursor>;

    The %SetCursor% function sets the cursor shape to the shape specified by the
    <hCursor> parameter. The cursor is set only if the new shape is different
    from the current shape. Otherwise, the function returns immediately. The
    %SetCursor% function is quite fast if the cursor identified by the <hCursor>
    parameter is the same as the current cursor.

    If <hCursor> is NULL, the cursor is removed from the screen.

    <hCursor>
        Identifes the cursor resource. The resource must have been loaded
        previously by using the %LoadCursor% function.

    The return value identifies the cursor resource that defines the previous
    cursor shape. It is NULL if there is no previous shape.

    The cursor is a shared resource. A window that uses the cursor should set
    the shape only when the cursor is in its client area or when it is capturing
    all mouse input. In systems without a mouse, the window should restore the
    previous cursor shape before the cursor leaves the client area or before the
    window relinquishes control to another window.

    Any application that needs to change the shape of the cursor while it is in
    a window must make sure the class cursor for the given window's class is set
    to NULL. If the class cursor is not NULL, Windows restores the previous
    shape each time the mouse is moved.
--*/

ULONG FASTCALL WU32SetCursor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETCURSOR16 parg16;

    GETARGPTR(pFrame, sizeof(SETCURSOR16), parg16);

    ul = GETHCURSOR16(SetCursor(
        HCURSOR32(parg16->f1)
    ));


    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void SetCursorPos(<X>, <Y>)
    int <X>;
    int <Y>;

    The %SetCursorPos% function moves the cursor to the screen coordinates given
    by the <X> and <Y> parameters. If the new coordinates are not within the
    screen rectangle set by the most recent %ClipCursor% function, Windows
    automatically adjusts the coordinates so that the cursor stays within the
    rectangle.

    <X>
        Specifies the new x-coordinate (in screen coordinates) of the cursor.

    <Y>
        Specifies the new <y>-coordinate (in screen coordinates) of the
        cursor.

    This function does not return a value.

    The cursor is a shared resource. A window should move the cursor only when
    the cursor is in its client area.
--*/

ULONG FASTCALL WU32SetCursorPos(PVDMFRAME pFrame)
{
    register PSETCURSORPOS16 parg16;

    GETARGPTR(pFrame, sizeof(SETCURSORPOS16), parg16);

    SetCursorPos(
    INT32(parg16->f1),
    INT32(parg16->f2)
    );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    int ShowCursor(<fShow>)
    BOOL <fShow>;

    The %ShowCursor% function shows or hides the cursor. When the %ShowCursor%
    function is called, an internal display counter is incremented by one if the
    <fShow> parameter is TRUE, or decremented by one if the <fShow> parameter is
    FALSE. If the internal display counter is greater then or equal to zero, the
    cursor is displayed. If the counter is less then zero, the cursor is
    hidden. Calls to the %ShowCursor% function are accumulative: for each call
    to hide the cursor, a corresponding call must be made to show the cursor.

    <fShow>
        Specifies whether the display count is to be increased or decreased. The
        display count is increased if fShow is TRUE. Otherwise, it is
        decreased.

    The return value specifies the new display count.

    When Windows is first started, the display count is zero if a mouse is
    installed or -1 if no mouse is installed.

    The cursor is a shared resource. A window that hides the cursor should show
    the cursor before the cursor leaves its client area, or before the window
    relinquishes control to another window.
--*/

ULONG FASTCALL WU32ShowCursor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSHOWCURSOR16 parg16;

    GETARGPTR(pFrame, sizeof(SHOWCURSOR16), parg16);

    ul = GETINT16(ShowCursor(
    BOOL32(parg16->f1)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
// This handles both LoadIcon and LoadCursor
//
//**************************************************************************

ULONG FASTCALL WU32LoadCursor(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSZ psz2;
    LPBYTE pResData = NULL;
    register PLOADCURSOR16 parg16;
    BOOL fIsCursor;
    HAND16 hInst16;
    HAND16 hRes16;

    LPWSTR lpUniName_CursorIcon;

    GETARGPTR(pFrame, sizeof(LOADCURSOR16), parg16);
    GETPSZIDPTR(parg16->f2, psz2);
    GETMISCPTR (parg16->f3, pResData);

    fIsCursor = ((WORD)parg16->f7  == (WORD)RT_CURSOR);
    hInst16 = FETCHWORD(parg16->f1);
    hRes16 = parg16->f5;

    if (HIWORD(psz2) != (WORD) NULL) {
        if (!(MBToWCS(psz2, -1, &lpUniName_CursorIcon, -1, TRUE))) {
            FREEMISCPTR(pResData);
            FREEPSZIDPTR(psz2);
            FREEARGPTR(parg16);
            RETURN(ul);
        }
    }
    else {
        lpUniName_CursorIcon = (LPWSTR)psz2;
    }

    ul = (ULONG) (pfnOut.pfnServerLoadCreateCursorIcon)(HINSTRES32(hInst16),
                                    (LPTSTR) NULL,  // pszModName unused by user32
                                    parg16->f6,
                                    (LPCTSTR) lpUniName_CursorIcon,
                                    parg16->f4,
                                    pResData,
                                    (LPTSTR) parg16->f7,
                                    0);

    if (ul)
        ul = SetupResCursorIconAlias(hInst16, (HAND32)ul,
                                     psz2, hRes16,
                                     fIsCursor ? HANDLE_TYPE_CURSOR : HANDLE_TYPE_ICON);



    if (HIWORD(psz2) != (WORD) NULL) {
        LocalFree (lpUniName_CursorIcon);
    }

    FREEMISCPTR(pResData);
    FREEPSZIDPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wudlg.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUDLG.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wudlg.c);

// SendDlgItemMessage cache
extern HWND  hdlgSDIMCached ;

/*++
    void CheckDlgButton(<hDlg>, <nIDButton>, <wCheck>)
    HWND <hDlg>;
    int <nIDButton>;
    WORD <wCheck>;

    The %CheckDlgButton% function places a checkmark next to or removes a
    checkmark from a button control, or changes the state of a three-state
    button. The %CheckDlgButton% function sends a BM_SETCHECK message to the
    button control that has the specified ID in the given dialog box.

    <hDlg>
        Identifies the dialog box that contains the button.

    <nIDButton>
        Specifies the button control to be modified.

    <wCheck>
        Specifies the action to take. If the <wCheck> parameter is
        nonzero, the %CheckDlgButton% function places a checkmark next to the
        button; if zero, the checkmark is removed. For three-state buttons, if
        <wCheck> is 2, the button is grayed; if <wCheck> is 1, it is checked; if
        <wCheck> is 0, the checkmark is removed.

    This function does not return a value.
--*/

ULONG FASTCALL WU32CheckDlgButton(PVDMFRAME pFrame)
{
    register PCHECKDLGBUTTON16 parg16;

    GETARGPTR(pFrame, sizeof(CHECKDLGBUTTON16), parg16);

    CheckDlgButton(
    HWND32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3)
    );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void CheckRadioButton(<hDlg>, <nIDFirstButton>, <nIDLastButton>,
        <nIDCheckButton>)
    HWND <hDlg>;
    int <nIDFirstButton>;
    int <nIDLastButton>;
    int <nIDCheckButton>;

    The %CheckRadioButton% function checks the radio button specified by the
    <nIDCheckButton> parameter and removes the checkmark from all other radio
    buttons in the group of buttons specified by the <nIDFirstButton> and
    <nIDLastButton> parameters. The %CheckRadioButton% function sends a
    BM_SETCHECK message to the radio-button control that has the specified ID in
    the given dialog box.

    <hDlg>
        Identifies the dialog box.

    <nIDFirstButton>
        Specifies the integer identifier of the first radio button in the
        group.

    <nIDLastButton>
        Specifies the integer identifier of the last radio button in the
        group.

    <nIDCheckButton>
        Specifies the integer identifier of the radio button to be
        checked.

    This function does not return a value.
--*/

ULONG FASTCALL WU32CheckRadioButton(PVDMFRAME pFrame)
{
    register PCHECKRADIOBUTTON16 parg16;

    GETARGPTR(pFrame, sizeof(CHECKRADIOBUTTON16), parg16);

    CheckRadioButton(
    HWND32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3),
    WORD32(parg16->f4)
    );

    FREEARGPTR(parg16);
    RETURN(0);
}

//***************************************************************************
// HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
// HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
// HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
// HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);
//
// int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
// int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
// int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
// int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);
//
// This is a common entry point for all the apis above. We distinguish
// between 'create' and 'dialogbox' apis by a bool flag (parg16->f7).
// TRUE implies 'dialogbox' apis else 'create' apis.
//
//                                                       - nanduri
//***************************************************************************

ULONG FASTCALL WU32DialogBoxParam(PVDMFRAME pFrame)
{
    ULONG    ul=(ULONG)-1;
    PVOID    pDlg;
    DWORD    cb, cb16;
    register PDIALOGBOXPARAM16 parg16;
    BYTE     abT[1024];
    WNDPROC  vpDlgProc = NULL;

    GETARGPTR(pFrame, sizeof(DIALOGBOXPARAM16), parg16);

    if (DWORD32(parg16->f4)) {
        // mark the proc as WOW proc and save the high bits in the RPL
        MarkWOWProc (parg16->f4,vpDlgProc);
    }

    if (!(cb16 = parg16->f6)) {
        cb = ConvertDialog16(NULL, DWORD32(parg16->f2), 0, cb16);
    }
    else {
        // The idea is eliminate a call to ConverDialog16
        //
        // the maximum size that 32bit dlgtemplate would be is twice
        // the 16bit dlgtemplate.
        //
        // this assumption is true cause - we convert most words to dwords
        // and ansi strings to unicode strings - since we know that a
        // DWORD is twice the sizeof a WORD a unicode character is 2bytes
        // therefore maxsize of dlgtemplate cannot exceed cb * 2.
        //
        //                                                      - nanduri

        cb = cb16 * max(sizeof(DWORD) / sizeof(WORD), sizeof(WCHAR)/sizeof(BYTE));
        WOW32ASSERT(cb >= ConvertDialog16(NULL, DWORD32(parg16->f2), 0, cb16));
    }

    pDlg = (cb > sizeof(abT)) ? malloc_w(cb) : (PVOID)abT;
    if (cb && pDlg) {
        cb = ConvertDialog16(pDlg, DWORD32(parg16->f2), cb, cb16);

        if (parg16->f7) {
            ul = GETINT16(DialogBoxIndirectParamAorW(HMODINST32(parg16->f1),
                            pDlg, HWND32(parg16->f3),
                            vpDlgProc,
                            (LPARAM) DWORD32(parg16->f5), SCDLG_ANSI));
        }
        else {
            ul = GETHWND16((pfnOut.pfnServerCreateDialog)(HMODINST32(parg16->f1), (LPDLGTEMPLATE)pDlg,
                            cb,  HWND32(parg16->f3),
                            vpDlgProc,
                            (LPARAM) DWORD32(parg16->f5),  SCDLG_CLIENT | SCDLG_ANSI | SCDLG_NOREVALIDATE));
        }

        if (pDlg != (PVOID)abT) {
            free_w (pDlg);
        }

    }

    // Invalidate SendDlgItemMessage cache
    hdlgSDIMCached = NULL ;

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    int DlgDirList(<hDlg>, <lpPathSpec>, <nIDListBox>, <nIDStaticPath>,
        <wFiletype>)
    HWND <hDlg>;
    LPSTR <lpPathSpec>;
    int <nIDListBox>;
    int <nIDStaticPath>;
    WORD <wFiletype>;

    The %DlgDirList% function fills a list-box control with a file or directory
    listing. It fills the list box specified by the <nIDListBox> parameter with
    the names of all files matching the pathname given by the <lpPathSpec>
    parameter.

    The %DlgDirList% function shows subdirectories enclosed in square brackets
    ([ ]), and shows drives in the form [-<x>-], where <x> is the drive letter.

    The <lpPathSpec> parameter has the following form:

    [drive:] [ [\u]directory[\idirectory]...\u] [filename]

    In this example, <drive> is a drive letter, <directory> is a valid directory
    name, and <filename> is a valid filename that must contain at least one
    wildcard character. The wildcard characters are a question mark (?), meaning
    match any character, and an asterisk (*), meaning match any number of
    characters.

    If the <lpPathSpec> parameter includes a drive and/or directory name, the
    current drive and directory are changed to the designated drive and
    directory before the list box is filled. The text control identified by the
    <nIDStaticPath> parameter is also updated with the new drive and/or
    directory name.

    After the list box is filled, <lpPathSpec> is updated by removing the drive
    and/or directory portion of the pathname.

    %DlgDirList% sends LB_RESETCONTENT and LB_DIR messages to the list box.

    <hDlg>
        Identifies the dialog box that contains the list box.

    <lpPathSpec>
        Points to a pathname string. The string must be a
        null-terminated character string.

    <nIDListBox>
        Specifies the identifier of a list-box control. If <nIDListBox> is
        zero, %DlgDirList% assumes that no list box exists and does not attempt
        to fill it.

    <nIDStaticPath>
        Specifies the identifier of the static-text control used for
        displaying the current drive and directory. If <nIDStaticPath> is zero,
        %DlgDirList% assumes that no such text control is present.

    <wFiletype>
        Specifies the attributes of the files to be displayed. It can be any
        combination of the following values:

    0x0000
        Read/write data files with no additional attributes

    0x0001
        Read-only files

    0x0002
        Hidden files

    0x0004
        System files

    0x0010
        Subdirectories

    0x0020
        Archives

    0x2000
        LB_DIR flag. If the LB_DIR flag is set, Windows places the messages
        generated by %DlgDirList% in the application's queue; otherwise they are
        sent directly to the dialog function.

    0x4000
        Drives

    0x8000
        Exclusive bit. If the exclusive bit is set, only files of the specified
        type are listed. Otherwise, files of the specified type are listed in
        addition to normal files.

    The return value specifies the outcome of the function. It is nonzero if a
    listing was made, even an empty listing. A zero return value implies that
    the input string did not contain a valid search path.

    The <wFiletype> parameter specifies the DOS attributes of the files to be
    listed. Table 4.6 describes these attributes.
--*/

ULONG FASTCALL WU32DlgDirList(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    register PDLGDIRLIST16 parg16;

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    GETARGPTR(pFrame, sizeof(DLGDIRLIST16), parg16);
    GETPSZPTR(parg16->f2, psz2);

    //
    // KidPix passes an invalid filetype flag (0x1000) that Win3.1 doesn't
    // check for.  Win32 does, and fails the API, so mask that flag off here.
    //  John Vert (jvert) 11-Jun-1993
    //

    ul = GETINT16(DlgDirList(
    HWND32(parg16->f1),
    psz2,
    WORD32(parg16->f3),
    WORD32(parg16->f4),
    WORD32(parg16->f5) & DDL_VALID
    ));

    UpdateDosCurrentDirectory(DIR_NT_TO_DOS);

    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    int DlgDirListComboBox(<hDlg>, <lpPathSpec>, <nIDComboBox>, <nIDStaticPath>,
        <wFiletype>)
    HWND <hDlg>;
    LPSTR <lpPathSpec>;
    int <nIDComboBox>;
    int <nIDStaticPath>;
    WORD <wFiletype>;

    The %DlgDirListComboBox% function fills the list box of a combo-box control
    with a file or directory listing. It fills the list box of the combo box
    specified by the <nIDComboBox> parameter with the names of all files
    matching the pathname given by the <lpPathSpec> parameter.

    The %DlgDirListComboBox% function shows subdirectories enclosed in square
    brackets ([ ]), and shows drives in the form [-<x>-], where <x> is the drive
    letter.

    The <lpPathSpec> parameter has the following form:

    [drive:] [ [\u]directory[\idirectory]...\u] [filename]

    In this example, <drive> is a drive letter, <directory> is a valid directory
    name, and <filename> is a valid filename that must contain at least one
    wildcard character. The wildcard characters are a question mark (?), meaning
    match any character, and an asterisk (*), meaning match any number of
    characters.

    If the <lpPathSpec> parameter includes a drive and/or directory name, the
    current drive and directory are changed to the designated drive and
    directory before the list box is filled. The text control identified by the
    <nIDStaticPath> parameter is also updated with the new drive and/or
    directory name.

    After the combo-box list box is filled, <lpPathSpec> is updated by removing
    the drive and/or directory portion of the pathname.

    %DlgDirListComboBox% sends CB_RESETCONTENT and CB_DIR messages to the combo
    box.

    <hDlg>
        Identifies the dialog box that contains the combo box.

    <lpPathSpec>
        Points to a pathname string. The string must be a
        null-terminated string.

    <nIDComboBox>
        Specifies the identifier of a combo-box control in a dialog box.
        If <nIDComboBox> is zero, %DlgDirListComboBox% assumes that no combo box
        exists and does not attempt to fill it.

    <nIDStaticPath>
        Specifies the identifier of the static-text control used for
        displaying the current drive and directory. If <nIDStaticPath> is zero,
        %DlgDirListComboBox% assumes that no such text control is present.

    <wFiletype>
        Specifies DOS file attributes of the files to be displayed. It
        can be any combination of the following values:

    The return value specifies the outcome of the function. It is nonzero if a
    listing was made, even an empty listing. A zero return value implies that
    the input string did not contain a valid search path.
--*/

ULONG FASTCALL WU32DlgDirListComboBox(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    register PDLGDIRLISTCOMBOBOX16 parg16;

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    GETARGPTR(pFrame, sizeof(DLGDIRLISTCOMBOBOX16), parg16);
    GETPSZPTR(parg16->f2, psz2);

    ul = GETINT16(DlgDirListComboBox(
    HWND32(parg16->f1),
    psz2,
    WORD32(parg16->f3),
    WORD32(parg16->f4),
    WORD32(parg16->f5)
    ));

    UpdateDosCurrentDirectory(DIR_NT_TO_DOS);


    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DlgDirSelectEx(<hDlg>, <lpString>, <nIDListBox>)
    HWND <hDlg>;
    LPSTR <lpString>;
    int <nIDListBox>;

    The %DlgDirSelectEx% function retrieves the current selection from a list
    box. It assumes that the list box has been filled by the %DlgDirList%
    function and that the selection is a drive letter, a file, or a directory
    name.

    The %DlgDirSelectEx% function copies the selection to the buffer given by the
    <lpString> parameter. If the current selection is a directory name or drive
    letter, %DlgDirSelectEx% removes the enclosing square brackets (and hyphens,
    for drive letters) so that the name or letter is ready to be inserted into a
    new pathname. If there is no selection, <lpString> does not change.

    %DlgDirSelectEx% sends LB_GETCURSEL and LB_GETTEXT messages to the list box.

    <hDlg>
        Identifies the dialog box that contains the list box.

    <lpString>
        Points to a buffer that is to receive the selected pathname.

    <nIDListBox>
        Specifies the integer ID of a list-box control in the dialog box.

    The return value specifies the status of the current list-box selection. It
    is TRUE if the current selection is a directory name. Otherwise, it is
    FALSE.

    The %DlgDirSelectEx% function does not allow more than one filename to be
    returned from a list box.

    The list box must not be a multiple-selection list box. If it is, this
    function will not return a zero value and <lpString> will remain unchanged.
--*/

ULONG FASTCALL WU32DlgDirSelect(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    VPVOID vp;
    register PDLGDIRSELECT16 parg16;

    GETARGPTR(pFrame, sizeof(DLGDIRSELECT16), parg16);
    ALLOCVDMPTR(parg16->f2, MAX_VDMFILENAME, psz2);
    vp = parg16->f2;

    ul = GETBOOL16(DlgDirSelectEx(
    HWND32(parg16->f1),
    psz2,
    SIZE_BOGUS, 
    WORD32(parg16->f3)
    ));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, strlen(psz2)+1, psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DlgDirSelectComboBoxEx(<hDlg>, <lpString>, <nIDComboBox>)
    HWND <hDlg>;
    LPSTR <lpString>;
    int <nIDComboBox>;

    The %DlgDirSelectComboBoxEx% function retrieves the current selection from the
    list box of a combo box created with the CBS_SIMPLE style. It cannot be used
    with combo boxes created with either the CBS_DROPDOWN or CBS_DROPDOWNLIST
    style. It assumes that the list box has been filled by the
    %DlgDirListComboBox% function and that the selection is a drive letter, a
    file, or a directory name.

    The %DlgDirSelectComboBoxEx% function copies the selection to the buffer given
    by the <lpString> parameter. If the current selection is a directory name or
    drive letter, %DlgDirSelectComboBoxEx% removes the enclosing square brackets
    (and hyphens, for drive letters) so that the name or letter is ready to be
    inserted into a new pathname. If there is no selection, <lpString> does not
    change.

    %DlgDirSelectComboBoxEx% sends CB_GETCURSEL and CB_GETLBTEXT messages to the
    combo box.

    <hDlg>
        Identifies the dialog box that contains the combo box.

    <lpString>
        Points to a buffer that is to receive the selected pathname.

    <nIDComboBox>
        Specifies the integer ID of the combo-box control in the dialog
        box.

    The return value specifies the status of the current combo-box selection. It
    is TRUE if the current selection is a directory name. Otherwise, it is
    FALSE.

    The %DlgDirSelectComboBoxEx% function does not allow more than one filename to
    be returned from a combo box.
--*/

ULONG FASTCALL WU32DlgDirSelectComboBox(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    VPVOID vp;
    register PDLGDIRSELECTCOMBOBOX16 parg16;

    GETARGPTR(pFrame, sizeof(DLGDIRSELECTCOMBOBOX16), parg16);
    ALLOCVDMPTR(parg16->f2, MAX_VDMFILENAME, psz2);
    vp = parg16->f2;

    ul = GETBOOL16(DlgDirSelectComboBoxEx(
    HWND32(parg16->f1),
    psz2,
    SIZE_BOGUS,
    WORD32(parg16->f3)
    ));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, strlen(psz2)+1, psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void EndDialog(<hDlg>, <nResult>)
    HWND <hDlg>;
    int <nResult>;

    The %EndDialog% function terminates a modal dialog box and returns the given
    result to the %DialogBox% function that created the dialog box. The
    %EndDialog% function is required to complete processing whenever the
    %DialogBox% function is used to create a modal dialog box. The function must
    be used in the dialog function of the modal dialog box and should not be
    used for any other purpose.

    The dialog function can call %EndDialog% at any time, even during the
    processing of the WM_INITDIALOG message. If called during the WM_INITDIALOG
    message, the dialog box is terminated before it is shown or before the input
    focus is set.

    %EndDialog% does not terminate the dialog box immediately. Instead, it sets
    a flag that directs the dialog box to terminate as soon as the dialog
    function ends. The %EndDialog% function returns to the dialog function, so
    the dialog function must return control to Windows.

    <hDlg>
        Identifies the dialog box to be destroyed.

    <nResult>
        Specifies the value to be returned from the dialog box to the
        %DialogBox% function that created it.

    This function does not return a value.
--*/

ULONG FASTCALL WU32EndDialog(PVDMFRAME pFrame)
{
    HWND     hwnd;
    register PENDDIALOG16 parg16;   
 
    GETARGPTR(pFrame, sizeof(ENDDIALOG16), parg16);

    hwnd = HWND32(parg16->f1);

    if(!EndDialog(hwnd, INT32(parg16->f2)) && IsWindow(hwnd)){
       CHAR szType[8];
       if(GetLastError() == ERROR_WINDOW_NOT_DIALOG ||
         (RealGetWindowClass(hwnd,szType,8) && WOW32_strnicmp(szType,"#32770",6))) {
          // jarbats
          // App is trying to close window created by CreateWindow
          // via EndDialog! whistler bug #231059

          DestroyWindow(hwnd);
       }
    }
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    LONG GetDialogBaseUnits(VOID)

    The %GetDialogBaseUnits% function returns the dialog base units used by
    Windows when creating dialog boxes. An application should use these values
    to calculate the average width of characters in the system font.

    This function has no parameters.

    The return value specifies the dialog base units. The high-order word
    contains the height in pixels of the current dialog base height unit derived
    from the height of the system font, and the low-order word contains the
    width in pixels of the current dialog base width unit derived from the width
    of the system font.

    The values returned represent dialog base units before being scaled to
    actual dialog units. The actual dialog unit in the <x> direction is
    1/4th of the width returned by %GetDialogBaseUnits%. The actual dialog
    unit in the <y> direction is 1/8th of the height returned by the
    function.

    To determine the actual height and width in pixels of a control, given the
    height (x) and width (y) in dialog units and the return value
    (lDlgBaseUnits) from calling %GetDialogBaseUnits%, use the following
    formula:

    (x * LOWORD(lDlgBaseUnits))/4
    (y * HIWORD(lDlgBaseUnits))/8

    To avoid rounding problems, perform the multiplication before the division
    in case the dialog base units are not evenly divisible by four.
--*/

ULONG FASTCALL WU32GetDialogBaseUnits(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETLONG16(GetDialogBaseUnits());

    RETURN(ul);
}


/*++
    int GetDlgCtrlID(<hwnd>)
    HWND <hwnd>;

    The %GetDlgCtrlID% function returns the ID value of the child window
    identified by the <hwnd> parameter.

    <hwnd>
        Identifies the child window.

    The return value is the numeric identifier of the child window if the
    function is successful. If the function fails, or if <hwnd> is not a valid
    window handle, the return value is NULL.

    Since top-level windows do not have an ID value, the return value of this
    function is invalid if the <hwnd> parameter identifies a top-level window.
--*/

ULONG FASTCALL WU32GetDlgCtrlID(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDLGCTRLID16 parg16;

    GETARGPTR(pFrame, sizeof(GETDLGCTRLID16), parg16);

    ul = GETINT16(GetDlgCtrlID(
    HWND32(parg16->f1)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD GetDlgItemInt(<hDlg>, <nIDDlgItem>, <lpTranslated>, <bSigned>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    BOOL FAR *<lpTranslated>;
    BOOL <bSigned>;

    The %GetDlgItemInt% function translates the text of a control in the given
    dialog box into an integer value. The %GetDlgItemInt% function retrieves the
    text of the control identified by the <nIDDlgItem> parameter. It translates
    the text by stripping any extra spaces at the beginning of the text and
    converting decimal digits, stopping the translation when it reaches the end
    of the text or encounters any nonnumeric character. If the <bSigned>
    parameter is TRUE, %GetDlgItemInt% checks for a minus sign (-) at the
    beginning of the text and translates the text into a signed number.
    Otherwise, it creates an unsigned value.

    %GetDlgItemInt% returns zero if the translated number is greater than 32,767
    (for signed numbers) or 65,535 (for unsigned). When errors occur, such as
    encountering nonnumeric characters and exceeding the given maximum,
    %GetDlgItemInt% copies zero to the location pointed to by the <lpTranslated>
    parameter. If there are no errors, <lpTranslated> receives a nonzero value.
    If <lpTranslated> is NULL, %GetDlgItemInt% does not warn about errors.
    %GetDlgItemInt% sends a WM_GETTEXT message to the control.

    <hDlg>
        Identifies the dialog box.

    <nIDDlgItem>
        Specifies the integer identifier of the dialog-box item to be
        translated.

    <lpTranslated>
        Points to the Boolean variable that is to receive the
        translated flag.

    <bSigned>
        Specifies whether the value to be retrieved is signed.

    The return value specifies the translated value of the dialog-box item text.
    Since zero is a valid return value, the <lpTranslated> parameter must be
    used to detect errors. If a signed return value is desired, it should be
    cast as an %int% type.
--*/

ULONG FASTCALL WU32GetDlgItemInt(PVDMFRAME pFrame)
{
    ULONG ul;
    BOOL t3;
    register PGETDLGITEMINT16 parg16;

    GETARGPTR(pFrame, sizeof(GETDLGITEMINT16), parg16);

    ul = GETWORD16(GetDlgItemInt(
    HWND32(parg16->f1),
    WORD32(parg16->f2),     // see comment in wu32getdlgitem
    &t3,
    BOOL32(parg16->f4)
    ));

    PUTBOOL16(parg16->f3, t3);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    int GetDlgItemText(<hDlg>, <nIDDlgItem>, <lpString>, <nMaxCount>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    LPSTR <lpString>;
    int <nMaxCount>;

    The %GetDlgItemText% function retrieves the caption or text associated with
    a control in a dialog box. The %GetDlgItemText% function copies the text to
    the location pointed to by the <lpString> parameter and returns a count of
    the number of characters it copies.

    %GetDlgItemText% sends a WM_GETTEXT message to the control.

    <hDlg>
        Identifies the dialog box that contains the control.

    <nIDDlgItem>
        Specifies the integer identifier of the dialog-box item whose
        caption or text is to be retrieved.

    <lpString>
        Points to the buffer to receive the text.

    <nMaxCount>
        Specifies the maximum length (in bytes) of the string to be copied
        to <lpString>. If the string is longer than <nMaxCount>, it is
        truncated.

    The return value specifies the actual number of characters copied to the
    buffer. It is zero if no text is copied.
--*/

ULONG FASTCALL WU32GetDlgItemText(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz3;
    VPVOID vp;
    register PGETDLGITEMTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(GETDLGITEMTEXT16), parg16);
    ALLOCVDMPTR(parg16->f3, parg16->f4, psz3);
    vp = parg16->f3;

    ul = GETINT16(GetDlgItemText(
    HWND32(parg16->f1),
    WORD32(parg16->f2), // see comment in wu32getdlgitem
    psz3,
    WORD32(parg16->f4)
    ));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f3, strlen(psz3)+1, psz3);
    FREEVDMPTR(psz3);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND GetNextDlgGroupItem(<hDlg>, <hCtl>, <bPrevious>)
    HWND <hDlg>;
    HWND <hCtl>;
    BOOL <bPrevious>;

    The %GetNextDlgGroupItem% function searches for the next (or previous)
    control within a group of controls in the dialog box identified by the
    <hDlg> parameter. A group of controls consists of one or more controls with
    WS_GROUP style.

    <hDlg>
        Identifies the dialog box being searched.

    <hCtl>
        Identifies the control in the dialog box where the search starts.

    <bPrevious>
        Specifies how the function is to search the group of controls in the
        dialog box. If the <bPrevious> parameter is zero, the function searches
        for the previous control in the group. If -<bPrevious> is TRUE, the
        function searches for the next control in the group.

    The return value identifies the next or previous control in the group.

    If the current item is the last item in the group and <bPrevious> is FALSE,
    the %GetNextDlgGroupItem% function returns the window handle of the first
    item in the group. If the current item is the first item in the group and
    <bPrevious> is TRUE, %GetNextDlgGroupItem% returns the window handle of the
    last item in the group.
--*/

ULONG FASTCALL WU32GetNextDlgGroupItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETNEXTDLGGROUPITEM16 parg16;

    GETARGPTR(pFrame, sizeof(GETNEXTDLGGROUPITEM16), parg16);

    ul = GETHWND16(GetNextDlgGroupItem(HWND32(parg16->f1),
                                       HWND32(parg16->f2),
                                       BOOL32(parg16->f3)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND GetNextDlgTabItem(<hDlg>, <hCtl>, <bPrevious>)
    HWND <hDlg>;
    HWND <hCtl>;
    BOOL <bPrevious>;

    The %GetNextDlgTabItem% function obtains the handle of the first control
    that has the WS_TABSTOP style that precedes (or follows) the control
    identified by the <hCtl> parameter.

    <hDlg>
        Identifies the dialog box being searched.

    <hCtl>
        Identifies the control to be used as a starting point for the
        search.

    <bPrevious>
        Specifies how the function is to search the dialog box. If the
        <bPrevious> parameter is FALSE, the function searches for the previous
        control in the dialog box. If <bPrevious> is TRUE, the function searches
        for the next control in the dialog box. Identifies the control to be
        used as a starting point for the search.

    The return value identifies the previous (or next) control that has the
    WS_TABSTOP style set.
--*/

ULONG FASTCALL WU32GetNextDlgTabItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETNEXTDLGTABITEM16 parg16;

    GETARGPTR(pFrame, sizeof(GETNEXTDLGTABITEM16), parg16);

    ul = GETHWND16(GetNextDlgTabItem(HWND32(parg16->f1),
                                     HWND32(parg16->f2),
                                     BOOL32(parg16->f3)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL IsDialogMessage(<hDlg>, <lpMsg>)
    HWND <hDlg>;
    LPMSG <lpMsg>;

    The %IsDialogMessage% function determines whether the given message is
    intended for the modeless dialog box specified by the <hDlg> parameter, and
    automatically processes the message if it is. When the %IsDialogMessage%
    function processes a message, it checks for keyboard messages and converts
    them into selection commands for the corresponding dialog box. For example,
    the ^TAB^ key selects the next control or group of controls, and the ^DOWN^
    key selects the next control in a group.

    If a message is processed by %IsDialogMessage%, it must not be passed to the
    %TranslateMessage% or %DispatchMessage% function. This is because
    %IsDialogMessage% performs all necessary translating and dispatching of
    messages.

    %IsDialogMessage% sends WM_GETDLGCODE messages to the dialog function to
    determine which keys should be processed.

    <hDlg>
        Identifies the dialog box.

    <lpMsg>
        Points to an %MSG% structure that contains the message to
        be checked.

    The return value specifies whether or not the given message has been
    processed. It is TRUE if the message has been processed. Otherwise, it is
    FALSE.

    Although %IsDialogMessage% is intended for modeless dialog boxes, it can be
    used with any window that contains controls to provide the same keyboard
    selection as in a dialog box.
--*/

ULONG FASTCALL WU32IsDialogMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t2;
    register PISDIALOGMESSAGE16 parg16;
    MSGPARAMEX mpex;
    PMSG16 pMsg16;

    GETARGPTR(pFrame, sizeof(ISDIALOGMESSAGE16), parg16);
    GETMISCPTR(parg16->f2, pMsg16);

    mpex.Parm16.WndProc.hwnd = pMsg16->hwnd;
    mpex.Parm16.WndProc.wMsg = pMsg16->message;
    mpex.Parm16.WndProc.wParam = pMsg16->wParam;
    mpex.Parm16.WndProc.lParam = pMsg16->lParam;
    mpex.iMsgThunkClass = WOWCLASS_WIN16;

    ThunkMsg16(&mpex);

    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(ISDIALOGMESSAGE16), parg16);

    t2.message   = mpex.uMsg;
    t2.wParam    = mpex.uParam;
    t2.lParam    = mpex.lParam;
    t2.hwnd      = HWND32(FETCHWORD(pMsg16->hwnd));
    t2.time      = FETCHLONG(pMsg16->time);
    t2.pt.x      = FETCHSHORT(pMsg16->pt.x);
    t2.pt.y      = FETCHSHORT(pMsg16->pt.y);

    ul = GETBOOL16(IsDialogMessage(
    HWND32(parg16->f1),
    &t2
    ));

    if (MSG16NEEDSTHUNKING(&mpex)) {
        mpex.uMsg   = t2.message;
        mpex.uParam = t2.wParam;
        mpex.lParam = t2.lParam;
        (mpex.lpfnUnThunk16)(&mpex);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD IsDlgButtonChecked(<hDlg>, <nIDButton>)
    HWND <hDlg>;
    int <nIDButton>;

    The %IsDlgButtonChecked% function determines whether a button control has a
    checkmark next to it, and whether a three-state button control is grayed,
    checked, or neither. The %IsDlgButtonChecked% function sends a BM_GETCHECK
    message to the button control.

    <hDlg>
        Identifies the dialog box that contains the button control.

    <nIDButton>
        Specifies the integer identifier of the button control.

    The return value specifies the outcome of the function. It is nonzero if the
    given control has a checkmark next to it. Otherwise, it is zero. For
    three-state buttons, the return value is 2 if the button is grayed, 1 if the
    button has a checkmark next to it, and zero otherwise.
--*/

ULONG FASTCALL WU32IsDlgButtonChecked(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISDLGBUTTONCHECKED16 parg16;

    GETARGPTR(pFrame, sizeof(ISDLGBUTTONCHECKED16), parg16);

    ul = GETWORD16(IsDlgButtonChecked(
    HWND32(parg16->f1),
    WORD32(parg16->f2)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void MapDialogRect(<hDlg>, <lpRect>)
    HDLG <hDlg>;
    LPRECT <lpRect>;

    The %MapDialogRect% function converts the dialog-box units given in the
    <lpRect> parameter to screen units. Dialog-box units are stated in terms of
    the current dialog base unit derived from the average width and height of
    characters in the system font. One horizontal unit is one-fourth of the
    dialog base width unit, and one vertical unit is one-eighth of the dialog
    base height unit. The %GetDialogBaseUnits% function returns the dialog base
    units in pixels.

    The %MapDialogRect% function replaces the dialog-box units in <lpRect> with
    screen units (pixels), so that the rectangle can be used to create a dialog
    box or position a control within a box.

    <hDlg>
        Identifies a dialog box.

    <lpRect>
        Points to a %RECT% structure that contains the dialog-box
        coordinates to be converted.

    This function does not return a value.

    The <hDlg> parameter must be created by using the %CreateDialog% or
    %DialogBox% function.
--*/

ULONG FASTCALL WU32MapDialogRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PMAPDIALOGRECT16 parg16;

    GETARGPTR(pFrame, sizeof(MAPDIALOGRECT16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    MapDialogRect(
        HWND32(parg16->f1),
        &t2
        );

    PUTRECT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    int MessageBox(<hwndParent>, <lpText>, <lpCaption>, <wType>)
    HWND <hwndParent>;
    LPSTR <lpText>;
    LPSTR <lpCaption>;
    WORD <wType>;

    The %MessageBox% function creates and displays a window that contains an
    application-supplied message and caption, plus any combination of the
    predefined icons and push buttons described in the following list.

    <hwndParent>
        Identifies the window that owns the message box.

    <lpText>
        Points to a null-terminated string containing the message to be
        displayed.

    <lpCaption>
        Points to a null-terminated string to be used for the dialog-box
        caption. If the <lpCaption> parameter is NULL, the default caption Error
        is used.

    <wType>
        Specifies the contents of the dialog box. It can be any
        combination of the following values:

    MB_ABORTRETRYIGNORE
        Message box contains three push buttons: Abort, Retry, and Ignore.

    MB_APPLMODAL
        The user must respond to the message box before continuing work in the
        window identified by the <hwndParent> parameter. However, the user can
        move to the windows of other applications and work in those windows.
        MB_APPLMODAL is the default if neither MB_SYSTEMMODAL nor MB_TASKMODAL
        are specified.

    MB_DEFBUTTON1
        First button is the default. Note that the first button is always the
        default unless MB_DEFBUTTON2 or MB_DEFBUTTON3 is specified.

    MB_DEFBUTTON2
        Second button is the default.

    MB_DEFBUTTON3
        Third button is the default.

    MB_ICONASTERISK
        Same as MB_ICONINFORMATION.

    MB_ICONEXCLAMATION
        An exclamation-point icon appears in the message box.

    MB_ICONHAND
        Same as MB_ICONSTOP.

    MB_ICONINFORMATION
        An icon consisting of a lowercase i in a circle appears in the message
        box.

    MB_ICONQUESTION
        A question-mark icon appears in the message box.

    MB_ICONSTOP
        A stop sign icon appears in the message box.

    MB_OK
        Message box contains one push button: OK.

    MB_OKCANCEL
        Message box contains two push buttons: OK and Cancel.

    MB_RETRYCANCEL
        Message box contains two push buttons: Retry and Cancel.

    MB_SYSTEMMODAL
        All applications are suspended until the user responds to the message
        box. Unless the application specifies MB_ICONHAND, the message box does
        not become modal until after it is created; consequently, the parent
        window and other windows continue to receive messages resulting from its
        activation. System-modal message boxes are used to notify the user of
        serious, potentially damaging errors that require immediate attention
        (for example, running out of memory).

    MB_TASKMODAL
        Same as MB_APPMODAL except that all the top-level windows belonging to
        the current task are disabled if the <hwndOwner> parameter is NULL. This
        flag should be used when the calling application or library does not
        have a window handle available, but still needs to prevent input to
        other windows in the current application without suspending other
        applications.

    MB_YESNO
        Message box contains two push buttons: Yes and No.

    MB_YESNOCANCEL
        Message box contains three push buttons: Yes, No, and Cancel.

    The return value specifies the outcome of the function. It is zero if there
    is not enough memory to create the message box. Otherwise, it is one of the
    following menu-item values returned by the dialog box:

    IDABORT   Abort button pressed.
    IDCANCEL  Cancel button pressed.
    IDIGNORE  Ignore button pressed.
    IDNO      No button pressed.
    IDOK      OK button pressed.
    IDRETRY   Retry button pressed.
    IDYES     Yes button pressed.

    If a message box has a Cancel button, the IDCANCEL value will be returned if
    either the ^ESCAPE^ key or Cancel button is pressed. If the message box has
    no Cancel button, pressing the ^ESCAPE^ key has no effect.

    When a system-modal message box is created to indicate that the system is
    low on memory, the strings passed as the <lpText> and <lpCaption> parameters
    should not be taken from a resource file, since an attempt to load the
    resource may fail.

    When an application calls the %MessageBox% function and specifies the
    MB_ICONHAND and MB_SYSTEMMODAL flags for the <wType> parameter, Windows will
    display the resulting message box regardless of available memory. When these
    flags are specified, Windows limits the length of the message-box text to
    one line.

    If a message box is created while a dialog box is present, use the handle of
    the dialog box as the <hwndParent> parameter. The <hwndParent> parameter
    should not identify a child window, such as a dialog-box control.
--*/

ULONG FASTCALL WU32MessageBox(PVDMFRAME pFrame)
{
    ULONG ul;
    UINT uType;
    PSZ psz2;
    PSZ psz3;
    register PMESSAGEBOX16 parg16;

    GETARGPTR(pFrame, sizeof(MESSAGEBOX16), parg16);
    GETPSZPTR(parg16->f2, psz2);
    GETPSZPTR(parg16->f3, psz3);
    
    // WHISTLER RAID BUG #348251
    // A messagebox posted by artgalry.exe would remain behind autosketches window
    // after it was invoked. In order to move the messagebox to the foreground we
    // need to set its MB_SETFOREGROUND bit. Since this will be applied to all 
    // 16bit MessageBox's we will only set this bit if the MessageBox does not 
    // have the MB_NOFOCUS bit. This fix works in conjunction with the 
    // GACF2_GIVEUPFOREGROUND compat flag. 
    uType = (UINT)parg16->f4;
    if(!(uType & MB_NOFOCUS))
    {
        uType |= MB_SETFOREGROUND;
    }
    
    ul = GETINT16(MessageBox(
    HWND32(parg16->f1),
    psz2,
    psz3,
    uType
    ));

    FREEPSZPTR(psz2);
    FREEPSZPTR(psz3);
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    void SetDlgItemInt(<hDlg>, <nIDDlgItem>, <wValue>, <bSigned>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    WORD <wValue>;
    BOOL <bSigned>;

    The %SetDlgItemInt% function sets the text of a control in the given dialog
    box to the string that represents the integer value given by the <wValue>
    parameter. The %SetDlgItemInt% function converts <wValue> to a string that
    consists of decimal digits, and then copies the string to the control. If
    the <bSigned> parameter is TRUE, <wValue> is assumed to be signed. If
    <wValue> is signed and less than zero, the function places a minus sign
    before the first digit in the string.

    %SetDlgItemInt% sends a WM_SETTEXT message to the given control.

    <hDlg>
        Identifies the dialog box that contains the control.

    <nIDDlgItem>
        Specifies the control to be modified.

    <wValue>
        Specifies the value to be set.

    <bSigned>
        Specifies whether or not the integer value is signed.

    This function does not return a value.
--*/

ULONG FASTCALL WU32SetDlgItemInt(PVDMFRAME pFrame)
{
    HWND     hwnd;
    register PSETDLGITEMINT16 parg16;

    GETARGPTR(pFrame, sizeof(SETDLGITEMINT16), parg16);

    hwnd = HWND32(parg16->f1);

    SetDlgItemInt(
        hwnd,
        WORD32(parg16->f2),         // see comment in wu32getdlgitem
        (parg16->f4) ? INT32(parg16->f3) : WORD32(parg16->f3),
        BOOL32(parg16->f4)
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void SetDlgItemText(<hDlg>, <nIDDlgItem>, <lpString>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    LPSTR <lpString>;

    The %SetDlgItemText% function sets the caption or text of a control in the
    dialog box specified by the <hDlg> parameter. The %SetDlgItemText% function
    sends a WM_SETTEXT message to the given control.

    <hDlg>
        Identifies the dialog box that contains the control.

    <nIDDlgItem>
        Specifies the control whose text is to be set.

    <lpString>
        Points to the null-terminated string that is to be copied to the
        control.

    This function does not return a value.
--*/

ULONG FASTCALL WU32SetDlgItemText(PVDMFRAME pFrame)
{
    HWND hwnd;
    PSZ psz3;
    register PSETDLGITEMTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(SETDLGITEMTEXT16), parg16);
    GETPSZPTR(parg16->f3, psz3);

    hwnd = HWND32(parg16->f1);

    if (NULL != psz3) {
        AddParamMap((DWORD)psz3, FETCHDWORD(parg16->f3));
    }

    SetDlgItemText(
    hwnd,
    WORD32(parg16->f2),     // see comment in wu32getdlgitem
    psz3
    );

    if (NULL != psz3) {
        DeleteParamMap((DWORD)psz3, PARAM_32, NULL);
    }


    FREEPSZPTR(psz3);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    No REF header file
--*/

ULONG FASTCALL WU32SysErrorBox(PVDMFRAME pFrame)
{
    DWORD dwExitCode;
    PSZ pszText;
    PSZ pszCaption;
    register PSYSERRORBOX16 parg16;

    GETARGPTR(pFrame, sizeof(SYSERRORBOX16), parg16);

    // WARNING - If things go wrong during boot, this routine can be called in
    // real mode (v86 mode).   So be very careful which GetPtr routines you
    // use to convert from 16:16 to flat pointers

    pszText = WOWGetVDMPointer(FETCHDWORD(parg16->vpszText),0,fWowMode);
    pszCaption = WOWGetVDMPointer(FETCHDWORD(parg16->vpszCaption),0,fWowMode);

    LOGDEBUG(5,("    SYSERRORBOX: %s\n", pszText));

    dwExitCode = WOWSysErrorBox(
                     pszCaption,
                     pszText,
                     parg16->sBtn1,
                     parg16->sBtn2,
                     parg16->sBtn3
                     );

    FREEPSZPTR(pszCaption);
    FREEPSZPTR(pszText);
    FREEARGPTR(parg16);
    RETURN(dwExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wudlg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUDLG.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



/* Function prototypes
 */

ULONG FASTCALL   WU32CheckDlgButton(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CheckRadioButton(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DialogBoxParam(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DlgDirList(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DlgDirListComboBox(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DlgDirSelect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DlgDirSelectComboBox(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EndDialog(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDialogBaseUnits(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDlgCtrlID(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDlgItem(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDlgItemInt(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDlgItemText(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetNextDlgGroupItem(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetNextDlgTabItem(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsDialogMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsDlgButtonChecked(PVDMFRAME pFrame);
ULONG FASTCALL   WU32MapDialogRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32MessageBox(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetDlgItemInt(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetDlgItemText(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SysErrorBox(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuhook.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUHOOK.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wuhook.c);


/*++
    FARPROC SetWindowsHook(<nFilterType>, <lpFilterFunc>)
    int <nFilterType>;
    FARPROC <lpFilterFunc>;

    The %SetWindowsHook% function installs a filter function in a chain. A
    filter function processes events before they are sent to an application's
    message loop in the WinMain function. A chain is a linked list of filter
    functions of the same type.

    <nFilterType>
        Specifies the system hook to be installed. It can be any one of the
        following values:

    WH_CALLWNDPROC      Installs a window-function filter.
    WH_GETMESSAGE       Installs a message filter.
    WH_JOURNALPLAYBACK  Installs a journaling playback filter.
    WH_JOURNALRECORD    Installs a journaling record filter.
    WH_KEYBOARD         Installs a keyboard filter.
    WH_MSGFILTER        Installs a message filter.
    WH_SYSMSGFILTER     Installs a system-wide message filter.

    <lpFilterFunc>
        Is the procedure-instance address of the filter function to be
        installed. See the following Comments section for details.

    The return value points to the procedure-instance address of the previously
    installed filter (if any). It is NULL if there is no previous filter. The
    application or library that calls the %SetWindowsHook% function should save
    this return value in the library's data segment. The fourth argument of the
    %DefHookProc% function points to the location in memory where the library
    saves this return value.

    The return value is -1 if the function fails.

    The WH_CALLWNDPROC hook will affect system performance. It is supplied for
    debugging purposes only.

    The system hooks are a shared resource. Installing a hook affects all
    applications. Most hook functions must be in libraries. The only exception
    is WH_MSGFILTER, which is task-specific. System hooks should be restricted
    to special-purpose applications or as a development aid during debugging of
    an application. Libraries that no longer need the hook should remove the
    filter function.

    To install a filter function, the %SetWindowsHook% function must receive a
    procedure-instance address of the function, and the function must be
    exported in the library's module-definition file. Libraries can pass the
    procedure address directly. Tasks must use %MakeProcInstance% to get a
    procedure-instance address. Dynamic-link libraries must use %GetProcAddress%
    to get a procedure-instance address.

    The following section describes how to support the individual hook
    functions.

    WH_CALLWNDPROC:

    Windows calls the WH_CALLWNDPROC filter function whenever the %SendMessage%
    function is called. Windows does not call the filter function when the
    %PostMessage% function is called.

    The filter function must use the Pascal calling convention and must be
    declared %FAR%. The filter function must have the following form:

    Filter Function:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the application- or library-supplied
    function name. The actual name must be exported by including it in an
    %EXPORTS% statement in the library's module-definition file.

    <nCode>
        Specifies whether the filter function should process the message or call
        the DefHookProc function. If the nCode parameter is less than zero, the
        filter function should pass the message to DefHookProc without further
        processing. <wParam> Specifies whether the message is sent by the
        current task. It is nonzero if the message is sent; otherwise, it is
        NULL.

    <lParam>
        Points to a structure that contains details about the message
        intercepted by the filter. The following shows the order, type, and
        description of each field of the structure:

    %lParam%
        %WORD% Contains the low-order word of the <lParam> parameter of the
        message received by the filter.

    %wParam%
        %WORD% Contains the <wParam> parameter of the message received by the
        filter.

    %wMsg%
        %WORD% Contains the message received by the filter.

    %hwnd%
        %WORD% Contains the window handle of the window that is to receive the
        message.

    The WH_CALLWNDPROC filter function can examine or modify the message as
    desired. Once it returns control to Windows, the message, with any
    modifications, is passed on to the window function. The filter function does
    not require a return value.

    WH_GETMESSAGE:

    Windows calls the WH_GETMESSAGE filter function whenever the %GetMessage%
    function is called. Windows calls the filter function immediately after
    %GetMessage% has retrieved a message from an application queue. The filter
    function must use the Pascal calling convention and must be declared %FAR%.
    The filter function must have the following form:

    Filter Function:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the library-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the library's module-definition file.

    <nCode>
        Specifies whether the filter function should process the message or call
        the DefHookProc function. If the <nCode> parameter is less than zero, the
        filter function should pass the message to DefHookProc without further
        processing.

    <wParam>
        Specifies a NULL value.

    <lParam>
        Points to a message structure.

    The WH_GETMESSAGE filter function can examine or modify the message as
    desired. Once it returns control to Windows, the %GetMessage% function
    returns the message, with any modifications, to the application that
    originally called it. The filter function does not require a return value.

    WH_JOURNALPLAYBACK:

    Windows calls the WH_JOURNALPLAYBACK filter function whenever a request for
    an event message is made. The function is intended to be used to supply a
    previously recorded event message.

    The filter function must use the Pascal calling convention and must be
    declared %FAR%. The filter function must have the following form:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the library-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the library's module-definition file.

    <nCode>
        Specifies whether the filter function should process the message or call
        the DefHookProc function. If the nCode parameter is less then zero, the
        filter function should pass the message to DefHookProc without further
        processing.

    <wParam>
        Specifies a NULL value.

    <lParam>
        Points to the message being processed by the filter function.

    The WH_JOURNALPLAYBACK function should copy an event message to the <lParam>
    parameter. The message must have been previously recorded by using the
    WH_JOURNALRECORD filter. It should not modify the message. The return value
    should be the amount of time (in clock ticks) Windows should wait before
    processing the message. This time can be computed by calculating the
    difference between the %time% fields in the current and previous event
    messages. If the function returns zero, the message is processed
    immediately. Once it returns control to Windows, the message continues to be
    processed. If the <nCode> parameter is HC_SKIP, the filter function should
    prepare to return the next recorded event message on its next call.

    While the WH_JOURNALPLAYBACK function is in effect, Windows ignores all
    mouse and keyboard input.

    WH_JOURNALRECORD:

    Windows calls the WH_JOURNALRECORD filter function whenever it processes a
    message from the event queue. The filter can be used to record the event for
    later playback.

    The filter function must use the Pascal calling convention and must be
    declared %FAR%. The filter function must have the following form:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>,<lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the library-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the library's module-definition file.

    <nCode>
        Specifies whether the filter function should process the message or call
        the DefHookProc function. If the nCode parameter is less than zero, the
        filter function should pass the message to DefHookProc without further
        processing.

    <wParam>
        Specifies a NULL value.

    <lParam>
        Points to a message structure.

    The WH_JOURNALRECORD function should save a copy of the event message for
    later playback. It should not modify the message. Once it returns control to
    Windows, the message continues to be processed. The filter function does not
    require a return value.

    WH_KEYBOARD:

    Windows calls the WH_KEYBOARD filter function whenever the application calls
    the %GetMessage% or %PeekMessage% function and there is a keyboard event
    (WM_KEYUP or WM_KEYDOWN) to process.

    The filter function must use the Pascal calling convention and must be
    declared %FAR%. The filter function must have the following form:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>; DWORD <lParam>;

    <FilterFunc> is a placeholder for the library-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the library's module-definition file.

    <nCode>
        Specifies whether the filter function should process the message or call
        the DefHookProc function. If this value is HC_NOREMOVE, the application
        is using the PeekMessage function with the PM_NOREMOVE option and the
        message will not be removed from the system queue. If this value is less
        than zero, the filter function should pass the message to DefHookProc
        without further processing.

    <wParam>
        Specifies the virtual-key code of the given key.

    <lParam>
        Specifies the repeat count, scan code, key-transition code, previous key
        state, and context code, as shown in the following list. Bit 1 is the
        low-order bit:

    0-15
        (low-order word) Repeat count (the number of times the keystroke is
        repeated as a result of the user holding down the key).

    16-23
        (low byte of high-order word) Scan code (OEM-dependent value).

    24
        Extended key (1 if it is an extended key).

    25-26
        Not used.

    27-28
        (Context code (1 if the ^ALT^ key was held down while the key was
        pressed, 0 otherwise) Used internally by Windows.

    30
        Previous key state (1 if the key was held down before the message was
        sent, 0 if the key was up).

    31
        Transition state (1 if the key is being released, 0 if the key is being
        pressed).

    The return value specifies what should happen to the message. It is zero if
    the message should be processed by Windows; it is 1 if the message should be
    discarded.

    WH_MSGFILTER:

    Windows calls the WH_MSGFILTER filter function whenever a dialog box,
    message box, or menu has retrieved a message, and before it has processed
    that message. The filter allows an application to process or modify the
    messages.

    This is the only task-specific filter. A task may install this filter.

    The WH_MSGFILTER filter function must use the Pascal calling convention and
    must be declared %FAR%. The filter function must have the following form:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the library- or application-supplied
    function name. The actual name must be exported by including it in an
    %EXPORTS% statement in the application's module-definition file.

    <nCode>
        Specifies the type of message being processed. It must be one of the
        following values:

    MSGF_MENU
        Processing keyboard and mouse messages in a menu.

    MSGF_MENU
        Processing keyboard and mouse messages in a menu.

        If the <nCode> parameter is less than zero, the filter function must
        pass the message to %DefHookProc% without further processing and return
        the value returned by %DefHookProc%.

    <wParam>
        Specifies a NULL value.

    <lParam>
        Points to the message structure.

    The return value specifies the outcome of the function. It is nonzero if the
    hook function processes the message. Otherwise, it is zero.

    WH_SYSMSGFILTER:

    Windows calls the WH_SYSMSGFILTER filter function whenever a dialog box,
    message box, or menu has retrieved a message and before it has processed
    that message. The filter allows an application to process or modify messages
    for any application in the system.

    The filter function must use the Pascal calling convention and must be
    declared %FAR%. The filter function must have the following form:

    DWORD FAR PASCAL <FilterFunc>(<nCode>, <wParam>, <lParam>)
    int <nCode>;
    WORD <wParam>;
    DWORD <lParam>;

    <FilterFunc> is a placeholder for the library-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the library's module-definition file.

    <nCode>
        Specifies the type of message being processed. It must be one of the
        following values:

    MSGF_MENU
        Processing keyboard and mouse messages in menu.

    MSGF_MESSAGEBOX
        Processing messages inside the %MessageBox% function.

        If the <nCode> parameter is less than zero, the filter function must
        pass the message to %DefHookProc% without further processing and return
        the value returned by %DefHookProc%.

    <wParam>
        Specifies a NULL value.

    <lParam>
        Points to the message structure.

    The return value specifies the outcome of the function. It is nonzero if the
    hook function processes the message. Otherwise, it is zero.
--*/

ULONG FASTCALL WU32SetWindowsHookInternal(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETWINDOWSHOOKINTERNAL16 parg16;
    HOOKSTATEDATA HkData;
    HAND16        hMod16;
    INT           iHook;
    DWORD         Proc16;
    DWORD         ThreadId;
    PTD ptd = CURRENTPTD();


    GETARGPTR(pFrame, sizeof(SETWINDOWSHOOKINTERNAL16), parg16);
    hMod16 = FETCHWORD(parg16->f1);
    iHook = INT32(parg16->f2);
    Proc16 = DWORD32(parg16->f3);

    //
    // HACKHACK - Work around MS Mail 3.0's journal record hook.
    //            This hook is used only to keep track of the input
    //            activity in the system.  When the hook is called,
    //            Mail simply stores the current time.  Later, on
    //            expiration of a timer, Mail determines whether or
    //            not to start background database compression, using
    //            the amount of time since input was received as a
    //            determining factor.  If the hook hasn't been called
    //            in a while, Mail is more likely to start slow
    //            compression or switch to fast compression.
    //
    //            The problem is that WH_JOURNALRECORD causes all
    //            threads in the system to share one input queue,
    //            thereby meaning that any app that stops processing
    //            input hangs the entire UI.
    //
    //            For now, just disable the hook.
    //

    if (WH_JOURNALRECORD == iHook &&
        (ptd->dwWOWCompatFlags & WOWCF_FAKEJOURNALRECORDHOOK)) {
        return 0;
    }

    /*
    ** Micrografx Draw installs a hook, then when minimized, it unhooks the
    ** hook by re-hooking the return value from the original hook call.
    ** This works in Win 3.1 because the hook return value is a proc address.
    ** We can detect this by looking at the HIWORD of the proc address.  If
    ** it is NULL, we assume they are passing us a hook handle instead of
    ** a proc address.  If this is the case, then what they really want is
    ** unhooking.  -BobDay
    */
    if ( HIWORD(Proc16) == HOOK_ID ) {
        ul = GETBOOL16(UnhookWindowsHookEx(W32FreeHHookOfIndex(GETHHOOKINDEX(Proc16))));
        FREEARGPTR(parg16);
        return( ul );
    }

    if (!(ul = (ULONG)W32IsDuplicateHook(iHook, Proc16, ptd->htask16))) {
        if (W32GetThunkHookProc(iHook, Proc16, &HkData)) {

            // We pass threadid=0, for all hooks except WH_MSGFILTER.
            // because it is the only task-specific filter in WIN30.
            //
            // The understanding between USER and WOW is this:
            //    When a WOW thread sets a hook, with thread ID = 0,
            //    USER does the following:
            //       If Journal Hooks are being set, USER will set the
            //          WOW hook 'globally', ie. system wide.
            //
            //       For all the other hooks, USER sets the hook for all
            //       'WOW' threads i.e., the hook is global for the  WOW
            //       process.
            //
            //   If the threadiD != 0, then no special processing is done.
            //   the hook is set only for that particular thread.
            //

            if (iHook == (INT)WH_MSGFILTER)
                ThreadId = (DWORD)THREADID32(HkData.TaskId);
            else
                ThreadId = 0;

            ul = (ULONG)SetWindowsHookEx(iHook, (HOOKPROC)HkData.Proc32,
                                        (HINSTANCE)HkData.hMod, ThreadId);
            HkData.hHook = (HANDLE)ul;
            HkData.hMod16 = hMod16;

            // Excel looks at the hiword; so instead of passing back just an
            // index we make the hiword a hook identifier.
            if (ul == (ULONG)NULL)
                HkData.InUse = FALSE;
            else
                ul = MAKEHHOOK(HkData.iIndex);

            W32SetHookStateData(&HkData);
        }
        else
            ul = (ULONG)NULL;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL UnhookWindowsHook(<nHook>, <lpfnHook>)

    The %UnhookWindowsHook% function removes the Windows hook function pointed
    to by the <lpfnHook> parameter from a chain of hook functions. A Windows
    hook function processes events before they are sent to an application's
    message loop in the WinMain function.

    <nHook>
        int Specifies the type of hook function removed. It may be one of the
        following values:

    WH_CALLWNDPROC
        Installs a window-function filter.

    WH_GETMESSAGE
        Installs a message filter.

    WH_JOURNALPLAYBACK
        Installs a journaling playback filter.

    WH_JOURNALRECORD
        Installs a journaling record filter.

    WH_KEYBOARD
        Install a keyboard filter.

    WH_MSGFILTER
        Installs a message filter.

    The return value specifies the outcome of the function. It is TRUE if the
    hook function is successfully removed. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32UnhookWindowsHook(PVDMFRAME pFrame)
{
    ULONG                         ul;
    register PUNHOOKWINDOWSHOOK16 parg16;
    INT                           iHook;
    DWORD                         Proc16;

    GETARGPTR(pFrame, sizeof(UNHOOKWINDOWSHOOK16), parg16);
    iHook = INT32(parg16->f1);
    Proc16 = DWORD32(parg16->f2);


    ul = GETBOOL16(UnhookWindowsHookEx(W32FreeHHook(iHook, Proc16)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    CallNextHookEx - similar to DefHookProc
--*/

ULONG FASTCALL WU32CallNextHookEx(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PCALLNEXTHOOKEX16 parg16;
    HOOKSTATEDATA HkData;
    ULONG         hHook16;
    INT           nCode;
    LONG          wParam;
    LONG          lParam;
    DWORD         iHookCode;

    GETARGPTR(pFrame, sizeof(CALLNEXTHOOKEX16), parg16);


    hHook16 = DWORD32(parg16->f1);
    nCode = INT32(parg16->f2);
    wParam = WORD32(parg16->f3);
    lParam = DWORD32(parg16->f4);

    if (ISVALIDHHOOK(hHook16)) {
        iHookCode = GETHHOOKINDEX(hHook16);
        HkData.iIndex = (INT)iHookCode;
        if ( W32GetHookStateData( &HkData ) ) {
            ul = (ULONG)WU32StdDefHookProc(nCode, wParam, lParam, iHookCode);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    SetWindowsHookEx - similar to SetWindowsHook.

--*/

ULONG FASTCALL WU32SetWindowsHookEx(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETWINDOWSHOOKEX16 parg16;
    HOOKSTATEDATA HkData;
    INT           iHook;
    DWORD         Proc16;


    GETARGPTR(pFrame, sizeof(SETWINDOWSHOOKEX16), parg16);
    iHook = INT32(parg16->f1);
    Proc16 = DWORD32(parg16->f2);

    if (W32GetThunkHookProc(iHook, Proc16, &HkData)) {
        ul = (ULONG)SetWindowsHookEx(iHook, (HOOKPROC)HkData.Proc32,
                                   (HINSTANCE)HkData.hMod, (DWORD)THREADID32(parg16->f4));
        HkData.hHook = (HANDLE)ul;
        if (ul == (ULONG)NULL) {
            HkData.InUse = FALSE;
        } else {
            ul = MAKEHHOOK(HkData.iIndex);
            HkData.hMod16 = GetExePtr16(parg16->f3);
        }

        W32SetHookStateData(&HkData);
    }
    else
        ul = (ULONG)NULL;

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    UnhookWindowsHookEx - similar to unhookwindowshook

--*/

ULONG FASTCALL WU32UnhookWindowsHookEx(PVDMFRAME pFrame)
{
    ULONG ul;
    register PUNHOOKWINDOWSHOOKEX16 parg16;

    GETARGPTR(pFrame, sizeof(UNHOOKWINDOWSHOOKEX16), parg16);

    ul = GETBOOL16(UnhookWindowsHookEx(W32FreeHHookOfIndex(GETHHOOKINDEX(INT32(parg16->f1)))));

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuhook.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUHOOK.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL   WU32SetWindowsHookInternal(PVDMFRAME pFrame);
ULONG FASTCALL   WU32UnhookWindowsHook(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CallNextHookEx(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetWindowsHookEx(PVDMFRAME pFrame);
ULONG FASTCALL   WU32UnhookWindowsHookEx(PVDMFRAME pFrame);


#define HOOK_ID      0x4B48             // dumps as 'H' 'K'
#define MAKEHHOOK(index)           (MAKELONG(index,HOOK_ID))
#define GETHHOOKINDEX(hook)        (LOWORD(hook))
#define ISVALIDHHOOK(hook)         (HIWORD(hook) == HOOK_ID)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wulang.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WULANG.H
 *  WOW32 16-bit User API support
 *
 *
 *  It thunks the win 3.x language functions to NT. These functions are
 *  mainly used by the programs that are ported to various international
 *  languages.
 *
 *  History:
 *  Created 19-April-1992 by Chandan Chauhan (ChandanC)
 *
--*/


ULONG FASTCALL WU32AnsiLower(PVDMFRAME pFrame);
ULONG FASTCALL WU32AnsiLowerBuff(PVDMFRAME pFrame);
ULONG FASTCALL WU32AnsiNext(PVDMFRAME pFrame);
ULONG FASTCALL WU32AnsiPrev(PVDMFRAME pFrame);
ULONG FASTCALL WU32AnsiUpper(PVDMFRAME pFrame);
ULONG FASTCALL WU32AnsiUpperBuff(PVDMFRAME pFrame);
ULONG FASTCALL WU32lstrcmp(PVDMFRAME pFrame);
ULONG FASTCALL WU32lstrcmpi(PVDMFRAME pFrame);
ULONG FASTCALL WU32wvsprintf(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsCharAlpha(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsCharAlphaNumeric(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsCharLower(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsCharUpper(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuman.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMAN.H
 *  WOW32 16-bit User API support (manually-coded thunks)
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/

typedef ULONG   (*WBP) (LPSTR, int, int, int);

ULONG FASTCALL   WU32ExitWindows(PVDMFRAME pFrame);
ULONG FASTCALL   WU32NotifyWow(PVDMFRAME pFrame);
ULONG FASTCALL   WU32WOWWordBreakProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32MouseEvent(PVDMFRAME pFrame);
ULONG FASTCALL   WU32KeybdEvent(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wumenu.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMENU.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WU32AppendMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32ChangeMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32CheckMenuItem(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreatePopupMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32DeleteMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32DestroyMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32DrawMenuBar(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuCheckMarkDimensions(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuString(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetSystemMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32HiliteMenuItem(PVDMFRAME pFrame);
ULONG FASTCALL WU32InsertMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32LoadMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32LoadMenuIndirect(PVDMFRAME pFrame);
ULONG FASTCALL WU32ModifyMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32RemoveMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetMenuItemBitmaps(PVDMFRAME pFrame);
ULONG FASTCALL WU32TrackPopupMenu(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuman.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMAN.C
 *  WOW32 16-bit User API support (manually-coded thunks)
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wuman.c);

WBP W32WordBreakProc = NULL;

extern DWORD fThunkStrRtns;

extern WORD gwKrnl386CodeSeg1;
extern WORD gwKrnl386CodeSeg2;
extern WORD gwKrnl386CodeSeg3;
extern WORD gwKrnl386DataSeg1;

ULONG FASTCALL WU32ExitWindows(PVDMFRAME pFrame)
// BUGBUG mattfe 4-mar-92, this routine should not return if we close down
// all the apps successfully.
{
    ULONG ul;
    register PEXITWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(EXITWINDOWS16), parg16);

    ul = GETBOOL16(ExitWindows(
    DWORD32(parg16->dwReserved),
    WORD32(parg16->wReturnCode)
    ));

    FREEARGPTR(parg16);

    RETURN(ul);
}

WORD gUser16CS = 0;

ULONG FASTCALL WU32NotifyWow(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PNOTIFYWOW16 parg16;

    GETARGPTR(pFrame, sizeof(NOTIFYWOW16), parg16);

    switch (FETCHWORD(parg16->Id)) {
        case NW_LOADACCELERATORS:
            ul = WU32LoadAccelerators(FETCHDWORD(parg16->pData));
            break;

        case NW_LOADICON:
        case NW_LOADCURSOR:
            ul = (ULONG) W32CheckIfAlreadyLoaded(parg16->pData, FETCHWORD(parg16->Id));
            break;

        case NW_WINHELP:
            {
                // this call is made from IWinHelp in USER.exe to find the
                // '16bit' help window if it exists.
                //

                LPSZ lpszClass;
                GETMISCPTR(parg16->pData, lpszClass);
                ul = (ULONG)(pfnOut.pfnWOWFindWindow)((LPCSTR)lpszClass, (LPCSTR)NULL);
                if (ul) {
                    // check if hwndWinHelp belongs to this process or not.
                    DWORD pid, pidT;
                    pid = pidT = GetCurrentProcessId();
                    GetWindowThreadProcessId((HWND)ul, &pid);
                    ul = (ULONG)MAKELONG((WORD)GETHWND16(ul),(WORD)(pid == pidT));
                }
                FREEMISCPTR(lpszClass);
            }
            break;

        case NW_KRNL386SEGS:
            {
                PKRNL386SEGS pKrnl386Segs;
                
                GETVDMPTR(parg16->pData, sizeof(KRNL386SEGS), pKrnl386Segs);

                gwKrnl386CodeSeg1 = pKrnl386Segs->CodeSeg1;
                gwKrnl386CodeSeg2 = pKrnl386Segs->CodeSeg2;
                gwKrnl386CodeSeg3 = pKrnl386Segs->CodeSeg3;
                gwKrnl386DataSeg1 = pKrnl386Segs->DataSeg1;
            }
            break;

        case NW_FINALUSERINIT:
            {
                static BYTE CallCsrFlag = 0;
                extern DWORD   gpsi;
                PUSERCLIENTGLOBALS pfinit16;
                WORD UNALIGNED *pwMaxDWPMsg;
                PBYTE pDWPBits;
#ifdef DEBUG
                WORD wMsg;
                int i;
                PSZ pszFormat;
#endif

                GETVDMPTR(parg16->pData, sizeof(USERCLIENTGLOBALS), pfinit16);
                GETVDMPTR(pfinit16->lpwMaxDWPMsg, sizeof(WORD), pwMaxDWPMsg);
                GETVDMPTR(pfinit16->lpDWPBits, pfinit16->cbDWPBits, pDWPBits);

                // store the 16bit hmod of user.exe
                gUser16hInstance = (WORD)pfinit16->hInstance;
                WOW32ASSERTMSGF((gUser16hInstance),
                                ("WOW Error gUser16hInstance == NULL!\n"));

                // store the 16bit CS of user.exe
                gUser16CS = HIWORD(pFrame->vpCSIP);

                // initialize user16client globals

                if (pfinit16->lpgpsi) {
                    BYTE **lpT;
                    GETVDMPTR(pfinit16->lpgpsi, sizeof(DWORD), lpT);
                    *lpT = (BYTE *)gpsi;
                    FLUSHVDMCODEPTR((ULONG)pfinit16->lpgpsi, sizeof(DWORD), lpT);
                    FREEVDMPTR(lpT);
                }


                if (pfinit16->lpCsrFlag) {
                    BYTE **lpT;
                    GETVDMPTR(pfinit16->lpCsrFlag, sizeof(DWORD), lpT);
                    *lpT = (LPSTR)&CallCsrFlag;
                    FLUSHVDMCODEPTR((ULONG)pfinit16->lpCsrFlag, sizeof(DWORD), lpT);
                    FREEVDMPTR(lpT);
                }

                if (pfinit16->lpHighestAddress) {
                    DWORD *lpT;
                    SYSTEM_BASIC_INFORMATION sbi;
                    NTSTATUS Status;

                    GETVDMPTR(pfinit16->lpHighestAddress, sizeof(DWORD), lpT);
                    Status = NtQuerySystemInformation(SystemBasicInformation,
                                                      &sbi,
                                                      sizeof(sbi),
                                                      NULL);

                    WOW32ASSERTMSGF((NT_SUCCESS(Status)),
                                ("WOW Error NtQuerySystemInformation failed!\n"));

                    *lpT = sbi.MaximumUserModeAddress;
                    FLUSHVDMCODEPTR((ULONG)pfinit16->lpHighestAddress, sizeof(DWORD), lpT);
                    FREEVDMPTR(lpT);
                }


                /* No longer required now that user32 & user.exe are separate
     DEAD CODE  if (HIWORD(pfinit16->dwBldInfo) != HIWORD(pfnOut.dwBldInfo)) {
     DEAD CODE      MessageBeep(0);
     DEAD CODE      MessageBoxA(NULL, "user.exe and user32.dll are mismatched.",
     DEAD CODE                  "WOW Error", MB_OK | MB_ICONEXCLAMATION);
     DEAD CODE  }
                */

                *pwMaxDWPMsg = (pfnOut.pfnWowGetDefWindowProcBits)(pDWPBits, pfinit16->cbDWPBits);

                FLUSHVDMCODEPTR(pfinit16->lpwMaxDWPMsg, sizeof(WORD), pwMaxDWPMsg);
                FLUSHVDMCODEPTR(pfinit16->lpDWPBits, pfinit16->cbDWPBits, pDWPBits);

#ifdef DEBUG
                LOGDEBUG(LOG_TRACE, ("WU32NotifyWow: got DefWindowProc bits, wMaxDWPMsg = 0x%x.\n", *pwMaxDWPMsg));
                LOGDEBUG(LOG_TRACE, ("The following messages will be passed on to 32-bit DefWindowProc:\n"));

#define FPASSTODWP32(msg) \
    (pDWPBits[msg >> 3] & (1 << (msg & 7)))

                wMsg = 0;
                i = 0;

                while (wMsg <= *pwMaxDWPMsg) {
                    if (FPASSTODWP32(wMsg)) {
                        if ( i & 3 ) {
                            pszFormat = ", %s";
                        } else {
                            pszFormat = "\n%s";
                        }
                        LOGDEBUG(LOG_TRACE, (pszFormat, aw32Msg[wMsg].lpszW32));
                        i++;
                    }
                    wMsg++;
                }

                LOGDEBUG(LOG_TRACE, ("\n\n"));
#endif

                gpfn16GetProcModule = pfinit16->pfnGetProcModule;

                //
                // Return value tells User16 whether to thunk
                // string routines to Win32 or use the fast
                // US-only versions.  TRUE means thunk.
                //
                // If the locale is U.S. English, we default to
                // not thunking, outside the U.S. we default to
                // thunking.  See wow32.c's use of fThunkStrRtns.
                //
                // We engage in this nastiness because the Winstone 94
                // Access 1.1 test takes *twice* as long to run in
                // the US if we thunk lstrcmp and lstrcmpi to Win32.
                //
                // By adding a value "ThunkNLS" to the WOW registry
                // key of type REG_DWORD, the user can force thunking
                // to Win32 (value 1) or use the fast US-only ones (value 0).
                //

                ul = fThunkStrRtns;

                FREEVDMPTR(pDWPBits);
                FREEVDMPTR(pwMaxDWPMsg);
                FREEVDMPTR(pfinit16);

            }
            break;

        default:
            ul = 0;
            break;
    }

    FREEARGPTR(parg16);
    return ul;
}


ULONG FASTCALL WU32WOWWordBreakProc(PVDMFRAME pFrame)
{
    PSZ         psz1;
    ULONG ul;
    register PWOWWORDBREAKPROC16 parg16;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETPSZPTR(parg16->lpszEditText, psz1);

    ul = (*W32WordBreakProc)(psz1, parg16->ichCurrentWord, parg16->cbEditText,
                             parg16->action);

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}

//
// WU32MouseEvent:  Thunk for 16-bit register-based API mouse_event,
//                  with the help of user16 function mouse_event (in
//                  winmisc2.asm).
//

ULONG FASTCALL WU32MouseEvent(PVDMFRAME pFrame)
{
    ULONG ul;
    register PMOUSEEVENT16 parg16;
    typedef ULONG (WINAPI *PFMOUSE_EVENT)(DWORD, DWORD, DWORD, DWORD, DWORD);

    GETARGPTR(pFrame, sizeof(PMOUSEEVENT16), parg16);

    //
    // mouse_event is declared void, but we'll return the same value as
    // user32.
    //

    ul = ((PFMOUSE_EVENT)(PVOID)mouse_event)(
             parg16->wFlags,
             parg16->dx,
             parg16->dy,
             parg16->cButtons,
             parg16->dwExtraInfo
             );

    FREEARGPTR(parg16);
    RETURN(ul);
}



//
// WU32KeybdEvent:  Thunk for 16-bit register-based API keybd_event,
//                  with the help of user16 function keybd_event (in
//                  winmisc2.asm).
//

ULONG FASTCALL WU32KeybdEvent(PVDMFRAME pFrame)
{
    ULONG ul;
    register PKEYBDEVENT16 parg16;
    typedef ULONG (WINAPI *PFKEYBD_EVENT)(BYTE, BYTE, DWORD, DWORD);

    GETARGPTR(pFrame, sizeof(PKEYBDEVENT16), parg16);

    //
    // keybd_event is declared void, but we'll return the same value as
    // user32.
    //

    ul = ((PFKEYBD_EVENT)(PVOID)keybd_event)(
             LOBYTE(parg16->bVirtualKey),
             LOBYTE(parg16->bScanCode),
             ((HIBYTE(parg16->bVirtualKey) == 0x80) ? KEYEVENTF_KEYUP : 0) |
             ((HIBYTE(parg16->bScanCode) == 0x1) ? KEYEVENTF_EXTENDEDKEY : 0),
             parg16->dwExtraInfo
             );

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wumenu.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMENU.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wumenu.c);


/*++
    BOOL AppendMenu(<hMenu>, <wFlags>, <wIDNewItem>, <lpNewItem>)
    HMENU <hMenu>;
    WORD <wFlags>;
    WORD <wIDNewItem>;
    LPSTR <lpNewItem>;

    The %AppendMenu% function appends a new item to the end of a menu. The
    application can specify the state of the menu item by setting values in the
    <wFlags> parameter.

    <hMenu>
        Identifies the menu to be changed.

    <wFlags>
        Specifies information about the state of the new menu item when
        it is added to the menu. It consists of one or more values listed in the
        following Comments section.

    <wIDNewItem>
        Specifies either the command ID of the new menu item or, if
        <wFlags> is set to MF_POPUP, the menu handle of the pop-up menu.

    <lpNewItem>
        Specifies the content of the new menu item. The interpretation
        of the <lpNewItem> parameter depends upon the setting of the <wFlags>
        parameter.

    MF_STRING
        Contains a long pointer to a null-terminated string.

    MF_BITMAP
        Contains a bitmap handle in its low-order word.

    MF_OWNERDRAW
        Contains an application-supplied 32-bit value which the application can
        use to maintain additional data associated with the menu item. This
        32-bit value is available to the application in the %itemData% member of
        the structure pointed to by the <lParam> parameter of the WM_MEASUREITEM
        and WM_DRAWITEM messages sent when the menu item is initially displayed
        or is changed.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%.

    Each of the following groups list flags that are mutually exclusive and
    cannot be used together:

    o   MF_BYCOMMAND and MF_BYPOSITION

    o   MF_DISABLED, MF_ENABLED, and MF_GRAYED

    o   MF_BITMAP, MF_STRING, and MF_OWNERDRAW

    o   MF_MENUBARBREAK and MF_MENUBREAK

    o   MF_CHECKED and MF_UNCHECKED

    .cmt
    16-Sep-1990 [ralphw]

    Some of the above flags aren't documented as valid values for the wFlags
    parameter. If they are valid, they should be documented, otherwise, they
    should be removed from the list.
    .endcmt

    The following list describes the flags which may be set in the <wFlags>
    parameter:

    MF_BITMAP
        Uses a bitmap as the item. The low-order word of the lpNewItem parameter
        contains the handle of the bitmap.

    MF_CHECKED
        Places a checkmark next to the item. If the application has supplied
        checkmark bitmaps (see %SetMenuItemBitmaps%), setting this flag displays
        the checkmark on bitmap next to the menu item.

    MF_DISABLED
        Disables the menu item so that it cannot be selected, but does not gray
        it.

    MF_ENABLED
        Enables the menu item so that it can be selected and restores it from
        its grayed state.

    MF_GRAYED
        Disables the menu item so that it cannot be selected and grays it.

    MF_MENUBARBREAK
        Same as MF_MENUBREAK except that for pop-up menus, separates the new
        column from the old column with a vertical line.

    MF_MENUBREAK
        Places the item on a new line for static menu-bar items. For pop-up
        menus, places the item in a new column, with no dividing line between
        the columns.

    MF_OWNERDRAW
        Specifies that the item is an owner-draw item. The window that owns the
        menu receives a WM_MEASUREITEM message when the menu is displayed for
        the first time to retrieve the height and width of the menu item. The
        WM_DRAWITEM message is then sent whenever the owner must update the
        visual appearance of the menu item. This option is not valid for a
        top-level menu item.

    MF_POPUP
        Specifies that the menu item has a pop-up menu associated with it. The
        <wIDNewItem> parameter specifies a handle to a pop-up menu to be
        associated with the item. This is used for adding either a top-level
        pop-up menu or adding a hierarchical pop-up menu to a pop-up menu item.

    MF_SEPARATOR
        Draws a horizontal dividing line. Can only be used in a pop-up menu.
        This line cannot be grayed, disabled, or highlighted. The <lpNewItem>
        and <wIDNewItem> parameters are ignored.

    MF_STRING
        Specifies that the menu item is a character string; the <lpNewItem>
        parameter points to the string for the menu item.

    MF_UNCHECKED
        Does not place a checkmark next to the item (default). If the
        application has supplied checkmark bitmaps (see %SetMenuItemBitmaps%),
        setting this flag displays the checkmark off bitmap next to the menu
        item.
--*/

ULONG FASTCALL WU32AppendMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz4;
    register PAPPENDMENU16 parg16;
    UINT wIDNewItem;

    GETARGPTR(pFrame, sizeof(APPENDMENU16), parg16);

    // USER has some internal bitmap identifiers for menu item bitmaps so
    // it doesn't have to store multiple copies of these bitmaps when they
    // appear in multiple menus.  WinProj does its own MDI and uses these
    // bitmaps.

    //  #define MENUHBM_CHILDCLOSE   (UINT)1
    //  #define MENUHBM_RESTORE      (UINT)2
    //  #define MENUHBM_MINIMIZE     (UINT)3
    //  #define MENUHBM_MAX          (UINT)4

    if (parg16->f2 & MF_BITMAP) {
        if (LOW(parg16->f4) >= 4)
            psz4 = (PSZ)HBITMAP32(LOW(parg16->f4));
        else
            psz4 = (PSZ)WORD32(parg16->f4);
    }
    else if (parg16->f2 & MF_OWNERDRAW)
        psz4 = (PSZ)DWORD32(parg16->f4);
    else
        GETPSZPTR(parg16->f4, psz4);

    wIDNewItem = (UINT) WORD32(parg16->f3);

    if (parg16->f2 & MF_POPUP)
        wIDNewItem = (UINT) HMENU32(parg16->f3);


    ul = GETBOOL16(AppendMenu(HMENU32(parg16->f1),
                              WORD32(parg16->f2),
                              wIDNewItem,
                              psz4));

#ifdef	FE_SB
    // For AutherWare Star ( APP BUG ) MAKKBUG:3203
    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_ASWHELPER) {                        	if (parg16->f2 & MF_POPUP) {
	    HWND hWnd;

	    if (!(hWnd=GetActiveWindow())) {
        	hWnd = GetForegroundWindow();
	    }
	    SetMenu(hWnd , HMENU32(parg16->f1));
	}
    }
#endif // FE_SB

    FREEPSZPTR(psz4);
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    BOOL ChangeMenu(<hMenu>,<wIDChangeItem>,<lpNewItem>,<wIDNewItem>,<wFlags>)
    HMENU <hMenu>;
    WORD <wIDChangeItem>;
    LPSTR <lpNewItem>;
    WORD <wIDNewItem>;
    WORD <wFlags>;

    The %ChangeMenu% function appends, inserts, deletes, or modifies a menu
    item in the menu given by the <hMenu> parameter.  The <wIDChangeItem>,
    <lpNewItem>, <wIDNewItem> and <wFlags> parameters define which item to
    change and how to change it.

    <hMenu>
        Identifies the menu to be changed.

    <wIDChangeItem>
        Specifies the item to be changed.  If MF_BYPOSITION is specified,
        <wIDChangeItem> gives the position of the menu item to be
        changed (the first item is at position zero).  If MF_BYCOMMAND is
        specified instead, <wIDChangeItem> specifies the menu-item ID.
        The menu-item ID can specify any popup-menu item (that is, an item
        in a popup menu associated with an item of <hMenu>).  If neither
        flag is given, the default is MF_BYCOMMAND.  When MF_INSERT is used,
        <wIDChangeItem> identifies the item before which the new item is to
        be inserted.  When MF_APPEND is used, <wIDChangeItem> is NULL.

    <lpNewItem>
        Specifies the content of the new menu item. The interpretation
        of the <lpNewItem> parameter depends upon the setting of the <wFlags>
        parameter.  The <lpNewItem> parameter is never a handle to a menu.
        The MF_POPUP flag applies to the <wIDNewItem> parameter only.

        MF_BITMAP
            <lpNewItem> contains a bitmap handle in its low-order word.

        MF_STRING
            <lpNewItem> contains a long pointer to a null-terminated string.

        The default is MF_STRING.  A NULL value for <lpNewItem> creates a
        horizontal break (the same effect as using the MF_SEPARATOR flag).

        Note that MF_OWNERDRAW is not allowed on ChangeMenu;  it conflicts with
        the ChangeMenu command bit MF_APPEND.

    <wIDNewItem>
        Specifies either the command ID of the new menu item or, if
        <wFlags> is set to MF_POPUP, the menu handle of the pop-up menu.
        It is never a menu-item position.

    <wFlags>
        Specifies information about the state of the new menu item when it
        is added to the menu.  It consists of one or more values listed in
        the following Comments section.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%.

    Each of the following groups list flags that are mutually exclusive and
    cannot be used together:

    o   MF_APPEND, MF_CHANGE, MF_DELETE, MF_INSERT and MF_REMOVE

    o   MF_BYCOMMAND and MF_BYPOSITION

    o   MF_DISABLED, MF_ENABLED, and MF_GRAYED

    o   MF_BITMAP, MF_POPUP and MF_STRING

    o   MF_MENUBARBREAK and MF_MENUBREAK

    o   MF_CHECKED and MF_UNCHECKED

    .cmt
    16-Sep-1990 [ralphw]

    Some of the above flags aren't documented as valid values for the wFlags
    parameter. If they are valid, they should be documented, otherwise, they
    should be removed from the list.
    .endcmt

    The following list describes the flags which may be set in the <wFlags>
    parameter:

    MF_APPEND
        Appends the new item to the end of the menu.

    MF_BITMAP
        Uses a bitmap as the item. The low-order word of the lpNewItem parameter
        contains the handle of the bitmap.

    MF_BYCOMMAND
        Specifies that the <wIDChangeItem> parameter gives the menu-item ID
        number (default).

    MF_BYPOSITION
        Specifies that the <wIDChangeItem> parameter gives the position of
        the menu item to be changed.

    MF_CHANGE
        Changes or replaces the specified item.

    MF_CHECKED
        Places a checkmark next to the item. If the application has supplied
        checkmark bitmaps (see %SetMenuItemBitmaps%), setting this flag displays
        the checkmark on bitmap next to the menu item.

    MF_DELETE
        Deletes the item.

    MF_DISABLED
        Disables the menu item so that it cannot be selected, but does not gray
        it.

    MF_ENABLED
        Enables the menu item so that it can be selected and restores it from
        its grayed state.

    MF_GRAYED
        Disables the menu item so that it cannot be selected and grays it.

    MF_INSERT
        Inserts a new item, just before the specified item.

    MF_MENUBARBREAK
        Same as MF_MENUBREAK except that for pop-up menus, separates the new
        column from the old column with a vertical line.

    MF_MENUBREAK
        Places the item on a new line for static menu-bar items. For pop-up
        menus, places the item in a new column, with no dividing line between
        the columns.

    MF_POPUP
        Specifies that the menu item has a pop-up menu associated with it. The
        <wIDNewItem> parameter specifies a handle to a pop-up menu to be
        associated with the item. This is used for adding either a top-level
        pop-up menu or adding a hierarchical pop-up menu to a pop-up menu item.

    MF_REMOVE
        Removes the item but does not delete it.

    MF_SEPARATOR
        Draws a horizontal dividing line. Can only be used in a pop-up menu.
        This line cannot be grayed, disabled, or highlighted. The <lpNewItem>
        and <wIDNewItem> parameters are ignored.

    MF_STRING
        Specifies that the menu item is a character string; the <lpNewItem>
        parameter points to the string for the menu item.

    MF_UNCHECKED
        Does not place a checkmark next to the item (default). If the
        application has supplied checkmark bitmaps (see %SetMenuItemBitmaps%),
        setting this flag displays the checkmark off bitmap next to the menu
        item.
--*/

ULONG FASTCALL WU32ChangeMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz3;
    DWORD dw4;

    register PCHANGEMENU16 parg16;

    GETARGPTR(pFrame, sizeof(CHANGEMENU16), parg16);

    if (parg16->f5 & MF_BITMAP) {
        if (LOW(parg16->f3) >= 4)
            psz3 = (PSZ)HBITMAP32(LOW(parg16->f3));
        else
            psz3 = (PSZ)WORD32(parg16->f3);
    }
    else
        GETPSZPTR(parg16->f3, psz3);

    dw4 = WORD32(parg16->f4);
    if (WORD32(parg16->f5) & MF_POPUP)
    dw4 = (DWORD)HMENU32(parg16->f4);

    ul = GETBOOL16(ChangeMenu(
      HMENU32(parg16->f1),
      WORD32(parg16->f2),
      psz3,
      dw4,
      WORD32(parg16->f5)
    ));

    FREEPSZPTR(psz3);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL CheckMenuItem(<hMenu>, <wIDCheckItem>, <wCheck>)
    HMENU <hMenu>;
    WORD <wIDCheckItem>;
    WORD <wCheck>;

    The %CheckMenuItem% function places checkmarks next to or removes checkmarks
    from menu items in the pop-up menu specified by the <hMenu> parameter. The
    <wIDCheckItem> parameter specifies the item to be modified.

    <hMenu>
        Identifies the menu.

    <wIDCheckItem>
        Specifies the menu item to be checked.

    <wCheck>
        Specifies how to check the menu item and how to determine the item's
        position in the menu. The <wCheck> parameter can be a combination of the
        MF_CHECKED or MF_UNCHECKED with MF_BYPOSITION or MF_BYCOMMAND flags.
        These flags can be combined by using the bitwise OR operator. They have
        the following meanings:

    MF_BYCOMMAND
        Specifies that the <wIDCheckItem> parameter gives the menu-item ID
        (MF_BYCOMMAND is the default).

    MF_BYPOSITION
        Specifies that the <wIDCheckItem > parameter gives the position of the
        menu item (the first item is at position zero).

    MF_CHECKED
        Adds checkmark.

    MF_UNCHECKED
        Removes checkmark.

    The return value specifies the previous state of the item. It is either
    MF_CHECKED or MF_UNCHECKED. The return value is -1 if the menu item does not
    exist.

    The <wIDCheckItem> parameter may identify a pop-up menu item as well as a
    menu item. No special steps are required to check a pop-up menu item.

    Top-level menu items cannot be checked.

    A pop-up menu item should be checked by position since it does not have a
    menu-item identifier associated with it.
--*/

ULONG FASTCALL WU32CheckMenuItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PCHECKMENUITEM16 parg16;

    GETARGPTR(pFrame, sizeof(CHECKMENUITEM16), parg16);

    ul = GETBOOL16(CheckMenuItem(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HMENU CreateMenu(VOID)

    The %CreateMenu% function creates a menu. The menu is initially empty, but
    can be filled with menu items by using the %AppendMenu% or %InsertMenu%
    function.

    This function has no parameters.

    The return value identifies the newly created menu. It is NULL if the menu
    cannot be created.
--*/

ULONG FASTCALL WU32CreateMenu(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETHMENU16(CreateMenu());

    RETURN(ul);
}


/*++
    HMENU CreatePopupMenu(VOID)

    The %CreatePopupMenu% function creates and returns a handle to an empty
    pop-up menu.

    An application adds items to the pop-up menu by calling %InsertMenu% and
    %AppendMenu%. The application can add the pop-up menu to an existing menu or
    pop-up menu, or it may display and track selections on the pop-up menu by
    calling %TrackPopupMenu%.

    This function has no parameters.

    The return value identifies the newly created menu. It is NULL if the menu
    cannot be created.
--*/

ULONG FASTCALL WU32CreatePopupMenu(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETHMENU16(CreatePopupMenu());

    RETURN(ul);
}


/*++
    BOOL DeleteMenu(<hMenu>, <nPosition>, <wFlags>)
    HMENU <hMenu>;
    WORD <nPosition>;
    WORD <wFlags>;

    The %DeleteMenu% function deletes an item from the menu identified by the
    <hMenu> parameter; if the menu item has an associated pop-up menu,
    %DeleteMenu% destroys the handle by the pop-up menu and frees the memory
    used by the pop-up menu.

    <hMenu>
        Identifies the menu to be changed.

    <nPosition>
        Specifies the menu item which is to be deleted, as determined by the
        <wFlags> parameter:

    MF_BYPOSITION
        Specifies the position of the menu item; the first item in the menu is
        at position 0.

    MF_BYCOMMAND
        Specifies the command ID of the existing menu item.

    <wFlags>
        Specifies how the <nPosition> parameter is interpreted. It may be
        set to either MF_BYCOMMAND or MF_BYPOSITION.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%.
--*/
ULONG FASTCALL WU32DeleteMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDELETEMENU16 parg16;
    PSZ pszModName;

    GETARGPTR(pFrame, sizeof(DELETEMENU16), parg16);

    // Nasty Hack to fix MSVC 1.5, they remove the close item
    // from their system menu, so we prevent them from doing
    // this and act like nothing happened ( ie return TRUE ).
    // From Win 95, Bug#8154, [t-arthb]

    if ((parg16->f2 == 6) && (parg16->f3 & MF_BYPOSITION)) {
        pszModName = ((PTDB)SEGPTR(CURRENTPTD()->htask16,0))->TDB_ModName;
        if (!WOW32_strncmp(pszModName, "MSVC", 4)) {
            FREEARGPTR(parg16);
            RETURN(GETBOOL16(TRUE));
        }
    }

    ul = GETBOOL16(DeleteMenu(HMENU32(parg16->f1),
                              WORD32(parg16->f2),
                              WORD32(parg16->f3)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DestroyMenu(<hMenu>)
    HMENU <hMenu>;

    The %DestroyMenu% function destroys the menu specified by the <hMenu>
    parameter and frees any memory that the menu occupied.

    <hMenu>
        Identifies the menu to be destroyed.

    The return value specifies whether or not the specified menu is destroyed.
    It is TRUE if the menu is destroyed. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32DestroyMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDESTROYMENU16 parg16;

    GETARGPTR(pFrame, sizeof(DESTROYMENU16), parg16);

    ul = GETBOOL16(DestroyMenu(HMENU32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void DrawMenuBar(<hwnd>)
    HWND <hwnd>;

    The %DrawMenuBar% function redraws the menu bar. If a menu bar is changed
    <after> Windows has created the window, this function should be called to
    draw the changed menu bar.

    <hwnd>
        Identifies the window whose menu needs redrawing.

    This function does not return a value.
--*/

ULONG FASTCALL WU32DrawMenuBar(PVDMFRAME pFrame)
{
    register PDRAWMENUBAR16 parg16;

    GETARGPTR(pFrame, sizeof(DRAWMENUBAR16), parg16);

    DrawMenuBar(HWND32(parg16->f1));

    FREEARGPTR(parg16);
    RETURN(TRUE);
}


/*++
    DWORD GetMenuCheckMarkDimensions(VOID)

    The %GetMenuCheckMarkDimensions% function returns the dimensions of the
    default checkmark bitmap. Windows displays this bitmap next to checked menu
    items. Before calling the %SetMenuItemBitmaps% function to replace the
    default checkmark, an application should call the
    %GetMenuCheckMarkDimensions% function to determine the correct size for the
    bitmaps.

    This function has no parameters.

    The return value specifies the height and width of the default checkmark
    bitmap. The high-order word contains the height in pixels and the low-order
    word contains the width.
--*/

ULONG FASTCALL WU32GetMenuCheckMarkDimensions(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETLONG16(GetMenuCheckMarkDimensions());

    RETURN(ul);
}


/*++
    int GetMenuString(<hMenu>, <wIDItem>, <lpString>, <nMaxCount>, <wFlag>)
    HMENU <hMenu>;
    WORD <wIDItem>;
    LPSTR <lpString>;
    int <nMaxCount>;
    WORD <wFlag>;

    The %GetMenuString% function copies the label of the specified menu item
    into the <lpString> parameter.

    <hMenu>
        Identifies the menu.

    <wIDItem>
        Specifies the integer identifier of the menu item (from the
        resource file) or the offset of the menu item in the menu, depending on
        the value of the <wFlag> parameter.

    <lpString>
        Points to the buffer that is to receive the label.

    <nMaxCount>
        Specifies the maximum length of the label to be copied. If the
        label is longer than the maximum specified in <nMaxCount>, the extra
        characters are truncated.

    <wFlag>
        Specifies the nature of the <wID> parameter. If <wFlags> contains
        MF_BYPOSITION, <wId> specifies a (zero-based) relative position; if the
        <wFlags> parameter contains MF_BYCOMMAND, <wId> specifies the item ID.

    The return value specifies the actual number of bytes copied to the buffer.

    The <nMaxCount> parameter should be one larger than the number of characters
    in the label to accommodate the null character that terminates a string.
--*/

#define GMS32_LIMIT 2000
ULONG FASTCALL WU32GetMenuString(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz3;
    register PGETMENUSTRING16 parg16;

    GETARGPTR(pFrame, sizeof(GETMENUSTRING16), parg16);
    ALLOCVDMPTR(parg16->f3, parg16->f4, psz3);

    // limit nMaxCount to a reasonable amount so it does not fail in client
    // server.  Some wow apps passed in -1.
    ul = GETINT16(GetMenuString(
        HMENU32(parg16->f1),
        WORD32(parg16->f2),
        psz3,
        (WORD32(parg16->f4) > GMS32_LIMIT) ? GMS32_LIMIT : WORD32(parg16->f4),
        WORD32(parg16->f5)
        ));

    FLUSHVDMPTR(parg16->f3, strlen(psz3)+1, psz3);
    FREEVDMPTR(psz3);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HMENU GetSystemMenu(<hwnd>, <bRevert>)
    HWND <hwnd>;
    BOOL <bRevert>;

    The %GetSystemMenu% function allows the application to access the System
    menu for copying and modification.

    <hwnd>
        Identifies the window that will own a copy of the System menu.

    <bRevert>
        Specifies the action to be taken.

        If <bRevert> is FALSE, the %GetSystemMenu% returns a handle to a copy of
        the System menu currently in use. This copy is initially identical to
        the System menu, but can be modified.

        If <bRevert> is TRUE, the %GetSystemMenu% function destroys the possibly
        modified copy of the System menu (if there is one) that belongs to the
        specified window and returns a handle to the original, unmodified
        version of the System menu.

    The return value identifies the System menu if <bRevert> is TRUE and the
    System menu has been modified. If <bRevert> is TRUE and the System menu
    has <not> been modified, the return value is NULL. If <bRevert> is FALSE, the
    return value identifies a copy of the System menu.

    Any window that does not use the %GetSystemMenu% function to make its own
    copy of the System menu receives the standard System menu.

    The handle returned by the %GetSystemMenu% function can be used with the
    %AppendMenu%, %InsertMenu% or %ModifyMenu% functions to change the System
    menu. The System menu initially contains items identified with various ID
    values such as SC_CLOSE, SC_MOVE, and SC_SIZE. Menu items on the System menu
    send WM_SYSCOMMAND messages. All predefined System-menu items have ID
    numbers greater than 0xF000. If an application adds commands to the System
    menu, it should use ID numbers less than F000.

    Windows automatically grays items on the standard System menu, depending on
    the situation. The application can carry out its own checking or graying by
    responding to the WM_INITMENU message, which is sent before any menu is
    displayed.
--*/

ULONG FASTCALL WU32GetSystemMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETSYSTEMMENU16 parg16;

    GETARGPTR(pFrame, sizeof(GETSYSTEMMENU16), parg16);

    ul = GETHMENU16(GetSystemMenu(HWND32(parg16->f1),
                                  BOOL32(parg16->f2)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL HiliteMenuItem(<hwnd>, <hMenu>, <wIDHiliteItem>, <wHilite>)
    HWND <hwnd>;
    HMENU <hMenu>;
    WORD <wIDHiliteItem>;
    WORD <wHilite>;

    The %HiliteMenuItem% function highlights or removes the highlighting from a
    top-level (menu-bar) menu item.

    <hwnd>
        Identifies the window that contains the menu.

    <hMenu>
        Identifies the top-level menu that contains the item to be
        highlighted.

    <wIDHiliteItem>
        Specifies the integer identifier of the menu item or the offset
        of the menu item in the menu, depending on the value of the <wHilite>
        parameter.

    <wHilite>
        Specifies whether the menu item is highlighted or the highlight
        is removed. It can be a combination of MF_HILITE or MF_UNHILITE with
        MF_BYCOMMAND or MF_BYPOSITION. The values can be combined using the
        bitwise OR operator. These values have the following meanings:

    MF_BYCOMMAND
        Interprets wIDHiliteItem as the menu-item ID (the default
        interpretation).

    MF_BYPOSITION
        Interprets <wIDHiliteItem> as an offset.

    MF_HILITE
        Highlights the item. If this value is not given, highlighting is removed
        from the item.

    MF_UNHILITE
        Removes highlighting from the item.

    The return value specifies whether or not the menu item is highlighted the
    outcome of the function. It is TRUE if the item is highlighted was set to
    the specified highlight state. Otherwise, it is FALSE.

    The MF_HILITE and MF_UNHILITE flags can be used only with the
    %HiliteMenuItem% function; they cannot be used with the %ModifyMenu%
    function.
--*/

ULONG FASTCALL WU32HiliteMenuItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PHILITEMENUITEM16 parg16;

    GETARGPTR(pFrame, sizeof(HILITEMENUITEM16), parg16);

    ul = GETBOOL16(HiliteMenuItem(
    HWND32(parg16->f1),
    HMENU32(parg16->f2),
    WORD32(parg16->f3),
    WORD32(parg16->f4)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL InsertMenu(<hMenu>, <nPosition>, <wFlags>, <wIDNewItem>, <lpNewItem>)
    HMENU <hMenu>;
    WORD <nPosition>;
    WORD <wFlags>;
    WORD <wIDNewItem>;
    LPSTR <lpNewItem>;

    The %InsertMenu% function inserts a new menu item at the position specified
    by the <nPosition> parameter, moving other items down the menu. The
    application can specify the state of the menu item by setting values in the
    <wFlags> parameter.

    <hMenu>
        Identifies the menu to be changed.

    <nPosition>
        Specifies the menu item before which the new menu item is to be
        inserted. The interpretation of the <nPosition> parameter depends upon
        the setting of the <wFlags> parameter.

    MF_BYPOSITION
        Specifies the position of the existing menu item. The first item in the
        menu is at position zero.

        If nPosition is -1, the new menu item is appended to the end of the
        menu.

    MF_BYCOMMAND
        Specifies the command ID of the existing menu item.

    <wFlags>
        Specifies how the <nPosition> parameter is interpreted and
        information about the state of the new menu item when it is added to the
        menu. It consists of one or more values listed in the following Comments
        section.

    <wIDNewItem>
        Specifies either the command ID of the new menu item or, if
        <wFlags> is set to MF_POPUP, the menu handle of the pop-up menu.

    <lpNewItem>
        Specifies the content of the new menu item. If <wFlags> is set
        to MF_STRING (the default), then <lpNewItem> is a long pointer to a
        null-terminated string. If <wFlags> is set to MF_BITMAP instead, then
        <lpNewItem> contains a bitmap handle (%HBITMAP%) in its low-order word.
        If <wFlags> is set to MF_OWNERDRAW, <lpNewItem> specifies an
        application-supplied 32-bit value which the application can use to
        maintain additional data associated with the menu item. This 32-bit
        value is available to the application in the %itemData% member of the
        structure pointed to by the <lParam> parameter of the following
        messages:

         WM_MEASUREITEM
         WM_DRAWITEM

        These messages are sent when the menu item is initially displayed, or is
        changed.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%.

    Each of the following groups lists flags that should not be used together:

    o   MF_BYCOMMAND and MF_BYPOSITION

    o   MF_DISABLED, MF_ENABLED, and MF_GRAYED

    o   MF_BITMAP, MF_STRING, MF_OWNERDRAW, and MF_SEPARATOR

    o   MF_MENUBARBREAK and MF_MENUBREAK

    o   MF_CHECKED and MF_UNCHECKED

    The following list describes the flags which may be set in the <wFlags>
    parameter:

    MF_BITMAP
        Uses a bitmap as the item. The low-order word of the lpNewItem parameter
        contains the handle of the bitmap. MF_BYCOMMAND Specifies that the
        <nPosition> parameter gives the menu-item control ID number (default).

    MF_BYPOSITION
        Specifies that the <nPosition> parameter gives the position of the menu
        item to be changed rather than an ID number.

    MF_CHECKED
        Places a checkmark next to the menu item. If the application has
        supplied checkmark bitmaps (see the %SetMenuItemBitmaps% function),
        setting this flag displays the checkmark on bitmap next to the menu
        item.

    MF_DISABLED
        Disables the menu item so that it cannot be selected, but does not gray
        it.

    MF_ENABLED
        Enables the menu item so that it can be selected and restores it from
        its grayed state.

    MF_GRAYED
        Disables the menu item so that it cannot be selected and grays it.

    MF_MENUBARBREAK
        Same as MF_MENUBREAK except that for pop-up menus, separates the new
        column from the old column with a vertical line.

    MF_MENUBREAK
        Places the menu item on a new line for static menu-bar items. For pop-up
        menus, places the menu item in a new column, with no dividing line
        between the columns.

    MF_OWNERDRAW
        Specifies that the item is an owner-draw item. The window that owns the
        menu receives a WM_MEASUREITEM message when the menu is displayed for
        the first time to retrieve the height and width of the menu item. The
        WM_DRAWITEM message is then sent to the owner whenever the owner must
        update the visual appearance of the menu item. This option is not valid
        for a top-level menu item.

    MF_POPUP
        Specifies that the menu item has a pop-up menu associated with it. The
        <wIDNewItem> parameter specifies a handle to a pop-up menu to be
        associated with the item. Use the MF_OWNERDRAW flag to add either a
        top-level pop-up menu or a hierarchical pop-up menu to a pop-up menu
        item.

    MF_SEPARATOR
        Draws a horizontal dividing line. You can use this flag in a pop-up
        menu. This line cannot be grayed, disabled, or highlighted. Windows
        ignores the <lpNewItem> and <wIDNewItem> parameters.

    MF_STRING
        Specifies that the menu item is a character string; the <lpNewItem>
        parameter points to the string for the item.

    MF_UNCHECKED
        Does not place a checkmark next to the item (default). If the
        application has supplied checkmark bitmaps (see %SetMenuItemBitmaps%),
        setting this flag displays the "checkmark off" bitmap next to the menu
        item.
--*/

ULONG FASTCALL WU32InsertMenu(PVDMFRAME pFrame)
{
    BOOL fNeedToFreePsz5 = FALSE;
    ULONG ul;
    PSZ psz5;
    UINT w4;
    register PINSERTMENU16 parg16;

    GETARGPTR(pFrame, sizeof(INSERTMENU16), parg16);

    if (parg16->f3 & MF_BITMAP) {
        if (LOW(parg16->f5) >= 4)
            psz5 = (PSZ)HBITMAP32(LOW(parg16->f5));
        else
            psz5 = (PSZ)WORD32(parg16->f5);
    }
    else if (parg16->f3 & MF_OWNERDRAW) {
        psz5 = (PSZ)DWORD32(parg16->f5);
    }
    else if (parg16->f3 & MF_SEPARATOR) {
        // lpszNewItem is ignored when inserting a separator bar.
        psz5 = NULL;
    }
    else {
        GETPSZPTR(parg16->f5, psz5);
        fNeedToFreePsz5 = TRUE;
    }

    w4 = (parg16->f3 & MF_POPUP) ? (UINT)HMENU32(parg16->f4) : WORD32(parg16->f4);

    ul = GETBOOL16(InsertMenu(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3),
    w4,
    psz5
    ));

    if (fNeedToFreePsz5) {
        FREEPSZPTR(psz5);
    }
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HMENU LoadMenu(<hInstance>, <lpMenuName>)
    HANDLE <hInstance>;
    LPSTR <lpMenuName>;

    This function loads the menu resource named by the <lpMenuName> parameter
    from the executable file associated with the module specified by the
    <hInstance> parameter.

    <hInstance>
        Identifies an instance of the module whose executable file contains the
        menu.

    <lpMenuName>
        Points to a character string that names the menu resource. The
        string must be a null-terminated string.

    The return value identifies a menu resource if the function is successful.
    Otherwise, it is NULL.

    The <lpMenuName> parameter can contain a value created by the
    %MAKEINTRESOURCE% macro. If it does, the ID must reside in the low-order
    word of <lpMenuName>, and the high-order word must be set to zero.
--*/

ULONG FASTCALL WU32LoadMenu(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSZ psz2;
    register PLOADMENU16 parg16;
    DWORD cb;
    LPBYTE lpResData;

    LPWSTR lpUniName_Menu;

    GETARGPTR(pFrame, sizeof(LOADMENU16), parg16);
    psz2 = (PSZ)DWORD32(parg16->f2);
    GETPSZIDPTR(parg16->f2, psz2);

    if (HIWORD(psz2) != (WORD) NULL) {
        if (!(MBToWCS(psz2, -1, &lpUniName_Menu, -1, TRUE))) {
            FREEPSZIDPTR(psz2);
            FREEARGPTR(parg16);
            RETURN(ul);
        }
    }
    else {
        lpUniName_Menu = (LPWSTR) psz2;
    }

    cb = parg16->f4 * sizeof(WCHAR);    // see SizeofResource16
    if (cb && (lpResData = malloc_w(cb))) {
        ConvertMenu16(parg16->f5, lpResData, parg16->f3, cb, parg16->f4);

    ul = GETHMENU16((pfnOut.pfnServerLoadCreateMenu)(HMODINST32(parg16->f1),
                                              (LPTSTR) lpUniName_Menu,
                                              lpResData,
                                              cb,
                                              FALSE));



        free_w (lpResData);
    }

    if (HIWORD(psz2) != (WORD) NULL) {
        LocalFree (lpUniName_Menu);
    }

    FREEPSZIDPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HMENU LoadMenuIndirect(<lpMenuTemplate>)
    LPSTR <lpMenuTemplate>;

    The %LoadMenuIndirect% function loads into memory the menu named by the
    <lpMenuTemplate> parameter. The template specified by <lpMenuTemplate> is a
    header followed by a collection of one or more %MENUITEMTEMPLATE%
    structures, each of which may contain one or more menu items and pop-up
    menus.

    <lpMenuTemplate>
        Points to a menu template (which is a collection of one or more
        %MENUITEMTEMPLATE% structures).

    The return value identifies the menu if the function is successful.
    Otherwise, it is NULL.
--*/

ULONG FASTCALL WU32LoadMenuIndirect(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    DWORD cb = 0;
    PVOID pMenu32;
    PLOADMENUINDIRECT16 parg16;

    GETARGPTR(pFrame, sizeof(LOADMENUINDIRECT16), parg16);
    /*
     * we need to convert this randomly created 16-bit resource into a
     * 32-bit resource so that NT user will be able to use it.
     */
    if ((cb = (DWORD)ConvertMenu16((WORD)0x300, NULL, (VPBYTE)parg16->f1, cb, 0)) != 0) {
        pMenu32 = malloc_w(cb);
        if (pMenu32 != NULL) {
            ConvertMenu16((WORD)0x300, pMenu32, (VPBYTE)parg16->f1, cb, 0);
            ul = GETHMENU16(LoadMenuIndirect(pMenu32));
            free_w(pMenu32);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL ModifyMenu(<hMenu>, <nPosition>, <wFlags>, <wIDNewItem>, <lpNewItem>)
    HMENU <hMenu>;
    WORD <nPosition>;
    WORD <wFlags>;
    WORD <wIDNewItem>;
    LPSTR <lpNewItem>;

    The %ModifyMenu% function changes an existing menu item at the position
    specified by the <nPosition> parameter. The application specifies the new
    state of the menu item by setting values in the <wFlags> parameter. If this
    function replaces a pop-up menu associated with the menu item, it destroys
    the old pop-up menu and frees the memory used by the pop-up menu.

    <hMenu>
        Identifies the menu to be changed.

    <nPosition>
        Specifies the menu item to be changed. The interpretation of the
        <nPosition> parameter depends upon the setting of the <wFlags>
        parameter.

    MF_BYPOSITION
        Specifies the position of the existing menu item. The first item in the
        menu is at position zero.

    MF_BYCOMMAND
        Specifies the command ID of the existing menu item.

    <wFlags>
        Specifies how the <nPosition> parameter is interpreted and
        information about the changes to be made to the menu item. It consists
        of one or more values listed in the following Comments section.

    <wIDNewItem>
        Specifies either the command ID of the modified menu item or, if
        <wFlags> is set to MF_POPUP, the menu handle of the pop-up menu.

    <lpNewItem>
        Specifies the content of the changed menu item. If <wFlags> is
        set to MF_STRING (the default), then <lpNewItem> is a long pointer to a
        null-terminated string. If <wFlags> is set to MF_BITMAP instead, then
        <lpNewItem> contains a bitmap handle (%HBITMAP%) in its low-order word.
        If <wFlags> is set to MF_OWNERDRAW, <lpNewItem> specifies an
        application-supplied 32-bit value which the application can use to
        maintain additional data associated with the menu item. This 32-bit
        value is available to the application in the %itemData% field of the
        structure, pointed to by the <lParam> parameter of the following
        messages:

         WM_MEASUREITEM
         WM_DRAWITEM

        These messages are sent when the menu item is initially displayed, or is
        changed.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%. In order to change
    the attributes of existing menu items, it is much faster to use the
    %CheckMenuItem% and %EnableMenuItem% functions.

    Each of the following groups lists flags that should not be used together:

    o   MF_BYCOMMAND and MF_BYPOSITION

    o   MF_DISABLED, MF_ENABLED, and MF_GRAYED

    o   MF_BITMAP, MF_STRING, MF_OWNERDRAW, and MF_SEPARATOR

    o   MF_MENUBARBREAK and MF_MENUBREAK

    o   MF_CHECKED and MF_UNCHECKED

    The following list describes the flags which may be set in the <wFlags>
    parameter:

    MF_BITMAP
        Uses a bitmap as the menu item. The low-order word of the lpNewItem
        parameter contains the handle of the bitmap.

    MF_BYCOMMAND
        Specifies that the <nPosition> parameter gives the menu item control ID
        number. This is the default if neither MF_BYCOMMAND nor MF_POSITION is
        set.

    MF_BYPOSITION
        Specifies that the <nPosition> parameter gives the position of the menu
        item to be changed rather than an ID number.

    MF_CHECKED
        Places a checkmark next to the menu item. If the application has
        supplied checkmark bitmaps (see %SetMenuItemBitmaps%), setting this flag
        displays the checkmark on bitmap next to the menu item.

    MF_DISABLED
        Disables the menu item so that it cannot be selected, but does not gray
        it.

    MF_ENABLED
        Enables the menu item so that it can be selected and restores it from
        its grayed state.

    MF_GRAYED
        Disables the menu item so that it cannot be selected and grays it.

    MF_MENUBARBREAK
        Same as MF_MENUBREAK except that for pop-up menus, separates the new
        column from the old column with a vertical line.

    MF_MENUBREAK
        Places the menu item on a new line for static menu-bar items. For pop-up
        menus, this flag places the item in a new column, with no dividing line
        between the columns.

    MF_OWNERDRAW
        Specifies that the menu item is an owner-draw item. The window that owns
        the menu receives a WM_MEASUREITEM message when the menu is displayed
        for the first time to retrieve the height and width of the menu item.
        The WM_DRAWITEM message is then sent whenever the owner must update the
        visual appearance of the menu item. This option is not valid for a
        top-level menu item.

    MF_POPUP
        Specifies that the item has a pop-up menu associated with it. The
        <wIDNewItem> parameter specifies a handle to a pop-up menu to be
        associated with the menu item. Use this flag for adding either a
        top-level pop-up menu or adding a hierarchical pop-up menu to a pop-up
        menu item.

    MF_SEPARATOR
        Draws a horizontal dividing line. You can only use this flag in a pop-up
        menu. This line cannot be grayed, disabled, or highlighted. The
        <lpNewItem> and <wIDNewItem> parameters are ignored.

    MF_STRING
        Specifies that the menu item is a character string; the <lpNewItem>
        parameter points to the string for the menu item.

    MF_UNCHECKED
        Does not place a checkmark next to the menu item. No checkmark is the
        default if neither MF_CHECKED nor MF_UNCHECKED is set. If the
        application has supplied checkmark bitmaps (see %SetMenuItemBitmaps%),
        setting this flag displays the checkmark off bitmap next to the menu
        item.
--*/

ULONG FASTCALL WU32ModifyMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz5;
    register PMODIFYMENU16 parg16;
    UINT wIDNewItem;



    GETARGPTR(pFrame, sizeof(MODIFYMENU16), parg16);

    if (parg16->f3 & MF_BITMAP) {
        if (LOW16(parg16->f5) >= 4)
            psz5 = (PSZ)HBITMAP32(LOW(parg16->f5));
        else
            psz5 = (PSZ)WORD32(parg16->f5);
    }
    else if (parg16->f3 & MF_OWNERDRAW)
        psz5 = (PSZ)DWORD32(parg16->f5);
    else
        GETPSZPTR(parg16->f5, psz5);

    wIDNewItem = (UINT) WORD32(parg16->f4);

    if (parg16->f3 & MF_POPUP)
        wIDNewItem = (UINT) HMENU32(parg16->f4);



    ul = GETBOOL16(ModifyMenu(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3),
    wIDNewItem,
    psz5
    ));

    if ( ul == FALSE && (parg16->f3 & MF_POPUP) ) {
        //
        // PowerPoint v4.0c passes an wIDNewItem which is not a menu handle
        // when they do pass MF_POPUP.  This hack allows it to avoid the
        // error path in WINSRV.  On Win 3.1, they never validated it so it
        // got through.  Luckily they quickly modify the menu to not have
        // a popup menu soon after that.
        //
        if ( !IsMenu((HMENU) wIDNewItem) ) {
            //
            // Try again with a better sub-menu handle.
            //
            wIDNewItem = (UINT)GetSubMenu( HMENU32(parg16->f1),
                                           WORD32(parg16->f2) );

            ul = GETBOOL16(ModifyMenu( HMENU32(parg16->f1),
                                       WORD32(parg16->f2),
                                       WORD32(parg16->f3),
                                       wIDNewItem,
                                       psz5 ));
        }
    }

    FREEPSZPTR(psz5);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL RemoveMenu(<hMenu>, <nPosition>, <wFlags>)
    HMENU <hMenu>;
    WORD <nPosition>;
    WORD <wFlags>;

    The %RemoveMenu% function deletes an menu item with an associated pop-up
    menu from the menu identified by the <hMenu> parameter but does not destroy
    the handle for the pop-up menu, allowing the menu to be reused. Before
    calling this function, the application should call %GetSubMenu% to retrieve
    the pop-up menu handle.

    <hMenu>
        Identifies the menu to be changed.

    <nPosition>
        Specifies the menu item to be removed. The interpretation of the
        <nPosition> parameter depends upon the setting of the <wFlags>
        parameter.

    MF_BYCOMMAND
        Specifies the command ID of the existing menu item.

    MF_BYPOSITION
        Specifies the position of the menu item. The first item in the menu is
        at position zero.

    <wFlags>
        Specifies how the <nPosition> parameter is interpreted. It must
        be either MF_BYCOMMAND or MF_BYPOSITION.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    Whenever a menu changes (whether or not the menu resides in a window that is
    displayed), the application should call %DrawMenuBar%.
--*/

ULONG FASTCALL WU32RemoveMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PREMOVEMENU16 parg16;

    GETARGPTR(pFrame, sizeof(REMOVEMENU16), parg16);

    ul = GETBOOL16(RemoveMenu(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL SetMenu(<hwnd>, <hMenu>)
    HWND <hwnd>;
    HMENU <hMenu>;

    The %SetMenu% function sets the given window's menu to the menu specified by
    the <hMenu> parameter. If <hMenu> is NULL, the window's current menu is
    removed. The %SetMenu% function causes the window to be redrawn to reflect
    the menu change.

    <hwnd>
        Identifies the window whose menu is to be changed.

    <hMenu>
        Identifies the new menu.

    The return value specifies whether the menu is changed. It is TRUE if the
    menu is changed. Otherwise, it is FALSE.

    %SetMenu% will not destroy a previous menu. An application should call the
    %DestroyMenu% function to accomplish this task.
--*/

ULONG FASTCALL WU32SetMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETMENU16 parg16;

    GETARGPTR(pFrame, sizeof(SETMENU16), parg16);

    ul = GETBOOL16(SetMenu(
    HWND32(parg16->f1),
    HMENU32(parg16->f2)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL SetMenuItemBitmaps(<hMenu>, <nPosition>, <wFlags>,
        <hBitmapUnchecked>, <hBitmapChecked>)
    HMENU <hMenu>;
    WORD <nPosition>;
    WORD <wFlags>;
    HBITMAP <hBitmapUnchecked>;
    HBITMAP <hBitmapChecked>;

    The %SetMenuItemBitmaps% function associates the specified bitmaps with a
    menu item. Whether the menu item is checked or unchecked, Windows displays
    the appropriate bitmap next to the menu item.

    <hMenu>
        Identifies the menu to be changed.

    <nPosition>
        Specifies the menu item to be changed. If <wFlags> is set to
        MF_BYPOSITION, <nPosition> specifies the position of the menu item; the
        first item in the menu is at position 0. If <wFlags> is set to
        MF_BYCOMMAND, then <nPosition> specifies the command ID of the menu
        item.

    <wFlags>
        Specifies how the <nPosition> parameter is interpreted. It may be
        set to MF_BYCOMMAND (the default) or MF_BYPOSITION.

    <hBitmapUnchecked>
        Identifies the bitmap to be displayed when the menu item is
        not checked.

    <hBitmapChecked>
        Identifies the bitmap to be displayed when the menu item is
        checked.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.

    If either the <hBitmapUnchecked> or the <hBitmapChecked> parameters is NULL,
    then Windows displays nothing next to the menu item for the corresponding
    attribute. If both parameters are NULL, Windows uses the default checkmark
    when the item is checked and removes the checkmark when the item is
    unchecked.

    When the menu is destroyed, these bitmaps are not destroyed; it is the
    responsibility of the application to destroy them.

    The %GetMenuCheckMarkDimensions% function retrieves the dimensions of the
    default checkmark used for menu items. The application should use these
    values to determine the appropriate size for the bitmaps supplied with this
    function.
--*/

ULONG FASTCALL WU32SetMenuItemBitmaps(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETMENUITEMBITMAPS16 parg16;

    GETARGPTR(pFrame, sizeof(SETMENUITEMBITMAPS16), parg16);

    ul = GETBOOL16(SetMenuItemBitmaps(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    WORD32(parg16->f3),
    HBITMAP32(parg16->f4),
    HBITMAP32(parg16->f5)
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL TrackPopupMenu(<hMenu>, <wFlags>, <x>, <y>, <nReserved>, <hwnd>,
        <lpReserved>)

    The %TrackPopupMenu% function displays a floating pop-up menu at the
    specified location and tracks the selection of items on the pop-up menu. A
    floating pop-up menu can appear anywhere on the screen. The <hMenu>
    parameter specifies the handle of the menu to be displayed; the application
    obtains this handle by calling %CreatePopupMenu% to create a new pop-up menu
    or by calling %GetSubMenu% to retrieve the handle of a pop-up menu
    associated with an existing menu item.

    Windows sends messages generated by the menu to the window identified by the
    <hwnd> parameter.

    <hMenu>
        Identifies the pop-up menu to be displayed.

    <wFlags>
        Not used. This parameter must be set to zero.

    <x>
        Specifies the horizontal position in screen coordinates of the
        left side of the menu on the screen.

    <y>
        Specifies the vertical position in screen coordinates of the top
        of the menu on the screen.

    <nReserved>
        Is reserved and must be set to zero.

    <hwnd>
        Identifies the window which owns the pop-up menu. This window
        receives all WM_COMMAND messages from the menu.

    <lpReserved>
        Is reserved and must be set to NULL.

    The return value specifies the outcome of the function. It is TRUE if the
    function is successful. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32TrackPopupMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t7, *p7;
    register PTRACKPOPUPMENU16 parg16;

    GETARGPTR(pFrame, sizeof(TRACKPOPUPMENU16), parg16);
    p7 = GETRECT16(parg16->f7, &t7);

    ul = GETBOOL16(TrackPopupMenu(
    HMENU32(parg16->f1),
    WORD32(parg16->f2),
    INT32(parg16->f3),
    INT32(parg16->f4),
    INT32(parg16->f5),
    HWND32(parg16->f6),
    p7
    ));

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wulang.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WULANG.C
 *  WOW32 16-bit User API support
 *
 *
 *  It thunks the win 3.x language functions to NT. These functions are
 *  mainly used by the programs that are ported to various international
 *  languages.
 *
 *  History:
 *  Created 19-April-1992 by Chandan Chauhan (ChandanC)
 *
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wulang.c);


/*++
    LPSTR AnsiLower(<lpString>)
    LPSTR <lpString>;

    The %AnsiLower% function converts the given character string to
    lowercase. The conversion is made by the language driver based on the
    criteria of the current language selected by the user at setup or with the
    Control Panel.

    <lpString>
        Points to a null-terminated string or specifies single character. If
        lpString specifies single character, that character is in the low-order
        byte of the low-order word, and the high-order word is zero.

    The return value points to a converted character string if the function
    parameter is a character string. Otherwise, it is a 32-bit value that
    contains the converted character in the low-order byte of the low-order
    word.
--*/

ULONG FASTCALL WU32AnsiLower(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PANSILOWER16 parg16;

    GETARGPTR(pFrame, sizeof(ANSILOWER16), parg16);
    GETPSZIDPTR(parg16->f1, psz1);

    ul = GETLPSTRBOGUS(AnsiLower(psz1));

    if (HIWORD(psz1)) {
        ul = parg16->f1;
    }

    FREEPSZIDPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD AnsiLowerBuff(<lpString>, <nLength>)
    LPSTR <lpString>;
    WORD <nLength>;

    The %AnsiLowerBuff% function converts character string in a buffer to
    lowercase. The conversion is made by the language driver based on the
    criteria of the current language selected by the user at setup or with the
    Control Panel.

    <lpString>
        Points to a buffer containing one or more characters.

    <nLength>
        Specifies the number of characters in the buffer identified by
        the <lpString> parameter. If <nLength> is zero, the length is
        64K (65,536).

    The return value specifies the length of the converted string.
--*/

ULONG FASTCALL WU32AnsiLowerBuff(PVDMFRAME pFrame)
{
    ULONG ul;
    PBYTE pb1;
    register PANSILOWERBUFF16 parg16;

    GETARGPTR(pFrame, sizeof(ANSILOWERBUFF16), parg16);
    GETVDMPTR(parg16->f1, SIZETO64K(parg16->f2), pb1);

    ul = GETWORD16(AnsiLowerBuff(pb1, SIZETO64K(parg16->f2)));

    FLUSHVDMPTR(parg16->f1, SIZETO64K(parg16->f2), pb1);
    FREEVDMPTR(pb1);
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    LPSTR AnsiNext(<lpCurrentChar>)
    LPSTR <lpCurrentChar>;

    The %AnsiNext% function moves to the next character in a string.

    <lpCurrentChar>
        Points to a character in a null-terminated string.

    The return value points to the next character in the string, or, if there is
    no next character, to the null character at the end of the string.

    The %AnsiNext% function is used to move through strings whose characters are
    two or more bytes each (for example, strings that contain characters from a
    Japanese character set).
--*/

ULONG FASTCALL WU32AnsiNext(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PANSINEXT16 parg16;
    DWORD ret;

    GETARGPTR(pFrame, sizeof(ANSINEXT16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    ul = (ULONG) AnsiNext(psz1);

    ul = ul - (ULONG) psz1;

    ret = FETCHDWORD(parg16->f1);

    ul = MAKELONG((LOWORD(ret) + ul),HIWORD(ret));

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    LPSTR AnsiPrev(<lpStart>, <lpCurrentChar>)
    LPSTR <lpStart>;
    LPSTR <lpCurrentChar>;

    The %AnsiPrev% function moves to the previous character in a string.

    <lpStart>
        Points to the beginning of the string.

    <lpCurrentChar>
        Points to a character in a null-terminated string.

    The return value points to the previous character in the string, or to the
    first character in the string if the <lpCurrentChar> parameter is equal to
    the <lpStart> parameter.

    The %AnsiPrev% function is used to move through strings whose characters are
    two or more bytes each (for example, strings that contain characters from a
    Japanese character set).
--*/

ULONG FASTCALL WU32AnsiPrev(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    register PANSIPREV16 parg16;
    DWORD ret;
#ifdef FE_SB
    PSZ lpCurrent;
#endif // FE_SB

    GETARGPTR(pFrame, sizeof(ANSIPREV16), parg16);
    GETPSZPTR(parg16->f1, psz1);
    GETPSZPTR(parg16->f2, psz2);

#ifdef FE_SB
    if (GetSystemDefaultLangID() == 0x411) {
        lpCurrent = psz2;

        // New Win32 CharPrev code for SUR-FE
        // The following code is correct.
        // But some Japanese Windows application does not work
        // with it.
        // Jpanese WOW uses old code with bug.
        //
        // if (psz1 > psz2)
        //     return psz1

        if (psz1 == psz2) {
            ul = (ULONG)psz1;
            goto PrevExit;
        }

        if (--lpCurrent == psz1) {
            ul = (ULONG)psz1;
            goto PrevExit;
        }

        // we assume lpCurrentChar never points the second byte
        // of double byte character
        // this check makes things a little bit faster [takaok]
        if (IsDBCSLeadByte(*lpCurrent)) {
            ul = (ULONG)lpCurrent-1;
            goto PrevExit;
        }

        do {
            lpCurrent--;
            if (!IsDBCSLeadByte(*lpCurrent)) {
                lpCurrent++;
                break;
            }
        } while(lpCurrent != psz1);

        ul = (ULONG)(psz2 - (((psz2 - lpCurrent) & 1) ? 1 : 2));
    }
    else
        ul = (ULONG) AnsiPrev(psz1, psz2);
PrevExit:
#else // !FE_SB
    ul = (ULONG) AnsiPrev(psz1, psz2);
#endif // !FE_SB

    ul = (ULONG) psz2 - ul;

    ret = FETCHDWORD(parg16->f2);

    ul = MAKELONG((LOWORD(ret) - ul),HIWORD(ret));

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    LPSTR AnsiUpper(<lpString>)
    LPSTR <lpString>;

    The %AnsiUpper% function converts the given character string to
    uppercase. The conversion is made by the language driver based on the
    criteria of the current language selected by the user at setup or with the
    Control Panel.

    <lpString>
        Points to a null-terminated string or specifies single character. If
        lpString specifies a single character, that character is in the
        low-order byte of the low-order word, and the high-order word is zero.

    The return value points to a converted character string if the function
    parameter is a character string; otherwise, it is a 32-bit value that
    contains the converted character in the low-order byte of the low-order
    word.
--*/

ULONG FASTCALL WU32AnsiUpper(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PANSIUPPER16 parg16;

    GETARGPTR(pFrame, sizeof(ANSIUPPER16), parg16);
    GETPSZIDPTR(parg16->f1, psz1);

    ul = GETLPSTRBOGUS(AnsiUpper(psz1));

    if (HIWORD(psz1)) {
        ul = parg16->f1;
    }

    FREEPSZIDPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD AnsiUpperBuff(<lpString>, <nLength>)
    LPSTR <lpString>;
    WORD <nLength>;

    The %AnsiUpperBuff% function converts a character string in a buffer to
    uppercase. The conversion is made by the language driver based on the
    criteria of the current language selected by the user at setup or with the
    Control Panel.

    <lpString>
        Points to a buffer containing one or more characters.

    <nLength>
        Specifies the number of characters in the buffer identified by
        the <lpString> parameter. If <nLength> is zero, the length is 64K
        (65,536).

    The return value specifies the length of the converted string.
--*/

ULONG FASTCALL WU32AnsiUpperBuff(PVDMFRAME pFrame)
{
    ULONG ul;
    PBYTE pb1;
    register PANSIUPPERBUFF16 parg16;

    GETARGPTR(pFrame, sizeof(ANSIUPPERBUFF16), parg16);
    GETVDMPTR(parg16->f1, SIZETO64K(parg16->f2), pb1);

    ul = GETWORD16(AnsiUpperBuff(pb1, SIZETO64K(parg16->f2)));

    FLUSHVDMPTR(parg16->f1, SIZETO64K(parg16->f2), pb1);
    FREEVDMPTR(pb1);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32lstrcmp(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    register PLSTRCMP16 parg16;

    GETARGPTR(pFrame, sizeof(LSTRCMP16), parg16);
    GETPSZPTR(parg16->f1, psz1);
    GETPSZPTR(parg16->f2, psz2);

    ul = GETINT16(lstrcmp(psz1, psz2));

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32lstrcmpi(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    register PLSTRCMPI16 parg16;

    GETARGPTR(pFrame, sizeof(LSTRCMPI16), parg16);
    GETPSZPTR(parg16->f1, psz1);
    GETPSZPTR(parg16->f2, psz2);

    ul = GETINT16(lstrcmpi(psz1, psz2));

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32IsCharAlpha(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHARALPHA16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHARALPHA16), parg16);

    ul = GETBOOL16(IsCharAlpha(CHAR32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32IsCharAlphaNumeric(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHARALPHANUMERIC16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHARALPHANUMERIC16), parg16);

    ul = GETBOOL16(IsCharAlphaNumeric(CHAR32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32IsCharLower(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHARLOWER16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHARLOWER16), parg16);

    ul = GETBOOL16(IsCharLower(CHAR32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32IsCharUpper(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHARUPPER16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHARUPPER16), parg16);

    ul = GETBOOL16(IsCharUpper(CHAR32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wumsg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMSG.H
 *  WOW32 16-bit User Message API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/

#define WOWDDE_POSTMESSAGE TRUE

extern BOOL fWhoCalled;

ULONG FASTCALL   WU32CallMsgFilter(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CallWindowProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DefDlgProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DefFrameProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DefMDIChildProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DefWindowProc(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DispatchMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetMessagePos(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetMessageTime(PVDMFRAME pFrame);
ULONG FASTCALL   WU32InSendMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32PeekMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32PostAppMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32PostMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32PostQuitMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32RegisterWindowMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ReplyMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SendDlgItemMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SendMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32TranslateAccelerator(PVDMFRAME pFrame);
ULONG FASTCALL   WU32TranslateMDISysAccel(PVDMFRAME pFrame);
ULONG FASTCALL   WU32TranslateMessage(PVDMFRAME pFrame);
ULONG FASTCALL   WU32WaitMessage(PVDMFRAME pFrame);

VOID    SetFakeDialogClass(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wumsg.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUMSG.C
 *  WOW32 16-bit User Message API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop


MODNAME(wumsg.c);


extern HANDLE hmodWOW32;

// SendDlgItemMessage cache
HWND  hdlgSDIMCached = NULL ;

BOOL fWhoCalled = FALSE;



// DDE bit used in GetMessage and PeekMessage

#define fAckReq 0x8000
#define fRelease 0x2000



/*++
    BOOL CallMsgFilter(<lpMsg>, <nCode>)
    LPMSG <lpMsg>;
    int <nCode>;

    The %CallMsgFilter% function passes the given message and code to the
    current message filter function. The message filter function is an
    application-specified function that examines and modifies all messages. An
    application specifies the function by using the %SetWindowsHook% function.

    <lpMsg>
        Points to an %MSG% structure that contains the message to be
        filtered.

    <nCode>
        Specifies a code used by the filter function to determine how to
        process the message.

    The return value specifies the state of message processing. It is FALSE if
    the message should be processed. It is TRUE if the message should not be
    processed further.

    The %CallMsgFilter% function is usually called by Windows to let
    applications examine and control the flow of messages during internal
    processing in menus and scroll bars or when moving or sizing a window.

    Values given for the <nCode> parameter must not conflict with any of the
    MSGF_ and HC_ values passed by Windows to the message filter function.
--*/

ULONG FASTCALL WU32CallMsgFilter(PVDMFRAME pFrame)
{
    INT   f2;
    ULONG ul;
    MSG t1;
    VPMSG16 vpf1;
    register PCALLMSGFILTER16 parg16;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(CALLMSGFILTER16), parg16);

    vpf1 = (VPMSG16)(parg16->f1);
    f2   = INT32(parg16->f2);

    getmsg16(vpf1, &t1, &mpex);

    // Note: getmsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    BlockWOWIdle(TRUE);

    ul = GETBOOL16(CallMsgFilter(&t1, f2));

    // Note: Call to CallMsgFilter may have caused 16-bit memory to move

    BlockWOWIdle(FALSE);

    // we need to free the struct ret'd by PackDDElParam in the getmsg16 call
    // (actually the call is made in ThunkWMMsg16() which is called by getmsg16)
    if((t1.message >= WM_DDE_FIRST) && (t1.message <= WM_DDE_LAST)) {
        if(t1.message == WM_DDE_ACK       ||
           t1.message == WM_DDE_DATA      ||
           t1.message == WM_DDE_POKE      ||
           t1.message == WM_DDE_ADVISE )            {

            // make sure this isn't in response to an initiate message
            if(!WI32DDEInitiate((HWND16) mpex.Parm16.WndProc.hwnd)) {
                FreeDDElParam(t1.message, t1.lParam);
            }
        }
    }

    FREEMSG16(vpf1, &t1);

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    LONG CallWindowProc(<lpPrevWndFunc>, <hwnd>, <wMsg>, <wParam>, <lParam>)
    FARPROC <lpPrevWndFunc>;
    HWND <hwnd>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %CallWindowProc% function passes message information to the function
    specified by the <lpPrevWndFunc> parameter. The %CallWindowProc% function is
    used for window subclassing. Normally, all windows with the same class share
    the same window function. A subclass is a window or set of windows belonging
    to the same window class whose messages are intercepted and processed by
    another function (or functions) before being passed to the window function
    of that class.

    The %SetWindowLong% function creates the subclass by changing the window
    function associated with a particular window, causing Windows to call the
    new window function instead of the previous one. Any messages not processed
    by the new window function must be passed to the previous window function by
    calling %CallWindowProc%. This allows a chain of window functions to be
    created.

    <lpPrevWndFunc>
        Is the procedure-instance address of the previous window function.

    <hwnd>
        Identifies the window that receives the message.

    <wMsg>
        Specifies the message number.

    <wParam>
        Specifies additional message-dependent information.

    <lParam>
        Specifies additional message-dependent information.

    The return value specifies the result of the message processing. The
    possible return values depend on the message sent.
--*/

ULONG FASTCALL WU32CallWindowProc(PVDMFRAME pFrame)
{
    ULONG ul;
    PARM16 Parm16;
    register PCALLWINDOWPROC16 parg16;
    WORD  f2, f3, f4;
    LONG  f5;
    DWORD Proc16;
    DWORD Proc32;
    INT  iMsgThunkClass = 0;

    ul = FALSE;
    GETARGPTR(pFrame, sizeof(CALLWINDOWPROC16), parg16);

    Proc16 = DWORD32(parg16->f1);
    f2     = parg16->f2;
    f3     = WORD32(parg16->f3);
    f4     = WORD32(parg16->f4);
    f5     = LONG32(parg16->f5);

    Proc32 = IsThunkWindowProc(Proc16, &iMsgThunkClass);

    // Note: IsThunkWindowProc may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    if (Proc32) {
        HWND hwnd;
        UINT uMsgNew;
        UINT uParamNew;
        LONG lParamNew;
        MSGPARAMEX mpex;

        mpex.Parm16.WndProc.hwnd   = f2;
        mpex.Parm16.WndProc.wMsg   = f3;
        mpex.Parm16.WndProc.wParam = f4;
        mpex.Parm16.WndProc.lParam = f5;
        mpex.iMsgThunkClass = iMsgThunkClass;

        if (hwnd = ThunkMsg16(&mpex)) {

            // Note: ThunkMsg16 may have caused 16-bit memory movement
            // But: we haven't refreshed them since freeing after IsThunkWindowProc above.
            // FREEARGPTR(pFrame);
            // FREEARGPTR(parg16);

            uMsgNew = mpex.uMsg;
            uParamNew = mpex.uParam;
            lParamNew = mpex.lParam;

            //
            // see comment in IsMDIChild()
            //

            if ((uMsgNew == WM_CREATE || uMsgNew == WM_NCCREATE) && iMsgThunkClass == WOWCLASS_MDICLIENT) {
                    FinishThunkingWMCreateMDI16(lParamNew,
                             (LPCLIENTCREATESTRUCT)((LPCREATESTRUCT)lParamNew + 1));
            }

            BlockWOWIdle(TRUE);

            ul = CallWindowProc((WNDPROC)Proc32, hwnd, uMsgNew,
                                                      uParamNew, lParamNew);
            BlockWOWIdle(FALSE);

            if ((uMsgNew == WM_CREATE || uMsgNew == WM_NCCREATE) && iMsgThunkClass == WOWCLASS_MDICLIENT) {
                StartUnThunkingWMCreateMDI16(lParamNew); // does nothing
            }

            if (MSG16NEEDSTHUNKING(&mpex)) {
                mpex.lReturn = ul;
                (mpex.lpfnUnThunk16)(&mpex);
                ul = mpex.lReturn;
            }
        }
    }
    else {
        Parm16.WndProc.hwnd   = f2;
        Parm16.WndProc.wMsg   = f3;
        Parm16.WndProc.wParam = f4;
        Parm16.WndProc.lParam = f5;
        Parm16.WndProc.hInst  = (WORD)GetWindowLong(HWND32(f2), GWL_HINSTANCE);
        CallBack16(RET_WNDPROC, &Parm16, VPFN32(Proc16), (PVPVOID)&ul);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}






/*++
    LONG DefDlgProc(<hDlg>, <wMsg>, <wParam>, <lParam>)
    HWND <hDlg>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %DefDlgProc% function provides default processing for any Windows
    messages that a dialog box with a private window class does not process.

    All window messages that are not explicitly processed by the window function
    must be passed to the %DefDlgProc% function, not the %DefWindowProc%
    function. This ensures that all messages not handled by their private window
    procedure will be handled properly.

    <hDlg>
        Identifies the dialog box.

    <wMsg>
        Specifies the message number.

    <wParam>
        Specifies 16 bits of additional message-dependent information.

    <lParam>
        Specifies 32 bits of additional message-dependent information.

    The return value specifies the result of the message processing and depends
    on the actual message sent.

    The source code for the %DefDlgProc% function is provided on the SDK disks.

    An application creates a dialog box by calling one of the following
    functions:

    %CreateDialog%
        Creates a modeless dialog box.

    %CreateDialogIndirect%
        Creates a modeless dialog box.

    %CreateDialogIndirectParam%
        Creates a modeless dialog box and passes data to it when it is created.

    %CreateDialogParam%
        Creates a modeless dialog box and passes data to it when it is created.

    %DialogBox%
        Creates a modal dialog box.

    %DialogBoxIndirect%
        Creates a modal dialog box.

    %DialogBoxIndirectParam%
        Creates a modal dialog box and passes data to it when it is created.

    %DialogBoxParam%
        Creates a modal dialog box and passes data to it when it is created.
--*/

ULONG FASTCALL WU32DefDlgProc(PVDMFRAME pFrame)
{
    HWND hdlg;
    MSGPARAMEX mpex;
    register PDEFDLGPROC16 parg16;

    GETARGPTR(pFrame, sizeof(DEFDLGPROC16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->f1;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f2);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->f3);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->f4);
    mpex.iMsgThunkClass = 0;

    if (hdlg = ThunkMsg16(&mpex)) {

        // Note: ThunkMsg16 may have caused 16-bit memory movement
        FREEARGPTR(pFrame);
        FREEARGPTR(parg16);

        BlockWOWIdle(TRUE);
        mpex.lReturn = DefDlgProc(hdlg, mpex.uMsg, mpex.uParam, mpex.lParam);
        BlockWOWIdle(FALSE);

        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}









/*++
    LONG DefFrameProc(<hwnd>, <hwndMDIClient>, <wMsg>, <wParam>, <lParam>)
    HWND <hwnd>;
    HWND <hwndMDIClient>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %DefFrameProc% function provides default processing for any Windows
    messages that the window function of a multiple document interface (MDI)
    frame window does not process. All window messages that are not explicitly
    processed by the window function must be passed to the %DefFrameProc%
    function, not the %DefWindowProc% function.

    <hwnd>
        Identifies the MDI frame window.

    <hwndMDIClient>
        Identifies the MDI client window.

    <wMsg>
        Specifies the message number.

    <wParam>
        Specifies 16 bits of additional message-dependent information.

    <lParam>
        Specifies 32 bits of additional message-dependent information.

    The return value specifies the result of the message processing and depends
    on the actual message sent. If the <hwndMDIClient> parameter is NULL, the
    return value is the same as for the %DefWindowProc% function.

    Normally, when an application's window procedure does not handle a message,
    it passes the message to the %DefWindowProc% function, which processes the
    message. MDI applications use the %fDefFrameProc% and %DefMDIChildProc%
    functions instead of %DefWindowProc% to provide default message processing.
    All messages that an application would normally pass to %DefWindowProc%
    (such as nonclient messages and WM_SETTEXT) should be passed to
    %DefFrameProc% instead. In addition to these, %DefFrameProc% also handles
    the following messages:

    WM_COMMAND
        The frame window of an MDI application receives the WM_COMMAND message
        to activate a particular MDI child window. The window ID accompanying
        this message will be the ID of the MDI child window assigned by Windows,
        starting with the first ID specified by the application when it created
        the MDI client window. This value of the first ID must not conflict with
        menu-item IDs.

    WM_MENUCHAR
        When the ^ALTHYPHEN^ key is pressed, the control menu of the active MDI
        child window will be selected.

    WM_SETFOCUS
        %DefFrameProc% passes focus on to the MDI client, which in turn passes
        the focus on to the active MDI child window.

    WM_SIZE
        If the frame window procedure passes this message to %DefFrameProc%, the
        MDI client window will be resized to fit in the new client area. If the
        frame window procedure sizes the MDI client to a different size, it
        should not pass the message to %DefWindowProc%.
--*/

ULONG FASTCALL WU32DefFrameProc(PVDMFRAME pFrame)
{
    HWND hwnd, hwnd2;

    MSGPARAMEX mpex;
    register PDEFFRAMEPROC16 parg16;

    GETARGPTR(pFrame, sizeof(DEFFRAMEPROC16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->f1;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f3);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->f4);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->f5);
    mpex.iMsgThunkClass = 0;

    hwnd2 = HWND32(parg16->f2);

    if (hwnd = ThunkMsg16(&mpex)) {

        // Note: ThunkMsg16 may have caused 16-bit memory movement
        FREEARGPTR(pFrame);
        FREEARGPTR(parg16);

        if (mpex.uMsg == WM_CLIENTSHUTDOWN &&
            CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_IGNORECLIENTSHUTDOWN) {

            //
            // TurboCAD picks up an uninitialized stack variable as the
            // message number to pass to DefFrameProc.  In NT 3.51 it
            // got 0x907 so the call was a NOP.  In NT 4.0, because we
            // now save FS and GS in wow16call, they pick up the x86
            // flat FS, 0x3b, which also happens to be WM_CLIENTSHUTDOWN
            // on NT and Win95, an undocumented message.  DefFrameProc
            // passes the message to DefWindowProc, which does some
            // shutdown related processing which causes TurboCAD to fault
            // soon thereafter.
            //
            // We considered renumbering WM_CLIENTSHUTDOWN, but Win95 uses
            // it as well and some apps may have reverse-engineered the
            // value 3b and depend on seeing the message.
            //
            // So instead we eat the call to DefFrameProc here under
            // a compatibility bit.
            //                            -- DaveHart 31-May-96
            //

            mpex.lReturn = 0;

        } else {

            BlockWOWIdle(TRUE);
            mpex.lReturn = DefFrameProc(hwnd, hwnd2,
                                        mpex.uMsg, mpex.uParam, mpex.lParam);
            BlockWOWIdle(FALSE);
        }

        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}










/*++
    LONG DefMDIChildProc(<hwnd>, <wMsg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %DefMDIChildProc% function provides default processing for any Windows
    messages that the window function of a multiple document interface (MDI)
    child window does not process. All window messages that are not explicitly
    processed by the window function must be passed to the %DefMDIChildProc%
    function, not the %DefWindowProc% function.

    <hwnd>
        Identifies the MDI child window.

    <wMsg>
        Specifies the message number.

    <wParam>
        Specifies 16 bits of additional message-dependent information.

    <lParam>
        Specifies 32 bits of additional message-dependent information.

    The return value specifies the result of the message processing and depends
    on the actual message sent.

    This function assumes that the parent of the window identified by the <hwnd>
    parameter was created with the MDICLIENT class.

    Normally, when an application's window procedure does not handle a message,
    it passes the message to the %DefWindowProc% function, which processes the
    message. MDI applications use the %DefFrameProc% and %DefMDIChildProc%
    functions instead of %DefWindowProc% to provide default message processing.
    All messages that an application would normally pass to %DefWindowProc%
    (such as nonclient messages and WM_SETTEXT) should be passed to
    %DefMDIChildProc% instead. In addition to these, %DefMDIChildProc% also
    handles the following messages:

    WM_CHILDACTIVATE
        Performs activation processing when child windows are sized, moved, or
        shown. This message must be passed.

    WM_GETMINMAXINFO
        Calculates the size of a maximized MDI child window based on the current
        size of the MDI client window.

    WM_MENUCHAR
        Sends the key to the frame window.

    WM_MOVE
        Recalculates MDI client scroll bars, if they are present.

    WM_SETFOCUS
        Activates the child window if it is not the active MDI child.

    WM_SIZE
        Performs necessary operations when changing the size of a window,
        especially when maximizing or restoring an MDI child window. Failing to
        pass this message to %DefMDIChildProc% will produce highly undesirable
        results.

    WM_SYSCOMMAND
        Also handles the next window command.
--*/

ULONG FASTCALL WU32DefMDIChildProc(PVDMFRAME pFrame)
{
    HWND hwnd;
    register PDEFMDICHILDPROC16 parg16;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(DEFMDICHILDPROC16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->f1;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f2);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->f3);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->f4);
    mpex.iMsgThunkClass = 0;

    if (hwnd = ThunkMsg16(&mpex)) {

        // Note: ThunkMsg16 may have caused 16-bit memory movement
        FREEARGPTR(pFrame);
        FREEARGPTR(parg16);

        BlockWOWIdle(TRUE);
        mpex.lReturn = DefMDIChildProc(hwnd, mpex.uMsg, mpex.uParam,
                                                                mpex.lParam);
        BlockWOWIdle(FALSE);

        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}










/*++
    LONG DefWindowProc(<hwnd>, <wMsg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %DefWindowProc% function calls the default window procedure. The
    default window procedure provides default processing for any window messages
    that an application does not process. This function is used to ensure that
    every message is processed. It should be called with the same parameters as
    those received by the window procedure.

    <hwnd>
        Identifies the window that received the message.

    <wMsg>
        Specifies the message.

    <wParam>
        Specifies 16 bits of additional message-dependent information.

    <lParam>
        Specifies 32 bits of additional message-dependent information.

    The return value is dependent on the message that was passed to this
    function.
--*/

ULONG FASTCALL WU32DefWindowProc(PVDMFRAME pFrame)
{
    HWND hwnd;
    register PDEFWINDOWPROC16 parg16;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(DEFWINDOWPROC16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->hwnd;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->wMsg);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->wParam);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->lParam);
    mpex.iMsgThunkClass = 0;

    if (hwnd = ThunkMsg16(&mpex)) {

        // Note: ThunkMsg16 may have caused 16-bit memory movement
        FREEARGPTR(pFrame);
        FREEARGPTR(parg16);

        BlockWOWIdle(TRUE);
        mpex.lReturn = DefWindowProc(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam);
        BlockWOWIdle(FALSE);

        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}










/*++
    LONG DispatchMessage(<lpMsg>)
    LPMSG <lpMsg>;

    The %DispatchMessage% function passes the message in the %MSG% structure
    pointed to by the <lpMsg> parameter to the window function of the specified
    window.

    <lpMsg>
        Points to an %MSG% structure that contains message information from
        the Windows application queue.

        The structure must contain valid message values. If <lpMsg> points to a
        WM_TIMER message and the <lParam> parameter of the WM_TIMER message is
        not NULL, then the <lParam> parameter is the address of a function that
        is called instead of the window function.

    The return value specifies the value returned by the window function. Its
    meaning depends on the message being dispatched, but generally the return
    value is ignored.
--*/

ULONG FASTCALL WU32DispatchMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    WORD  wTDB;
    MSG t1;
    register PDISPATCHMESSAGE16 parg16;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(DISPATCHMESSAGE16), parg16);

    wTDB = pFrame->wTDB;

    getmsg16(parg16->f1, &t1, &mpex);

    // Note: getmsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    if (CACHENOTEMPTY() && !(CURRENTPTD()->dwWOWCompatFlags & WOWCF_DONTRELEASECACHEDDC)) {

        ReleaseCachedDCs(wTDB, 0, 0, 0, SRCHDC_TASK16);
    }

    BlockWOWIdle(TRUE);

    ul = GETLONG16(DispatchMessage(&t1));

    BlockWOWIdle(FALSE);

    // WARNING Don't rely on any 32 bit flat pointers to 16 bit memory
    // After the dispatchmessage call.

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    BOOL GetMessage(<lpMsg>, <hwnd>, <wMsgFilterMin>, <wMsgFilterMax>)
    LPMSG <lpMsg>;
    HWND <hwnd>;
    WORD <wMsgFilterMin>;
    WORD <wMsgFilterMax>;

    The %GetMessage% function retrieves a message from the application queue and
    places the message in the structure pointed to by the <lpMsg> parameter. If
    no message is available, the %GetMessage% function yields control to other
    applications until a message becomes available.

    %GetMessage% retrieves only messages associated with the window specified by
    the <hwnd> parameter and within the range of message values given by the
    <wMsgFilterMin> and <wMsgFilterMax> parameters. If <hwnd> is NULL,
    %GetMessage% retrieves messages for any window that belongs to the
    application making the call. (The %GetMessage% function does not retrieve
    messages for windows that belong to other applications.) If <wMsgFilterMin>
    and <wMsgFilterMax> are both zero, %GetMessage% returns all available
    messages (no filtering is performed).

    The constants WM_KEYFIRST and WM_KEYLAST can be used as filter values to
    retrieve all messages related to keyboard input; the constants WM_MOUSEFIRST
    and WM_MOUSELAST can be used to retrieve all mouse-related messages.

    <lpMsg>
        Points to an %MSG% structure that contains message information from
        the Windows application queue.

    <hwnd>
        Identifies the window whose messages are to be examined. If
        <hwnd> is NULL, %GetMessage% retrieves messages for any window that
        belongs to the application making the call.

    <wMsgFilterMin>
        Specifies the integer value of the lowest message value to be
        retrieved.

    <wMsgFilterMax>
        Specifies the integer value of the highest message value to be
        retrieved.

    The return value is TRUE if a message other than WM_QUIT is retrieved. It is
    FALSE if the WM_QUIT message is retrieved.

    The return value is usually used to decide whether to terminate the
    application's main loop and exit the program.

    In addition to yielding control to other applications when no messages are
    available, the %GetMessage% and %PeekMessage% functions also yield control
    when WM_PAINT or WM_TIMER messages for other tasks are available.

    The %GetMessage%, %PeekMessage%, and %WaitMessage% functions are the only
    ways to let other applications run. If your application does not call any of
    these functions for long periods of time, other applications cannot run.

    When %GetMessage%, %PeekMessage%, and %WaitMessage% yield control to other
    applications, the stack and data segments of the application calling the
    function may move in memory to accommodate the changing memory requirements
    of other applications. If the application has stored long pointers to
    objects in the data or stack segment (that is, global or local variables),
    these pointers can become invalid after a call to %GetMessage%,
    %PeekMessage%, or %WaitMessage%. The <lpMsg> parameter of the called
    function remains valid in any case.
--*/

ULONG FASTCALL WU32GetMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t1;
    VPMSG16  vpMsg;
    register PGETMESSAGE16 parg16;
    ULONG ulReturn;

    BlockWOWIdle(TRUE);

// NOTE: pFrame needs to be restored on all GOTO's to get_next_dde_message
get_next_dde_message:

    GETARGPTR(pFrame, sizeof(GETMESSAGE16), parg16);

    vpMsg = parg16->vpMsg;


    ul = GETBOOL16(GetMessage(&t1,
                              HWND32(parg16->hwnd),
                              WORD32(parg16->wMin),
                              WORD32(parg16->wMax)));

    // There Could have been a Task Switch Before GetMessage Returned so
    // Don't Trust any 32 bit flat pointers we have, memory could've been
    // compacted or moved.
    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);


#ifdef DEBUG
    if (t1.message == WM_TIMER) {
        WOW32ASSERT(HIWORD(t1.wParam) == 0);
    }
#endif

    ulReturn = putmsg16(vpMsg, &t1);

    // NOTE: Call to putmsg16 could've caused 16-bit memory movement

    if (((t1.message == WM_DDE_DATA) || (t1.message == WM_DDE_POKE)) && (!ulReturn)) {
        register PMSG16 pmsg16;
        DDEDATA *lpMem32;
        WORD Status;
        UINT dd;
        WORD ww;
        char szMsgBoxText[1024];
        char szCaption[256];

        GETVDMPTR(vpMsg, sizeof(MSG16), pmsg16);

        dd = FETCHDWORD(pmsg16->lParam);
        ww = FETCHWORD(pmsg16->wParam);

        lpMem32 = GlobalLock((HGLOBAL)dd);
        Status = (*((PWORD) lpMem32));
        GlobalUnlock((HGLOBAL)dd);

        (pfnOut.pfnFreeDDEData)((HANDLE)dd, TRUE, TRUE);

        GlobalDeleteAtom (ww);

        if ((Status & fAckReq) || (t1.message == WM_DDE_POKE)) {
            LoadString(hmodWOW32, iszOLEMemAllocFailedFatal, szMsgBoxText, sizeof szMsgBoxText);
            LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
            MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK | MB_SETFOREGROUND | MB_TOPMOST);
            PostMessage((HWND) t1.wParam, WM_DDE_TERMINATE, (WPARAM)FULLHWND32((WORD)t1.hwnd), (LPARAM)0l);
        }
        else {
            LoadString(hmodWOW32, iszOLEMemAllocFailed, szMsgBoxText, sizeof szMsgBoxText);
            LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
            MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK | MB_SETFOREGROUND | MB_TOPMOST);
        }

        FREEVDMPTR(pmsg16);

        // restore the frame ptr due to possible 16-bit memory movement
        GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);

        goto get_next_dde_message;
    }

    BlockWOWIdle(FALSE);

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);
    RETURN(ul);
}







/*++
    DWORD GetMessagePos(VOID)

    The %GetMessagePos% function returns a long value that represents the cursor
    position (in screen coordinates) when the last message obtained by the
    %GetMessage% function occurred.

    This function has no parameters.

    The return value specifies the <x>- and <y>-coordinates of the cursor
    position. The <x>-coordinate is in the low-order word, and the
    <y>-coordinate is in the high-order word. If the return value is assigned to
    a variable, the %MAKEPOINT% macro can be used to obtain a %POINT% structure
    from the return value; the %LOWORD% or %HIWORD% macro can be used to extract
    the <x>- or the <y>-coordinate.

    To obtain the current position of the cursor instead of the position when
    the last message occurred, use the %GetCursorPos% function.
--*/

ULONG FASTCALL WU32GetMessagePos(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETDWORD16(GetMessagePos());

    RETURN(ul);
}







/*++
    DWORD GetMessageTime(VOID)

    The %GetMessageTime% function returns the message time for the last message
    retrieved by the %GetMessage% function. The time is a long integer that
    specifies the elapsed time (in milliseconds) from the time the system was
    booted to the time the message was created (placed in the application
    queue).

    This function has no parameters.

    The return value specifies the message time.

    Do not assume that the return value is always increasing. The return value
    will wrap around to zero if the timer count exceeds the maximum value for
    long integers.

    To calculate time delays between messages, subtract the time of the second
    message from the time of the first message.
--*/

ULONG FASTCALL WU32GetMessageTime(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETLONG16(GetMessageTime());

    RETURN(ul);
}







/*++
    BOOL InSendMessage(VOID)

    The %InSendMessage% function specifies whether the current window function
    is processing a message that is passed to it through a call to the
    %SendMessage% function.

    This function has no parameters.

    The return value specifies the outcome of the function. It is TRUE if the
    window function is processing a message sent to it with %SendMessage%.
    Otherwise, it is FALSE.

    Applications use the %InSendMessage% function to determine how to handle
    errors that occur when an inactive window processes messages. For example,
    if the active window uses %SendMessage% to send a request for information to
    another window, the other window cannot become active until it returns
    control from the %SendMessage% call. The only method an inactive window has
    to inform the user of an error is to create a message box.
--*/

ULONG FASTCALL WU32InSendMessage(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETBOOL16(InSendMessage());

    RETURN(ul);
}







/*++
    BOOL PeekMessage(<lpMsg>, <hwnd>, <wMsgFilterMin>, <wMsgFilterMax>,
        <wRemoveMsg>)
    LPMSG <lpMsg>;
    HWND <hwnd>;
    WORD <wMsgFilterMin>;
    WORD <wMsgFilterMax>;
    WORD <wRemoveMsg>;

    The %PeekMessage% function checks the application queue for a message and
    places the message (if any) in the structure pointed to by the <lpMsg>
    parameter. Unlike the %GetMessage% function, the %PeekMessage% function does
    not wait for a message to be placed in the queue before returning. It does,
    however, yield control (if the PM_NOYIELD flag isn't set) and does not
    return control after the yield until Windows returns control to the
    application.

    %PeekMessage% retrieves only messages associated with the window specified
    by the <hwnd> parameter, or any of its children as specified by the
    %IsChild% function, and within the range of message values given by the
    <wMsgFilterMin> and <wMsgFilterMax> parameters. If <hwnd> is NULL,
    %PeekMessage% retrieves messages for any window that belongs to the
    application making the call. (The %PeekMessage% function does not retrieve
    messages for windows that belong to other applications.) If <hwnd> is -1,
    %PeekMessage% returns only messages with a <hwnd> of NULL as posted by the
    %PostAppMessage% function. If <wMsgFilterMin> and <wMsgFilterMax> are both
    zero, %PeekMessage% returns all available messages (no range filtering is
    performed).

    The WM_KEYFIRST and WM_KEYLAST flags can be used as filter values to
    retrieve all key messages; the WM_MOUSEFIRST and WM_MOUSELAST flags can be
    used to retrieve all mouse messages.

    <lpMsg>
        Points to an %MSG% structure that contains message information from
        the Windows application queue.

    <hwnd>
        Identifies the window whose messages are to be examined.

    <wMsgFilterMin>
        Specifies the value of the lowest message position to be
        examined.

    <wMsgFilterMax>
        Specifies the value of the highest message position to be
        examined.

    <wRemoveMsg>
        Specifies a combination of the flags described in the following
        list. PM_NOYIELD can be combined with either PM_NOREMOVE or PM_REMOVE:

    PM_NOREMOVE
        Messages are not removed from the queue after processing by
        PeekMessage.

    PM_NOYIELD
        Prevents the current task from halting and yielding system resources to
        another task.

    PM_REMOVE
        Messages are removed from the queue after processing by %PeekMessage%.

    The return value specifies whether or not a message is found. It is TRUE if
    a message is available. Otherwise, it is FALSE.

    %PeekMessage% does not remove WM_PAINT messages from the queue. The messages
    remain in the queue until processed. The %GetMessage%, %PeekMessage%, and
    %WaitMessage% functions yield control to other applications. These calls are
    the only way to let other applications run. If your application does not
    call any of these functions for long periods of time, other applications
    cannot run.

    When %GetMessage%, %PeekMessage%, and %WaitMessage% yield control to other
    applications, the stack and data segments of the application calling the
    function may move in memory to accommodate the changing memory requirements
    of other applications.

    If the application has stored long pointers to objects in the data or stack
    segment (global or local variables), and if they are unlocked, these
    pointers can become invalid after a call to %GetMessage%, %PeekMessage%, or
    %WaitMessage%. The <lpMsg> parameter of the called function remains valid in
    any case.
--*/

ULONG FASTCALL WU32PeekMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    VPMSG16 vpf1;
    HANDLE  f2;
    WORD    f3, f4, f5;
    MSG t1;
    register PPEEKMESSAGE16 parg16;
    BOOL fNoYield;

    BlockWOWIdle(TRUE);

// NOTE: pFrame needs to be restored on all GOTO's to get_next_dde_message
get_next_dde_message:

    GETARGPTR(pFrame, sizeof(PEEKMESSAGE16), parg16);

    vpf1 = parg16->f1;
    f2   = HWND32(parg16->f2);
    f3   = WORD32(parg16->f3);
    f4   = WORD32(parg16->f4);
    f5   = parg16->f5;

    fNoYield = f5 & PM_NOYIELD;

    ul = GETBOOL16(PeekMessage(&t1, f2, f3, f4, f5));

    // There could've been a task switch before peekmessage returned
    // so Don't trust any 32 bit flat pointers we have, memory could
    // have been compacted or moved.
    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

#ifdef DEBUG
    if (ul && t1.message == WM_TIMER) {
        WOW32ASSERT(HIWORD(t1.wParam) == 0);
    }
#endif

    // If PeekMessage returned NULL don't bother to copy anything back

    if (ul) {
        ULONG ulReturn;

        //
        // We need to set/reset fThunkDDEmsg (based on PM_REMOVE flag)
        // so that we know whether to call FreeDDElParam or not while
        // thunking 32 bit message to 16 bit message.
        //

        fThunkDDEmsg = (BOOL) (f5 & PM_REMOVE);
        ulReturn = putmsg16(vpf1, &t1);

        // There Could've been a Task Switch Before putmsg16 Returned so Don't
        // Trust any 32 bit flat pointers we have, memory could have been
        // compacted or moved.
        FREEARGPTR(parg16);
        FREEVDMPTR(pFrame);

        fThunkDDEmsg = TRUE;

        if (((t1.message == WM_DDE_DATA) || (t1.message == WM_DDE_POKE)) && (!ulReturn)) {
            register PMSG16 pmsg16;
            DDEDATA *lpMem32;
            WORD Status;
            UINT dd;
            WORD ww;
            char szMsgBoxText[1024];
            char szCaption[256];

            GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);

            dd = FETCHDWORD(pmsg16->lParam);
            ww = FETCHWORD(pmsg16->wParam);

            lpMem32 = GlobalLock((HGLOBAL)dd);
            Status = (*((PWORD) lpMem32));
            GlobalUnlock((HGLOBAL)dd);

            (pfnOut.pfnFreeDDEData)((HANDLE)dd, TRUE, TRUE);

            GlobalDeleteAtom (ww);

            if (!(f5 & PM_REMOVE)) {

                ul = GETBOOL16(PeekMessage(&t1, f2, f3, f4, f5 | PM_REMOVE));

                // There could've been a task switch before peekmessage returned
                // so Don't trust any 32 bit flat pointers we have, memory could
                // have been compacted or moved.
                FREEARGPTR(parg16);
                FREEVDMPTR(pFrame);
                FREEVDMPTR(pmsg16);

                // uncomment if parg16 is ref'd before goto get_next_dde_message
                //GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
                //GETARGPTR(pFrame, sizeof(PEEKMESSAGE16), parg16);

                // uncomment if pmsg16 is ref'd before goto get_next_dde_message
                //GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);
            }

            if ((Status & fAckReq) || (t1.message == WM_DDE_POKE)) {

                LoadString(hmodWOW32, iszOLEMemAllocFailedFatal, szMsgBoxText, sizeof szMsgBoxText);
                LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
                MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK);
                PostMessage ((HWND) t1.wParam, WM_DDE_TERMINATE, (WPARAM)FULLHWND32((WORD)t1.hwnd), (LPARAM)0l);
            }
            else {
                LoadString(hmodWOW32, iszOLEMemAllocFailed, szMsgBoxText, sizeof szMsgBoxText);
                LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
                MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK);
            }

            FREEVDMPTR(pmsg16);

            // restore the frame ptr due to possible 16-bit memory movement
            GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);

            goto get_next_dde_message;
        }
    }
    else if (fNoYield && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_SETNULLMESSAGE)) {

        // winproj (help.tutorial) calls peekmessage with PM_REMOVE and
        // PM_NOYIELD  and an lpmsg whose contents are uninitialized. However
        // even if peekmessage returns false, it checks if lpmsg->message is
        // WM_QUIT and if true exits. In WOW by pure coincidence the
        // unintialized lpmsg->message happens to be value 0x12, which is
        // WM_QUIT and thus the tutorial always exits after initialization.
        //
        // So we reset lpmsg->message to zero, if it was called with PM_NOYIELD
        // and if it happens to be WM_QUIT and if peekmessage returns zero.
        //
        //                                                       - nanduri

        // we don't need to reinitialize pFrame etc. 'cause peekmessage was
        // called with PM_NOYIELD and thus the 16bit memory couldn't have moved

        register PMSG16 pmsg16;
        GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);
        if (pmsg16 && (pmsg16->message == WM_QUIT)) {
            pmsg16->message = 0;
        }
        FREEVDMPTR(pmsg16);
    }


    BlockWOWIdle(FALSE);

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);
    RETURN(ul);
}







/*++
    BOOL PostAppMessage(<hTask>, <wMsg>, <wParam>, <lParam>)
    HANDLE <hTask>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %PostAppMessage% function posts a message to an application identified
    by a task handle, and then returns without waiting for the application to
    process the message. The application receiving the message obtains the
    message by calling the %GetMessage% or %PeekMessage% function. The <hwnd>
    parameter of the returned %MSG% structure is NULL.

    <hTask>
        Identifies the task that is to receive the message. The
        %GetCurrentTask% function returns this handle.

    <wMsg>
        Specifies the type of message posted.

    <wParam>
        Specifies additional message information.

    <lParam>
        Specifies additional message information.

    The return value specifies whether or not the message is posted. It is
    TRUE if the message is posted. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32PostAppMessage(PVDMFRAME pFrame)
{
    register PPOSTAPPMESSAGE16 parg16;
    DWORD    f1;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(POSTAPPMESSAGE16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = 0;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f2);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->f3);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->f4);
    mpex.iMsgThunkClass = 0;

    f1 = THREADID32(parg16->f1);

    ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    mpex.lReturn = PostThreadMessage(f1, mpex.uMsg, mpex.uParam, mpex.lParam);

    if (MSG16NEEDSTHUNKING(&mpex)) {
        (mpex.lpfnUnThunk16)(&mpex);
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    BOOL PostMessage(<hwnd>, <msg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <msg>;
    WORD <wParam>;
    LONG <lParam>;

    The %PostMessage% function places a message in a window's application queue,
    and then returns without waiting for the corresponding window to process the
    message. Messages in a message queue are retrieved by calls to the
    %GetMessage% or %PeekMessage% function.

    .*
    .* DA's: the following parameters section should be identical to the
    .*       parameters section in the sdmsg.ref file. If there is a change
    .*       to this section, the identical change should be made in the other
    .*       file.
    .*

    <hwnd>
        Identifies the window that is to receive the message. If this parameter
        is 0xFFFF (-1), the message is sent to all top-level windows.

    <msg>
        Specifies the message to be sent.

    <wParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    <lParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    The return value is TRUE if the message is posted, or FALSE if it is not.

    An application should never use the %PostMessage% function to send a message
    to a control.

    .cmt
    27-Oct-1990 [ralphw]

    The following is a rewording of the previous documentation. However, it
    needs confirmation from development as to its technical accuracy before it
    can be released for public consumption.

    If the message is being sent to another application, and the <wParam> or
    <lParam> parameters are used to pass a handle or pointer to global memory,
    the memory should be allocated by the %GlobalAlloc% function using the
    GMEM_NOT_BANKED flag. In a system using expanded memory (EMS), this ensures
    that the memory is not in in a different bank of memory from the application
    using the memory.
    .endcmt
--*/

ULONG FASTCALL WU32PostMessage(PVDMFRAME pFrame)
{
    LONG l;
    UINT f2;
    WPARAM f3;
    LPARAM f4;
    HWND hwnd;
    register PPOSTMESSAGE16 parg16;
    MSGPARAMEX mpex;
    DWORD err = NO_ERROR;

    GETARGPTR(pFrame, sizeof(POSTMESSAGE16), parg16);

    // Apps should never use PostMessage to post messages that have
    // pointers to structures, because those messages will show up in
    // GetMessage, and if GetMessage tries to thunk them (ie, tries to
    // call back to the 16-bit kernel to allocate some 16-bit memory to
    // copy the converted 32-bit structure into), we have no way of
    // knowing when to free that 16-bit memory.
    //
    // BUGBUG 22-Aug-91 JeffPar:  a flag should be added to ThunkMsg16
    // indicating whether or not such allocations are permissible;  this
    // flag should be passed on to all the ThunkXXMsg16 subfunctions,
    // and each of those subfunctions should assert the flag is false
    // whenever allocating 16-bit memory.


    //
    // Used by 16->32 DDE thunkers.
    //

    WOW32ASSERT(fWhoCalled == FALSE);
    fWhoCalled = WOWDDE_POSTMESSAGE;

    f2 = (UINT)WORD32(parg16->f2);
    f3 = (WPARAM)(WORD32(parg16->f3));
    f4 = (LPARAM)(LONG32(parg16->f4));

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->f1;
    mpex.Parm16.WndProc.wMsg   = (WORD)f2;
    mpex.Parm16.WndProc.wParam = (WORD)f3;
    mpex.Parm16.WndProc.lParam = f4;
    mpex.iMsgThunkClass = 0;

    // The Reader.exe shipped with Lotus 123MM version has a message
    // synchronization problem.  Force proper synchronization by
    // converting this PostMessage call to a SendMessage().
    if ((f2 == WM_VSCROLL) &&
         ((f3 == SB_THUMBTRACK) || (f3 == SB_THUMBPOSITION)) &&
         (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_SENDPOSTEDMSG) ) {

        l = (LONG)WU32SendMessage(pFrame);
        FREEARGPTR(parg16);
        RETURN((ULONG) l);
    }

    hwnd = ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
    fWhoCalled = FALSE;
    if (hwnd) {

        l = PostMessage(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam);

        if (!l)
            err = GetLastError();

        mpex.lReturn = l;
        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }


        // If the post message failed, then the message was probably one
        // that has pointers and therefore can not be posted. (MetaDesign
        // tries to post these kind of messages.) If the destination was a
        // WOW app, then make it into a private message, and try the post
        // again.  We don't have to worry about thunking since both the source
        // and destination are in the WOW address space.

        if (err == ERROR_INVALID_PARAMETER) {
            PWW   pww;
            DWORD dwpid;

            pww = FindPWW(hwnd);

            // was added for WM_DRAWITEM messages which are probably intended
            // for owner drawn std-type classes.  see bug #2047 NTBUG4
            if (pww != NULL && GETICLASS(pww, hwnd) != WOWCLASS_WIN16) {

                // make sure we're in the same vdm process
                if (!(GetWindowThreadProcessId(hwnd, &dwpid) &&
                      (dwpid == GetCurrentProcessId()))) {
                          return 0;
                }

                mpex.lReturn = PostMessage(hwnd, f2 | WOWPRIVATEMSG, f3, f4);
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    void PostQuitMessage(<nExitCode>)
    int <nExitCode>;

    The %PostQuitMessage% function informs Windows that the application wishes
    to terminate execution. It is typically used in response to a WM_DESTROY
    message.

    The %PostQuitMessage% function posts a WM_QUIT message to the application
    and returns immediately; the function merely informs the system that the
    application wants to quit sometime in the future.

    When the application receives the WM_QUIT message, it should exit the
    message loop in the main function and return control to Windows. The exit
    code returned to Windows must be the <wParam> parameter of the WM_QUIT
    message.

    <nExitCode>
        Specifies an application exit code. It is used as the wParam parameter
        of the WM_QUIT message.

    This function does not return a value.
--*/

ULONG FASTCALL WU32PostQuitMessage(PVDMFRAME pFrame)
{
    register PPOSTQUITMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(POSTQUITMESSAGE16), parg16);

    PostQuitMessage(INT32(parg16->wExitCode));

    FREEARGPTR(parg16);
    RETURN(0);
}







/*++
    WORD RegisterWindowMessage(<lpString>)
    LPSTR <lpString>;

    This function defines a new window message that is guaranteed to be unique
    throughout the system. The returned message value can be used when calling
    the %SendMessage% or %PostMessage% function.

    %RegisterWindowMessage% is typically used for communication between two
    cooperating applications.

    If the same message string is registered by two different applications, the
    same message value is returned. The message remains registered until the
    user ends the Windows session.

    <lpString>
        Points to the message string to be registered.

    The return value specifies the outcome of the function. It is an unsigned
    short integer within the range 0xC000 to 0xFFFF if the message is
    successfully registered. Otherwise, it is zero.

    Use the %RegisterWindowMessage% function only when the same message must be
    understood by more than one application. For sending private messages within
    an application, an application can use any integer within the range WM_USER
    to 0xBFFF.
--*/

ULONG FASTCALL WU32RegisterWindowMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PREGISTERWINDOWMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(REGISTERWINDOWMESSAGE16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    ul = GETWORD16(RegisterWindowMessage(psz1));

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    void ReplyMessage(<lReply>)
    LONG <lReply>;

    The %ReplyMessage% function is used to reply to a message sent through the
    %SendMessage% function without returning control to the function that called
    %SendMessage.%

    By calling this function, the window function that receives the message
    allows the task that called %SendMessage% to continue to execute as though
    the task that received the message had returned control. The task that calls
    %ReplyMessage% also continues to execute.

    Normally a task that calls %SendMessage% to send a message to another task
    will not continue executing until the window procedure that Windows calls to
    receive the message returns. However, if a task that is called to receive a
    message needs to perform some type of operation that might yield control
    (such as calling the %MessageBox% or %DialogBox% functions), Windows could
    be placed in a deadlock situation where the sending task needs to execute
    and process messages but cannot because it is waiting for %SendMessage% to
    return. An application can avoid this problem if the task receiving the
    message calls %ReplyMessage% before performing any operation that could
    cause the task to yield.

    The %ReplyMessage% function has no effect if the message was not sent
    through the %SendMessage% function or if the message was sent by the same
    task.

    <lReply>
        Specifies the result of the message processing. The possible values
        depend on the actual message sent.

    This function does not return a value.
--*/

ULONG FASTCALL WU32ReplyMessage(PVDMFRAME pFrame)
{
    register PREPLYMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(REPLYMESSAGE16), parg16);

    ReplyMessage(LONG32(parg16->f1));

    // WARNING - Don't use any 32 bit flat pointers after call to ReplyMessage,
    //           other tasks might have run and made the pointers invalid.

    FREEARGPTR(parg16);
    RETURN(0);
}







/*++
    DWORD SendDlgItemMessage(<hDlg>, <nIDDlgItem>, <wMsg>, <wParam>, <lParam>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %SendDlgItemMessage% function sends a message to the control specified
    by the <nIDDlgItem> parameter within the dialog box specified by the <hDlg>
    parameter. The %SendDlgItemMessage% function does not return until the
    message has been processed.

    <hDlg>
        Identifies the dialog box that contains the control.

    <nIDDlgItem>
        Specifies the integer identifier of the dialog item that is to
        receive the message.

    <wMsg>
        Specifies the message value.

    <wParam>
        Specifies additional message information.

    <lParam>
        Specifies additional message information.

    The return value specifies the outcome of the function. It is the value
    returned by the control's window function, or zero if the control identifier
    is not valid.

    Using %SendDlgItemMessage% is identical to obtaining a handle to the given
    control and calling the %SendMessage% function.
--*/

#define W31EM_GETRECT (WM_USER+2)  // w31 EM_GETRECT != NT EM_GETRECT

ULONG FASTCALL WU32SendDlgItemMessage(PVDMFRAME pFrame)
{
    HWND hdlg, hwndItem, hwnd;
    register PSENDDLGITEMMESSAGE16 parg16;
    MSGPARAMEX mpex;

static HWND  hwndCached = NULL ;
static DWORD dwCachedItem = 0L ;

    GETARGPTR(pFrame, sizeof(SENDDLGITEMMESSAGE16), parg16);

    // QuarkExpress v3.31 passes a hard coded 7fff:0000 as the pointer to the
    // RECT struct for EM_GETRECT message - W3.1 rejects it in validation layer
    if( (DWORD32(parg16->f5) == 0x7FFF0000)    &&
        (WORD32(parg16->f3) == W31EM_GETRECT)  &&
        (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_BOGUSPOINTER) ) {

        FREEARGPTR(parg16);
        RETURN((ULONG)0);
    }

    // Need unique handle
    hdlg = (HWND)FULLHWND32(parg16->f1);

    //
    // Caching the hwnd for the dialog item because EForm will
    // call SendDlgItemMessage in a tight loop.
    //
    if ( hdlg == hdlgSDIMCached && WORD32(parg16->f2) == dwCachedItem ) {

        // Set from cached
        hwndItem = hwndCached ;
    }
    else {
        if ( hwndItem = GetDlgItem(hdlg, WORD32(parg16->f2)) ) {

            // and cache needed information
            hdlgSDIMCached     = hdlg ;
            hwndCached         = hwndItem ;
            dwCachedItem       = WORD32(parg16->f2) ;
        }
        else {
            FREEARGPTR(parg16);
            RETURN((ULONG)0);
        }
    }

    mpex.lReturn = 0;
    if (hwndItem) {
        mpex.Parm16.WndProc.hwnd   = GETHWND16(hwndItem);
        mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f3);
        mpex.Parm16.WndProc.wParam = WORD32(parg16->f4);
        mpex.Parm16.WndProc.lParam = LONG32(parg16->f5);
        mpex.iMsgThunkClass = 0;

        if (hwnd = ThunkMsg16(&mpex)) {

            // Note: ThunkMsg16 may have caused memory movement
            FREEARGPTR(pFrame);
            FREEARGPTR(parg16);

            /*
            ** Since we already know which window the message is going to
            ** don't make USER32 look it up again. - MarkRi
            */
            mpex.lReturn = SendMessage(hwndItem, mpex.uMsg, mpex.uParam,
                                                                mpex.lParam);
            // to keep common dialog structs in sync (see wcommdlg.c)
            Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd,
                                (VPVOID)mpex.Parm16.WndProc.lParam);

            if (MSG16NEEDSTHUNKING(&mpex)) {
                (mpex.lpfnUnThunk16)(&mpex);
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    DWORD SendMessage(<hwnd>, <msg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <msg>;
    WORD <wParam>;
    LONG <lParam>;

    The %SendMessage% function sends a message to a window or windows. The
    %SendMessage% function calls the window procedure for the specified window,
    and does not return until that window procedure has processed the message.
    This is in contrast to the %PostMessage% function which places the message
    into the specified window's message queue and returns immediately.

    <hwnd>
        Identifies the window that is to receive the message. If this parameter
        is 0xFFFF (-1), the message is sent to all top-level windows.

    <msg>
        Specifies the message to be sent.

    <wParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    <lParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    The return value is the result returned by the invoked window procedure; its
    value depends on the message being sent.
--*/

ULONG FASTCALL WU32SendMessage(PVDMFRAME pFrame)
{
    // NOTE: This can be called directly by WU32PostMessage!!!

    HWND hwnd;
    register PSENDMESSAGE16 parg16;
    MSGPARAMEX mpex;
    HWND16 hwndOld;
    UINT uMsgOld;
    UINT uParamOld;
    LONG lParamOld;
#ifdef DBCS
    HMEM16 hMem16;
    LPSZ lpBuf16,lpBuf32;
#endif // DBCS

    GETARGPTR(pFrame, sizeof(SENDMESSAGE16), parg16);

    hwndOld   = parg16->f1;
    uMsgOld   = WORD32(parg16->f2);
    uParamOld = WORD32(parg16->f3);
    lParamOld = LONG32(parg16->f4);

    //
    // Check for funky apps sending WM_SYSCOMMAND - SC_CLOSE to progman
    //
    if ( uMsgOld == WM_SYSCOMMAND && uParamOld == SC_CLOSE ) {
        if ( hwndOld == GETHWND16(hwndProgman) && hwndProgman != (HWND)0 ) {
            //
            // Now if shift key is down, they must be trying to save
            // settings in progman.
            //
            if ( GetKeyState( VK_SHIFT ) < 0 ) {
                uMsgOld = RegisterWindowMessage("SaveSettings");
            }
        }
    }


    //
    // This is for the apps that use DDE protocol wrongly, like AmiPro.
    //

    WOW32ASSERT(fWhoCalled == FALSE);
    fWhoCalled = WOWDDE_POSTMESSAGE;

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = hwndOld;
    mpex.Parm16.WndProc.wMsg   = (WORD)uMsgOld;
#ifdef DBCS
    //
    // For WIN3.1J's BUG ?
    // SendMessage( hwnd, WM_GETTEXT, 2, lpBuffer )
    // if string is DBCS, return is DBCS-leadbyte.
    // KKSUZUKA:#1731
    // 1994.8.8 add by V-HIDEKK
    //
    if( uMsgOld == WM_GETTEXT && uParamOld == 2 ){
        mpex.Parm16.WndProc.wParam = (WORD)(uParamOld + 1);
        mpex.Parm16.WndProc.lParam = GlobalAllocLock16( GMEM_SHARE | GMEM_MOVEABLE, uParamOld +1, &hMem16 );
    }
    else {
        mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
        mpex.Parm16.WndProc.lParam = lParamOld;
    }
#else // !DBCS
    mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
    mpex.Parm16.WndProc.lParam = lParamOld;
#endif // !DBCS
    mpex.iMsgThunkClass = 0;

    hwnd = ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
    fWhoCalled = FALSE;

    if (hwnd) {

        BlockWOWIdle(TRUE);

#ifdef DEBUG
        if ( WM_DDE_EXECUTE == mpex.uMsg ) {
             // comes handy when debugging shell shortcut problems
             LOGDEBUG(1,("dest %x, src%x, msg %s\n",hwnd,mpex.uParam,mpex.lParam));
        }             
#endif
        mpex.lReturn = SendMessage(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam);

        BlockWOWIdle(FALSE);
#ifdef DBCS
    //
    // For WIN3.1J's BUG ?
    // SendMessage( hwnd, WM_GETTEXT, 2, lpBuffer )
    // if string is DBCS, return is DBCSLeadbyte.
    // KKSUZUKA:#1731
    // 1994.8.8 add by V-HIDEKK
    //
        if( uMsgOld == WM_GETTEXT && uParamOld == 2 ){

            GETVDMPTR(mpex.Parm16.WndProc.lParam,mpex.Parm16.WndProc.wParam,lpBuf32);
            GETVDMPTR(lParamOld,uParamOld,lpBuf16);
            lpBuf16[0] = lpBuf32[0];
            if( mpex.lReturn == 2 ){
                lpBuf16[1] = 0;
                mpex.lReturn = 1;
            }
            else {
                lpBuf16[1] = lpBuf32[1];
            }
            FREEVDMPTR(lpBuf16);
            FREEVDMPTR(lpBuf32);
            GlobalUnlockFree16( mpex.Parm16.WndProc.lParam );
            mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
            mpex.Parm16.WndProc.lParam = lParamOld;
        }
#endif // DBCS


        WOW32ASSERT(fWhoCalled == FALSE);
        fWhoCalled = WOWDDE_POSTMESSAGE;
        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
        WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
        fWhoCalled = FALSE;
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    int TranslateAccelerator(<hwnd>, <hAccTable>, <lpMsg>)

    The %TranslateAccelerator% function processes keyboard accelerators for menu
    commands. The %TranslateAccelerator% function translates WM_KEYUP and
    WM_KEYDOWN messages to WM_COMMAND or WM_SYSCOMMAND messages, if there is an
    entry for the key in the application's accelerator table. The high-order
    word of the <lParam> parameter of the WM_COMMAND or WM_SYSCOMMAND message
    contains the value 1 to differentiate the message from messages sent by
    menus or controls.

    WM_COMMAND or WM_SYSCOMMAND messages are sent directly to the window, rather
    than being posted to the application queue. The %TranslateAccelerator%
    function does not return until the message is processed.

    Accelerator key strokes that are defined to select items from the system
    menu are translated into WM_SYSCOMMAND messages; all other accelerators are
    translated into WM_COMMAND messages.

    <hwnd>
        Identifies the window whose messages are to be translated.

    <hAccTable>
        %HANDLE% Identifies an accelerator table (loaded by using the
        %LoadAccelerators% function).

    <lpMsg>
        Points to a message retrieved by using the %GetMessage% or
        %PeekMessage% function. The message must be an %MSG% structure and
        contain message information from the Windows application queue.

    .cmt
    19-Sep-1990 [johnca]
    Doesn't this function really return a BOOL?
    .endcmt

    The return value specifies the outcome of the function. It is nonzero if
    translation occurs. Otherwise, it is zero.

    When %TranslateAccelerator% returns nonzero (meaning that the message is
    translated), the application should <not> process the message again by using
    the %TranslateMessage% function.

    Commands in accelerator tables do not have to correspond to menu items.

    If the accelerator command does correspond to a menu item, the application
    is sent WM_INITMENU and WM_INITMENUPOPUP messages, just as if the user were
    trying to display the menu. However, these messages are not sent if any of
    the following conditions are present:

    o   The window is disabled.

    o   The menu item is disabled.

    o   The command is not in the System menu and the window is minimized.

    o   A mouse capture is in effect (for more information, see the %SetCapture%
        function, earlier in this chapter).

    If the window is the active window and there is no keyboard focus (generally
    true if the window is minimized), then WM_SYSKEYUP and WM_SYSKEYDOWN
    messages are translated instead of WM_KEYUP and WM_KEYDOWN messages.

    If an accelerator key stroke that corresponds to a menu item occurs when the
    window that owns the menu is iconic, no WM_COMMAND message is sent. However,
    if an accelerator key stroke that does not match any of the items on the
    window's menu or the System menu occurs, a WM_COMMAND message is sent, even
    if the window is iconic.
--*/

ULONG FASTCALL WU32TranslateAccelerator(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t3;
    register PTRANSLATEACCELERATOR16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEACCELERATOR16), parg16);

    W32CopyMsgStruct(parg16->f3, &t3, TRUE);
    ul = GETINT16(TranslateAccelerator(HWND32(parg16->f1),
                                       HACCEL32(parg16->f2), &t3 ));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    BOOL TranslateMDISysAccel(<hwndClient>, <lpMsg>)

    The %TranslateMDISysAccel% function processes keyboard accelerators for
    multiple document interface (MDI) child window System-menu commands. The
    %TranslateMDISysAccel% function translates WM_KEYUP and WM_KEYDOWN messages
    to WM_SYSCOMMAND messages. The high-order word of the <lParam> parameter of
    the WM_SYSCOMMAND message contains the value 1 to differentiate the message
    from messages sent by menus or controls.

    <hwndClient>
        Identifies the parent MDI client window.

    <lpMsg>
        Points to a message retrieved by using the %GetMessage% or
        %PeekMessage% function. The message must be an %MSG% structure and
        contain message information from the Windows application queue.

    The return value is TRUE if the function translated a message into a system
    command. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32TranslateMDISysAccel(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t2;
    register PTRANSLATEMDISYSACCEL16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEMDISYSACCEL16), parg16);

    W32CopyMsgStruct(parg16->f2, &t2, TRUE);

    ul = GETBOOL16(TranslateMDISysAccel(HWND32(parg16->f1), &t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    BOOL TranslateMessage(<lpMsg>)

    The %TranslateMessage% function translates virtual-key messages into
    character messages, as follows:

    o   WM_KEYDOWN/WM_KEYUP combinations produce a WM_CHAR or a WM_DEADCHAR
        message.

    o   WM_SYSKEYDOWN/WM_SYSKEYUP combinations produce a WM_SYSCHAR or a
        WM_SYSDEADCHAR message.

    The character messages are posted to the application queue, to be read the
    next time the application calls the %GetMessage% or %PeekMessage% function.

    <lpMsg>
        Points to a %MSG% structure retrieved through the GetMessage or
        PeekMessage function. The structure contains message information from
        the Windows application queue.

    The return value specifies the outcome of the function. It is TRUE if the
    message is translated (that is, character messages are posted to the
    application queue). Otherwise, it is FALSE.

    The %TranslateMessage% function does not modify the message given by the
    <lpMsg> parameter.

    %TranslateMessage% produces WM_CHAR messages only for keys which are mapped
    to ASCII characters by the keyboard driver.

    An application should not call %TranslateMessage% if the application
    processes virtual-key messages for some other purpose. For instance, an
    application should not call the %TranslateMessage% function if the
    %TranslateAccelerator% function returns TRUE.
--*/

ULONG FASTCALL WU32TranslateMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t1;
    register PTRANSLATEMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEMESSAGE16), parg16);

    W32CopyMsgStruct(parg16->f1, &t1, TRUE);

    ul = GETBOOL16(TranslateMessage( &t1 ));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    void WaitMessage(VOID)

    The %WaitMessage% function yields control to other applications when an
    application has no other tasks to perform. The %WaitMessage% function
    suspends the application and does not return until a new message is placed
    in the application's queue.

    This function has no parameters.

    This function does not return a value.

    The %GetMessage%, %PeekMessage%, and %WaitMessage% functions yield control
    to other applications. These calls are the only way to let other
    applications run. If your application does not call any of these functions
    for long periods of time, other applications cannot run.

    When %GetMessage%, %PeekMessage%, and %WaitMessage% yield control to other
    applications, the stack and data segments of the application calling the
    function may move in memory to accommodate the changing memory requirements
    of other applications. If the application has stored long pointers to
    objects in the data or stack segment (that is, global or local variables),
    these pointers can become invalid after a call to %GetMessage%,
    %PeekMessage%, or %WaitMessage%.
--*/

ULONG FASTCALL WU32WaitMessage(PVDMFRAME pFrame)
{
    UNREFERENCED_PARAMETER(pFrame);

    BlockWOWIdle(TRUE);

    WaitMessage();

    BlockWOWIdle(FALSE);

    RETURN(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuser.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUSER.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#define OEMRESOURCE

#include "precomp.h"
#pragma hdrstop


MODNAME(wuser.c);

extern HANDLE hmodWOW32;


/*++
    HDC BeginPaint(<hwnd>, <lpPaint>)
    HWND <hwnd>;
    LPPAINTSTRUCT <lpPaint>;

    The %BeginPaint% function prepares the given window for painting and fills
    the paint structure pointed to by the <lpPaint> parameter with information
    about the painting.

    The paint structure contains a handle to the device context for the window,
    a %RECT% structure that contains the smallest rectangle that completely
    encloses the update region, and a flag that specifies whether or not the
    background has been erased.

    The %BeginPaint% function automatically sets the clipping region of the
    device context to exclude any area outside the update region. The update
    region is set by the %InvalidateRect% or %InvalidateRgn% functions and by
    the system after sizing, moving, creating, scrolling, or any other operation
    that affects the client area. If the update region is marked for erasing,
    %BeginPaint% sends a WM_ERASEBKGND message to the window.

    An application should not call the %BeginPaint% function except in response
    to a WM_PAINT message. Each %BeginPaint% call must have a matching call to
    the %EndPaint% function.

    <hwnd>
        Identifies the window to be repainted.

    <lpPaint>
        Points to the %PAINTSTRUCT% structure that is to receive painting
        information, such as the device context for the window and the update
        rectangle.

    The return value identifies the device context for the specified window.

    If the caret is in the area to be painted, the %BeginPaint% function
    automatically hides the caret to prevent it from being erased.
--*/

ULONG FASTCALL WU32BeginPaint(PVDMFRAME pFrame)
{
    ULONG ul;
    PAINTSTRUCT t2;
    register PBEGINPAINT16 parg16;
    VPVOID  vpPaint;

    GETARGPTR(pFrame, sizeof(BEGINPAINT16), parg16);
    vpPaint = parg16->vpPaint;

    ul = GETHDC16(BeginPaint(
    HWND32(parg16->hwnd),
    &t2
    ));

    putpaintstruct16(vpPaint, &t2);
    W32FixPaintRect (vpPaint, &t2);

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HICON CreateIcon(<hInstance>, <nWidth>, <nHeight>, <nPlanes>,
        <nBitsPixel>, <lpANDbits>, <lpXORbits>)
    HANDLE <hInstance>;
    int <nWidth>;
    int <nHeight>;
    BYTE <nPlanes>;
    BYTE <nBitsPixel>;
    LPSTR <lpANDbits>;
    LPSTR <lpXORbits>;

    This function creates an icon that has specified width, height, colors, and
    bit patterns.

    <hInstance>
        Identifies an instance of the module creating the icon.

    <nWidth>
        Specifies the width in pixels of the icon.

    <nHeight>
        Specifies the height in pixels of the icon.

    <nPlanes>
        Specifies the number of planes in the XOR mask of the icon.

    <nBitsPixel>
        Specifies the number of bits per pixel in the XOR mask of the icon.

    <lpANDbits>
        Points to an array of bytes that contains the bit values for the AND
        mask of the icon. This array must specify a monochrome mask.

    <lpXORbits>
        Points to an array of bytes that contains the bit values for the XOR
        mask of the icon. This can be the bits of a monochrome or
        device-dependent color bitmap.

    The return value identifies an icon if the function is successful.
    Otherwise, it is NULL.
--*/

ULONG FASTCALL WU32CreateIcon(PVDMFRAME pFrame)
{
    ULONG   ul;
    register PCREATEICON16 parg16;
    int     nWidth;
    int     nHeight;
    BYTE    nPlanes;
    BYTE    nBitsPixel;
    DWORD   nBytesAND;
    DWORD   nBytesXOR;
    LPBYTE  lpBitsAND;
    LPBYTE  lpBitsXOR;
    int     ScanLen16;

    HANDLE  h32;
    HAND16  h16;
    HAND16  hInst16;

    GETARGPTR(pFrame, sizeof(CREATEICON16), parg16);

    hInst16    = parg16->f1;
    nWidth     = INT32(parg16->f2);
    nHeight    = INT32(parg16->f3);

    /*
    ** Convert the AND mask bits
    */
    nPlanes    = 1;     /* MONOCHROME BITMAP */
    nBitsPixel = 1;     /* MONOCHROME BITMAP */
    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
    nBytesAND = ScanLen16*nHeight*nPlanes;

    GETVDMPTR(parg16->f6, nBytesAND, lpBitsAND);


    /*
    ** Convert the XOR mask bits
    */
    nPlanes    = BYTE32(parg16->f4);
    nBitsPixel = BYTE32(parg16->f5);

    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
    nBytesXOR = ScanLen16*nHeight*nPlanes;

    GETVDMPTR(parg16->f7, nBytesXOR, lpBitsXOR);


    h32 = (HANDLE)CreateIcon(HMODINST32(hInst16),
                 nWidth,
                 nHeight,
                 nPlanes,
                 nBitsPixel,
                 lpBitsAND,
                 lpBitsXOR);

    if (h32) {
        h16 = (HAND16)W32Create16BitCursorIcon(hInst16,
                            nWidth/2, nHeight/2,
                            nWidth, nHeight, nPlanes, nBitsPixel,
                            lpBitsAND, lpBitsXOR,
                            nBytesAND, nBytesXOR);

        ul  = SetupCursorIconAlias(hInst16, h32, h16,
                                   HANDLE_TYPE_ICON, NULL, (WORD)NULL);
    } else {
        ul = 0;
    }

    FREEPSZPTR(lpBitsAND);
    FREEPSZPTR(lpBitsXOR);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DestroyIcon(<hIcon>)
    HICON <hIcon>;

    This function destroys an icon that was previously created by the
    %CreateIcon% function and frees any memory that the icon occupied. It should
    not be used to destroy any icon that was not created with the %CreateIcon%
    function.

    <hIcon>
        Identifies the icon to be destroyed. The icon must not be in current
        use.

    The return value is TRUE if the function was successful. It is FALSE if
    the function failed.
--*/

ULONG FASTCALL WU32DestroyIcon(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDESTROYICON16 parg16;

    GETARGPTR(pFrame, sizeof(DESTROYICON16), parg16);

    if (ul = GETBOOL16(DestroyIcon(HICON32(parg16->f1))))
        FREEHICON16(parg16->f1);

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32DragDetect(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PDRAGDETECT16 parg16;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    COPYPOINT16(parg16->pt, pt);

    ul = (ULONG) DragDetect(
                     HWND32(parg16->hwnd),
                     pt
                     );

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    void DrawFocusRect(<hDC>, <lpRect>)
    HDC <hDC>;
    LPRECT <lpRect>;

    The %DrawFocusRect% function draws a rectangle in the style used to indicate
    focus.

    <hDC>
        Identifies the device context.

    <lpRect>
        Points to a %RECT% structure that specifies the
        coordinates of the rectangle to be drawn.

    This function does not return a value.

    Since this is an XOR function, calling this function a second time with the
    same rectangle removes the rectangle from the display.

    The rectangle drawn by this function cannot be scrolled. To scroll an area
    containing a rectangle drawn by this function, call %DrawFocusRect% to
    remove the rectangle from the display, scroll the area, and then call
    %DrawFocusRect% to draw the rectangle in the new position.
--*/

ULONG FASTCALL WU32DrawFocusRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PDRAWFOCUSRECT16 parg16;

    GETARGPTR(pFrame, sizeof(DRAWFOCUSRECT16), parg16);

    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    DrawFocusRect(
    HDC32(parg16->f1),
    &t2
    );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    int DrawText(<hDC>, <lpString>, <nCount>, <lpRect>, <wFormat>)
    HDC <hDC>;
    LPSTR <lpString>;
    int <nCount>;
    LPRECT <lpRect>;
    WORD <wFormat>;

    The %DrawText% function draws formatted text in the rectangle specified by
    the <lpRect> parameter. It formats text by expanding tabs into appropriate
    spaces, justifying text to the left, right, or center of the given
    rectangle, and breaking text into lines that fit within the given
    rectangle. The type of formatting is specified by the <wFormat> parameter.

    The %DrawText% function uses the device context's selected font, text color,
    and background color to draw the text. Unless the DT_NOCLIP format is used,
    %DrawText% clips the text so that the text does not appear outside the given
    rectangle. All formatting is assumed to have multiple lines unless the
    DT_SINGLELINE format is given.

    <hDC>
        Identifies the device context.

    <lpString>
        Points to the string to be drawn. If the <nCount> parameter is -1, the
        string must be null-terminated.

    <nCount>
        Specifies the number of bytes in the string. If <nCount> is -1,
        then <lpString> is assumed to be a long pointer to a null-terminated
        string and %DrawText% computes the character count automatically.

    <lpRect>
        Points to a %RECT% structure that contains the rectangle
        (in logical coordinates) in which the text is to be formatted.

    <wFormat>
        Specifies the method of formatting the text. It can be any
        combination of the following values:

    DT_BOTTOM
        Specifies bottom-justified text. This value must be combined with
        DT_SINGLELINE.

    DT_CALCRECT
        Determines the width and height of the rectangle. If there are multiple
        lines of text, %DrawText% will use the width of the rectangle pointed to
        by the <lpRect> parameter and extend the base of the rectangle to bound
        the last line of text. If there is only one line of text, %DrawText%
        will modify the right side of the rectangle so that it bounds the last
        character in the line. In either case, %DrawText% returns the height of
        the formatted text but does not draw the text.

    DT_CENTER
        Centers text horizontally.

    DT_EXPANDTABS
        Expands tab characters. The default number of characters per tab is
        eight.

    DT_EXTERNALLEADING
        Includes the font external leading in line height. Normally, external
        leading is not included in the height of a line of text.

    DT_LEFT
        Aligns text flush-left.

    DT_NOCLIP
        Draws without clipping. %DrawText% is somewhat faster when DT_NOCLIP is
        used.

    DT_NOPREFIX
        Turns off processing of prefix characters. Normally, %DrawText%
        interprets the mnemonic-prefix character & as a directive to
        underscore the character that follows, and the mnemonic-prefix
        characters && as a directive to print a single &. By specifying
        DT_NOPREFIX, this processing is turned off.

    DT_RIGHT
        Aligns text flush-right.

    DT_SINGLELINE
        Specifies single line only. Carriage returns and linefeeds do not break
        the line.

    DT_TABSTOP
        Sets tab stops. The high-order byte of the <wFormat> parameter is the
        number of characters for each tab. The default number of characters per
        tab is eight.

    DT_TOP
        Specifies top-justified text (single line only).

    DT_VCENTER
        Specifies vertically centered text (single line only).

    DT_WORDBREAK
        Specifies word breaking. Lines are automatically broken between words if
        a word would extend past the edge of the rectangle specified by the
        <lpRect> parameter. A carriage return/line sequence will also break the
        line.

        Note that the DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP,
        and DT_NOPREFIX values cannot be used with the DT_TABSTOP value:

    The return value specifies the height of the text.

    If the selected font is too large for the specified rectangle, the
    %DrawText% function does not attempt to substitute a smaller font.
--*/

ULONG FASTCALL WU32DrawText(PVDMFRAME pFrame)
{
    ULONG ul;
    PSTR pstr2;
    RECT t4;
    register PDRAWTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(DRAWTEXT16), parg16);
    GETVARSTRPTR(parg16->vpString, INT32(parg16->nCount), pstr2);

    WOW32VERIFY(GETRECT16(parg16->vpRect, &t4));

    ul = GETINT16(DrawText(
                      HDC32(parg16->hdc),
                      pstr2,
                      INT32(parg16->nCount),
                      &t4,
                      WORD32(parg16->wFormat)
                      ));

    PUTRECT16(parg16->vpRect, &t4);

    FREESTRPTR(pstr2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void EndPaint(<hwnd>, <lpPaint>)
    HWND <hwnd>;
    LPPAINTSTRUCT <lpPaint>;

    The %EndPaint% function marks the end of painting in the given window. The
    %EndPaint% function is required for each call to the %BeginPaint% function,
    but only after painting is complete.

    <hwnd>
        Identifies the window that is repainted.

    <lpPaint>
        Points to a %PAINTSTRUCT% structure that contains the painting
        information retrieved by the %BeginPaint% function.

    This function does not return a value.

    If the caret was hidden by the %BeginPaint% function, %EndPaint% restores
    the caret to the screen.
--*/

ULONG FASTCALL WU32EndPaint(PVDMFRAME pFrame)
{
    HAND16 hdc16;
    PAINTSTRUCT t2;
    register PENDPAINT16 parg16;

    GETARGPTR(pFrame, sizeof(ENDPAINT16), parg16);
    hdc16 = getpaintstruct16(parg16->vpPaint, &t2);

    EndPaint(
        HWND32(parg16->hwnd),
        &t2
        );

    DeleteWOWGdiHandle(t2.hdc, hdc16);

    FREEARGPTR(parg16);
    RETURN(0);
}


#define MAX_WIN16_PROP_TEXT 256     /* Taken from Win 3.1 - winprops.c */

static VPVOID   vpEnumPropsProc;
static VPVOID   vpString;

INT W32EnumPropsFunc( HWND hwnd, LPSTR lpString, HANDLE hData )
{
    PARM16 Parm16;
    LONG lReturn;
    VPVOID vp;

    if ( HIWORD(lpString) == 0 ) {
        vp = (DWORD)lpString;
    } else {
        INT cb;

        vp = vpString;
        cb = strlen(lpString)+1;
        if ( cb > MAX_WIN16_PROP_TEXT-1 ) {
            cb = MAX_WIN16_PROP_TEXT-1;
        }
        putstr16(vpString, lpString, cb);
    }

    Parm16.EnumPropsProc.hwnd = GETHWND16(hwnd);
    Parm16.EnumPropsProc.vpString = vp;
    Parm16.EnumPropsProc.hData = GETHANDLE16(hData);

    CallBack16(RET_ENUMPROPSPROC, &Parm16, vpEnumPropsProc, (PVPVOID)&lReturn);

    return (SHORT)lReturn;
}

/*++
    int EnumProps(<hwnd>, <lpEnumFunc>)
    HWND <hwnd>;
    FARPROC <lpEnumFunc>;

    The %EnumProps% function enumerates all entries in the property list of the
    specified window. It enumerates the entries by passing them, one by one, to
    the callback function specified by <lpEnumFunc>. %EnumProps% continues until
    the last entry is enumerated or the callback function returns zero.

    <hwnd>
        Identifies the window whose property list is to be enumerated.

    <lpEnumFunc>
        Specifies the procedure-instance address of the callback function.
        See the following Comments section for details.

    The return value specifies the last value returned by the callback function.
    It is -1 if the function did not find a property for enumeration.

    An application can remove only those properties which it has added. It
    should not remove properties added by other applications or by Windows
    itself.

    The following restrictions apply to the callback function:

    1   The callback function must not yield control or do anything that might
        yield control to other tasks.

    2   The callback function can call the %RemoveProp% function. However, the
        %RemoveProp% function can remove only the property passed to the
        callback function through the callback function's parameters.

    3   A callback function should not attempt to add properties.

    The address passed in the <lpEnumFunc> parameter must be created by using
    the %MakeProcInstance% function.

    Fixed Data Segments:

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. In applications and dynamic libraries with fixed data
    segments and in dynamic libraries with moveable data segments that do not
    contain a stack, the callback function must have the form shown below.

    Callback Function:

    int  FAR PASCAL <EnumFunc>(<hwnd>, <lpString>, <hData>)
    HWND <hwnd>;
    LPSTR <lpString>;
    HANDLE <hData>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies a handle to the window that contains the property list.

    <lpString>
        Points to the null-terminated string associated with the data handle
        when the application called the%SetProp% function to set the property.
        If the application passed an atom instead of a string to the %SetProp%
        function, the<lpString> parameter contains the atom in its low-order
        word, and the high-order word is zero.

    <hData>
        Identifies the data handle.

    The callback function can carry out any desired task. It must return a
    nonzero value to continue enumeration, or a zero value to stop it.

    Moveable Data Segments:

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. In applications with moveable data segments and in dynamic
    libraries whose moveable data segments also contain a stack, the callback
    function must have the form shown below.

    Callback Function:

    int  FAR PASCAL <EnumFunc>(<hwnd>, <nDummy>, <pString>, <hData>)
    HWND <hwnd>;
    WORD <nDummy>;
    PSTR <pString>;
    HANDLE <hData>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies a handle to the window that contains the property list.

    <nDummy>
        Specifies a dummy parameter.

    <pString>
        Points to the null-terminated string associated with the data handle
        when the application called the %SetProp% function to set the property.
        If the application passed an atom instead of a string to the %SetProp%
        function, the <pString> parameter contains the atom.

    <hData>
        Identifies the data handle.

    The callback function can carry out any desired task. It should return a
    nonzero value to continue enumeration, or a zero value to stop it.

    The alternate form above is required since movement of the data will
    invalidate any long pointer to a variable on the stack, such as the
    <lpString> parameter. The data segment typically moves if the callback
    function allocates more space in the local heap than is currently
    available.
--*/

ULONG FASTCALL WU32EnumProps(PVDMFRAME pFrame)
{
    ULONG ul;
    HWND    hwnd;
    register PENUMPROPS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMPROPS16), parg16);

    hwnd            = HWND32(parg16->f1);
    vpEnumPropsProc =        parg16->f2;

    vpString = malloc16(MAX_WIN16_PROP_TEXT);
    // 16-bit memory may have moved - invalidate flat pointers
    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    if (vpString) {
        ul = GETINT16(EnumProps(hwnd,(PROPENUMPROC)W32EnumPropsFunc));
        free16(vpString);

    } else {
        ul = (ULONG)-1;
    }

    RETURN(ul);
}



/*++
    int FillWindow(<hWndParent>, <hWnd>, <hDC>, <hBrush>)
    HWND <hWndParent>;
    HWND  <hWnd>;
    HDC <hDC>;
    HBRUSH <hBrush>;

    The %FillWindow% function paints a given window by using the specified
    brush.

    <hWndParent>
        Identifies the parent of the window to be painted.

    <hWnd>
        Identifies the window to be painted.

    <hDC>
        Identifies the device context.

    <hBrush>
        Identifies the brush used to fill the rectangle.

--*/

ULONG FASTCALL WU32FillWindow(PVDMFRAME pFrame)
{
    register PFILLWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(FILLWINDOW16), parg16);

    (pfnOut.pfnFillWindow)(
        HWND32(parg16->f1),
        HWND32(parg16->f2),
        HDC32(parg16->f3),
        HBRUSH32(parg16->f4)
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    int FillRect(<hDC>, <lpRect>, <hBrush>)
    HDC <hDC>;
    LPRECT <lpRect>;
    HBRUSH <hBrush>;

    The %FillRect% function fills a given rectangle by using the specified
    brush. The %FillRect% function fills the complete rectangle, including the
    left and top borders, but does not fill the right and bottom borders.

    <hDC>
        Identifies the device context.

    <lpRect>
        Points to a %RECT% structure that contains the logical
        coordinates of the rectangle to be filled.

    <hBrush>
        Identifies the brush used to fill the rectangle.

    Although the %FillRect% function return type is an integer, the return value
    is not used and has no meaning.

    The brush must have been created previously by using either the
    %CreateHatchBrush%, %CreatePatternBrush%, or %CreateSolidBrush% function, or
    retrieved using the %GetStockObject% function.

    When filling the specified rectangle, the %FillRect% function does not
    include the rectangle's right and bottom sides. GDI fills a rectangle up to,
    but does not include, the right column and bottom row, regardless of the
    current mapping mode.

    %FillRect% compares the values of the %top%, %bottom%, %left%, and %right%
    members of the specified rectangle. If %bottom% is less than or equal to
    %top%, or if %right% is less than or equal to %left%, the rectangle is not
    drawn.
--*/

ULONG FASTCALL WU32FillRect(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PFILLRECT16 parg16;

    GETARGPTR(pFrame, sizeof(FILLRECT16), parg16);

    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    ul = GETINT16(FillRect(
                      HDC32(parg16->f1),
                      &t2,
                      HBRUSH32(parg16->f3)
                      ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    int FrameRect(<hDC>, <lpRect>, <hBrush>)
    HDC <hDC>;
    LPRECT <lpRect>;
    HBRUSH <hBrush>;

    The %FrameRect% function draws a border around the rectangle specified by
    the <lpRect> parameter. The %FrameRect% function uses the given brush to
    draw the border. The width and height of the border is always one logical
    unit.

    <hDC>
        Identifies the device context of the window.

    <lpRect>
        Points to a %RECT% structure that contains the logical
        coordinates of the upper-left and lower-right corners of the rectangle.

    <hBrush>
        Identifies the brush to be used for framing the rectangle.

    Although the return value type is integer, its contents should be ignored.

    The brush identified by the <hBrush> parameter must have been created
    previously by using the %CreateHatchBrush%, %CreatePatternBrush%, or
    %CreateSolidBrush% function.

    If the %bottom% member is less than or equal to the %top% member, or if the
    %right% member is less than or equal to the %left% member, the rectangle is
    not drawn.
--*/

ULONG FASTCALL WU32FrameRect(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PFRAMERECT16 parg16;

    GETARGPTR(pFrame, sizeof(FRAMERECT16), parg16);

    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    ul = GETINT16(FrameRect(
                      HDC32(parg16->f1),
                      &t2,
                      HBRUSH32(parg16->f3)
                      ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HDC GetDC(<hwnd>)
    HWND <hwnd>;

    The %GetDC% function retrieves a handle to a display context for the client
    area of the given window. The display context can be used in subsequent GDI
    functions to draw in the client area.

    The %GetDC% function retrieves a common, class, or private display context
    depending on the class style specified for the given window. For common
    display contexts, %GetDC% assigns default attributes to the context each
    time it is retrieved. For class and private contexts, %GetDC% leaves the
    previously assigned attributes unchanged.

    <hwnd>
        Identifies the window whose display context is to be retrieved.

    The return value identifies the display context for the given window's
    client area if the function is successful. Otherwise, it is NULL.

    After painting with a common display context, the %ReleaseDC% function must
    be called to release the context. Class and private display contexts do not
    have to be released. Since only five common display contexts are available
    at any given time, failure to release a display context can prevent other
    applications from accessing a display context.
--*/

ULONG FASTCALL WU32GetDC(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDC16 parg16;
    HAND16 htask16 = pFrame->wTDB;

    GETARGPTR(pFrame, sizeof(GETDC16), parg16);

    if (CACHENOTEMPTY()) {
        ReleaseCachedDCs(htask16, parg16->f1, 0, 0, SRCHDC_TASK16_HWND16);
    }

    CURRENTPTD()->ulLastDesktophDC = 0;
    
    ul = GETHDC16(GetDC(
                      HWND32(parg16->f1)
                      ));

    if (ul) {
// Some apps such as MSWORKS and MS PUBLISHER use some wizard code that accepts
// a hDC or a hWnd as a parameter and attempt to figure out what type of handle
// it is by using the IsWindow() call. Since both handles come from different
// handle spaces they may end up the same value and this wizard code will end
// up writing to the DC for a random window. By ORing in a 1 we ensure that the
// handle types will never share the same value since all hWnds are even. Note
// that this hack is also made in WG32CreateCompatibleDC()
//
// Note that there are some apps that use the lower 2 bits of the hDC for their
// own purposes.
        if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_UNIQUEHDCHWND) {
            ul = ul | 1;
        } else if ((CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FIXDCFONT4MENUSIZE) &&
                   (parg16->f1 == 0)) {
// WP tutorial assumes that the font selected in the hDC for desktop window
// (ie, result of GetDC(NULL)) is the same font as the font selected for 
// drawing the menu. Unfortunetly in SUR this is not true as the user can
// select any font for the menu. So we remember the hDC returned for GetDC(0)
// and check for it in GetTextExtentPoint. If the app does try to use it we
// find the hDC for the current menu window and substitute that. When the app
// does another GetDC or ReleaseDC we forget the hDC returned for the original
// GetDC(0).
            CURRENTPTD()->ulLastDesktophDC = ul;
        }



        StoreDC(htask16, parg16->f1, (HAND16)ul);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void GetScrollRange(<hwnd>, <nBar>, <lpMinPos>, <lpMaxPos>)
    HWND <hwnd>;
    int <nBar>;
    LPINT <lpMinPos>;
    LPINT <lpMaxPos>;

    The %GetScrollRange% function copies the current minimum and maximum
    scroll-bar positions for the given scroll bar to the locations specified by
    the <lpMinPos> and <lpMaxPos> parameters. If the given window does not have
    standard scroll bars or is not a scroll-bar control, then the
    %GetScrollRange% function copies zero to <lpMinPos> and <lpMaxPos>.

    <hwnd>
        Identifies a window that has standard scroll bars or a scroll-bar
        control, depending on the value of the nBar parameter.

    <nBar>
        Specifies an integer value that identifies which scroll bar to
        retrieve. It can be one of the following values:

    SB_CTL
        Retrieves the position of a scroll-bar control; in this case, the hwnd
        parameter must be the handle of a scroll-bar control.

    SB_HORZ
        Retrieves the position of a window's horizontal scroll bar.

    SB_VERT
        Retrieves the position of a window's vertical scroll bar.

    <lpMinPos>
        Points to the integer variable that is to receive the minimum
        position.

    <lpMaxPos>
        Points to the integer variable that is to receive the maximum
        position.

    This function does not return a value.

    The default range for a standard scroll bar is 0 to 100. The default range
    for a scroll-bar control is empty (both values are zero).
--*/

ULONG FASTCALL WU32GetScrollRange(PVDMFRAME pFrame)
{
    INT t3;
    INT t4;
    register PGETSCROLLRANGE16 parg16;

    GETARGPTR(pFrame, sizeof(GETSCROLLRANGE16), parg16);

    GetScrollRange(
        HWND32(parg16->f1),
        INT32(parg16->f2),
        &t3,
        &t4
        );

    PUTINT16(parg16->f3, t3);
    PUTINT16(parg16->f4, t4);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    ULONG GetTimerResolution(VOID)


    This function has no parameters.

    The Win 3.0 & 3.1 code just return 1000.

    Contacts on this: NeilK DarrinM

    The return value is always 1000.

--*/

ULONG FASTCALL WU32GetTimerResolution(PVDMFRAME pFrame)
{

    UNREFERENCED_PARAMETER(pFrame);

    RETURN(1000L);
}


/*++
    BOOL GetUpdateRect(<hwnd>, <lpRect>, <bErase>)
    HWND <hwnd>;
    LPRECT <lpRect>;
    BOOL <bErase>;

    The %GetUpdateRect% function retrieves the coordinates of the smallest
    rectangle that completely encloses the update region of the given window. If
    the window was created with the CS_OWNDC style and the mapping mode is not
    MM_TEXT, the %GetUpdateRect% function gives the rectangle in logical
    coordinates. Otherwise, %GetUpdateRect% gives the rectangle in client
    coordinates. If there is no update region, %GetUpdateRect% makes the
    rectangle empty (sets all coordinates to zero).

    The <bErase> parameter specifies whether %GetUpdateRect% should erase the
    background of the update region. If <bErase> is TRUE and the update region
    is not empty, the background is erased. To erase the background,
    %GetUpdateRect% sends a WM_ERASEBKGND message to the given window.

    <hwnd>
        Identifies the window whose update region is to be retrieved.

    <lpRect>
        Points to the %RECT% structure that is to receive the
        client coordinates of the enclosing rectangle.

    <bErase>
        Specifies whether the background in the update region is to be
        erased.

    The return value specifies the status of the update region of the given
    window. It is TRUE if the update region is not empty. Otherwise, it is
    FALSE.

    The update rectangle retrieved by the %BeginPaint% function is identical to
    that retrieved by the %GetUpdateRect% function.

    %BeginPaint% automatically validates the update region, so any call to
    %GetUpdateRect% made immediately after the %BeginPaint% call retrieves an
    empty update region.
--*/

ULONG FASTCALL WU32GetUpdateRect(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PGETUPDATERECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETUPDATERECT16), parg16);

    ul = GETBOOL16(GetUpdateRect(
                       HWND32(parg16->f1),
                       &t2,
                       BOOL32(parg16->f3)
                       ));


    PUTRECT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32GlobalAddAtom(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    UINT dw1;
    register PGLOBALADDATOM16 parg16;

    GETARGPTR(pFrame, sizeof(GLOBALADDATOM16), parg16);

    dw1 = UINT32(parg16->f1);

    if (!HIWORD(dw1)) {

        //
        // If the hiword is zero, it's not a pointer.
        // Instead, it's an integer and we either return
        // the integer passed (if it's not a valid atom
        // value), or zero (if it is a valid atom value).
        //

        if (!dw1 || dw1 >= 0xc000) {
            ul = 0;
        } else {
            ul = dw1;
        }

    } else {

        GETPSZPTR(parg16->f1, psz1);

        ul = GETATOM16(GlobalAddAtom(
                 psz1
                 ));

        FREEPSZPTR(psz1);

    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32GlobalDeleteAtom(PVDMFRAME pFrame)
{

    // Envoy viewer (part of PerfectOffice) has a bug in GlobalDeleteAtom
    // where it expects the wrong return value (the app thought 0 was
    // failure while its for success). This causes the app to go in an
    // infinite loop trying to delete a global object. This app works on
    // Win3.1 because Win3.1 returns some garbage in AX if the atom is
    // already deleted which takes this app out of the loop. On Win95 and
    // NT3.51 that is not the case and 0 is always returned. The following
    // comaptibility fix mimics the win3.1 behavior for this app.

    ULONG ul;
    static USHORT envoyHandle16=0;
    static BOOL   fFoundEnvoyAtom = FALSE;
    BOOL    IsEnvoy;
    CHAR  envoyString [32];
    register PGLOBALDELETEATOM16 parg16;

    GETARGPTR(pFrame, sizeof(GLOBALDELETEATOM16), parg16);

    IsEnvoy = (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_GLOBALDELETEATOM);
    if (IsEnvoy){
        if (!fFoundEnvoyAtom && GlobalGetAtomName (ATOM32(parg16->f1),
                               envoyString,
                               32) &&
                !WOW32_stricmp (envoyString, "SomeEnvoyViewerIsRunning")) {
            envoyHandle16 = parg16->f1;
        }

    }
    ul = GETATOM16(GlobalDeleteAtom(
    ATOM32(parg16->f1)
    ));

    if (IsEnvoy){
        if (envoyHandle16 && !fFoundEnvoyAtom) {
            fFoundEnvoyAtom = TRUE;
        }
        else if (fFoundEnvoyAtom) {
            if (envoyHandle16 == parg16->f1) {
                envoyHandle16 = 0;
                fFoundEnvoyAtom = FALSE;
                ul = parg16->f1;
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32GlobalGetAtomName(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSZ psz2;
    register PGLOBALGETATOMNAME16 parg16;

    GETARGPTR(pFrame, sizeof(GLOBALGETATOMNAME16), parg16);
    ALLOCVDMPTR(parg16->f2, parg16->f3, psz2);

    if (parg16->f1) {
        ul = GETWORD16(GlobalGetAtomName(ATOM32(parg16->f1),
                                         psz2,
                                         INT32(parg16->f3)));

        FLUSHVDMPTR(parg16->f2, strlen(psz2)+1, psz2);
    }
    else {
        *psz2 = '\0';
    }


    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL GrayString(<hDC>, <hBrush>, <lpOutputFunc>, <lpData>, <nCount>, <X>,
        <Y>, <nWidth>, <nHeight>)
    HDC <hDC>;
    HBRUSH <hBrush>;
    FARPROC <lpOutputFunc>;
    DWORD <lpData>;
    int <nCount>;
    int <X>;
    int <Y>;
    int <nWidth>;
    int <nHeight>;

    The %GrayString% function draws gray text at the given location. The
    %GrayString% function draws gray text by writing the text in a memory
    bitmap, graying the bitmap, and then copying the bitmap to the display. The
    function grays the text regardless of the selected brush and
    background. %GrayString% uses the font currently selected for the device
    context specified by the <hDC> parameter.

    If the <lpOutputFunc> parameter is NULL, GDI uses the %TextOut% function,
    and the <lpData> parameter is assumed to be a long pointer to the character
    string to be output. If the characters to be output cannot be handled by
    %TextOut% (for example, the string is stored as a bitmap), the application
    must supply its own output function.

    <hDC>
        Identifies the device context.

    <hBrush>
        Identifies the brush to be used for graying.

    <lpOutputFunc>
        Is the procedure-instance address of the application-supplied
        function that will draw the string, or, if the %TextOut% function is to
        be used to draw the string, it is a NULL pointer. See the following
        Comments section for details.

    <lpData>
        Specifies a long pointer to data to be passed to the output
        function. If the <lpOutputFunc> parameter is NULL, <lpData> must be a
        long pointer to the string to be output.

    <nCount>
        Specifies the number of characters to be output. If the <nCount>
        parameter is zero, %GrayString% calculates the length of the string
        (assuming that <lpData> is a pointer to the string). If <nCount> is -1
        and the function pointed to by <lpOutputFunc> returns zero, the image is
        shown but not grayed.

    <X>
        Specifies the logical <x>-coordinate of the starting position of
        the rectangle that encloses the string.

    <Y>
        Specifies the logical <y>-coordinate of the starting position of
        the rectangle that encloses the string.

    <nWidth>
        Specifies the width (in logical units) of the rectangle that
        encloses the string. If the <nWidth> parameter is zero, %GrayString%
        calculates the width of the area, assuming <lpData> is a pointer to the
        string.

    <nHeight>
        Specifies the height (in logical units) of the rectangle that
        encloses the string. If the <nHeight> parameter is zero, %GrayString%
        calculates the height of the area, assuming <lpData> is a pointer to the
        string.


    The return value specifies the outcome of the function. It is TRUE if the
    string is drawn. A return value of FALSE means that either the %TextOut%
    function or the application-supplied output function returned FALSE, or
    there was insufficient memory to create a memory bitmap for graying.

    An application can draw grayed strings on devices that support a solid gray
    color, without calling the %GrayString% function. The system color
    COLOR_GRAYTEXT is the solid-gray system color used to draw disabled text.
    The application can call the %GetSysColor% function to retrieve the color
    value of COLOR_GRAYTEXT. If the color is other than zero (black), the
    application can call the %SetTextColor% to set the text color to the color
    value and then draw the string directly. If the retrieved color is black,
    the application must call %GrayString% to gray the text.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%.

    Callback Function:

    BOOL FAR PASCAL <OutputFunc>(<hDC>, <lpData>, <nCount>)
    HDC <hDC>;
    DWORD <lpData>;
    int <nCount>;

    <OutputFunc> is a placeholder for the application-supplied callback function
    name. The actual name must be exported by including it in an %EXPORTS%
    statement in the application's module-definition file.

    <hDC>
        Identifies a memory device context with a bitmap of at least the width
        and height specified by the nWidth and nHeight parameters,
        respectively.

    <lpData>
        Points to the character string to be drawn.

    <nCount>
        Specifies the number of characters to be output.

    The return value must be TRUE to indicate success. Otherwise, it is FALSE.

    This output function (<OutputFunc>) must draw an image relative to the
    coordinates (0,0) rather than (<X,Y>). The address passed as the
    <lpOutputFunc> parameter must be created by using the %MakeProcInstance%
    function, and the output function name must be exported; it must be
    explicitly defined in an %EXPORTS% statement of the application's
    module-definition file.

    The MM_TEXT mapping mode must be selected before using this function.
--*/

BOOL W32GrayStringProc(HDC hDC,PGRAYSTRINGDATA pGray, int n) {
    INT iReturn;
    PARM16 Parm16;

    WOW32ASSERT(pGray);

    if (pGray->fResetLengthToZero)
        n = 0;

    LOGDEBUG(12,("    Graystring callback function, n = %d, hdc = %lx, %lx\n",n,hDC,pGray->dwUserParam));

    Parm16.GrayStringProc.n = (SHORT)n;
    Parm16.GrayStringProc.data = pGray->dwUserParam;
    pGray->hdc=Parm16.GrayStringProc.hdc = GETHDC16(hDC);
    CallBack16(RET_GRAYSTRINGPROC, &Parm16, pGray->vpfnGrayStringProc, (PVPVOID)&iReturn);

    LOGDEBUG(12,("    Graystring callback function returns %x\n",iReturn));
    return (BOOL)((SHORT)iReturn);
}

ULONG FASTCALL WU32GrayString(PVDMFRAME pFrame)
{
    ULONG          ul=0;
    PSZ            psz2;
    HDC            hdc;
    INT            n,wid,hgt;
    VPVOID         vpfn;
    VPVOID         vpstr;
    GRAYSTRINGDATA Gray;
    register PGRAYSTRING16 parg16;

    GETARGPTR(pFrame, sizeof(GRAYSTRING16), parg16);

    hdc=HDC32(parg16->f1);

    vpfn = DWORD32(parg16->f3);

    vpstr = DWORD32(parg16->f4);

    n=INT32(parg16->f5);

    wid=INT32(parg16->f8);
    hgt=INT32(parg16->f9);


    if ( HIWORD(vpfn) ) {       // SQLWin/repowin passes junk in low word

        Gray.fResetLengthToZero = FALSE;

        if( n==0 ) {

            n = 1;              // Prevent USER from doing strlen on &Gray below

            if ( HIWORD(vpstr) != 0 ) {  // Blow off small integers right away

                GETVDMPTR(vpstr, 0, psz2); // This might assert on mips, ignore it!

                if ( psz2 ) {
                    try {
                        n = strlen(psz2);
                        if (!n) {
                            n = 1;
                            Gray.fResetLengthToZero = TRUE;
                        }

                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                    }
                }

                FREEVDMPTR( psz2 );
            }
        }

        if ( wid == 0 || hgt == 0) {
            if ( HIWORD(vpstr) != 0 ) {
                GETVDMPTR(vpstr, 0, psz2); // This might assert on mips, ignore it!

                if (psz2) {
                    SIZE size;

                    try {
                        GetTextExtentPointA(hdc, (LPCSTR)psz2, n, &size);
                        wid = size.cx;
                        hgt = size.cy;
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                    }
                }

                FREEVDMPTR( psz2 );
            }
        }

        Gray.vpfnGrayStringProc = DWORD32(parg16->f3);
        Gray.dwUserParam        = vpstr;
        Gray.hdc = 0;

        LOGDEBUG(12,("    Graystring with callback %lx  n,w,h = %d,%d,%d\n",
                 vpstr,n,wid,hgt));


        ul = GETBOOL16(GrayString(hdc,
                                  HBRUSH32(parg16->f2),
                                  (GRAYSTRINGPROC)W32GrayStringProc,
                                  (DWORD)&Gray,
                                  n,
                                  INT32(parg16->f6),
                                  INT32(parg16->f7),
                                  wid,
                                  hgt));

    } else {

       GETPSZPTR(vpstr, psz2);

#ifdef DOESNT_USER_DO_THIS
        if( n==0 ) {
            n=strlen(psz2);
        }
        if( ((wid == 0) || (hgt == 0)) ) {
            GetTextExtentPoint(hdc,psz2,n,&sz);

            wid=sz.cx;
            hgt=sz.cy;
        }
#endif
        ul = GETBOOL16(GrayString(hdc,
                                  HBRUSH32(parg16->f2),
                                  NULL,
                                  (DWORD)psz2,
                                  n,
                                  INT32(parg16->f6),
                                  INT32(parg16->f7),
                                  wid,
                                  hgt));

        FREEPSZPTR(psz2);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    void InvalidateRect(<hwnd>, <lpRect>, <bErase>)
    HWND <hwnd>;
    LPRECT <lpRect>;
    BOOL <bErase>;

    The %InvalidateRect% function invalidates the client area within the given
    rectangle by adding that rectangle to the window's update region. The
    invalidated rectangle, along with all other areas in the update region, is
    marked for painting when the next WM_PAINT message occurs. The invalidated
    areas accumulate in the update region until the region is processed when the
    next WM_PAINT message occurs, or the region is validated by using the
    %ValidateRect% or %ValidateRgn% function.

    The <bErase> parameter specifies whether the background within the update
    area is to be erased when the update region is processed. If <bErase> is
    TRUE, the background is erased when the %BeginPaint% function is called;
    if <bErase> is FALSE, the background remains unchanged. If <bErase> is
    TRUE for any part of the update region, the background in the entire
    region is erased, not just in the given part.

    <hwnd>
        Identifies the window whose update region is to be modified.

    <lpRect>
        Points to a %RECT% structure that contains the rectangle
        (in client coordinates) to be added to the update region. If the
        <lpRect> parameter is NULL, the entire client area is added to the
        region.

    <bErase>
        Specifies whether the background within the update region is to
        be erased.

    This function does not return a value.

    Windows sends a WM_PAINT message to a window whenever its update region is
    not empty and there are no other messages in the application queue for that
    window.
--*/

ULONG FASTCALL WU32InvalidateRect(PVDMFRAME pFrame)
{
    RECT t2, *p2;
    register PINVALIDATERECT16 parg16;

    GETARGPTR(pFrame, sizeof(INVALIDATERECT16), parg16);
    p2 = GETRECT16(parg16->f2, &t2);

    InvalidateRect(
        HWND32(parg16->f1),
        p2,
        BOOL32(parg16->f3)
        );

    FREEARGPTR(parg16);
    RETURN(1);    // Win 3.x always returned 1 as a side-effect of jmping to
                  // IRedrawWindow [core\user\wmupdate.c] - MarkRi 5/93
}


/*++
    void InvalidateRgn(<hwnd>, <hRgn>, <bErase>)
    HWND <hwnd>;
    HRGN <hRgn>;
    BOOL <bErase>;

    The %InvalidateRgn% function invalidates the client area within the given
    region by adding it to the current update region of the given window. The
    invalidated region, along with all other areas in the update region, is
    marked for painting when the next WM_PAINT message occurs. The invalidated
    areas accumulate in the update region until the region is processed when the
    next WM_PAINT message occurs, or the region is validated by using the
    %ValidateRect% or %ValidateRgn% function.

    The <bErase> parameter specifies whether the background within the update
    area is to be erased when the update region is processed. If <bErase> is
    TRUE, the background is erased when the %BeginPaint% function is called; if
    <bErase> is FALSE, the background remains unchanged. If <bErase> is TRUE for
    any part of the update region, the background in the entire region is
    erased, not just in the given part.

    <hwnd>
        Identifies the window whose update region is to be modified.

    <hRgn>
        Identifies the region to be added to the update region. The
        region is assumed to have client coordinates.

    <bErase>
        Specifies whether the background within the update region is to
        be erased.

    This function does not return a value.

    Windows sends a WM_PAINT message to a window whenever its update region is
    not empty and there are no other messages in the application queue for that
    window.

    The given region must have been previously created by using one of the
    region functions (for more information, see Chapter 1, Window Manager
    Interface Functions).
--*/

ULONG FASTCALL WU32InvalidateRgn(PVDMFRAME pFrame)
{
    register PINVALIDATERGN16 parg16;

    GETARGPTR(pFrame, sizeof(INVALIDATERGN16), parg16);

    InvalidateRgn(
        HWND32(parg16->f1),
        HRGN32(parg16->f2),
        BOOL32(parg16->f3)
        );

    FREEARGPTR(parg16);
    RETURN(1);    // Win 3.x always returned 1 as a side-effect of jmping to
                  // IRedrawWindow [core\user\wmupdate.c] - MarkRi 5/93
}


/*++
    void InvertRect(<hDC>, <lpRect>)
    HDC <hDC>;
    LPRECT <lpRect>;

    The %InvertRect% function inverts the contents of the given rectangle. On
    monochrome displays, the %InvertRect% function makes white pixels black, and
    black pixels white. On color displays, the inversion depends on how colors
    are generated for the display. Calling %InvertRect% twice with the same
    rectangle restores the display to its previous colors.

    <hDC>
        Identifies the device context.

    <lpRect>
        Points to a %RECT% structure that contains the logical coordinates of
        the rectangle to be inverted.

    This function does not return a value.

    The %InvertRect% function compares the values of the %top%, %bottom%,
    %left%, and %right% members of the specified rectangle. If %bottom% is less
    than or equal to %top%, or if %right% is less than or equal to %left%, the
    rectangle is not drawn.
--*/

ULONG FASTCALL WU32InvertRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PINVERTRECT16 parg16;

    GETARGPTR(pFrame, sizeof(INVERTRECT16), parg16);

    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    InvertRect(
        HDC32(parg16->f1),
        &t2
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


ULONG FASTCALL WU32LoadBitmap(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSZ psz2;
    register PLOADBITMAP16 parg16;
    LPBYTE pResData = NULL;

    GETARGPTR(pFrame, sizeof(LOADBITMAP16), parg16);
    GETPSZIDPTR(parg16->f2, psz2);
    GETMISCPTR(parg16->f3, pResData);

    ul = GETHBITMAP16((pfnOut.pfnWOWLoadBitmapA)(HINSTRES32(parg16->f1),
                                     psz2,
                                     pResData,
                                     parg16->f4));

    FREEMISCPTR(pResData);
    FREEPSZIDPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    int ReleaseDC(<hwnd>, <hDC>)
    HWND <hwnd>;
    HDC <hDC>;

    The %ReleaseDC% function releases a device context, freeing it for use by
    other applications. The effect of the %ReleaseDC% function depends on the
    device-context type. It only frees common and window device contexts. It has
    no effect on class or private device contexts.

    <hwnd>
        Identifies the window whose device context is to be released.

    <hDC>
        Identifies the device context to be released.

    The return value specifies whether the device context is released. It is 1
    if the device context is released. Otherwise, it is zero.

    The application must call the %ReleaseDC% function for each call to the
    %GetWindowDC% function and for each call to the %GetDC% function that
    retrieves a common device context.
--*/

ULONG FASTCALL WU32ReleaseDC(PVDMFRAME pFrame)
{
    ULONG ul;
    register PRELEASEDC16 parg16;
    HAND16 htask16 = CURRENTPTD()->htask16;

    GETARGPTR(pFrame, sizeof(RELEASEDC16), parg16);

    CURRENTPTD()->ulLastDesktophDC = 0;

    // Note:  The GDI 16-32 mapping table gets updated for ReleaseDC in wreldc.c

    CacheReleasedDC(htask16, parg16->f1, parg16->f2);
    ul = TRUE;

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL ScrollDC(<hDC>, <dx>, <dy>, <lprcScroll>, <lprcClip>, <hrgnUpdate>,
        <lprcUpdate>)
    HDC <hDC>;
    int <dx>;
    int <dy>;
    LPRECT <lprcScroll>;
    LPRECT <lprcClip>;
    HRGN <hrgnUpdate>;
    LPRECT <lprcUpdate>;

    The %ScrollDC% function scrolls a rectangle of bits horizontally and
    vertically. The <lprcScroll> parameter points to the rectangle to be
    scrolled, the <dx> parameter specifies the number of units to be scrolled
    horizontally, and the <dy> parameter specifies the number of units to be
    scrolled vertically.

    <hDC>
        Identifies the device context that contains the bits to be scrolled.

    <dx>
        Specifies the number of horizontal scroll units.

    <dy>
        Specifies the number of vertical scroll units.

    <lprcScroll>
        Points to the %RECT% structure that contains the
        coordinates of the scrolling rectangle.

    <lprcClip>
        Points to the %RECT% structure that contains the
        coordinates of the clipping rectangle. When this rectangle is smaller
        than the original pointed to by <lprcScroll>, scrolling occurs only in
        the smaller rectangle.

    <hrgnUpdate>
        Identifies the region uncovered by the scrolling process. The
        %ScrollDC% function defines this region; it is not necessarily a
        rectangle.

    <lprcUpdate>
        Points to the %RECT% structure that, upon return, contains
        the coordinates of the rectangle that bounds the scrolling update
        region. This is the largest rectangular area that requires repainting.

    This value specifies the outcome of the function. It is TRUE if scrolling is
    executed. Otherwise, it is FALSE.

    If the <lprcUpdate> parameter is NULL, Windows does not compute the update
    rectangle. If both the <hrgnUpdate> and <lprcUpdate> parameters are NULL,
    Windows does not compute the update region. If <hrgnUpdate> is not NULL,
    Windows assumes that it contains a valid region handle to the region
    uncovered by the scrolling process (defined by the %ScrollDC% function).

    An application should use the %ScrollWindow% function when it is necessary
    to scroll the entire client area of a window. Otherwise, it should use
    %ScrollDC%.
--*/

ULONG FASTCALL WU32ScrollDC(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t4;
    RECT t5;
    RECT t7;
    register PSCROLLDC16 parg16;

    GETARGPTR(pFrame, sizeof(SCROLLDC16), parg16);

    ul = GETBOOL16(ScrollDC(
    HDC32(parg16->f1),
    INT32(parg16->f2),
    INT32(parg16->f3),
    GETRECT16(parg16->f4, &t4),
    GETRECT16(parg16->f5, &t5),
    HRGN32(parg16->f6),
    &t7
    ));

    PUTRECT16(parg16->f7, &t7);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND SetCapture(<hwnd>)
    HWND <hwnd>;

    The %SetCapture% function causes all subsequent mouse input to be sent to
    the window specified by the <hwnd> parameter, regardless of the position of
    the cursor.

    <hwnd>
        Identifies the window that is to receive the mouse input.

    The return value identifies the window that previously received all mouse
    input. It is NULL if there is no such window.

    When the window no longer requires all mouse input, the application should
    call the %ReleaseCapture% function so that other windows can receive mouse
    input.
--*/

ULONG FASTCALL WU32SetCapture(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETCAPTURE16 parg16;

    GETARGPTR(pFrame, sizeof(SETCAPTURE16), parg16);

    // MS Works Ver 3.0B has an unintialized local variable. We need to make
    // sure it see's a positive int value in the location on the stack where we
    // write the 32-bit thunk address for fast dispatching to this thunk.

    if (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_SETCAPSTACK) {
        // wCallID has already been used for dispatch so we can overwrite it.
        // Note: This will cause the logging on checked builds show ISCHILD()
        //       as the return API instead of SetCapture().
        //       For folks grepping for this:  SetCapture() : IsChild()
        pFrame->wCallID = 0x100;
    }

    ul = GETHWND16(SetCapture(HWND32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32SetEventHook(PVDMFRAME pFrame)
{
    PTD     ptd;
    PTDB    pTDB;
    DWORD   dwButtonPushed;
#ifdef FE_SB
    CHAR    szErrorMessage[256];
#else // !FE_SB
    CHAR    szErrorMessage[200];
#endif // !FE_SB
    char    szModName[9];
    char    szTitle[100];
    register PSETEVENTHOOK16 parg16;

    GETARGPTR(pFrame, sizeof(SETEVENTHOOK16), parg16);

    // Retail Build

    ptd = CURRENTPTD();
    if (ptd->dwFlags & TDF_FORCETASKEXIT) {
        goto SetEventHookExit;
    }

    pTDB = (PVOID)SEGPTR(ptd->htask16,0);

    RtlCopyMemory(szModName, pTDB->TDB_ModName, sizeof(szModName)-1);
    szModName[sizeof(szModName)-1] = 0;

    if (!LoadString(hmodWOW32, iszEventHook,
                    szErrorMessage, sizeof(szErrorMessage)/sizeof(CHAR)))
    {
        szErrorMessage[0] = 0;
    }
    if (!LoadString(hmodWOW32, iszApplication,
                    szTitle, sizeof(szTitle)/sizeof(CHAR)))
    {
        szTitle[0] = 0;
    }
    if((strlen(szTitle) + strlen(szModName)) < sizeof(szTitle)) {
        strcat(szTitle, szModName);
    }

    dwButtonPushed = WOWSysErrorBox(
            szTitle,
            szErrorMessage,
            SEB_CLOSE | SEB_DEFBUTTON,
            0,
            SEB_IGNORE
            );

    if (dwButtonPushed != 3) {
        //
        // If user typed Cancel or Any of the above fail,
        // force the task to die.
        //

        GETFRAMEPTR(ptd->vpStack, pFrame);
        pFrame->wRetID = RET_FORCETASKEXIT;

        ptd->dwFlags |= TDF_FORCETASKEXIT;
    }

SetEventHookExit:
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void SetKeyboardState(<lpKeyState>)
    LPBYTE <lpKeyState>;

    The %SetKeyboardState% function copies the 256 bytes pointed to by the
    <lpKeyState> parameter into the Windows keyboard-state table.

    <lpKeyState>
        Points to an array of 256 bytes that contains keyboard key states.

    This function does not return a value.

    In many cases, an application should call the %GetKeyboardState% function
    first to initialize the 256-byte array. The application should then change
    the desired bytes.

    %SetKeyboardState% sets the LEDs and BIOS flags for the ^NUMLOCK^,
    ^CAPSLOCK^, and ^SCROLL LOCK^ keys according to the toggle state of the
    VK_NUMLOCK, VK_CAPITAL, and VK_OEM_SCROLL entries of the array.

    For more information, see the description of %GetKeyboardState%, earlier in
    this chapter.
--*/

ULONG FASTCALL WU32SetKeyboardState(PVDMFRAME pFrame)
{
    PBYTE p1;
    register PSETKEYBOARDSTATE16 parg16;

    GETARGPTR(pFrame, sizeof(SETKEYBOARDSTATE16), parg16);
    GETVDMPTR(parg16->f1, 256, p1);

    SetKeyboardState(
    p1
    );

    FREEVDMPTR(p1);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void SetSysColors(<cDspElements>, <aiDspElements>, <aRgbValues>)
    int <cDspElements>;
    LPINT <aiDspElements>;
    LPDWORD <aRgbValues>;

    The %SetSysColors% function sets the system colors for one or more display
    elements. Display elements are the various parts of a window and the Windows
    display that appear on the system display screen.

    The %SetSysColors% function sends a WM_SYSCOLORCHANGE message to all windows
    to inform them of the change in color. It also directs Windows to repaint
    the affected portions of all currently visible windows.

    <cDspElements>
        Specifies the number of display elements in the <aiDspElements> array.

    <aiDspElements>
        Points to an array of integers that specify the display elements
        to be changed. For a list of possible display elements, see the following
        "Comments" section.

    <aRgbValues>
        Points to an array of unsigned long integers that contains the new RGB
        color value for each display element in the <aiDspElements> array.

    This function does not return a value.

    The %SetSysColors% function changes the current Windows session only. The
    new colors are not saved when Windows terminates.

    The following is the list of display elements that may be used in the array
    of display elements pointed to by the <aiDspElements> parameter:

    COLOR_ACTIVEBORDER
        Active window border.

    COLOR_ACTIVECAPTION
        Active window caption.

    COLOR_APPWORKSPACE
        Background color of multiple document interface (MDI) applications.

    COLOR_BACKGROUND
        Desktop.

    COLOR_BTNFACE
        Face shading on push buttons.

    COLOR_BTNSHADOW
        Edge shading on push buttons.

    COLOR_BTNTEXT
        Text on push buttons.

    COLOR_CAPTIONTEXT
        Text in caption, size box, scroll-bar arrow box.

    COLOR_GRAYTEXT
        Grayed (disabled) text. This color is set to 0 if the current display
        driver does not support a solid gray color.

    COLOR_HIGHLIGHT
        Items selected item in a control.

    COLOR_HIGHLIGHTTEXT
        Text of item selected in a control.

    COLOR_INACTIVEBORDER
        Inactive window border.

    COLOR_INACTIVECAPTION
        Inactive window caption.

    COLOR_INACTIVECAPTIONTEXT
        Color of text in an inactive caption.

    COLOR_MENU
        Menu background.

    COLOR_MENUTEXT
        Text in menus.

    COLOR_SCROLLBAR
        Scroll-bar gray area.

    COLOR_WINDOW
        Window background.

    COLOR_WINDOWFRAME
        Window frame.

    COLOR_WINDOWTEXT
        Text in windows.
--*/

#define SSC_BUF_SIZE	    256

ULONG FASTCALL WU32SetSysColors(PVDMFRAME pFrame)
{
    PINT p2;
    PDWORD p3;
    register PSETSYSCOLORS16 parg16;
    INT BufElements[SSC_BUF_SIZE];

    GETARGPTR(pFrame, sizeof(SETSYSCOLORS16), parg16);
    p2 = STACKORHEAPALLOC(INT32(parg16->f1) * sizeof(INT), sizeof(BufElements), BufElements);
    getintarray16(parg16->f2, INT32(parg16->f1), p2);
    GETDWORDARRAY16(parg16->f3, INT32(parg16->f1), p3);

    if (SetSysColors(
        INT32(parg16->f1),
        p2,
        p3
        ) == FALSE) {
#ifndef i386
    PDWORD p4;
    ULONG   BufRGB [SSC_BUF_SIZE];

        // On RISC platforms, SetSysColors could fail if the third parameter
        // is unaligned. We need to check that and copy it to an aligned
        // buffer before making this call. Win16 SetSysColor never fails
        // so on x86 if this ever fails under NT, it will just pass through.

        if ((ULONG)p3 & 3) {

            p4 = STACKORHEAPALLOC(INT32(parg16->f1) * sizeof(INT), sizeof(BufRGB), BufRGB);

            RtlMoveMemory ((PVOID)p4, (CONST VOID *)p3,
                                       INT32(parg16->f1) * sizeof(ULONG));


            SetSysColors(
                INT32(parg16->f1),
                p2,
                p4
                );
            STACKORHEAPFREE(p4, BufRGB);
        }
#endif

    }

    FREEDWORDARRAY16(p3);
    STACKORHEAPFREE(p2, BufElements);
    FREEARGPTR(parg16);
    RETURN(0);
}

/*++
    void InvalidateRect(<hwnd>, <lpRect>, <bErase>)
    HWND <hwnd>;
    LPRECT <lpRect>;
    BOOL <bErase>;

    The %InvalidateRect% function invalidates the client area within the given
    rectangle by adding that rectangle to the window's update region. The
    invalidated rectangle, along with all other areas in the update region, is
    marked for painting when the next WM_PAINT message occurs. The invalidated
    areas accumulate in the update region until the region is processed when the
    next WM_PAINT message occurs, or the region is validated by using the
    %ValidateRect% or %ValidateRgn% function.

    The <bErase> parameter specifies whether the background within the update
    area is to be erased when the update region is processed. If <bErase> is
    TRUE, the background is erased when the %BeginPaint% function is called;
    if <bErase> is FALSE, the background remains unchanged. If <bErase> is
    TRUE for any part of the update region, the background in the entire
    region is erased, not just in the given part.

    <hwnd>
        Identifies the window whose update region is to be modified.

    <lpRect>
        Points to a %RECT% structure that contains the rectangle
        (in client coordinates) to be added to the update region. If the
        <lpRect> parameter is NULL, the entire client area is added to the
        region.

    <bErase>
        Specifies whether the background within the update region is to
        be erased.

    This function does not return a value.

    Windows sends a WM_PAINT message to a window whenever its update region is
    not empty and there are no other messages in the application queue for that
    window.
--*/

ULONG FASTCALL WU32ValidateRect(PVDMFRAME pFrame)
{
    RECT t2, *p2;
    register PVALIDATERECT16 parg16;

    GETARGPTR(pFrame, sizeof(VALIDATERECT16), parg16);
    p2 = GETRECT16(parg16->f2, &t2);

    ValidateRect(
        HWND32(parg16->f1),
        p2
        );

    FREEARGPTR(parg16);
    RETURN(1);    // Win 3.x always returned 1 as a side-effect of jmping to
                  // IRedrawWindow [core\user\wmupdate.c] - MarkRi 5/93
}


/*++
    void InvalidateRgn(<hwnd>, <hRgn>, <bErase>)
    HWND <hwnd>;
    HRGN <hRgn>;
    BOOL <bErase>;

    The %InvalidateRgn% function invalidates the client area within the given
    region by adding it to the current update region of the given window. The
    invalidated region, along with all other areas in the update region, is
    marked for painting when the next WM_PAINT message occurs. The invalidated
    areas accumulate in the update region until the region is processed when the
    next WM_PAINT message occurs, or the region is validated by using the
    %ValidateRect% or %ValidateRgn% function.

    The <bErase> parameter specifies whether the background within the update
    area is to be erased when the update region is processed. If <bErase> is
    TRUE, the background is erased when the %BeginPaint% function is called; if
    <bErase> is FALSE, the background remains unchanged. If <bErase> is TRUE for
    any part of the update region, the background in the entire region is
    erased, not just in the given part.

    <hwnd>
        Identifies the window whose update region is to be modified.

    <hRgn>
        Identifies the region to be added to the update region. The
        region is assumed to have client coordinates.

    <bErase>
        Specifies whether the background within the update region is to
        be erased.

    This function does not return a value.

    Windows sends a WM_PAINT message to a window whenever its update region is
    not empty and there are no other messages in the application queue for that
    window.

    The given region must have been previously created by using one of the
    region functions (for more information, see Chapter 1, Window Manager
    Interface Functions).
--*/

ULONG FASTCALL WU32ValidateRgn(PVDMFRAME pFrame)
{
    register PVALIDATERGN16 parg16;

    GETARGPTR(pFrame, sizeof(VALIDATERGN16), parg16);

    ValidateRgn(
        HWND32(parg16->f1),
        HRGN32(parg16->f2)
        );

    FREEARGPTR(parg16);
    RETURN(1);    // Win 3.x always returned 1 as a side-effect of jmping to
                  // IRedrawWindow [core\user\wmupdate.c] - MarkRi 5/93
}


/*++
    BOOL WinHelp(<hwnd>, <lpHelpFile>, <wCommand>, <dwData>)
    HWND <hwnd>;
    LPSTR <lpHelpFile>;
    WORD <wCommand>;
    DWORD <dwData>;

    This function invokes the Windows Help application and passes optional data
    indicating the nature of the help requested by the application. The
    application specifies the name and, where required, the directory path of
    the help file which the Help application is to display.

    <hwnd>
        Identifies the window requesting help.

    <lpHelpFile>
        Points to a null-terminated string containing the directory
        path, if needed, and the name of the help file which the Help
        application is to display.

    <wCommand>
        Specifies the type of help requested. It may be any one of the
        following values:

    HELP_CONTEXT
        Displays help for a particular context identified by a 32-bit unsigned
        integer value in dwData.

    HELP_HELPONHELP
        Displays help for using the help application itself. If the <wCommand>
        parameter is set to HELP_HELPONHELP, %WinHelp% ignores the
        <lpHelpFile> and <dwData> parameters.

    HELP_INDEX
        Displays the index of the specified help file. An application should use
        this value only for help files with a single index. It should not use
        this value with HELP_SETINDEX.

    HELP_MULTIKEY
        Displays help for a key word in an alternate keyword table.

    HELP_QUIT
        Notifies the help application that the specified help file is no longer
        in use.

    HELP_SETINDEX
        Sets the context specified by the <dwData> parameter as the current
        index for the help file specified by the <lpHelpFile> parameter. This
        index remains current until the user accesses a different help file. To
        help ensure that the correct index remains set, the application should
        call %WinHelp% with <wCommand> set to HELP_SETINDEX (with <dwData>
        specifying the corresponding context identifier) following each call to
        %WinHelp% with <wCommand> set to HELP_CONTEXT. An application should use
        this value only for help files with more than one index. It should not
        use this value with HELP_INDEX.

    <dwData>
        %DWORD% Specifies the context or key word of the help requested. If
        <wCommand> is HELP_CONTEXT, <dwData> is a 32-bit unsigned integer
        containing a context-identifier number. If <wCommand> is HELP_KEY,
        <dwData> is a long pointer to a null-terminated string that contains a
        key word identifying the help topic. If <wCommand> is HELP_MULTIKEY,
        <dwData> is a long pointer to a %MULTIKEYHELP% structure.
        Otherwise, <dwData> is ignored and should be set to NULL.

    The return value specifies the outcome of the function. It is TRUE if the
    function was successful. Otherwise it is FALSE.

    The application must call %WinHelp% with <wCommand> set to HELP_QUIT before
    closing the window that requested the help. The Help application will not
    actually terminate until all applications that have requested help have
    called %WinHelp% with <wCommand> set to HELP_QUIT.
--*/

/*++ 
    RAID bug # 394455
    05/19/2001  alexsm
        
    Some applications were having problems finding and displaying their helpfiles 
    via the 16 bit winhelp. These issues can be fixed by redirecting the calls to
    winhlp32. 
    
    This redirection is activitated by the WOWCFEX_USEWINHELP32 compat flag. The flag
    is checked in the IWinHelp() function in user.exe. It redirects the call, along with 
    its parameters, to this 32 bit thunk. 

--*/


ULONG FASTCALL WU32WinHelp(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    register PWIN32WINHELP16 parg16;
    DWORD dwCommand;
    DWORD dwData;
    UINT  cb, len;
    MULTIKEYHELP *lpmkey;
    PMULTIKEYHELP16 pmkey16;
    HELPWININFO     hwinfo;
    PHELPWININFO16  phwinfo16;
    
    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    GETARGPTR(pFrame, sizeof(WIN32WINHELP16), parg16);

    GETPSZPTR(parg16->f2, psz2);
    dwCommand = WORD32(parg16->f3);

    switch (dwCommand) {
        case HELP_KEY:
        case HELP_COMMAND:
        case HELP_PARTIALKEY:
            GETPSZPTR(parg16->f4, (PSZ)dwData);
            break;

        case HELP_HELPONHELP:
             //
             // some apps (eg multimedia raid#) pass along a help file name which confuses winhlp32.exe
             // by definition the help gfile name parameter is meaningless.
             //
             psz2 = NULL;
             dwData = 0;
             break;


        case HELP_MULTIKEY:
            GETVDMPTR(parg16->f4, sizeof(MULTIKEYHELP16), pmkey16);
            cb = FETCHWORD(pmkey16->mkSize);
            FREEVDMPTR(pmkey16);
            GETVDMPTR(parg16->f4, cb, pmkey16);

            //
            // It is my understanding that 'mkSize' is the total
            // data length and NOT just sizeof(MULTIKEYHELP)
            //

            cb += sizeof(MULTIKEYHELP) - sizeof(MULTIKEYHELP16);
            // the *real* size of this MULTIKEYHELP32 struct
            len = strlen(pmkey16->szKeyphrase) + 1;
            if(cb < (len + sizeof(DWORD) + sizeof(TCHAR))) {
                cb = len + sizeof(DWORD) + sizeof(TCHAR);
            }
            
            lpmkey = (MULTIKEYHELP *)malloc_w(cb);
            if (lpmkey) {
                lpmkey->mkSize = cb;
                lpmkey->mkKeylist = pmkey16->mkKeylist;
                strncpy(lpmkey->szKeyphrase, pmkey16->szKeyphrase, len);
                lpmkey->szKeyphrase[len-1] = '\0';
            }
            FREEVDMPTR(pmkey16);
            dwData = (DWORD)lpmkey;
 
            break;

        case HELP_SETWINPOS:
            GETVDMPTR(parg16->f4, sizeof(HELPWININFO16), phwinfo16);

            hwinfo.wStructSize = (int)(FETCHWORD(phwinfo16->wStructSize) +
                                 (sizeof(HELPWININFO) - sizeof(HELPWININFO16)));
            hwinfo.x           = (int)FETCHSHORT(phwinfo16->x);
            hwinfo.y           = (int)FETCHSHORT(phwinfo16->y);
            hwinfo.dx          = (int)FETCHSHORT(phwinfo16->dx);
            hwinfo.dy          = (int)FETCHSHORT(phwinfo16->dy);
            hwinfo.wMax        = (int)FETCHSHORT(phwinfo16->wMax);
            hwinfo.rgchMember[0] = (CHAR)phwinfo16->rgchMember[0];
            hwinfo.rgchMember[1] = (CHAR)phwinfo16->rgchMember[1];

            FREEVDMPTR(phwinfo16);
            dwData = (DWORD)&hwinfo;
            break;

        default:
            dwData = DWORD32(parg16->f4);
            break;
    }
    
    LOGDEBUG(LOG_WARNING, 
            ("WU32Winhelp: Paramaters passed to WinHelp():/nHwnd=%x psz2=%x dwCommand=%x dwData=%x",
             parg16->f1, psz2, dwCommand, dwData));
    ul = GETBOOL16(WinHelp(HWND32(parg16->f1), psz2, dwCommand, dwData));

    switch (dwCommand) {
        case HELP_KEY:
        case HELP_COMMAND:
        case HELP_PARTIALKEY:
            FREEPSZPTR((PSZ)dwData);
            break;

        case HELP_MULTIKEY:
            if (lpmkey)
                free_w(lpmkey);
            break;

        case HELP_SETWINPOS:
            break;

        default:
            break;
    }


    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}



#pragma pack(1)

//
// win16 Module Table structure (based off of ne header)
// see wow16\inc\newexe.inc
//

typedef struct _NE_MODULE {
    USHORT ne_magic;           // Magic number
    USHORT ne_usage;           // usage count of module
    USHORT ne_enttab;          // Offset of Entry Table
    USHORT ne_pnextexe;        // sel next module table
    USHORT ne_pautodata;       // offset autodata seg table
    USHORT ne_pfileinfo;       // offset load file info
    USHORT ne_flags;           // Flag word
    USHORT ne_autodata;        // Automatic data segment number
    USHORT ne_heap;            // Initial heap allocation
    USHORT ne_stack;           // Initial stack allocation
    ULONG  ne_csip;            // Initial CS:IP setting
    ULONG  ne_sssp;            // Initial SS:SP setting
    USHORT ne_cseg;            // Count of file segments
    USHORT ne_cmod;            // Entries in Module Reference Table
    USHORT ne_cbnrestab;       // Size of non-resident name table
    USHORT ne_segtab;          // Offset of Segment Table
    USHORT ne_rsrctab;         // Offset of Resource Table
    USHORT ne_restab;          // Offset of resident name table
    USHORT ne_modtab;          // Offset of Module Reference Table
    USHORT ne_imptab;          // Offset of Imported Names Table
    ULONG  ne_nrestab;         // Offset of Non-resident Names Table
    USHORT ne_cmovent;         // Count of movable entries
    USHORT ne_align;           // Segment alignment shift count
    USHORT ne_cres;            // Count of resource segments
    UCHAR  ne_exetyp;          // Target Operating system
    UCHAR  ne_flagsothers;     // Other .EXE flags
    USHORT ne_pretthunks;      // offset to return thunks
    USHORT ne_psegrefbytes;    // offset to segment ref. bytes
    USHORT ne_swaparea;        // Minimum code swap area size
    USHORT ne_expver;          // Expected Windows version number
} NEMODULE;
typedef NEMODULE UNALIGNED *PNEMODULE;

#pragma pack()

#ifdef FE_IME
VOID WN32WINNLSSImeNotifyTaskExit();      // wnman.c
#endif // FE_IME

//
//   Performs Module cleanup (win31:tmdstroy.c\ModuleUnload())
//
void
ModuleUnload(
   HAND16  hModule16,
   BOOL fTaskExit
   )
{
   PNEMODULE pNeModule = SEGPTR(hModule16, 0);
   PTD ptd = CURRENTPTD();

   if (pNeModule->ne_usage == 1 || fTaskExit) {
       W32UnhookHooks(hModule16,FALSE);
   }

   if (fTaskExit) {
       ptd->dwFlags |= TDF_TASKCLEANUPDONE;
       (pfnOut.pfnWOWCleanup)(HINSTRES32(ptd->hInst16), (DWORD) ptd->htask16);
   }

   if (pNeModule->ne_usage > 1) {
       return;
       }

#ifdef FE_IME
   /*
    * We need to notify IMM that this WOW task is quiting before
    * calling WowCleanup or IME windows can not receive WM_DESTROY
    * and will fail to clean up their 32bit resource.
    */
   if ( fTaskExit ) {
       WN32WINNLSSImeNotifyTaskExit();
   }
#endif // FE_IME


    /*   WowCleanup, UserSrv private api
     *   It cleans up any USER objects created by this hModule, most notably
     *   classes, and subclassed windows.
     */
   (pfnOut.pfnWOWModuleUnload)((HANDLE)hModule16);

   RemoveHmodFromCache(hModule16);

}


WORD
FASTCALL
WOWGetProcModule16(
    DWORD vpfn
    )
{
    WOW32ASSERTMSG(gpfn16GetProcModule, "WOWGetProcModule16 called before gpfn16GetProcModule initialized.\n");

    return (WORD) WOWCallback16(
                      gpfn16GetProcModule,
                      vpfn
                      );
}


/*++
    BOOL SignalProc(<hwnd>, <lpHelpFile>, <wCommand>, <dwData>)
    HWND <hwnd>;
    LPSTR <lpHelpFile>;
    WORD <wCommand>;
    DWORD <dwData>;

    This function provides the communication link between KERNEL and USER.

--*/

#define SG_EXIT         0x0020
#define SG_LOAD_DLL     0x0040
#define SG_EXIT_DLL     0x0080
#define SG_GP_FAULT     0x0666



ULONG FASTCALL WU32SignalProc(PVDMFRAME pFrame)
{
    WORD    message;
    LONG    lparam;
    register PSIGNALPROC16 parg16;
    HAND16  hModule16;
    PTD     ptd;

    GETARGPTR(pFrame, sizeof(SIGNALPROC16), parg16);
    message   = FETCHWORD(parg16->f2);

    switch( message ) {
        case SG_EXIT:
        case SG_GP_FAULT:
            lparam    = FETCHDWORD(parg16->f4);
            ptd = CURRENTPTD();
            ptd->dwFlags |= TDF_IGNOREINPUT;
            ptd->cStackAlloc16 = 0;
            ModuleUnload(GetExePtr16((HAND16)HIWORD(lparam)), TRUE);
            FreeCursorIconAlias(ptd->htask16, CIALIAS_HTASK);
            break;

        case SG_LOAD_DLL:
            break;

        case SG_EXIT_DLL:
            hModule16 = FETCHWORD(parg16->f1);
            ModuleUnload(hModule16, FALSE);
            FreeCursorIconAlias(hModule16, CIALIAS_HMOD);
            break;
    }

    FREEARGPTR(parg16);
    RETURN(0);
}





// This routine checks the RECT structure (in PAINTSTRUCT) on BeginPaint
// call and updates its fields for maximum positive and minimum negative
// numbers for 16 bit apps to be compatible with win 3.1.
//

void W32FixPaintRect (VPVOID vpPaint, LPPAINTSTRUCT ps)
{
    SHORT i;
    PPAINTSTRUCT16 pps16;

    GETVDMPTR(vpPaint, sizeof(PAINTSTRUCT16), pps16);

    if (i = ConvertInt16 (ps->rcPaint.left)) {
        STORESHORT(pps16->rcPaint.left, i);
    }

    if (i = ConvertInt16 (ps->rcPaint.top)) {
        STORESHORT(pps16->rcPaint.top, i);
    }

    if (i = ConvertInt16 (ps->rcPaint.right)) {
        STORESHORT(pps16->rcPaint.right, i);
    }

    if (i = ConvertInt16 (ps->rcPaint.bottom)) {
        STORESHORT(pps16->rcPaint.bottom, i);
    }

    FLUSHVDMPTR(vpPaint, sizeof(PAINTSTRUCT16), pps16);
    FREEVDMPTR(pps16);
}

SHORT   ConvertInt16 (LONG x)
{
    if (x > (LONG)0x7fff)
        return((SHORT)0x7fff);

    if (x < (LONG)0xffff8000)
        return((SHORT)0x8000);

    return ((SHORT)0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuser31.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUSER31.H
 *  WOW32 16-bit Win 3.1 User API support
 *
 *  History:
 *  Created 16-Mar-1992 by Chandan S. Chauhan (ChandanC)
--*/

#define WINDOWPLACEMENT16TO32(vp,lp) {\
    LPWINDOWPLACEMENT16 lp16;\
    GETVDMPTR(vp, sizeof(WINDOWPLACEMENT16), lp16);\
    (lp)->length  = sizeof(WINDOWPLACEMENT);\
    (lp)->flags   = FETCHWORD(lp16->flags);\
    (lp)->showCmd = FETCHWORD(lp16->showCmd);\
    (lp)->ptMinPosition.x      = (INT) FETCHSHORT(lp16->ptMinPosition.x);\
    (lp)->ptMinPosition.y      = (INT) FETCHSHORT(lp16->ptMinPosition.y);\
    (lp)->ptMaxPosition.x      = (INT) FETCHSHORT(lp16->ptMaxPosition.x);\
    (lp)->ptMaxPosition.y      = (INT) FETCHSHORT(lp16->ptMaxPosition.y);\
    (lp)->rcNormalPosition.left   = (INT) FETCHSHORT(lp16->rcNormalPosition.left);\
    (lp)->rcNormalPosition.top    = (INT) FETCHSHORT(lp16->rcNormalPosition.top);\
    (lp)->rcNormalPosition.right  = (INT) FETCHSHORT(lp16->rcNormalPosition.right);\
    (lp)->rcNormalPosition.bottom = (INT) FETCHSHORT(lp16->rcNormalPosition.bottom);\
    FREEVDMPTR(lp16);\
}



#define WINDOWPLACEMENT32TO16(vp,lp) {\
    LPWINDOWPLACEMENT16 lp16;\
    GETVDMPTR(vp, sizeof(WINDOWPLACEMENT16), lp16);\
    STOREWORD(lp16->length, sizeof(WINDOWPLACEMENT16));\
    STOREWORD(lp16->flags, (lp)->flags);\
    STOREWORD(lp16->showCmd, (lp)->showCmd);\
    STORESHORT(lp16->ptMinPosition.x, (lp)->ptMinPosition.x);\
    STORESHORT(lp16->ptMinPosition.y, (lp)->ptMinPosition.y);\
    STORESHORT(lp16->ptMaxPosition.x, (lp)->ptMaxPosition.x);\
    STORESHORT(lp16->ptMaxPosition.y, (lp)->ptMaxPosition.y);\
    STORESHORT(lp16->rcNormalPosition.left, (lp)->rcNormalPosition.left);\
    STORESHORT(lp16->rcNormalPosition.top, (lp)->rcNormalPosition.top);\
    STORESHORT(lp16->rcNormalPosition.right, (lp)->rcNormalPosition.right);\
    STORESHORT(lp16->rcNormalPosition.bottom, (lp)->rcNormalPosition.bottom);\
    FLUSHVDMPTR(vp, sizeof(WINDOWPLACEMENT16), lp16);\
    FREEVDMPTR(lp16);\
}




ULONG FASTCALL WU32DlgDirSelectComboBoxEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32DlgDirSelectEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32EnableScrollBar(PVDMFRAME pFrame);
ULONG FASTCALL WU32ExitWindowsExec(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetClipCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetCursor(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetDCEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMessageExtraInfo(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetOpenClipboardWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowPlacement(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetFreeSystemResources(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetQueueStatus(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32LockWindowUpdate(PVDMFRAME pFrame);
ULONG FASTCALL WU32RedrawWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32ScrollWindowEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowPlacement(PVDMFRAME pFrame);
ULONG FASTCALL WU32SystemParametersInfo(PVDMFRAME pFrame);

ULONG FASTCALL WU32MapWindowPoints(PVDMFRAME pFrame);

//
// for ExitWindowsExec support
//

#define EWEXEC_SET   0
#define EWEXEC_DEL   1
#define EWEXEC_QUERY 2
#define WOWSZ_EWEXECEVENT "WOWEWExecEvent"
#define WOWSZ_EWEXECVALUE "EWExecCmdLine"

BOOL W32EWExecData(DWORD fnid, LPSTR lpData, DWORD cb);
BOOL W32EWExecer(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wusercli.h ===
//**************************************************************************
// wusercli.h : prototypes for thunks that may be handled on 16bit side
//
//**************************************************************************

ULONG FASTCALL WU32DefHookProc(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetKeyState(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetKeyboardState(PVDMFRAME pFrame);


#define WU32CLIENTTOSCREEN             WU32ClientToScreen
#define WU32GETCLASSNAME               IT(GetClassName)
#define WU32GETCLIENTRECT              WU32GetClientRect
#define WU32GETCURSORPOS               WU32GetCursorPos
#define WU32GETDESKTOPWINDOW           WU32GetDesktopWindow
#define WU32GETDLGITEM                 WU32GetDlgItem
#define WU32GETMENU                    WU32GetMenu
#define WU32GETMENUITEMCOUNT           WU32GetMenuItemCount
#define WU32GETMENUITEMID              IT(GetMenuItemID)
#define WU32GETMENUSTATE               IT(GetMenuState)
#define WU32GETNEXTWINDOW              IT(GetWindow)
#define WU32GETPARENT                  IT(GetParent)
#define WU32GETSUBMENU                 IT(GetSubMenu)
#define WU32GETSYSCOLOR                WU32GetSysColor
#define WU32GETSYSTEMMETRICS           WU32GetSystemMetrics
#define WU32GETTICKCOUNT               WU32GetTickCount
#define WU32GETTOPWINDOW               WU32GetTopWindow
#define WU32GETWINDOW                  IT(GetWindow)
#define WU32GETWINDOWRECT              WU32GetWindowRect
#define WU32ISCHILD                    WU32IsChild
#define WU32ISICONIC                   WU32IsIconic
#define WU32ISWINDOW                   WU32IsWindow 
#define WU32ISWINDOWENABLED            WU32IsWindowEnabled
#define WU32ISWINDOWVISIBLE            IT(IsWindowVisible)
#define WU32ISZOOMED                   WU32IsZoomed
#define WU32SCREENTOCLIENT             WU32ScreenToClient

ULONG FASTCALL WU32ClientToScreen(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetClientRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetCursorPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetDesktopWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetDlgItem(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemCount(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemID(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetSysColor(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetSystemMetrics(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetTopWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32ScreenToClient(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsChild(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsIconic(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsWindowEnabled(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsZoomed(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetTickCount(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuser.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUSER.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/

typedef struct _GRAYSTRINGDATA {    /* graystringdata */
    VPPROC  vpfnGrayStringProc;  // 16-bit  function
    DWORD   dwUserParam;    // user param
    HDC16   hdc;
    BOOL    fResetLengthToZero;
} GRAYSTRINGDATA, *PGRAYSTRINGDATA;



ULONG FASTCALL   WU32BeginPaint(PVDMFRAME pFrame);
ULONG FASTCALL   WU32CreateIcon(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DestroyIcon(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DragDetect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DrawFocusRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32DrawText(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EndPaint(PVDMFRAME pFrame);
ULONG FASTCALL   WU32EnumProps(PVDMFRAME pFrame);
ULONG FASTCALL   WU32FillWindow(PVDMFRAME pFrame);
ULONG FASTCALL   WU32FillRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32FrameRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetCapture(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetDC(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetScrollRange(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetTimerResolution(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GetUpdateRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GlobalAddAtom(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GlobalDeleteAtom(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GlobalGetAtomName(PVDMFRAME pFrame);
ULONG FASTCALL   WU32GrayString(PVDMFRAME pFrame);
ULONG FASTCALL   WU32InvalidateRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32InvalidateRgn(PVDMFRAME pFrame);
ULONG FASTCALL   WU32InvertRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsCharAlpha(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsCharAlphaNumeric(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsCharLower(PVDMFRAME pFrame);
ULONG FASTCALL   WU32IsCharUpper(PVDMFRAME pFrame);
ULONG FASTCALL   WU32LoadBitmap(PVDMFRAME pFrame);
ULONG FASTCALL   WU32LoadString(PVDMFRAME pFrame);
ULONG FASTCALL   WU32OffsetRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ReleaseDC(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ScrollDC(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetCapture(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetEventHook(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetKeyboardState(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SetSysColors(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ValidateRect(PVDMFRAME pFrame);
ULONG FASTCALL   WU32ValidateRgn(PVDMFRAME pFrame);
ULONG FASTCALL   WU32WinHelp(PVDMFRAME pFrame);
ULONG FASTCALL   WU32lstrcmp(PVDMFRAME pFrame);
ULONG FASTCALL   WU32lstrcmpi(PVDMFRAME pFrame);
ULONG FASTCALL   WU32wvsprintf(PVDMFRAME pFrame);
ULONG FASTCALL   WU32SignalProc(PVDMFRAME pFrame);

void    W32FixPaintRect (VPVOID vpPaint, LPPAINTSTRUCT ps);
SHORT   ConvertInt16 (LONG x);
WORD FASTCALL WOWGetProcModule16(DWORD vpfn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuser31.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUSER31.C
 *  WOW32 16-bit Win 3.1 User API support
 *
 *  History:
 *  Created 16-Mar-1992 by Chandan S. Chauhan (ChandanC)
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(wuser31.c);

ULONG FASTCALL WU32DlgDirSelectComboBoxEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      psz2;
    VPVOID   vp;
    register PDLGDIRSELECTCOMBOBOXEX16 parg16;

    GETARGPTR(pFrame, sizeof(DLGDIRSELECTCOMBOBOXEX16), parg16);
    GETVDMPTR(parg16->f2, INT32(parg16->f3), psz2);
    vp = parg16->f2;

    // note: this calls back to 16-bit code and could invalidate the flat ptrs
    ul = GETBOOL16(DlgDirSelectComboBoxEx(
    HWND32(parg16->f1),
    psz2,
    INT32(parg16->f3), 
    WORD32(parg16->f4) // we zero-extend window IDs everywhere
    ));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, INT32(parg16->f3), psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN (ul);
}


ULONG FASTCALL WU32DlgDirSelectEx(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    VPVOID vp;
    register PDLGDIRSELECTEX16 parg16;

    GETARGPTR(pFrame, sizeof(DLGDIRSELECTEX16), parg16);
    GETVDMPTR(parg16->f2, INT32(parg16->f3), psz2);
    vp = parg16->f2;

    ul = GETBOOL16(DlgDirSelectEx(
    HWND32(parg16->f1),
    psz2,
    INT32(parg16->f3),
    WORD32(parg16->f4)
    ));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, INT32(parg16->f3), psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN (ul);
}


ULONG FASTCALL WU32GetClipCursor(PVDMFRAME pFrame)
{
    RECT Rect;
    register PGETCLIPCURSOR16 parg16;

    GETARGPTR(pFrame, sizeof(GETCLIPCURSOR16), parg16);

    GetClipCursor(&Rect);

    PUTRECT16(parg16->f1, &Rect);

    FREEARGPTR(parg16);

    RETURN (0);  // GetClipCursor has no return value
}


ULONG FASTCALL WU32GetDCEx(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDCEX16 parg16;
    HAND16 htask16 = pFrame->wTDB;

    GETARGPTR(pFrame, sizeof(GETDCEX16), parg16);

    // This may need the same logic as WU32GetDC() and WU32GetWindowDC() to 
    // prevent a handle leak during the life of a given task (or at least until
    // the app calls GetDC() or GetWindowDC() which will empty the cache):
    // 
    //   if (CACHENOTEMPTY()) {
    //      ReleaseCachedDCs(htask16, parg16->f1, 0, 0, SRCHDC_TASK16_HWND16);
    //   }
    //   CURRENTPTD()->ulLastDesktophDC = 0;
    //
    // We may not be removing cached DC's in this case because the cache code
    // has no concept of "clip regions" which are associated with this API.  I
    // kind of doubt it because the SRCHDC_TASK16_HWND16 flag specified in the 
    // other two cases wlll cause all cached DC's to be released 
    // indiscriminantly.

    ul = GETHDC16(GetDCEx(HWND32(parg16->f1),
                          HRGN32(parg16->f2),
                          DWORD32(parg16->f3)));

    if (ul)
        StoreDC(htask16, parg16->f1, (HAND16)ul);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WU32RedrawWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT Rect, *p2;
    register PREDRAWWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(REDRAWWINDOW16), parg16);

    p2 = GETRECT16 (parg16->f2, &Rect);

    ul = GETBOOL16(RedrawWindow(HWND32(parg16->f1),
                                p2,
                                HRGN32(parg16->f3),
                                WORD32(parg16->f4)));

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WU32ScrollWindowEx(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSCROLLWINDOWEX16 parg16;

    RECT RectScroll, *p4;
    RECT RectClip, *p5;
    RECT RectUpdate;

    GETARGPTR(pFrame, sizeof(SCROLLWINDOWEX16), parg16);
    p4 = GETRECT16 (parg16->f4, &RectScroll);
    p5 = GETRECT16 (parg16->f5, &RectClip);

    ul = GETINT16(ScrollWindowEx(HWND32(parg16->f1),
                                 INT32(parg16->f2),
                                 INT32(parg16->f3),
                                 p4,
                                 p5,
                                 HRGN32(parg16->f6),
                                 &RectUpdate,
                                 UINT32(parg16->f8)));

    PUTRECT16 (parg16->f7, &RectUpdate);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WU32SystemParametersInfo(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PSYSTEMPARAMETERSINFO16 parg16;
    UINT    wParam;
    LONG    vParam;
    LOGFONT lf;
    INT     iMouse[3];
    PVOID   lpvParam;
    PWORD16 lpw;
    PDWORD16 lpdw;
    RECT    rect;
#ifndef _X86_
    DWORD   dwSize;
    LPBYTE  lpFree = NULL;
#endif

    GETARGPTR(pFrame, sizeof(SYSTEMPARAMETERSINFO16), parg16);

    // Assume these parameters fly straight through; fix them up per option
    // if they don't
    wParam = parg16->f2;
    lpvParam = &vParam;

    switch (parg16->f1) {

    case SPI_GETICONTITLELOGFONT:
        wParam = sizeof(LOGFONT);
        lpvParam = &lf;
        break;

    case SPI_SETICONTITLELOGFONT:
        GETLOGFONT16(parg16->f3, &lf);
        wParam = sizeof(LOGFONT);
        lpvParam = &lf;
        break;

    case SPI_GETMOUSE:
    case SPI_SETMOUSE:
        lpvParam = iMouse;
        break;

    case SPI_SETDESKPATTERN:
        // For the pattern if wParam == -1 then no string for lpvParam copy as is
        if (parg16->f2 == 0xFFFF) {
            wParam = 0xFFFFFFFF;
            lpvParam = (PVOID)parg16->f3;
            break;
        }
        // Otherwise fall through and do a string check

    case SPI_SETDESKWALLPAPER:
        // lpvParam (f3) is may be 0,-1 or a string
        if (parg16->f3 == 0xFFFF) {
            lpvParam = (PVOID)0xFFFFFFFF;
            break;
        }
        if (parg16->f3 == 0) {
            lpvParam = (PVOID)NULL;
            break;
        }
        // Otherwise fall through and do a string copy

    case SPI_LANGDRIVER:
        GETPSZPTR(parg16->f3, lpvParam);
        break;

    //
    // SPI_GET structures pointed to by pvParam, size in first dword of struct.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.  However unlike
    // Win95 we need to ensure the buffer passed to Win32 is aligned on RISC.
    // To have common code to thunk all these various structures, we align to
    // 16 bytes.
    //

    case SPI_GETACCESSTIMEOUT:
    case SPI_GETANIMATION:
    case SPI_GETNONCLIENTMETRICS:
    case SPI_GETMINIMIZEDMETRICS:
    case SPI_GETICONMETRICS:
    case SPI_GETFILTERKEYS:
    case SPI_GETSTICKYKEYS:
    case SPI_GETTOGGLEKEYS:
    case SPI_GETMOUSEKEYS:
    case SPI_GETSOUNDSENTRY:
#ifndef _X86_
        GETMISCPTR(parg16->f3, lpdw);
        dwSize = *lpdw;
        lpFree = malloc_w(dwSize + 16);
        if(lpFree) {
            lpvParam = (LPVOID)(((DWORD)lpFree + 16) & ~(16 - 1));
            *(PDWORD16)lpvParam = dwSize;
            break;
        }
        else {
            lpvParam = NULL;
        }
#endif             // otherwise fall through to simple struct case

    //
    // SPI_SET structures pointed to by pvParam, size in first dword of struct.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.  However unlike
    // Win95 we need to ensure the buffer passed to Win32 is aligned on RISC.
    // To have common code to thunk all these various structures, we align to
    // 16 bytes.
    //

    case SPI_SETANIMATION:
    case SPI_SETICONMETRICS:
    case SPI_SETMINIMIZEDMETRICS:
    case SPI_SETNONCLIENTMETRICS:
    case SPI_SETACCESSTIMEOUT:
#ifndef _X86_
        GETMISCPTR(parg16->f3, lpdw);
        dwSize = *lpdw;
        lpFree = malloc_w(dwSize + 16);
        if(lpFree) {
            lpvParam = (LPVOID)(((DWORD)lpFree + 16) & ~(16 - 1));
            RtlCopyMemory(lpvParam, lpdw, dwSize);
            break;
        }
        else {
            lpvParam = NULL;
        }
#endif             // otherwise fall through to simple struct case

    //
    // structures pointed to by pvParam, size in uiParam or first dword.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.
    //

    case SPI_GETHIGHCONTRAST:
    case SPI_GETSERIALKEYS:
    case SPI_SETDEFAULTINPUTLANG:
    case SPI_SETFILTERKEYS:
    case SPI_SETHIGHCONTRAST:
    case SPI_SETMOUSEKEYS:
    case SPI_SETSERIALKEYS:
    case SPI_SETSHOWSOUNDS:
    case SPI_SETSOUNDSENTRY:
    case SPI_SETSTICKYKEYS:
    case SPI_SETTOGGLEKEYS:
        GETMISCPTR(parg16->f3, lpvParam);
        break;

    //
    // pvParam points to WORD or BOOL
    //

    case SPI_GETBEEP:
    case SPI_GETBORDER:
    case SPI_GETDRAGFULLWINDOWS:
    case SPI_GETFASTTASKSWITCH:
    case SPI_GETFONTSMOOTHING:
    case SPI_GETGRIDGRANULARITY:
    case SPI_GETICONTITLEWRAP:
    case SPI_GETKEYBOARDSPEED:
    case SPI_GETKEYBOARDDELAY:
    case SPI_GETKEYBOARDPREF:
    case SPI_GETLOWPOWERACTIVE:
    case SPI_GETLOWPOWERTIMEOUT:
    case SPI_GETMENUDROPALIGNMENT:
    case SPI_GETMOUSETRAILS:
    case SPI_GETPOWEROFFACTIVE:
    case SPI_GETPOWEROFFTIMEOUT:
    case SPI_GETSCREENREADER:
    case SPI_GETSCREENSAVEACTIVE:
    case SPI_GETSCREENSAVETIMEOUT:
    case SPI_GETSHOWSOUNDS:
    case SPI_SCREENSAVERRUNNING:
        break;

    //
    // pvParam points to DWORD
    //

    case SPI_GETDEFAULTINPUTLANG:
        break;

    //
    // pvParam not used
    //

    case SPI_GETWINDOWSEXTENSION:
    case SPI_ICONHORIZONTALSPACING:
    case SPI_ICONVERTICALSPACING:
    case SPI_SETBEEP:
    case SPI_SETBORDER:
    case SPI_SETDOUBLECLICKTIME:
    case SPI_SETDOUBLECLKHEIGHT:
    case SPI_SETDOUBLECLKWIDTH:
    case SPI_SETDRAGFULLWINDOWS:
    case SPI_SETDRAGHEIGHT:
    case SPI_SETDRAGWIDTH:
    case SPI_SETFASTTASKSWITCH:
    case SPI_SETFONTSMOOTHING:
    case SPI_SETGRIDGRANULARITY:
    case SPI_SETHANDHELD:
    case SPI_SETICONTITLEWRAP:
    case SPI_SETKEYBOARDDELAY:
    case SPI_SETKEYBOARDPREF:
    case SPI_SETKEYBOARDSPEED:
    case SPI_SETLANGTOGGLE:
    case SPI_SETLOWPOWERACTIVE:
    case SPI_SETLOWPOWERTIMEOUT:
    case SPI_SETMENUDROPALIGNMENT:
    case SPI_SETMOUSEBUTTONSWAP:
    case SPI_SETMOUSETRAILS:
    case SPI_SETPENWINDOWS:
    case SPI_SETPOWEROFFACTIVE:
    case SPI_SETPOWEROFFTIMEOUT:
    case SPI_SETSCREENREADER:
    case SPI_SETSCREENSAVEACTIVE:
    case SPI_SETSCREENSAVETIMEOUT:
        break;

    //
    // pvParam points to a RECT
    //

    case SPI_GETWORKAREA:
    case SPI_SETWORKAREA:
        GETRECT16(parg16->f3, &rect);
        lpvParam = &rect;
        break;


    default:
#ifdef DEBUG
        {
            DWORD dwSaveOptions = flOptions;
            flOptions |= OPT_DEBUG;
            LOGDEBUG(0, ("WARNING SystemParametersInfo case %d not pre-thunked in WOW!\n", parg16->f1));
            flOptions = dwSaveOptions;
        }
#endif
        break;
    }


    ul = SystemParametersInfo(
        UINT32(parg16->f1),
        wParam,
        lpvParam,
        UINT32(parg16->f4)
        );


    switch (parg16->f1) {
    case SPI_GETICONTITLELOGFONT:
        PUTLOGFONT16(parg16->f3, sizeof(LOGFONT), lpvParam);
        break;

    case SPI_SETICONTITLELOGFONT:
        break;

    case SPI_GETMOUSE:
    case SPI_SETMOUSE:
        PUTINTARRAY16(parg16->f3, 3, lpvParam);
        break;

    case SPI_LANGDRIVER:
    case SPI_SETDESKWALLPAPER:
        FREEPSZPTR(lpvParam);
        break;

    case SPI_ICONHORIZONTALSPACING:
    case SPI_ICONVERTICALSPACING:
        // optional outee
        if (!parg16->f3)
            break;

        // fall through


    //
    // pvParam points to WORD or BOOL
    //

    case SPI_GETBEEP:
    case SPI_GETBORDER:
    case SPI_GETDRAGFULLWINDOWS:
    case SPI_GETFASTTASKSWITCH:
    case SPI_GETFONTSMOOTHING:
    case SPI_GETGRIDGRANULARITY:
    case SPI_GETICONTITLEWRAP:
    case SPI_GETKEYBOARDSPEED:
    case SPI_GETKEYBOARDDELAY:
    case SPI_GETKEYBOARDPREF:
    case SPI_GETLOWPOWERACTIVE:
    case SPI_GETLOWPOWERTIMEOUT:
    case SPI_GETMENUDROPALIGNMENT:
    case SPI_GETMOUSETRAILS:
    case SPI_GETPOWEROFFACTIVE:
    case SPI_GETPOWEROFFTIMEOUT:
    case SPI_GETSCREENREADER:
    case SPI_GETSCREENSAVEACTIVE:
    case SPI_GETSCREENSAVETIMEOUT:
    case SPI_GETSHOWSOUNDS:
    case SPI_SCREENSAVERRUNNING:
        GETVDMPTR(FETCHDWORD(parg16->f3), sizeof(*lpw), lpw);

        *lpw = (WORD)(*(LPLONG)lpvParam);

        FLUSHVDMPTR(FETCHDWORD(parg16->f3), sizeof(*lpw), lpw);
        FREEVDMPTR(lpw);

        break;

    //
    // pvParam points to DWORD
    //

    case SPI_GETDEFAULTINPUTLANG:
        GETVDMPTR(FETCHDWORD(parg16->f3), sizeof(*lpdw), lpdw);

        *lpdw = *(LPDWORD)lpvParam;

        FLUSHVDMPTR(FETCHDWORD(parg16->f3), sizeof(*lpdw), lpdw);
        FREEVDMPTR(lpdw);

        break;

    //
    // SPI_GET structures pointed to by pvParam, size in first dword of struct.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.  However unlike
    // Win95 we need to ensure the buffer passed to Win32 is aligned.  In order
    // to have common code to thunk all these various structures, we align to
    // 16 bytes.
    //

    case SPI_GETACCESSTIMEOUT:
    case SPI_GETANIMATION:
    case SPI_GETNONCLIENTMETRICS:
    case SPI_GETMINIMIZEDMETRICS:
    case SPI_GETICONMETRICS:
    case SPI_GETFILTERKEYS:
    case SPI_GETSTICKYKEYS:
    case SPI_GETTOGGLEKEYS:
    case SPI_GETMOUSEKEYS:
    case SPI_GETSOUNDSENTRY:
#ifndef _X86_
        RtlCopyMemory(lpdw, lpvParam, dwSize);
        FREEMISCPTR(lpdw);
        break;
#endif             // otherwise fall through to simple struct case

    //
    // SPI_SET structures pointed to by pvParam, size in first dword of struct.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.  However unlike
    // Win95 we need to ensure the buffer passed to Win32 is aligned.  In order
    // to have common code to thunk all these various structures, we align to
    // 16 bytes.
    //

    case SPI_SETANIMATION:
    case SPI_SETICONMETRICS:
    case SPI_SETMINIMIZEDMETRICS:
    case SPI_SETNONCLIENTMETRICS:
    case SPI_SETACCESSTIMEOUT:
#ifndef _X86_
        FREEMISCPTR(lpdw);
        break;
#endif             // otherwise fall through to simple struct case

    //
    // structures pointed to by pvParam, size in uiParam or first dword.
    // Note all these assume the Win16 and Win32 structures are equal.
    // These are all new for Win95 and thankfully that's true.
    //

    case SPI_GETHIGHCONTRAST:
    case SPI_GETSERIALKEYS:
    case SPI_SETDEFAULTINPUTLANG:
    case SPI_SETFILTERKEYS:
    case SPI_SETHIGHCONTRAST:
    case SPI_SETMOUSEKEYS:
    case SPI_SETSERIALKEYS:
    case SPI_SETSHOWSOUNDS:
    case SPI_SETSOUNDSENTRY:
    case SPI_SETSTICKYKEYS:
    case SPI_SETTOGGLEKEYS:
        FREEMISCPTR(lpvParam);
        break;


    //
    // pvParam not used
    //

    case SPI_GETWINDOWSEXTENSION:
    case SPI_SETBEEP:
    case SPI_SETBORDER:
    case SPI_SETDOUBLECLICKTIME:
    case SPI_SETDOUBLECLKHEIGHT:
    case SPI_SETDOUBLECLKWIDTH:
    case SPI_SETDRAGFULLWINDOWS:
    case SPI_SETDRAGHEIGHT:
    case SPI_SETDRAGWIDTH:
    case SPI_SETFASTTASKSWITCH:
    case SPI_SETFONTSMOOTHING:
    case SPI_SETGRIDGRANULARITY:
    case SPI_SETHANDHELD:
    case SPI_SETICONTITLEWRAP:
    case SPI_SETKEYBOARDDELAY:
    case SPI_SETKEYBOARDPREF:
    case SPI_SETKEYBOARDSPEED:
    case SPI_SETLANGTOGGLE:
    case SPI_SETLOWPOWERACTIVE:
    case SPI_SETLOWPOWERTIMEOUT:
    case SPI_SETMENUDROPALIGNMENT:
    case SPI_SETMOUSEBUTTONSWAP:
    case SPI_SETMOUSETRAILS:
    case SPI_SETPENWINDOWS:
    case SPI_SETPOWEROFFACTIVE:
    case SPI_SETPOWEROFFTIMEOUT:
    case SPI_SETSCREENREADER:
    case SPI_SETSCREENSAVEACTIVE:
    case SPI_SETSCREENSAVETIMEOUT:
        break;

    //
    // pvParam points to a RECT
    //

    case SPI_GETWORKAREA:
    case SPI_SETWORKAREA:
        PUTRECT16(parg16->f3, &rect);
        break;


    default:
#ifdef DEBUG
        {
            DWORD dwSaveOptions = flOptions;
            flOptions |= OPT_DEBUG;
            LOGDEBUG(0, ("WARNING SystemParametersInfo case %d not post-thunked in WOW!\n", parg16->f1));
            flOptions = dwSaveOptions;
        }
#endif
        break;
    }

#ifndef _X86_
    if (lpFree) {
        free_w(lpFree);
    }
#endif

    FREEARGPTR(parg16);
    RETURN (ul);
}


ULONG FASTCALL WU32SetWindowPlacement(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PSETWINDOWPLACEMENT16 parg16;

    WINDOWPLACEMENT wndpl;


    GETARGPTR(pFrame, sizeof(SETWINDOWPLACEMENT16), parg16);

    WINDOWPLACEMENT16TO32(parg16->f2, &wndpl);

    ul = GETBOOL16(SetWindowPlacement(HWND32(parg16->f1),
                                      &wndpl));

    FREEARGPTR(parg16);
    RETURN (ul);
}


ULONG FASTCALL WU32GetWindowPlacement(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PGETWINDOWPLACEMENT16 parg16;

    WINDOWPLACEMENT wndpl;


    GETARGPTR(pFrame, sizeof(GETWINDOWPLACEMENT16), parg16);

    wndpl.length = sizeof(WINDOWPLACEMENT);

    ul = GETBOOL16(GetWindowPlacement(HWND32(parg16->f1),
                                      &wndpl));

    WINDOWPLACEMENT32TO16(parg16->f2, &wndpl);

    FREEARGPTR(parg16);
    RETURN (ul);
}



ULONG FASTCALL WU32GetFreeSystemResources(PVDMFRAME pFrame)
{
    ULONG ul = 90;

    UNREFERENCED_PARAMETER( pFrame );

    RETURN (ul);
}


ULONG FASTCALL WU32ExitWindowsExec(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PEXITWINDOWSEXEC16 parg16;
    LPSTR   lpstrProgName;
    LPSTR   lpstrCmdLine;
    UINT    lengthProgName;
    UINT    lengthCmdLine;
    BYTE    abT[REGISTRY_BUFFER_SIZE];


    GETARGPTR(pFrame, sizeof(EXITWINDOWSEXEC16), parg16);

    GETPSZPTR(parg16->vpProgName, lpstrProgName);
    GETPSZPTR(parg16->vpCmdLine, lpstrCmdLine);

    lengthProgName = (lpstrProgName) ? strlen(lpstrProgName) : 0;
    lengthCmdLine  = (lpstrCmdLine)  ? strlen(lpstrCmdLine)  : 0;

    WOW32ASSERT(sizeof(abT) > (lengthProgName+lengthCmdLine+2));

    abT[0] = '\0';
    //                                                         + space + NULL
    if(sizeof(abT) >= (lengthProgName + lengthCmdLine + 1 + 1)) {
        if ( lpstrProgName ) {
            strcpy(abT, lpstrProgName );
        }
        if ( lpstrCmdLine ) {
            strcat(abT, " " );
            strcat(abT, lpstrCmdLine );
        }
    }
    else {
        return ul;
    }

    //
    // We write the commandline to registry "WOW/EWExecCmdLine"
    // If the system logs off successfully, after reboot, we read
    // the registry and exec the specfied app before launching any
    // wow app in any wow vdm. We donot launch the app before logoff
    // because winlogon doesn't allow any app to be execed during
    // the logoff process.
    //                                                - nanduri

    // only one exitwindowsexec call at a time.
    // if value/key exists, return error.

    if (!W32EWExecData(EWEXEC_QUERY, abT, sizeof(abT))) {
        HANDLE hevT;

        // only one exitwindowsexec call at a time.
        // if event exits, return error.

        if (hevT = CreateEvent(NULL, TRUE, FALSE, WOWSZ_EWEXECEVENT)) {
            if (GetLastError() == 0) {
                // wake up any waiting threads (in w32ewexecer)

                SetEvent(hevT);

                // Write the data to the registry

                if (W32EWExecData(EWEXEC_SET, abT, strlen(abT)+1)) {
                    DWORD   dwlevel;
                    DWORD   dwflags;

                    if (!GetProcessShutdownParameters(&dwlevel, &dwflags)) {
                        dwlevel = 0x280;    // default level per docs
                        dwflags = 0;
                    }

                    //
                    // 0xff = last system reserved level  Logically makes this last user
                    // process to shutdown. This takes care of Multiple WOW VDMs
                    //

                    SetProcessShutdownParameters(0xff, 0);

                    //
                    // EWX_NOTIFY private bit for WOW. Generates queue message
                    // WM_ENDSESSION, if any process cancels logoff/shutdown.

                    if (ExitWindowsEx(EWX_LOGOFF | EWX_NOTIFY, 0)) {
                        MSG msg;

                        //
                        //  PeekMessage yields to other WOW tasks. We effectively
                        //  freeze the current task by removing all input messages.
                        //  Loop terminates only if WM_ENDSESSION message has been
                        //  received. This message is posted by winsrv if any process
                        //  in the system cancels logoff.
                        //

                        while (TRUE) {
                            if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
                                if ((msg.message >= WM_MOUSEFIRST &&
                                        msg.message <= WM_MOUSELAST) ||
                                     (msg.message >= WM_KEYFIRST &&
                                        msg.message <= WM_KEYLAST) ||
                                     (msg.message >= WM_NCMOUSEMOVE &&
                                        msg.message <= WM_NCMBUTTONDBLCLK)) {

                                    // don't dispatch the message

                                }
                                else if (msg.message == WM_ENDSESSION) {
                                    WOW32ASSERT((msg.hwnd == 0) && (msg.wParam == 0));
                                    break;
                                }
                                else {
                                    TranslateMessage(&msg);
                                    DispatchMessage(&msg);
                                }
                            }
                        }
                    }

                    //
                    // Here if logoff was cancelled.
                    // Set defaults and delete the associated value from registry.
                    //

                    SetProcessShutdownParameters(dwlevel, dwflags);
                    if (!W32EWExecData(EWEXEC_DEL, (LPSTR)NULL, 0)) {
                        WOW32ASSERT(FALSE);
                    }
                }
            }
            CloseHandle(hevT);
        }
    }

    LOGDEBUG(0,("WOW: ExitWindowsExec failed\r\n"));
    FREEARGPTR(parg16);
    return 0;
}

ULONG FASTCALL WU32MapWindowPoints(PVDMFRAME pFrame)
{
    LPPOINT p3;
    register PMAPWINDOWPOINTS16 parg16;
    POINT  BufferT[128];


    GETARGPTR(pFrame, sizeof(MAPWINDOWPOINTS16), parg16);
    p3 = STACKORHEAPALLOC(parg16->f4 * sizeof(POINT), sizeof(BufferT), BufferT);


    if ( p3 ) {
         getpoint16(parg16->f3, parg16->f4, p3);

         MapWindowPoints(
           HWND32(parg16->f1),
           HWND32(parg16->f2),
           p3,
           INT32(parg16->f4)
           );

           PUTPOINTARRAY16(parg16->f3, parg16->f4, p3);
           STACKORHEAPFREE(p3, BufferT);
    }
    else {
        FREEARGPTR(parg16);
        RETURN(0);
    }
         
    FREEARGPTR(parg16);

    RETURN(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wusercli.c ===
//**************************************************************************
// wusercli.c :
//     Contains all functions that execute USER32 client code on 16bitside.
//     Most of these functions don't exist on x86 builds. So any changes
//     to these files must be reflected in wow16\user\usercli.asm
//
//                                                          - nanduri
//**************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(wusercli.c);


//**************************************************************************
//  WU32ClientToScreen -
//
//**************************************************************************

ULONG FASTCALL WU32ClientToScreen(PVDMFRAME pFrame)
{
    POINT t2;
    register PCLIENTTOSCREEN16 parg16;

    GETARGPTR(pFrame, sizeof(CLIENTTOSCREEN16), parg16);
    GETPOINT16(parg16->f2, &t2);

    ClientToScreen( HWND32(parg16->f1), &t2 );

    PUTPOINT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32GetClientRect -
//
//**************************************************************************

ULONG FASTCALL WU32GetClientRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PGETCLIENTRECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETCLIENTRECT16), parg16);

    /*
     * Home Design Gold 2.0
     *
     * If the call fails, don't overwrite the passed-in
     * rect.
     */
    if (GetClientRect(HWND32(parg16->hwnd), &t2)) {
        PUTRECT16(parg16->vpRect, &t2);
    }

    FREEARGPTR(parg16);
    RETURN(0);
}



//**************************************************************************
//  WU32GetCursorPos -
//
//**************************************************************************

ULONG FASTCALL WU32GetCursorPos(PVDMFRAME pFrame)
{
    POINT t1;
    register PGETCURSORPOS16 parg16;

    GETARGPTR(pFrame, sizeof(GETCURSORPOS16), parg16);

    GetCursorPos( &t1 );

    PUTPOINT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32GetDesktopWindow -
//
//**************************************************************************

ULONG FASTCALL WU32GetDesktopWindow(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETHWND16(GetDesktopWindow());

    RETURN(ul);
}


//**************************************************************************
//  WU32GetDlgItem -
//
//**************************************************************************

ULONG FASTCALL WU32GetDlgItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDLGITEM16 parg16;

    //
    // pass the child ID zero-extended.  this ID is the hMenu param to
    // CreateWindow, so USER gets this ID with hiword = 0.
    // Visual Basic relies on this.
    //


    GETARGPTR(pFrame, sizeof(GETDLGITEM16), parg16);

    ul = GETHWND16(GetDlgItem(HWND32(parg16->f1),WORD32(parg16->f2)));

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {
        ((PTDB)SEGPTR(pFrame->wTDB,0))->TDB_CompatHandle = (USHORT) ul;
    }


    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetMenu -
//
//**************************************************************************

ULONG FASTCALL WU32GetMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETMENU16 parg16;

    GETARGPTR(pFrame, sizeof(GETMENU16), parg16);

    ul = GETHMENU16(GetMenu(HWND32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetMenuItemCount -
//
//**************************************************************************

ULONG FASTCALL WU32GetMenuItemCount(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETMENUITEMCOUNT16 parg16;

    GETARGPTR(pFrame, sizeof(GETMENUITEMCOUNT16), parg16);

    ul = GETWORD16(GetMenuItemCount( HMENU32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetSysColor -
//
//**************************************************************************

ULONG FASTCALL WU32GetSysColor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETSYSCOLOR16 parg16;

    GETARGPTR(pFrame, sizeof(GETSYSCOLOR16), parg16);

    ul = GETDWORD16(GetSysColor( INT32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetSystemMetrics -
//
//**************************************************************************

ULONG FASTCALL WU32GetSystemMetrics(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETSYSTEMMETRICS16 parg16;
    int     sm;

    GETARGPTR(pFrame, sizeof(GETSYSTEMMETRICS16), parg16);

    sm = INT32(parg16->f1);

    ul = GETINT16(GetSystemMetrics(sm) );

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetTopWindow -
//
//**************************************************************************

ULONG FASTCALL WU32GetTopWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETTOPWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(GETTOPWINDOW16), parg16);

    ul = GETHWND16(GetTopWindow(HWND32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


char szTrayWnd[] = "Shell_TrayWnd";

//**************************************************************************
//  WU32GetWindowRect -
//
//**************************************************************************

ULONG FASTCALL WU32GetWindowRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PGETWINDOWRECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWRECT16), parg16);

    /*
     * Home Design Gold 2.0
     *
     * If the call fails, don't overwrite the passed-in
     * rect.
     */
    if (GetWindowRect(HWND32(parg16->f1), &t2)) {

        // Sierra on-line setup hack (expects tray rect to be Classic style)
        // See bug #425058
        // Unfortunately we can't cache the tray hwnd because if explorer dies
        // while the VDM is still running, explorer will get a new hwnd when it
        // is restarted that won't match our cached one.

        // IMHO this could be a general fix and not under an app compat flag
        // in BlackComb.
        if(CURRENTPTD()->dwWOWCompatFlags2 & WOWCF2_FIXLUNATRAYRECT) {

            char szClassName[20];

            if(GetClassName((HWND)parg16->f1,
                            szClassName,
                            sizeof(szClassName))) {

                if(!lstrcmp(szClassName, szTrayWnd)) {

                    // these will only be 0 for the Luna theme
                    if((t2.left == 0) || (t2.top == 0)) {

                        // Find tray position on desktop. Leave the border that
                        // is actually in the desktop alone so that the apps can
                        // calculate their windows accurately.

                        /*******************************************************
                        * Note: IMHO the code that is commented out below could
                        *       be uncommented for BlackComb as it more acurr-
                        *       ately resembles what would be returned in
                        *       Classic view.  Instead, since we are late in the
                        *       cycle for Whistler (RC2), we adjust the bare
                        *       minimum required to fix the known Sierra cases.
                        *
                        * // if tray is at the BOTTOM of the desktop window
                        * if(t2.top > 0) {
                        *     t2.left--;
                        *     t2.right++;
                        *     t2.bottom++;
                        *
                        * // else if the tray is at the RIGHT of desktop window
                        * } else if(t2.left > 0) {
                        *     t2.top--;
                        *     t2.right++;
                        *     t2.bottom++;
                        *
                        * // else if the tray is at the TOP of desktop window
                        * } else if(t2.right > t2.bottom) {
                        *     t2.top--;
                        *     t2.left--;
                        *     t2.right++;
                        *
                        * // else the tray must be at the LEFT of desktop window
                        * } else {
                        *     t2.top--;
                        *     t2.left--;
                        *     t2.bottom++;
                        * }
                        *******************************************************/

                       // if tray is at the BOTTOM of the desktop window
                       if(t2.top > 0)
                           t2.bottom++;

                       // else if the tray is at the TOP of the desktop window
                       else if(t2.right > t2.bottom)
                           t2.top--;
                    }
                }
            }
        }
        PUTRECT16(parg16->f2, &t2);
    }

    FREEARGPTR(parg16);
    RETURN(0);
}



//**************************************************************************
//  WU32IsWindow -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindow(PVDMFRAME pFrame)
{
    ULONG  ul;
    HWND   hWnd;
    register PISWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOW16), parg16);

    hWnd = HWND32(parg16->f1);

    ul = GETBOOL16(IsWindow(hWnd));

    // For apps that get burned by recycled handles -- ie. the old handle they
    // had has been destroyed & realloc'd to a different window -- not the one
    // they were expecting.  This needs to be handled on an app by app basis.
    if(ul && (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FAKENOTAWINDOW)) {

        // NetScape 4.0x install (the bug is in InstallShield)
        // Test the offset portion of the 16:16 return address to this call.
        // Bug #132616 et al
        switch(pFrame->vpCSIP & 0x0000FFFF) {

            case 0x4880:  // (InstallShield 3.00.104.0)
            case 0x44E4:  // (InstallShield 3.00.091.0)

            {
                ULONG  result;
                LPVOID lp;

                // we only want this to fail for calls during Int.Shld cleanup
                // we probably shouldn't fail it if was created by a WOW process
                result = GetWindowLong(hWnd, GWL_WNDPROC);
                if(!IsWOWProc(result)) {
                    goto IW_HACK;
                }

                // extra sanity check: InstallSheild calls GetWindowLong & uses
                // the returned value as a 16:16 ptr
                result = GetWindowLong(hWnd, DWL_MSGRESULT);
                GETVDMPTR(result, sizeof(VPVOID), lp);
                if(!lp) {
                    goto IW_HACK;
                }
                break;
                    
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);

IW_HACK:
    WOW32WARNMSG((0),"WOW32::IsWindow hack hit!\n");
    RETURN(0);
   
}



//**************************************************************************
//  WU32ScreenToClient -
//
//**************************************************************************

ULONG FASTCALL WU32ScreenToClient(PVDMFRAME pFrame)
{
    POINT t2;
    register PSCREENTOCLIENT16 parg16;

    GETARGPTR(pFrame, sizeof(SCREENTOCLIENT16), parg16);
    GETPOINT16(parg16->f2, &t2);

    ScreenToClient( HWND32(parg16->f1), &t2 );

    PUTPOINT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32IsChild -
//
//**************************************************************************

ULONG FASTCALL WU32IsChild(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHILD16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHILD16), parg16);

    ul = GETBOOL16(IsChild( HWND32(parg16->f1), HWND32(parg16->f2) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsIconic -
//
//**************************************************************************

ULONG FASTCALL WU32IsIconic(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISICONIC16 parg16;

    GETARGPTR(pFrame, sizeof(ISICONIC16), parg16);

    ul = GETBOOL16(IsIconic( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsWindowEnabled -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindowEnabled(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISWINDOWENABLED16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOWENABLED16), parg16);

    ul = GETBOOL16(IsWindowEnabled( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsWindowVisible -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindowVisible(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISWINDOWVISIBLE16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOWVISIBLE16), parg16);

    ul = GETBOOL16(IsWindowVisible( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32IsZoomed -
//
//**************************************************************************

ULONG FASTCALL WU32IsZoomed(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISZOOMED16 parg16;

    GETARGPTR(pFrame, sizeof(ISZOOMED16), parg16);

    ul = GETBOOL16(IsZoomed( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetTickCount -
//
//**************************************************************************

ULONG FASTCALL WU32GetTickCount(PVDMFRAME pFrame)
{
    ULONG   ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = (ULONG)GetTickCount();

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GRAINYTICS) {

        //
        // round down to the nearest 55ms    this is for RelayGold, which
        // spins calling this API until consecutive calls return a delta
        // greater than 52.
        //

        ul = ul - (ul % 55);
    }

    RETURN(ul);
}



//**************************************************************************
//  On I386 all these functions her handled on clientside. But conditionally
//  they may endup doing the actual work via these thunks.
//
//  So any changes here like 'win31 compatiblity code' may have to be added
//  in mvdm\wow16\user\usercli.asm too.
//
//                                                               - nanduri
//**************************************************************************


//**************************************************************************
//  WU32DefHookProc -
//
//**************************************************************************

ULONG FASTCALL WU32DefHookProc(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDEFHOOKPROC16 parg16;
    HOOKSTATEDATA HkData;
    ULONG hHook16;
    INT iHookCode;
    INT nCode;
    LONG wParam;
    LONG lParam;
    LPINT lpiFunc;

    GETARGPTR(pFrame, sizeof(DEFHOOKPROC16), parg16);

    nCode = INT32(parg16->f1);
    wParam = WORD32(parg16->f2);
    lParam = DWORD32(parg16->f3);

    GETMISCPTR(parg16->f4, lpiFunc);
    hHook16 = FETCHDWORD(*lpiFunc);
    FREEVDMPTR(lpiFunc);

    if (ISVALIDHHOOK(hHook16)) {
        iHookCode = GETHHOOKINDEX(hHook16);
        HkData.iIndex = (BYTE)iHookCode;
        if ( W32GetHookStateData( &HkData ) ) {
            ul = (ULONG)WU32StdDefHookProc(nCode, wParam, lParam, iHookCode);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetKeyState -
//
//**************************************************************************

ULONG FASTCALL WU32GetKeyState(PVDMFRAME pFrame)
{
    ULONG ul;
    SHORT sTmp;
    register PGETKEYSTATE16 parg16;

    GETARGPTR(pFrame, sizeof(GETKEYSTATE16), parg16);

    sTmp = GetKeyState(INT32(parg16->f1));

    // compatiblity:
    // MSTEST (testdrvr.exe) tests the bit 0x80 for checking the
    // shift key state. This works in win31 because the keystate in win31 is
    // one byte long and because of similar code below
    //
    // win31 code is similar to:
    //             mov al, byte ptr keystate
    //             cbw
    //             ret
    //
    // if 'al' is 0x80, cbw will make ax = 0xff80 and thus in win31
    // (state & 0x8000) and (state & 0x0080) will work and mean the same.
    //

    ul = (ULONG)((sTmp & 0x8000) ? (sTmp | 0x80) : sTmp);



    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetKeyboardState -
//
//**************************************************************************

ULONG FASTCALL WU32GetKeyboardState(PVDMFRAME pFrame)
{
    PBYTE pb1;
    register PGETKEYBOARDSTATE16 parg16;

    GETARGPTR(pFrame, sizeof(GETKEYBOARDSTATE16), parg16);
    ALLOCVDMPTR(parg16->f1, 256, pb1);

#ifdef HACK32   // bug 5704
    if (pb1) {
        GetKeyboardState( pb1 );
    }
#else
        GetKeyboardState( pb1 );
#endif

    FLUSHVDMPTR(parg16->f1, 256, pb1);
    FREEVDMPTR(pb1);
    FREEARGPTR(parg16);
    RETURN(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutext.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTEXT.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WU32GetTabbedTextExtent(PVDMFRAME pFrame);
ULONG FASTCALL WU32TabbedTextOut(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutext.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTEXT.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wutext.c);


ULONG FASTCALL WU32GetTabbedTextExtent(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    PINT p5;
    register PGETTABBEDTEXTEXTENT16 parg16;
    INT BufferT[256];

    GETARGPTR(pFrame, sizeof(GETTABBEDTEXTEXTENT16), parg16);
    GETPSZPTR(parg16->f2, psz2);
    p5 = STACKORHEAPALLOC(parg16->f4 * sizeof(INT), sizeof(BufferT), BufferT);
    getintarray16(parg16->f5, parg16->f4, p5);

    ul = GETDWORD16(GetTabbedTextExtent(HDC32(parg16->f1), psz2,
                     INT32(parg16->f3),  INT32(parg16->f4), p5 ));

    STACKORHEAPFREE(p5, BufferT);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32TabbedTextOut(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz4;
    PINT p7;
    register PTABBEDTEXTOUT16 parg16;
    INT BufferT[256];

    GETARGPTR(pFrame, sizeof(TABBEDTEXTOUT16), parg16);
    GETPSZPTR(parg16->f4, psz4);
    p7 = STACKORHEAPALLOC(parg16->f6 * sizeof(INT), sizeof(BufferT), BufferT);
    getintarray16(parg16->f7, parg16->f6, p7);

    ul = GETLONG16(TabbedTextOut(
        HDC32(parg16->f1),
        INT32(parg16->f2),
        INT32(parg16->f3),
        psz4,
        INT32(parg16->f5),
        INT32(parg16->f6),
        p7,
        INT32(parg16->f8)
        ));

    STACKORHEAPFREE(p7, BufferT);
    FREEPSZPTR(psz4);
    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutmr.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTMR.C
 *  WOW32 16-bit User Timer API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *          24-Feb-1993 reworked to use array of timer functions - barryb
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wutmr.c);

LIST_ENTRY TimerList;

// Element Zero is unused.

STATIC PTMR aptmrWOWTimers[] = {
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL
                               };


STATIC TIMERPROC afnTimerFuncs[] = {
                        NULL,       W32Timer1,  W32Timer2,  W32Timer3,
                        W32Timer4,  W32Timer5,  W32Timer6,  W32Timer7,
                        W32Timer8,  W32Timer9,  W32Timer10, W32Timer11,
                        W32Timer12, W32Timer13, W32Timer14, W32Timer15,
                        W32Timer16, W32Timer17, W32Timer18, W32Timer19,
                        W32Timer20, W32Timer21, W32Timer22, W32Timer23,
                        W32Timer24, W32Timer25, W32Timer26, W32Timer27,
                        W32Timer28, W32Timer29, W32Timer30, W32Timer31,
                        W32Timer32, W32Timer33, W32Timer34
                        };


/* Timer mapping functions
 *
 * The basic 16-bit timer mapping operations are Add, Find and Free.  When
 * a 16-bit app calls SetTimer, we call Win32's SetTimer with W32TimerProc
 * in place of the 16-bit proc address.  Assuming the timer is successfully
 * allocated, we add the timer to our own table, recording the 16-bit proc
 * address.
 */


//
// Search for a timer by its 16-bit information.  Looks in the list of
// active timers.  If the timer is found by this routine, then SetTimer()
// has been called and KillTimer() has not yet been called.
//
PTMR IsDuplicateTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;
    register INT iTimer;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (iTimer=1; iTimer<NUMEL(aptmrWOWTimers); iTimer++) {

        ptmr = aptmrWOWTimers[iTimer];

        if (ptmr) {
            if (LOWORD(ptmr->dwEventID) == wIDEvent &&
                ptmr->htask16 == htask16 &&
                (ptmr->hwnd16 == hwnd16 || !ptmr->hwnd16)) {

                return ptmr;
            }
        }
    }

    return NULL;
}



//
// This is called to free *ALL* timers created with a given hwnd16
// ie. All timers created by SetTimer(hwnd != NULL, id, duration)
// This should only be called when the hwnd is being destroyed: DestroyWindow()
//
VOID FreeWindowTimers16(HWND hwnd32)
{
    register PTMR ptmr;
    register INT iTimer;
    HAND16 htask16;

    htask16 = CURRENTPTD()->htask16;

    for (iTimer=1; iTimer<NUMEL(aptmrWOWTimers); iTimer++) {

        ptmr = aptmrWOWTimers[iTimer];

        if (ptmr) {
            if (ptmr->htask16 == htask16 && GETHWND16(hwnd32) == ptmr->hwnd16) {

                // we can't wait for Win32 to kill the timer for us during its
                // normal DestroyWindow() handling because it might send another
                // WM_TIMER message which we are now not ready to handle.
                KillTimer(ptmr->hwnd32, ptmr->dwEventID);

                // now free our WOW structures supporting this timer
                FreeTimer16(ptmr);
            }
        }
    }
}





//
// Search for a timer by its 32-bit information.  Looks in the list of
// all timers (including those that have already been killed by KillTimer().
//
//
PTMR FindTimer32(HWND16 hwnd16, DWORD dwIDEvent)
{
    register PTMR ptmr;
    HAND16 htask16;

    htask16 = CURRENTPTD()->htask16;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (ptmr->dwEventID == dwIDEvent &&
            ptmr->htask16 == htask16 &&
            (ptmr->hwnd16 == hwnd16 || (hwnd16 && !ptmr->hwnd16))) {

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


//
// Search for a timer by its 16-bit information.  Looks in the list of
// all timers (including those that have already been killed by KillTimer().
//
//
PTMR FindTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (LOWORD(ptmr->dwEventID) == wIDEvent &&
            ptmr->htask16 == htask16 &&
            (ptmr->hwnd16 == hwnd16 || (hwnd16 && !ptmr->hwnd16))) {

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


//
// Search for a killed timer by its 16-bit information.
//
//
PTMR FindKilledTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (ptmr->wIndex == 0 &&
            ptmr->htask16 == htask16 &&
            ptmr->hwnd16 == hwnd16 &&
            (LOWORD(ptmr->dwEventID) == wIDEvent || !hwnd16)) {
            // 1. the timer has been killed and
            // 2. the timer is in this task and
            // 3. the hwnds match (both might be 0) and
            // 4. the IDs match, or the hwnds are both 0 (in that case,
            //    IDs are ignored)

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


VOID FreeTimer16(PTMR ptmr)
{
    WOW32ASSERT(ptmr->wIndex == 0 || ptmr == aptmrWOWTimers[ptmr->wIndex]);
    aptmrWOWTimers[ptmr->wIndex] = NULL;
    RemoveEntryList(&ptmr->TmrList);
    free_w(ptmr);
}


VOID DestroyTimers16(HTASK16 htask16)
{
    PTMR ptmr, next;

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = next) {

        next = (PTMR)ptmr->TmrList.Flink;
        if (ptmr->htask16 == htask16) {

            //
            // don't call KillTimer() if the timer was associated with
            // a window and the window is gone, USER has already
            // cleaned it up.
            //

            if (ptmr == aptmrWOWTimers[ptmr->wIndex] && (!ptmr->hwnd32 || IsWindow(ptmr->hwnd32))) {
                if ( KillTimer(ptmr->hwnd32, ptmr->dwEventID) ) {
                    LOGDEBUG(LOG_IMPORTANT,
                       ("DestroyTimers16:Killed %04x\n",ptmr->dwEventID));
                } else {
                    LOGDEBUG(LOG_ERROR,
                       ("DestroyTimers16:FAILED %04x\n",ptmr->dwEventID));
                }
            }
            FreeTimer16(ptmr);
        }

    }
}


VOID W32TimerFunc(UINT index, HWND hwnd, UINT idEvent, DWORD dwTime)
{
    PARM16 Parm16;
    register PTMR ptmr;

    ptmr = aptmrWOWTimers[index];

    if ( !ptmr ) {
        LOGDEBUG(LOG_ALWAYS,("    W32TimerFunc ERROR: cannot find timer %08x\n", idEvent));
        return;
    }

    if (ptmr->dwEventID != idEvent) {
        //
        // This is an extra timer message which was already in the message
        // queue when the app called KillTimer().  The PTMR isn't in the
        // array, but it is still linked into the TimerList.
        //
        LOGDEBUG(LOG_WARNING,("    W32TimerFunc WARNING: Timer %08x called after KillTimer()\n", idEvent));
        for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {
            if (ptmr->dwEventID == idEvent) {
                break;
            }
        }

        if ( ptmr == (PTMR)&TimerList ) {
            LOGDEBUG(LOG_ALWAYS,("    W32TimerFunc ERROR: cannot find timer %08x (second case)\n", idEvent));
            return;
        }
    }

    Parm16.WndProc.hwnd   = ptmr->hwnd16;
    Parm16.WndProc.wMsg   = WM_TIMER;
    Parm16.WndProc.wParam = LOWORD(ptmr->dwEventID);
    Parm16.WndProc.lParam = dwTime;
    Parm16.WndProc.hInst  = 0;     // callback16 defaults to ss

    CallBack16(RET_WNDPROC, &Parm16, ptmr->vpfnTimerProc, NULL);
}


/*++
    BOOL KillTimer(<hwnd>, <nIDEvent>)
    HWND <hwnd>;
    INT <nIDEvent>;

    The %KillTimer% function kills the timer event identified by the <hwnd> and
    <nIDEvent> parameters. Any pending WM_TIMER messages associated with the
    timer are removed from the message queue.

    <hwnd>
        Identifies the window associated with the given timer event. This must
        be the same value passed as the hwnd parameter to the SetTimer function
        call that created the timer event.

    <nIDEvent>
        Specifies the timer event to be killed. If the application called
        %SetTimer% with the <hwnd> parameter set to NULL, this must be the event
        identifier returned by %SetTimer%. If the <hwnd> parameter of %SetTimer%
        was a valid window handle, <nIDEvent> must be the value of the
        <nIDEvent> parameter passed to %SetTimer%.

    The return value specifies the outcome of the function. It is TRUE if the
    event was killed. It is FALSE if the %KillTimer% function could not find the
    specified timer event.
--*/

ULONG FASTCALL WU32KillTimer(PVDMFRAME pFrame)
{
    ULONG ul;
    register PTMR ptmr;
    register PKILLTIMER16 parg16;
    HWND16 hwnd16;
    WORD   wIDEvent;
    HAND16 htask16;

    GETARGPTR(pFrame, sizeof(KILLTIMER16), parg16);

    htask16  = CURRENTPTD()->htask16;
    hwnd16   = (HWND16)parg16->f1;
    wIDEvent = parg16->f2;

    ptmr = IsDuplicateTimer16(hwnd16, htask16, wIDEvent);

    if (ptmr) {
        ul = GETBOOL16(KillTimer(ptmr->hwnd32, ptmr->dwEventID));
        aptmrWOWTimers[ptmr->wIndex] = NULL;
        ptmr->wIndex = 0;
    }
    else {
        ul = 0;
        LOGDEBUG(LOG_IMPORTANT,("    WU32KillTimer ERROR: cannot find timer %04x\n", wIDEvent));
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD SetTimer(<hwnd>, <nIDEvent>, <wElapse>, <lpTimerFunc>)
    HWND <hwnd>;
    int <nIDEvent>;
    WORD <wElapse>;
    FARPROC <lpTimerFunc>;

    The %SetTimer% function creates a system timer event. When a timer event
    occurs, Windows passes a WM_TIMER message to the application-supplied
    function specified by the <lpTimerFunc> parameter. The function can then
    process the event. A NULL value for <lpTimerFunc> causes WM_TIMER messages
    to be placed in the application queue.

    <hwnd>
        Identifies the window to be associated with the timer. If hwnd is NULL,
        no window is associated with the timer.

    <nIDEvent>
        Specifies a nonzero timer-event identifier if the <hwnd> parameter
        is not NULL.

    <wElapse>
        Specifies the elapsed time (in milliseconds) between timer
        events.

    <lpTimerFunc>
        Is the procedure-instance address of the function to be
        notified when the timer event takes place. If <lpTimerFunc> is NULL, the
        WM_TIMER message is placed in the application queue, and the %hwnd%
        member of the %MSG% structure contains the <hwnd> parameter given in the
        %SetTimer% function call. See the following Comments section for
        details.

    The return value specifies the integer identifier for the new timer event.
    If the <hwnd> parameter is NULL, an application passes this value to the
    %KillTimer% function to kill the timer event. The return value is zero if
    the timer was not created.

    Timers are a limited global resource; therefore, it is important that an
    application check the value returned by the %SetTimer% function to verify
    that a timer is actually available.

    To install a timer function, %SetTimer% must receive a procedure-instance
    address of the function, and the function must be exported in the
    application's module-definition file. A procedure-instance address can be
    created using the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%.

    Callback Function:

    WORD FAR PASCAL <TimerFunc>(<hwnd>, <wMsg>, <nIDEvent>, <dwTime>)
    HWND <hwnd>;
    WORD <wMsg>;
    int <nIDEvent>;
    DWORD <dwTime>;

    <TimerFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window associated with the timer event.

    <wMsg>
        Specifies the WM_TIMER message.

    <nIDEvent>
        Specifies the timer's ID.

    <dwTime>
        Specifies the current system time.
--*/

ULONG FASTCALL WU32SetTimer(PVDMFRAME pFrame)
{
    ULONG ul;
    register PTMR ptmr;
    register PSETTIMER16 parg16;
    HWND16  hwnd16;
    WORD    wIDEvent;
    WORD    wElapse;
    DWORD   vpfnTimerProc;
    DWORD   dwTimerProc32;
    HAND16  htask16;
    INT     iTimer;

    GETARGPTR(pFrame, sizeof(SETTIMER16), parg16);

    ul = 0;

    htask16       = CURRENTPTD()->htask16;
    hwnd16        = (HWND16)parg16->f1;
    wIDEvent      = parg16->f2;
    wElapse       = parg16->f3;

    // Don't allow WOW apps to set a timer with a period of less than
    // 55 ms. Myst and Winstone depend on this.
    if (wElapse < 55) wElapse = 55;

    vpfnTimerProc = VPFN32(parg16->f4);

    ptmr = IsDuplicateTimer16(hwnd16, htask16, wIDEvent);

    if (!ptmr) {

        // Loop through the slots in the timer array

        iTimer = 2;
        while (iTimer < NUMEL(aptmrWOWTimers)) {
            /*
            ** Find a slot in the arrays for which
            ** no pointer has yet been allocated.
            */
            if ( !aptmrWOWTimers[iTimer] ) {

                //
                // See if there is already thunking information for this
                // timer.  If there is, delete it from the list of timer
                // info and re-use its memory because this new timer
                // superceeds the old thunking information.
                //
                ptmr = FindKilledTimer16(hwnd16, htask16, wIDEvent);
                if (ptmr) {

                    RemoveEntryList(&ptmr->TmrList);

                } else {

                    // Allocate a TMR structure for the new timer
                    ptmr = malloc_w(sizeof(TMR));

                }

                aptmrWOWTimers[iTimer] = ptmr;

                if (!ptmr) {
                    LOGDEBUG(LOG_ALWAYS,("    WOW32 ERROR: TMR allocation failure\n"));
                    return 0;
                }

                break;          // Fall out into initialization code
            }
            iTimer++;
        }
        if (iTimer >= NUMEL(aptmrWOWTimers)) {
            LOGDEBUG(LOG_ALWAYS,("    WOW32 ERROR: out of timer slots\n"));
            return 0;
        }

        // Initialize the constant parts of the TMR structure (done on 1st SetTimer)
        InsertHeadList(&TimerList, &ptmr->TmrList);
        ptmr->hwnd16    = hwnd16;
        ptmr->hwnd32    = HWND32(hwnd16);
        ptmr->htask16   = htask16;
        ptmr->wIndex    = (WORD)iTimer;
    }


    // Setup the changeable parts of the TMR structure (done for every SetTimer)

    if (vpfnTimerProc) {
        dwTimerProc32 = (DWORD)afnTimerFuncs[ptmr->wIndex];
    } else {
        dwTimerProc32 = (DWORD)NULL;
    }

    ptmr->vpfnTimerProc = vpfnTimerProc;
    ptmr->dwTimerProc32 = dwTimerProc32;

    ul = SetTimer(
                ptmr->hwnd32,
                (UINT)wIDEvent,
                (UINT)wElapse,
                (TIMERPROC)dwTimerProc32 );

    //
    // USER-generated timerID's are between 0x100 and 0x7fff
    //

    WOW32ASSERT(HIWORD(ul) == 0);

    if (ul) {

        ptmr->dwEventID = ul;

        //
        // when hwnd!=NULL and nEventID==0 the API returns 1 to
        // indicate success but the timer's ID is 0 as requested.
        //

        if (!wIDEvent && ptmr->hwnd32)
            ptmr->dwEventID = 0;

    } else {

        // Since the real SetTimer failed, free
        // our local data using simply our own timer ID

        FreeTimer16(ptmr);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


VOID CALLBACK W32Timer1(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(1, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer2(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(2, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer3(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(3, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer4(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(4, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer5(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(5, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer6(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(6, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer7(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(7, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer8(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(8, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer9(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(9, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer10(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(10, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer11(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(11, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer12(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(12, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer13(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(13, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer14(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(14, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer15(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(15, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer16(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(16, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer17(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(17, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer18(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(18, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer19(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(19, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer20(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(20, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer21(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(21, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer22(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(22, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer23(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(23, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer24(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(24, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer25(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(25, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer26(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(26, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer27(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(27, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer28(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(28, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer29(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(29, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer30(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(30, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer31(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(31, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer32(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(32, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer33(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(33, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer34(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(34, hwnd, idEvent, dwTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutbl.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTBL.H
 *  WOW32 16-bit User API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/



/* User dispatch table
 */
extern W32 aw32User[];



#ifdef DEBUG_OR_WOWPROFILE
extern INT iUserMax;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, 1992, 1993 Microsoft Corporation
 *
 *  WUTBL2.h
 *  WOW32 user API thunks
 *
 *  This file is included into the master thunk table.
 *
--*/


    {W32FUN(UNIMPLEMENTEDAPI,               "DUMMYENTRY",           MOD_USER,      0)},
    {W32FUN(WU32MessageBox,                 "MESSAGEBOX",           MOD_USER,      sizeof(MESSAGEBOX16))},
    {W32FUN(LOCALAPI,                       "OLDEXITWINDOWS",       MOD_USER,      0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENABLEOEMLAYER",       MOD_USER,      0)},
    {W32FUN(NOPAPI,                         "DISABLEOEMLAYER",      MOD_USER,      0)},
    {W32FUN(LOCALAPI,                       "INITAPP",              MOD_USER,      0)},
    {W32FUN(WU32PostQuitMessage,            "POSTQUITMESSAGE",      MOD_USER,      sizeof(POSTQUITMESSAGE16))},
    {W32FUN(WU32ExitWindows,                "EXITWINDOWS",          MOD_USER,      sizeof(EXITWINDOWS16))},
    {W32FUN(UNIMPLEMENTED95API,             "PlaySoundEvent",       MOD_USER,      sizeof(PLAYSOUNDEVENT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                     MOD_USER,      0)},

  /*** 0010 ***/
    {W32FUN(WU32SetTimer,                   "SETTIMER",              MOD_USER,     sizeof(SETTIMER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETSYSTEMTIMER",        MOD_USER,     0)},
    {W32FUN(WU32KillTimer,                  "KILLTIMER",             MOD_USER,     sizeof(KILLTIMER16))},
    {W32FUN(WU32GETTICKCOUNT,               "GETTICKCOUNT",          MOD_USER,     0)},
    {W32FUN(WU32GetTimerResolution,         "GETTIMERRESOLUTION",    MOD_USER,     0)},
    {W32FUN(WU32GETTICKCOUNT,               "GETCURRENTTIME",        MOD_USER,     0)},
    {W32FUN(WU32ClipCursor,                 "CLIPCURSOR",            MOD_USER,     sizeof(CLIPCURSOR16))},
    {W32FUN(WU32GETCURSORPOS,               "GETCURSORPOS",          MOD_USER,     sizeof(GETCURSORPOS16))},
    {W32FUN(WU32SetCapture,                 "SetCapture",            MOD_USER,     sizeof(SETCAPTURE16))},
    {W32FUN(IT(ReleaseCapture),             "ReleaseCapture",        MOD_USER,     0)},

  /*** 0020 ***/
    {W32FUN(IT(SetDoubleClickTime),         "SetDoubleClickTime",    MOD_USER,     sizeof(SETDOUBLECLICKTIME16))},
    {W32FUN(IT(GetDoubleClickTime),         "GetDoubleClickTime",    MOD_USER,     0)},
    {W32FUN(IT(SetFocus),                   "SetFocus",              MOD_USER,     sizeof(SETFOCUS16))},
    {W32FUN(IT(GetFocus),                   "GetFocus",              MOD_USER,     0)},
    {W32FUN(IT(RemoveProp),                 "RemoveProp",            MOD_USER,     sizeof(REMOVEPROP16))},
    {W32FUN(IT(GetProp),                    "GetProp",               MOD_USER,     sizeof(GETPROP16))},
    {W32FUN(IT(SetProp),                    "SetProp",               MOD_USER,     sizeof(SETPROP16))},
    {W32FUN(WU32EnumProps,                  "ENUMPROPS",             MOD_USER,     sizeof(ENUMPROPS16))},
    {W32FUN(WU32CLIENTTOSCREEN,             "CLIENTTOSCREEN",        MOD_USER,     sizeof(CLIENTTOSCREEN16))},
    {W32FUN(WU32SCREENTOCLIENT,             "SCREENTOCLIENT",        MOD_USER,     sizeof(SCREENTOCLIENT16))},

  /*** 0030 ***/
    {W32FUN(WU32WindowFromPoint,            "WindowFromPoint",        MOD_USER,    sizeof(WINDOWFROMPOINT16))},
    {W32FUN(WU32ISICONIC,                   "IsIconic",               MOD_USER,    sizeof(ISICONIC16))},
    {W32FUN(WU32GETWINDOWRECT,              "GetWindowRect",          MOD_USER,    sizeof(GETWINDOWRECT16))},
    {W32FUN(WU32GETCLIENTRECT,              "GetClientRect",          MOD_USER,    sizeof(GETCLIENTRECT16))},
    {W32FUN(IT(EnableWindow),               "EnableWindow",           MOD_USER,    sizeof(ENABLEWINDOW16))},
    {W32FUN(WU32ISWINDOWENABLED,            "IsWindowEnabled",        MOD_USER,    sizeof(ISWINDOWENABLED16))},
    {W32FUN(WU32GetWindowText,              "GetWindowText",          MOD_USER,    sizeof(GETWINDOWTEXT16))},
    {W32FUN(WU32SetWindowText,              "SetWindowText",          MOD_USER,    sizeof(SETWINDOWTEXT16))},
    {W32FUN(IT(GetWindowTextLength),        "GetWindowTextLength",    MOD_USER,    sizeof(GETWINDOWTEXTLENGTH16))},
    {W32FUN(WU32BeginPaint,                 "BEGINPAINT",             MOD_USER,    sizeof(BEGINPAINT16))},

  /*** 0040 ***/
    {W32FUN(WU32EndPaint,                   "ENDPAINT",               MOD_USER,    sizeof(ENDPAINT16))},
    {W32FUN(WU32CreateWindow,               "CreateWindow",           MOD_USER,    sizeof(CREATEWINDOW16))},
    {W32FUN(WU32ShowWindow,                 "ShowWindow",             MOD_USER,    sizeof(SHOWWINDOW16))},
    {W32FUN(IT(CloseWindow),                "CloseWindow",            MOD_USER,    sizeof(CLOSEWINDOW16))},
    {W32FUN(IT(OpenIcon),                   "OpenIcon",               MOD_USER,    sizeof(OPENICON16))},
    {W32FUN(IT(BringWindowToTop),           "BringWindowToTop",       MOD_USER,    sizeof(BRINGWINDOWTOTOP16))},
    {W32FUN(WU32GETPARENT,                  "GetParent",              MOD_USER,    sizeof(GETPARENT16))},
    {W32FUN(WU32ISWINDOW,                   "IsWindow",               MOD_USER,    sizeof(ISWINDOW16))},
    {W32FUN(WU32ISCHILD,                    "ISCHILD",                MOD_USER,    sizeof(ISCHILD16))},
    {W32FUN(WU32ISWINDOWVISIBLE,            "IsWindowVisible",        MOD_USER,    sizeof(ISWINDOWVISIBLE16))},

  /*** 0050 ***/
    {W32FUN(WU32FindWindow,                 "FINDWINDOW",             MOD_USER,    sizeof(FINDWINDOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISTWOBYTECHARPREFIX",    MOD_USER,    sizeof(ISTWOBYTECHARPREFIX16))},
    {W32FUN(IT(AnyPopup),                   "AnyPopup",               MOD_USER,    0)},
    {W32FUN(WU32DestroyWindow,              "DestroyWindow",          MOD_USER,    sizeof(DESTROYWINDOW16))},
    {W32FUN(WU32EnumWindows,                "EnumWindows",            MOD_USER,    sizeof(ENUMWINDOWS16))},
    {W32FUN(WU32EnumChildWindows,           "EnumChildWindows",       MOD_USER,    sizeof(ENUMCHILDWINDOWS16))},
    {W32FUN(WU32MoveWindow,                 "MoveWindow",             MOD_USER,    sizeof(MOVEWINDOW16))},
    {W32FUN(WU32RegisterClass,              "RegisterClass",          MOD_USER,    sizeof(REGISTERCLASS16))},
    {W32FUN(WU32GETCLASSNAME,               "GetClassName",           MOD_USER,    sizeof(GETCLASSNAME16))},
    {W32FUN(IT(SetActiveWindow),            "SetActiveWindow",        MOD_USER,    sizeof(SETACTIVEWINDOW16))},

  /*** 0060 ***/
    {W32FUN(WU32GetActiveWindow,            "GetActiveWindow",        MOD_USER,    0)},
    {W32FUN(WU32ScrollWindow,               "ScrollWindow",           MOD_USER,    sizeof(SCROLLWINDOW16))},
    {W32FUN(IT(SetScrollPos),               "SetScrollPos",           MOD_USER,    sizeof(SETSCROLLPOS16))},
    {W32FUN(IT(GetScrollPos),               "GetScrollPos",           MOD_USER,    sizeof(GETSCROLLPOS16))},
    {W32FUN(IT(SetScrollRange),             "SetScrollRange",         MOD_USER,    sizeof(SETSCROLLRANGE16))},
    {W32FUN(WU32GetScrollRange,             "GetScrollRange",         MOD_USER,    sizeof(GETSCROLLRANGE16))},
    {W32FUN(WU32GetDC,                      "GetDC",                  MOD_USER,    sizeof(GETDC16))},
    {W32FUN(WU32GetWindowDC,                "GetWindowDC",            MOD_USER,    sizeof(GETWINDOWDC16))},
    {W32FUN(WU32ReleaseDC,                  "ReleaseDC",              MOD_USER,    sizeof(RELEASEDC16))},
    {W32FUN(WU32SetCursor,                  "SetCursor",              MOD_USER,    sizeof(SETCURSOR16))},

  /*** 0070 ***/
    {W32FUN(WU32SetCursorPos,               "SETCURSORPOS",           MOD_USER,    sizeof(SETCURSORPOS16))},
    {W32FUN(WU32ShowCursor,                 "SHOWCURSOR",             MOD_USER,    sizeof(SHOWCURSOR16))},
    {W32FUN(LOCALAPI,                       "SETRECT",                MOD_USER,    sizeof(SETRECT16))},
    {W32FUN(LOCALAPI,                       "SETRECTEMPTY",           MOD_USER,    sizeof(SETRECTEMPTY16))},
    {W32FUN(LOCALAPI,                       "COPYRECT",               MOD_USER,    sizeof(COPYRECT16))},
    {W32FUN(LOCALAPI,                       "ISRECTEMPTY",            MOD_USER,    sizeof(ISRECTEMPTY16))},
    {W32FUN(LOCALAPI,                       "PTINRECT",               MOD_USER,    sizeof(PTINRECT16))},
    {W32FUN(LOCALAPI,                       "OFFSETRECT",             MOD_USER,    sizeof(OFFSETRECT16))},
    {W32FUN(LOCALAPI,                       "INFLATERECT",            MOD_USER,    sizeof(INFLATERECT16))},
    {W32FUN(LOCALAPI,                       "INTERSECTRECT",          MOD_USER,    sizeof(INTERSECTRECT16))},

  /*** 0080 ***/
    {W32FUN(LOCALAPI,                       "UNIONRECT",               MOD_USER,   sizeof(UNIONRECT16))},
    {W32FUN(WU32FillRect,                   "FILLRECT",                MOD_USER,   sizeof(FILLRECT16))},
    {W32FUN(WU32InvertRect,                 "INVERTRECT",              MOD_USER,   sizeof(INVERTRECT16))},
    {W32FUN(WU32FrameRect,                  "FRAMERECT",               MOD_USER,   sizeof(FRAMERECT16))},
    {W32FUN(IT(DrawIcon),                   "DrawIcon",                MOD_USER,   sizeof(DRAWICON16))},
    {W32FUN(WU32DrawText,                   "DrawText",                MOD_USER,   sizeof(DRAWTEXT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ICONSIZE",                MOD_USER,   0)},
    {W32FUN(LOCALAPI,                       "DIALOGBOX",               MOD_USER,   sizeof(DIALOGBOX16))},
    {W32FUN(WU32EndDialog,                  "ENDDIALOG",               MOD_USER,   sizeof(ENDDIALOG16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOG",            MOD_USER,   sizeof(CREATEDIALOG16))},

  /*** 0090 ***/
    {W32FUN(WU32IsDialogMessage,            "ISDIALOGMESSAGE",         MOD_USER,   sizeof(ISDIALOGMESSAGE16))},
    {W32FUN(WU32GETDLGITEM,                 "GETDLGITEM",              MOD_USER,   sizeof(GETDLGITEM16))},
    {W32FUN(WU32SetDlgItemText,             "SETDLGITEMTEXT",          MOD_USER,   sizeof(SETDLGITEMTEXT16))},
    {W32FUN(WU32GetDlgItemText,             "GETDLGITEMTEXT",          MOD_USER,   sizeof(GETDLGITEMTEXT16))},
    {W32FUN(WU32SetDlgItemInt,              "SETDLGITEMINT",           MOD_USER,   sizeof(SETDLGITEMINT16))},
    {W32FUN(WU32GetDlgItemInt,              "GETDLGITEMINT",           MOD_USER,   sizeof(GETDLGITEMINT16))},
    {W32FUN(WU32CheckRadioButton,           "CHECKRADIOBUTTON",        MOD_USER,   sizeof(CHECKRADIOBUTTON16))},
    {W32FUN(WU32CheckDlgButton,             "CHECKDLGBUTTON",          MOD_USER,   sizeof(CHECKDLGBUTTON16))},
    {W32FUN(WU32IsDlgButtonChecked,         "ISDLGBUTTONCHECKED",      MOD_USER,   sizeof(ISDLGBUTTONCHECKED16))},
    {W32FUN(WU32DlgDirSelect,               "DLGDIRSELECT",            MOD_USER,   sizeof(DLGDIRSELECT16))},

  /*** 0100 ***/
    {W32FUN(WU32DlgDirList,                 "DLGDIRLIST",               MOD_USER,  sizeof(DLGDIRLIST16))},
    {W32FUN(WU32SendDlgItemMessage,         "SENDDLGITEMMESSAGE",       MOD_USER,  sizeof(SENDDLGITEMMESSAGE16))},
    {W32FUN(WU32AdjustWindowRect,           "ADJUSTWINDOWRECT",         MOD_USER,  sizeof(ADJUSTWINDOWRECT16))},
    {W32FUN(WU32MapDialogRect,              "MAPDIALOGRECT",            MOD_USER,  sizeof(MAPDIALOGRECT16))},
    {W32FUN(IT(MessageBeep),                "MessageBeep",              MOD_USER,  sizeof(MESSAGEBEEP16))},
    {W32FUN(IT(FlashWindow),                "FlashWindow",              MOD_USER,  sizeof(FLASHWINDOW16))},
    {W32FUN(WU32GetKeyState,                "GETKEYSTATE",              MOD_USER,  sizeof(GETKEYSTATE16))},
    {W32FUN(WU32DefWindowProc,              "DEFWINDOWPROC",            MOD_USER,  sizeof(DEFWINDOWPROC16))},
    {W32FUN(WU32GetMessage,                 "GETMESSAGE",               MOD_USER,  sizeof(GETMESSAGE16))},
    {W32FUN(WU32PeekMessage,                "PEEKMESSAGE",              MOD_USER,  sizeof(PEEKMESSAGE16))},

  /*** 0110 ***/
    {W32FUN(WU32PostMessage,                "POSTMESSAGE",              MOD_USER,  sizeof(POSTMESSAGE16))},
    {W32FUN(WU32SendMessage,                "SENDMESSAGE",              MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(WU32WaitMessage,                "WAITMESSAGE",              MOD_USER,  0)},
    {W32FUN(WU32TranslateMessage,           "TRANSLATEMESSAGE",         MOD_USER,  sizeof(TRANSLATEMESSAGE16))},
    {W32FUN(WU32DispatchMessage,            "DISPATCHMESSAGE",          MOD_USER,  sizeof(DISPATCHMESSAGE16))},
    {W32FUN(WU32ReplyMessage,               "REPLYMESSAGE",             MOD_USER,  sizeof(REPLYMESSAGE16))},
    {W32FUN(WU32PostAppMessage,             "POSTAPPMESSAGE",           MOD_USER,  sizeof(POSTAPPMESSAGE16))},
    {W32FUN(IT(WindowFromDC),               "WindowFromDC",             MOD_USER,  sizeof(WINDOWFROMDC16))},
    {W32FUN(WU32RegisterWindowMessage,      "RegisterWindowMessage",    MOD_USER,  sizeof(REGISTERWINDOWMESSAGE16))},
    {W32FUN(WU32GetMessagePos,              "GETMESSAGEPOS",            MOD_USER,  0)},

  /*** 0120 ***/
    {W32FUN(WU32GetMessageTime,             "GETMESSAGETIME",           MOD_USER,  0)},
    {W32FUN(WU32SetWindowsHookInternal,     "SETWINDOWSHOOKINTERNAL",   MOD_USER,  sizeof(SETWINDOWSHOOKINTERNAL16))},
    {W32FUN(WU32CallWindowProc,             "CALLWINDOWPROC",           MOD_USER,  sizeof(CALLWINDOWPROC16))},
    {W32FUN(WU32CallMsgFilter,              "CALLMSGFILTER",            MOD_USER,  sizeof(CALLMSGFILTER16))},
    {W32FUN(WU32UpdateWindow,               "UPDATEWINDOW",             MOD_USER,  sizeof(UPDATEWINDOW16))},
    {W32FUN(WU32InvalidateRect,             "INVALIDATERECT",           MOD_USER,  sizeof(INVALIDATERECT16))},
    {W32FUN(WU32InvalidateRgn,              "INVALIDATERGN",            MOD_USER,  sizeof(INVALIDATERGN16))},
    {W32FUN(WU32ValidateRect,               "VALIDATERECT",             MOD_USER,  sizeof(VALIDATERECT16))},
    {W32FUN(WU32ValidateRgn,                "VALIDATERGN",              MOD_USER,  sizeof(VALIDATERGN16))},
    {W32FUN(WU32GetClassWord,               "GETCLASSWORD",             MOD_USER,  sizeof(GETCLASSWORD16))},

  /*** 0130 ***/
    {W32FUN(WU32SetClassWord,               "SETCLASSWORD",             MOD_USER,  sizeof(SETCLASSWORD16))},
    {W32FUN(WU32GetClassLong,               "GETCLASSLONG",             MOD_USER,  sizeof(GETCLASSLONG16))},
    {W32FUN(WU32SetClassLong,               "SETCLASSLONG",             MOD_USER,  sizeof(SETCLASSLONG16))},
    {W32FUN(WU32GetWindowWord,              "GETWINDOWWORD",            MOD_USER,  sizeof(GETWINDOWWORD16))},
    {W32FUN(WU32SetWindowWord,              "SETWINDOWWORD",            MOD_USER,  sizeof(SETWINDOWWORD16))},
    {W32FUN(WU32GetWindowLong,              "GETWINDOWLONG",            MOD_USER,  sizeof(GETWINDOWLONG16))},
    {W32FUN(WU32SetWindowLong,              "SETWINDOWLONG",            MOD_USER,  sizeof(SETWINDOWLONG16))},
    {W32FUN(WU32OpenClipboard,              "OPENCLIPBOARD",            MOD_USER,  sizeof(OPENCLIPBOARD16))},
    {W32FUN(WU32CloseClipboard,             "CLOSECLIPBOARD",           MOD_USER,  0)},
    {W32FUN(WU32EmptyClipboard,             "EMPTYCLIPBOARD",           MOD_USER,  0)},

  /*** 0140 ***/
    {W32FUN(WU32GetClipboardOwner,          "GETCLIPBOARDOWNER",        MOD_USER,  0)},
    {W32FUN(WU32SetClipboardData,           "SETCLIPBOARDDATA",         MOD_USER,  sizeof(SETCLIPBOARDDATA16))},
    {W32FUN(WU32GetClipboardData,           "GETCLIPBOARDDATA",         MOD_USER,  sizeof(GETCLIPBOARDDATA16))},
    {W32FUN(WU32CountClipboardFormats,      "COUNTCLIPBOARDFORMATS",    MOD_USER,  0)},
    {W32FUN(WU32EnumClipboardFormats,       "ENUMCLIPBOARDFORMATS",     MOD_USER,  sizeof(ENUMCLIPBOARDFORMATS16))},
    {W32FUN(WU32RegisterClipboardFormat,    "REGISTERCLIPBOARDFORMAT",  MOD_USER,  sizeof(REGISTERCLIPBOARDFORMAT16))},
    {W32FUN(WU32GetClipboardFormatName,     "GETCLIPBOARDFORMATNAME",   MOD_USER,  sizeof(GETCLIPBOARDFORMATNAME16))},
    {W32FUN(WU32SetClipboardViewer,         "SETCLIPBOARDVIEWER",       MOD_USER,  sizeof(SETCLIPBOARDVIEWER16))},
    {W32FUN(WU32GetClipboardViewer,         "GETCLIPBOARDVIEWER",       MOD_USER,  0)},
    {W32FUN(WU32ChangeClipboardChain,       "CHANGECLIPBOARDCHAIN",     MOD_USER,  sizeof(CHANGECLIPBOARDCHAIN16))},

  /*** 0150 ***/
    {W32FUN(WU32LoadMenu,                   "LOADMENU",                 MOD_USER,  sizeof(LOADMENU16))},
    {W32FUN(WU32CreateMenu,                 "CREATEMENU",               MOD_USER,  0)},
    {W32FUN(WU32DestroyMenu,                "DESTROYMENU",              MOD_USER,  sizeof(DESTROYMENU16))},
    {W32FUN(WU32ChangeMenu,                 "CHANGEMENU",               MOD_USER,  sizeof(CHANGEMENU16))},
    {W32FUN(WU32CheckMenuItem,              "CHECKMENUITEM",            MOD_USER,  sizeof(CHECKMENUITEM16))},
    {W32FUN(IT(EnableMenuItem),             "EnableMenuItem",           MOD_USER,  sizeof(ENABLEMENUITEM16))},
    {W32FUN(WU32GetSystemMenu,              "GETSYSTEMMENU",            MOD_USER,  sizeof(GETSYSTEMMENU16))},
    {W32FUN(WU32GETMENU,                    "GETMENU",                  MOD_USER,  sizeof(GETMENU16))},
    {W32FUN(WU32SetMenu,                    "SETMENU",                  MOD_USER,  sizeof(SETMENU16))},
    {W32FUN(WU32GETSUBMENU,                 "GetSubMenu",               MOD_USER,  sizeof(GETSUBMENU16))},

  /*** 0160 ***/
    {W32FUN(WU32DrawMenuBar,                "DRAWMENUBAR",              MOD_USER,  sizeof(DRAWMENUBAR16))},
    {W32FUN(WU32GetMenuString,              "GETMENUSTRING",            MOD_USER,  sizeof(GETMENUSTRING16))},
    {W32FUN(WU32HiliteMenuItem,             "HILITEMENUITEM",           MOD_USER,  sizeof(HILITEMENUITEM16))},
    {W32FUN(WU32CreateCaret,                "CREATECARET",              MOD_USER,  sizeof(CREATECARET16))},
    {W32FUN(WU32DestroyCaret,               "DESTROYCARET",             MOD_USER,  0)},
    {W32FUN(WU32SetCaretPos,                "SETCARETPOS",              MOD_USER,  sizeof(SETCARETPOS16))},
    {W32FUN(WU32HideCaret,                  "HIDECARET",                MOD_USER,  sizeof(HIDECARET16))},
    {W32FUN(WU32ShowCaret,                  "SHOWCARET",                MOD_USER,  sizeof(SHOWCARET16))},
    {W32FUN(WU32SetCaretBlinkTime,          "SETCARETBLINKTIME",        MOD_USER,  sizeof(SETCARETBLINKTIME16))},
    {W32FUN(WU32GetCaretBlinkTime,          "GETCARETBLINKTIME",        MOD_USER,  0)},

  /*** 0170 ***/
    {W32FUN(IT(ArrangeIconicWindows),       "ArrangeIconicWindows",     MOD_USER,  sizeof(ARRANGEICONICWINDOWS16))},
    {W32FUN(LOCALAPI,                       "WINHELP",                  MOD_USER,  sizeof(WINHELP16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SWITCHTOTHISWINDOW",       MOD_USER,  0)},
    {W32FUN(WU32LoadCursor,                 "LOADCURSOR",               MOD_USER,  sizeof(LOADCURSOR16))},
    {W32FUN(WU32LoadCursor,                 "LOADICON",                 MOD_USER,  sizeof(LOADICON16))},
    {W32FUN(WU32LoadBitmap,                 "LOADBITMAP",               MOD_USER,  sizeof(LOADBITMAP16))},
    {W32FUN(LOCALAPI,                       "LOADSTRING",               MOD_USER,  sizeof(LOADSTRING16))},
    {W32FUN(LOCALAPI,                       "LOADACCELERATORS",         MOD_USER,  sizeof(LOADACCELERATORS16))},
    {W32FUN(WU32TranslateAccelerator,       "TRANSLATEACCELERATOR",     MOD_USER,  sizeof(TRANSLATEACCELERATOR16))},
    {W32FUN(WU32GETSYSTEMMETRICS,           "GETSYSTEMMETRICS",         MOD_USER,  sizeof(GETSYSTEMMETRICS16))},

  /*** 0180 ***/
    {W32FUN(WU32GETSYSCOLOR,                "GETSYSCOLOR",              MOD_USER,  sizeof(GETSYSCOLOR16))},
    {W32FUN(WU32SetSysColors,               "SETSYSCOLORS",             MOD_USER,  sizeof(SETSYSCOLORS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "KILLSYSTEMTIMER",          MOD_USER,  0)},
    {W32FUN(WU32GetCaretPos,                "GETCARETPOS",              MOD_USER,  sizeof(GETCARETPOS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "QUERYSENDMESSAGE",         MOD_USER,  sizeof(QUERYSENDMESSAGE16))},
    {W32FUN(WU32GrayString,                 "GRAYSTRING",               MOD_USER,  sizeof(GRAYSTRING16))},
    {W32FUN(IT(SwapMouseButton),            "SwapMouseButton",          MOD_USER,  sizeof(SWAPMOUSEBUTTON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENDMENU",                  MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "SETSYSMODALWINDOW",        MOD_USER,  sizeof(SETSYSMODALWINDOW16))},
    {W32FUN(LOCALAPI,                       "GETSYSMODALWINDOW",        MOD_USER,  0)},

  /*** 0190 ***/
    {W32FUN(WU32GetUpdateRect,              "GETUPDATERECT",            MOD_USER, sizeof(GETUPDATERECT16))},
    {W32FUN(WU32ChildWindowFromPoint,       "ChildWindowFromPoint",     MOD_USER, sizeof(CHILDWINDOWFROMPOINT16))},
    {W32FUN(WU32InSendMessage,              "INSENDMESSAGE",            MOD_USER, 0)},
    {W32FUN(WU32IsClipboardFormatAvailable, "ISCLIPBOARDFORMATAVAILABLE",MOD_USER, sizeof(ISCLIPBOARDFORMATAVAILABLE16))},
    {W32FUN(WU32DlgDirSelectComboBox,       "DLGDIRSELECTCOMBOBOX",     MOD_USER, sizeof(DLGDIRSELECTCOMBOBOX16))},
    {W32FUN(WU32DlgDirListComboBox,         "DLGDIRLISTCOMBOBOX",       MOD_USER, sizeof(DLGDIRLISTCOMBOBOX16))},
    {W32FUN(WU32TabbedTextOut,              "TABBEDTEXTOUT",            MOD_USER, sizeof(TABBEDTEXTOUT16))},
    {W32FUN(WU32GetTabbedTextExtent,        "GETTABBEDTEXTEXTENT",      MOD_USER, sizeof(GETTABBEDTEXTEXTENT16))},
    {W32FUN(LOCALAPI,                       "CascadeChildWindows",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "TileChildWindows",         MOD_USER, 0)},

  /*** 0200 ***/
    {W32FUN(WU32OpenComm,                   "OPENCOMM",                 MOD_USER,  sizeof(OPENCOMM16))},
    {W32FUN(WU32SetCommState,               "SETCOMMSTATE",             MOD_USER,  sizeof(SETCOMMSTATE16))},
    {W32FUN(WU32GetCommState,               "GETCOMMSTATE",             MOD_USER,  sizeof(GETCOMMSTATE16))},
    {W32FUN(WU32GetCommError,               "GETCOMMERROR",             MOD_USER,  sizeof(GETCOMMERROR16))},
    {W32FUN(WU32ReadComm,                   "READCOMM",                 MOD_USER,  sizeof(READCOMM16))},
    {W32FUN(WU32WriteComm,                  "WRITECOMM",                MOD_USER,  sizeof(WRITECOMM16))},
    {W32FUN(WU32TransmitCommChar,           "TRANSMITCOMMCHAR",         MOD_USER,  sizeof(TRANSMITCOMMCHAR16))},
    {W32FUN(WU32CloseComm,                  "CLOSECOMM",                MOD_USER,  sizeof(CLOSECOMM16))},
    {W32FUN(WU32SetCommEventMask,           "SETCOMMEVENTMASK",         MOD_USER,  sizeof(SETCOMMEVENTMASK16))},
    {W32FUN(WU32GetCommEventMask,           "GETCOMMEVENTMASK",         MOD_USER,  sizeof(GETCOMMEVENTMASK16))},

  /*** 0210 ***/
    {W32FUN(WU32SetCommBreak,               "SETCOMMBREAK",             MOD_USER,  sizeof(SETCOMMBREAK16))},
    {W32FUN(WU32ClearCommBreak,             "CLEARCOMMBREAK",           MOD_USER,  sizeof(CLEARCOMMBREAK16))},
    {W32FUN(WU32UngetCommChar,              "UNGETCOMMCHAR",            MOD_USER,  sizeof(UNGETCOMMCHAR16))},
    {W32FUN(WU32BuildCommDCB,               "BUILDCOMMDCB",             MOD_USER,  sizeof(BUILDCOMMDCB16))},
    {W32FUN(WU32EscapeCommFunction,         "ESCAPECOMMFUNCTION",       MOD_USER,  sizeof(ESCAPECOMMFUNCTION16))},
    {W32FUN(WU32FlushComm,                  "FLUSHCOMM",                MOD_USER,  sizeof(FLUSHCOMM16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "USERSEEUSERDO",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOOKUPMENUHANDLE",         MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "DIALOGBOXINDIRECT",        MOD_USER,  sizeof(DIALOGBOXINDIRECT16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGINDIRECT",     MOD_USER,  sizeof(CREATEDIALOGINDIRECT16))},

  /*** 0220 ***/
    {W32FUN(WU32LoadMenuIndirect,           "LOADMENUINDIRECT",         MOD_USER,  sizeof(LOADMENUINDIRECT16))},
    {W32FUN(WU32ScrollDC,                   "SCROLLDC",                 MOD_USER,  sizeof(SCROLLDC16))},
    {W32FUN(WU32GetKeyboardState,           "GETKEYBOARDSTATE",         MOD_USER,  sizeof(GETKEYBOARDSTATE16))},
    {W32FUN(WU32SetKeyboardState,           "SETKEYBOARDSTATE",         MOD_USER,  sizeof(SETKEYBOARDSTATE16))},
    {W32FUN(WU32GetWindowTask,              "GETWINDOWTASK",            MOD_USER,  sizeof(GETWINDOWTASK16))},
    {W32FUN(WU32EnumTaskWindows,            "ENUMTASKWINDOWS",          MOD_USER,  sizeof(ENUMTASKWINDOWS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOCKINPUT",                MOD_USER,  sizeof(LOCKINPUT16))},
    {W32FUN(WU32GetNextDlgGroupItem,        "GETNEXTDLGGROUPITEM",      MOD_USER,  sizeof(GETNEXTDLGGROUPITEM16))},
    {W32FUN(WU32GetNextDlgTabItem,          "GETNEXTDLGTABITEM",        MOD_USER,  sizeof(GETNEXTDLGTABITEM16))},
    {W32FUN(WU32GETTOPWINDOW,               "GETTOPWINDOW",             MOD_USER,  sizeof(GETTOPWINDOW16))},

  /*** 0230 ***/
    {W32FUN(WU32GETNEXTWINDOW,              "GetNextWindow",            MOD_USER,  sizeof(GETNEXTWINDOW16))},
    {W32FUN(LOCALAPI,                       "GETSYSTEMDEBUGSTATE",      MOD_USER,  0)},
    {W32FUN(WU32SetWindowPos,               "SetWindowPos",             MOD_USER,  sizeof(SETWINDOWPOS16))},
    {W32FUN(IT(SetParent),                  "SetParent",                MOD_USER,  sizeof(SETPARENT16))},
    {W32FUN(WU32UnhookWindowsHook,          "UnhookWindowsHook",        MOD_USER,  sizeof(UNHOOKWINDOWSHOOK16))},
    {W32FUN(WU32DefHookProc,                "DefHookProc",              MOD_USER,  sizeof(DEFHOOKPROC16))},
    {W32FUN(IT(GetCapture),                 "GetCapture",               MOD_USER,  0)},
    {W32FUN(IT(GetUpdateRgn),               "GetUpdateRgn",             MOD_USER,  sizeof(GETUPDATERGN16))},
    {W32FUN(IT(ExcludeUpdateRgn),           "ExcludeUpdateRgn",         MOD_USER,  sizeof(EXCLUDEUPDATERGN16))},
    {W32FUN(WU32DialogBoxParam,             "DialogBoxParam",           MOD_USER,  sizeof(DIALOGBOXPARAM16))},

  /*** 0240 ***/
    {W32FUN(LOCALAPI,                       "DIALOGBOXINDIRECTPARAM",   MOD_USER,  sizeof(DIALOGBOXINDIRECTPARAM16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGPARAM",        MOD_USER,  sizeof(CREATEDIALOGPARAM16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGINDIRECTPARAM",MOD_USER,  sizeof(CREATEDIALOGINDIRECTPARAM16))},
    {W32FUN(WU32GetDialogBaseUnits,         "GETDIALOGBASEUNITS",       MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "EQUALRECT",                MOD_USER,  sizeof(EQUALRECT16))},
    {W32FUN(WU32EnableCommNotification,     "ENABLECOMMNOTIFICATION",   MOD_USER,  sizeof(ENABLECOMMNOTIFICATION16))},
    {W32FUN(WU32ExitWindowsExec,            "EXITWINDOWSEXEC",          MOD_USER,  0)},
    {W32FUN(IT(GetCursor),                  "GetCursor",                MOD_USER,  0)},
    {W32FUN(IT(GetOpenClipboardWindow),     "GetOpenClipboardWindow",   MOD_USER,  0)},
    {W32FUN(IT(GetAsyncKeyState),           "GetAsyncKeyState",         MOD_USER,  sizeof(GETASYNCKEYSTATE16))},

  /*** 0250 ***/
    {W32FUN(WU32GETMENUSTATE,               "GetMenuState",             MOD_USER,  sizeof(GETMENUSTATE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SENDDRIVERMESSAGE",        MOD_USER,  sizeof(SENDDRIVERMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "OPENDRIVER",               MOD_USER,  sizeof(OPENDRIVER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CLOSEDRIVER",              MOD_USER,  sizeof(CLOSEDRIVER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETDRIVERMODULEHANDLE",    MOD_USER,  sizeof(GETDRIVERMODULEHANDLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "DEFDRIVERPROC",            MOD_USER,  sizeof(DEFDRIVERPROC16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETDRIVERINFO",            MOD_USER,  sizeof(GETDRIVERINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETNEXTDRIVER",            MOD_USER,  sizeof(GETNEXTDRIVER16))},
    {W32FUN(WU32MapWindowPoints,            "MAPWINDOWPOINTS",          MOD_USER,  sizeof(MAPWINDOWPOINTS16))},
    {W32FUN(IT(BeginDeferWindowPos),        "BeginDeferWindowPos",      MOD_USER,  sizeof(BEGINDEFERWINDOWPOS16))},

  /*** 0260 ***/
    {W32FUN(WU32DeferWindowPos,             "DEFERWINDOWPOS",           MOD_USER,  sizeof(DEFERWINDOWPOS16))},
    {W32FUN(WU32EndDeferWindowPos,          "ENDDEFERWINDOWPOS",        MOD_USER,  sizeof(ENDDEFERWINDOWPOS16))},
    {W32FUN(WU32GETWINDOW,                  "GetWindow",                MOD_USER,  sizeof(GETWINDOW16))},
    {W32FUN(WU32GETMENUITEMCOUNT,           "GETMENUITEMCOUNT",         MOD_USER,  sizeof(GETMENUITEMCOUNT16))},
    {W32FUN(WU32GETMENUITEMID,              "GetMenuItemID",            MOD_USER,  sizeof(GETMENUITEMID16))},
    {W32FUN(IT(ShowOwnedPopups),            "ShowOwnedPopups",          MOD_USER,  sizeof(SHOWOWNEDPOPUPS16))},
    {W32FUN(LOCALAPI,                       "SetMessageQueue",          MOD_USER,  sizeof(SETMESSAGEQUEUE16))},
    {W32FUN(IT(ShowScrollBar),              "ShowScrollBar",            MOD_USER,  sizeof(SHOWSCROLLBAR16))},
    {W32FUN(WU32GlobalAddAtom,              "GLOBALADDATOM",            MOD_USER,  sizeof(GLOBALADDATOM16))},
    {W32FUN(WU32GlobalDeleteAtom,           "GLOBALDELETEATOM",         MOD_USER,  sizeof(GLOBALDELETEATOM16))},

  /*** 0270 ***/
    {W32FUN(IT(GlobalFindAtom),             "GlobalFindAtom",           MOD_USER,  sizeof(GLOBALFINDATOM16))},
    {W32FUN(WU32GlobalGetAtomName,          "GLOBALGETATOMNAME",        MOD_USER,  sizeof(GLOBALGETATOMNAME16))},
    {W32FUN(WU32ISZOOMED,                   "ISZOOMED",                 MOD_USER,  sizeof(ISZOOMED16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CONTROLPANELINFO",         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETNEXTQUEUEWINDOW",       MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "REPAINTSCREEN",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOCKMYTASK",               MOD_USER,  0)},
    {W32FUN(WU32GetDlgCtrlID,               "GETDLGCTRLID",             MOD_USER,  sizeof(GETDLGCTRLID16))},
    {W32FUN(WU32GETDESKTOPWINDOW,           "GETDESKTOPHWND",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDESKPATTERN",           MOD_USER,  0)},

  /*** 0280 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETSYSTEMMENU",            MOD_USER,  0)},
    {W32FUN(IT(GetSysColorBrush),           "GetSysColorBrush",         MOD_USER,  sizeof(GETSYSCOLORBRUSH16))},
    {W32FUN(IT(SelectPalette),              "SelectPalette",            MOD_USER,  sizeof(SELECTPALETTE16))},
    {W32FUN(IT(RealizePalette),             "RealizePalette",           MOD_USER,  sizeof(REALIZEPALETTE16))},
    {W32FUN(WU32GetFreeSystemResources,     "GETFREESYSTEMRESOURCES",   MOD_USER,  sizeof(GETFREESYSTEMRESOURCES16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDESKWALLPAPER",         MOD_USER,  0)},
    {W32FUN(WU32GETDESKTOPWINDOW,           "GETDESKTOPWINDOW",         MOD_USER,  0)},
    {W32FUN(IT(GetLastActivePopup),         "GetLastActivePopup",       MOD_USER,  sizeof(GETLASTACTIVEPOPUP16))},
    {W32FUN(IT(GetMessageExtraInfo),        "GetMessageExtraInfo",      MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "KEYBD_EVENT",              MOD_USER,  0)},

  /*** 0290 ***/
    {W32FUN(WU32RedrawWindow,               "REDRAWWINDOW",             MOD_USER,  sizeof(REDRAWWINDOW16))},
    {W32FUN(WU32SetWindowsHookEx,           "SETWINDOWSHOOKEX",         MOD_USER,  sizeof(SETWINDOWSHOOKEX16))},
    {W32FUN(WU32UnhookWindowsHookEx,        "UNHOOKWINDOWSHOOKEX",      MOD_USER,  sizeof(UNHOOKWINDOWSHOOKEX16))},
    {W32FUN(WU32CallNextHookEx,             "CALLNEXTHOOKEX",           MOD_USER,  sizeof(CALLNEXTHOOKEX16))},
    {W32FUN(IT(LockWindowUpdate),           "LockWindowUpdate",         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "MOUSE_EVENT",              MOD_USER,  0)},

  /*** 0300 ***/
    {W32FUN(UNIMPLEMENTED95API,             "UnloadInstallableDrivers", MOD_USER,  sizeof(UNLOADINSTALLABLEDRIVERS16))},
    {W32FUN(LOCALAPI,                       "EDITWNDPROC",              MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "STATICWNDPROC",            MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "BUTTONWNDPROC",            MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "SBWNDPROC",                MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "DESKTOPWNDPROC",           MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "MENUWINDOWPROC",           MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "LBOXCTLWNDPROC",           MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(WU32DefDlgProc,                 "DEFDLGPROC",               MOD_USER,  sizeof(DEFDLGPROC16))},
    {W32FUN(WU32GetClipCursor,              "GETCLIPCURSOR",            MOD_USER,  sizeof(GETCLIPCURSOR16))},

  /*** 0310 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "CONTSCROLL",               MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CARETBLINKPROC",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SENDMESSAGE2",             MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "POSTMESSAGE2",             MOD_USER,  0)},
    {W32FUN(WU32SignalProc,                 "SIGNALPROC",               MOD_USER,  sizeof(SIGNALPROC16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "XCSTODS",                  MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COMPUPDATERECT",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COMPUPDATERGN",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETWC2",                   MOD_USER,  0)},
    {W32FUN(WU32ScrollWindowEx,             "SCROLLWINDOWEX",           MOD_USER,  sizeof(SCROLLWINDOWEX16))},

  /*** 0320 ***/
    {W32FUN(WU32SysErrorBox,                "SYSERRORBOX",              MOD_USER,  sizeof(SYSERRORBOX16))},
    {W32FUN(WU32SetEventHook,               "SETEVENTHOOK",             MOD_USER,  sizeof(SETEVENTHOOK16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "WINOLDAPPHACKOMATIC",      MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETMESSAGE2",              MOD_USER,  0)},
    {W32FUN(WU32FillWindow,                 "FillWindow",               MOD_USER,  sizeof(FILLWINDOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "PAINTRECT",                MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETCONTROLBRUSH",          MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "KILLTIMER2",               MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETTIMER2",                MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "MENUITEMSTATE",            MOD_USER,  0)},

  /*** 0330 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETGETKBDSTATE",            MOD_USER, 0)},
    {W32FUN(NOPAPI,                         "EnableHardwareInput",       MOD_USER, sizeof(ENABLEHARDWAREINPUT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "USERYIELD",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISUSERIDLE",                MOD_USER, 0)},
    {W32FUN(IT(GetQueueStatus),             "GetQueueStatus",            MOD_USER, sizeof(GETQUEUESTATUS16))},
    {W32FUN(IT(GetInputState),              "GetInputState",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADCURSORICONHANDLER",     MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "GETMOUSEEVENTPROC",         MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0340 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "WINFARFRAME",               MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "_FFFE_FARFRAME",            MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETFILEPORTNAME",           MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "COMBOBOXCTLWNDPROC",        MOD_USER, sizeof(SENDMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "TITLEWNDPROC",              MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "FILEPORTDLGPROC",           MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SWITCHWNDPROC",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0350 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "TABTHETEXTOUTFORWIMPS",     MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "BROADCASTMESSAGE",          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADDIBCURSORHANDLER",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADDIBICONHANDLER",        MOD_USER, 0)},
    {W32FUN(IT(IsMenu),                     "IsMenu",                    MOD_USER, sizeof(ISMENU16))},
    {W32FUN(WU32GetDCEx,                    "GETDCEX",                   MOD_USER, sizeof(GETDCEX16))},

  /*** 0360 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(LookupIconIdFromDirectoryEx),"LookupIconIdFromDirectoryEx",MOD_USER,sizeof(LOOKUPICONIDFROMDIRECTORYEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COPYICON",                  MOD_USER,  sizeof(COPYICON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "COPYCURSOR",                MOD_USER,  sizeof(COPYCURSOR16))},

  /*** 0370 ***/
    {W32FUN(WU32GetWindowPlacement,         "GETWINDOWPLACEMENT",        MOD_USER, sizeof(GETWINDOWPLACEMENT16))},
    {W32FUN(WU32SetWindowPlacement,         "SETWINDOWPLACEMENT",        MOD_USER, sizeof(SETWINDOWPLACEMENT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "SUBTRACTRECT",              MOD_USER, sizeof(SUBTRACTRECT16))},
    {W32FUN(UNIMPLEMENTED95API,             "DllEntryPoint",             MOD_USER, sizeof(DLLENTRYPOINT16))},
    {W32FUN(WU32DrawTextEx,                 "DrawTextEx",                MOD_USER, sizeof(DRAWTEXTEX16))},
    {W32FUN(IT(SetMessageExtraInfo),        "SetMessageExtraInfo",       MOD_USER, sizeof(SETMESSAGEEXTRAINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetPropEx),                  "SetPropEx",                 MOD_USER, sizeof(SETPROPEX16))},
    {W32FUN(IT(GetPropEx),                  "GetPropEx",                 MOD_USER, sizeof(GETPROPEX16))},

  /*** 0380 ***/
    {W32FUN(IT(RemovePropEx),               "RemovePropEx",              MOD_USER, sizeof(REMOVEPROPEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetWindowContextHelpId),     "SetWindowContextHelpId",    MOD_USER, sizeof(SETWINDOWCONTEXTHELPID16))},
    {W32FUN(IT(GetWindowContextHelpId),     "GetWindowContextHelpId",    MOD_USER, sizeof(GETWINDOWCONTEXTHELPID16))},
    {W32FUN(IT(SetMenuContextHelpId),       "SetMenuContextHelpId",      MOD_USER, sizeof(SETMENUCONTEXTHELPID16))},
    {W32FUN(IT(GetMenuContextHelpId),       "GetMenuContextHelpId",      MOD_USER, sizeof(GETMENUCONTEXTHELPID16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(LoadImage),                  "LoadImage",                 MOD_USER, sizeof(LOADIMAGE16))},

  /*** 0390 ***/
    {W32FUN(WU32CopyImage,                  "CopyImage",                 MOD_USER, sizeof(COPYIMAGE16))},
    {W32FUN(UNIMPLEMENTED95API,             "SignalProc32",              MOD_USER, sizeof(SIGNALPROC3216))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(DrawIconEx),                 "DrawIconEx",                MOD_USER, sizeof(DRAWICONEX16))},
    {W32FUN(WU32GetIconInfo,                "GetIconInfo",               MOD_USER, sizeof(GETICONINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "RegisterClassEx",           MOD_USER, sizeof(REGISTERCLASSEX16))},
    {W32FUN(UNIMPLEMENTED95API,             "GetClassInfoEx",            MOD_USER, sizeof(GETCLASSINFOEX16))},
    {W32FUN(WU32ChildWindowFromPointEx,     "ChildWindowFromPointEx",    MOD_USER, sizeof(CHILDWINDOWFROMPOINTEX16))},

  /*** 0400 ***/
    {W32FUN(NOPAPI,                         "FinalUserInit",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetPriorityClipboardFormat, "GETPRIORITYCLIPBOARDFORMAT",MOD_USER, sizeof(GETPRIORITYCLIPBOARDFORMAT16))},
    {W32FUN(IT(UnregisterClass),            "UnregisterClass",           MOD_USER, sizeof(UNREGISTERCLASS16))},
    {W32FUN(WU32GetClassInfo,               "GETCLASSINFO",              MOD_USER, sizeof(GETCLASSINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32CreateCursor,               "CREATECURSOR",              MOD_USER, sizeof(CREATECURSOR16))},
    {W32FUN(WU32CreateIcon,                 "CREATEICON",                MOD_USER, sizeof(CREATEICON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATECURSORICONINDIRECT",  MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "InitThreadInput",           MOD_USER, sizeof(INITTHREADINPUT16))},

  /*** 0410 ***/
    {W32FUN(WU32InsertMenu,                 "INSERTMENU",                MOD_USER, sizeof(INSERTMENU16))},
    {W32FUN(WU32AppendMenu,                 "APPENDMENU",                MOD_USER, sizeof(APPENDMENU16))},
    {W32FUN(WU32RemoveMenu,                 "REMOVEMENU",                MOD_USER, sizeof(REMOVEMENU16))},
    {W32FUN(WU32DeleteMenu,                 "DELETEMENU",                MOD_USER, sizeof(DELETEMENU16))},
    {W32FUN(WU32ModifyMenu,                 "MODIFYMENU",                MOD_USER, sizeof(MODIFYMENU16))},
    {W32FUN(WU32CreatePopupMenu,            "CREATEPOPUPMENU",           MOD_USER, 0)},
    {W32FUN(WU32TrackPopupMenu,             "TRACKPOPUPMENU",            MOD_USER, sizeof(TRACKPOPUPMENU16))},
    {W32FUN(WU32GetMenuCheckMarkDimensions, "GETMENUCHECKMARKDIMENSIONS",MOD_USER, 0)},
    {W32FUN(WU32SetMenuItemBitmaps,         "SETMENUITEMBITMAPS",        MOD_USER, sizeof(SETMENUITEMBITMAPS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0420 ***/
    {W32FUN(LOCALAPI,                       "_WSPRINTF",                 MOD_USER, sizeof(WSPRINTF16))},
    {W32FUN(LOCALAPI,                       "WVSPRINTF",                 MOD_USER, sizeof(WVSPRINTF16))},
    {W32FUN(WU32DlgDirSelectEx,             "DLGDIRSELECTEX",            MOD_USER, sizeof(DLGDIRSELECTEX16))},
    {W32FUN(WU32DlgDirSelectComboBoxEx,     "DLGDIRSELECTCOMBOBOXEX",    MOD_USER, sizeof(DLGDIRSELECTCOMBOBOXEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(FindWindowEx),               "FindWindowEx",              MOD_USER, sizeof(FINDWINDOWEX16))},
    {W32FUN(WU32TileWindows,                "TileWindows",               MOD_USER, sizeof(TILEWINDOWS16))},
    {W32FUN(WU32CascadeWindows,             "CascadeWindows",            MOD_USER, sizeof(CASCADEWINDOWS16))},

  /*** 0430 ***/
    {W32FUN(WU32lstrcmp,                    "LSTRCMP",                   MOD_USER, 0)},
    {W32FUN(WU32AnsiUpper,                  "ANSIUPPER",                 MOD_USER, sizeof(ANSIUPPER16))},
    {W32FUN(WU32AnsiLower,                  "ANSILOWER",                 MOD_USER, sizeof(ANSILOWER16))},
    {W32FUN(WU32IsCharAlpha,                "ISCHARALPHA",               MOD_USER, sizeof(ISCHARALPHA16))},
    {W32FUN(WU32IsCharAlphaNumeric,         "ISCHARALPHANUMERIC",        MOD_USER, sizeof(ISCHARALPHANUMERIC16))},
    {W32FUN(WU32IsCharUpper,                "ISCHARUPPER",               MOD_USER, sizeof(ISCHARUPPER16))},
    {W32FUN(WU32IsCharLower,                "ISCHARLOWER",               MOD_USER, sizeof(ISCHARLOWER16))},
    {W32FUN(WU32AnsiUpperBuff,              "ANSIUPPERBUFF",             MOD_USER, sizeof(ANSIUPPERBUFF16))},
    {W32FUN(WU32AnsiLowerBuff,              "ANSILOWERBUFF",             MOD_USER, sizeof(ANSILOWERBUFF16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0440 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32InsertMenuItem,             "InsertMenuItem",            MOD_USER, sizeof(INSERTMENUITEM16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetMenuItemInfo,            "GetMenuItemInfo",           MOD_USER, sizeof(GETMENUITEMINFO16))},
    {W32FUN(LOCALAPI,                       "MDIClientWndProc",          MOD_USER, sizeof(SENDMESSAGE16))},
    {W32FUN(WU32DefFrameProc,               "DefFrameProc",              MOD_USER, sizeof(DEFFRAMEPROC16))},
    {W32FUN(WU32SetMenuItemInfo,            "SetMenuItemInfo",           MOD_USER, sizeof(SETMENUITEMINFO16))},
    {W32FUN(WU32DefMDIChildProc,            "DefMDIChildProc",           MOD_USER, sizeof(DEFMDICHILDPROC16))},
    {W32FUN(WU32DrawAnimatedRects,          "DrawAnimatedRects",         MOD_USER, sizeof(DRAWANIMATEDRECTS16))},
    {W32FUN(WU32DrawState,                  "DrawState",                 MOD_USER, sizeof(DRAWSTATE16))},

  /*** 0450 ***/
    {W32FUN(IT(CreateIconFromResourceEx),   "CreateIconFromResourceEx",  MOD_USER, sizeof(CREATEICONFROMRESOURCEEX16))},
    {W32FUN(WU32TranslateMDISysAccel,       "TRANSLATEMDISYSACCEL",      MOD_USER, sizeof(TRANSLATEMDISYSACCEL16))},
    {W32FUN(WU32CreateWindowEx,             "CREATEWINDOWEX",            MOD_USER, sizeof(CREATEWINDOWEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "LBOXCARETBLINKER",          MOD_USER, 0)},
    {W32FUN(WU32AdjustWindowRectEx,         "ADJUSTWINDOWRECTEX",        MOD_USER, sizeof(ADJUSTWINDOWRECTEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETICONID",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADICONHANDLER",           MOD_USER, 0)},
    {W32FUN(WU32DestroyIcon,                "DESTROYICON",               MOD_USER, sizeof(DESTROYICON16))},
    {W32FUN(WU32DestroyCursor,              "DESTROYCURSOR",             MOD_USER, sizeof(DESTROYCURSOR16))},
    {W32FUN(LOCALAPI,                       "DUMPICON",                  MOD_USER, 0)},

  /*** 0460 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "GETINTERNALWINDOWPOS",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETINTERNALWINDOWPOS",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CALCCHILDSCROLL",           MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SCROLLCHILDREN",            MOD_USER, 0)},
    {W32FUN(IT(DragObject),                 "DragObject",                MOD_USER, sizeof(DRAGOBJECT16))},
    {W32FUN(WU32DragDetect,                 "DragDetect",                MOD_USER, sizeof(DRAGDETECT16))},
    {W32FUN(WU32DrawFocusRect,              "DrawFocusRect",             MOD_USER, sizeof(DRAWFOCUSRECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0470 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "STRINGFUNC",                MOD_USER, 0)},
    {W32FUN(WU32lstrcmpi,                   "LSTRCMPI",                  MOD_USER, 0)},
    {W32FUN(WU32AnsiNext,                   "ANSINEXT",                  MOD_USER, sizeof(ANSINEXT16))},
    {W32FUN(WU32AnsiPrev,                   "ANSIPREV",                  MOD_USER, sizeof(ANSIPREV16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetScrollInfo),              "SetScrollInfo",             MOD_USER, sizeof(SETSCROLLINFO16))},
    {W32FUN(IT(GetScrollInfo),              "GetScrollInfo",             MOD_USER, sizeof(GETSCROLLINFO16))},
    {W32FUN(IT(GetKeyboardLayoutName),      "GetKeyboardLayoutName",     MOD_USER, sizeof(GETKEYBOARDLAYOUTNAME16))},
    {W32FUN(IT(LoadKeyboardLayout),         "LoadKeyboardLayout",        MOD_USER, sizeof(LOADKEYBOARDLAYOUT16))},
    {W32FUN(WU32MenuItemFromPoint,          "MenuItemFromPoint",         MOD_USER, sizeof(MENUITEMFROMPOINT16))},

  /*** 0480 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(EnableScrollBar),            "EnableSrollBar",            MOD_USER, sizeof(ENABLESCROLLBAR16))},
    {W32FUN(WU32SystemParametersInfo,       "SystemParametersInfo",      MOD_USER, sizeof(SYSTEMPARAMETERSINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0490 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetAppVer,                  "GetAppVer",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0500 ***/
    {W32FUN(LOCALAPI,                       "FARCALLNETDRIVER",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETOPENJOB",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCLOSEJOB",              MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETHOLDJOB",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETRELEASEJOB",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCANCELJOB",             MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETSETJOBCOPIES",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETWATCHQUEUE",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETUNWATCHQUEUE",          MOD_USER, 0)},

  /*** 0510 ***/
    {W32FUN(LOCALAPI,                       "WNETLOCKQUEUEDATA",         MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETUNLOCKQUEUEDATA",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETCONNECTION",         MOD_USER, sizeof(WNETGETCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETGETCAPS",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDEVICEMODE",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETBROWSEDIALOG",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETUSER",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETADDCONNECTION",         MOD_USER, sizeof(WNETADDCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETCANCELCONNECTION",      MOD_USER, sizeof(WNETCANCELCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETGETERROR",              MOD_USER, 0)},

  /*** 0520 ***/
    {W32FUN(LOCALAPI,                       "WNETGETERRORTEXT",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETENABLE",                MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDISABLE",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETRESTORECONNECTION",     MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETWRITEJOB",              MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCONNECTDIALOG",         MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDISCONNECTDIALOG",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCONNECTIONDIALOG",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETVIEWQUEUEDIALOG",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETPROPERTYDIALOG",        MOD_USER, 0)},

  /*** 0530 ***/
    {W32FUN(LOCALAPI,                       "WNETGETDIRECTORYTYPE",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDIRECTORYNOTIFY",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETPROPERTYTEXT",       MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "WNetInitialize",            MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "WNetLogon",                 MOD_USER, sizeof(WNETLOGON16))},
    {W32FUN(WU32NotifyWow,                  "NOTIFYWOW",                 MOD_USER, sizeof(NOTIFYWOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "--Available--",             MOD_USER, 0)},
    {W32FUN(WU32WOWWordBreakProc,           "WOWWordBreakProc",          MOD_USER, sizeof(WOWWORDBREAKPROC16))},
    {W32FUN(WU32MouseEvent,                 "MOUSEEVENT",                MOD_USER, sizeof(MOUSEEVENT16))},
    {W32FUN(WU32KeybdEvent,                 "KEYBDEVENT",                MOD_USER, sizeof(KEYBDEVENT16))},

  /*** 0540 ***/
    {W32FUN(IT(GetShellWindow),             "GetShellWindow",            MOD_USER, 0)},
    {W32FUN(NOPAPI,                         "DoHotKeyStuff",             MOD_USER, sizeof(DOHOTKEYSTUFF16))},
    {W32FUN(NOPAPI,                         "SetCheckCursorTimer",       MOD_USER, sizeof(SETCHECKCURSORTIMER16))},
    {W32FUN(IT(SetMenuDefaultItem),         "SetMenuDefaultItem",        MOD_USER, sizeof(SETMENUDEFAULTITEM16))},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},

  /*** 0550 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(IT(DestroyIcon32),              "DestroyIcon32",             MOD_USER, sizeof(DESTROYICON3216))},
    {W32FUN(UNIMPLEMENTED95API,             "BroadcastSystemMessage",    MOD_USER, sizeof(BROADCASTSYSTEMMESSAGE16))},
    {W32FUN(UNIMPLEMENTED95API,             "HackTaskMonitor",           MOD_USER, sizeof(HACKTASKMONITOR16))},
    {W32FUN(UNIMPLEMENTED95API,             "FormatMessage",             MOD_USER, sizeof(FORMATMESSAGE16))},
    {W32FUN(IT(ChangeDisplaySettings),      "ChangeDisplaySettings",     MOD_USER, sizeof(CHANGEDISPLAYSETTINGS16))},
    {W32FUN(IT(GetForegroundWindow),        "GetForegroundWindow",       MOD_USER, 0)},
    {W32FUN(IT(SetForegroundWindow),        "SetForegroundWindow",       MOD_USER, sizeof(SETFOREGROUNDWINDOW16))},

  /*** 0560 ***/
    {W32FUN(IT(EnumDisplaySettings),        "EnumDisplaySettings",       MOD_USER, sizeof(ENUMDISPLAYSETTINGS16))},
    {W32FUN(IT(MsgWaitForMultipleObjects),  "MsgWaitForMultipleObjects", MOD_USER, sizeof(MSGWAITFORMULTIPLEOBJECTS16))},
    {W32FUN(IT(ActivateKeyboardLayout),     "ActivateKeyboardLayout",    MOD_USER, sizeof(ACTIVATEKEYBOARDLAYOUT16))},
    {W32FUN(IT(GetKeyboardLayout),          "GetKeyboardLayout",         MOD_USER, sizeof(GETKEYBOARDLAYOUT16))},
    {W32FUN(IT(GetKeyboardLayoutList),      "GetKeyboardLayoutList",     MOD_USER, sizeof(GETKEYBOARDLAYOUTLIST16))},
    {W32FUN(IT(UnloadKeyboardLayout),       "UnloadKeyboardLayout",      MOD_USER, sizeof(UNLOADKEYBOARDLAYOUT16))},
    {W32FUN(UNIMPLEMENTED95API,             "PostPostedMessages",        MOD_USER, 0)},
    {W32FUN(WU32DrawFrameControl,           "DrawFrameControl",          MOD_USER, sizeof(DRAWFRAMECONTROL16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrawCaptionTemp",           MOD_USER, sizeof(DRAWCAPTIONTEMP16))},
    {W32FUN(NOPAPI,                         "DispatchInput",             MOD_USER, 0)},

  /*** 0570 ***/
    {W32FUN(WU32DrawEdge,                   "DrawEdge",                  MOD_USER, sizeof(DRAWEDGE16))},
    {W32FUN(WU32DrawCaption,                "DrawCaption",               MOD_USER, sizeof(DRAWCAPTION16))},
    {W32FUN(UNIMPLEMENTED95API,             "SetSysColorsTemp",          MOD_USER, sizeof(SETSYSCOLORSTEMP16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrawMenuBarTemp",           MOD_USER, sizeof(DRAWMENUBARTEMP16))},
    {W32FUN(IT(GetMenuDefaultItem),         "GetMenuDefaultItem",        MOD_USER, sizeof(GETMENUDEFAULTITEM16))},
    {W32FUN(WU32GetMenuItemRect,            "GetMenuItemRect",           MOD_USER, sizeof(GETMENUITEMRECT16))},
    {W32FUN(IT(CheckMenuRadioItem),         "CheckMenuRadioItem",        MOD_USER, sizeof(CHECKMENURADIOITEM16))},
    {W32FUN(WU32TrackPopupMenuEx,           "TrackPopupMenuEx",          MOD_USER, sizeof(TRACKPOPUPMENUEX16))},
    {W32FUN(IT(SetWindowRgn),               "SetWindowRgn",              MOD_USER, sizeof(SETWINDOWRGN16))},
    {W32FUN(IT(GetWindowRgn),               "GetWindowRgn",              MOD_USER, sizeof(GETWINDOWRGN16))},

  /*** 0580 ***/
    {W32FUN(UNIMPLEMENTED95API,             "ChooseFont_Callback16",     MOD_USER, sizeof(CHOOSEFONT_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "FindReplace_Callback16",    MOD_USER, sizeof(FINDREPLACE_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "OpenFilename_Callback16",   MOD_USER, sizeof(OPENFILENAME_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "PrintDlg_Callback16",       MOD_USER, sizeof(PRINTDLG_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "ChooseColor_Callback16",    MOD_USER, sizeof(CHOOSECOLOR_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "PeekMessage32",             MOD_USER, sizeof(PEEKMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "GetMessage32",              MOD_USER, sizeof(GETMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "TranslateMessage32",        MOD_USER, sizeof(TRANSLATEMESSAGE3216))},
    {W32FUN(IT(DispatchMessage32),          "DispatchMessage32",         MOD_USER, sizeof(DISPATCHMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "CallMsgFilter32",           MOD_USER, sizeof(CALLMSGFILTER3216))},

  /*** 0590 ***/
    {W32FUN(UNIMPLEMENTED95API,             "IsDialogMessage32",         MOD_USER, sizeof(ISDIALOGMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "PostMessage32",             MOD_USER, sizeof(POSTMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "PostThreadMessage32",       MOD_USER, sizeof(POSTTHREADMESSAGE3216))},
    {W32FUN(WU32MessageBoxIndirect,         "MessageBoxIndirect",        MOD_USER, sizeof(MESSAGEBOXINDIRECT16))},
    {W32FUN(UNIMPLEMENTED95API,             "InstallIMT",                MOD_USER, sizeof(INSTALLIMT16))},
    {W32FUN(UNIMPLEMENTED95API,             "UninstallIMT",              MOD_USER, sizeof(UNINSTALLIMT16))},
    {W32FUN(WU32WinHelp,                    "Win32WinHelp",              MOD_USER, sizeof(WIN32WINHELP16))},
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuwind.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUWIND.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *  12-FEB-92 mattfe changed WU32EnumTaskWindows to access 16 bit TDB
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(wuwind.c);

// From wumsg.c [SendDlgItemMesssage caching]
extern HWND hdlgSDIMCached ;

// From wuman.c [Identify thunked system class WndProcs]
extern WORD gUser16CS;

// From wkman.c [hinst/hmod for user32]
extern HANDLE ghInstanceUser32;

// dwExStyle is used by the CreateWindow and CreateWindowEx thunks
// so that they can use a common procedure (don't worry, the current
// task cannot be preempted during its use)

STATIC ULONG dwExStyle;

// Some apps (DASHboard from HP) try to get PROGMAN to save its settings
// in a funky way.  This variable is used to help detect these guys.
// Bobday 5/29/93
HWND hwndProgman = (HWND)0;

/*++
    void AdjustWindowRect(<lpRect>, <dwStyle>, <bMenu>)
    LPRECT <lpRect>;
    DWORD <dwStyle>;
    BOOL <bMenu>;

    The %AdjustWindowRect% function computes the required size of the window
    rectangle based on the desired client-rectangle size. The window rectangle
    can then be passed to the %CreateWindow% function to create a window whose
    client area is the desired size. A client rectangle is the smallest
    rectangle that completely encloses a client area. A window rectangle is the
    smallest rectangle that completely encloses the window. The dimensions of
    the resulting window rectangle depend on the window styles and on whether
    the window has a menu.

    <lpRect>
        Points to a %RECT% structure that contains the coordinates of the
        client rectangle.

    <dwStyle>
        Specifies the window styles of the window whose client rectangle
        is to be converted.

    <bMenu>
        Specifies whether the window has a menu.

    This function does not return a value.

    This function assumes a single menu row. If the menu bar wraps to two or
    more rows, the coordinates are incorrect.
--*/

ULONG FASTCALL WU32AdjustWindowRect(PVDMFRAME pFrame)
{
    RECT t1;
    register PADJUSTWINDOWRECT16 parg16;

    GETARGPTR(pFrame, sizeof(ADJUSTWINDOWRECT16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    AdjustWindowRect(
        &t1,
        LONG32(parg16->f2),
        BOOL32(parg16->f3)
        );

    PUTRECT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void AdjustWindowRectEx(<lpRect>, <dwStyle>, <bMenu>, <dwExStyle>)
    LPRECT <lpRect>;
    DWORD <dwStyle>;
    BOOL <bMenu>;
    DWORD <dwExStyle>;

    The %AdjustWindowRectEx% function computes the required size of the
    rectangle of a window with extended style based on the desired
    client-rectangle size. The window rectangle can then be passed to the
    %CreateWindowEx% function to create a window whose client area is the
    desired size.

    A client rectangle is the smallest rectangle that completely encloses a
    client area. A window rectangle is the smallest rectangle that completely
    encloses the window. The dimensions of the resulting window rectangle
    depends on the window styles and on whether the window has a menu.

    <lpRect>
        Points to a %RECT% structure that contains the coordinates of the
        client rectangle.

    <dwStyle>
        Specifies the window styles of the window whose client rectangle
        is to be converted.

    <bMenu>
        Specifies whether the window has a menu.

    <dwExStyle>
        Specifies the extended style of the window being created.

    This function does not return a value.

    This function assumes a single menu row. If the menu bar wraps to two or
    more rows, the coordinates are incorrect.
--*/

ULONG FASTCALL WU32AdjustWindowRectEx(PVDMFRAME pFrame)
{
    RECT t1;
    register PADJUSTWINDOWRECTEX16 parg16;

    GETARGPTR(pFrame, sizeof(ADJUSTWINDOWRECTEX16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    AdjustWindowRectEx(
        &t1,
        LONG32(parg16->f2),
        BOOL32(parg16->f3),
        DWORD32(parg16->f4)
        );

    PUTRECT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}

/*++
    HWND ChildWindowFromPoint(<hwndParent>, <Point>)
    HWND <hwndParent>;
    POINT <Point>;

    The %ChildWindowFromPoint% function determines which, if any, of the child
    windows belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.

    The return value identifies the child window that contains the point. It is
    NULL if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any child window, the
    handle of the parent window is returned.
--*/

ULONG FASTCALL WU32ChildWindowFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT t2;
    register PCHILDWINDOWFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(CHILDWINDOWFROMPOINT16), parg16);
    COPYPOINT16(parg16->f2, t2);

    ul = GETHWND16(ChildWindowFromPoint(HWND32(parg16->f1), t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND ChildWindowFromPointEx(<hwndParent>, <Point>, <Flags>)
    HWND <hwndParent>;
    POINT <Point>;
    UINT <Flags>;

    The %ChildWindowFromPointEx% function determines which, if any, of the child
    windows belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.
        
    <Flags>
        Skipping flags

    The return value identifies the child window that contains the point. It is
    NULL if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any child window, the
    handle of the parent window is returned.
--*/

ULONG FASTCALL WU32ChildWindowFromPointEx(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt32;
    register PCHILDWINDOWFROMPOINTEX16 parg16;

    GETARGPTR(pFrame, sizeof(CHILDWINDOWFROMPOINTEX16), parg16);
    COPYPOINT16(parg16->pt, pt32);

    ul = GETHWND16(ChildWindowFromPointEx(HWND32(parg16->hwnd), pt32, DWORD32(parg16->wFlags)));

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    HWND CreateWindow(<lpClassName>, <lpWindowName>, <dwStyle>, <X>, <Y>,
        <nWidth>, <nHeight>, <hwndParent>, <hMenu>, <hInstance>, <lpParam>)
    LPSTR <lpClassName>;
    LPSTR <lpWindowName>;
    DWORD <dwStyle>;
    int <X>;
    int <Y>;
    int <nWidth>;
    int <nHeight>;
    HWND <hwndParent>;
    HMENU <hMenu>;
    HANDLE <hInstance>;
    LPSTR <lpParam>;

    The %CreateWindow% function creates an overlapped, pop-up, or child
    window. The %CreateWindow% function specifies the window class, window
    title, window style, and (optionally) initial position and size of the
    window. The %CreateWindow% function also specifies the window's parent (if
    any) and menu.

    For overlapped, pop-up, and child windows, the %CreateWindow% function sends
    WM_CREATE, WM_GETMINMAXINFO, and WM_NCCREATE messages to the window. The
    <lParam> parameter of the WM_CREATE message contains a pointer to a
    %CREATESTRUCT% structure. If WS_VISIBLE style is given, %CreateWindow%
    sends the window all the messages required to activate and show the window.

    If the window style specifies a title bar, the window title pointed to by
    the <lpWindowName> parameter is displayed in the title bar. When using
    %CreateWindow% to create controls such as buttons, check boxes, and text
    controls, the <lpWindowName> parameter specifies the text of the control.

    <lpClassName>
        Points to a null-terminated string that names the window class. The
        class name can be any name registered with the RegisterClass function or
        any of the predefined control-class names specified in Table T.2,
        "Control Classes."

    <lpWindowName>
        Points to a null-terminated string that represents the window name.

    <dwStyle>
        Specifies the style of window being created. It can be any
        combination of the styles given in Table *** <$R[C#]> ***.3, Window
        Styles the control styles given in Table 4.4, Control Styles, or a
        combination of styles created by using the bitwise OR operator. ,

    <X>
        Specifies the initial <x>-position of the window. For an
        overlapped or pop-up window, the <X> parameter is the initial
        <x>-coordinate of the window's upper-left corner (in screen
        coordinates). If this value is CW_USEDEFAULT, Windows selects the
        default position for the window's upper-left corner. For a child window,
        <X> is the <x>-coordinate of the upper-left corner of the window in the
        client area of its parent window.

    <Y>
        Specifies the initial <y>-position of the window. For an
        overlapped window, the <Y> parameter is the initial <y>-coordinate of
        the window's upper-left corner. For a pop-up window, <Y> is the
        <y>-coordinate (in screen coordinates) of the upper-left corner of the
        pop-up window. For list-box controls, <Y> is the <y>-coordinate of the
        upper-left corner of the control's client area. For a child window, <Y>
        is the <y>-coordinate of the upper-left corner of the child window. All
        of these coordinates are for the window, not the window's client area.

    <nWidth>
        Specifies the width (in device units) of the window. For
        overlapped windows, the <nWidth> parameter is either the window's width
        (in screen coordinates) or CW_USEDEFAULT. If <nWidth> is CW_USEDEFAULT,
        Windows selects a default width and height for the window (the default
        width extends from the initial <x>-position to the right edge of the
        screen, and the default height extends from the initial <y>-position to
        the top of the icon area).

    <nHeight>
        Specifies the height (in device units) of the window. For
        overlapped windows, the <nHeight> parameter is the window's height in
        screen coordinates. If the <nWidth> parameter is CW_USEDEFAULT, Windows
        ignores <nHeight>.

    <hwndParent>
        Identifies the parent or owner window of the window being
        created. A valid window handle must be supplied when creating a child
        window or an owned window. An owned window is an overlapped window that
        is destroyed when its owner window is destroyed, hidden when its owner
        is made iconic, and which is always displayed on top of its owner
        window. For pop-up windows, a handle can be supplied, but is not
        required. If the window does not have a parent or is not owned by
        another window, the <hwndParent> parameter must be set to NULL.

    <hMenu>
        Identifies a menu or a child-window identifier. The meaning
        depends on the window style. For overlapped or pop-up windows, the
        <hMenu> parameter identifies the menu to be used with the window. It can
        be NULL, if the class menu is to be used. For child windows, <hMenu>
        specifies the child-window identifier, an integer value that is used by
        a dialog-box control to notify its parent of events (such as the
        EN_HSCROLL message). The child-window identifier is determined by the
        application and should be unique for all child windows with the same
        parent window.

    <hInstance>
        Identifies the instance of the module to be associated with the
        window.

    <lpParam>
        Points to a value that is passed to the window through the
        %CREATESTRUCT% structure referenced by the <lParam> parameter of
        the WM_CREATE message. If an application is calling %CreateWindow% to
        create a multiple document interface (MDI) client window, <lpParam> must
        point to a %CLIENTCREATESTRUCT% structure.

    The return value identifies the new window. It is NULL if the window is not
    created.

    The %CreateWindow% function sends a WM_CREATE message to to the window
    procedure before it returns.

    For overlapped windows where the <X> parameter is CW_USEDEFAULT, the <Y>
    parameter can be one of the show-style parameters described with the
    %ShowWindow% function, or, for the first overlapped window to be created by
    the application, it can be the <nCmdShow> parameter passed to the WinMain
    function.

    BUTTON
        Designates a small rectangular child window that represents a button the
        user can turn on or off by clicking it. Button controls can be used
        alone or in groups, and can either be labeled or appear without text.
        Button controls typically change appearance when the user clicks them.

    COMBOBOX
        Designates a control consisting of a selection field similar to an edit
        control plus a list box. The list box may be displayed at all times or
        may be dropped down when the user selects a pop box next to the
        selection field.

        Depending on the style of the combo box, the user can or cannot edit the
        contents of the selection field. If the list box is visible, typing
        characters into the selection box will cause the first list box entry
        that matches the characters typed to be highlighted. Conversely,
        selecting an item in the list box displays the selected text in the
        selection field.

    EDIT
        Designates a rectangular child window in which the user can enter text
        from the keyboard. The user selects the control, and gives it the input
        focus by clicking it or moving to it by using the ^TAB^ key. The user
        can enter text when the control displays a flashing caret. The mouse can
        be used to move the cursor and select characters to be replaced, or to
        position the cursor for inserting characters. The ^BACKSPACE^ key can be
        used to delete characters.

        Edit controls use the variable-pitch system font and display ANSI
        characters. Applications compiled to run with previous versions of
        Windows display text with a fixed-pitch system font unless they have
        been marked by the Windows 3.0 %MARK% utility with the %MEMORY FONT%
        option. An application can also send the WM_SETFONT message to the edit
        control to change the default font.

        Edit controls expand tab characters into as many space characters as are
        required to move the cursor to the next tab stop. Tab stops are assumed
        to be at every eighth character position.

    LISTBOX
        Designates a list of character strings. This control is used whenever an
        application needs to present a list of names, such as filenames, that
        the user can view and select. The user can select a string by pointing
        to it and clicking. When a string is selected, it is highlighted and a
        notification message is passed to the parent window. A vertical or
        horizontal scroll bar can be used with a list-box control to scroll
        lists that are too long for the control window. The list box
        automatically hides or shows the scroll bar as needed.

    MDICLIENT
        Designates an MDI client window. The MDI client window receives messages
        which control the MDI application's child windows. The recommended style
        bits are WS_CLIPCHILDREN and WS_CHILD. To create a scrollable MDI client
        window which allows the user to scroll MDI child windows into view, an
        application can also use the WS_HSCROLL and WS_VSCROLL styles.

    SCROLLBAR
        Designates a rectangle that contains a thumb and has direction arrows at
        both ends. The scroll bar sends a notification message to its parent
        window whenever the user clicks the control. The parent window is
        responsible for updating the thumb position, if necessary. Scroll-bar
        controls have the same appearance and function as scroll bars used in
        ordinary windows. Unlike scroll bars, scroll-bar controls can be
        positioned anywhere in a window and used whenever needed to provide
        scrolling input for a window.

        The scroll-bar class also includes size-box controls. A size-box control
        is a small rectangle that the user can expand to change the size of the
        window.

    STATIC
        Designates a simple text field, box, or rectangle that can be used to
        label, box, or separate other controls. Static controls take no input
        and provide no output.

    DS_LOCALEDIT
        Specifies that edit controls in the dialog box will use memory in the
        application's data segment. By default, all edit controls in dialog
        boxes use memory outside the application's data segment. This feature
        may be suppressed by adding the DS_LOCALEDIT flag to the STYLE command
        for the dialog box. If this flag is not used, EM_GETHANDLE and
        EM_SETHANDLE messages must not be used since the storage for the control
        is not in the application's data segment. This feature does not affect
        edit controls created outside of dialog boxes.

    DS_MODALFRAME
        Creates a dialog box with a modal dialog-box frame that can be combined
        with a title bar and System menu by specifying the WS_CAPTION and
        WS_SYSMENU styles.

    DS_NOIDLEMSG
        Suppresses WM_ENTERIDLE messages that Windows would otherwise send to
        the owner of the dialog box while the dialog box is displayed.

    DS_SYSMODAL
        Creates a system-modal dialog box.

    WS_BORDER
        Creates a window that has a border.

    WS_CAPTION
        Creates a window that has a title bar (implies the WS_BORDER style).
        This style cannot be used with the WS_DLGFRAME style.

    WS_CHILD
        Creates a child window. Cannot be used with the WS_POPUP style.

    WS_CHILDWINDOW
        Creates a child window that has the WS_CHILD style.

    WS_CLIPCHILDREN
        Excludes the area occupied by child windows when drawing within the
        parent window. Used when creating the parent window.

    WS_CLIPSIBLINGS
        Clips child windows relative to each other; that is, when a particular
        child window receives a paint message, the WS_CLIPSIBLINGS style clips
        all other overlapped child windows out of the region of the child window
        to be updated. (If WS_CLIPSIBLINGS is not given and child windows
        overlap, it is possible, when drawing within the client area of a child
        window, to draw within the client area of a neighboring child window.)
        For use with the WS_CHILD style only.

    WS_DISABLED
        Creates a window that is initially disabled.

    WS_DLGFRAME
        Creates a window with a double border but no title.

    WS_GROUP
        Specifies the first control of a group of controls in which the user can
        move from one control to the next by using the ^DIRECTION^ keys. All
        controls defined with the WS_GROUP style after the first control belong
        to the same group. The next control with the WS_GROUP style ends the
        style group and starts the next group (that is, one group ends where the
        next begins). Only dialog boxes use this style.

    WS_HSCROLL
        Creates a window that has a horizontal scroll bar.

    WS_ICONIC
        Creates a window that is initially iconic. For use with the
        WS_OVERLAPPED style only.

    WS_MAXIMIZE
        Creates a window of maximum size.

    WS_MAXIMIZEBOX
        Creates a window that has a maximize box.

    WS_MINIMIZE
        Creates a window of minimum size.

    WS_MINIMIZEBOX
        Creates a window that has a minimize box.

    WS_OVERLAPPED
        Creates an overlapped window. An overlapped window has a caption and a
        border.

    WS_OVERLAPPEDWINDOW
        Creates an overlapped window having the WS_OVERLAPPED, WS_CAPTION,
        WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX, and WS_MAXIMIZEBOX styles.

    WS_POPUP
        Creates a pop-up window. Cannot be used with the WS_CHILD style.

    WS_POPUPWINDOW
        Creates a pop-up window that has the WS_BORDER, WS_POPUP, and WS_SYSMENU
        styles. The WS_CAPTION style must be combined with the WS_POPUPWINDOW
        style to make the system menu visible.

    WS_SYSMENU
        Creates a window that has a System-menu box in its title bar. Used only
        for windows with title bars.

    WS_TABSTOP
        Specifies one of any number of controls through which the user can move
        by using the ^TAB^ key. The ^TAB^ key moves the user to the next control
        specified by the WS_TABSTOP style. Only dialog boxes use this style.

    WS_THICKFRAME
        Creates a window with a thick frame that can be used to size the
        window.

    WS_VISIBLE
        Creates a window that is initially visible. This applies to overlapped
        and pop-up windows. For overlapped windows, the <Y> parameter is used as
        a %ShowWindow% function parameter.

    WS_VSCROLL
        Creates a window that has a vertical scroll bar.
--*/

ULONG FASTCALL WU32CreateWindow(PVDMFRAME pFrame)
{

    dwExStyle = 0;

    // this is a hack for MS Explorapedia -- see bug #189004 -- handle recycling
    // the app destroys this 1st hwnd it squirreled away -- which is the problem
    if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCF_CREATEBOGUSHWND) {

        // we detect this version by the offset of the return address
        if((pFrame->vpCSIP & 0x0000FFFF) == 0x8DBB)
            W32CreateWindow(pFrame);
    }

    return W32CreateWindow(pFrame);
}


/*++
    HWND CreateWindowEx(<dwExStyle>, <lpszClass>, <lpszName>,
        <dwStyle>, <x>, <y>, <cx>, <cy>, <hwndParent>, <hMenu>,
        <hInstance>, <lpCreateParams>)
    DWORD <dwExStyle>;
    LPSTR <lpszClass>;
    LPSTR <lpszName>;
    DWORD <dwStyle>;
    int <x>;
    int <y>;
    int <cx>;
    int <cy>;
    HWND <hwndParent>;
    HMENU <hMenu>;
    HANDLE <hInstance>;
    LPSTR <lpCreateParams>;

    The %CreateWindowEx% function creates an overlapped, pop-up, or child window
    with an extended style specified in the <dwExStyle> parameter. Otherwise,
    this function is identical to the %CreateWindow% function. See the
    description of the %CreateWindow% function for more information on creating
    a window and for a full descriptions of the other parameters of
    %CreateWindowEx%.

    <dwExStyle>
        Specifies the extended style of the window being created. It may be one
        of the following values:

    WS_EX_DLGMODALFRAME
        Designates a window with a double border that may optionally be created
        with a title bar by specifying the WS_CAPTION style flag in the
        <dwStyle> parameter.

    WS_EX_NOPARENTNOTIFY
        Specifies that a child window created with this style will not send the
        WM_PARENTNOTIFY message to its parent window when the child window is
        created or destroyed.

    WS_EX_TOPMOST
        ???

    WS_EX_ACCEPTFILES
        ???

    <lpszClass>
        Points to a null-terminated string containing the name of the window
        class.

    <lpszName>
        Points to a null-terminated string containing the window name.

    <dwStyle>
        Specifies the style of window being created.

    <x>
        Specifies the initial left side position of the window.

    <y>
        Specifies the initial top position of the window.

    <cx>
        Specifies the width (in device units) of the window.

    <cy>
        Specifies the height (in device units) of the window.

    <hwndParent>
        Identifies the parent or owner window of the window being
        created.

    <hMenu>
        Identifies a menu or a child-window identifier. The meaning
        depends on the window style.

    <hInstance>
        Identifies the instance of the module to be associated with the
        window.

    <lpCreateParams>
        Contains any application-specific creation parameters. The window being
        created may access this data when the %CREATESTRUCT% structure is passed
        to the window via the WM_NCCREATE and WM_CREATE messages.

    The return value identifies the new window. It is NULL if the window is not
    created.

    The %CreateWindowEx% function sends the following messages to the window
    being created:

         WM_NCCREATE
         WM_NCCALCSIZE
         WM_CREATE
         WM_OTHERWINDOWCREATED
--*/

ULONG FASTCALL WU32CreateWindowEx(PVDMFRAME pFrame)
{
    register PCREATEWINDOWEX16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEWINDOWEX16), parg16);
    /*
     * We've had problems with apps setting new (Win 5.0) bits, like WS_EX_LAYERED.
     * This causes Real Bad Problems with thos apps.  Keep Wow apps from doing that.
     *  FritzS
     */
    dwExStyle = DWORD32(parg16->f1) & WS_EX_VALID40;

    FREEARGPTR(parg16);
    RETURN(W32CreateWindow(pFrame));
}
#ifdef FE_SB
// HACK for Director 4.0J
#define MAXNUMOFSTR 20
typedef struct _DIRECTOR {
    HWND   hwnd;            // handle of director window
    UCHAR  orgstr[2];       // application oreginal string
} DIRECTOR, *PDIRECTOR;
DIRECTOR  director[MAXNUMOFSTR];
#endif // FE_SB

ULONG FASTCALL W32CreateWindow(PVDMFRAME pFrame)
{
    PSZ     psz1;
    PSZ     pszClass;
    PSZ     psz2;
    HWND    hwnd32;
    HMENU   hmenu32;
    register PCREATEWINDOW16 parg16;
    CLIENTCREATESTRUCT  clientcreatestruct;
    LPVOID  vpparam;
    CHAR    szAtomName[WOWCLASS_ATOM_NAME];
    DWORD   dwStyle;
#ifdef FE_SB
    PDIRECTOR pdirector;
    unsigned char * pszTmp;
#endif // FE_SB

    GETARGPTR(pFrame, sizeof(CREATEWINDOW16), parg16);
    GETPSZIDPTR(parg16->vpszClass, psz1);
    GETPSZPTR(parg16->vpszWindow, psz2);

    if ( HIWORD(psz1) == 0 ) {
        pszClass = szAtomName;
        GetAtomName( (ATOM)psz1, pszClass, WOWCLASS_ATOM_NAME );
    } else {
        pszClass = psz1;
    }

    //
    // For child windows, the hMenu parameter is just a child window ID
    //
    if (DWORD32(parg16->dwStyle) & WS_CHILD) {
        hmenu32 = (HMENU)parg16->hMenu;

        // Invalidate SendDlgItemMessage cache
        hdlgSDIMCached = NULL ;
    }
    else
        hmenu32 = (HMENU32(parg16->hMenu));

    if (WOW32_stricmp(pszClass, "MDIClient")) {
        vpparam = (LPVOID)DWORD32(parg16->vpParam);
    } else {
        GETCLIENTCREATESTRUCT16(parg16->vpParam, &clientcreatestruct );
        vpparam = &clientcreatestruct;
    }

    dwStyle = DWORD32(parg16->dwStyle);
#ifdef FE_SB
        if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START && psz2) {

            pdirector = director;
            while (pdirector->hwnd)
                   pdirector++;

            for ((PSZ)pszTmp = psz2; *pszTmp; pszTmp++) {
                if (IsDBCSLeadByte(*pszTmp)) {
                    if (*(pszTmp+1) < 0x40 || *(pszTmp+1) > 0xfc) {
                        pdirector->orgstr[0] = *pszTmp;
                        pdirector->orgstr[1] = *(pszTmp+1);
                        *(pszTmp+1) = *pszTmp = 0x7c;
                        pdirector++;
                    }
                    pszTmp++;
                }
            }
        }
#endif // FE_SB

    hwnd32 = (pfnOut.pfnCsCreateWindowEx)(
               dwExStyle,
               pszClass,
               psz2,
               dwStyle,
               INT32DEFAULT(parg16->x),
               INT32DEFAULT(parg16->y),
               INT32DEFAULT(parg16->cx),
               INT32DEFAULT(parg16->cy),
               HWND32(parg16->hwndParent),
               hmenu32,
               HMODINST32(parg16->hInstance),
               vpparam,
               CW_FLAGS_ANSI);
#ifdef FE_SB
    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START) {

        pdirector = director;

        for (; pdirector->orgstr[0]; pdirector++) {
            if (hwnd32)
                if (!pdirector->hwnd)
                    pdirector->hwnd = hwnd32;
            else
                if (!pdirector->hwnd)
                    pdirector->orgstr[1] = pdirector->orgstr[0] = 0;
        }
    }
#endif // FE_SB

#ifdef DEBUG
    if (hwnd32) {
        CHAR    szClassName[80];

        LOGDEBUG(LOG_WARNING,("  Window %04x created on class = %s\n", GETHWND16(hwnd32),
                (GetClassName(hwnd32, szClassName, sizeof(szClassName)) ? szClassName : "Unknown")));
    } else {
        LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s\n", pszClass));
    }
#endif

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN((ULONG) GETHWND16(hwnd32));
}


/*++
    HANDLE BeginDeferWindowPos(<nNumWindows>)
    int <nNumWindows>;

    The %BeginDeferWindowPos% function allocates memory to contain a multiple
    window-position data structure and returns a handle to the structure. The
    %DeferWindowPos% function fills this structure with information about the
    target position for a window that is about to be moved. The
    %EndDeferWindowPos% function accepts this structure and instantaneously
    repositions the windows using the information stored in the structure.

    <nNumWindows>
        Specifies the initial number of windows for which position information
        is to be stored in the structure. The %DeferWindowPos% function
        increases the size of the structure if needed.

    The return value identifies the multiple window-position structure. The
    return value is NULL if system resources are not available to allocate the
    structure.
--*/

ULONG FASTCALL WU32DeferWindowPos(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    HDWP  h32;
    register PDEFERWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(DEFERWINDOWPOS16), parg16);

    h32 = HDWP32(parg16->f1);

    if ( h32 ) {
      ul = (ULONG) DeferWindowPos(
                     h32,
                     HWND32(parg16->f2),
                     HWNDIA32(parg16->f3),
                     INT32(parg16->f4),
                     INT32(parg16->f5),
                     INT32(parg16->f6),
                     INT32(parg16->f7),
                     WORD32(parg16->f8) & SWP_VALID
                     );
    }
    else {
        goto WDWP_error;
    }

    if (ul != (ULONG) h32) {
        FREEHDWP16(parg16->f1);
        ul = GETHDWP16(ul);
        LOGDEBUG (12, ("WOW::DeferWindowsPos: ul = %08x, h32 = %08x\n", ul, h32));
    }
    else {
        ul = parg16->f1;
        LOGDEBUG (12, ("WOW::DeferWindowsPos: ul = %08x, parg = %08x\n", ul, parg16->f1));
    }
WDWP_error:
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DestroyWindow(<hwnd>)
    HWND <hwnd>;

    The %DestroyWindow% function destroys the specified window. The
    %DestroyWindow% function sends appropriate messages to the window to
    deactivate it and remove the input focus. It also destroys the window's
    menu, flushes the application queue, destroys outstanding timers, removes
    clipboard ownership, and breaks the clipboard-viewer chain, if the window is
    at the top of the viewer chain. It sends WM_DESTROY and WM_NCDESTROY
    messages to the window.

    If the given window is the parent of any windows, these child windows are
    automatically destroyed when the parent window is destroyed. The
    %DestroyWindow% function destroys child windows first, and then the window
    itself.

    The %DestroyWindow% function also destroys modeless dialog boxes created by
    the %CreateDialog% function.

    <hwnd>
        Identifies the window to be destroyed.

    The return value specifies whether or not the specified window is destroyed.
    It is TRUE if the window is destroyed. Otherwise, it is FALSE.

    If the window being destroyed is a top-level window, a
    WM_OTHERWINDOWDESTROYED message will be broadcast to all top-level windows.

    If the window being destroyed is a child window and does not have the
    WS_NOPARENTNOTIFY style set, then a WM_PARENTNOTIFY message is sent to the
    parent.
--*/

ULONG FASTCALL WU32DestroyWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDESTROYWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(DESTROYWINDOW16), parg16);

    ul = GETBOOL16(DestroyWindow(HWND32(parg16->f1)));

    // Invalidate SendDlgItemMessage cache
    hdlgSDIMCached = NULL ;
#ifdef FE_SB
    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START) {

        PDIRECTOR pdirector = director;

        for (; pdirector->hwnd; ) {
            if (parg16->f1 == (WORD)pdirector->hwnd) {

                PDIRECTOR ptmp = pdirector;

                do {
                    ptmp->hwnd = (ptmp+1)->hwnd;
                    ptmp->orgstr[0] = (ptmp+1)->orgstr[0];
                    ptmp->orgstr[1] = (ptmp+1)->orgstr[1];
                    ptmp++;
                } while (ptmp->hwnd);
            }
            else
                pdirector++;
        }
    }
#endif // FE_SB

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void EndDeferWindowPos(<hWinPosInfo>)
    HANDLE <hWinPosInfo>;

    The %EndDeferWindowPos% function simultaneously updates the position and
    size of one or more windows in a single screen-refresh cycle. The
    <hWinPosInfo> parameter identifies a multiple window-position structure that
    contains the update information for the windows. The %DeferWindowPos%
    function stores the update information in the structure; the
    %BeginDeferWindowPos% function creates the initial structure used by these
    functions.

    <hWinPosInfo>
        Identifies a multiple window-position structure that contains size
        and position information for one or more windows. This structure is
        returned by the %BeginDeferWindowPos% function or the most recent call to
        the %DeferWindowPos% function.

    This function does not return a value.
--*/

ULONG FASTCALL WU32EndDeferWindowPos(PVDMFRAME pFrame)
{
    ULONG ul;
    register PENDDEFERWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(ENDDEFERWINDOWPOS16), parg16);

    ul = (ULONG)EndDeferWindowPos(HDWP32(parg16->f1));
    FREEHDWP16(parg16->f1);

    FREEARGPTR(parg16);
    RETURN(ul);
}


BOOL W32EnumWindowFunc(HWND hwnd, DWORD lParam)
{
    BOOL fReturn;
    PARM16 Parm16;

    WOW32ASSERT(lParam);

    Parm16.EnumWndProc.hwnd = GETHWND16(hwnd);
    STOREDWORD(Parm16.EnumWndProc.lParam, ((PWNDDATA)lParam)->dwUserWndParam);
    CallBack16(RET_ENUMWINDOWPROC, &Parm16, ((PWNDDATA)lParam)->vpfnEnumWndProc, (PVPVOID)&fReturn);

    return (BOOL16)fReturn;
}


/*++
    BOOL EnumChildWindows(<hwndParent>, <lpEnumFunc>, <lParam>)
    HWND <hwndParent>;
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumChildWindows% function enumerates the child windows that belong to
    the specified parent window by passing the handle of each child window, in
    turn, to the application-supplied callback function pointed to by the
    <lpEnumFunc> parameter.

    The %EnumChildWindows% function continues to enumerate windows until the
    called function returns zero or until the last child window has been
    enumerated.

    <hwndParent>
        Identifies the parent window whose child windows are to be enumerated.

    <lpEnumFunc>
        Is the procedure-instance address of the callback function.

    <lParam>
        Specifies the value to be passed to the callback function for
        the application's use.

    The return value is TRUE if all child windows have been enumerated.
    Otherwise, it is FALSE.

    This function does not enumerate pop-up windows that belong to the
    <hwndParent> parameter.

    The address passed as the <lpEnumFunc> parameter must be created by using
    the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%.

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window handle.

    <lParam>
        Specifies the long parameter argument of the %EnumChildWindows%
        function.

    The callback function should return TRUE to continue enumeration; it should
    return FALSE to stop enumeration.
--*/

ULONG FASTCALL WU32EnumChildWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMCHILDWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMCHILDWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f2);
    WndData.dwUserWndParam  = DWORD32(parg16->f3);

    ul = GETBOOL16(EnumChildWindows(HWND32(parg16->f1),
                                    (WNDENUMPROC)W32EnumWindowFunc,
                                    (LONG)&WndData));
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    BOOL EnumTaskWindows(<hTask>, <lpEnumFunc>, <lParam>)
    HANDLE <hTask>;
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumTaskWindows% function enumerates all windows associated with the
    <hTask> parameter, which is returned by the %GetCurrentTask% function. (A
    task is any program that executes as an independent unit. All applications
    are executed as tasks and each instance of an application is a task.) The
    enumeration terminates when the callback function, pointed to by
    <lpEnumFunc>, returns FALSE.

    <hTask>
        Identifies the specified task. The GetCurrentTask function returns this
        handle.

    <lpEnumFunc>
        Specifies the procedure-instance address of the window's callback
        function.

    <lParam>
        Specifies the 32-bit value that contains additional parameters
        that are sent to the callback function pointed to by <lpEnumFunc>.

    The return value specifies the outcome of the function. It is TRUE if all
    the windows associated with a particular task are enumerated. Otherwise, it
    is FALSE.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. The callback function must have the following form:

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies a window associated with the current task.

    <lParam>
        Specifies the same argument that was passed to the %EnumTaskWindows%
        function.

    The callback function can carry out any desired task. It must return TRUE to
    continue enumeration, or FALSE to stop it.
--*/

ULONG FASTCALL WU32EnumTaskWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMTASKWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMTASKWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f2);
    WndData.dwUserWndParam  = DWORD32(parg16->f3);

    ul = GETBOOL16(EnumThreadWindows(THREADID32(parg16->f1),
                                     (WNDENUMPROC)W32EnumWindowFunc,
                                     (LONG)&WndData));
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    BOOL EnumWindows(<lpEnumFunc>, <lParam>)
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumWindows% function enumerates all parent windows on the screen by
    passing the handle of each window, in turn, to the callback function pointed
    to by the <lpEnumFunc> parameter. Child windows are not enumerated.

    The %EnumWindows% function continues to enumerate windows until the called
    function returns zero or until the last window has been enumerated.

    <lpEnumFunc>
        Is the procedure-instance address of the callback function. See the
        following "Comments" section for details.

    <lParam>
        Specifies the value to be passed to the callback function for
        the application's use.

    The return value is TRUE if all windows have been enumerated. Otherwise, it
    is FALSE.

    The address passed as the <lpEnumFunc> parameter must be created by using
    the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. The callback function must have the following form:

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window handle.

    <lParam>
        Specifies the 32-bit argument of the %EnumWindows% function.

    The function must return TRUE to continue enumeration, or FALSE to stop it.
--*/

ULONG FASTCALL WU32EnumWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f1);
    WndData.dwUserWndParam  = DWORD32(parg16->f2);

    ul = GETBOOL16(EnumWindows((WNDENUMPROC)W32EnumWindowFunc, (LONG)&WndData));

    FREEARGPTR(parg16);
    RETURN(ul);
}




/*++
    HWND FindWindow(<lpClassName>, <lpWindowName>)
    LPSTR <lpClassName>;
    LPSTR <lpWindowName>;

    The %FindWindow% function returns the handle of the window whose class is
    given by the <lpClassName> parameter and whose window name, or caption, is
    given by the <lpWindowName> parameter. This function does not search child
    windows.

    <lpClassName>
        Points to a null-terminated string that specifies the window's class
        name. If lpClassName is NULL, all class names match.

    <lpWindowName>
        Points to a null-terminated string that specifies the window name (the
        window's text caption). If <lpWindowName> is NULL, all window names
        match.

    The return value identifies the window that has the specified class name and
    window name. It is NULL if no such window is found.
--*/

ULONG FASTCALL WU32FindWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    PSZ pszClass;
    register PFINDWINDOW16 parg16;
    CHAR    szAtomName[WOWCLASS_ATOM_NAME];

    GETARGPTR(pFrame, sizeof(FINDWINDOW16), parg16);
    GETPSZIDPTR(parg16->f1, psz1);
    GETOPTPTR(parg16->f2, 0, psz2);

    if ( psz1 && HIWORD(psz1) == 0 ) {
        pszClass = szAtomName;
        GetAtomName( (ATOM)psz1, pszClass, WOWCLASS_ATOM_NAME );
    } else {
        pszClass = psz1;
    }


    // Some apps during their installation try to find Program Manager's
    // window handle by doing FindWindow. Once they get the window handle
    // then they do DDE with program manager to create app group. An app
    // can call FindWindow in one of the three ways.
    //
    //   FindWindow ("progman", NULL)
    //   FindWindow (NULL, "program manager")
    //   FindWindow ("progman", "program manager")
    //
    // The case 2 and 3 of the above will fail on NT because the title of
    // the program manager window under NT is "Program Manager - xxx\yyy".
    // Where xxx is the domain name and yyy is the user name.
    //
    // To provide the Win 3.1 compatibility to the 16 bit apps, we check for
    // the above cases. For these cases we call FindWindow ("progman", NULL)
    // to get the window handle of the program manager's top level window.
    //
    // AmiPro calls FindWindow as case two of the above to find the window
    // handle of the program manager to do DDE with.
    // ChandanC, 5/18/93
    //

    // Some apps send WM_SYSCOMMAND - SC_CLOSE messages to program manager
    // with the shift key down to get it to save its settings.  They do
    // this by 1st finding the program manager window...

    if ((pszClass && !WOW32_stricmp (pszClass, "progman")) ||
        (psz2 && !WOW32_stricmp (psz2, "program manager"))) {

        ul = GETHWND16(FindWindow("progman", NULL));

        // Some apps send WM_SYSCOMMAND - SC_CLOSE messages to program manager
        // with the shift key down to get it to save its settings.      They do
        // this by 1st finding the program manager window...
        // So, save this window handle for later.
        hwndProgman = (HWND)ul;
    }
    else {
        ul = GETHWND16(FindWindow(pszClass, psz2));
    }

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND GetActiveWindow(VOID)

    The %GetActiveWindow% function retrieves the window handle of the active
    window. The active window is either the window that has the current input
    focus, or the window explicitly made active by the %SetActiveWindow%
    function.

    This function has no parameters.

    The return value identifies the active window.
--*/

ULONG FASTCALL WU32GetActiveWindow(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = (ULONG)GetActiveWindow();

    // GetActiveWindow returned NULL. So try GetForegroundWindow.
    // Some apps like Toolbook donot paint if GetActiveWindow returns NULL.
    //
    // Alternatively we can return the wowexec's window handle.. basically
    // something NON-NULL
    //
    // NOTE: Win31 and Win32 GetActiveWindow differ semantically and hence
    //       the need for fooling with this API.
    //
    //                                              - Nanduri Ramakrishna
    //
    // We need to do something different now, since JimA recently changed
    // GetForegroundWindow() so that it can return NULL if the caller doesn't
    // have access to the foreground window.
    //
    //                                              - Dave Hart
    //
    // When GetForegroundWindow() returns null, now we return wowexec's
    // window handle. This theoretically could have some strange effects
    // since it is a hidden window. It might be better to return, say,
    // the desktop window. However, for reasons currently unknown, 
    // this screws a shutdown scenario with Micrografix Designer (it
    // gpfaults).
    //                                              - Neil Sandlin

    if (ul == (ULONG)NULL) {
        ul = (ULONG)GetForegroundWindow();
    }

    if (ul == (ULONG)NULL) {
        ul = (ULONG)ghwndShell;
    }

    ul = GETHWND16(ul);

    WOW32ASSERT(ul);
    RETURN(ul);
}


/*++
    HDC GetWindowDC(<hwnd>)
    HWND <hwnd>;

    The %GetWindowDC% function retrieves the display context for the entire
    window, including caption bar, menus, and scroll bars. A window display
    context permits painting anywhere in a window, including the caption bar,
    menus, and scroll bars, since the origin of the context is the upper-left
    corner of the window instead of the client area.

    %GetWindowDC% assigns default attributes to the display context each time it
    retrieves the context. Previous attributes are lost.

    <hwnd>
        Identifies the window whose display context is to be retrieved.

    The return value identifies the display context for the given window if the
    function is successful. Otherwise, it is NULL.

    The %GetWindowDC% function is intended to be used for special painting
    effects within a window's nonclient area. Painting in nonclient areas of any
    window is not recommended.

    The %GetSystemMetrics% function can be used to retrieve the dimensions of
    various parts of the nonclient area, such as the caption bar, menu, and
    scroll bars.

    After painting is complete, the %ReleaseDC% function must be called to
    release the display context. Failure to release a window display context
    will have serious effects on painting requested by applications.
--*/

ULONG FASTCALL WU32GetWindowDC(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETWINDOWDC16 parg16;
    HAND16 htask16 = pFrame->wTDB;

    GETARGPTR(pFrame, sizeof(GETWINDOWDC16), parg16);

    ReleaseCachedDCs(htask16, parg16->f1, 0, 0, SRCHDC_TASK16_HWND16);

    ul = GETHDC16(GetWindowDC(
    HWND32(parg16->f1)
    ));

    if (ul)
        StoreDC(htask16, parg16->f1, (HAND16)ul);

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    LONG GetWindowLong(<hwnd>, <nIndex>)
    HWND <hwnd>;
    int <nIndex>;

    The %GetWindowLong% function retrieves information about the window
    identified by the <hwnd> parameter.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the value to be retrieved. It can
        also be one of the following values:

    GWL_EXSTYLE
        Extended window style.

    GWL_STYLE
        Window style

    GWL_WNDPROC
        Long pointer to the window function

    The return value specifies information about the given window.

    To access any extra four-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first four-byte value in
    the extra space, 4 for the next four-byte value and so on.
--*/

ULONG FASTCALL WU32GetWindowLong(PVDMFRAME pFrame)
{
    ULONG ul;
    INT iOffset;
    register PWW pww;
    register PGETWINDOWLONG16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWLONG16), parg16);

    // Make sure Win32 didn't change offsets for GWL constants

#if (GWL_WNDPROC != (-4) || GWL_STYLE != (-16) || GWL_EXSTYLE != (-20) || DWL_MSGRESULT != (0))
#error Win16/Win32 GWL constants differ
#endif

#ifndef WIN16_GWW_HINSTANCE
#define WIN16_GWW_HINSTANCE     (-6)
#define WIN16_GWW_HWNDPARENT    (-8)
#define WIN16_GWW_ID            (-12)
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_WNDPROC  ||
        iOffset == GWL_STYLE || iOffset == GWL_EXSTYLE ||
        iOffset == WIN16_GWW_HINSTANCE  ||
        iOffset == WIN16_GWW_HWNDPARENT ||
        iOffset == WIN16_GWW_ID         );

    ul = 0;
    switch( iOffset ) {
        case DWL_DLGPROC:
        case GWL_WNDPROC:
            if (pww = FindPWW(HWND32(parg16->f1))) {
                DWORD dwWndProc32Cur;

                if ((iOffset == DWL_DLGPROC) && !(pww->state & WF_DIALOG_WINDOW)) {
                    goto defgwl;
                }
                dwWndProc32Cur = GetWindowLong(HWND32(parg16->f1), iOffset);

                if (IsWOWProc (dwWndProc32Cur)) {
                    if ( HIWORD(dwWndProc32Cur) == WNDPROC_HANDLE ) {
                        /*
                        ** Has a 32-bit WindowProc that is a handle-based value
                        ** (if it needs a 32-bit Ansi-Unicode transition, or
                        ** vice versa.)
                        */
                        ul = GetThunkWindowProc( dwWndProc32Cur, NULL, pww, HWND32(parg16->f1) );
                    } else {
                        /*
                        ** Has a WOW WindowProc
                        */

                        //Unmark the proc and restore the high bits from rpl field
                        UnMarkWOWProc (dwWndProc32Cur,ul);
                    }
                } else {
                    /*
                    ** Has a 32-bit WindowProc
                    */
                    if (dwWndProc32Cur) {
                        ul = GetThunkWindowProc( dwWndProc32Cur, NULL, pww, HWND32(parg16->f1) );
                    }
                }
            }
            break;

        case GWL_EXSTYLE:
            // Lotus Approach needs the WS_EX_TOPMOST bit cleared on
            // GetWindowLong of NETDDE AGENT window.
            ul = GetWindowLong(HWND32(parg16->f1), iOffset);
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLCLRTOPMOST) {
                char szBuf[40];

                if (GetClassName(HWND32(parg16->f1), szBuf, sizeof(szBuf))) {
                    if (!WOW32_stricmp(szBuf, "NDDEAgnt")) {
                        ul &= !WS_EX_TOPMOST;
                    }
                }
            }

            break;

defgwl:
        default:

            // This is a real HACK for PowerBuild 3.0. Before we change the offset
            // from 2 to 4, we nneed to make sure that we are doing it correctly for
            // this specific class.
            // The class in this case is "PaList".
            //
            // ChandanC Marh 9th 1994
            //

            if (iOffset == 2) {
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLINDEX2TO4) {
                    char Buffer[40];

                    if (GetClassName (HWND32(parg16->f1), Buffer, sizeof(Buffer))) {
                        if (!WOW32_stricmp (Buffer, "PaList")) {
                            iOffset = 4;
                        }
                    }
                }
            }

            ul = GetWindowLong(HWND32(parg16->f1), iOffset);
            break;

        case WIN16_GWW_HINSTANCE:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */
            ul = GetGWW_HINSTANCE(HWND32(parg16->f1));
            break;

        case WIN16_GWW_HWNDPARENT:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */

            ul = (ULONG)GETHWND16((HAND32)GetWindowLong(HWND32(parg16->f1),
                                                        GWL_HWNDPARENT));
            break;

        case WIN16_GWW_ID:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */
            ul = (ULONG)((WORD)GetWindowLong(HWND32(parg16->f1), GWL_ID));
            break;

    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HANDLE GetWindowTask(<hwnd>)
    HWND <hwnd>;

    The %GetWindowTask% function searches for the handle of a task associated
    with the <hwnd> parameter. A task is any program that executes as an
    independent unit. All applications are executed as tasks. Each instance of
    an application is a task.

    <hwnd>
        Identifies the window for which a task handle is retrieved.

    The return value identifies the task associated with a particular window.
--*/

ULONG FASTCALL WU32GetWindowTask(PVDMFRAME pFrame)
{
    register PGETWINDOWTASK16 parg16;
    DWORD dwThreadID, dwProcessID;
    PTD ptd;

    GETARGPTR(pFrame, sizeof(GETWINDOWTASK16), parg16);

    dwThreadID = GetWindowThreadProcessId(HWND32(parg16->f1), &dwProcessID);

    //
    // return corresponding htask16 if window belongs to a WOW thread
    // else return WowExec's htask.
    //

    ptd = ThreadProcID32toPTD(dwThreadID, dwProcessID);

    if (ptd == NULL) {
        ptd = gptdShell;
    }

    FREEARGPTR(parg16);
    return (ULONG)ptd->htask16;
}





/*++
    int GetWindowText(<hwnd>, <lpString>, <nMaxCount>)
    HWND <hwnd>;
    LPSTR <lpString>;
    int <nMaxCount>;

    The %GetWindowText% function copies the given window's caption title (if it
    has one) into the buffer pointed to by the <lpString> parameter. If the
    <hwnd> parameter identifies a control, the %GetWindowText% function copies
    the text within the control instead of copying the caption.

    <hwnd>
        Identifies the window or control whose caption or text is to be copied.

    <lpString>
        Points to the buffer that is to receive the copied string.

    <nMaxCount>
        Specifies the maximum number of characters to be copied to the
        buffer. If the string is longer than the number of characters specified
        in the <nMaxCount> parameter, it is truncated.

    The return value specifies the length of the copied string. It is zero if
    the window has no caption or if the caption is empty.

    This function causes a WM_GETTEXT message to be sent to the given window or
    control.
--*/

ULONG FASTCALL WU32GetWindowText(PVDMFRAME pFrame)
{
    ULONG ul;
    VPVOID vp;
    PSZ psz2;
    register PGETWINDOWTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWTEXT16), parg16);
    ALLOCVDMPTR(parg16->f2, parg16->f3, psz2);
    vp = parg16->f2;

    ul = GETINT16(GetWindowText(HWND32(parg16->f1), psz2, WORD32(parg16->f3)));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, (USHORT)ul+1, psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}




/*++
    WORD GetWindowWord(<hwnd>, <nIndex>)
    HWND <hwnd>;
    int <nIndex>;

    The %GetWindowWord% function retrieves information about the window
    identified by <hwnd>.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the value to be retrieved. It can
        also be one of the following values:

    GWL_HINSTANCE
        Instance handle of the module that owns the window.

    GWL_HWNDPARENT
        Handle of the parent window, if any. The %SetParent% function changes
        the parent window of a child window. An application should not call the
        %SetWindowLong% function to change the parent of a child window.

    GWL_ID
        Control ID of the child window.

    The return value specifies information about the given window.


    To access any extra two-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first two-byte value in the
    extra space, 2 for the next two-byte value and so on.
--*/

ULONG FASTCALL WU32GetWindowWord(PVDMFRAME pFrame)
{
    ULONG ul;
    HWND hwnd;
    INT iOffset;
    PWW pww;
    PGETWINDOWWORD16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWWORD16), parg16);

    // Make sure Win32 didn't change offsets

#if (GWL_HINSTANCE != (-6) || GWL_HWNDPARENT != (-8) || GWL_ID != (-12))
#error Win16/Win32 window-word constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_HINSTANCE  ||
        iOffset == GWL_STYLE      ||
        iOffset == GWL_HWNDPARENT || iOffset == GWL_ID);

    hwnd = HWND32(parg16->f1);

    switch(iOffset) {
    case GWL_STYLE:
        // Wordperfect for windows calls GetWindowWord with GWL_STYLE.
        ul = (ULONG)GetWindowLong(hwnd, iOffset);
        break;

    case GWL_HINSTANCE:
        ul = GetGWW_HINSTANCE(hwnd);
        break;

    case GWL_HWNDPARENT:
        ul = (ULONG)GETHWND16((HAND32)GetWindowLong(hwnd, iOffset));
        break;

    case GWL_ID:
        ul = GetWindowLong(hwnd, iOffset);
        if (!(GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)) {
            ul = (ULONG)GETHMENU16(ul);
        }
        break;

    // Under Windows index 4 of a static control could be the icon
    case 4:
        pww = FindPWW(hwnd);
        if (pww) {
            if (((pww->style & SS_TYPEMASK) == SS_ICON)    && 
                (GETICLASS(pww, hwnd) == WOWCLASS_STATIC)) {
                ul = SendMessage(hwnd, STM_GETICON, 0, 0);
                return GETHICON16(ul);
            }
        }
        // FALL THROUGH!


    default:
        //
        // Offset is non-negative, this is the cbWndExtra bytes that
        // are fair game.
        //

        //
        // Gross app hack for Adonis' Clip-Art Window Shopper online
        // clipart software that comes with CA-Cricket Presents.
        // These people SetWindowWord(hwnd, 3, wWhatever), thereby
        // overwriting the 4th and 5th bytes of per-window data.
        // The edit control itself only uses the first 2 bytes
        // on 3.1, and has 6 bytes reserved, so this works.  On
        // NT the first 4 bytes are used (32-bit handle), and so
        // this P.O.S. overwrites the high byte of the handle.
        // So if it's the compatibility flag is set and the class name
        // matches the one this bogus app uses, and it's storing a
        // word at offset 3, change it to 4.  This is safe because
        // the NT edit control only uses the first 4 of its 6
        // reserved window extra bytes.
        //

        if (3 == iOffset && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_EDITCTRLWNDWORDS)) {

            char szClassName[30];

            if (GetClassName(hwnd, szClassName, sizeof(szClassName)) &&
                !WOW32_strcmp(szClassName, "SuperPassEdit")) {

                iOffset = 4;

                LOGDEBUG(LOG_ALWAYS,("WOW WU32GetWindowWord: SHOPPER hack triggered, using offset 4, rc = %x.\n",
                         GetWindowWord(hwnd, iOffset)));

            }
        }

        ul = GetWindowWord(hwnd, iOffset);
        break;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}

//
// GetGWW_HINSTANCE is a common implementation for GetWindowWord(GWW_HINSTANCE)
// and GetWindowLong(GWW_HINSTANCE).
//

ULONG FASTCALL GetGWW_HINSTANCE(HWND hwnd)
{
    DWORD dwProcessID32, dwThreadID32;
    ULONG ul;
    PWOAINST pWOA;
    PTD ptd;
    HTASK16 htask16;

    dwProcessID32 = (DWORD)-1;
    dwThreadID32 = GetWindowThreadProcessId( hwnd, &dwProcessID32 );

    ul = (ULONG)GetWindowLong(hwnd, GWL_HINSTANCE);

    if ( ISINST16(ul) ) {

        //
        // This could be a valid HINST in another WOW VDM,
        // in which case we need to hide it from this VDM.
        //

        if (dwProcessID32 != GetCurrentProcessId() &&
            dwProcessID32 != (DWORD)-1) {

            ul = (ULONG)ghInstanceUser32;
            goto ElseClause;
        }
    }
    else
    {
      ElseClause:
        // here if ul = NULL or ul = 0xZZZZ0000
        //
        // if (ul is 0xZZZZ0000) return 16bit user.exe instance.
        // PowerBuilder 3.0 does
        //     hInst =  GetWindowWord(Dialog, GWL_HINSTANCE)
        //     hIcon =  CreateIcon(... hInst ...);
        // CreateIcon will fail if hInst is invalid (say BOGUSGDT). So
        // we return 16bit user.exe hinstance in all such cases.
        //
        // Some 32-bit applications put 0 in the HINSTANCE
        // stuff for their window (its optional for 32-bit windows).
        //

        //
        // Check if this window belongs to a task we spawned via
        // WinOldAp, if so, return WinOldAp's hmodule.
        //

        ptd = CURRENTPTD();
        EnterCriticalSection(&ptd->csTD);
        pWOA = ptd->pWOAList;
        while (pWOA && pWOA->dwChildProcessID != dwProcessID32) {
            pWOA = pWOA->pNext;
        }

        if (pWOA) {
            ul = pWOA->ptdWOA->hInst16;
            LOGDEBUG(LOG_ALWAYS, ("WOW32 GetWindowWord(0x%x, GWW_HINSTANCE) returning 0x%04x\n",
                                  hwnd, ul));
        } else {

            ul = (ul) ? gUser16hInstance : ul;

            if (cHtaskAliasCount != 0 ) {

                //
                // Must be some 32-bit process, not a wow app's window
                //

                if ( dwThreadID32 != 0 ) {

                    htask16 = FindHtaskAlias( dwThreadID32 );

                    if ( htask16 != 0 ) {
                        ul = (ULONG)htask16;
                    }
                }
            }
        }
        LeaveCriticalSection(&ptd->csTD);
    }

    return ul;
}

/*++
    UINT MenuItemFromPoint(<hwndParent>, <Menu>, <Point>)
    HWND <hwndParent>;
    HMENU <Menu>;
    POINT <Point>;

    The %MenuItemFromPoint% function determines which, if any, of the menu
    items belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.

    The return value identifies the menu item that contains the point. It is
    -1 if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any menu item, -1
    is returned.
--*/

ULONG FASTCALL WU32MenuItemFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt32;
    register PMENUITEMFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(MENUITEMFROMPOINT16), parg16);
    COPYPOINT16(parg16->ptScreen, pt32);

    ul = MenuItemFromPoint(HWND32(parg16->hwnd), HMENU32(parg16->hmenu), pt32);

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    BOOL MoveWindow(<hwnd>, <left>, <top>, <width>, <height>, <fRepaint>)
    HWND <hwnd>;
    int <left>;
    int <top>;
    int <width>;
    int <height>;
    BOOL <fRepaint>;

    The %MoveWindow% function changes the position and dimensions of a window.

    <hwnd>
        Identifies the window to change.

    <left>
        Specifies the new position of the left side of the window.

    <top>
        Specifies the new position of the top of the window.

    <width>
        Specifies the new width of the window.

    <height>
        Specifies the new height of the window.

    <fRepaint>
        Specifies whether or not the window is to be repainted. If this
        parameter is TRUE, the window is repainted.

    The return value is nonzero if the function is successful. Otherwise it is
    zero.  (updated for Win3.1 compatability -- this returned void for Win3.0)

    For top-level windows the <left> and <top> parameters are relative to the
    upper-left corner of the screen. For child windows, they are relative to the
    upper-left corner of the parent window's client area.

    The %MoveWindow% function sends a WM_GETMINMAXINFO message to the window
    being moved. This gives the window being moved the opportunity to modify
    the default values for the largest and smallest possible windows. If the
    parameters to the %MoveWindow% function exceed these values, the values will
    be replaced by the minimum or maximum values specified in the
    WM_GETMINMAXINFO message.
--*/

ULONG FASTCALL WU32MoveWindow(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PMOVEWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(MOVEWINDOW16), parg16);

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {
        RECT ParentRect;
        RECT ScreenRect;

        GetWindowRect(GetDesktopWindow(), &ScreenRect);
        if ((INT32(parg16->f2) > ScreenRect.right) ||
            (INT32(parg16->f3) > ScreenRect.bottom) ||
            (INT32(parg16->f4) > ScreenRect.right) ||
            (INT32(parg16->f5) > ScreenRect.bottom)) {
            int x, y, cx, cy;

            GetWindowRect(GetParent(HWND32(parg16->f1)), &ParentRect);
            x  = ParentRect.left;
            y  = ParentRect.top;
            cx = ParentRect.right - ParentRect.left;
            cy = ParentRect.bottom - ParentRect.top;


            ul = GETBOOL16(MoveWindow(HWND32(parg16->f1), x, y, cx, cy,
                                      BOOL32(parg16->f6)));
            FREEARGPTR(parg16);
            RETURN(ul);
        }
    }

    ul = GETBOOL16(MoveWindow(HWND32(parg16->f1),
                              INT32(parg16->f2),
                              INT32(parg16->f3),
                              INT32(parg16->f4),
                              INT32(parg16->f5),
                              BOOL32(parg16->f6)));


    FREEARGPTR(parg16);

    RETURN(ul);
}


/*++
    void ScrollWindow(<hwnd>, <XAmount>, <YAmount>, <lpRect>, <lpClipRect>)
    HWND <hwnd>;
    int <XAmount>;
    int <YAmount>;
    LPRECT <lpRect>;
    LPRECT <lpClipRect>;

    The %ScrollWindow% function scrolls a window by moving the contents of the
    window's client area the number of units specified by the <XAmount>
    parameter along the screen's <x>-axis and the number of units specified by
    the <YAmount> parameter along the <y>-axis. The scroll moves right if
    <XAmount> is positive and left if it is negative. The scroll moves down if
    <YAmount> is positive and up if it is negative.

    <hwnd>
        Identifies the window whose client area is to be scrolled.

    <XAmount>
        Specifies the amount (in device units) to scroll in the <x>
        direction.

    <YAmount>
        Specifies the amount (in device units) to scroll in the <y>
        direction.

    <lpRect>
        Points to a %RECT% structure that specifies the portion of
        the client area to be scrolled. If <lpRect> is NULL, the entire client
        area is scrolled.

    <lpClipRect>
        Points to a %RECT% structure that specifies the clipping
        rectangle to be scrolled. Only bits inside this rectangle are scrolled.
        If <lpClipRect> is NULL, the entire window is scrolled.

    This function does not return a value.

    If the caret is in the window being scrolled, %ScrollWindow% automatically
    hides the caret to prevent it from being erased, then restores the caret
    after the scroll is finished. The caret position is adjusted accordingly.

    The area uncovered by the %ScrollWindow% function is not repainted, but is
    combined into the window's update region. The application will eventually
    receive a WM_PAINT message notifying it that the region needs repainting. To
    repaint the uncovered area at the same time the scrolling is done, call the
    %UpdateWindow% function immediately after calling %ScrollWindow%.

    If the <lpRect> parameter is NULL, the positions of any child windows in the
    window are offset by the amount specified by <XAmount> and <YAmount>, and
    any invalid (unpainted) areas in the window are also offset. %ScrollWindow%
    is faster when <lpRect> is NULL.

    If the <lpRect> parameter is not NULL, the positions of child windows are
    <not> changed, and invalid areas in the window are <not> offset. To prevent
    updating problems when <lpRect> is not NULL, call the %UpdateWindow%
    function to repaint the window before calling %ScrollWindow%.
--*/

ULONG FASTCALL WU32ScrollWindow(PVDMFRAME pFrame)
{
    RECT t4, *p4;
    RECT t5, *p5;
    register PSCROLLWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(SCROLLWINDOW16), parg16);
    p4 = GETRECT16(parg16->f4, &t4);
    p5 = GETRECT16(parg16->f5, &t5);

    ScrollWindow(
        HWND32(parg16->f1),
        INT32(parg16->f2),
        INT32(parg16->f3),
        p4,
        p5
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    LONG SetWindowLong(<hwnd>, <nIndex>, <dwNewLong>)
    HWND <hwnd>;
    int <nIndex>;
    DWORD <dwNewLong>;

    The %SetWindowLong% function changes an attribute of the window specified by
    the <hwnd> parameter.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the attribute to be changed. It may
        also be one of the following values:

    GWL_EXSTYLE
        Sets a new extended window style.

    GWL_STYLE
        Sets a new window style.

    GWL_WNDPROC
        Sets a new long pointer to the window procedure.

    <dwNewLong>
        Specifies the replacement value.

    The return value specifies the previous value of the specified long
    integer.

    If the %SetWindowLong% function and the GWL_WNDPROC index are used to set a
    new window function, that function must have the window-function form and be
    exported in the module-definition file of the application. For more
    information, see the %RegisterClass% function, earlier in this chapter.

    Calling %SetWindowLong% with the GCL_WNDPROC index creates a subclass of the
    window class used to create the window. See Chapter 1, Window Manager
    Interface Functions, for more information on window subclassing. An
    application should not attempt to create a window subclass for standard
    Windows controls such as combo boxes and buttons.

    To access any extra four-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first four-byte value in
    the extra space, 4 for the next four-byte value and so on.
--*/
ULONG FASTCALL WU32SetWindowLong(PVDMFRAME pFrame)
{
    ULONG ul;
    INT iOffset, iClass;
    register PWW pww;
    register PSETWINDOWLONG16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWLONG16), parg16);

    // Make sure Win32 didn't change offsets for GWL constants

#if (GWL_WNDPROC != (-4) || GWL_STYLE != (-16) || GWL_EXSTYLE != (-20))
#error Win16/Win32 GWL constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_WNDPROC  ||
        iOffset == GWL_STYLE || iOffset == GWL_EXSTYLE);

    ul = 0;
    if ((iOffset == GWL_WNDPROC) || (iOffset == DWL_DLGPROC)) {

        if (pww = FindPWW(HWND32(parg16->f1))) {
            DWORD dwWndProc32Old;
            DWORD dwWndProc32New;

            if ((iOffset == DWL_DLGPROC) && !(pww->state & WF_DIALOG_WINDOW)) {
                goto defswp;
            }
            // Look to see if the new 16:16 proc is a thunk for a 32-bit proc.
            dwWndProc32New = IsThunkWindowProc(LONG32(parg16->f3), &iClass );

            if ( dwWndProc32New != 0 ) {
                //
                // They are attempting to set the window proc to an existing
                // 16-bit thunk that is really just a thunk for a 32-bit
                // routine.  We can just set it back to the 32-bit routine.
                //
                dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, dwWndProc32New);

                // If the 32 bit set failed, perhaps because its another process,
                // then we want to fail too
                if (!dwWndProc32Old)
                    goto SWL_Cleanup;

            } else {
                //
                // They are attempting to set it to a real 16:16 proc.
                //
                LONG    l;

                l = LONG32(parg16->f3);

                // mark the proc as WOW proc and save the high bits in the RPL
                //
                // Don't mark a NULL proc since USER32 DefWindowProcWorker
                // looks specifically for NULL. WOW used to do this correctly
                // but was broken by a performance enhancement checkin. This
                // fixes VC1.52 debugging.
                //
                if (l) {
                    MarkWOWProc (l,l);
                }

                dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);

                // If the 32 bit set failed, perhaps because its another process,
                // then we want to fail too
                if (!dwWndProc32Old)
                    goto SWL_Cleanup;

            }

            if ( IsWOWProc (dwWndProc32Old)) {
                if ( HIWORD(dwWndProc32Old) == WNDPROC_HANDLE ) {
                    //
                    // If the return value was a handle to a proc (due to
                    // the need for unicode-ansi transitions, or vice versa)
                    // then treat it as a 32-bit thunk.
                    //
                    ul = GetThunkWindowProc(dwWndProc32Old, NULL, pww, HWND32(parg16->f1));
                } else {
                    //
                    // Previous proc was a 16:16 proc
                    //
                    //Unmark the proc and restore the high bits from rpl field
                    UnMarkWOWProc (dwWndProc32Old,ul);
                }
            } else {
                //
                // Previous proc was a 32-bit proc, use an allocated thunk
                //
                ul = GetThunkWindowProc(dwWndProc32Old, NULL, pww, HWND32(parg16->f1));
            }
        }

    }
    else {    // not GWL_WNDPROC or GWL_DLGPROC
        LONG new;
defswp:
        new = LONG32(parg16->f3);
    /*
     * We need to keep Wow apps from putting garbage in post-4.0 bits in
     * the extended style DWORD.  Kiplinger's TaxCut 97 sets the WS_EX_LAYERED
     * bit on their help window, which is quite unfortunate.
     */

        if (iOffset == GWL_EXSTYLE) {
            new &= WS_EX_VALID40;
            new |= (GetWindowLong(HWND32(parg16->f1), GWL_EXSTYLE) & ~WS_EX_VALID40);
    }

    // This is a real HACK for PowerBuild 3.0. Before we change the offset
    // from 2 to 4, we nneed to make sure that we are doing it for this
    // specific class.
    // The class in this case is "PaList".
    //
    // ChandanC Marh 9th 1994
    //

        if (iOffset == 2) {
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLINDEX2TO4) {
                char Buffer[40];

                if (GetClassName (HWND32(parg16->f1), Buffer, sizeof(Buffer))) {
                    if (!WOW32_stricmp (Buffer, "PaList")) {
                        iOffset = 4;
                    }
                }
            }
        }

        ul = SetWindowLong(HWND32(parg16->f1), iOffset, new);
    }

SWL_Cleanup:
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL ShowWindow(<hWnd>, <nCmdShow>)
    HWND <hWnd>;
    int <nCmdShow>;

    The %ShowWindow% function sets the specified windows show state.

    <hWnd>
        Handle to the window.

    <nCmdShow>
        Specifies how the window is to be shown. This value can have any of the
        following values:

    SW_FORCEMINIMIZE
        Minimizes a window, even if the thread that owns the window is hung.
        This flag should only be used when minimizing windows from a different
        thread.

    SW_HIDE
        Hides the window and activiates another window.

    SW_MINIMIZE
        Minimizes the specified window and activates the next top-level window
        in the Z order.

    SW_RESTORE
        Activates and displays the window. If the window is minimized or maximized,
        the system restores it to its original size and position. An application 
        should specify this flag when restoring a minimized window.

    SW_SHOW
        Activiates the window and displays it in its current size and position.

    SW_SHOWDEFAULT
        Sets the show state based on the SW_ value specified in the STARTUPINFO
        structure passed to the CreateProcess() function by the program that started
        the application.

    SW_SHOWMAXIMIZED
        Activates the window and displays it as a minimized window.

    SW_SHOWMINNOACTIVE
        Displays the window as a minimized window. This value is similar to 
        SW_SHOWMINIMIZED, except the window is not activated.
 
    SW_SHOWNA
        Displays the window in its current size and position. This value is similar
        to SW_SHOW, except the window is not activated.

    SW_SHOWNOACTIVATE
        Displays a window in its most recent size and position. This value is similar
        to SW_SHOWNORMAL, except the window is not activated.

    SW_SHOWNORMAL
        Activates and displays a window. If the window is minimized or maximized,
        the system restores it to its orignial size and position. An application 
        should specify this flag when displaying the window for the first time.


    This function returns nonzero if the window if the window was previously visible. 
    It returns zero if the window was previously hidden.

    The first time an application calls ShowWindow(), it should use the WinMain
    function's <nCmdShow> parameter as its <nCmdShow> parameter. Subsequent calls to
    ShowWindow() must use one of the values in the given list, instead of the one
    specified by the WinMain function's <nCmdShow> parameter.

--*/        
ULONG FASTCALL WU32ShowWindow(PVDMFRAME pFrame)
{
    BOOL bReturn = FALSE;
    register PSHOWWINDOW16 parg16;
   
    GETARGPTR(pFrame, sizeof(SHOWWINDOW16), parg16);

    bReturn = ShowWindow(HWND32(parg16->f1), INT32(parg16->f2));
    
    // WHISTLER RAID BUG #348251
    // The artgalry.exe window would remain behind autosketches window after it was
    // invoked. This hack works in conjuction with the GACF2_GIVEUPFOREGROUND
    // compatibility flag, applied to the app that will not give up the foreground.
    // In order to move the 16bit window to the top, we have to call 
    // SetForegroundWindow() on the hwnd. We only want to call this if the windows
    // show bit is set and the window is active.
    if((INT32(parg16->f2) | SW_SHOW) && (bReturn == 0) && (CURRENTPTD()->dwWOWCompatFlags2 & WOWCF2_SETFOREGROUND))
    {
        SetForegroundWindow(HWND32(parg16->f1));
        
        LOGDEBUG(LOG_WARNING, ("WU32ShowWindow: SetForegroundWindow called. HWND=%x STYLE=%x\n",
                 HWND32(parg16->f1),
                 INT32(parg16->f2)));
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)bReturn);
}


/*++
    BOOL SetWindowPos(<hwnd>, <hwndInsertAfter>, <X>, <Y>, <cx>, <cy>, <wFlags>)
    HWND <hwnd>;
    HWND <hwndInsertAfter>;
    int <X>;
    int <Y>;
    int <cx>;
    int <cy>;
    WORD <wFlags>;

    The %SetWindowPos% function changes the size, position, and ordering of
    child, pop-up, and top-level windows. Child, pop-up, and top-level windows
    are ordered according to their appearance on the screen; the topmost window
    receives the highest rank, and it is the first window in the list. This
    ordering is recorded in a window list.

    <hwnd>
        Identifies the window that will be positioned.

    <hwndInsertAfter>
        Identifies a window in the window-manager's list that will
        precede the positioned window.

    <X>
        Specifies the <x->coordinate of the window's upper-left corner.

    <Y>
        Specifies the <y->coordinate of the window's upper-left corner.

    <cx>
        Specifies the new window's width.

    <cy>
        Specifies the new window's height.

    <wFlags>
        Specifies one of eight possible 16-bit values that affect the
        sizing and positioning of the window. It must be one of the following
        values:

    SWP_DRAWFRAME
        Draws a frame (defined in the window's class description) around the
        window.

    SWP_HIDEWINDOW
        Hides the window.

    SWP_NOACTIVATE
        Does not activate the window.

    SWP_NOMOVE
        Retains current position (ignores the <x> and <y> parameters).

    SWP_NOSIZE
        Retains current size (ignores the <cx> and <cy> parameters).

    SWP_NOREDRAW
        Does not redraw changes.

    SWP_NOZORDER
        Retains current ordering (ignores the <hwndInsertAfter> parameter).

    SWP_SHOWWINDOW
        Displays the window.

    The return value is nonzero if the function is successful. Otherwise it is
    zero.  (updated for Win3.1 compatability -- this returned void for Win3.0)

    If the SWP_NOZORDER flag is not specified, Windows places the window
    identified by the <hwnd> parameter in the position following the window
    identified by the <hwndInsertAfter> parameter. If <hwndInsertAfter> is NULL,
    Windows places the window identified by <hwnd> at the top of the list. If
    <hwndInsertAfter> is set to 1, Windows places the window identified by
    <hwnd> at the bottom of the list.

    If the SWP_SHOWWINDOW or the SWP_HIDEWINDOW flags are set, scrolling and
    moving cannot be done simultaneously.

    All coordinates for child windows are relative to the upper-left corner of
    the parent window's client area.
--*/

ULONG FASTCALL WU32SetWindowPos(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PSETWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWPOS16), parg16);
#ifdef FE_IME	
    // MSKKBUG:3866  HWND_IMETOPMOST for MS-DRAW
    if ( (HWND)INT32(parg16->f2) == (HWND)-3 )
        ul = GETBOOL16(SetWindowPos(HWND32(parg16->f1),
                                    HWND_TOPMOST,
                                    INT32(parg16->f3),
                                    INT32(parg16->f4),
                                    INT32(parg16->f5),
                                    INT32(parg16->f6),
                                    WORD32(parg16->f7) & SWP_VALID));
    else
#endif // FE_IME
    ul = GETBOOL16(SetWindowPos(HWND32(parg16->f1),
                                HWNDIA32(parg16->f2),
                                INT32(parg16->f3),
                                INT32(parg16->f4),
                                INT32(parg16->f5),
                                INT32(parg16->f6),
                                WORD32(parg16->f7) & SWP_VALID));
    FREEARGPTR(parg16);

    RETURN(ul);
}


/*++
    void SetWindowText(<hwnd>, <lpString>)

    The %SetWindowText% function sets the given window's caption title (if one
    exists) to the string pointed to by the <lpString> parameter. If the <hwnd>
    parameter is a handle to a control, the %SetWindowText% function sets the
    text within the control instead of within the caption.

    <hwnd>
        Identifies the window or control whose text is to be changed.

    <lpString>
        Points to a null-terminated string.

    This function does not return a value.
--*/

ULONG FASTCALL WU32SetWindowText(PVDMFRAME pFrame)
{
    PSZ psz2;
    register PSETWINDOWTEXT16 parg16;
    HANDLE handle;

    GETARGPTR(pFrame, sizeof(SETWINDOWTEXT16), parg16);
    GETPSZPTR(parg16->f2, psz2);
    handle = HWND32(parg16->f1);

    if (NULL != psz2) {
        AddParamMap((DWORD)psz2, FETCHDWORD(parg16->f2));
    }

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {

        if (NULL == handle) {
            handle = (HANDLE) ((PTDB)SEGPTR(pFrame->wTDB,0))->TDB_CompatHandle;
        }
    }

    SetWindowText(handle, psz2);

    // if we used param map successfully - then nuke there

    if (NULL != psz2) {
        DeleteParamMap((DWORD)psz2, PARAM_32, NULL);
    }

    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    WORD SetWindowWord(<hwnd>, <nIndex>, <wNewWord>)

    The %SetWindowWord% function changes an attribute of the window specified by
    the <hwnd> parameter.

    <hwnd>
        Identifies the window to be modified.

    <nIndex>
        Specifies the byte offset of the word to be changed. It can also
        be one of the following values:

    GWL_HINSTANCE
        Instance handle of the module that owns the window.

    GWL_ID
        Control ID of the child window.

    <wNewWord>
        Specifies the replacement value.

    The return value specifies the previous value of the specified word.

    To access any extra two-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first two-byte value in the
    extra space, 2 for the next two-byte value and so on.
--*/

ULONG FASTCALL WU32SetWindowWord(PVDMFRAME pFrame)
{
    ULONG ul;
    HWND hwnd;
    INT iOffset;
    PSETWINDOWWORD16 parg16;
    PWW pww;

    GETARGPTR(pFrame, sizeof(SETWINDOWWORD16), parg16);

    // Make sure Win32 didn't change offsets

#if (GWL_HINSTANCE != (-6) || GWL_HWNDPARENT != (-8) || GWL_ID != (-12))
#error Win16/Win32 window-word constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_HINSTANCE || iOffset == GWL_ID ||
        iOffset == GWL_HWNDPARENT);

    hwnd = HWND32(parg16->f1);
    ul = WORD32(parg16->f3);

    switch(iOffset) {
        case GWL_HINSTANCE:
            ul = GETHINST16(SetWindowLong(hwnd,
                                          iOffset,
                                          (LONG)HMODINST32(parg16->f3)));
            break;

        case GWL_HWNDPARENT:
            //    ul = 0;         // not allowed to set this
            ul = SetWindowLong(hwnd, iOffset, (LONG)HWND32(parg16->f3));
            ul = GETHWND16((HAND32)ul);
            break;

        case GWL_ID:
            {
                // if this isn't a child window then the value should be a
                // menu handle
                BOOL    fChild = (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD);
                ul = SetWindowLong(hwnd,
                                   iOffset,
                                   fChild ? (LONG)ul : (LONG)HMENU32(parg16->f3));

                if (!fChild)
                    ul = (ULONG)GETHMENU16(ul);

                // Invalidate the SendDlgItemMessage cache
                hdlgSDIMCached = NULL ;
            }
            break;

        // Under Windows index 4 of a static control could be the icon
        case 4:
            pww = FindPWW(hwnd);
            if (pww) {
                if (((pww->style & SS_TYPEMASK) == SS_ICON)    && 
                    (GETICLASS(pww, hwnd) == WOWCLASS_STATIC)) {
                    ul = SendMessage(hwnd, STM_SETICON, (WPARAM)HICON32(ul), 0);
                    return GETHICON16(ul);
                }
            }
            // FALL THROUGH!

        default:
            //
            // Offset is non-negative, this is the cbWndExtra bytes that
            // are fair game.
            //

            //
            // Gross app hack for Adonis' Clip-Art Window Shopper online
            // clipart software that comes with CA-Cricket Presents.
            // These people SetWindowWord(hwnd, 3, wWhatever), thereby
            // overwriting the 4th and 5th bytes of per-window data.
            // The edit control itself only uses the first 2 bytes
            // on 3.1, and has 6 bytes reserved, so this works.  On
            // NT the first 4 bytes are used (32-bit handle), and so
            // this P.O.S. overwrites the high byte of the handle.
            // So if it's an app called "SHOPPER" and it's storing a
            // word at offset 3, change it to 4.  This is safe because
            // the NT edit control only uses the first 4 of its 6
            // reserved window extra bytes.
            //

            if (3 == iOffset && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_EDITCTRLWNDWORDS)) {

                char szClassName[30];

                if (GetClassName(hwnd, szClassName, sizeof(szClassName)) &&
                    !WOW32_strcmp(szClassName, "SuperPassEdit")) {

                    iOffset = 4;

                    LOGDEBUG(LOG_ALWAYS,("WOW WU32SetWindowWord: SHOPPER hack triggered, using offset 4.\n"));
                }
            }

            ul = SetWindowWord(hwnd, iOffset, (WORD)ul);
            break;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++          user
    void UpdateWindow(<hwnd>)

    The %UpdateWindow% function updates the client area of the given window by
    sending a WM_PAINT message to the window if the update region for the window
    is not empty. The %UpdateWindow% function sends a WM_PAINT message directly
    to the window function of the given window, bypassing the application
    queue. If the update region is empty, no message is sent.

    <hwnd>
        Identifies the window to be updated.

    This function does not return a value.
--*/

ULONG FASTCALL WU32UpdateWindow(PVDMFRAME pFrame)
{
    register PUPDATEWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(UPDATEWINDOW16), parg16);

    UpdateWindow(
        HWND32(parg16->f1)
        );

    FREEARGPTR(parg16);
    RETURN(0xcdef);         // ack!     same as win31
}


/*++
    HWND WindowFromPoint(<Point>)

    The %WindowFromPoint% function identifies the window that contains the given
    point; <Point> must specify the screen coordinates of a point on the screen.

    <Point>
        Specifies a %POINT% structure that defines the point to be checked.

    The return value identifies the window in which the point lies. It is NULL
    if no window exists at the given point.
--*/

ULONG FASTCALL WU32WindowFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT t1;
    register PWINDOWFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(WINDOWFROMPOINT16), parg16);
    COPYPOINT16(parg16->f1, t1);

    ul = GETHWND16(WindowFromPoint(t1));

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wuwind.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUWIND.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Enumeration handler data
 */
typedef struct _WNDDATA {       /* wnddata */
    VPPROC  vpfnEnumWndProc;    // 16-bit enumeration function
    DWORD   dwUserWndParam;     // user param, if any
} WNDDATA, *PWNDDATA;


/* Function prototypes
 */
ULONG FASTCALL WU32AdjustWindowRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32AdjustWindowRectEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32ChildWindowFromPoint(PVDMFRAME pFrame);
ULONG FASTCALL WU32ChildWindowFromPointEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateWindowEx(PVDMFRAME pFrame);
ULONG FASTCALL W32CreateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32DeferWindowPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32DestroyWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32EndDeferWindowPos(PVDMFRAME pFrame);

BOOL    W32EnumWindowFunc(HWND hwnd, DWORD lParam);

ULONG FASTCALL WU32EnumChildWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32EnumTaskWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32EnumWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32FindWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetActiveWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowDC(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowLong(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowTask(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowText(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowWord(PVDMFRAME pFrame);
ULONG FASTCALL WU32MenuItemFromPoint(PVDMFRAME pFrame);
ULONG FASTCALL WU32MoveWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32ScrollWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowLong(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowText(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowWord(PVDMFRAME pFrame);
ULONG FASTCALL WU32ShowWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32UpdateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32WindowFromPoint(PVDMFRAME pFrame);

ULONG FASTCALL GetGWW_HINSTANCE(HWND hwnd);

extern HWND hwndProgman;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wutmr.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTMR.H
 *  WOW32 16-bit User Timer API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Types
 */
typedef struct _TMR {       /* tmr */
    LIST_ENTRY TmrList;     // TMRs are stored in a list
    HWND16  hwnd16;	    // 16-bit handle of owning window, if any
    HTASK16 htask16;        // 16-bit handle of owning task
    HWND    hwnd32;         // 32-bit handle of owning window, if any
    WORD    wIndex;         // index into array for this timer
    UINT    dwEventID;      // 32-bit timer ID (as generated by WIN32)
    VPPROC  vpfnTimerProc;  // 16-bit timer proc address
    DWORD   dwTimerProc32;  // 32-bit timer proc address
} TMR, *PTMR, **PPTMR;


/* Function prototypes
 */

VOID CALLBACK W32Timer1(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer2(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer3(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer4(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer5(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer6(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer7(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer8(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer9(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer10(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer11(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer12(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer13(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer14(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer15(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer16(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer17(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer18(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer19(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer20(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer21(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer22(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer23(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer24(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer25(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer26(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer27(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer28(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer29(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer30(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer31(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer32(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer33(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer34(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);


VOID W32TimerFunc(UINT index, HWND hwnd, UINT idEvent, DWORD dwTime);


VOID    FreeTimer16(PTMR ptmr);
VOID    DestroyTimers16(HTASK16 htask16);

ULONG FASTCALL  WU32KillTimer(PVDMFRAME pFrame);
ULONG FASTCALL  WU32SetTimer(PVDMFRAME pFrame);

PTMR	FindTimer32(HWND16 hwnd, DWORD dwEventID);
PTMR    FindTimer16(HWND16 hwnd, HTASK16 htask16, WORD wEventID);
PTMR    IsDuplicateTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wEventID);
VOID    FreeWindowTimers16(HWND hwnd32);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wwmtbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, 1992, 1993 Microsoft Corporation
 *
 *  WKTBL2.h
 *  WOW32 wifeman API thunks
 *
 *  This file is included into the master thunk table.
 *
--*/
#ifdef FE_SB
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0010 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0020 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0030 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0040 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0050 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0060 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(WWM32MiscGetEUDCLeadByteRange, "MISCGETEUDCLEADBYTERANGE", MOD_WIFEMAN, sizeof(MISCGETEUDCLEADBYTERANGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
#endif // FE_SB

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wwmman.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1994, Microsoft Corporation
 *
 *  WWMMAN.H
 *  WOW32 16-bit WifeMan API support (manually-coded thunks)
 *
 *  History:
 *  Created 17-May-1994 by hiroh
--*/

ULONG FASTCALL	WWM32MiscGetEUDCLeadByteRange(PVDMFRAME pFrame);
unsigned char far * PASCAL SkipWhite(unsigned char far *lpch);
unsigned char far * PASCAL StrtoNum(unsigned char  far *lpch,
                                    unsigned short far *lpus);
unsigned short PASCAL CharToNum(unsigned char ch);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wwstbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WWSTBL2.h
 *  WOW32 16-bit Winsock API tables
 *
 *  History:
 *  Created 02-Oct-1992 by David Treadwell (davidtr)
 *
 *  This file is included into the master thunk table.
 *
--*/

    {W32FUN(UNIMPLEMENTEDAPI,              "DUMMYENTRY",           MOD_WINSOCK,    0)},
    {W32FUN(WWS32accept,                   "ACCEPT",               MOD_WINSOCK,    sizeof(ACCEPT16))},
    {W32FUN(WWS32bind,                     "BIND",                 MOD_WINSOCK,    sizeof(BIND16))},
    {W32FUN(WWS32closesocket,              "CLOSESOCKET",          MOD_WINSOCK,    sizeof(CLOSESOCKET16))},
    {W32FUN(WWS32connect,                  "CONNECT",              MOD_WINSOCK,    sizeof(CONNECT16))},
    {W32FUN(WWS32getpeername,              "GETPEERNAME",          MOD_WINSOCK,    sizeof(GETPEERNAME16))},
    {W32FUN(WWS32getsockname,              "GETSOCKNAME",          MOD_WINSOCK,    sizeof(GETSOCKNAME16))},
    {W32FUN(WWS32getsockopt,               "GETSOCKOPT",           MOD_WINSOCK,    sizeof(GETSOCKOPT16))},
    {W32FUN(WWS32htonl,                    "HTONL",                MOD_WINSOCK,    sizeof(HTONL16))},
    {W32FUN(WWS32htons,                    "HTONS",                MOD_WINSOCK,    sizeof(HTONS16))},

  /*** 0010 ***/
    {W32FUN(WWS32inet_addr,                "INET_ADDR",            MOD_WINSOCK,    sizeof(INET_ADDR16))},
    {W32FUN(WWS32inet_ntoa,                "INET_NTOA",            MOD_WINSOCK,    sizeof(INET_NTOA16))},
    {W32FUN(WWS32ioctlsocket,              "IOCTLSOCKET",          MOD_WINSOCK,    sizeof(IOCTLSOCKET16))},
    {W32FUN(WWS32listen,                   "LISTEN",               MOD_WINSOCK,    sizeof(LISTEN16))},
    {W32FUN(WWS32ntohl,                    "NTOHL",                MOD_WINSOCK,    sizeof(NTOHL16))},
    {W32FUN(WWS32ntohs,                    "NTOHS",                MOD_WINSOCK,    sizeof(NTOHS16))},
    {W32FUN(WWS32recv,                     "RECV",                 MOD_WINSOCK,    sizeof(RECV16))},
    {W32FUN(WWS32recvfrom,                 "RECVFROM",             MOD_WINSOCK,    sizeof(RECVFROM16))},
    {W32FUN(WWS32select,                   "SELECT",               MOD_WINSOCK,    sizeof(SELECT16))},
    {W32FUN(WWS32send,                     "SEND",                 MOD_WINSOCK,    sizeof(SEND16))},

  /*** 0020 ***/
    {W32FUN(WWS32sendto,                   "SENDTO",               MOD_WINSOCK,    sizeof(SENDTO16))},
    {W32FUN(WWS32setsockopt,               "SETSOCKOPT",           MOD_WINSOCK,    sizeof(SETSOCKOPT16))},
    {W32FUN(WWS32shutdown,                 "SHUTDOWN",             MOD_WINSOCK,    sizeof(SHUTDOWN16))},
    {W32FUN(WWS32socket,                   "SOCKET",               MOD_WINSOCK,    sizeof(SOCKET16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0030 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0040 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0050 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(WWS32gethostbyaddr,            "GETHOSTBYADDR",        MOD_WINSOCK,    sizeof(GETHOSTBYADDR16))},
    {W32FUN(WWS32gethostbyname,            "GETHOSTBYNAME",        MOD_WINSOCK,    sizeof(GETHOSTBYNAME16))},
    {W32FUN(WWS32getprotobyname,           "GETPROTOBYNAME",       MOD_WINSOCK,    sizeof(GETPROTOBYNAME16))},
    {W32FUN(WWS32getprotobynumber,         "GETPROTOBYNUMBER",     MOD_WINSOCK,    sizeof(GETPROTOBYNUMBER16))},
    {W32FUN(WWS32getservbyname,            "GETSERVBYNAME",        MOD_WINSOCK,    sizeof(GETSERVBYNAME16))},
    {W32FUN(WWS32getservbyport,            "GETSERVBYPORT",        MOD_WINSOCK,    sizeof(GETSERVBYPORT16))},
    {W32FUN(WWS32gethostname,              "GETHOSTNAME",          MOD_WINSOCK,    sizeof(GETHOSTNAME16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0060 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0070 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0080 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0090 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0100 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAAsyncSelect,           "WSAASYNCSELECT",         MOD_WINSOCK,  sizeof(WSAASYNCSELECT16))},
    {W32FUN(WWS32WSAAsyncGetHostByAddr,    "WSAASYNCGETHOSTBYADDR",  MOD_WINSOCK,  sizeof(WSAASYNCGETHOSTBYADDR16))},
    {W32FUN(WWS32WSAAsyncGetHostByName,    "WSAASYNCGETHOSTBYNAME",  MOD_WINSOCK,  sizeof(WSAASYNCGETHOSTBYNAME16))},
    {W32FUN(WWS32WSAAsyncGetProtoByNumber, "WSAASYNCGETPROTOBYNUMBER",MOD_WINSOCK, sizeof(WSAASYNCGETPROTOBYNUMBER16))},
    {W32FUN(WWS32WSAAsyncGetProtoByName,   "WSAASYNCGETPROTOBYNAME", MOD_WINSOCK,  sizeof(WSAASYNCGETPROTOBYNAME16))},
    {W32FUN(WWS32WSAAsyncGetServByPort,    "WSAASYNCGETSERVBYPORT",  MOD_WINSOCK,  sizeof(WSAASYNCGETSERVBYPORT16))},
    {W32FUN(WWS32WSAAsyncGetServByName,    "WSAASYNCGETSERVBYNAME",  MOD_WINSOCK,  sizeof(WSAASYNCGETSERVBYNAME16))},
    {W32FUN(WWS32WSACancelAsyncRequest,    "WSACANCELASYNCREQUEST",  MOD_WINSOCK,  sizeof(WSACANCELASYNCREQUEST16))},
    {W32FUN(WWS32WSASetBlockingHook,       "WSASETBLOCKINGHOOK",     MOD_WINSOCK,  sizeof(WSASETBLOCKINGHOOK16))},

  /*** 0110 ***/
    {W32FUN(WWS32WSAUnhookBlockingHook,    "WSAUNHOOKBLOCKINGHOOK",  MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAGetLastError,          "WSAGETLASTERROR",        MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSASetLastError,          "WSASETLASTERROR",        MOD_WINSOCK,  sizeof(WSASETLASTERROR16))},
    {W32FUN(WWS32WSACancelBlockingCall,    "WSACANCELBLOCKINGCALL",  MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAIsBlocking,            "WSAISBLOCKING",          MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAStartup,               "WSASTARTUP",             MOD_WINSOCK,  sizeof(WSASTARTUP16))},
    {W32FUN(WWS32WSACleanup,               "WSACLEANUP",             MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0120 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0130 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0140 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0150 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(WWS32__WSAFDIsSet,             "__WSAFDISSET",           MOD_WINSOCK,  sizeof(__WSAFDISSET16))},
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\wwmman.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1994, Microsoft Corporation
 *
 *  WWMMAN.C
 *  WOW32 16-bit WifeMan API support (manually-coded thunks)
 *
 *  History:
 *  Created 17-May-1994 by hiroh
 *  Rewrote 12-May-1995 by hideyukn
 *
--*/
#include "precomp.h"
#pragma hdrstop

#ifdef FE_SB

#include "wowwife.h"
#include "wwmman.h"

MODNAME(wwmman.c);

STATIC LPSTR SkipSpaces(LPSTR lpch)
{
    if (lpch == NULL) return(NULL);

    for ( ; ; lpch++ ) {
        switch (*lpch) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
            break;

        case '\0':
        // fall through...
        default:
            return(lpch);
        }
    }
}

#define EUDC_RANGE_KEY \
   (LPSTR) "SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage\\EUDCCodeRange"

ULONG FASTCALL WWM32MiscGetEUDCLeadByteRange(PVDMFRAME pFrame)
{
    unsigned short usEUDCRange = 0;
    unsigned char  chEUDCStart = 0, chEUDCEnd = 0;

    HKEY   hKey;
    ULONG  ulRet;
    CHAR   achACP[10];
    CHAR   achRange[256];

    DWORD  dwType;
    DWORD  dwRangeSize = sizeof(achRange);

    UNREFERENCED_PARAMETER(pFrame);

    //
    // Get EUDC Range
    //
    // In Win32, We support multiple EUDC Range, but for
    // Win16, we just return only first EUDC range to
    // keep backward compatibility...
    //

    ulRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, EUDC_RANGE_KEY,
                          (DWORD) 0, KEY_QUERY_VALUE, &hKey);
 
    if (ulRet != ERROR_SUCCESS) {
        #if DBG
        LOGDEBUG(0,("WOW32:RegOpenKeyExA(EUDC_RANGE_KEY) fail\n"));
        #endif
        return 0;
    }

    //
    // Convert ACP to string..
    //
    RtlIntegerToChar(GetACP(),10,sizeof(achACP),achACP);

    ulRet = RegQueryValueExA(hKey, achACP, (LPDWORD)NULL, (LPDWORD)&dwType,
                             (LPBYTE)achRange, &dwRangeSize);

    if (ulRet != ERROR_SUCCESS) {
        #if DBG
        LOGDEBUG(0,("WOW32:RegQueryValueExA(CP_ACP) fail\n"));
        #endif
        RegCloseKey(hKey);
        return 0;
    }

    RegCloseKey(hKey);

    //
    // Perse the data.
    //
    {
        LPSTR  pszData = achRange;
        USHORT usStart, usEnd;

        pszData = SkipSpaces(pszData);

        if ((*pszData) == '\0') {
            #if DBG
            LOGDEBUG(0,("WOW32:Parse First Data fail\n"));
            #endif
            return 0;
        }

        usStart = (USHORT)strtoul(pszData,&pszData,16);

        if ((pszData = WOW32_strchr(pszData,'-')) == NULL) {
            #if DBG
            LOGDEBUG(0,("WOW32:Find End Data fail\n"));
            #endif
            return 0;
        }

        //
        // Skip '-'..
        //
        pszData++;

        pszData = SkipSpaces(pszData);

        if ((*pszData) == '\0') {
            #if DBG
            LOGDEBUG(0,("WOW32:Parse End Data fail\n"));
            #endif
            return 0;
        }

        usEnd = (USHORT)strtoul(pszData,&pszData,16);

        //
        // Confirm the data sort order is correct
        //
        if (usStart > usEnd) {
            #if DBG
            LOGDEBUG(0,("WOW32:Invalid EUDC Range Order\n"));
            #endif
            return 0;
        }

        //
        // Get EUDC Start, End LeadByte...
        //
        chEUDCStart = HIBYTE(usStart);
        chEUDCEnd   = HIBYTE(usEnd);
    }

    //
    // Setup return value.
    //

    usEUDCRange = ((unsigned short)chEUDCEnd << 8) |
                  ((unsigned short)chEUDCStart     );

    #if DBG
    LOGDEBUG(10,("WOW32:EUDC Range = %x\n",usEUDCRange));
    #endif

    RETURN(usEUDCRange); 
}
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=xms

TARGETNAME=xms486
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..;\
    ..\..\inc;\
    $(SOFTPC_TREE)\base\inc

!IF $(ALPHA) || $(MIPS)
GPSIZE=0
!ELSE
GPSIZE=32
!ENDIF

SOURCES=..\xms.c       \
        ..\xmsa20.c    \
        ..\xmsblock.c  \
        ..\xmsdisp.c   \
        ..\xmsmisc.c   \
        ..\xmsumb.c

i386_SOURCES=..\i386\xmsmem86.c
MIPS_SOURCES=..\xmsmemr.c
ALPHA_SOURCES=..\xmsmemr.c
PPC_SOURCES=..\xmsmemr.c

C_DEFINES=-DWIN_32

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xms.h ===
/* xms.h - main include file for dem
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 *
 * williamh 25-Sept-1992 Added UMB support
 */

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32	1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
#define TRUE_IF_WIN32	0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL	0xC0010003
#endif
#include <xmsexp.h>
#include <suballoc.h>

#define SIZE_PARAGRAPH	16
#define XMSUMB_THRESHOLD    3 * SIZE_PARAGRAPH

/** Basic Typedefs of XMS **/

typedef VOID (*PFNSVC)(VOID);

typedef struct _ExtMemMove {
    ULONG   mm_len;		// Move Length
    USHORT  mm_hSource; 	// Source Handle
    ULONG   mm_SourceOffset;	// Source Offset
    USHORT  mm_hDest;		// Dest Handle
    ULONG   mm_DestOffset;	// Dest. offset
} EXTMEMMOVE, *PEXTMEMMOVE;


typedef struct _XMSUMB_ {
    WORD    Segment;
    WORD    Size;
    WORD    Owner;
    struct _XMSUMB_ *Next;
} XMSUMB, *PXMSUMB;

/** Function Prototypes */

VOID xmsA20		    (VOID);
VOID xmsAllocBlock	    (VOID);
VOID xmsFreeBlock	    (VOID);
VOID xmsReallocBlock	    (VOID);
VOID xmsMoveBlock	    (VOID);
VOID xmsSysPageSize	    (VOID);
VOID xmsQueryExtMem	    (VOID);
VOID xmsQueryFreeExtMem	    (VOID);
ULONG xmsGetMemorySize	    (BOOL);
ULONG xmsGetDefaultVDMSize  (VOID);
VOID xmsInitUMB		    (VOID);
VOID xmsRequestUMB	    (VOID);
VOID xmsReleaseUMB	    (VOID);
VOID xmsReleaseUMBNotify    (PVOID, ULONG);
VOID xmsInsertUMB           (PVOID, ULONG);
VOID xmsNotifyHookI15       (VOID);

VOID xmsDisableA20Wrapping   (VOID);
VOID xmsEnableA20Wrapping   (VOID);

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    );

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    );

VOID
xmsMoveMemory(
    ULONG Source,
    ULONG Destination,
    ULONG Count
    );


#ifndef i386
BOOL sas_manage_xms (VOID * start_addr, ULONG cb, INT a_or_f);
#endif

/** External Data */

extern ULONG xmsMemorySize;
extern BYTE * pHimemA20State;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xms.c ===
/*
 *  xms.c - Main Module of XMS DLL.
 *
 *  Sudeepb 15-May-1991 Craeted
 *  williamh 25-Sept-1992 added UMB support
 *  williamh 10-10-1992 added A20 line support
 */

#include <xms.h>
#include <suballoc.h>
#include "umb.h"
#include "memapi.h"

/* XMSInit - XMS Initialiazation routine. (This name may change when XMS is
 *       converted to DLL).
 *
 * Entry
 *  None
 *
 * Exit
 *  TRUE - iff ok to run NTVDM
 */

ULONG xmsMemorySize = (ULONG)0;   // Total XMS meory in K

extern BOOL VDMForWOW;

PVOID ExtMemSA;

BOOL XMSInit (VOID)
{
    DWORD   Size;
    PVOID   Address;
    ULONG   VdmAddress, XmsSize;
    NTSTATUS Status;

    if (!xmsMemorySize)
        return FALSE;

    Size = 0;
    Address = NULL;
    // commit all free UMBs.
    ReserveUMB(UMB_OWNER_RAM, &Address, &Size);

    XmsSize = xmsMemorySize * 1024 - (64*1024);

#ifndef i386
    Status = VdmAllocateVirtualMemory(&VdmAddress,
                                      XmsSize,
                                      FALSE);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        // Old emulator, just assume base address
#endif ; //i386
        //
        // Initialize the sub allocator
        //
        ExtMemSA = SAInitialize(
            1024 * 1024 + 64*1024,
            XmsSize,
            xmsCommitBlock,
            xmsDecommitBlock,
            xmsMoveMemory
            );

#ifndef i386
    } else {

        //
        // New emulator. Make sure the reserve worked
        //

        if (!NT_SUCCESS(Status)) {
            ASSERT(FALSE);
            return FALSE;
        }
       
        //
        // We only work correctly if emulator returned this value
        //
        if (VdmAddress != (1024 * 1024 + 64*1024)) {
            ASSERT(FALSE);
            return FALSE;
        }

        ExtMemSA = SAInitialize(
            VdmAddress,
            XmsSize,
            VdmCommitVirtualMemory,
            VdmDeCommitVirtualMemory,
            xmsMoveMemory
            );
            
    }
#endif // i386

    if (ExtMemSA == NULL) {
        return FALSE;
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsdisp.c ===
/*
 *  xmsdisp.c - SVC dispatch module for XMS
 *
 *  Modification History:
 *
 *  Sudeepb 15-May-1991 Created
 *
 *  williamh 25-Sept-1992 Added UMB support
 */

#include <xms.h>
#include <xmsexp.h>
#include <stdio.h>
#include <softpc.h>
#include <xmssvc.h>

PFNSVC	apfnXMSSvc [] = {
     xmsA20,		    // XMS_A20
     xmsMoveBlock,	    // XMS_MOVEBLOCK
     xmsAllocBlock,	    // XMS_ALLOCBLOCK
     xmsFreeBlock,	    // XMS_FREEBLOCK
     xmsSysPageSize,	    // XMS_SYSTEMPAGESIZE
     xmsQueryExtMem,	    // XMS_EXTMEM
     xmsInitUMB,	    // XMS_INITUMB
     xmsRequestUMB,	    // XMS_REQUESTUMB
     xmsReleaseUMB,         // XMS_RELEASEUMB
     xmsNotifyHookI15,      // XMS_NOTIFYHOOKI15
     xmsQueryFreeExtMem,    // XMS_QUERYEXTMEM
     xmsReallocBlock        // XMS_REALLOCBLOCK
};

/* XMSDispatch - Dispatch SVC call to right handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 * Note  - Some mechanism has to be worked out to let the emulator know
 *	   about DOSKRNL code segment and size. Using these it will figure
 *	   out whether SVCop (hlt for the moment) has to be passed to
 *	   DEM or to be handled as normal invalid opcode.
 */

BOOL XMSDispatch (ULONG iSvc)
{

#if DBG

    if (iSvc >= XMS_LASTSVC){
	printf("XMS:Unimplemented SVC index %x\n",iSvc);
	setCF(1);
	return FALSE;
    }

#endif

    (apfnXMSSvc [iSvc])();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsa20.c ===
/* xmsa20.c - A20 related XMS routines
 *
 * XMSA20
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"

#include <xmssvc.h>
#include <softpc.h>

void sas_enable_20_bit_wrapping(void);
void sas_disable_20_bit_wrapping(void);
BOOL sas_twenty_bit_wrapping_enabled(void);

BYTE * pHimemA20State = NULL;


/* xmsA20 - Handle A20 requests
 *
 *
 * Entry - Client (AX) 0 - Disable A20
 *		       1 - Enable A20
 *		       2 - Query
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *	     if on entry AX=2 Then
 *		Client (AX) =1 means was enabled
 *		Client (AX) =0 means was disabled
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsA20 (VOID)
{
    int reason;

    reason = getAX();

    setAX(1);

    if (reason == 0)
	xmsEnableA20Wrapping();
    else if (reason == 1)
	    xmsDisableA20Wrapping();
	 else if (reason == 2) {
		if (sas_twenty_bit_wrapping_enabled())
		    setAX(0);
		setBL(0);
	      }
	      else
		setAX(0);
}
// function to enable 1MB wrapping (turn off A20 line)
VOID xmsEnableA20Wrapping(VOID)
{
    sas_enable_20_bit_wrapping();
    if (pHimemA20State != NULL)
	*pHimemA20State = 0;

#if 0 // this is not necessay because the intel space(pointed by
      // HimemA20State) doesn't contain instruction
      // doesn't contain instruction
#ifdef MIPS
	Sim32FlushVDMPointer
	 (
	  (((ULONG)pHimemA20State >> 4) << 16) | ((ULONG)pHimemA20State & 0xF),
	  1,
	  pHimemA20State,
	  FALSE
	 );

#endif
#endif

}

// function to disable 1MB wrapping(turn on A20 line)
VOID xmsDisableA20Wrapping(VOID)
{

    sas_disable_20_bit_wrapping();
    if (pHimemA20State != NULL)
	*pHimemA20State = 1;
#if 0 // this is not necessay because the intel space(pointed by
      // HimemA20State) doesn't contain instruction
      // doesn't contain instruction
#ifdef MIPS
	Sim32FlushVDMPointer
	 (
	  (((ULONG)pHimemA20State >> 4) << 16) | ((ULONG)pHimemA20State & 0xF),
	  1,
	  pHimemA20State,
	  FALSE
	 );

#endif
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\i386\callpr32.asm ===
title "x86-only Helper routine for generic thunk interface CallProc32[Ex]W"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    callpr32.asm
;
; Abstract:
;
;    WK32ICallProc32MakeCall is a helper routine for wkgthunk.c's
;    WK32ICallProc32, the common thunk for CallProc32W and
;    CallProc32ExW, the two generic thunk routines which allow
;    16-bit code to call any 32-bit function.
;
; Author:
;
;    Dave Hart (davehart) 23-Jan-96
;--
.386p

include callconv.inc

if DBG
DEBUG   equ 1
endif

ifdef DEBUG
DEBUG_OR_WOWPROFILE equ 1
endif
ifdef WOWPROFILE
DEBUG_OR_WOWPROFILE equ 1
endif

;include wow.inc

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;        EXTRNP _DispatchInterrupts,0

_TEXT   ENDS


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;        extrn _aw32WOW:Dword

_DATA   ENDS




_TEXT   SEGMENT

        page    ,132
        subttl "WK32ICallProc32MakeCall"
;++
;
;   Routine Description:
;
;    WK32ICallProc32MakeCall is a helper routine for wkgthunk.c's
;    WK32ICallProc32, the common thunk for CallProc32W and
;    CallProc32ExW, the two generic thunk routines which allow
;    16-bit code to call any 32-bit function.
;
;    Like Win95's implementation, this code allows the called
;    routine to fail to restore esp (for example, if we are
;    told the routine is STDCALL but it's really CDECL).
;    A number of Works 95's Wizards don't work otherwise.
;
;   Arguments:
;
;       pfn        procedure to call
;       cArgs      count of DWORDs
;       pArgs      Argument array
;
;   Returns:
;
;       return value of called routine.
;

        assume DS:_DATA,ES:Nothing,SS:_DATA
ALIGN 16
cPublicProc _WK32ICallProc32MakeCall,3
.FPO (0,3,2,2,0,0)                ; 3 params, 2 byte prolog, 2 saved registers

        push    edi
        push    esi

pfn     equ     [esp+0ch]
cbArgs  equ     [esp+10h]
pArgs   equ     [esp+14h]

        mov     ecx,cbArgs
        mov     edx,pfn
        mov     edi,esp                ; Save ESP if no args
        or      ecx,ecx
        mov     eax,ecx
        jz      DoneArgs
        shr     ecx,2                  ; convert bytes to dwords

        mov     esi,pArgs
        sub     esp,eax                ; parm macros are invalid
        cld                            ; "push" the arguments
        mov     edi,esp
        rep movsd
                                       ; edi is left at correct post-call ESP
DoneArgs:

        call    edx
        mov     esp,edi

        pop     esi
        pop     edi
        stdRET  _WK32ICallProc32MakeCall

stdENDP _WK32ICallProc32MakeCall


_TEXT   ends

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsblock.c ===
/* xmsblock.c - XMS Extended block related routines
 *
 * xmsAllocBlock
 * xmsFreeBlock
 * xmsReallocBlock
 * xmsMoveBlock
 * xmsQueryExtMem
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"
#include <memory.h>
#include <string.h>
#include <xmssvc.h>
#include <softpc.h>
#include <mvdm.h>


/* xmsAllocBlock - Commit Memory for an EMB.
 *
 *
 * Entry - DX    - Size in K to allocate 
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) - Start address of the EMB (in K)
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsAllocBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG size;

    size = getDX() * 1024;
    if(size) {

        //
        // Ask for a chunk of memory
        //
        Success = SAAllocate(
            ExtMemSA,
            size,
            &BaseAddress
            );
            
        if (!Success) {
            DbgPrint("xmsAllocBlock:SAAlloc failed !!!!\n");
            setAX(0);
            return;
        }
    }
    else
	BaseAddress = 0;

    ASSERT((USHORT)(BaseAddress / 1024) < 65535);
    setAX((USHORT)(BaseAddress / 1024));
    return;
}

/* xmsFreeBlock - Free Memory for an EMB.
 *
 *
 * Entry - AX	 - Start address of the EMB (in K)
 *	   DX	 - Size in K to free 
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsFreeBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG size;

    BaseAddress = (getAX() * 1024);
    size = getDX() * 1024;

    Success = SAFree(
        ExtMemSA,
        size,
        BaseAddress
        );
        
    if (!Success) {
        DbgPrint("xmsFreeBlock:SAFree failed !!!!");
        setAX(0);
        return;
    }

    setAX(1);
    return;
}

/* xmsReallocBlock - Change the size of an EMB.
 *
 *
 * Entry - AX       - Start address of the EMB (in K)
 *	   DX       - Original Size in K
 *         BX       - New size in K
 *
 * Exit
 *	   SUCCESS
 *	     Client (CX) = New base of block
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsReallocBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG NewAddress;
ULONG size;
ULONG NewSize;

    size = getDX() * 1024;
    NewSize = getBX() * 1024;
    BaseAddress = getAX() * 1024;
    if(size != NewSize) {

        //
        // Realloc the chunk of memory
        //
        Success = SAReallocate(
            ExtMemSA,
            size,
            BaseAddress,
            NewSize,
            &NewAddress
            );
            
        if (!Success) {
            DbgPrint("xmsReallocBlock:SARealloc failed !!!!\n");
            setCX(0);
            return;
        }
    }
    else
    {
	NewAddress = BaseAddress;
    }

    ASSERT((NewAddress / 1024) < 65535);
    setCX((USHORT)(NewAddress / 1024));
    return;
}

/* xmsMoveBlock - Process Move Block Functions
 *
 *
 * Entry - Client (SS:BP) Pointer to Ext. Memory Move Structure
 *	    SS:BP-4	= DWORD Transfer Count in words (guaranteed even)
 *	    SS:BP-8	= DWORD Src Linear Address
 *	    SS:BP-12	= DWORD Dst Linear Address
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *
 *	   FAILURE
 *	     Client (AX) = 0
 *	     Client (BL) = error code
 *
 *  NOTE: For Overlapping regions XMS spec says "If the Source and
 *	  Destination blocks overlap, only forward moves (i.e. where
 *	  the destination base is less than the source base) are
 *	  guaranteed to work properly"
 */

VOID xmsMoveBlock (VOID)
{
PBYTE	pExtMoveInfo,pSrc,pDst;
ULONG	cbTransfer,SoftpcBase, DstSegOff;

    pExtMoveInfo = (PBYTE) GetVDMAddr(getSS(),getBP());
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    cbTransfer = (FETCHDWORD(*(PULONG)pExtMoveInfo));
    cbTransfer *= 2;					// Get in bytes
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    (DWORD)pSrc = FETCHDWORD(*(PULONG)pExtMoveInfo);
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    (DWORD)pDst = FETCHDWORD(*(PULONG)pExtMoveInfo);

    // Yes, we could use memmov for handling the overlapping regions
    // but XMS spec wants memcpy behaviour.

#ifdef i386
    RtlCopyMemory (pDst,pSrc,cbTransfer);
#else
    SoftpcBase = (ULONG) GetVDMAddr (0,0);
    RtlCopyMemory((PVOID)((ULONG)pDst + SoftpcBase),
	   (PVOID)((ULONG)pSrc + SoftpcBase),
	   cbTransfer);
    // if we touched the intel memory, tell the emulator to flush its cache
    // WARNING!!!! Do not use Sim32FlushVDMPoiner unless you know the exact segment
    // address. In this case, we have no idea what the segment value is, all we
    // know is its "linear address".
    // BUGBUG verify whether we can ignore the case with pDst > 0x110000
    sas_overwrite_memory(pDst, cbTransfer);

#endif
    setAX(1);
    return;
}

/* xmsQueryExtMem - Process query extended memory
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Largest Free Block in K
 *	     Client (DX) = Free Memory in K
 *
 *	   FAILURE
 *	     Client (AX) = 0
 *	     Client (DX) = 0
 *
 */
VOID xmsQueryFreeExtMem(VOID)
{
    ULONG LargestFree = 0;
    ULONG TotalFree = 0;
    
    //
    // Find out how much memory remains
    //
    SAQueryFree(
        ExtMemSA,
        &TotalFree,
        &LargestFree
        );
        
    ASSERT((TotalFree / 1024) < 65534);
    setAX((USHORT)(TotalFree / 1024));
    ASSERT((LargestFree / 1024) < 65534);
    setDX((USHORT)(LargestFree / 1024));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsmisc.c ===
/* xmsmisc.c - Misc. Support Functions for himem.
 *
 * xmsSysPageSize
 * xmsQueryExtMem
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"

#include <xmssvc.h>
#include <softpc.h>

extern void UpdateKbdInt15(WORD Seg,WORD Off);

/* xmsSysPageSize - Get the System Page size.
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Page Size in bytes
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsSysPageSize (VOID)
{
SYSTEM_INFO SysInfo;

    GetSystemInfo(&SysInfo);

    setAX((USHORT)SysInfo.dwPageSize);

    return;
}



/* xmsQueryExtMem - Get the extended memory for the vdm
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Extended Memory in K
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsQueryExtMem (VOID)
{
    setAX((USHORT)(xmsMemorySize));
    return;
}


/* xmsNotifyHookI15 - Informs softpc that someone is hooking I15
 *            - also returns the extended memory for the vdm
 *
 *
 * Entry -   Client (CS:AX) seg:off of new I15 vector
 *
 * Exit
 *         SUCCESS
 *           Client (CX) = Extended Memory in K
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsNotifyHookI15 (VOID)
{
    UpdateKbdInt15(getCS(), getAX());

    setCX((USHORT)(xmsMemorySize));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsmemr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmsmemr.c

Abstract:

    This module conains the memory commit/decommit/move routines
    for risc.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <xms.h>
#include <suballoc.h>
#include <softpc.h>

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using sas_manage_xms.

Arguments:

    BaseAddress -- Supplies the base address to commit memory at
    Size -- Supplies the size of the block to commit
    
Return Value:

    0 if successfull

--*/
{
    BOOL Status;
    
    //
    // Perform the allocation
    //
    Status = sas_manage_xms( 
        (PVOID)BaseAddress,
        Size,
        1
        );

    //
    // We elected to have 0 indicate success, because that allows
    // us to directly pass back NTSTATUS codes.  On x86 we use
    // NT memory management to do the commit for us, and the returned
    // status code contains more information than just success or failure
    //
    
    if (Status) {
        return STATUS_SUCCESS;
    } else {
        return -1;
    }
}

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using sas_manage_xms.

Arguments:

    BaseAddress -- Supplies the base address to decommit memory at
    Size -- Supplies the size of the block to decommit
    
Return Value:

    0 if successful

--*/
{
    BOOL Status;
    
    //
    // Perform the allocation
    //
    Status = sas_manage_xms(
        (PVOID)BaseAddress,
        Size,
        2
        );
        
    //
    // We elected to have 0 indicate success, because that allows
    // us to directly pass back NTSTATUS codes.  On x86 we use
    // NT memory management to do the commit for us, and the returned
    // status code contains more information than just success or failure
    //
    if (Status) {
        return STATUS_SUCCESS;
    } else {
        return -1;
    }
}

VOID
xmsMoveMemory(
    ULONG Destination,
    ULONG Source,
    ULONG Count
    )
/*++

Routine Description:

    This routine moves a block of memory, and notifies the emulator.
    It correctly handles overlapping source and destination

Arguments:

    Destination -- Supplies a pointer to the destination Intel (NOT Linear)
        Address
    Source -- Supplies a pointer to the source Intel Address
    Count -- Supplies the number of bytes to move
    
Return Value:

    None.

--*/
{
    ULONG SoftpcBase;
    
    //
    // Get the linear address of the beginning of Intel memory
    //
    SoftpcBase = (ULONG) GetVDMAddr(0,0);
    
    //
    // Move the memory
    //
    RtlMoveMemory(
        (PVOID)((ULONG)Destination + SoftpcBase),
        (PVOID)((ULONG)Source + SoftpcBase),
        Count
        );

    // WARNING!!!! Donot use Sim32FlushVDMPoiner unless you know the exact segment
    // address. In this case, we have no idea what the segment value is, all we
    // know is its "linear address".

    sas_overwrite_memory((PBYTE)Destination, Count);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\avrfp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    avrfp.h

Abstract:

    Internal application verifier header.

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/

#ifndef _AVRFP_
#define _AVRFP_

//
// Application verifier interfaces used in other parts 
// of the loader.
//

VOID
AVrfInitializeVerifier (
    BOOLEAN EnabledSystemWide,
    PCUNICODE_STRING ImageName,
    ULONG Phase
    );

NTSTATUS
AVrfDllLoadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

VOID
AVrfDllUnloadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

NTSTATUS
AVrfPageHeapDllNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

#endif // _AVRFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\i386\xmsmem86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmscmt86.c

Abstract:

    This module conains the memory commit/decommit routines
    for x86.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <xms.h>
#include <suballoc.h>

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using NtAllocateVirtualMemory.

Arguments:

    BaseAddress -- Supplies the base address to commit memory at
    Size -- Supplies the size of the block to commit
    
Return Value:

    Same as NtAllocateVirtualMemory.

--*/
{
    PVOID Address;
    ULONG s;
    NTSTATUS Status;
    
    //
    // Copy the parameters locally, so that MM doesn't 
    // change them for us
    //
    Address = (PVOID)BaseAddress;
    s = Size;
    
    //
    // Perform the allocation
    //
    Status = NtAllocateVirtualMemory( 
        NtCurrentProcess(),
        &Address,
        0L,
        &s,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    return Status;
}

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using NtAllocateVirtualMemory.

Arguments:

    BaseAddress -- Supplies the base address to decommit memory at
    Size -- Supplies the size of the block to decommit
    
Return Value:

    Same as NtFreeVirtualMemory.

--*/
{
    PVOID Address;
    ULONG s;
    NTSTATUS Status;
    
    //
    // Copy the parameters locally, so that MM doesn't 
    // change them for us
    //
    Address = (PVOID)BaseAddress;
    s = Size;
    
    //
    // Perform the allocation
    //
    Status = NtFreeVirtualMemory( NtCurrentProcess(),
        &Address,
        &s,
        MEM_DECOMMIT
        );

    return Status;
}

VOID
xmsMoveMemory(
    ULONG Destination,
    ULONG Source,
    ULONG Count
    )
/*++

Routine Description:

    This routine moves a block of memory, and notifies the emulator.
    It correctly handles overlapping source and destination

Arguments:

    Destination -- Supplies a pointer to the destination Linear
        Address
    Source -- Supplies a pointer to the source Linear Address
    Count -- Supplies the number of bytes to move
    
Return Value:

    None.

--*/
{
   
    //
    // Move the memory
    //
    RtlMoveMemory(
        (PVOID)Destination,
        (PVOID)Source,
        Count
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\buffer.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    The module implements a buffer in the style popularized by
    Michael J. Grier (MGrier), where some amount (like MAX_PATH)
    of storage is preallocated (like on the stack) and if the storage
    needs grow beyond the preallocated size, the heap is used.

Author:

    Jay Krell (a-JayK) June 2000

Environment:

    User Mode or Kernel Mode (but don't preallocate much on the stack in kernel mode)

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <limits.h>

NTSTATUS
NTAPI
RtlpEnsureBufferSize (
    IN ULONG    Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
/*++

Routine Description:

    This function ensures Buffer can hold Size bytes, or returns
    an error. It either bumps Buffer->Size closer to Buffer->StaticSize,
    or heap allocates.

Arguments:

    Buffer - a Buffer object, see also RtlInitBuffer.

    Size - the number of bytes the caller wishes to store in Buffer->Buffer.


Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY

--*/
{
    PUCHAR Temp;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }
    if (Buffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Size <= Buffer->Size) {
        return STATUS_SUCCESS;
    }
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        return STATUS_SUCCESS;
    }
    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateStringRoutine(Size);
    if (Temp == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeStringRoutine(Buffer->Buffer);
        Buffer->Buffer = NULL;
    }
    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;

    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
RtlMultiAppendUnicodeStringBuffer (
    OUT PRTL_UNICODE_STRING_BUFFER Destination,
    IN  ULONG                      NumberOfSources,
    IN  const UNICODE_STRING*      SourceArray
    )
/*++

Routine Description:


Arguments:

    Destination -
    NumberOfSources -
    SourceArray -

Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY
     STATUS_NAME_TOO_LONG

--*/
{
    SIZE_T Length;
    ULONG i;
    NTSTATUS Status;
    const SIZE_T CharSize = sizeof(*Destination->String.Buffer);
    const ULONG OriginalDestinationLength = Destination->String.Length;

    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        Length += SourceArray[i].Length;
        if (Length > MAX_UNICODE_STRING_MAXLENGTH) {
            return STATUS_NAME_TOO_LONG;
        }
    }
    Length += CharSize;
    if (Length > MAX_UNICODE_STRING_MAXLENGTH) {
        return STATUS_NAME_TOO_LONG;
    }

    Status = RtlEnsureBufferSize(0, &Destination->ByteBuffer, Length);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Destination->String.MaximumLength = (USHORT)Length;
    Destination->String.Length = (USHORT)(Length - CharSize);
    Destination->String.Buffer = (PWSTR)Destination->ByteBuffer.Buffer;
    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        RtlMoveMemory(
            Destination->String.Buffer + Length / CharSize,
            SourceArray[i].Buffer,
            SourceArray[i].Length);
        Length += SourceArray[i].Length;
    }
    Destination->String.Buffer[Length / CharSize] = 0;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\csrdll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrdll.h

Abstract:

    Main include file for Client side of the Client Server Runtime (CSR)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

//
// Include definitions common between the Client and Server portions.
//

#include "csr.h"

//
// Include definitions specific to the Client portion.
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

#if DBG
#define CSR_DEBUG_INIT              0x00000001
#define CSR_DEBUG_LPC               0x00000002
#define CSR_DEBUG_FLAG3             0x00000004
#define CSR_DEBUG_FLAG4             0x00000008
#define CSR_DEBUG_FLAG5             0x00000010
#define CSR_DEBUG_FLAG6             0x00000020
#define CSR_DEBUG_FLAG7             0x00000040
#define CSR_DEBUG_FLAG8             0x00000080
#define CSR_DEBUG_FLAG9             0x00000100
#define CSR_DEBUG_FLAG10            0x00000200
#define CSR_DEBUG_FLAG11            0x00000400
#define CSR_DEBUG_FLAG12            0x00000800
#define CSR_DEBUG_FLAG13            0x00001000
#define CSR_DEBUG_FLAG14            0x00002000
#define CSR_DEBUG_FLAG15            0x00004000
#define CSR_DEBUG_FLAG16            0x00008000
#define CSR_DEBUG_FLAG17            0x00010000
#define CSR_DEBUG_FLAG18            0x00020000
#define CSR_DEBUG_FLAG19            0x00040000
#define CSR_DEBUG_FLAG20            0x00080000
#define CSR_DEBUG_FLAG21            0x00100000
#define CSR_DEBUG_FLAG22            0x00200000
#define CSR_DEBUG_FLAG23            0x00400000
#define CSR_DEBUG_FLAG24            0x00800000
#define CSR_DEBUG_FLAG25            0x01000000
#define CSR_DEBUG_FLAG26            0x02000000
#define CSR_DEBUG_FLAG27            0x04000000
#define CSR_DEBUG_FLAG28            0x08000000
#define CSR_DEBUG_FLAG29            0x10000000
#define CSR_DEBUG_FLAG30            0x20000000
#define CSR_DEBUG_FLAG31            0x40000000
#define CSR_DEBUG_FLAG32            0x80000000

ULONG CsrDebug;
#define IF_CSR_DEBUG( ComponentFlag ) \
    if (CsrDebug & (CSR_DEBUG_ ## ComponentFlag))

#else
#define IF_CSR_DEBUG( ComponentFlag ) if (FALSE)
#endif

//
// Common Types and Definitions
//

//
// CSR_HEAP_MEMORY_SIZE defines how much address space should be
// reserved for the Client heap.  This heap is used to store all
// data structures maintained by the Client DLL.
//

#define CSR_HEAP_MEMORY_SIZE (64*1024)


//
// CSR_PORT_MEMORY_SIZE defines how much address space should be
// reserved for passing data to the Server.  The memory is visible
// to both the client and server processes.
//

#define CSR_PORT_MEMORY_SIZE 0x10000

//
// Global data accessed by Client DLL
//

BOOLEAN CsrInitOnceDone;

//
// This boolean is TRUE if the dll is attached to a server process.
//

BOOLEAN CsrServerProcess;

//
// This points to the server routine that dispatches APIs, if the dll is
// being called by a server process.
//

NTSTATUS (*CsrServerApiRoutine)(PCSR_API_MSG,PCSR_API_MSG);

//
// The CsrNtSysInfo global variable contains NT specific constants of
// interest, such as page size, allocation granularity, etc.  It is filled
// in once during process initialization.
//

SYSTEM_BASIC_INFORMATION CsrNtSysInfo;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + CsrNtSysInfo.PageSize - 1) & ~(CsrNtSysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(CsrNtSysInfo.PageSize - 1))

//
// The CsrDebugFlag is non-zero if the Client Application was
// invoked with the Debug option.
//

ULONG CsrDebugFlag;

//
// The CsrHeap global variable describes a single heap used by the Client
// DLL for process wide storage management.  Process private data maintained
// by the Client DLL is allocated out of this heap.
//

PVOID CsrHeap;


//
// The connection to the Server is described by the CsrPortHandle global
// variable.  The connection is established when the CsrConnectToServer
// function is called.
//

UNICODE_STRING CsrPortName;
HANDLE CsrPortHandle;
HANDLE CsrProcessId;

//
// In order to pass large arguments to the Server (e.g. path name
// arguments) the CsrPortHeap global variable describes a heap that
// is visible to both the Windows Client process and the Server
// process.
//

PVOID CsrPortHeap;
ULONG_PTR CsrPortMemoryRemoteDelta;

ULONG CsrPortBaseTag;

#define MAKE_CSRPORT_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrPortBaseTag, t ))

#define CAPTURE_TAG 0

//
// The CsrDllHandle global variable contains the DLL handle for the WINDLL
// client stubs executable.
//

HANDLE CsrDllHandle;


//
// Routines defined in dllinit.c
//

BOOLEAN
CsrDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    );

NTSTATUS
CsrpConnectToServer(
    IN PWSTR ObjectDirectory
    );


//
// Routines defined in dllutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\csrinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contains the initialization code for the Client-Server (CS)
    Client DLL.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode only

Revision History:

--*/

#include "ldrp.h"
#include "csrdll.h"

BOOLEAN
ProtectHandle (
    HANDLE hObject
    );

BOOLEAN
UnProtectHandle (
    HANDLE hObject
    );


BOOLEAN
CsrDllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function is the DLL initialization routine for the Client DLL
    This function gets control when the application links to this DLL
    are snapped.

Arguments:

    Context - Supplies an optional context buffer that will be restored
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

Return Value:

    Status value.

--*/

{
    UNREFERENCED_PARAMETER (Context);

    if (Reason == DLL_PROCESS_ATTACH) {

        //
        // Remember our DLL handle in a global variable.
        //

        CsrDllHandle = DllHandle;
    }

    return TRUE;
}


NTSTATUS
CsrOneTimeInitialize (
    VOID
    )
{
    NTSTATUS Status;

    //
    // Save away system information in a global variable.
    //

    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &CsrNtSysInfo,
                                       sizeof (CsrNtSysInfo),
                                       NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Use the process heap for memory allocations.
    //

    CsrHeap = RtlProcessHeap ();

    CsrInitOnceDone = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
CsrClientConnectToServer (
    IN PWSTR ObjectDirectory,
    IN ULONG ServerDllIndex,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    )

/*++

Routine Description:

    This function is called by the client side DLL to connect with its
    server side DLL.

Arguments:

    ObjectDirectory - Points to a null terminated string that is the same
        as the value of the ObjectDirectory= argument passed to the CSRSS
        program.

    ServerDllIndex - Index of the server DLL that is being connected to.
        It should match one of the ServerDll= arguments passed to the CSRSS
        program.

    ConnectionInformation - An optional pointer to uninterpreted data.
        This data is intended for clients to pass package, version and
        protocol identification information to the server to allow the
        server to determine if it can satisfy the client before
        accepting the connection.  Upon return to the client, the
        ConnectionInformation data block contains any information passed
        back from the server DLL by its call to the
        CsrCompleteConnection call.  The output data overwrites the
        input data.

    ConnectionInformationLength - Pointer to the length of the
        ConnectionInformation data block.  The output value is the
        length of the data stored in the ConnectionInformation data
        block by the server's call to the NtCompleteConnectPort
        service.  This parameter is OPTIONAL only if the
        ConnectionInformation parameter is NULL, otherwise it is
        required.

    CalledFromServer - On output, TRUE if the dll has been called from
        a server process.

Return Value:

    Status value.

--*/

{
    NTSTATUS Status;
    CSR_API_MSG m;
    PCSR_CLIENTCONNECT_MSG a = &m.u.ClientConnect;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    HANDLE CsrServerModuleHandle;
    STRING ProcedureName;
    UNICODE_STRING DllName_U;
    PIMAGE_NT_HEADERS NtHeaders;

    if ((ARGUMENT_PRESENT (ConnectionInformation)) &&
        (!ARGUMENT_PRESENT (ConnectionInformationLength) ||
          *ConnectionInformationLength == 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!CsrInitOnceDone) {
        Status = CsrOneTimeInitialize();
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    //
    // If we are being called by a server process, skip LPC port initialization
    // and call to server connect routine and just initialize the heap.  The
    // dll initialization routine will do any necessary initialization.  This
    // stuff only needs to be done for the first connect.
    //

    if (CsrServerProcess == TRUE) {
        if (ARGUMENT_PRESENT (CalledFromServer)) {
            *CalledFromServer = CsrServerProcess;
        }
        return STATUS_SUCCESS;
    }

    //
    // If the image is an NT native image, we are running in the
    // context of the server.
    //

    NtHeaders = RtlImageNtHeader (NtCurrentPeb()->ImageBaseAddress);

    if (!NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    CsrServerProcess =
        (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE) ? TRUE : FALSE;

    if (CsrServerProcess) {

        extern PVOID NtDllBase;

        DllName_U.Buffer = L"csrsrv";
        DllName_U.Length = sizeof (L"csrsrv") - sizeof (WCHAR);
        DllName_U.MaximumLength = sizeof(L"csrsrv");

        Status = LdrDisableThreadCalloutsForDll (NtDllBase);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        Status = LdrGetDllHandle (NULL,
                                  NULL,
                                  &DllName_U,
                                  (PVOID *)&CsrServerModuleHandle);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        RtlInitString (&ProcedureName,"CsrCallServerFromServer");

        Status = LdrGetProcedureAddress (CsrServerModuleHandle,
                                         &ProcedureName,
                                         0L,
                                         (PVOID *)&CsrServerApiRoutine);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        ASSERT (NT_SUCCESS(Status));

        ASSERT (CsrPortHeap == NULL);

        CsrPortHeap = RtlProcessHeap();

        CsrPortBaseTag = RtlCreateTagHeap (CsrPortHeap,
                                           0,
                                           L"CSRPORT!",
                                           L"CAPTURE\0");

        if (ARGUMENT_PRESENT(CalledFromServer)) {
            *CalledFromServer = CsrServerProcess;
        }

        return STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT(ConnectionInformation)) {

        if (CsrPortHandle == NULL) {

            Status = CsrpConnectToServer (ObjectDirectory);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }

        Status = STATUS_SUCCESS;

        //
        // For basesrv this is one big noop.
        //
        if (ServerDllIndex != BASESRV_SERVERDLL_INDEX) {

            a->ServerDllIndex = ServerDllIndex;
            a->ConnectionInformationLength = *ConnectionInformationLength;

            CaptureBuffer = CsrAllocateCaptureBuffer (1,
                                                      a->ConnectionInformationLength);

            if (CaptureBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }

            CsrAllocateMessagePointer (CaptureBuffer,
                                       a->ConnectionInformationLength,
                                       (PVOID *)&a->ConnectionInformation);

            RtlCopyMemory (a->ConnectionInformation,
                           ConnectionInformation,
                           a->ConnectionInformationLength);

            *ConnectionInformationLength = a->ConnectionInformationLength;

            Status = CsrClientCallServer (&m,
                                          CaptureBuffer,
                                          CSR_MAKE_API_NUMBER (CSRSRV_SERVERDLL_INDEX,
                                                               CsrpClientConnect),
                                          sizeof (*a));

            if (CaptureBuffer != NULL) {

                RtlCopyMemory (ConnectionInformation,
                               a->ConnectionInformation,
                               *ConnectionInformationLength);

                CsrFreeCaptureBuffer (CaptureBuffer);
            }
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT(CalledFromServer)) {
        *CalledFromServer = CsrServerProcess;
    }

    return Status;
}


NTSTATUS
CsrpConnectToServer (
    IN PWSTR ObjectDirectory
    )
{
    NTSTATUS Status;
    REMOTE_PORT_VIEW ServerView;
    ULONG MaxMessageLength;
    ULONG ConnectionInformationLength;
    CSR_API_CONNECTINFO ConnectionInformation;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    HANDLE PortSection;
    PORT_VIEW ClientView;
    SIZE_T n;
    LARGE_INTEGER SectionSize;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID SystemSid;
    PPEB Peb;
    SIZE_T Odl;
    PWCHAR p;
    
    //
    // Create the port name string by combining the passed in object directory
    // name with the port name.
    //

    Odl = wcslen (ObjectDirectory);
    n = ((Odl + 1) * sizeof (WCHAR)) +
        sizeof (CSR_API_PORT_NAME) - sizeof (WCHAR);

    if (n > MAXUSHORT) {
        return STATUS_NAME_TOO_LONG;
    }

    CsrPortName.Buffer = p = RtlAllocateHeap (CsrHeap, MAKE_TAG (CSR_TAG), n);

    if (CsrPortName.Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlCopyMemory (p, ObjectDirectory, Odl * sizeof (WCHAR));
    p += Odl;
    *p++ = L'\\';
    RtlCopyMemory (p, CSR_API_PORT_NAME, sizeof (CSR_API_PORT_NAME) - sizeof (WCHAR));

    CsrPortName.Length = (USHORT) n;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // Create a section to contain the Port Memory.  Port Memory is private
    // memory that is shared between the client and server processes.
    // This allows data that is too large to fit into an API request message
    // to be passed to the server.
    //

    SectionSize.LowPart = CSR_PORT_MEMORY_SIZE;
    SectionSize.HighPart = 0;

    Status = NtCreateSection (&PortSection,
                              SECTION_ALL_ACCESS,
                              NULL,
                              &SectionSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Connect to the server.  This includes a description of the Port Memory
    // section so that the LPC connection logic can make the section visible
    // to both the client and server processes.  Also pass information the
    // server needs in the connection information structure.
    //

    ClientView.Length = sizeof (ClientView);
    ClientView.SectionHandle = PortSection;
    ClientView.SectionOffset = 0;
    ClientView.ViewSize = SectionSize.LowPart;
    ClientView.ViewBase = 0;
    ClientView.ViewRemoteBase = 0;

    ServerView.Length = sizeof (ServerView);
    ServerView.ViewSize = 0;
    ServerView.ViewBase = 0;

    ConnectionInformationLength = sizeof (ConnectionInformation);

    SystemSid = NULL;

    Status = RtlAllocateAndInitializeSid (&NtAuthority,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          &SystemSid);

    if (!NT_SUCCESS (Status)) {
        NtClose (PortSection);
        return Status;
    }

#if DBG
    ConnectionInformation.DebugFlags = 0;
#endif

    Status = NtSecureConnectPort (&CsrPortHandle,
                                  &CsrPortName,
                                  &DynamicQos,
                                  &ClientView,
                                  SystemSid,
                                  &ServerView,
                                  (PULONG)&MaxMessageLength,
                                  (PVOID)&ConnectionInformation,
                                  (PULONG)&ConnectionInformationLength);

    RtlFreeSid (SystemSid);

    NtClose (PortSection);

    if (!NT_SUCCESS (Status)) {

        IF_DEBUG {
            DbgPrint ("CSRDLL: Unable to connect to %wZ Server - Status == %X\n",
                      &CsrPortName,
                      Status);
        }

        return Status;
    }

#if DBG
    ProtectHandle (CsrPortHandle);
#endif

    Peb = NtCurrentPeb();

    Peb->ReadOnlySharedMemoryBase = ConnectionInformation.SharedSectionBase;
    Peb->ReadOnlySharedMemoryHeap = ConnectionInformation.SharedSectionHeap;
    Peb->ReadOnlyStaticServerData = (PVOID *)ConnectionInformation.SharedStaticServerData;
    CsrProcessId = ConnectionInformation.ServerProcessId;

#if DBG
    CsrDebug = ConnectionInformation.DebugFlags;
#endif

    CsrPortMemoryRemoteDelta = (ULONG_PTR)ClientView.ViewRemoteBase -
                               (ULONG_PTR)ClientView.ViewBase;

    IF_CSR_DEBUG( LPC ) {
        DbgPrint ("CSRDLL: ClientView: Base=%p  RemoteBase=%p  Delta: %lX  Size=%lX\n",
                  ClientView.ViewBase,
                  ClientView.ViewRemoteBase,
                  CsrPortMemoryRemoteDelta,
                  (ULONG)ClientView.ViewSize);
    }

    //
    // Create a sparse heap in the shared memory section.  Initially
    // commit just one page.
    //

    CsrPortHeap = RtlCreateHeap (HEAP_CLASS_8,               // Flags
                                 ClientView.ViewBase,        // HeapBase
                                 ClientView.ViewSize,        // ReserveSize
                                 CsrNtSysInfo.PageSize,      // CommitSize
                                 0,                          // Reserved
                                 0);                         // GrowthThreshold

    if (CsrPortHeap == NULL) {

#if DBG
        UnProtectHandle (CsrPortHandle);
#endif

        NtClose (CsrPortHandle);
        CsrPortHandle = NULL;

        return STATUS_NO_MEMORY;
    }

    CsrPortBaseTag = RtlCreateTagHeap (CsrPortHeap,
                                       0,
                                       L"CSRPORT!",
                                       L"!CSRPORT\0"
                                       L"CAPTURE\0");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\xms.486\xmsumb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    XNSUMB.C

Abstract:

    Routines to service XMS Request UMB and Release UMB functions.
    Also includes UMB initialization routine

Author:

    William Hsieh (williamh) Created 23-Sept-1992

[Environment:]

    User mode, running in the MVDM context (bop from 16bits)

[Notes:]



Revision History:

--*/
#include    <xms.h>
#include    "umb.h"
#include    "softpc.h"



// This global variable points to the first node(lowest address) UMB list
static PXMSUMB	xmsUMBHead;
static BOOL xmsIsON = FALSE;
// ------------------------------------------------------------------
// Initialization for UMB support. It create a single direction linked
// list and allocate all available UMBs.
// Input: client (AX:BX) = segment:offset of himem.sys A20State variable
//
// Output: list header, xmsUMBHead set.
//-------------------------------------------------------------------
VOID  xmsInitUMB(VOID)
{
    PVOID   Address;
    ULONG   Size;
    PXMSUMB xmsUMB, xmsUMBNew;
    xmsUMBHead = NULL;
    while (ReserveUMB(UMB_OWNER_XMS, &Address, &Size) &&
	   (xmsUMBNew = (PXMSUMB) malloc(sizeof(XMSUMB))) != NULL) {
	    // convert size in bytes to paragraphs
	    xmsUMBNew->Size = (WORD) (Size >> 4);
	    // convert linear address to paragraphs segment
	    xmsUMBNew->Segment = (WORD)((DWORD)Address >> 4);
	    xmsUMBNew->Owner = 0;
	    if (xmsUMBHead == NULL) {
		xmsUMBHead = xmsUMBNew;
		xmsUMBHead->Next = NULL;
	    }
	    else {
		xmsUMBNew->Next = xmsUMB->Next;
		xmsUMB->Next = xmsUMBNew;
	    }
	    xmsUMB = xmsUMBNew;
    }
    xmsIsON = TRUE;
    pHimemA20State = (PBYTE) GetVDMAddr(getAX(), getBX());
    xmsEnableA20Wrapping();



}

// This function receives control whenever there has been an UMB released
// Input: PVOID Address = the block address
//	  ULONG Size = the block size
VOID xmsReleaseUMBNotify(
PVOID	Address,
DWORD	Size
)
{
    // If the block is good and xms driver is ON,
    // grab the block and insert it into our xms UMB list
    if (Address != NULL && Size > 0  && xmsIsON &&
	ReserveUMB(UMB_OWNER_XMS, &Address, &Size)){
	xmsInsertUMB(Address, Size);
    }

}
// ------------------------------------------------------------------
// Insert a given UMB into the list
// Input: PVOID Address = linear address of the block to be inserted
//	  ULONG Size = size in byte of the block
// Output: TRUE if the block was inserted to the list successfully
//	   FALSE if the block wasn't inserted
//-------------------------------------------------------------------

VOID xmsInsertUMB(
PVOID	Address,
ULONG	Size
)
{
    PXMSUMB xmsUMB, xmsUMBNew;
    WORD    Segment;

    Segment = (WORD) ((DWORD)Address >> 4);
    Size >>= 4;

    xmsUMB = xmsUMBNew = xmsUMBHead;
    while (xmsUMBNew != NULL && xmsUMBNew->Segment < Segment) {
	xmsUMB = xmsUMBNew;
	xmsUMBNew = xmsUMBNew->Next;
    }
    // merge it with previous block if possible
    if (xmsUMB != NULL &&
	xmsUMB->Owner == 0 &&
	Segment == xmsUMB->Segment + xmsUMB->Size) {

        xmsUMB->Size += (WORD) Size;
	return;
    }
    // merge it with the after block if possible
    if (xmsUMBNew != NULL &&
	xmsUMBNew->Owner == 0 &&
	xmsUMBNew->Segment == Segment + Size) {

        xmsUMBNew->Size += (WORD) Size;
	xmsUMBNew->Segment = Segment;
	return;
    }
    // create a new node for the block
    if ((xmsUMBNew = (PXMSUMB)malloc(sizeof(XMSUMB))) != NULL) {
        xmsUMBNew->Size = (WORD) Size;
	xmsUMBNew->Segment = Segment;
	xmsUMBNew->Owner = 0;
	if (xmsUMBHead == NULL) {
	    xmsUMBHead = xmsUMBNew;
	    xmsUMBNew->Next = NULL;
	}
	else {
	    xmsUMBNew->Next = xmsUMB->Next;
	    xmsUMB->Next = xmsUMBNew;
	}
    }
}
// ------------------------------------------------------------------
// XMS function 16, Request UMB.
// Input: (DX) = requested size in paragraphs
// Output: (AX) = 1 if succeed and
//		    (BX) has segment address(number) of the block
//		    (DX) has actual allocated size in paragraphs
//	   (AX) = 0 if failed and
//		    (BL) = 0xB0, (DX) = largest size available
//		    or
//		    (BL) = 0xB1 if no UMBs are available
//-------------------------------------------------------------------
VOID xmsRequestUMB(VOID)
{
    PXMSUMB xmsUMB, xmsUMBNew;
    WORD    SizeRequested, SizeLargest;

    xmsUMB = xmsUMBHead;
    SizeRequested = getDX();
    SizeLargest = 0;
    while (xmsUMB != NULL) {
	if (xmsUMB->Owner == 0) {
	    if (xmsUMB->Size >= SizeRequested) {
		if((xmsUMB->Size - SizeRequested) >= XMSUMB_THRESHOLD &&
		   (xmsUMBNew = (PXMSUMB) malloc(sizeof(XMSUMB))) != NULL) {

		    xmsUMBNew->Segment = xmsUMB->Segment + SizeRequested;
		    xmsUMBNew->Size = xmsUMB->Size - SizeRequested;
		    xmsUMBNew->Next = xmsUMB->Next;
		    xmsUMB->Next = xmsUMBNew;
		    xmsUMBNew->Owner = 0;
		    xmsUMB->Size -= xmsUMBNew->Size;
		}
		xmsUMB->Owner = 0xFFFF;
		setAX(1);
		setBX(xmsUMB->Segment);
		setDX(xmsUMB->Size);
		return;
	    }
	    else {
		if (xmsUMB->Size > SizeLargest)
		    SizeLargest = xmsUMB->Size;
	    }
	}
	xmsUMB = xmsUMB->Next;
    }
    setAX(0);
    setDX(SizeLargest);
    if (SizeLargest > 0)
	setBL(0xB0);
    else
	setBL(0xB1);
}


//------------------------------------------------------------------
// XMS function 17, Release UMB.
// Input : (DX) = segment to be released
// Output: (AX) = 1 if succeed
//	   (AX) = 0 if failed and
//		    (BL) = 0xB2 if segment not found in the list
//------------------------------------------------------------------
VOID xmsReleaseUMB(VOID)
{
    PXMSUMB xmsUMB, xmsUMBNext;
    WORD    Segment;

    xmsUMB = xmsUMBHead;
    Segment = getDX();
    while (xmsUMB != NULL && xmsUMB->Segment != Segment) {
	xmsUMB = xmsUMB->Next;
    }
    if (xmsUMB != NULL && xmsUMB->Owner != 0) {
	xmsUMB->Owner = 0;
	// no walk through the entire list to combine consecutive
	// blocks together
	xmsUMB = xmsUMBHead;
	while (xmsUMB != NULL) {
	    while (xmsUMB->Owner == 0 &&
		   (xmsUMBNext = xmsUMB->Next) != NULL &&
		   xmsUMBNext->Owner == 0 &&
		   (WORD)(xmsUMB->Segment + xmsUMB->Size) == xmsUMBNext->Segment){
		xmsUMB->Size += xmsUMBNext->Size;
		xmsUMB->Next = xmsUMBNext->Next;
		free(xmsUMBNext);
	    }
	    xmsUMB = xmsUMB->Next;
	}
	setAX(1);
    }
    else {
	setBL(0xB2);
	setAX(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\csrtask.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dlltask.c

Abstract:

    This module implements Csr DLL tasking routines

Author:

    Mark Lucovsky (markl) 13-Nov-1990

Revision History:

--*/

#pragma warning(disable:4201)   // nameless struct/union

#include "csrdll.h"


NTSTATUS
CsrNewThread (
    VOID
    )

/*++

Routine Description:

    This function is called by each new thread (except the first thread in
    a process). Its function is to call the subsystem to notify it that
    a new thread is starting.

Arguments:

    None.

Return Value:

    Status Code from either client or server

--*/

{
    return NtRegisterThreadTerminatePort (CsrPortHandle);
}


NTSTATUS
CsrIdentifyAlertableThread (
    VOID
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
CsrSetPriorityClass (
    IN HANDLE ProcessHandle,
    IN OUT PULONG PriorityClass
    )
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER( ProcessHandle );
    UNREFERENCED_PARAMETER( PriorityClass );

    Status = STATUS_INVALID_PARAMETER;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\dbgdllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgdllp.h

Abstract:

    Debug Subsystem Dll Private Types and Prototypes

Author:

    Mark Lucovsky (markl) 22-Jan-1990

Revision History:

--*/

#ifndef _DBGDLLP_
#define _DBGDLLP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsm.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>



//
// DbgSs Private Dll Prototypes and variables
//

HANDLE DbgSspApiPort;
HANDLE DbgSspKmReplyPort;
PDBGSS_UI_LOOKUP DbgSspUiLookUpRoutine;
PDBGSS_SUBSYSTEMKEY_LOOKUP DbgSspSubsystemKeyLookupRoutine;
PDBGSS_DBGKM_APIMSG_FILTER DbgSspKmApiMsgFilter;

typedef struct _DBGSS_CONTINUE_KEY {
    DBGKM_APIMSG KmApiMsg;
    HANDLE ReplyEvent;
} DBGSS_CONTINUE_KEY, *PDBGSS_CONTINUE_KEY;


NTSTATUS
DbgSspConnectToDbg( VOID );

NTSTATUS
DbgSspSrvApiLoop(
    IN PVOID ThreadParameter
    );

NTSTATUS
DbgSspCreateProcess (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PCLIENT_ID DebugUiClientId,
    IN PDBGKM_CREATE_PROCESS NewProcess
    );

NTSTATUS
DbgSspCreateThread (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_CREATE_THREAD NewThread
    );

NTSTATUS
DbgSspExitThread (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXIT_THREAD ExitThread
    );

NTSTATUS
DbgSspExitProcess (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXIT_PROCESS ExitProcess
    );

NTSTATUS
DbgSspException (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXCEPTION Exception
    );

NTSTATUS
DbgSspLoadDll (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_LOAD_DLL LoadDll
    );

NTSTATUS
DbgSspUnloadDll (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_UNLOAD_DLL UnloadDll
    );

#endif // _DBGDLLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\curdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    Current directory support

Author:

    Mark Lucovsky (markl) 10-Oct-1990

Revision History:

--*/

#pragma warning(disable:4201)   // nameless struct/union

#include "nt.h"
#include "ntos.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"
#include "ctype.h"
#include "sxstypes.h"
#include "ntdllp.h"
#include "ntcsrmsg.h"
#include "base.h"

#if defined(_WIN64) || defined(BUILD_WOW6432)
#include <wow64t.h>
#endif // defined(_WIN64)

#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))
#define IS_END_OF_COMPONENT_U(ch) (IS_PATH_SEPARATOR_U(ch) || (ch) == UNICODE_NULL)
#define IS_DOT_U(s) ( (s)[0] == L'.' && IS_END_OF_COMPONENT_U( (s)[1] ))
#define IS_DOT_DOT_U(s) ( (s)[0] == L'.' && IS_DOT_U( (s) + 1))
#define IS_DRIVE_LETTER(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))

#define IS_END_OF_COMPONENT_USTR(s, len) \
                ((len) == 0 || IS_PATH_SEPARATOR_U((s)[0]))

#define IS_DOT_USTR(s, len) \
                ((len) >= sizeof(WCHAR) && (s)[0] == L'.' && \
                IS_END_OF_COMPONENT_USTR( (s) + 1, (len) - sizeof(WCHAR) ))

#define IS_DOT_DOT_USTR(s, len) \
                ((len) >= sizeof(WCHAR) && (s)[0] == L'.' && \
                IS_DOT_USTR( (s) + 1, (len) - sizeof(WCHAR) ))

extern const UNICODE_STRING RtlpDosLPTDevice = RTL_CONSTANT_STRING( L"LPT" );
extern const UNICODE_STRING RtlpDosCOMDevice = RTL_CONSTANT_STRING( L"COM" );
extern const UNICODE_STRING RtlpDosPRNDevice = RTL_CONSTANT_STRING( L"PRN" );
extern const UNICODE_STRING RtlpDosAUXDevice = RTL_CONSTANT_STRING( L"AUX" );
extern const UNICODE_STRING RtlpDosNULDevice = RTL_CONSTANT_STRING( L"NUL" );
extern const UNICODE_STRING RtlpDosCONDevice = RTL_CONSTANT_STRING( L"CON" );

extern const UNICODE_STRING RtlpDosSlashCONDevice   = RTL_CONSTANT_STRING( L"\\\\.\\CON" );
extern const UNICODE_STRING RtlpSlashSlashDot       = RTL_CONSTANT_STRING( L"\\\\.\\" );
extern const UNICODE_STRING RtlpDosDevicesPrefix    = RTL_CONSTANT_STRING( L"\\??\\" );
extern const UNICODE_STRING RtlpDosDevicesUncPrefix = RTL_CONSTANT_STRING( L"\\??\\UNC\\" );

#define RtlpLongestPrefix   RtlpDosDevicesUncPrefix.Length

const UNICODE_STRING RtlpEmptyString = RTL_CONSTANT_STRING(L"");

//
// \\? is referred to as the "Win32Nt" prefix or root.
// Paths that start with \\? are referred to as "Win32Nt" paths.
// Fudging the \\? to \?? converts the path to an Nt path.
//
extern const UNICODE_STRING RtlpWin32NtRoot         = RTL_CONSTANT_STRING( L"\\\\?" );
extern const UNICODE_STRING RtlpWin32NtRootSlash    = RTL_CONSTANT_STRING( L"\\\\?\\" );
extern const UNICODE_STRING RtlpWin32NtUncRoot      = RTL_CONSTANT_STRING( L"\\\\?\\UNC" );
extern const UNICODE_STRING RtlpWin32NtUncRootSlash = RTL_CONSTANT_STRING( L"\\\\?\\UNC\\" );

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

typedef struct _RTLP_CURDIR_REF {
    LONG RefCount;
    HANDLE DirectoryHandle;
} RTLP_CURDIR_REF;

PRTLP_CURDIR_REF RtlpCurDirRef = NULL; // N.B. Protected by the PEB lock

FORCEINLINE
VOID
RtlpInitializeCurDirRef(
    OUT PRTLP_CURDIR_REF CurDirRef,
    IN HANDLE DirectoryHandle
    )
{
    ASSERT(CurDirRef);

    CurDirRef->RefCount = 1;
    CurDirRef->DirectoryHandle = DirectoryHandle;
}

FORCEINLINE
VOID
RtlpReferenceCurDirRef(
    IN PRTLP_CURDIR_REF CurDirRef
    )
{
    ASSERT(CurDirRef);

    if (CurDirRef) {
        InterlockedIncrement(&CurDirRef->RefCount);
    }
}

FORCEINLINE
VOID
RtlpDereferenceCurDirRef(
    IN PRTLP_CURDIR_REF CurDirRef
    )
{
    ASSERT(CurDirRef);

    if (CurDirRef && ! InterlockedDecrement(&CurDirRef->RefCount)) {
        RTL_VERIFY(
            NT_SUCCESS(
                NtClose(CurDirRef->DirectoryHandle)
                ));
        RtlFreeHeap(RtlProcessHeap(), 0, CurDirRef);
    }
}

ULONG
RtlpComputeBackupIndex(
    IN PCURDIR CurDir
    )
{
    ULONG BackupIndex;
    PWSTR UncPathPointer;
    ULONG NumberOfPathSeparators;
    RTL_PATH_TYPE CurDirPathType;


    //
    // Get pathType of curdir
    //

    CurDirPathType = RtlDetermineDosPathNameType_U(CurDir->DosPath.Buffer);
    BackupIndex = 3;
    if ( CurDirPathType == RtlPathTypeUncAbsolute ) {

        //
        // We want to scan the supplied path to determine where
        // the "share" ends, and set BackupIndex to that point.
        //

        UncPathPointer = CurDir->DosPath.Buffer + 2;
        NumberOfPathSeparators = 0;

        while (*UncPathPointer) {
            if (IS_PATH_SEPARATOR_U(*UncPathPointer)) {

                NumberOfPathSeparators++;

                if (NumberOfPathSeparators == 2) {
                    break;
                    }
                }

            UncPathPointer++;

            }

        BackupIndex = (ULONG)(UncPathPointer - CurDir->DosPath.Buffer);
        }
    return BackupIndex;
}


ULONG
RtlGetLongestNtPathLength( VOID )

/*++

Routine Description:

    Returns the character count of the longest NT path directly translated from
    a DOS path

Arguments:

    None

Return Value:

    the character count  (NOT byte count)

--*/

{
    //
    // return the char count
    //
    return (RtlpLongestPrefix/sizeof(WCHAR)) + DOS_MAX_PATH_LENGTH + 1;
}


VOID
RtlpResetDriveEnvironment(
    IN WCHAR DriveLetter
    )
{
    WCHAR EnvVarNameBuffer[4];
    WCHAR EnvVarNameValue[4];
    UNICODE_STRING s1,s2;

    EnvVarNameBuffer[0] = L'=';
    EnvVarNameBuffer[1] = DriveLetter;
    EnvVarNameBuffer[2] = L':';
    EnvVarNameBuffer[3] = L'\0';
    RtlInitUnicodeString(&s1,EnvVarNameBuffer);

    EnvVarNameValue[0] = DriveLetter;
    EnvVarNameValue[1] = L':';
    EnvVarNameValue[2] = L'\\';
    EnvVarNameValue[3] = L'\0';
    RtlInitUnicodeString(&s2,EnvVarNameValue);

    RtlSetEnvironmentVariable(NULL,&s1,&s2);
}


ULONG
RtlGetCurrentDirectory_U(
    ULONG nBufferLength,
    PWSTR lpBuffer
    )

/*++

Routine Description:

    The current directory for a process can be retrieved using
    GetCurrentDirectory.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is to
        receive the current directory string.

    lpBuffer - Returns the current directory string for the current
        process.  The string is a null terminated string and specifies
        the absolute path to the current directory.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    PCURDIR CurDir;
    ULONG Length;
    PWSTR  CurDirName;

    CurDir = &NtCurrentPeb()->ProcessParameters->CurrentDirectory;

    RtlAcquirePebLock();
    CurDirName = CurDir->DosPath.Buffer;

    //
    // Make sure user's buffer is big enough to hold the null
    // terminated current directory
    //

    Length = CurDir->DosPath.Length>>1;

    //
    // Assuming CurDir->DosPath.Buffer always has a trailing slash
    // if the root of a drive,
    // then return x:\
    // else return x:\directory\subdir
    //

    ASSERT( (CurDirName != NULL) && (Length > 0) );

    if ((Length > 1) && (CurDirName[Length-2] != L':')) {
        if (nBufferLength < (Length)<<1) {
            RtlReleasePebLock();
            return (Length)<<1;
        }
    } else {
        if (nBufferLength <= (Length<<1)) {
            RtlReleasePebLock();
            return ((Length+1)<<1);
        }
    }

    try {
        RtlCopyMemory (lpBuffer,CurDirName,Length<<1);
        ASSERT(lpBuffer[Length-1] == L'\\');

        if ((Length > 1) && (lpBuffer[Length-2] == L':')) {
            //
            // root of a drive, append a null
            //
            lpBuffer[Length] = UNICODE_NULL;
        } else {
            //
            // some directory, change the trailing slash to a null
            //
            lpBuffer[Length-1] = UNICODE_NULL;
            Length--;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        RtlReleasePebLock();
        return 0L;
    }
    RtlReleasePebLock();
    return Length<<1;
}


NTSTATUS
RtlSetCurrentDirectory_U(
    PCUNICODE_STRING PathName
    )

/*++

Routine Description:

    The current directory for a process is changed using
    SetCurrentDirectory.

    Each process has a single current directory.  A current directory is
    made up of type parts.

        - A disk designator either which is either a drive letter followed
          by a colon, or a UNC servername/sharename "\\servername\sharename".

        - A directory on the disk designator.

    For APIs that manipulate files, the file names may be relative to
    the current directory.  A filename is relative to the entire current
    directory if it does not begin with a disk designator or a path name
    SEPARATOR.  If the file name begins with a path name SEPARATOR, then
    it is relative to the disk designator of the current directory.  If
    a file name begins with a disk designator, than it is a fully
    qualified absolute path name.

    The value of lpPathName supplies the current directory.  The value
    of lpPathName, may be a relative path name as described above, or a
    fully qualified absolute path name.  In either case, the fully
    qualified absolute path name of the specified directory is
    calculated and is stored as the current directory.

Arguments:

    lpPathName - Supplies the pathname of the directory that is to be
        made the current directory.

Return Value:

    NT_SUCCESS - The operation was successful

    !NT_SUCCESS - The operation failed

--*/

{
    PCURDIR CurDir;
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    ULONG DosDirLength;
    ULONG IsDevice;
    ULONG DosDirCharCount;
    UNICODE_STRING DosDir;
    UNICODE_STRING NtFileName;
    HANDLE NewDirectoryHandle;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    RTL_PATH_TYPE InputPathType;
    PPEB Peb;
    HANDLE HandleToClose, HandleToClose1;
    PRTLP_CURDIR_REF CurDirRefToDereference;
    HANDLE Heap;

    Peb = NtCurrentPeb();
    Heap = Peb->ProcessHeap;
    CurDir = &Peb->ProcessParameters->CurrentDirectory;


    DosDir.Buffer = NULL;
    FreeBuffer = NULL;
    NewDirectoryHandle = NULL;
    HandleToClose = NULL;
    HandleToClose1 = NULL;
    CurDirRefToDereference = NULL;

    IsDevice = RtlIsDosDeviceName_Ustr(PathName);

    RtlAcquirePebLock();

    Peb->EnvironmentUpdateCount += 1;

    //
    // Set current directory is called first by the loader.
    // If current directory is not being inherited, then close
    // it !
    //

    if (((ULONG_PTR)CurDir->Handle & OBJ_HANDLE_TAGBITS) == RTL_USER_PROC_CURDIR_CLOSE) {
        HandleToClose = CurDir->Handle;
        CurDir->Handle = NULL;
    }

    Status =  STATUS_SUCCESS;
    try {
        try {

            if ( IsDevice ) {
                Status = STATUS_NOT_A_DIRECTORY;
                leave;
            }

            //
            // Compute the length of the Dos style fully qualified current
            // directory
            //

            DosDirLength = CurDir->DosPath.MaximumLength;
            DosDir.Buffer = RtlAllocateHeap (Heap, 0, DosDirLength);
            if ( !DosDir.Buffer ) {
                Status = STATUS_NO_MEMORY;
                leave;
            }

            DosDir.Length = 0;
            DosDir.MaximumLength = (USHORT)DosDirLength;


            //
            // Now get the full pathname for the Dos style current
            // directory
            //


            DosDirLength = RtlGetFullPathName_Ustr(
                                PathName,
                                DosDirLength,
                                DosDir.Buffer,
                                NULL,
                                NULL,
                                &InputPathType
                                );
            if ( !DosDirLength ) {
                Status = STATUS_OBJECT_NAME_INVALID;
                leave;
            }

            if ( DosDirLength > DosDir.MaximumLength ) {
                Status = STATUS_NAME_TOO_LONG;
                leave;
            }

            DosDirCharCount = DosDirLength >> 1;


            //
            // Get the Nt filename of the new current directory
            //
            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                    DosDir.Buffer,
                                    &NtFileName,
                                    NULL,
                                    NULL
                                    );

            if ( !TranslationStatus ) {
                Status = STATUS_OBJECT_NAME_INVALID;
                leave;
            }
            FreeBuffer = NtFileName.Buffer;

            InitializeObjectAttributes(
                &Obja,
                &NtFileName,
                OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
                NULL,
                NULL
                );

            //
            // If we are inheriting current directory, then
            // avoid the open
            //

            if ( ((ULONG_PTR)CurDir->Handle & OBJ_HANDLE_TAGBITS) ==  RTL_USER_PROC_CURDIR_INHERIT ) {
                NewDirectoryHandle = (HANDLE)((ULONG_PTR)CurDir->Handle & ~OBJ_HANDLE_TAGBITS);
                CurDir->Handle = NULL;

                //
                // Test to see if this is removable media. If so
                // tag the handle this may fail if the process was
                // created with inherit handles set to false
                //

                Status = NtQueryVolumeInformationFile(
                            NewDirectoryHandle,
                            &IoStatusBlock,
                            &DeviceInfo,
                            sizeof(DeviceInfo),
                            FileFsDeviceInformation
                            );
                if ( !NT_SUCCESS(Status) ) {
                    Status = RtlSetCurrentDirectory_U(PathName);
                    leave;
                } else {
                    if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                        NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
                    }
                }

            } else {
                //
                // Open a handle to the current directory. Don't allow
                // deletes of the directory.
                //

                Status = NtOpenFile(
                            &NewDirectoryHandle,
                            FILE_TRAVERSE | SYNCHRONIZE,
                            &Obja,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                            );

                if ( !NT_SUCCESS(Status) ) {
                    leave;
                }

                //
                // Test to see if this is removable media. If so
                // tag the handle
                //
                Status = NtQueryVolumeInformationFile(
                            NewDirectoryHandle,
                            &IoStatusBlock,
                            &DeviceInfo,
                            sizeof(DeviceInfo),
                            FileFsDeviceInformation
                            );
                if ( !NT_SUCCESS(Status) ) {
                    leave;
                } else {
                    if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                        NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
                    }
                }
            }

            //
            // If there is no trailing '\', than place one
            //

            DosDir.Length = (USHORT)DosDirLength;
            if ( DosDir.Buffer[DosDirCharCount-1] != L'\\') {

                if ( (DosDirCharCount + 2) >
                     (DosDir.MaximumLength / sizeof( WCHAR )) ) {
                    Status = STATUS_NAME_TOO_LONG;
                    leave;
                }
                DosDir.Buffer[DosDirCharCount] = L'\\';
                DosDir.Buffer[DosDirCharCount+1] = UNICODE_NULL;
                DosDir.Length += sizeof( UNICODE_NULL );
            }

            //
            // Now we are set to change to the new directory.
            //

            if (RtlpCurDirRef
                && RtlpCurDirRef->RefCount == 1) {

                HandleToClose1 = RtlpCurDirRef->DirectoryHandle;
                RtlpCurDirRef->DirectoryHandle = NewDirectoryHandle;

            } else {

                CurDirRefToDereference = RtlpCurDirRef;

                RtlpCurDirRef = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(RTLP_CURDIR_REF));
                if (! RtlpCurDirRef) {
                    RtlpCurDirRef = CurDirRefToDereference;
                    CurDirRefToDereference = NULL;
                    Status = STATUS_NO_MEMORY;
                    leave;
                }

                RtlpInitializeCurDirRef(RtlpCurDirRef, NewDirectoryHandle);
            }

            CurDir->Handle = NewDirectoryHandle;
            NewDirectoryHandle = NULL;

            RtlCopyMemory (CurDir->DosPath.Buffer, DosDir.Buffer, DosDir.Length + sizeof (UNICODE_NULL));
            CurDir->DosPath.Length = DosDir.Length;

        } finally {

            RtlReleasePebLock();

            if (DosDir.Buffer != NULL) {
                RtlFreeHeap (Heap, 0, DosDir.Buffer);
            }

            if (FreeBuffer != NULL) {
                RtlFreeHeap (Heap, 0, FreeBuffer);
            }

            if (NewDirectoryHandle != NULL) {
                NtClose (NewDirectoryHandle);
            }

            if (HandleToClose != NULL) {
                NtClose (HandleToClose);
            }

            if (HandleToClose1 != NULL) {
                NtClose (HandleToClose1);
            }

            if (CurDirRefToDereference != NULL) {
                RtlpDereferenceCurDirRef(CurDirRefToDereference);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_ACCESS_VIOLATION;
    }
    return Status;
}


RTL_PATH_TYPE
RtlDetermineDosPathNameType_U(
    IN PCWSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    ASSERT(DosFileName != NULL);

    if (IS_PATH_SEPARATOR_U(*DosFileName)) {
        if ( IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( DosFileName[2] == '.' || DosFileName[2] == '?') {
                if ( IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                else if ( (*(DosFileName+3)) == UNICODE_NULL ){
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            ReturnValue = RtlPathTypeRooted;
            }
        }
    else if ((*DosFileName) && (*(DosFileName+1)==L':')) {
        if (IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        ReturnValue = RtlPathTypeRelative;
        }

    return ReturnValue;
}


RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    const PCWSTR DosFileName = String->Buffer;

#define ENOUGH_CHARS(_cch) (String->Length >= ((_cch) * sizeof(WCHAR)))

    if ( ENOUGH_CHARS(1) && IS_PATH_SEPARATOR_U(*DosFileName) ) {
        if ( ENOUGH_CHARS(2) && IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( ENOUGH_CHARS(3) && (DosFileName[2] == '.' ||
                                     DosFileName[2] == '?') ) {

                if ( ENOUGH_CHARS(4) && IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    // "\\.\" or "\\?\"
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                else if ( String->Length == (3 * sizeof(WCHAR)) ){
                    // "\\." or \\?"
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    // "\\.x" or "\\?x"
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                // "\\x"
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            // "\x"
            ReturnValue = RtlPathTypeRooted;
            }
        }
    //
    // the "*DosFileName" is left over from the PCWSTR version
    // Win32 and DOS don't allow embedded nuls and much code limits
    // drive letters to strictly 7bit a-zA-Z so it's ok.
    //
    else if (ENOUGH_CHARS(2) && *DosFileName && *(DosFileName+1)==L':') {
        if (ENOUGH_CHARS(3) && IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            // "x:\"
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            // "c:x"
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        // "x", first char is not a slash / second char is not colon
        ReturnValue = RtlPathTypeRelative;
        }
    return ReturnValue;

#undef ENOUGH_CHARS
}


NTSTATUS
NTAPI
RtlpDetermineDosPathNameType4(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE PathType = 0;
    BOOLEAN Win32Nt = FALSE;
    BOOLEAN Win32NtUncAbsolute = FALSE;
    BOOLEAN Win32NtDriveAbsolute = FALSE;
    BOOLEAN IncompleteRoot = FALSE;
    RTL_PATH_TYPE PathTypeAfterWin32Nt = 0;

    if (OutType != NULL
        ) {
        *OutType = RtlPathTypeUnknown;
    }
    if (OutFlags != NULL
        ) {
        *OutFlags = 0;
    }
    if (
           !RTL_SOFT_VERIFY(DosPath != NULL)
        || !RTL_SOFT_VERIFY(OutType != NULL)
        || !RTL_SOFT_VERIFY(OutFlags != NULL)
        || !RTL_SOFT_VERIFY(
                (InFlags & ~(RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD | RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT))
                == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    PathType = RtlDetermineDosPathNameType_Ustr(DosPath);
    *OutType = PathType;
    if (InFlags & RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD)
        goto Exit;

    if (DosPath->Length == sizeof(L"\\\\") - sizeof(DosPath->Buffer[0])
        ) {
        IncompleteRoot = TRUE;
    }
    else if (RtlEqualUnicodeString(&RtlpWin32NtRoot, DosPath, TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlEqualUnicodeString(&RtlpWin32NtRootSlash, DosPath, TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlPrefixUnicodeString(&RtlpWin32NtRootSlash, DosPath, TRUE)
        ) {
        Win32Nt = TRUE;
    }

    if (Win32Nt) {
        if (RtlEqualUnicodeString(&RtlpWin32NtUncRoot, DosPath, TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlEqualUnicodeString(&RtlpWin32NtUncRootSlash, DosPath, TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlPrefixUnicodeString(&RtlpWin32NtUncRootSlash, DosPath, TRUE)
            ) {
            Win32NtUncAbsolute = TRUE;
        }
        if (Win32NtUncAbsolute
            ) {
            Win32NtDriveAbsolute = FALSE;
        } else if (!IncompleteRoot) {
            const RTL_STRING_LENGTH_TYPE i = RtlpWin32NtRootSlash.Length;
            UNICODE_STRING PathAfterWin32Nt = *DosPath;

            PathAfterWin32Nt.Buffer +=  i / sizeof(PathAfterWin32Nt.Buffer[0]);
            PathAfterWin32Nt.Length = PathAfterWin32Nt.Length - i;
            PathAfterWin32Nt.MaximumLength = PathAfterWin32Nt.MaximumLength - i;

            PathTypeAfterWin32Nt = RtlDetermineDosPathNameType_Ustr(&PathAfterWin32Nt);
            if (PathTypeAfterWin32Nt == RtlPathTypeDriveAbsolute) {
                Win32NtDriveAbsolute = TRUE;
            }
            else {
                Win32NtDriveAbsolute = FALSE;
            }

            if (InFlags & RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT
                ) {
                if (!RTL_SOFT_VERIFY(Win32NtDriveAbsolute
                    )) {
                    *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID;
                    // we still succeed the function call
                }
            }
        }
    }

    ASSERT(RTLP_IMPLIES(Win32NtDriveAbsolute, Win32Nt));
    ASSERT(RTLP_IMPLIES(Win32NtUncAbsolute, Win32Nt));
    ASSERT(!(Win32NtUncAbsolute && Win32NtDriveAbsolute));

    if (IncompleteRoot)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INCOMPLETE_ROOT;
    if (Win32Nt)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT;
    if (Win32NtUncAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_ABSOLUTE;
    if (Win32NtDriveAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


ULONG
RtlIsDosDeviceName_Ustr(
    IN PCUNICODE_STRING DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines if it
    is a Dos device name (e.g. LPT1, etc.).  Valid Dos device names are:

        LPTn
        COMn
        PRN
        AUX
        NUL
        CON

    when n is a digit.  Trailing colon is ignored if present.

Arguments:

    DosFileName - Supplies the Dos format file name that is to be examined.

Return Value:

    0 - Specified Dos file name is not the name of a Dos device.

    > 0 - Specified Dos file name is the name of a Dos device and the
          return value is a ULONG where the high order 16 bits is the
          offset in the input buffer where the dos device name beings
          and the low order 16 bits is the length of the device name
          the length of the name (excluding any optional
          trailing colon).

--*/

{
    UNICODE_STRING UnicodeString;
    USHORT NumberOfCharacters, OriginalLength;
    ULONG ReturnLength;
    ULONG ReturnOffset;
    LPWSTR p;
    USHORT ColonBias;
    RTL_PATH_TYPE PathType;
    WCHAR wch;

    ColonBias = 0;

    //
    // NOTICE-2002/03/18-ELi
    // DosFileName->Buffer might not be a null-terminated string
    // RtlSetCurrentDirectory_U can called this function with such a string
    //
    PathType = RtlDetermineDosPathNameType_Ustr(DosFileName);

    switch ( PathType ) {

    case RtlPathTypeLocalDevice:
        //
        // For Unc Absolute, Check for \\.\CON
        // since this really is not a device
        //

        if ( RtlEqualUnicodeString(DosFileName,&RtlpDosSlashCONDevice,TRUE) ) {
            return 0x00080006;
        }

        //
        // FALLTHRU
        //

    case RtlPathTypeUncAbsolute:
    case RtlPathTypeUnknown:
        return 0;
    }

    UnicodeString = *DosFileName;
    OriginalLength = UnicodeString.Length;
    NumberOfCharacters = OriginalLength >> 1;

    if (NumberOfCharacters && UnicodeString.Buffer[NumberOfCharacters-1] == L':') {
        UnicodeString.Length -= sizeof(WCHAR);
        NumberOfCharacters--;
        ColonBias = 1;
    }

    //
    // The above strip the trailing colon logic could have left us with 0
    // for NumberOfCharacters, so that needs to be tested
    //

    if ( NumberOfCharacters == 0 ) {
        return 0;
        }

    wch = UnicodeString.Buffer[NumberOfCharacters-1];
    while ( NumberOfCharacters && (wch == L'.' || wch == L' ') ) {
        UnicodeString.Length -= sizeof(WCHAR);
        NumberOfCharacters--;
        ColonBias++;

        if ( NumberOfCharacters > 0 ) {
            wch = UnicodeString.Buffer[NumberOfCharacters-1];
        }
    }

    ReturnLength = NumberOfCharacters << 1;

    //
    //  Walk backwards through the string finding the
    //  first slash or the beginning of the string.  We also stop
    //  at the drive: if it is present.
    //

    ReturnOffset = 0;
    if ( NumberOfCharacters ) {
        p = UnicodeString.Buffer + NumberOfCharacters-1;
        while ( p >= UnicodeString.Buffer ) {
            if ( *p == L'\\' || *p == L'/'
                 || (*p == L':' && p == UnicodeString.Buffer + 1)) {
                p++;

                //
                // NOTICE-2002/02/12-ELi
                // if p points to the end of the string, then cannot access p++
                // because string may not be NULL-terminated
                // if at the end of the string, don't have any more chars in
                // the name to check so just return 0
                //
                if ( p >= (UnicodeString.Buffer +
                          (OriginalLength / sizeof(WCHAR)))) {
                    return 0;
                }

                //
                //  Get the first char of the file name and convert it to
                //  lower case.  This will be safe since we will be comparing
                //  it to only lower-case ASCII.
                //

                wch = (*p) | 0x20;

                //
                //  check to see if we possibly have a hit on
                //  lpt, prn, con, com, aux, or nul
                //

                if ( !(wch == L'l' || wch == L'c' || wch == L'p' || wch == L'a'
                       || wch == L'n')
                     ) {
                    return 0;
                    }
                ReturnOffset = (ULONG)((PSZ)p - (PSZ)UnicodeString.Buffer);

                //
                // NOTICE-2002/03/18-ELi
                // assuming that at this point
                // UnicodeString.Buffer < p < (UnicodeString.Buffer +
                //     OriginalLength / sizeof(WCHAR))
                // Therefore the USHORT cast and subtractions are ok
                //
                UnicodeString.Length = OriginalLength - (USHORT)((PCHAR)p -
                    (PCHAR)UnicodeString.Buffer);
                UnicodeString.Buffer =  p;

                NumberOfCharacters = UnicodeString.Length >> 1;
                NumberOfCharacters = NumberOfCharacters - ColonBias;
                ReturnLength = NumberOfCharacters << 1;
                UnicodeString.Length -= ColonBias*sizeof(WCHAR);
                break;
                }
            p--;
            }

        wch = UnicodeString.Buffer[0] | 0x20;

        //
        // check to see if we possibly have a hit on
        // lpt, prn, con, com, aux, or nul
        //

        if ( !( wch == L'l' || wch == L'c' || wch == L'p' || wch == L'a'
                || wch == L'n' ) ) {
            return 0;
            }
        }

    //
    //  Now we need to see if we are dealing with a device name that has
    //  an extension or a stream name. If so, we need to limit the search to the
    //  file portion only
    //

    p = UnicodeString.Buffer;
    while (p < UnicodeString.Buffer + NumberOfCharacters && *p != L'.' && *p != L':') {
        p++;
    }

    //
    //  p either points past end of string or to a dot or :.  We back up over
    //  trailing spaces
    //

    while (p > UnicodeString.Buffer && p[-1] == L' ') {
        p--;
    }

    //
    //  p either points to the beginning of the string or p[-1] is
    //  the first non-space char found above.
    //

    NumberOfCharacters = (USHORT)(p - UnicodeString.Buffer);
    UnicodeString.Length = NumberOfCharacters * sizeof( WCHAR );

    if ( NumberOfCharacters == 4 && iswdigit(UnicodeString.Buffer[3] ) ) {
        if ( (WCHAR)UnicodeString.Buffer[3] == L'0') {
            return 0;
        } else {
            UnicodeString.Length -= sizeof(WCHAR);
            if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosLPTDevice,TRUE) ||
                 RtlEqualUnicodeString(&UnicodeString,&RtlpDosCOMDevice,TRUE) ) {
                ReturnLength = NumberOfCharacters << 1;
            } else {
                return 0;
            }
        }
    } else if ( NumberOfCharacters != 3 ) {
        return 0;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosPRNDevice,TRUE) ) {
            ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosAUXDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosNULDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosCONDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else {
        return 0;
    }

    return ReturnLength | (ReturnOffset << 16);
}


ULONG
RtlIsDosDeviceName_U(
    IN PCWSTR DosFileName
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    Status = RtlInitUnicodeStringEx(&UnicodeString,DosFileName);

    if( !NT_SUCCESS( Status ) ) {
        return 0;
    }

    return RtlIsDosDeviceName_Ustr(&UnicodeString);
}


NTSTATUS
RtlpCheckDeviceName(
    PCUNICODE_STRING DevName,
    ULONG DeviceNameOffset,
    BOOLEAN* NameInvalid
    )
{
    PWSTR DevPath;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Heap;

    DevPath = RtlAllocateHeap(Heap = RtlProcessHeap(), 0,DevName->Length);
    if (!DevPath) {
        *NameInvalid = FALSE;
        Status = STATUS_NO_MEMORY;
        goto Exit;
        }

    *NameInvalid = TRUE;
    try {

        RtlCopyMemory(DevPath,DevName->Buffer,DevName->Length);

        //
        // NOTICE-2002/02/12-ELi
        // assuming that DeviceNameOffset <= (DevName->Length - 6) because
        // this function is called only if DevName is a DosDevice name, which
        // should be at least 3 chars long
        //
        DevPath[DeviceNameOffset>>1]=L'.';
        DevPath[(DeviceNameOffset>>1)+1]=UNICODE_NULL;

        if (RtlDoesFileExists_U(DevPath) ) {
            *NameInvalid = FALSE;
            }
        else {
            *NameInvalid = TRUE;
            }

        }
    finally {
        RtlFreeHeap(Heap, 0, DevPath);
        }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


//
//  We keep an open handle to the current directory on the current drive in order
//  to make relative opens faster.
//
//  However, this current directory can become invalid under two circumstances:
//
//  1. The current drive is removable media.  The user may arbitrarily switch
//      media without our knowledge.  At this point, whatever information the
//      filesystem has about the media is now out of date.
//  2. The volume is dismounted by explicit system/user action.
//
//  We can ping (via FSCTL_IS_VOLUME_MOUNTED) the volume each time we want to
//  test to see if the current directory is still valid.  While a "cheap" call
//  we will end up doing it a lot.  We can reduce this frequency by only checking
//  when the media is known to be removable or when a dismount is known to have
//  occurred.  The Io system exports in USER_SHARED_DATA a count of dismounts
//  since boot.  We capture this and use it to decide if a dismount was performed.
//

ULONG RtlpSavedDismountCount = (ULONG)-1;


VOID
RtlpValidateCurrentDirectory(
    PCURDIR CurDir
    )

/*++

Routine Description:

    This function is used to validate the current directory for the process.
    The current directory can change in several ways, first, by replacing
    the media with one that has a different directory structure.  Second
    by performing a force-dismount.

Arguments:

    CurDir - Current directory structure for process

Return Value:

    None.

--*/

{
    NTSTATUS FsCtlStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR TrimmedPath[4];
    UNICODE_STRING str;

    if (((ULONG_PTR)CurDir->Handle & 1) == 0
        && USER_SHARED_DATA->DismountCount == RtlpSavedDismountCount) {

        return;

    }
    //
    // Never been set yet.
    //
    if (CurDir->Handle == NULL) {
        return;
    }

    //
    // Call Nt to see if the volume that
    // contains the directory is still mounted.
    // If it is, then continue. Otherwise, trim
    // current directory to the root.
    //

    //
    //  We're updated as far as possible with the current dismount count
    //

    RtlpSavedDismountCount = USER_SHARED_DATA->DismountCount;

    FsCtlStatus = NtFsControlFile(
                                 CurDir->Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_IS_VOLUME_MOUNTED,
                                 NULL,
                                 0,
                                 NULL,
                                 0
                                 );

    if ( FsCtlStatus == STATUS_WRONG_VOLUME || FsCtlStatus == STATUS_VOLUME_DISMOUNTED) {

        //
        // Try to get back to where we were, failing that reset current directory
        // to the root of the current drive
        //

        RtlpDereferenceCurDirRef(RtlpCurDirRef);
        RtlpCurDirRef = NULL;
        CurDir->Handle = NULL;

        FsCtlStatus = RtlSetCurrentDirectory_U(&CurDir->DosPath);
        if ( !NT_SUCCESS(FsCtlStatus) ) {

            TrimmedPath[0] = CurDir->DosPath.Buffer[0];
            TrimmedPath[1] = CurDir->DosPath.Buffer[1];
            TrimmedPath[2] = CurDir->DosPath.Buffer[2];
            TrimmedPath[3] = UNICODE_NULL;
            RtlpResetDriveEnvironment( TrimmedPath[0] );
            RtlInitUnicodeString( &str, TrimmedPath );

            //
            //  This can still fail if the volume was hard dismounted. We tried.
            //  Ah well.
            //

            (VOID) RtlSetCurrentDirectory_U( &str );
        }

    }
}


ULONG
RtlGetFullPathName_Ustr(
    PCUNICODE_STRING FileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType
    )

/*++

Routine Description:

    This function is used to return a fully qualified pathname
    corresponding to the specified unicode filename.  It does this by
    merging the current drive and directory together with the specified
    file name.  In addition to this, it calculates the address of the
    file name portion of the fully qualified pathname.

Arguments:

    lpFileName - Supplies the unicode file name of the file whose fully
        qualified pathname is to be returned.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        specified file.

    lpFilePart - Optional parameter that if specified, returns the
        address of the last component of the fully qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating unicode null character.  If the return
    value is greater than nBufferLength, the return value is the size of
    the buffer required to hold the pathname.  The return value is zero
    if the function failed.

--*/

{
    ULONG DeviceNameLength;
    ULONG DeviceNameOffset;
    ULONG PrefixSourceLength;
    LONG PathNameLength;
    UCHAR CurDrive, NewDrive;
    WCHAR EnvVarNameBuffer[4];
    UNICODE_STRING EnvVarName;
    PWSTR Source,Dest;
    UNICODE_STRING Prefix;
    PCURDIR CurDir;
    ULONG MaximumLength;
    UNICODE_STRING FullPath;
    ULONG BackupIndex;
    RTL_PATH_TYPE PathType;
    NTSTATUS Status;
    BOOLEAN StripTrailingSlash;
    UNICODE_STRING UnicodeString;
    ULONG NumberOfCharacters;
    PWSTR lpFileName;
    WCHAR wch;
    ULONG i,j;
    ULONG PathLength;

    if ( ARGUMENT_PRESENT(NameInvalid) ) {
        *NameInvalid = FALSE;
    }

    if ( nBufferLength > MAXUSHORT ) {
        nBufferLength = MAXUSHORT - 1;
    }

    *InputPathType = RtlPathTypeUnknown;

    UnicodeString = *FileName;
    lpFileName = UnicodeString.Buffer;

    NumberOfCharacters = UnicodeString.Length >> 1;
    PathNameLength = UnicodeString.Length;

    if ( PathNameLength == 0 || UnicodeString.Buffer[0] == UNICODE_NULL ) {
        return 0;
    }

    //
    // trim trailing spaces to check for a null name
    //
    DeviceNameLength = PathNameLength;
    wch = UnicodeString.Buffer[(DeviceNameLength>>1) - 1];
    while ( DeviceNameLength && wch == L' ' ) {
        DeviceNameLength -= sizeof(WCHAR);
        if ( DeviceNameLength ) {
            wch = UnicodeString.Buffer[(DeviceNameLength>>1) - 1];
        }
    }
    if ( !DeviceNameLength ) {
        return 0;
    }

    if ( lpFileName[NumberOfCharacters-1] == L'\\' || lpFileName[NumberOfCharacters-1] == L'/' ) {
        StripTrailingSlash = FALSE;
    }
    else {
        StripTrailingSlash = TRUE;
    }

    //
    // If pass Dos file name is a Dos device name, then turn it into
    // \\.\devicename and return its length.
    //

    DeviceNameLength = RtlIsDosDeviceName_Ustr (&UnicodeString);
    if ( DeviceNameLength ) {

        if ( ARGUMENT_PRESENT( lpFilePart ) ) {
            *lpFilePart = NULL;
        }

        DeviceNameOffset = DeviceNameLength >> 16;
        DeviceNameLength &= 0x0000ffff;

        if ( ARGUMENT_PRESENT(NameInvalid) && DeviceNameOffset ) {
            Status = RtlpCheckDeviceName(&UnicodeString, DeviceNameOffset,
                                         NameInvalid);
            if ((!NT_SUCCESS(Status)) || (*NameInvalid)) {
                return 0;
            }
        }

        PathNameLength = DeviceNameLength + RtlpSlashSlashDot.Length;
        if ( PathNameLength < (LONG)nBufferLength ) {
            RtlCopyMemory (lpBuffer,
                           RtlpSlashSlashDot.Buffer,
                           RtlpSlashSlashDot.Length);
            RtlMoveMemory ((PVOID)((PUCHAR)lpBuffer+RtlpSlashSlashDot.Length),
                           (PSZ)lpFileName+DeviceNameOffset,
                           DeviceNameLength);

            RtlZeroMemory ((PVOID)((PUCHAR)lpBuffer+RtlpSlashSlashDot.Length+DeviceNameLength),
                           sizeof(UNICODE_NULL));

            return PathNameLength;
        } else {
            PathNameLength += sizeof(UNICODE_NULL);
            if (PathNameLength > MAXUSHORT) {
                PathNameLength = 0;
            }
            return PathNameLength;
        }
    }

    //
    // Setup output string that points to callers buffer.
    //

    FullPath.MaximumLength = (USHORT)nBufferLength;
    FullPath.Length = 0;
    FullPath.Buffer = lpBuffer;
    RtlZeroMemory(lpBuffer,nBufferLength);
    //
    // Get a pointer to the current directory structure.
    //

    CurDir = &NtCurrentPeb()->ProcessParameters->CurrentDirectory;


    //
    // Determine the type of Dos Path Name specified.
    //

    *InputPathType = PathType = RtlDetermineDosPathNameType_Ustr( &UnicodeString );

    //
    // Determine the prefix and backup index.
    //
    //  Input        Prefix                     Backup Index
    //
    //  \\        -> \\,                            end of \\server\share
    //  \\.\      -> \\.\,                          4
    //  \\.       -> \\.                            3 (\\.)
    //  \         -> Drive: from CurDir.DosPath     3 (Drive:\)
    //  d:        -> Drive:\curdir from environment 3 (Drive:\)
    //  d:\       -> no prefix                      3 (Drive:\)
    //  any       -> CurDir.DosPath                 3 (Drive:\)
    //

    //
    // No prefixes yet.
    //

    Source = lpFileName;
    PrefixSourceLength = 0;
    Prefix.Length = 0;
    Prefix.MaximumLength = 0;
    Prefix.Buffer = NULL;

    RtlAcquirePebLock();

    PathLength = 0;
    try {


        switch (PathType) {
            case RtlPathTypeUncAbsolute : {
                    PWSTR UncPathPointer;
                    ULONG NumberOfPathSeparators;

                    //
                    // We want to scan the supplied path to determine where
                    // the "share" ends, and set BackupIndex to that point.
                    //

                    UncPathPointer = lpFileName + 2;
                    NumberOfPathSeparators = 0;

                    i = 2 * sizeof(WCHAR);
                    while (i < UnicodeString.Length) {
                        if (IS_PATH_SEPARATOR_U(*UncPathPointer)) {

                            NumberOfPathSeparators++;

                            if (NumberOfPathSeparators == 2) {
                                break;
                            }
                        }

                        i += sizeof(WCHAR);
                        UncPathPointer++;

                    }

                    BackupIndex = (ULONG)(UncPathPointer - lpFileName);

                    //
                    // Unc name. prefix = \\server\share
                    //

                    PrefixSourceLength = BackupIndex << 1;

                    Source += BackupIndex;

                    //
                    //  There is no prefix to place into the buffer.
                    //  The entire path is in Source
                    //

                }
                break;

            case RtlPathTypeLocalDevice :

                //
                // Local device name. prefix = "\\.\"
                //

                PrefixSourceLength = RtlpSlashSlashDot.Length;
                BackupIndex = 4;
                Source += BackupIndex;

                //
                //  There is no prefix to place into the buffer.
                //  The entire path is in Source
                //

                break;

            case RtlPathTypeRootLocalDevice :

                //
                // Local Device root. prefix = "\\.\"
                //

                Prefix = RtlpSlashSlashDot;
                Prefix.Length = (USHORT)(Prefix.Length - (USHORT)(2*sizeof(UNICODE_NULL)));
                PrefixSourceLength = Prefix.Length + sizeof(UNICODE_NULL);
                BackupIndex = 3;
                Source += BackupIndex;
                PathNameLength -= BackupIndex * sizeof( WCHAR );
                break;

            case RtlPathTypeDriveAbsolute :

                CurDrive = (UCHAR)RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );
                NewDrive = (UCHAR)RtlUpcaseUnicodeChar( lpFileName[0] );
                if ( CurDrive == NewDrive ) {

                    RtlpValidateCurrentDirectory( CurDir );

                }

                //
                // Dos drive absolute name
                //

                BackupIndex = 3;
                break;

            case RtlPathTypeDriveRelative :

                //
                // Dos drive relative name
                //

                CurDrive = (UCHAR)RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );
                NewDrive = (UCHAR)RtlUpcaseUnicodeChar( lpFileName[0] );
                if ( CurDrive == NewDrive ) {

                    RtlpValidateCurrentDirectory( CurDir );

                    Prefix = *(PUNICODE_STRING)&CurDir->DosPath;

                } else {
                    RtlpCheckRelativeDrive((WCHAR)NewDrive);

                    EnvVarNameBuffer[0] = L'=';
                    EnvVarNameBuffer[1] = (WCHAR)NewDrive;
                    EnvVarNameBuffer[2] = L':';
                    EnvVarNameBuffer[3] = UNICODE_NULL;
                    RtlInitUnicodeString(&EnvVarName,EnvVarNameBuffer);

                    Prefix = FullPath;
                    Status = RtlQueryEnvironmentVariable_U( NULL,
                                                            &EnvVarName,
                                                            &Prefix
                                                          );
                    if ( !NT_SUCCESS( Status ) ) {
                        if (Status == STATUS_BUFFER_TOO_SMALL) {
                            PathNameLength = (ULONG)(Prefix.Length) + PathNameLength + 2;
                            if (PathNameLength > MAXUSHORT) {
                                PathNameLength = 0;
                            }
                            PathLength =PathNameLength;
                            leave;
                        } else {
                            //
                            // Otherwise default to root directory of drive
                            //

                            Status = STATUS_SUCCESS;
                            EnvVarNameBuffer[0] = (WCHAR)NewDrive;
                            EnvVarNameBuffer[1] = L':';
                            EnvVarNameBuffer[2] = L'\\';
                            EnvVarNameBuffer[3] = UNICODE_NULL;
                            RtlInitUnicodeString(&Prefix,EnvVarNameBuffer);
                        }
                    } else {
                        ULONG LastChar;

                        //
                        // Determine
                        // if a backslash needs to be added
                        //

                        LastChar = Prefix.Length >> 1;

                        if (LastChar > 3) {
                            Prefix.Buffer[ LastChar ] = L'\\';
                            Prefix.Length += sizeof(UNICODE_NULL);
                        }
                    }
                }

                BackupIndex = 3;
                Source += 2;
                PathNameLength -= 2 * sizeof( WCHAR );
                break;

            case RtlPathTypeRooted :
                BackupIndex = RtlpComputeBackupIndex(CurDir);
                if ( BackupIndex != 3 ) {
                    Prefix = CurDir->DosPath;
                    Prefix.Length = (USHORT)(BackupIndex << 1);
                    }
                else {

                    //
                    // Rooted name. Prefix is drive portion of current directory
                    //

                    Prefix = CurDir->DosPath;
                    Prefix.Length = 2*sizeof(UNICODE_NULL);
                    }
                break;

            case RtlPathTypeRelative :

                RtlpValidateCurrentDirectory( CurDir );

                //
                // Current drive:directory relative name
                //

                Prefix = CurDir->DosPath;
                BackupIndex = RtlpComputeBackupIndex(CurDir);
                break;

            default:
                PathLength = 0;
                leave;
        }

        //
        // Maximum length required is the length of the prefix plus
        // the length of the specified pathname. If the callers buffer
        // is not at least this large, then return an error.
        //

        MaximumLength = PathNameLength + Prefix.Length;

        if ( (MaximumLength + sizeof(WCHAR)) > nBufferLength ) {
            if ( (NumberOfCharacters > 1) ||
                 (*lpFileName != L'.') ) {
                MaximumLength += sizeof(UNICODE_NULL);
                if (MaximumLength > MAXUSHORT) {
                    MaximumLength = 0;
                }
                PathLength =  MaximumLength;
                leave;
            } else {

                //
                // If we are expanding curdir, then remember the trailing '\'
                //

                if ( NumberOfCharacters == 1 && *lpFileName == L'.' ) {

                    //
                    // We are expanding .
                    //

                    if ( Prefix.Length == 6 ) {
                        if ( nBufferLength <= Prefix.Length ) {
                            PathLength = (ULONG)(Prefix.Length+(USHORT)sizeof(UNICODE_NULL));
                            leave;
                        }
                    } else {
                        if ( nBufferLength < Prefix.Length ) {
                            PathLength = (ULONG)Prefix.Length;
                            leave;
                        } else {
                            for(i=0,j=0;i<Prefix.Length;i+=sizeof(WCHAR),j++){
                                if ( Prefix.Buffer[j] == L'\\' ||
                                     Prefix.Buffer[j] == L'/' ) {

                                    FullPath.Buffer[j] = L'\\';
                                } else {
                                    FullPath.Buffer[j] = Prefix.Buffer[j];
                                }
                            }
                            FullPath.Length = Prefix.Length-(USHORT)sizeof(L'\\');
                            goto skipit;
                        }
                    }
                } else {
                    if (MaximumLength > MAXUSHORT) {
                        MaximumLength = 0;
                    }
                    PathLength = MaximumLength;
                    leave;
                }
            }
        }

        if (PrefixSourceLength || Prefix.Buffer != FullPath.Buffer) {
            //
            // Copy the prefix from the source string.
            //

            //RtlMoveMemory(FullPath.Buffer,lpFileName,PrefixSourceLength);

            for(i=0,j=0;i<PrefixSourceLength;i+=sizeof(WCHAR),j++){
                if ( lpFileName[j] == L'\\' ||
                     lpFileName[j] == L'/' ) {

                    FullPath.Buffer[j] = L'\\';
                } else {
                    FullPath.Buffer[j] = lpFileName[j];
                }
            }

            FullPath.Length = (USHORT)PrefixSourceLength;

            //
            // Append any additional prefix
            //

            for(i=0,j=0;i<Prefix.Length;i+=sizeof(WCHAR),j++) {
                if ( Prefix.Buffer[j] == L'\\' ||
                     Prefix.Buffer[j] == L'/' ) {

                    FullPath.Buffer[j+(FullPath.Length>>1)] = L'\\';
                } else {
                    FullPath.Buffer[j+(FullPath.Length>>1)] = Prefix.Buffer[j];
                }
            }
            FullPath.Length = FullPath.Length + Prefix.Length;

        } else {
            FullPath.Length = Prefix.Length;
        }
skipit:
        Dest =  (PWSTR)((PUCHAR)FullPath.Buffer + FullPath.Length);
        *Dest = UNICODE_NULL;

        i = (ULONG)((PCHAR)Source - (PCHAR)lpFileName);
        while ( i < UnicodeString.Length ) {
            i += sizeof(WCHAR);
            switch ( *Source ) {

            case L'\\' :
            case L'/' :

                //
                // collapse multiple "\" characters. If the previous character was
                // a path character, skip it.
                //

                if  ( *(Dest-1) != L'\\' ) {
                    *Dest++ = L'\\';
                }

                Source++;
                break;

            case '.' :

                //
                // Ignoring dot in a leading //./ has already been taken
                // care of by advancing Source above.
                //
                // Eat single dots as in /./ by simply skipping them
                //
                // Double dots back up one level as in /../
                //
                // Any other . is just a filename character
                //

                j = UnicodeString.Length - i + sizeof(WCHAR);
                if ( IS_DOT_USTR(Source, j) ) {
                    Source++;

                    if ( (i < UnicodeString.Length) &&
                         IS_PATH_SEPARATOR_U(*Source) ) {
                        Source++;
                        i += sizeof(WCHAR);
                    }
                    break;

                } else if ( IS_DOT_DOT_USTR(Source, j) ) {
                    //
                    // backup destination string looking for a '\'
                    //

                    while (*Dest != L'\\') {
                        *Dest = UNICODE_NULL;
                        Dest--;
                    }

                    //
                    // backup to previous component..
                    // \a\b\c\.. to \a\b
                    //

                    do {

                        //
                        // If we bump into root prefix, then
                        // stay at root
                        //

                        if ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
                            break;
                        }

                        *Dest = UNICODE_NULL;
                        Dest--;

                    } while (*Dest != L'\\');
                    if ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
                        Dest++;
                    }

                    //
                    // Advance source past ..
                    //

                    Source += 2;
                    i += sizeof(WCHAR);

                    break;
                }

                //
                // Not a single dot or double-dot.  The dot we found begins
                // a file name so we treat this as a normal file name
                //
                // FALLTHRU
                //

            default:
//
//  IIS cannot handle the change below in the .NET timeframe.  Back it out and
//  go back to the previous version
//
#if FALSE

                //
                // Copy the filename. Note that no remaining chars and /,\
                // will stop the copy.
                //

                //
                //  Here is what should be processed:
                //
                //  Names that are all dots and spaces.
                //  Names that have something other than dot and space with trailing spaces and dots removed.
                //
                //  Simple state machine:
                //
                //  Start: DOT => DotAndSpace
                //         SPACE => DotAndSpace
                //         OTHER => Component
                //
                //  DotAndSpace: DOT => DotAndSpace
                //               SPACE => DotAndSpace
                //               OTHER => Component
                //
                //  Component: DOT => ComponentTrailingDotSpace (Save location for truncation)
                //             SPACE => ComponentTrailingDotSpace (Save location for truncation)
                //             OTHER => Component
                //
                //  ComponentTrailingDotSpace: DOT => ComponentTrailingDotSpace
                //                             SPACE => ComponentTrailingDotSpace
                //                             OTHER => Component (Reset location for truncation)
                //

                {
                    typedef enum {
                        StateStart,
                        StateDotAndSpace,
                        StateComponent,
                        StateComponentTrailingDotSpace
                    } COPYCOMPONENTSTATE;


                    COPYCOMPONENTSTATE State = StateStart;
                    PWCHAR TruncationPoint = NULL;

                    i -= sizeof(WCHAR);
                    j = UnicodeString.Length - i;
                    while ( !IS_END_OF_COMPONENT_USTR(Source, j) ) {
                        WCHAR c = *Source;
                        *Dest++ = *Source++;
                        j -= sizeof( WCHAR );
                        i += sizeof( WCHAR );

                        switch (State) {
                        case StateStart:
                            State = (c == L'.') ? StateDotAndSpace :
                                    (c == L' ') ? StateDotAndSpace :
                                                  StateComponent;
                            break;
                        case StateDotAndSpace:
                            State = (c == L'.') ? StateDotAndSpace :
                                    (c == L' ') ? StateDotAndSpace :
                                                  StateComponent;
                            break;
                        case StateComponent:
                            State = (c == L'.') ? (TruncationPoint = Dest-1, StateComponentTrailingDotSpace) :
                                    (c == L' ') ? (TruncationPoint = Dest-1, StateComponentTrailingDotSpace) :
                                                  StateComponent;
                            break;
                        case StateComponentTrailingDotSpace:
                            State = (c == L'.') ? StateComponentTrailingDotSpace :
                                    (c == L' ') ? StateComponentTrailingDotSpace :
                                                  (TruncationPoint = NULL, StateComponent);
                            break;
                        default:

                            //  DbgPrint( "RtlGetFullPathName_Ustr: Invalid State %d\n", State );
                            //  DbgBreakPoint( );

                            PathLength = 0;
                            leave;
                        }
                    }

                    if (TruncationPoint != NULL) {

                        // DbgPrint( "RtlGetFullPathName_Ustr: Truncating %Z\n", FileName );
                        Dest = TruncationPoint;
                    }
                }
#else   //  Put back in old code for IIS

                //
                // Copy the filename. Note that
                // null and /,\ will stop the copy. If any
                // charcter other than null or /,\ is encountered,
                // then the pathname is invalid.
                //

                //
                //  Copy up until NULL or path separator
                //

                i -= sizeof(WCHAR);
                j = UnicodeString.Length - i;
                while ( !IS_END_OF_COMPONENT_USTR(Source, j) ) {
                    j -= sizeof( WCHAR );
                    i += sizeof( WCHAR );
                    *Dest++ = *Source++;
                }


                //
                //  Once copied, we should do some processing for compatibility with Win9x.
                //  Win9x strips all trailing spaces and dots from the name.
                //  Nt4/Win2K strips only the last dot if its followed by a path separator.
                //
                //  Ideally, we'd do something reasonable like stripping all trailing spaces
                //  and dots (like Win9X).  However, IIS has a security model that's based
                //  on NAMES and not on objects.  This means that IIS needs to process names
                //  in the same way that we do.  They should use GetFullPathName and be done
                //  with it.  In any event, DON'T CHANGE THE CANONICALIZATION OF THE NAME
                //  HERE WITHOUTH FIRST GOING THROUGH IIS.
                //
                //  We do EXACTLY what Nt4 did: if there's a trailing dot AND we're at a path
                //  seperator, remove the trailing dot.
                //

                if (IS_PATH_SEPARATOR_U( *Source ) && Dest[-1] == L'.') {
                    Dest--;
                }
#endif

            }
        }

        *Dest = UNICODE_NULL;

        if ( StripTrailingSlash ) {
            if ( Dest > (FullPath.Buffer + BackupIndex ) && *(Dest-1) == L'\\' ) {
                Dest--;
                *Dest = UNICODE_NULL;
            }
        }
        FullPath.Length = (USHORT)(PtrToUlong(Dest) - PtrToUlong(FullPath.Buffer));

//
//  More IIS stuff to put back in
//

#if TRUE
        //
        //  Strip trailing spaces and dots.
        //

        while (Dest > FullPath.Buffer && (Dest[-1] == L' ' || Dest[-1] == L'.')) {
            *--Dest = UNICODE_NULL;
            FullPath.Length -= sizeof( WCHAR );
        }
#endif

        if ( ARGUMENT_PRESENT( lpFilePart ) ) {

            //
            // Locate the file part...
            //

            Source = Dest-1;
            Dest = NULL;

            while(Source > FullPath.Buffer ) {
                if ( *Source == L'\\' ) {
                    Dest = Source + 1;
                    break;
                }
                Source--;
            }

            if ( Dest && *Dest ) {

                //
                // If this is a UNC name, make sure filepart is past the backup index
                //
                if ( PathType == RtlPathTypeUncAbsolute ) {
                    if ( Dest < (FullPath.Buffer + BackupIndex ) ) {
                        *lpFilePart = NULL;
                        PathLength = (ULONG)FullPath.Length;
                        leave;
                    }
                }
                *lpFilePart = Dest;
            } else {
                *lpFilePart = NULL;
            }
        }
        PathLength = (ULONG)FullPath.Length;
    } finally {
        RtlReleasePebLock();
    }

    return PathLength;
}


NTSTATUS
RtlGetFullPathName_UstrEx(
    PCUNICODE_STRING FileName,
    PUNICODE_STRING StaticString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    SIZE_T *FilePartPrefixCch OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType,
    SIZE_T *BytesRequired OPTIONAL
    )

/*++

Routine Description:

    See a description of RtlGetFullPathName_Ustr() for a functional
    description.

    This function provides the same basic behavior as RtlGetFullPathName_Ustr(),
    but with easier support for dynamically allocated arbitrary path name
    buffers.

    One would think that this is the core implementation and the non-Ex()
    version would call the ...Ex() version, but that seems risky, and
    would only really help the performance of the case where a dynamic allocation
    is done.

--*/
{
    NTSTATUS Status;
    ULONG Length;
    PWSTR FilePart = NULL;
    UNICODE_STRING TempDynamicString;
    USHORT StaticBufferSize;
    PWSTR StaticDynamic = NULL;
    PWSTR StaticBuffer;

    if (StringUsed != NULL) {
        *StringUsed = NULL;
    }

    if (BytesRequired != NULL) {
        *BytesRequired = 0;
    }

    if (FilePartPrefixCch != NULL) {
        *FilePartPrefixCch = 0;
    }

    TempDynamicString.Buffer = NULL;

    if ((StaticString != NULL) && (DynamicString != NULL) && (StringUsed == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StaticString != NULL) {
        StaticBufferSize = StaticString->MaximumLength;
        StaticBuffer = StaticString->Buffer;
    }
    else {
        StaticBufferSize = DOS_MAX_PATH_LENGTH * sizeof(WCHAR);
        StaticDynamic = (RtlAllocateStringRoutine)( StaticBufferSize );

        if (StaticDynamic == NULL) {
            return STATUS_NO_MEMORY;
        }
        StaticBuffer = StaticDynamic;
    }

    // First try getting into the static string.
    Length = RtlGetFullPathName_Ustr(
        FileName,
        StaticBufferSize,
        StaticBuffer,
        &FilePart,
        NameInvalid,
        InputPathType);
    if (Length == 0) {
#if DBG
        DbgPrint("%s(%d) - RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
        Status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }

    if ((StaticString != NULL) && (Length < StaticBufferSize)) {
        // woohoo it worked.
        StaticString->Length = (USHORT) Length;

        if (FilePartPrefixCch != NULL) {
            *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - StaticString->Buffer) : 0;
        }

        if (StringUsed != NULL)
            *StringUsed = StaticString;

        Status = STATUS_SUCCESS;
    } else if (DynamicString == NULL) {
        // The static buffer wasn't big enough and the caller doesn't want us to do
        // a dynamic allocation; the best we can hope for is to give them back a
        // reasonable size.

        if (BytesRequired != NULL) {
            *BytesRequired = Length;
        }

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    } else if ((StaticDynamic != NULL) && (Length < StaticBufferSize)) {
        //
        // Temporary StaticDynamic worked and DynamicString != NULL
        // So change StaticDynamic into DynamicString
        //
        DynamicString->MaximumLength = StaticBufferSize;
        DynamicString->Length = (USHORT) Length;

        StaticDynamic[Length / sizeof(WCHAR)] = UNICODE_NULL;

        if (FilePartPrefixCch != NULL) {
            *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - StaticDynamic) : 0;
        }

        if (StringUsed != NULL) {
            *StringUsed = DynamicString;
        }

        DynamicString->Buffer = StaticDynamic;
        StaticDynamic = NULL;   // make sure it does not get freed on exit

        Status = STATUS_SUCCESS;

    } else {
        // Not big enough... allocate some memory into the dynamic buffer.
        // But wait; we need to lock the Peb lock so that someone doesn't
        // change the process's current directory out from under us!

        Status = STATUS_INTERNAL_ERROR;
        RtlAcquirePebLock();
        __try {
            // Do it again with the peb lock taken so that we can get an accurate stable
            // length.

            Length = RtlGetFullPathName_Ustr(
                            FileName,
                            StaticBufferSize,
                            StaticBuffer,
                            &FilePart,
                            NameInvalid,
                            InputPathType);
            if (Length == 0) {
#if DBG
                DbgPrint("%s line %d: RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
                Status = STATUS_OBJECT_NAME_INVALID;
                __leave;
            }

            if ((StaticString != NULL) && (Length < StaticString->MaximumLength)) {
                // woohoo it worked; some voodoo is going on where the current directory
                // or something just changed prior to us acquiring the Peb lock.
                StaticString->Length = (USHORT) Length;

                if (FilePartPrefixCch != NULL) {
                    *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - StaticString->Buffer) : 0;
                }

                if (StringUsed != NULL) {
                    *StringUsed = StaticString;
                }
            } else {
                // If it doesn't fit into a UNICODE string, we're in big trouble.
                if ((Length + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
                    Status = STATUS_NAME_TOO_LONG;
                    __leave;
                }

                TempDynamicString.MaximumLength = (USHORT) (Length + sizeof(WCHAR));

                TempDynamicString.Buffer = (RtlAllocateStringRoutine)(TempDynamicString.MaximumLength);
                if (TempDynamicString.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    __leave;
                }

                Length = RtlGetFullPathName_Ustr(
                            FileName,
                            TempDynamicString.MaximumLength - sizeof(WCHAR),
                            TempDynamicString.Buffer,
                            &FilePart,
                            NameInvalid,
                            InputPathType);
                if (Length == 0) {
#if DBG
                    DbgPrint("%s line %d: RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
                    Status = STATUS_OBJECT_NAME_INVALID;
                    __leave;
                }

                // If this assert fires, it means that someone changed something that
                // RtlGetFullPathName_Ustr() uses to resolve the filename, even while
                // we're holding the Peb lock.  This is really bad and whoever is
                // trashing the PEB is resposible, not this code.
                ASSERT(Length < (TempDynamicString.MaximumLength - sizeof(WCHAR)));
                if (Length > (TempDynamicString.MaximumLength - sizeof(WCHAR))) {
                    Status = STATUS_INTERNAL_ERROR;
                    __leave;
                }

                if (FilePartPrefixCch != NULL) {
                    *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - TempDynamicString.Buffer) : 0;
                }

                TempDynamicString.Buffer[Length / sizeof(WCHAR)] = UNICODE_NULL;

                DynamicString->Buffer = TempDynamicString.Buffer;
                DynamicString->Length = (USHORT) Length;
                DynamicString->MaximumLength = TempDynamicString.MaximumLength;

                if (StringUsed != NULL)
                    *StringUsed = DynamicString;

                TempDynamicString.Buffer = NULL;
            }

            Status = STATUS_SUCCESS;

        } __finally {
            RtlReleasePebLock();
        }
    }
Exit:
    if (StaticDynamic != NULL) {
        (RtlFreeStringRoutine)(StaticDynamic);
    }

    if (TempDynamicString.Buffer != NULL) {
        (RtlFreeStringRoutine)(TempDynamicString.Buffer);
    }

#if DBG
    // This happens a lot for STATUS_NO_SUCH_FILE and STATUS_BUFFER_TOO_SMALL; we'll report any others
    if (NT_ERROR(Status) && (Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
        DbgPrint("RTL: %s - failing on filename %wZ with status %08lx\n", __FUNCTION__, FileName, Status);
    }
#endif // DBG

    return Status;
}


ULONG
RtlGetFullPathName_U(
    PCWSTR lpFileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL
    )

{
    UNICODE_STRING UnicodeString;
    RTL_PATH_TYPE PathType;
    NTSTATUS Status;

    Status = RtlInitUnicodeStringEx(&UnicodeString,lpFileName);
    if (!NT_SUCCESS (Status)) {
        return 0;
    }

    return RtlGetFullPathName_Ustr(&UnicodeString,nBufferLength,lpBuffer,lpFilePart,NULL,&PathType);
}


NTSTATUS
RtlpWin32NTNameToNtPathName_U(
    IN PCUNICODE_STRING DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    )
/*++

    Note: assumes that DosFileName has already been validated to have more than
          4 WCHARs

--*/
{
    PWSTR FullNtPathName = NULL;
    PWSTR Source,Dest;
    ULONG NtFileLength;
    NTSTATUS Status = STATUS_SUCCESS;


    NtFileLength = DosFileName->Length - 8 + RtlpDosDevicesPrefix.Length;
    if ( NtFileLength > (MAXUSHORT - sizeof(UNICODE_NULL)) ) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    FullNtPathName = RtlAllocateHeap(
                        RtlProcessHeap(),
                        0,
                        NtFileLength + sizeof(UNICODE_NULL)
                        );
    if ( !FullNtPathName ) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    //
    // Copy the full Win32/NT path next to the name prefix, skipping over
    // the \\?\ at the front of the path.
    //

    RtlCopyMemory (FullNtPathName,RtlpDosDevicesPrefix.Buffer,RtlpDosDevicesPrefix.Length);
    RtlCopyMemory ((PUCHAR)FullNtPathName+RtlpDosDevicesPrefix.Length,
                   DosFileName->Buffer + 4,
                   DosFileName->Length - 8);

    //
    // Null terminate the path name to make strlen below happy.
    //
    FullNtPathName[ NtFileLength >> 1 ] = UNICODE_NULL;

    //
    // Now we have the passed in path with \DosDevices\ prepended. Blow out the
    // relative name structure (if provided), and possibly compute filepart
    //

    if ( ARGUMENT_PRESENT(RelativeName) ) {

        //
        // If the current directory is a sub-string of the
        // Nt file name, and if a handle exists for the current
        // directory, then return the directory handle and name
        // relative to the directory.
        //

        RelativeName->RelativeName.Length = 0;
        RelativeName->RelativeName.MaximumLength = 0;
        RelativeName->RelativeName.Buffer = 0;
        RelativeName->ContainingDirectory = NULL;
        RelativeName->CurDirRef = NULL;
    }

    if ( ARGUMENT_PRESENT( FilePart ) ) {

        //
        // Locate the file part...
        //

        Source = &FullNtPathName[ (NtFileLength-1) >> 1 ];
        Dest = NULL;

        while(Source > FullNtPathName ) {
            if ( *Source == L'\\' ) {
                Dest = Source + 1;
                break;
            }
            Source--;
        }

        if ( Dest && *Dest ) {
            *FilePart = Dest;
        } else {
            *FilePart = NULL;
        }
    }

    NtFileName->Buffer = FullNtPathName;
    NtFileName->Length = (USHORT)(NtFileLength);
    NtFileName->MaximumLength = (USHORT)(NtFileLength + sizeof(UNICODE_NULL));

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


BOOLEAN
RtlpDosPathNameToRelativeNtPathName_Ustr(
    IN BOOLEAN CaptureRelativeName,
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    )
/*++

Routine Description:

    A Dos pathname can be translated into an Nt style pathname
    using this function.

    This function is used only within the Base dll to translate Dos
    pathnames to Nt pathnames. Upon successful translation, the
    pointer (NtFileName->Buffer) points to memory from RtlProcessHeap()
    that contains the Nt version of the input dos file name.

Arguments:

    CaptureRelativeName - Indicates whether we should capture the
        handle for the relative name.

    DosFileName - Supplies the unicode Dos style file name that is to be
        translated into an equivalent unicode Nt file name.

    NtFileName - Returns the address of memory in the RtlProcessHeap() that
        contains an NT filename that refers to the specified Dos file
        name.

    FilePart - Optional parameter that if specified, returns the
        trailing file portion of the file name.  A path of \foo\bar\x.x
        returns the address of x.x as the file part.

    RelativeName - An optional parameter, that if specified, returns
        a pathname relative to the current directory. The
        length field of RelativeName->RelativeName is 0 if the relative
        name can not be used.

Return Value:

    TRUE - The path name translation was successful.  Once the caller is
        done with the translated name, the memory pointed to by
        NtFileName.Buffer should be returned to the RtlProcessHeap().

    FALSE - The operation failed.

Note:
    The buffers pointed to by RelativeName, FilePart, and NtFileName must ALL
    point within the same memory address.  If they don't, code that calls
    this routine will fail.

--*/

{
    ULONG BufferLength;
    ULONG DosPathLength;
    PWSTR FullNtPathName = NULL;
    PWSTR FullDosPathName = NULL;
    UNICODE_STRING Prefix;
    UNICODE_STRING UnicodeFilePart;
    UNICODE_STRING FullDosPathString;
    PCURDIR CurDir;
    RTL_PATH_TYPE DosPathType;
    RTL_PATH_TYPE InputDosPathType;
    ULONG DosPathNameOffset;
    ULONG FullDosPathNameLength;
    ULONG LastCharacter;
    UNICODE_STRING UnicodeString;
    BOOLEAN NameInvalid;
    WCHAR StaticDosBuffer[DOS_MAX_PATH_LENGTH + 1];
    BOOLEAN UseWin32Name, fRC;

    //
    // Calculate the size needed for the full pathname. Add in
    // space for the longest Nt prefix
    //

    BufferLength = sizeof(StaticDosBuffer);
    DosPathLength = (DOS_MAX_PATH_LENGTH << 1 );

    UnicodeString = *DosFileNameString;

    //
    // see if this is \\?\ form of name
    //
    if ( UnicodeString.Length > 8 && UnicodeString.Buffer[0] == '\\' &&
         UnicodeString.Buffer[1] == '\\' && UnicodeString.Buffer[2] == '?' &&
         UnicodeString.Buffer[3] == '\\' ) {

        UseWin32Name = TRUE;
    } else {
        UseWin32Name = FALSE;

        //
        // The dos name starts just after the longest Nt prefix
        //

        FullDosPathName = &StaticDosBuffer[0];

        BufferLength += RtlpLongestPrefix;

        //
        // Allocate space for the full Nt Name (including DOS name portion)
        //

        FullNtPathName = RtlAllocateHeap(RtlProcessHeap(), 0, BufferLength);

        if ( !FullNtPathName ) {
            return FALSE;
        }
    }

    fRC = TRUE;
    RtlAcquirePebLock();

    __try {
        __try {

            if ( UseWin32Name ) {
                NTSTATUS Status;

                Status = RtlpWin32NTNameToNtPathName_U(&UnicodeString,NtFileName,FilePart,RelativeName);
                if (NT_SUCCESS(Status)) {
                    fRC = TRUE;
                } else {
                    fRC = FALSE;
                }
                __leave;
            }

            FullDosPathNameLength = RtlGetFullPathName_Ustr(
                                        &UnicodeString,
                                        DosPathLength,
                                        FullDosPathName,
                                        FilePart,
                                        &NameInvalid,
                                        &InputDosPathType
                                        );
            if ( NameInvalid || !FullDosPathNameLength ||
                  FullDosPathNameLength > DosPathLength ) {
                fRC = FALSE;
                __leave;
            }

            //
            // Determine how to format prefix of FullNtPathName base on the
            // the type of Dos path name.  All Nt names begin in the \DosDevices
            // directory.
            //

            Prefix = RtlpDosDevicesPrefix;

            DosPathType = RtlDetermineDosPathNameType_U(FullDosPathName);
            DosPathNameOffset = 0;

            switch (DosPathType) {
                case RtlPathTypeUncAbsolute :

                    //
                    // Unc name, use \DosDevices\UNC symbolic link to find
                    // redirector.  Skip of \\ in source Dos path.
                    //

                    Prefix = RtlpDosDevicesUncPrefix;
                    DosPathNameOffset = 2;
                    break;

                case RtlPathTypeLocalDevice :

                    //
                    // Local device name, so just use \DosDevices prefix and
                    // skip \\.\ in source Dos path.
                    //

                    DosPathNameOffset = 4;
                    break;

                case RtlPathTypeRootLocalDevice :

                    ASSERT( FALSE );
                    break;

                case RtlPathTypeDriveAbsolute :
                case RtlPathTypeDriveRelative :
                case RtlPathTypeRooted :
                case RtlPathTypeRelative :

                    //
                    // All drive references just use \DosDevices prefix and
                    // do not skip any of the characters in the source Dos path.
                    //

                    break;

                default:
                    ASSERT( FALSE );
            }

            //
            // Copy the full DOS path next to the name prefix, skipping over
            // the "\\" at the front of the UNC path or the "\\.\" at the front
            // of a device name.
            //

            RtlCopyMemory(FullNtPathName,Prefix.Buffer,Prefix.Length);
            RtlCopyMemory((PUCHAR)FullNtPathName+Prefix.Length,
                          FullDosPathName + DosPathNameOffset,
                          FullDosPathNameLength - (DosPathNameOffset<<1));

            //
            // Null terminate the path name to make strlen below happy.
            //


            NtFileName->Buffer = FullNtPathName;
            NtFileName->Length = (USHORT)(FullDosPathNameLength-(DosPathNameOffset<<1))+Prefix.Length;
            NtFileName->MaximumLength = (USHORT)BufferLength;
            LastCharacter = NtFileName->Length >> 1;
            FullNtPathName[ LastCharacter ] = UNICODE_NULL;


            //
            // Readjust the file part to point to the appropriate position within
            // the FullNtPathName buffer instead of inside the FullDosPathName
            // buffer
            //


            if ( ARGUMENT_PRESENT(FilePart) ) {
                if (*FilePart) {
                    NTSTATUS Status;

                    Status = RtlInitUnicodeStringEx(&UnicodeFilePart,*FilePart);
                    if (!NT_SUCCESS(Status)) {
                        fRC = FALSE;
                        __leave;
                    }
                    *FilePart = &FullNtPathName[ LastCharacter ] - (UnicodeFilePart.Length >> 1);
                }
            }

            if ( ARGUMENT_PRESENT(RelativeName) ) {

                //
                // If the current directory is a sub-string of the
                // Nt file name, and if a handle exists for the current
                // directory, then return the directory handle and name
                // relative to the directory.
                //

                RelativeName->RelativeName.Length = 0;
                RelativeName->RelativeName.MaximumLength = 0;
                RelativeName->RelativeName.Buffer = 0;
                RelativeName->ContainingDirectory = NULL;
                RelativeName->CurDirRef = NULL;

                if ( InputDosPathType == RtlPathTypeRelative ) {

                    CurDir = &NtCurrentPeb()->ProcessParameters->CurrentDirectory;

                    if ( CurDir->Handle ) {
                        NTSTATUS Status;
                        //
                        // Now compare curdir to full dos path. If curdir length is
                        // greater than full path. It is not a match. Otherwise,
                        // trim full path length to cur dir length and compare.
                        //

                        Status = RtlInitUnicodeStringEx(&FullDosPathString,
                                                        FullDosPathName);
                        if (!NT_SUCCESS(Status)) {
                            fRC = FALSE;
                            __leave;
                        }
                        if ( CurDir->DosPath.Length <= FullDosPathString.Length ) {
                            FullDosPathString.Length = CurDir->DosPath.Length;
                            if ( RtlEqualUnicodeString(
                                    (PUNICODE_STRING)&CurDir->DosPath,
                                    &FullDosPathString,
                                    TRUE
                                    ) ) {

                                //
                                // The full dos pathname is a substring of the
                                // current directory.  Compute the start of the
                                // relativename.
                                //

                                RelativeName->RelativeName.Buffer = (PWSTR)((PCHAR)FullNtPathName + Prefix.Length - (DosPathNameOffset<<1) + (CurDir->DosPath.Length));
                                RelativeName->RelativeName.Length = (USHORT)FullDosPathNameLength - (CurDir->DosPath.Length);
                                if ( *RelativeName->RelativeName.Buffer == L'\\' ) {
                                    RelativeName->RelativeName.Buffer += 1;
                                    RelativeName->RelativeName.Length -= sizeof(WCHAR);
                                }
                                RelativeName->RelativeName.MaximumLength = RelativeName->RelativeName.Length;
                                if (CaptureRelativeName) {
                                    ASSERT(RtlpCurDirRef);
                                    ASSERT(RtlpCurDirRef->DirectoryHandle == CurDir->Handle);
                                    RelativeName->CurDirRef = RtlpCurDirRef;
                                    RtlpReferenceCurDirRef(RtlpCurDirRef);
                                }

                                RelativeName->ContainingDirectory = CurDir->Handle;
                            }
                        }
                    }
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
              fRC = FALSE;
        }
    }
    finally {
        RtlReleasePebLock();

        if (fRC == FALSE && FullNtPathName != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, FullNtPathName);
        }
    }
    return fRC;
}

BOOLEAN
RtlDosPathNameToRelativeNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName
    )
{
    ASSERT(RelativeName);
    return RtlpDosPathNameToRelativeNtPathName_Ustr(TRUE,
                                                    DosFileNameString,
                                                    NtFileName,
                                                    FilePart,
                                                    RelativeName);
}

BOOLEAN
RtlDosPathNameToNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    IN PVOID Reserved
    )
{
    return RtlpDosPathNameToRelativeNtPathName_Ustr(FALSE,
                                                    DosFileNameString,
                                                    NtFileName,
                                                    FilePart,
                                                    (PRTL_RELATIVE_NAME_U) Reserved);
}

BOOLEAN
RtlpDosPathNameToRelativeNtPathName_U(
    IN BOOLEAN CaptureRelativeName,
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    )
{
    UNICODE_STRING DosFileNameString;
    SIZE_T Length = 0;

    if (DosFileName != NULL) {
        Length = wcslen( DosFileName ) * sizeof( WCHAR );
        if (Length + sizeof( UNICODE_NULL ) >= UNICODE_STRING_MAX_BYTES) {
            return FALSE;
        }
        DosFileNameString.MaximumLength = (USHORT)(Length + sizeof( UNICODE_NULL ));
    } else {
        DosFileNameString.MaximumLength = 0;
    }

    DosFileNameString.Buffer = (PWSTR) DosFileName;
    DosFileNameString.Length = (USHORT)Length;

    return RtlpDosPathNameToRelativeNtPathName_Ustr(CaptureRelativeName,
                                                    &DosFileNameString,
                                                    NtFileName,
                                                    FilePart,
                                                    RelativeName);
}

BOOLEAN
RtlDosPathNameToRelativeNtPathName_U(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName
    )
{
    ASSERT(RelativeName);
    return RtlpDosPathNameToRelativeNtPathName_U(TRUE,
                                                 DosFileName,
                                                 NtFileName,
                                                 FilePart,
                                                 RelativeName);
}

BOOLEAN
RtlDosPathNameToNtPathName_U(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    IN PVOID Reserved
    )
{
    return RtlpDosPathNameToRelativeNtPathName_U(FALSE,
                                                 DosFileName,
                                                 NtFileName,
                                                 FilePart,
                                                 (PRTL_RELATIVE_NAME_U) Reserved);
}

VOID
NTAPI
RtlReleaseRelativeName(
    IN PRTL_RELATIVE_NAME_U RelativeName
    )

/*++

Routine Description:

    This function closes the handle earlier created by a
    call to RtlDosPathNameToRelativeNtPathName_U().

Arguments:

    RelativeName - contains the current directory information to be released.

Return Value:

    None.

--*/

{
    ASSERT(RelativeName);

    if (RelativeName->CurDirRef) {

        RtlpDereferenceCurDirRef(RelativeName->CurDirRef);

        RelativeName->CurDirRef = NULL;

    }
}

BOOLEAN
RtlDoesFileExists_UstrEx(
    IN PCUNICODE_STRING FileNameString,
    IN BOOLEAN TreatDeniedOrSharingAsHit
    )
/*++

Routine Description:

    This function checks to see if the specified unicode filename exists.

Arguments:

    FileName - Supplies the file name of the file to find.

    TreatDeniedOrSharingAsHit - treat denied or sharing error as file existance
        TRUE  - treat denied or sharing error as sign of file existance
        FALSE - do not treat denied or sharing error as sign of file existance

Return Value:

    TRUE - The file was found.

    FALSE - The file was not found.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING NtFileName;
    BOOLEAN ReturnValue;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    FILE_BASIC_INFORMATION BasicInfo;

    ReturnValue = RtlDosPathNameToRelativeNtPathName_Ustr(
                    FileNameString,
                    &NtFileName,
                    NULL,
                    &RelativeName
                    );

    if ( !ReturnValue ) {
        return FALSE;
        }

    FreeBuffer = NtFileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        NtFileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &NtFileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Query the file's attributes.  Note that the file cannot simply be opened
    // to determine whether or not it exists, as the NT LanMan redirector lies
    // on NtOpenFile to a Lan Manager server because it does not actually open
    // the file until an operation is performed on it.
    //

    Status = NtQueryAttributesFile(
                &Obja,
                &BasicInfo
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_SHARING_VIOLATION ||
             Status == STATUS_ACCESS_DENIED ) {
            if ( TreatDeniedOrSharingAsHit ) {
                ReturnValue = TRUE;
                }
            else {
                ReturnValue = FALSE;
                }
            }
        else {
            ReturnValue = FALSE;
            }
        }
    else {
        ReturnValue = TRUE;
        }
    return ReturnValue;
}


BOOLEAN
RtlDoesFileExists_UEx(
    IN PCWSTR FileName,
    IN BOOLEAN TreatDeniedOrSharingAsHit
    )
{
    UNICODE_STRING FileNameString;
    NTSTATUS Status;

    Status = RtlInitUnicodeStringEx(&FileNameString, FileName);
    if( !NT_SUCCESS( Status ) ) {
        return FALSE;
    }
    return RtlDoesFileExists_UstrEx(&FileNameString, TreatDeniedOrSharingAsHit);
}


BOOLEAN
RtlDoesFileExists_U(
    IN PCWSTR FileName
    )

/*++

Routine Description:

    This function checks to see if the specified unicode filename exists.

Arguments:

    FileName - Supplies the file name of the file to find.

Return Value:

    TRUE - The file was found.

    FALSE - The file was not found.

--*/

{
    return RtlDoesFileExists_UEx(FileName,TRUE);
}


BOOLEAN
RtlDoesFileExists_UStr(
    IN PCUNICODE_STRING FileName
    )
/*
RtlDoesFileExists_UStr same as RtlDoesFileExists_U but takes a PCUNICODE_STRING instead of a PCWSTR,
saving a call to wcslen
*/
{
    return RtlDoesFileExists_UstrEx(FileName,TRUE);
}


ULONG
RtlDosSearchPath_U(
    IN PCWSTR lpPath,
    IN PCWSTR lpFileName,
    IN PCWSTR lpExtension OPTIONAL,
    IN ULONG nBufferLength,
    OUT PWSTR lpBuffer,
    OUT PWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    lpPath - Supplies the search path to be used when locating the file.

    lpFileName - Supplies the file name of the file to search for.

    lpExtension - An optional parameter, that if specified, supplies an
        extension to be added to the filename when doing the search.
        The extension is only added if the specified filename does not
        end with an extension.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        file that was found.

    lpFilePart - Optional parameter that if specified, returns the
        address of the last component of the fully qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.


--*/

{

    PWSTR ComputedFileName;
    ULONG ExtensionLength;
    ULONG PathLength;
    ULONG FileLength;
    UNICODE_STRING Scratch;
    PCWSTR p;
    NTSTATUS Status;

    //
    // if the file name is not a relative name, then
    // return if the file does not exist.
    //
    // If a fully qualified pathname is used in the search, then
    // allow access_denied or sharing violations to terminate the
    // search. This was the nt 3.1-4.0 behavior, and was changed for the
    // loader to handle cases where when walking through a search, we didn't
    // terminate the search early because of an inaccessible UNC path component
    // be restoring the old behavior in this case, we give the correct (access_denied)
    // error codes on fully qualified module lookups, but keep going when bumping
    // through search path components
    //

    if ( RtlDetermineDosPathNameType_U(lpFileName) != RtlPathTypeRelative ) {
        if (RtlDoesFileExists_UEx(lpFileName,TRUE) ) {
            PathLength = RtlGetFullPathName_U(
                           lpFileName,
                           nBufferLength,
                           lpBuffer,
                           lpFilePart
                           );
            return PathLength;
        } else {
            return 0;
        }
    }

    //
    // Determine if the file name contains an extension
    //
    ExtensionLength = 1;
    p = lpFileName;
    while (*p) {
        if ( *p == L'.' ) {
            ExtensionLength = 0;
            break;
        }
        p++;
    }

    //
    // If no extension was found, then determine the extension length
    // that should be used to search for the file
    //

    if ( ExtensionLength ) {
        if ( ARGUMENT_PRESENT(lpExtension) ) {
            Status = RtlInitUnicodeStringEx(&Scratch,lpExtension);
            if ( !NT_SUCCESS(Status) ) {
                return 0;
            }
            ExtensionLength = Scratch.Length;
        } else {
            ExtensionLength = 0;
        }
    }

    //
    // Compute the file name length and the path length;
    //

    Status = RtlInitUnicodeStringEx(&Scratch,lpPath);
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }
    PathLength = Scratch.Length;

    Status = RtlInitUnicodeStringEx(&Scratch,lpFileName);
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }
    FileLength = Scratch.Length;

    //
    // FUTURE-2002/02/19-ELi
    // Could chew up unnecessary memory with PathLength
    // sync up with the Str version
    //
    ComputedFileName = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            PathLength + FileLength + ExtensionLength + 3*sizeof(UNICODE_NULL)
                            );

    if ( !ComputedFileName ) {
        KdPrint(("%s: Failing due to out of memory (RtlAllocateHeap failure)\n", __FUNCTION__));
        return 0;
    }

    //
    // find ; 's in path and copy path component to computed file name
    //
    do {
        PWSTR Cursor;

        Cursor = ComputedFileName;
        while (*lpPath) {
            if (*lpPath == L';') {
                lpPath++;
                break;
            }
            *Cursor++ = *lpPath++;
        }

        if (Cursor != ComputedFileName &&
            Cursor [ -1 ] != L'\\' ) {
            *Cursor++ = L'\\';
        }
        if (*lpPath == UNICODE_NULL) {
            lpPath = NULL;
        }
        RtlCopyMemory(Cursor,lpFileName,FileLength);
        if ( ExtensionLength ) {
            RtlCopyMemory((PUCHAR)Cursor+FileLength,lpExtension,ExtensionLength+sizeof(UNICODE_NULL));
        } else {
            *(PWSTR)((PUCHAR)Cursor+FileLength) = UNICODE_NULL;
        }

        if (RtlDoesFileExists_UEx(ComputedFileName,FALSE) ) {
            PathLength = RtlGetFullPathName_U(
                           ComputedFileName,
                           nBufferLength,
                           lpBuffer,
                           lpFilePart
                           );
            RtlFreeHeap(RtlProcessHeap(), 0, ComputedFileName);
            return PathLength;
        }
    } while ( lpPath );

    RtlFreeHeap(RtlProcessHeap(), 0, ComputedFileName);
    return 0;
}


NTSTATUS
RtlDosSearchPath_Ustr(
    IN ULONG Flags,
    IN PCUNICODE_STRING Path,
    IN PCUNICODE_STRING FileName,
    IN PCUNICODE_STRING DefaultExtension OPTIONAL,
    OUT PUNICODE_STRING StaticString OPTIONAL,
    OUT PUNICODE_STRING DynamicString OPTIONAL,
    OUT PCUNICODE_STRING *FullFileNameOut OPTIONAL,
    OUT SIZE_T *FilePartPrefixCch OPTIONAL,
    OUT SIZE_T *BytesRequired OPTIONAL // includes space for trailing NULL
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    Flags - Optional flags to affect the behavior of the path search.
        Use the logical or operator (|) to combine flags.
        Defined flags include:

        RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION
            If the FileName passed in is a relative path, isolation
            redirection of the file path is applied prior to searching
            for a matching path.

    Path - search path to use when locating the file

    FileName - file name to search for

    DefaultExtension - Optional extension to apply to the file name
        if the file name does not include an extension.

    StaticString - Optional UNICODE_STRING which references an already
        allocated buffer which is used to construct the actual path
        of the file.

    DynamicString - Optional UNICODE_STRING which will be filled in with
        a dynamically allocated UNICODE_STRING if either StaticBuffer is
        not provided, or is not long enough to hold the resolved name.

        The dynamic buffer's size is reflected in the MaximumLength field
        of the UNICODE_STRING.  It will always exceed the Length of the
        string by at least two bytes, but may be even larger.

    FullFileNameOut - Optional pointer to UNICODE_STRING which points to
        the complete resolved file name.  This UNICODE_STRING is not
        allocated; it is either set equal to FileName, StaticBuffer or
        DynamicBuffer as appropriate.

Return Value:

     NTSTATUS indicating the disposition of the function.  If the file
     is redirected via activation context data, STATUS_SUCCESS is returned
     regardless of whether the file exists or not.  If the file does not
     exist in any of the directories referenced by the Path parameter,
     STATUS_NO_SUCH_FILE is returned.

--*/

{
    NTSTATUS Status;
    PWSTR Cursor;
    PWSTR EndMarker;
    SIZE_T MaximumPathSegmentLength = 0;
    SIZE_T BiggestPossibleFileName;
    USHORT DefaultExtensionLength = 0;
    RTL_PATH_TYPE PathType; // not used; required argument to RtlGetFullPathName_Ustr().
    UNICODE_STRING CandidateString;
    WCHAR StaticCandidateBuffer[DOS_MAX_PATH_LENGTH];

    CandidateString.Length = 0;
    CandidateString.MaximumLength = sizeof(StaticCandidateBuffer);
    CandidateString.Buffer = StaticCandidateBuffer;

    if (FullFileNameOut != NULL) {
        *FullFileNameOut = NULL;
    }

    if (BytesRequired != NULL) {
        *BytesRequired = 0;
    }

    if (FilePartPrefixCch != NULL) {
        *FilePartPrefixCch = 0;
    }

    if (DynamicString != NULL) {
        DynamicString->Length = 0;
        DynamicString->MaximumLength = 0;
        DynamicString->Buffer = NULL;
    }

    if (((Flags & ~(
                RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION |
                RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH |
                RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION)) != 0) ||
        (Path == NULL) ||
        (FileName == NULL) ||
        ((StaticString != NULL) && (DynamicString != NULL) && (FullFileNameOut == NULL))) {
#if DBG
        DbgPrint("%s: Invalid parameters passed\n", __FUNCTION__);
#endif // DBG
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    PathType = RtlDetermineDosPathNameType_Ustr(FileName);

    // If the caller wants to disallow .\ and ..\ relative path searches, stop them!
    if ((Flags & RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH) && (PathType == RtlPathTypeRelative)) {
        if (FileName->Length >= (2 * sizeof(WCHAR))) {
            if (FileName->Buffer[0] == L'.') {
                if (IS_PATH_SEPARATOR_U(FileName->Buffer[1])) {
                    PathType = RtlPathTypeUnknown;
                } else if ((FileName->Buffer[1] == L'.') &&
                           (FileName->Length >= (3 * sizeof(WCHAR))) &&
                           IS_PATH_SEPARATOR_U(FileName->Buffer[2])) {
                    PathType = RtlPathTypeUnknown;
                }
            }
        }
    }

    //
    // if the file name is not a relative name, then
    // return an if the file does not exist.
    //
    // If a fully qualified pathname is used in the search, then
    // allow access_denied or sharing violations to terminate the
    // search. This was the nt 3.1-4.0 behavior, and was changed for the
    // loader to handle cases where when walking through a search, we didn't
    // terminate the search early because of an inaccessible UNC path component
    // be restoring the old behavior in this case, we give the correct (access_denied)
    // error codes on fully qualified module lookups, but keep going when bumping
    // through search path components
    //

    if (PathType != RtlPathTypeRelative ) {
        if (RtlDoesFileExists_UstrEx(FileName, TRUE)) {
            Status = RtlGetFullPathName_UstrEx(
                            FileName,
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (!NT_SUCCESS(Status)) {
#if DBG
                if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
                    DbgPrint("%s: Failing because RtlGetFullPathName_UstrEx() on %wZ failed with %08lx\n", __FUNCTION__, FileName, Status);
                }
#endif // DBG
                goto Exit;
            }
        } else {
            //
            // The file wasn't there; let's try adding the default extension if we need to.
            //

            if ((DefaultExtension == NULL) || (DefaultExtension->Length == 0)) {
#if DBG
//                DbgPrint("%s: Failing because RtlDoesFileExists_UstrEx() on %wZ says it does not exist and there is no default extension to apply\n", __FUNCTION__, FileName);
#endif // DBG
                Status = STATUS_NO_SUCH_FILE;
                goto Exit;
            }

            DefaultExtensionLength = DefaultExtension->Length;

            // If they've asked for SearchPathW() bug compatibility mode, always apply the default
            // extension if the file isn't found, even if the file name has an extension.
            if (!(Flags & RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION)) {
                if (FileName->Length != 0) {
                    Cursor = FileName->Buffer + (FileName->Length / sizeof(WCHAR));

                    while (Cursor > FileName->Buffer) {
                        const WCHAR wch = *--Cursor;

                        if (IS_PATH_SEPARATOR_U(wch)) {
                            // it's a slash; we have a filename without an extension...
                            break;
                        }

                        if (wch == L'.') {
                            // There was an extension.  We're just out of luck.
                            Status = STATUS_NO_SUCH_FILE;
                            goto Exit;
                        }
                    }
                }
            }

            // We need to move the filename into a different buffer.
            BiggestPossibleFileName = (FileName->Length + DefaultExtensionLength + sizeof(WCHAR));

            if (BiggestPossibleFileName > UNICODE_STRING_MAX_BYTES) {
#if DBG
                DbgPrint("%s: Failing because the filename plus extension (%Iu bytes) is too big\n", __FUNCTION__, BiggestPossibleFileName);
#endif // DBG
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            // If the buffer on the stack isn't big enough, allocate one from the heap
            if (BiggestPossibleFileName > CandidateString.MaximumLength) {
                CandidateString.MaximumLength = (USHORT) BiggestPossibleFileName;
                CandidateString.Buffer = (RtlAllocateStringRoutine)(CandidateString.MaximumLength);
                if (CandidateString.Buffer == NULL) {
#if DBG
                    DbgPrint("%s: Failing because allocating the dynamic filename buffer failed\n", __FUNCTION__);
#endif // DBG
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }
            }

            RtlCopyMemory(CandidateString.Buffer, FileName->Buffer, FileName->Length);
            RtlCopyMemory(CandidateString.Buffer + (FileName->Length / sizeof(WCHAR)), DefaultExtension->Buffer, DefaultExtension->Length);
            CandidateString.Buffer[(FileName->Length + DefaultExtension->Length) / sizeof(WCHAR)] = UNICODE_NULL;
            CandidateString.Length = FileName->Length + DefaultExtension->Length;

            if (!RtlDoesFileExists_UstrEx(&CandidateString, TRUE)) {
                Status = STATUS_NO_SUCH_FILE;
                goto Exit;
            }

            Status = RtlGetFullPathName_UstrEx(
                            &CandidateString,
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (!NT_SUCCESS(Status)) {
#if DBG
                if (Status != STATUS_NO_SUCH_FILE) {
                    DbgPrint("%s: Failing on \"%wZ\" because RtlGetFullPathName_UstrEx() failed with status %08lx\n", __FUNCTION__, &CandidateString, Status);
                }
#endif // DBG
                goto Exit;
            }
        }

        Status = STATUS_SUCCESS;
        goto Exit;
    }

    // We know it's a relative path at this point.  Do we want to try side-by-side
    // isolation of the file?
    if (Flags & RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION) {
        PUNICODE_STRING FullPathStringFound = NULL;

        Status = RtlDosApplyFileIsolationRedirection_Ustr(
            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL, FileName,
            DefaultExtension, StaticString, DynamicString, &FullPathStringFound,
            NULL, FilePartPrefixCch, BytesRequired);
        if (NT_SUCCESS(Status)) {
            if (FullFileNameOut != NULL) {
                *FullFileNameOut = FullPathStringFound;
            }
            Status = STATUS_SUCCESS;
            goto Exit;
        }

        if (Status != STATUS_SXS_KEY_NOT_FOUND) {
#if DBG
            DbgPrint("%s: Failing because call to RtlDosApplyFileIsolationRedirection_Ustr(%wZ) failed with status 0x%08lx\n", __FUNCTION__, FileName, Status);
#endif // DBG
            goto Exit;
        }
    }

    //
    // If a default extension was provided, see if we need to account for it
    //

    if (DefaultExtension != NULL) {
        DefaultExtensionLength = DefaultExtension->Length;

        if (FileName->Length != 0) {
            Cursor = FileName->Buffer + (FileName->Length / sizeof(WCHAR));

            while (Cursor > FileName->Buffer) {
                const WCHAR wch = *--Cursor;

                if (IS_PATH_SEPARATOR_U(wch)) {
                    // it's a slash; we have a filename without an extension...
                    break;
                }

                if (wch == L'.') {
                    // There's an extension; ignore the defualt.
                    DefaultExtension = NULL;
                    DefaultExtensionLength = 0;
                    break;
                }
            }
        }
    }

    if (Path->Length != 0) {
        USHORT CchThisSegment;
        PCWSTR LastCursor;

        Cursor = Path->Buffer + (Path->Length / sizeof(WCHAR));
        LastCursor = Cursor;

        while (Cursor > Path->Buffer) {
            if (*--Cursor == L';') {
                CchThisSegment = (USHORT) ((LastCursor - Cursor) - 1);

                if (CchThisSegment != 0) {
                    // If there is not a trailing slash, add one character
                    if (!IS_PATH_SEPARATOR_U(LastCursor[-1])) {
                        CchThisSegment++;
                    }
                }

                if (CchThisSegment > MaximumPathSegmentLength) {
                    MaximumPathSegmentLength = CchThisSegment;
                }

                // LastCursor now points to the semicolon...
                LastCursor = Cursor;
            }
        }

        CchThisSegment = (USHORT) (LastCursor - Cursor);
        if (CchThisSegment != 0) {
            if (!IS_PATH_SEPARATOR_U(LastCursor[-1])) {
                CchThisSegment++;
            }
        }

        if (CchThisSegment > MaximumPathSegmentLength) {
            MaximumPathSegmentLength = CchThisSegment;
        }

        // Convert from WCHARs to bytes
        MaximumPathSegmentLength *= sizeof(WCHAR);
    }

    BiggestPossibleFileName =
        MaximumPathSegmentLength +
        FileName->Length +
        DefaultExtensionLength +
        sizeof(WCHAR); // don't forget space for a trailing NULL...

    // It's all got to fit into a UNICODE_STRING at some point, so check that that's possible
    if (BiggestPossibleFileName > UNICODE_STRING_MAX_BYTES) {
#if DBG
        DbgPrint("%s: returning STATUS_NAME_TOO_LONG because the computed worst case file name length is %Iu bytes\n", __FUNCTION__, BiggestPossibleFileName);
#endif // DBG
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    // It's tempting to allocate the dynamic buffer here, but if it turns out that
    // the file is quickly found in one of the first segments that fits in the
    // static buffer, we'll have wasted a heap alloc.

    Cursor = Path->Buffer;
    EndMarker = Cursor + (Path->Length / sizeof(WCHAR));

    while (Cursor < EndMarker) {
        PWSTR BufferToFillCursor;
        PWSTR SegmentEnd = Cursor;
        USHORT SegmentSize;
        USHORT BytesToCopy;
        UNICODE_STRING DebugString;

        // Scan ahead for the end of the path buffer or the next semicolon
        while ((SegmentEnd != EndMarker) && (*SegmentEnd != L';'))
            SegmentEnd++;

        SegmentSize = (USHORT) ((SegmentEnd - Cursor) * sizeof(WCHAR));

        DebugString.Buffer = Cursor;
        DebugString.Length = SegmentSize;
        DebugString.MaximumLength = SegmentSize;

        BytesToCopy = SegmentSize;

        // Add space for a trailing slash if there isn't one.
        if ((SegmentSize != 0) && !IS_PATH_SEPARATOR_U(SegmentEnd[-1])) {
            SegmentSize += sizeof(WCHAR);
        }

        // If the string we're using for the candidates isn't big enough, allocate one that is.
        if (CandidateString.MaximumLength < (SegmentSize + FileName->Length + DefaultExtensionLength + sizeof(WCHAR))) {
            // If CandidateString is already a dynamic buffer, something's hosed because we should have allocated
            // the largest one needed the first time we outgrew the static one.
            ASSERT(CandidateString.Buffer == StaticCandidateBuffer);
            if (CandidateString.Buffer != StaticCandidateBuffer) {
#if DBG
                DbgPrint("%s: internal error #1; CandidateString.Buffer = %p; StaticCandidateBuffer = %p\n", __FUNCTION__, CandidateString.Buffer, StaticCandidateBuffer);
#endif // DBG
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            // If this assert fires, there's either a code bug above where we computed the maximum
            // segment length, or someone's changing either the filename, default extension or
            // path around on us in another thread.  Performing a capture on the buffers seems like
            // massive overkill, so we'll just not overrun our buffers here.

            ASSERT((SegmentSize + FileName->Length + DefaultExtensionLength) < UNICODE_STRING_MAX_BYTES);
            if ((SegmentSize + FileName->Length + DefaultExtensionLength ) >
                (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))) {
#if DBG
                DbgPrint("%s: internal error #2; SegmentSize = %u, FileName->Length = %u, DefaultExtensionLength = %u\n", __FUNCTION__,
                    SegmentSize, FileName->Length, DefaultExtensionLength);
#endif // DBG
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            CandidateString.MaximumLength = (USHORT) BiggestPossibleFileName;
            CandidateString.Buffer = (RtlAllocateStringRoutine)(CandidateString.MaximumLength);
            if (CandidateString.Buffer == NULL) {
#if DBG
                DbgPrint("%s: Unable to allocate %u byte buffer for path candidate\n", __FUNCTION__, CandidateString.MaximumLength);
#endif // DBG
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }
        }

        RtlCopyMemory(
            CandidateString.Buffer,
            Cursor,
            BytesToCopy);

        BufferToFillCursor = CandidateString.Buffer + (BytesToCopy / sizeof(WCHAR));

        // Add a trailing slash if it was omitted. It's safe to index [-1] since
        // we know that SegmentSize != 0.
        if ((SegmentSize != 0) && (BytesToCopy != SegmentSize))
            *BufferToFillCursor++ = L'\\';

        RtlCopyMemory(
            BufferToFillCursor,
            FileName->Buffer,
            FileName->Length);
        BufferToFillCursor += (FileName->Length / sizeof(WCHAR));

        if (DefaultExtension != NULL) {
            RtlCopyMemory(
                BufferToFillCursor,
                DefaultExtension->Buffer,
                DefaultExtension->Length);

            BufferToFillCursor += (DefaultExtension->Length / sizeof(WCHAR));
        }

        // And top it off with a unicode null...
        *BufferToFillCursor = UNICODE_NULL;

        CandidateString.Length = (USHORT) ((BufferToFillCursor - CandidateString.Buffer) * sizeof(WCHAR));

        if (RtlDoesFileExists_UEx(CandidateString.Buffer, FALSE)) {
            // Run it through the path canonicalizer...
            Status = RtlGetFullPathName_UstrEx(
                            &CandidateString,
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (NT_SUCCESS(Status))
                Status = STATUS_SUCCESS;
            else {
#if DBG
                if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
                    DbgPrint("%s: Failing because we thought we found %wZ on the search path, but RtlGetFullPathName_UstrEx() returned %08lx\n", __FUNCTION__, FileName, Status);
                }
#endif // DBG
            }

            goto Exit;
        }

        if (SegmentEnd != EndMarker)
            Cursor = SegmentEnd + 1;
        else
            Cursor = SegmentEnd;
    }

    Status = STATUS_NO_SUCH_FILE;

Exit:
    if ((CandidateString.Buffer != NULL) &&
        (CandidateString.Buffer != StaticCandidateBuffer)) {
        RtlFreeUnicodeString(&CandidateString);
    }

    return Status;
}


VOID
RtlpCheckRelativeDrive(
    WCHAR NewDrive
    )

/*++

Routine Description:

    This function is called whenever we are asked to expand a non
    current directory drive relative name ( f:this\is\my\file ).  In
    this case, we validate the environment variable string to make sure
    the current directory at that drive is valid. If not, we trim back to
    the root.

Arguments:

    NewDrive - Supplies the drive to check

Return Value:

    None.

--*/

{

    WCHAR EnvVarValueBuffer[DOS_MAX_PATH_LENGTH+12]; // + sizeof (\DosDevices\)
    WCHAR EnvVarNameBuffer[4];
    UNICODE_STRING EnvVarName;
    UNICODE_STRING EnvValue;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE DirHandle;
    ULONG HardErrorValue;

    EnvVarNameBuffer[0] = L'=';
    EnvVarNameBuffer[1] = (WCHAR)NewDrive;
    EnvVarNameBuffer[2] = L':';
    EnvVarNameBuffer[3] = UNICODE_NULL;
    RtlInitUnicodeString(&EnvVarName,EnvVarNameBuffer);


    //
    // capture the value in a buffer that has space at the front for the dos devices
    // prefix
    //

    EnvValue.Length = 0;
    EnvValue.MaximumLength = DOS_MAX_PATH_LENGTH<<1;
    EnvValue.Buffer = &EnvVarValueBuffer[RtlpDosDevicesPrefix.Length>>1];

    Status = RtlQueryEnvironmentVariable_U( NULL,
                                            &EnvVarName,
                                            &EnvValue
                                          );
    if ( !NT_SUCCESS( Status ) ) {

        //
        // Otherwise default to root directory of drive
        //

        EnvValue.Buffer[0] = (WCHAR)NewDrive;
        EnvValue.Buffer[1] = L':';
        EnvValue.Buffer[2] = L'\\';
        EnvValue.Buffer[3] = UNICODE_NULL;
        EnvValue.Length = 6;
        }

    //
    // Form the NT name for this directory
    //

    EnvValue.Length = EnvValue.Length + RtlpDosDevicesPrefix.Length;

    EnvValue.MaximumLength = sizeof(EnvVarValueBuffer);
    EnvValue.Buffer = EnvVarValueBuffer;
    RtlCopyMemory(EnvVarValueBuffer,RtlpDosDevicesPrefix.Buffer,RtlpDosDevicesPrefix.Length);

    InitializeObjectAttributes(
        &Obja,
        &EnvValue,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    RtlSetThreadErrorMode(RTL_ERRORMODE_FAILCRITICALERRORS,
                          &HardErrorValue);

    Status = NtOpenFile(
                &DirHandle,
                SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );

    RtlSetThreadErrorMode(HardErrorValue, NULL);

    //
    // If the open succeeds, then the directory is valid... No need to do anything
    // further. If the open fails, then trim back the environment to the root.
    //

    if ( NT_SUCCESS(Status) ) {
        NtClose(DirHandle);
        return;
        }

    RtlpResetDriveEnvironment(NewDrive);
}

#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT   (0x00000001)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS         (0x00000002)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT               (0x00000003)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS              (0x00000004)


NTSTATUS
NTAPI
RtlpGetLengthWithoutLastPathElement(
    IN  ULONG            Flags,
    IN  ULONG            PathType,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.
    This is much simpler than RtlRemoveLastDosPathElement.
    It is used to implement the other RtlRemoveLast*PathElement.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path or a full DOS path; the various relative DOS
        path types do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    ULONG Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE DosPathType = RtlPathTypeUnknown;
    ULONG DosPathFlags = 0;
    ULONG AllowedDosPathTypeBits =   (1UL << RtlPathTypeRooted)
                                   | (1UL << RtlPathTypeUncAbsolute)
                                   | (1UL << RtlPathTypeDriveAbsolute)
                                   | (1UL << RtlPathTypeLocalDevice)     // "\\?\"
                                   | (1UL << RtlPathTypeRootLocalDevice) // "\\?"
                                   ;
    WCHAR PathSeperators[2] = { '/', '\\' };

#define LOCAL_IS_PATH_SEPARATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (LengthOut != NULL) {
        *LengthOut = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Length = RTL_STRING_GET_LENGTH_CHARS(Path);

    switch (PathType)
    {
    default:
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT:
        //
        // RtlpDetermineDosPathNameType4 calls it "rooted"
        // only backslashes are seperators
        // path must start with backslash
        // second char must not be backslash
        //
        AllowedDosPathTypeBits = (1UL << RtlPathTypeRooted);
        PathSeperators[0] = '\\';
        if (Length > 0 && Path->Buffer[0] != '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (Length > 1 && Path->Buffer[1] == '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS:
        AllowedDosPathTypeBits &= ~(1UL << RtlPathTypeRooted);
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT:
        break;
    }

    if (Length == 0) {
        goto Exit;
    }

    Status = RtlpDetermineDosPathNameType4(
                RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT,
                Path,
                &DosPathType,
                &DosPathFlags
                );

    if (!RTL_SOFT_VERIFY(NT_SUCCESS(Status))) {
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY((1UL << DosPathType) & AllowedDosPathTypeBits)
        ) {
        //KdPrintEx();
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (!RTL_SOFT_VERIFY(
           (DosPathFlags & RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID) == 0
            )) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // skip one or more trailing path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip trailing path element
    for ( ; Length != 0 && !LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip one or more in between path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // put back a trailing path seperator, for the sake of c:\ vs. c:
    if (Length != 0) {
        ++Length;
    }

    //
    // Should optionally check for "bad dos roots" here.
    //

    *LengthOut = Length;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
#undef LOCAL_IS_PATH_SEPARATOR
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT, Path, LengthOut);
    return Status;
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosOrNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT, Path, LengthOut);
    return Status;
}


CONST CHAR*
RtlpDbgBadDosRootPathTypeToString(
    IN ULONG         Flags,
    IN ULONG         RootType
    )
/*++

Routine Description:

  An aid to writing DbgPrint code.

Arguments:

    Flags - room for future binary compatible expansion

    RootType - fairly specifically what the string is
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX       - \\? or \\?\
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX   - \\?\unc or \\?\unc\
        RTLP_BAD_DOS_ROOT_PATH_NT_PATH              - \??\ but this is only a rough check
        RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE     - \\machine or \\?\unc\machine
        RTLP_GOOD_DOS_ROOT_PATH                     - none of the above, seems ok

Return Value:

    strings like those that describe RootType or "unknown" or empty in free builds
--*/
{
    CONST CHAR* s = "";
#if DBG
    if (Flags != 0) {
        DbgPrint("Invalid parameter to %s ignored\n", __FUNCTION__);
    }
    switch (RootType
        ) {
        case RTLP_GOOD_DOS_ROOT_PATH                  : s = "good"; break;
        case RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX    : s = "\\\\?\\"; break;
        case RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX: s = "\\\\?\\unc"; break;
        case RTLP_BAD_DOS_ROOT_PATH_NT_PATH           : s = "\\??\\"; break;
        case RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE  : s = "\\\\machine or \\\\?\\unc\\machine"; break;
        default:
            s = "unknown";
            DbgPrint("Invalid parameter %0x08Ix to %s ignored\n", RootType, __FUNCTION__);
            break;

    }
#else
    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (RootType);
#endif

    return s;
}


NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  Path,
    OUT ULONG*           RootType
    )
/*++

Routine Description:


Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked

    RootType - fairly specifically what the string is
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX       - \\? or \\?\
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX   - \\?\unc or \\?\unc\
        RTLP_BAD_DOS_ROOT_PATH_NT_PATH              - \??\ but this i only a rough check
        RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE     - \\machine or \\?\unc\machine
        RTLP_GOOD_DOS_ROOT_PATH                     - none of the above, seems ok

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    ULONG Length = 0;
    ULONG Index = 0;
    BOOLEAN Unc = FALSE;
    BOOLEAN Unc1 = FALSE;
    BOOLEAN Unc2 = FALSE;
    ULONG PiecesSeen = 0;

    if (RootType != NULL) {
        *RootType = 0;
    }

    if (!RTL_SOFT_VERIFY(Path != NULL) ||
        !RTL_SOFT_VERIFY(RootType != NULL) ||
        !RTL_SOFT_VERIFY(Flags == 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    Length = Path->Length / sizeof(Path->Buffer[0]);

    if (Length < 3 || !RTL_IS_PATH_SEPARATOR(Path->Buffer[0])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    // prefix \??\ (heuristic, doesn't catch many NT paths)
    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), RTL_CONST_CAST(PUNICODE_STRING)(Path), TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_NT_PATH;
        return STATUS_SUCCESS;
    }

    if (!RTL_IS_PATH_SEPARATOR(Path->Buffer[1])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    // == \\?
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        return STATUS_SUCCESS;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        return STATUS_SUCCESS;
    }

    // == \\?\unc
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        return STATUS_SUCCESS;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        return STATUS_SUCCESS;
    }

    // prefix \\ or \\?\unc
    // must check the longer string first, or avoid the short circuit (| instead of ||)
    Unc1 = RtlPrefixUnicodeString(&RtlpWin32NtUncRootSlash, Path, TRUE);

    if (RTL_IS_PATH_SEPARATOR(Path->Buffer[1])) {
        Unc2 = TRUE;
    }
    else {
        Unc2 = FALSE;
    }

    Unc = Unc1 || Unc2;

    if (!Unc)  {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    //
    // it's unc, see if it is only a machine (note that it'd be really nice if FindFirstFile(\\machine\*)
    // just worked and we didn't have to care..)
    //

    // point index at a slash that precedes the machine, anywhere in the run of slashes,
    // but after the \\? stuff
    if (Unc1) {
        Index = (RtlpWin32NtUncRootSlash.Length / sizeof(RtlpWin32NtUncRootSlash.Buffer[0])) - 1;
    } else {
        ASSERT(Unc2);
        Index = 1;
    }
    ASSERT(RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]));
    Length = Path->Length/ sizeof(Path->Buffer[0]);

    //
    // skip leading slashes
    //
    for ( ; Index < Length && RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 1;
    }
    // skip the machine name
    for ( ; Index < Length && !RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 2;
    }
    // skip the slashes between machine and share
    for ( ; Index < Length && RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 4;
    }

    //
    // Skip the share (make sure it's at least one char).
    //

    if (Index < Length && !RTL_IS_PATH_SEPARATOR(Path->Buffer[Index])) {
        PiecesSeen |= 8;
    }

    if (PiecesSeen != 0xF) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    )
/*++

Routine Description:


Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked and possibly emptied

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status;
    ULONG    RootType = 0;

    UNREFERENCED_PARAMETER (Flags);

    Status = RtlpCheckForBadDosRootPath(0, Path, &RootType);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // this is not invalid parameter, our contract is we
    // go \\machine\share to empty \\?\c: to empty, etc.
    //

    if (RootType != RTLP_GOOD_DOS_ROOT_PATH) {
        if (RootType == RTLP_BAD_DOS_ROOT_PATH_NT_PATH) {
            return STATUS_INVALID_PARAMETER;
        }
        Path->Length = 0;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Given a fulldospath, like c:\, \\machine\share, \\?\unc\machine\share, \\?\c:,
    return (in an out parameter) the length if the last element was cut off.

Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be truncating

    LengthOut - the length if the last path element is removed

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CheckRootString = { 0 };

    //
    // parameter validation is done in RtlpGetLengthWithoutLastPathElement
    //

    Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS, Path, LengthOut);
    if (!(NT_SUCCESS(Status))) {
        goto Exit;
    }

    CheckRootString.Buffer = Path->Buffer;
    CheckRootString.Length = (USHORT)(*LengthOut * sizeof(*Path->Buffer));
    CheckRootString.MaximumLength = CheckRootString.Length;
    if (!NT_SUCCESS(Status = RtlpBadDosRootPathToEmptyString(0, &CheckRootString))) {
        goto Exit;
    }
    *LengthOut = RTL_STRING_GET_LENGTH_CHARS(&CheckRootString);

    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}


NTSTATUS
NTAPI
RtlAppendPathElement(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    PCUNICODE_STRING                  ConstElement
    )
/*++

Routine Description:

    This function appends a path element to a path.
    For now, like:
        typedef PRTL_UNICODE_STRING_BUFFER PRTL_MUTABLE_PATH;
        typedef PCUNICODE_STRING           PCRTL_CONSTANT_PATH_ELEMENT;
    Maybe something higher level in the future.

    The result with regard to trailing slashes aims to be similar to the inputs.
    If either Path or ConstElement contains a trailing slash, the result has a trailing slash.
    The character used for the in between and trailing slash is picked among the existing
    slashes in the strings.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    Path -
        a string representing a path using \\ or / as seperators

    ConstElement -
        a string representing a path element
        this can actually contain multiple \\ or / delimited path elements
          only the start and end of the string are examined for slashes

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
    STATUS_NO_MEMORY - RtlHeapAllocate failed
    STATUS_NAME_TOO_LONG - the resulting string does not fit in a UNICODE_STRING, due to its
        use of USHORT instead of ULONG or SIZE_T
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING InBetweenSlashString = RtlpEmptyString;
    UNICODE_STRING TrailingSlashString =  RtlpEmptyString;
    WCHAR Slashes[] = {0,0,0,0};
    ULONG i;
    UNICODE_STRING PathsToAppend[3]; // possible slash, element, possible slash
    WCHAR PathSeperators[2] = { '/', '\\' };
    const ULONG ValidFlags =
              RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR
            | RTL_APPEND_PATH_ELEMENT_BUGFIX_CHECK_FIRST_THREE_CHARS_FOR_SLASH_TAKE_FOUND_SLASH_INSTEAD_OF_FIRST_CHAR
            ;
    const ULONG InvalidFlags = ~ValidFlags;

#define LOCAL_IS_PATH_SEPARATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (   !RTL_SOFT_VERIFY((Flags & InvalidFlags) == 0)
        || !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(ConstElement != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) != 0) {
        PathSeperators[0] = '\\';
    }

    if (ConstElement->Length != 0) {

        UNICODE_STRING Element = *ConstElement;

        //
        // Note leading and trailing slashes on the inputs.
        // So that we know if an in-between slash is needed, and if a trailing slash is needed,
        // and to guide what sort of slash to place.
        //
        i = 0;
        if (Path->String.Length != 0) {
            ULONG j;
            ULONG Length = Path->String.Length / sizeof(WCHAR);
            //
            // for the sake for dos drive paths, check the first three chars for a slash
            //
            for (j = 0 ; j < 3 && j  < Length ; ++j) {
                if (LOCAL_IS_PATH_SEPARATOR(Path->String.Buffer[j])) {
                    if (Flags & RTL_APPEND_PATH_ELEMENT_BUGFIX_CHECK_FIRST_THREE_CHARS_FOR_SLASH_TAKE_FOUND_SLASH_INSTEAD_OF_FIRST_CHAR) {
                        Slashes[i] = Path->String.Buffer[j];
                        break;
                    }
                    Slashes[i] = Path->String.Buffer[0];
                    break;
                }
            }
            i += 1;
            if (LOCAL_IS_PATH_SEPARATOR(Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1])) {
                Slashes[i] = Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1];
            }
        }
        i = 2;
        if (LOCAL_IS_PATH_SEPARATOR(Element.Buffer[0])) {
            Slashes[i] = Element.Buffer[0];
        }
        i += 1;
        if (LOCAL_IS_PATH_SEPARATOR(Element.Buffer[Element.Length/sizeof(WCHAR) - 1])) {
            Slashes[i] = Element.Buffer[Element.Length/sizeof(WCHAR) - 1];
        }

        if (!Slashes[1] && !Slashes[2]) {
            //
            // first string lacks trailing slash and second string lacks leading slash,
            // must insert one; we favor the types we have, otherwise use a default
            //
            InBetweenSlashString.Length = sizeof(WCHAR);
            InBetweenSlashString.Buffer = RtlPathSeperatorString.Buffer;
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                if (Slashes[3]) {
                    InBetweenSlashString.Buffer = &Slashes[3];
                } else if (Slashes[0]) {
                    InBetweenSlashString.Buffer = &Slashes[0];
                }
            }
        }

        if (Slashes[1] && !Slashes[3]) {
            //
            // first string has a trailing slash and second string does not,
            // must add one, the same type
            //
            TrailingSlashString.Length = sizeof(WCHAR);
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                TrailingSlashString.Buffer = &Slashes[1];
            } else {
                TrailingSlashString.Buffer = RtlPathSeperatorString.Buffer;
            }
        }

        if (Slashes[1] && Slashes[2]) {
            //
            // have both trailing and leading slash, remove leading
            //
            Element.Buffer += 1;
            Element.Length -= sizeof(WCHAR);
            Element.MaximumLength -= sizeof(WCHAR);
        }

        i = 0;
        PathsToAppend[i++] = InBetweenSlashString;
        PathsToAppend[i++] = Element;
        PathsToAppend[i++] = TrailingSlashString;
        Status = RtlMultiAppendUnicodeStringBuffer(Path, RTL_NUMBER_OF(PathsToAppend), PathsToAppend);
        if (!NT_SUCCESS(Status))
            goto Exit;
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ, %wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path ? &Path->String : NULL, ConstElement, Status));
    return Status;
#undef LOCAL_IS_PATH_SEPARATOR
}

//
// FUTURE-2002/02/20-ELi
// Spelling mistake (Separators)
// This function does not appear to be used and is exported
// Figure out if it can be removed
//
NTSTATUS
NTAPI
RtlGetLengthWithoutTrailingPathSeperators(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    This function computes the length of the string (in characters) if
    trailing path seperators (\\ and /) are removed.

Arguments:

    Path -
        a string representing a path using \\ or / as seperators

    LengthOut -
        the length of String (in characters) having removed trailing characters

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    ULONG Length = 0;

    if (LengthOut != NULL) {
        //
        // Arguably this should be Path->Length / sizeof(*Path->Buffer), but as long
        // as the callstack is all high quality code, it doesn't matter.
        //
        *LengthOut = 0;
    }
    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    Length = Path->Length / sizeof(*Path->Buffer);
    for (Index = Length ; Index != 0 ; --Index) {
        if (!RTL_IS_PATH_SEPARATOR(Path->Buffer[Index - 1])) {
            break;
        }
    }
    //*LengthOut = (Length - Index);
    *LengthOut = Index;

    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}


NTSTATUS
NTAPI
RtlpApplyLengthFunction(
    IN ULONG     Flags,
    IN SIZE_T    SizeOfStruct,
    IN OUT PVOID UnicodeStringOrUnicodeStringBuffer,
    NTSTATUS (NTAPI* LengthFunction)(ULONG, PCUNICODE_STRING, ULONG*)
    )
/*++

Routine Description:

    This function is common code for patterns like
        #define RtlRemoveTrailingPathSeperators(Path_) \
            (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutTrailingPathSeperators))

    #define RtlRemoveLastPathElement(Path_) \
        (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutLastPathElement))

    Note that shortening a UNICODE_STRING only changes the length, whereas
    shortening a RTL_UNICODE_STRING_BUFFER writes a terminal nul.

    I expect this pattern will be less error prone than having clients pass the UNICODE_STRING
    contained in the RTL_UNICODE_STRING_BUFFER followed by calling RTL_NUL_TERMINATE_STRING.

    And, that pattern cannot be inlined with a macro while also preserving that we
    return an NTSTATUS.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    UnicodeStringOrUnicodeStringBuffer -
        a PUNICODE_STRING or PRTL_UNICODE_STRING_BUFFER, as indicated by
        SizeOfStruct

    SizeOfStruct -
        a rough type indicator of UnicodeStringOrUnicodeStringBuffer, to allow for overloading in C

    LengthFunction -
        computes a length for UnicodeStringOrUnicodeStringBuffer to be shortened too

Return Value:

    STATUS_SUCCESS -
    STATUS_INVALID_PARAMETER -
        SizeOfStruct not one of the expected sizes
        or LengthFunction is NULL
        or UnicodeStringOrUnicodeStringBuffer is NULL


--*/
{
    PUNICODE_STRING UnicodeString = NULL;
    PRTL_UNICODE_STRING_BUFFER UnicodeStringBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;

    if (!RTL_SOFT_VERIFY(UnicodeStringOrUnicodeStringBuffer != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(LengthFunction != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(Flags == 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    switch (SizeOfStruct)
    {
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        case sizeof(*UnicodeString):
            UnicodeString = UnicodeStringOrUnicodeStringBuffer;
            break;
        case sizeof(*UnicodeStringBuffer):
            UnicodeStringBuffer = UnicodeStringOrUnicodeStringBuffer;
            UnicodeString = &UnicodeStringBuffer->String;
            break;
    }

    Status = (*LengthFunction)(Flags, UnicodeString, &Length);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (Length > (UNICODE_STRING_MAX_BYTES / sizeof(UnicodeString->Buffer[0])) ) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }
    UnicodeString->Length = (USHORT)(Length * sizeof(UnicodeString->Buffer[0]));
    if (UnicodeStringBuffer != NULL) {
        RTL_NUL_TERMINATE_STRING(UnicodeString);
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, UnicodeString, Status));
    return Status;
}


NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T NtFilePartOffset = 0;
    const static UNICODE_STRING DosUncPrefix = RTL_CONSTANT_STRING(L"\\\\");
    PCUNICODE_STRING NtPrefix = NULL;
    PCUNICODE_STRING DosPrefix = NULL;
    RTL_STRING_LENGTH_TYPE Cch = 0;

    if (ARGUMENT_PRESENT(Disposition)) {
        *Disposition = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ARGUMENT_PRESENT(FilePart) && *FilePart != NULL) {
        NtFilePartOffset = *FilePart - Path->String.Buffer;
        if (!RTL_SOFT_VERIFY(NtFilePartOffset < RTL_STRING_GET_LENGTH_CHARS(&Path->String))
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (RtlPrefixUnicodeString(&RtlpDosDevicesUncPrefix, &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesUncPrefix;
        DosPrefix = &DosUncPrefix;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC;
        }
    }
    else if (RtlPrefixUnicodeString(&RtlpDosDevicesPrefix, &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesPrefix;
        DosPrefix = &RtlpEmptyString;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE;
        }
    }
    else {
        //
        // It is not recognizably an Nt path produced by RtlDosPathNameToNtPathName_U.
        //
        if (ARGUMENT_PRESENT(Disposition)) {
            RTL_PATH_TYPE PathType = RtlDetermineDosPathNameType_Ustr(&Path->String);
            switch (PathType) {
                case RtlPathTypeUnknown:
                case RtlPathTypeRooted: // NT paths are identified as this
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                //
                // "already" dospaths, but not gotten from this function, let's
                // give a less good disposition
                //
                case RtlPathTypeDriveRelative:
                case RtlPathTypeRelative:
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                // these are pretty clearly dospaths already
                case RtlPathTypeUncAbsolute:
                case RtlPathTypeDriveAbsolute:
                case RtlPathTypeLocalDevice: // "\\?\" or "\\.\" or "\\?\blah" or "\\.\blah"
                case RtlPathTypeRootLocalDevice: // "\\?" or "\\."
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS;
                    break;
            }
        }
        goto Exit;
    }

    //
    // Path->String is bound by MAXUSHORT/sizeof(WCHAR) and
    // DosPrefix and NtPrefix are const small strings.
    //
    Cch =
              RTL_STRING_GET_LENGTH_CHARS(&Path->String)
            + RTL_STRING_GET_LENGTH_CHARS(DosPrefix)
            - RTL_STRING_GET_LENGTH_CHARS(NtPrefix);

    Status =
        RtlEnsureUnicodeStringBufferSizeChars(Path, Cch);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // overlapping buffer shuffle...careful.
    //
    RtlMoveMemory(
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(DosPrefix),
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(NtPrefix),
        Path->String.Length - NtPrefix->Length
        );
    RtlCopyMemory(
        Path->String.Buffer,
        DosPrefix->Buffer,
        DosPrefix->Length
        );
    Path->String.Length = Cch * sizeof(Path->String.Buffer[0]);
    RTL_NUL_TERMINATE_STRING(&Path->String);

    if (NtFilePartOffset != 0) {
        // review/test..
        *FilePart = Path->String.Buffer + (NtFilePartOffset - RTL_STRING_GET_LENGTH_CHARS(NtPrefix) + RTL_STRING_GET_LENGTH_CHARS(DosPrefix));
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\dllssstb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllssstb.c

Abstract:

    Debug Subsystem DbgSs API Stubs

Author:

    Mark Lucovsky (markl) 22-Jan-1990

Revision History:

--*/

#include "dbgdllp.h"
#include "ldrp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\i386.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\frame.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    frame.c

Abstract:

    Code to set/restore the active frame pointer in the TEB for
    additional debugging assistance.

Author:

    Michael Grier (mgrier) 3/2/2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
    const PTEB Teb = NtCurrentTeb();
    Frame->Previous = Teb->ActiveFrame;
    Teb->ActiveFrame = Frame;
}

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
    const PTEB Teb = NtCurrentTeb();
    Teb->ActiveFrame = Frame->Previous;
}

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID
    )
{
    return NtCurrentTeb()->ActiveFrame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\error.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the per-thread errormode code.

Author:

    Rob Earhart (earhart) 30-Apr-2002

Environment:

    User Mode only

Revision History:

--*/

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wow64t.h>

NTSTATUS
NTAPI
RtlSetThreadErrorMode(
    IN  ULONG  NewMode,
    OUT PULONG OldMode OPTIONAL
    )
{
#if defined(BUILD_WOW6432)
    PTEB64 Teb = NtCurrentTeb64();
#else
    PTEB Teb = NtCurrentTeb();
#endif

    if (NewMode & ~(RTL_ERRORMODE_FAILCRITICALERRORS |
                    RTL_ERRORMODE_NOGPFAULTERRORBOX |
                    RTL_ERRORMODE_NOOPENFILEERRORBOX)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (OldMode) {
        *OldMode = Teb->HardErrorMode;
    }
    Teb->HardErrorMode = NewMode;

    return TRUE;
}

ULONG
NTAPI
RtlGetThreadErrorMode(
    VOID
    )
{
#if defined(BUILD_WOW6432)
    return NtCurrentTeb64()->HardErrorMode;
#else
    return NtCurrentTeb()->HardErrorMode;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\csrutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllutil.c

Abstract:

    This module contains utility procedures for the Windows Client DLL

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#pragma warning(disable:4201)   // nameless struct/union

#include "csrdll.h"


NTSTATUS
CsrClientCallServer (
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    )

/*++

Routine Description:

    This function sends an API request to the Windows Emulation Subsystem
    Server and waits for a reply.

Arguments:

    m - Pointer to the API request message to send.

    CaptureBuffer - Optional pointer to a capture buffer located in the
        Port Memory section that contains additional data being sent
        to the server.  Since Port Memory is also visible to the server,
        no data needs to be copied, but pointers to locations within the
        capture buffer need to be converted into pointers valid in the
        server's process context, since the server's view of the Port Memory
        is not at the same virtual address as the client's view.

    ApiNumber - Small integer that is the number of the API being called.

    ArgLength - Length, in bytes, of the argument portion located at the
        end of the request message.  Used to calculate the length of the
        request message.

Return Value:

    Status Code from either client or server

--*/

{
    NTSTATUS Status;
    PULONG_PTR PointerOffsets;
    ULONG CountPointers;
    ULONG_PTR Pointer;

    //
    // Initialize the header of the message.
    //

    if ((LONG)ArgLength < 0) {
        ArgLength = (ULONG)(-(LONG)ArgLength);
        m->h.u2.s2.Type = 0;
    }
    else {
        m->h.u2.ZeroInit = 0;
    }

    ArgLength |= (ArgLength << 16);
    ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m->u )) << 16) |
                     (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m->h ));
    m->h.u1.Length = ArgLength;
    m->CaptureBuffer = NULL;
    m->ApiNumber = ApiNumber;

    //
    // if the caller is within the server process, do the API call directly
    // and skip the capture buffer fixups and LPC call.
    //

    if (CsrServerProcess == FALSE) {

        //
        // If the CaptureBuffer argument is present, then there is data located
        // in the Port Memory section that is being passed to the server.  All
        // Port Memory pointers need to be converted so they are valid in the
        // Server's view of the Port Memory.
        //

        if (ARGUMENT_PRESENT (CaptureBuffer)) {

            //
            // Store a pointer to the capture buffer in the message that is
            // valid in the server process's context.
            //

            m->CaptureBuffer = (PCSR_CAPTURE_HEADER)
                ((PCHAR)CaptureBuffer + CsrPortMemoryRemoteDelta);

            //
            // Mark the fact that we are done allocating space from the end of
            // the capture buffer.
            //

            CaptureBuffer->FreeSpace = NULL;

            //
            // Loop over all of the pointers to Port Memory within the message
            // itself and convert them into server pointers.  Also, convert
            // the pointers to pointers into offsets.
            //

            PointerOffsets = CaptureBuffer->MessagePointerOffsets;
            CountPointers = CaptureBuffer->CountMessagePointers;
            while (CountPointers--) {
                Pointer = *PointerOffsets++;
                if (Pointer != 0) {
                    *(PULONG_PTR)Pointer += CsrPortMemoryRemoteDelta;
                    PointerOffsets[ -1 ] = Pointer - (ULONG_PTR)m;
                }
            }
        }

        //
        // Send the request to the server and wait for a reply.
        //

        Status = NtRequestWaitReplyPort (CsrPortHandle,
                                         (PPORT_MESSAGE)m,
                                         (PPORT_MESSAGE)m);

        //
        // If the CaptureBuffer argument is present then reverse what we did
        // to the pointers above so that the client side code can use them
        // again.
        //

        if (ARGUMENT_PRESENT (CaptureBuffer)) {

            //
            // Convert the capture buffer pointer back to a client pointer.
            //

            m->CaptureBuffer = (PCSR_CAPTURE_HEADER)
                ((PCHAR)m->CaptureBuffer - CsrPortMemoryRemoteDelta);

            //
            // Loop over all of the pointers to Port Memory within the message
            // itself and convert them into client pointers.  Also, convert
            // the offset pointers to pointers into back into pointers
            //

            PointerOffsets = CaptureBuffer->MessagePointerOffsets;
            CountPointers = CaptureBuffer->CountMessagePointers;
            while (CountPointers--) {
                Pointer = *PointerOffsets++;
                if (Pointer != 0) {
                    Pointer += (ULONG_PTR)m;
                    PointerOffsets[ -1 ] = Pointer;
                    *(PULONG_PTR)Pointer -= CsrPortMemoryRemoteDelta;
                }
            }
        }

        //
        // Check for failed status and do something.
        //

        if (!NT_SUCCESS (Status)) {
#if DBG
                if (Status != STATUS_PORT_DISCONNECTED &&
                    Status != STATUS_INVALID_HANDLE) {

                    DbgPrint( "CSRDLL: NtRequestWaitReplyPort failed - Status == %X\n",
                              Status);
                }
#endif
            m->ReturnValue = Status;
        }

    } else {

        m->h.ClientId = NtCurrentTeb()->ClientId;

        Status = (CsrServerApiRoutine) ((PCSR_API_MSG)m,
                                        (PCSR_API_MSG)m);

        //
        // Check for failed status and do something.
        //

        if (!NT_SUCCESS( Status )) {
#if DBG
                DbgPrint( "CSRDLL: Server side client call failed - Status == %X\n",
                          Status);
#endif

            m->ReturnValue = Status;
        }
    }

    //
    // The value of this function is whatever the server function returned.
    //

    return m->ReturnValue;
}


HANDLE
CsrGetProcessId (
    VOID
    )
/*++

Routine Description:

    This function gets the process ID of the CSR process (for the session)

Arguments:

    None

Return Value:

    Process ID of CSR

--*/

{
    return CsrProcessId;
}


PCSR_CAPTURE_HEADER
CsrAllocateCaptureBuffer (
    IN ULONG CountMessagePointers,
    IN ULONG Size
    )

/*++

Routine Description:

    This function allocates a buffer from the Port Memory section for
    use by the client in capture arguments into Port Memory.  In addition to
    specifying the size of the data that needs to be captured, the caller
    needs to specify how many pointers to captured data will be passed.
    Pointers can be located in either the request message itself, and/or
    the capture buffer.

Arguments:

    CountMessagePointers - Number of pointers within the request message
        that will point to locations within the allocated capture buffer.

    Size - Total size of the data that will be captured into the capture
        buffer.

Return Value:

    A pointer to the capture buffer header.

--*/

{
    ULONG CountPointers, SizePointers;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG RemainingSize;

    //
    // Calculate the total number of pointers that will be passed
    //

    CountPointers = CountMessagePointers;

    //
    // Calculate the total size of the capture buffer.  This includes the
    // header, the array of pointer offsets and the data length.  We round
    // the data length to a 32-bit boundary, assuming that each pointer
    // points to data whose length is not aligned on a 32-bit boundary.
    //

    RemainingSize = (MAXLONG & ~0x3) - FIELD_OFFSET(CSR_CAPTURE_HEADER,
                                                    MessagePointerOffsets);

    //
    // Bail early if too big.
    //
    if ((Size >= RemainingSize) ||
        (CountPointers > (MAXLONG/sizeof(PVOID)))
        ) {
        return NULL;
    }

    RemainingSize -= Size;
    SizePointers = CountPointers * sizeof(PVOID);

    if (SizePointers >= RemainingSize) {
        return NULL;
    }

    RemainingSize -= SizePointers;

    if ((CountPointers+1) >= (RemainingSize/3) ) {
        return NULL;
    }

    Size += FIELD_OFFSET(CSR_CAPTURE_HEADER, MessagePointerOffsets) +
            SizePointers;

    Size = (Size + (3 * (CountPointers+1))) & ~3;

    //
    // Allocate the capture buffer from the Port Memory Heap.
    //

    CaptureBuffer = RtlAllocateHeap (CsrPortHeap,
                                     MAKE_CSRPORT_TAG( CAPTURE_TAG ),
                                     Size);

    if (CaptureBuffer == NULL) {

        //
        // FIX, FIX - need to attempt the receive lost reply messages to
        // to see if they contain CaptureBuffer pointers that can be freed.
        //

        return NULL;
    }

    //
    // Initialize the capture buffer header
    //

    CaptureBuffer->Length = Size;
    CaptureBuffer->CountMessagePointers = 0;

    //
    // If there are pointers being passed then initialize the arrays of
    // pointer offsets to zero.  In either case set the free space pointer
    // in the capture buffer header to point to the first 32-bit aligned
    // location after the header, the arrays of pointer offsets are considered
    // part of the header.
    //

    RtlZeroMemory (CaptureBuffer->MessagePointerOffsets,
                   CountPointers * sizeof (ULONG_PTR));

    CaptureBuffer->FreeSpace = (PCHAR)
        (CaptureBuffer->MessagePointerOffsets + CountPointers);

    //
    // Return the address of the capture buffer.
    //

    return CaptureBuffer;
}


VOID
CsrFreeCaptureBuffer (
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    )

/*++

Routine Description:

    This function frees a capture buffer allocated by CsrAllocateCaptureBuffer.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

Return Value:

    None.

--*/

{
    //
    // Free the capture buffer back to the Port Memory heap.
    //

    RtlFreeHeap (CsrPortHeap, 0, CaptureBuffer);
}


ULONG
CsrAllocateMessagePointer (
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    )

/*++

Routine Description:

    This function allocates space from the capture buffer along with a
    pointer to point to it.  The pointer is presumed to be located in
    the request message structure.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    Length - Size of data being allocated from the capture buffer.

    Pointer - Address of the pointer within the request message that
        is to point to the space allocated out of the capture buffer.

Return Value:

    The actual length of the buffer allocated, after it has been rounded
    up to a multiple of 4.

--*/

{
    if (Length == 0) {
        *Pointer = NULL;
        Pointer = NULL;
    }
    else {

        //
        // Set the returned pointer value to point to the next free byte in
        // the capture buffer.
        //

        *Pointer = CaptureBuffer->FreeSpace;

        //
        // Round the length up to a multiple of 4
        //

        if (Length >= MAXLONG) {
            //
            // Bail early if too big
            //
            return 0;
        }

        Length = (Length + 3) & ~3;

        //
        // Update the free space pointer to point to the next available byte
        // in the capture buffer.
        //

        CaptureBuffer->FreeSpace += Length;
    }

    //
    // Remember the location of this pointer so that CsrClientCallServer can
    // convert it into a server pointer prior to sending the request to
    // the server.
    //

    CaptureBuffer->MessagePointerOffsets[ CaptureBuffer->CountMessagePointers++ ] =
        (ULONG_PTR)Pointer;

    //
    // Return the actual length allocated.
    //

    return Length;
}


VOID
CsrCaptureMessageBuffer (
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    )

/*++

Routine Description:

    This function captures a buffer of bytes in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    Buffer - Optional pointer to the buffer.  If this parameter is
        not present, then no data is copied into capture buffer.

    Length - Length of the buffer.

    CapturedBuffer - Pointer to the field in the message that will
        be filled in to point to the capture buffer.

Return Value:

    None.

--*/

{
    //
    // Set the length fields of the captured string structure and allocated
    // the Length for the string from the capture buffer.
    //

    CsrAllocateMessagePointer (CaptureBuffer,
                               Length,
                               CapturedBuffer);

    //
    // If Buffer parameter is not present or the length of the data is zero,
    // return.
    //

    if (!ARGUMENT_PRESENT( Buffer ) || (Length == 0)) {
        return;
    }

    //
    // Copy the buffer data to the capture area.
    //

    RtlMoveMemory (*CapturedBuffer, Buffer, Length);

    return;
}


VOID
CsrCaptureMessageString (
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String OPTIONAL,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    )

/*++

Routine Description:

    This function captures an ASCII string into a counted string data
    structure located in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    String - Optional pointer to the ASCII string.  If this parameter is
        not present, then the counted string data structure is set to
        the null string.

    Length - Length of the ASCII string, ignored if String is NULL.

    MaximumLength - Maximum length of the string.  Different for null
        terminated strings, where Length does not include the null and
        MaximumLength does. This is always how much space is allocated
        from the capture buffer.

    CaptureString - Pointer to the counted string data structure that will
        be filled in to point to the captured ASCII string.

Return Value:

    None.

--*/

{
    ASSERT(CapturedString != NULL);
    //
    // If String parameter is not present, then set the captured string
    // to be the null string and return.
    //

    if (!ARGUMENT_PRESENT( String )) {
        CapturedString->Length = 0;
        CapturedString->MaximumLength = (USHORT)MaximumLength;
        CsrAllocateMessagePointer( CaptureBuffer,
                                   MaximumLength,
                                   (PVOID *)&CapturedString->Buffer
                                 );
        //
        // Make it NULL terminated if there is any room.
        //
        if (MaximumLength != 0) {
            CapturedString->Buffer[0] = 0;
        }
        return;
    }

    //
    // Set the length fields of the captured string structure and allocated
    // the MaximumLength for the string from the capture buffer.
    //

    CapturedString->Length = (USHORT)Length;
    CapturedString->MaximumLength = (USHORT)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   MaximumLength,
                                   (PVOID *)&CapturedString->Buffer
                                 );
    //
    // If the Length of the ASCII string is non-zero then move it to the
    // capture area.
    //

    if (Length != 0) {
        RtlMoveMemory (CapturedString->Buffer, String, MaximumLength );
    }

    if (CapturedString->Length < CapturedString->MaximumLength) {
        CapturedString->Buffer[ CapturedString->Length ] = '\0';
    }

    return;
}


VOID
CsrCaptureMessageUnicodeStringInPlace (
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN OUT PUNICODE_STRING     String
    )
/*++

Routine Description:

    This function captures an ASCII string into a counted string data
    structure located in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    String - Optional pointer to the Unicode string.  If this parameter is
        not present, then the counted string data structure is set to
        the null string.

    Length - Length of the Unicode string in bytes, ignored if String is NULL.

    MaximumLength - Maximum length of the string.  Different for null
        terminated strings, where Length does not include the null and
        MaximumLength does. This is always how much space is allocated
        from the capture buffer.

    CaptureString - Pointer to the counted string data structure that will
        be filled in to point to the captured Unicode string.

Return Value:

    None, but if you don't trust the String parameter, use a __try block.

--*/
{
    ASSERT(String != NULL);

    CsrCaptureMessageString (CaptureBuffer,
                             (PCSTR)String->Buffer,
                             String->Length,
                             String->MaximumLength,
                             (PSTRING)String);

    // test > before substraction due to unsignedness

    if (String->MaximumLength > String->Length) {
        if ((String->MaximumLength - String->Length) >= sizeof(WCHAR)) {
            String->Buffer[ String->Length / sizeof(WCHAR) ] = 0;
        }
    }
}


NTSTATUS
CsrCaptureMessageMultiUnicodeStringsInPlace (
    IN OUT PCSR_CAPTURE_HEADER* InOutCaptureBuffer,
    IN ULONG                    NumberOfStringsToCapture,
    IN const PUNICODE_STRING*   StringsToCapture
    )
/*++

Routine Description:

    Capture multiple unicode strings.
    If the CaptureBuffer hasn't been allocated yet (passed as NULL), first
        allocate it.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer, or NULL, in which case we call CsrAllocateCaptureBuffer
        for you; this is the case if you are only capturing these strings
        and nothing else.

    NumberOfStringsToCapture - 

    StringsToCapture - 

Return Value:

    NTSTATUS

--*/
{
    ULONG Length = 0;
    ULONG i = 0;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    if (InOutCaptureBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    CaptureBuffer = *InOutCaptureBuffer;

    if (CaptureBuffer == NULL) {
        Length = 0;
        for (i = 0 ; i != NumberOfStringsToCapture ; ++i) {
            if (StringsToCapture[i] != NULL) {
                Length += StringsToCapture[i]->MaximumLength;
            }
        }
        CaptureBuffer = CsrAllocateCaptureBuffer(NumberOfStringsToCapture, Length);
        if (CaptureBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        *InOutCaptureBuffer = CaptureBuffer;
    }

    for (i = 0 ; i != NumberOfStringsToCapture ; i += 1) {

        if (StringsToCapture[i] != NULL) {

            CsrCaptureMessageUnicodeStringInPlace (CaptureBuffer,
                                                   StringsToCapture[i]);
        }
    }

    return STATUS_SUCCESS;
}


PLARGE_INTEGER
CsrCaptureTimeout (
    IN ULONG MilliSeconds,
    OUT PLARGE_INTEGER Timeout
    )
{
    if (MilliSeconds == -1) {
        return NULL;
    }

    Timeout->QuadPart = Int32x32To64( MilliSeconds, -10000 );
    return (PLARGE_INTEGER)Timeout;
}


VOID
CsrProbeForWrite (
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility.
    If the structure is not accessible, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{
    CHAR Temp;
    volatile CHAR *StartAddress;
    volatile CHAR *EndAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8));

        StartAddress = (volatile CHAR *)Address;

        if (((ULONG_PTR)StartAddress & (Alignment - 1)) != 0) {
            RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
        } else {
            Temp = *StartAddress;
            *StartAddress = Temp;
            EndAddress = StartAddress + Length - 1;
            Temp = *EndAddress;
            *EndAddress = Temp;
        }
    }
}


VOID
CsrProbeForRead (
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility.
    If the structure is not accessible, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{
    CHAR Temp;
    volatile CHAR *StartAddress;
    volatile CHAR *EndAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8));
        StartAddress = (volatile CHAR *)Address;

        if (((ULONG_PTR)StartAddress & (Alignment - 1)) != 0) {
            RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
        } else {
            Temp = *StartAddress;
            EndAddress = StartAddress + Length - 1;
            Temp = *EndAddress;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\dlluistb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dlluistb.c

Abstract:

    Debug Subsystem DbgUi API Stubs

Author:

    Mark Lucovsky (markl) 23-Jan-1990

Revision History:

    Neill Clift 27-Apr-2000 - Rehashed to call new kernel APIs for process debugging

--*/

#include "dbgdllp.h"
#include "windows.h"

#define DbgUiDebugObjectHandle (NtCurrentTeb()->DbgSsReserved[1])

NTSTATUS
DbgUiConnectToDbg (
    VOID
    )

/*++

Routine Description:

    This routine makes a connection between the caller and the DbgUi
    port in the Dbg subsystem.  In addition to returning a handle to a
    port object, a handle to a state change semaphore is returned.  This
    semaphore is used in DbgUiWaitStateChange APIs.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    OBJECT_ATTRIBUTES oa;

    //
    // if app is already connected, don't reconnect
    //
    st = STATUS_SUCCESS;
    if ( !DbgUiDebugObjectHandle ) {

        InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);
        st = NtCreateDebugObject (&DbgUiDebugObjectHandle,
                                  DEBUG_ALL_ACCESS,
                                  &oa,
                                  DEBUG_KILL_ON_CLOSE);
    }
    return st;

}

HANDLE
DbgUiGetThreadDebugObject (
    )
/*++

Routine Description:

    This function returns the current threads debug port handle if it has one.

Arguments:

    None

Return Value:

    HANDLE - Debug port handle;

--*/
{
    return DbgUiDebugObjectHandle;
}


VOID
DbgUiSetThreadDebugObject (
    IN HANDLE DebugObject
    )
/*++

Routine Description:

    This function sets the current thread's debug port handle.
    Any previous value is simply overwritten; there is no
    automatic close of a previous handle.

Arguments:

    DebugObject - Debug object handle to set.

Return Value:

    None.

--*/
{
    DbgUiDebugObjectHandle = DebugObject;
}


NTSTATUS
DbgUiWaitStateChange (
    OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function causes the calling user interface to wait for a
    state change to occur in one of it's application threads. The
    wait is ALERTABLE.

Arguments:

    StateChange - Supplies the address of state change record that
        will contain the state change information.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;


    //
    // Wait for a StateChange to occur
    //
    st = NtWaitForDebugEvent (DbgUiDebugObjectHandle,
                              TRUE,
                              Timeout,
                              StateChange);

    return st;
}

NTSTATUS
DbgUiContinue (
    IN PCLIENT_ID AppClientId,
    IN NTSTATUS ContinueStatus
    )

/*++

Routine Description:

    This function continues an application thread whose state change was
    previously reported through DbgUiWaitStateChange.

Arguments:

    AppClientId - Supplies the address of the ClientId of the
        application thread being continued.  This must be an application
        thread that previously notified the caller through
        DbgUiWaitStateChange but has not yet been continued.

    ContinueStatus - Supplies the continuation status to the thread
        being continued.  valid values for this are:

        DBG_EXCEPTION_HANDLED
        DBG_EXCEPTION_NOT_HANDLED
        DBG_TERMINATE_THREAD
        DBG_TERMINATE_PROCESS
        DBG_CONTINUE

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_CID - An invalid ClientId was specified for the
        AppClientId, or the specified Application was not waiting
        for a continue.

    STATUS_INVALID_PARAMETER - An invalid continue status was specified.

--*/

{
    NTSTATUS st;

    st = NtDebugContinue (DbgUiDebugObjectHandle,
                          AppClientId,
                          ContinueStatus);

    return st;
}

NTSTATUS
DbgUiStopDebugging (
    IN HANDLE Process
    )
/*++

Routine Description:

    This function stops debugging the specified process

Arguments:

    Process - Process handle of process being debugged

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS st;

    st = NtRemoveProcessDebug (Process,
                               DbgUiDebugObjectHandle);

    return st;
}

VOID
DbgUiRemoteBreakin (
    IN PVOID Context
    )
/*++

Routine Description:

    This function starts debugging the target process

Arguments:

    Context - Thread context    

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER (Context);

    //
    // We need to cover the case here where the caller detaches the debugger
    // (or the debugger fails and the port is removed by
    // the kernel). In this case by the time we execute the debugger may be
    // gone. Test first that the debugger is present and if it
    // is call the breakpoint routine in a try/except block so if it goes
    // away now we unwind and just exit this thread.
    //
    if ((NtCurrentPeb()->BeingDebugged) ||
        (USER_SHARED_DATA->KdDebuggerEnabled & 0x00000002)) {
        try {
            DbgBreakPoint();
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }
    RtlExitUserThread (STATUS_SUCCESS);
}

NTSTATUS
DbgUiIssueRemoteBreakin (
    IN HANDLE Process
    )
/*++

Routine Description:

    This function creates a remote thread int he target process to break in

Arguments:

    Process - Process to debug

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;
    HANDLE Thread;
    CLIENT_ID ClientId;

    Status = RtlCreateUserThread (Process,
                                  NULL,
                                  FALSE,
                                  0,
                                  0,
                                  0x4000,
                                  (PUSER_THREAD_START_ROUTINE) DbgUiRemoteBreakin,
                                  NULL,
                                  &Thread,
                                  &ClientId);
    if (NT_SUCCESS (Status)) {
        Status1 = NtClose (Thread);
        ASSERT (NT_SUCCESS (Status1));
    }
    return Status;
}

NTSTATUS
DbgUiDebugActiveProcess (
     IN HANDLE Process
     )
/*++

Routine Description:

    This function starts debugging the target process

Arguments:

    dwProcessId - Process ID of process being debugged

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;

    Status = NtDebugActiveProcess (Process,
                                   DbgUiDebugObjectHandle);
    if (NT_SUCCESS (Status)) {
        Status = DbgUiIssueRemoteBreakin (Process);
        if (!NT_SUCCESS (Status)) {
            Status1 = DbgUiStopDebugging (Process);
        }
    }

    return Status;
}

NTSTATUS
DbgUiConvertStateChangeStructure (
    IN PDBGUI_WAIT_STATE_CHANGE StateChange,
    OUT LPDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    This function converts the internal state change record to the win32 structure.

Arguments:

    StateChange - Native debugger event structure
    DebugEvent  - Win32 structure

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadBasicInfo;

    DebugEvent->dwProcessId = HandleToUlong (StateChange->AppClientId.UniqueProcess);
    DebugEvent->dwThreadId = HandleToUlong (StateChange->AppClientId.UniqueThread);

    switch (StateChange->NewState) {

    case DbgCreateThreadStateChange :
        DebugEvent->dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
        DebugEvent->u.CreateThread.hThread =
            StateChange->StateInfo.CreateThread.HandleToThread;
        DebugEvent->u.CreateThread.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)StateChange->StateInfo.CreateThread.NewThread.StartAddress;
        Status = NtQueryInformationThread (StateChange->StateInfo.CreateThread.HandleToThread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof (ThreadBasicInfo),
                                           NULL);
        if (!NT_SUCCESS (Status)) {
            DebugEvent->u.CreateThread.lpThreadLocalBase = NULL;
        } else {
            DebugEvent->u.CreateThread.lpThreadLocalBase = ThreadBasicInfo.TebBaseAddress;
        }

        break;

    case DbgCreateProcessStateChange :
        DebugEvent->dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
        DebugEvent->u.CreateProcessInfo.hProcess =
            StateChange->StateInfo.CreateProcessInfo.HandleToProcess;
        DebugEvent->u.CreateProcessInfo.hThread =
            StateChange->StateInfo.CreateProcessInfo.HandleToThread;
        DebugEvent->u.CreateProcessInfo.hFile =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
        DebugEvent->u.CreateProcessInfo.lpBaseOfImage =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.BaseOfImage;
        DebugEvent->u.CreateProcessInfo.dwDebugInfoFileOffset =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.DebugInfoFileOffset;
        DebugEvent->u.CreateProcessInfo.nDebugInfoSize =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.DebugInfoSize;
        DebugEvent->u.CreateProcessInfo.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)StateChange->StateInfo.CreateProcessInfo.NewProcess.InitialThread.StartAddress;
        Status = NtQueryInformationThread (StateChange->StateInfo.CreateProcessInfo.HandleToThread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof (ThreadBasicInfo),
                                           NULL);
        if (!NT_SUCCESS (Status)) {
            DebugEvent->u.CreateProcessInfo.lpThreadLocalBase = NULL;
        } else {
            DebugEvent->u.CreateProcessInfo.lpThreadLocalBase = ThreadBasicInfo.TebBaseAddress;
        }
        DebugEvent->u.CreateProcessInfo.lpImageName = NULL;
        DebugEvent->u.CreateProcessInfo.fUnicode = 1;


        break;

    case DbgExitThreadStateChange :

        DebugEvent->dwDebugEventCode = EXIT_THREAD_DEBUG_EVENT;
        DebugEvent->u.ExitThread.dwExitCode = (DWORD)StateChange->StateInfo.ExitThread.ExitStatus;
        break;

    case DbgExitProcessStateChange :

        DebugEvent->dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
        DebugEvent->u.ExitProcess.dwExitCode = (DWORD)StateChange->StateInfo.ExitProcess.ExitStatus;
        break;

    case DbgExceptionStateChange :
    case DbgBreakpointStateChange :
    case DbgSingleStepStateChange :

        if (StateChange->StateInfo.Exception.ExceptionRecord.ExceptionCode == DBG_PRINTEXCEPTION_C) {
            DebugEvent->dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;

            DebugEvent->u.DebugString.lpDebugStringData =
                (PVOID)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[1];
            DebugEvent->u.DebugString.nDebugStringLength =
                (WORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[0];
            DebugEvent->u.DebugString.fUnicode = (WORD)0;
        } else if (StateChange->StateInfo.Exception.ExceptionRecord.ExceptionCode == DBG_RIPEXCEPTION) {
            DebugEvent->dwDebugEventCode = RIP_EVENT;

            DebugEvent->u.RipInfo.dwType =
                (DWORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[1];
            DebugEvent->u.RipInfo.dwError =
                (DWORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[0];
        } else {
            DebugEvent->dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
            DebugEvent->u.Exception.ExceptionRecord =
                StateChange->StateInfo.Exception.ExceptionRecord;
            DebugEvent->u.Exception.dwFirstChance =
                StateChange->StateInfo.Exception.FirstChance;
        }
        break;

    case DbgLoadDllStateChange :
        DebugEvent->dwDebugEventCode = LOAD_DLL_DEBUG_EVENT;
        DebugEvent->u.LoadDll.lpBaseOfDll =
            StateChange->StateInfo.LoadDll.BaseOfDll;
        DebugEvent->u.LoadDll.hFile =
            StateChange->StateInfo.LoadDll.FileHandle;
        DebugEvent->u.LoadDll.dwDebugInfoFileOffset =
            StateChange->StateInfo.LoadDll.DebugInfoFileOffset;
        DebugEvent->u.LoadDll.nDebugInfoSize =
            StateChange->StateInfo.LoadDll.DebugInfoSize;
        //
        // pick up the image name
        //

        DebugEvent->u.LoadDll.lpImageName = StateChange->StateInfo.LoadDll.NamePointer;
        DebugEvent->u.LoadDll.fUnicode = 1;

        break;

    case DbgUnloadDllStateChange :
        DebugEvent->dwDebugEventCode = UNLOAD_DLL_DEBUG_EVENT;
        DebugEvent->u.UnloadDll.lpBaseOfDll =
            StateChange->StateInfo.UnloadDll.BaseAddress;
        break;

    default:
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\heaptag.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heaptag.c

Abstract:

    This module implements the support routines needed for FLG_HEAP_ENABLE_TAG_BY_DLL

Author:

    Steve Wood (stevewo) 07-Apr-1995

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include "ldrp.h"
#include <stktrace.h>
#include <heap.h>
#include <stdio.h>

#define LDRP_MAXIMUM_DLL_TAGS 64

BOOLEAN LdrpDllTagsInitialized;
ULONG LdrpNumberOfDllTags;
ULONG LdrpBaseDllTag;
ULONG LdrpDllTags[ LDRP_MAXIMUM_DLL_TAGS ];

#define DEFINE_HEAPTAG_ENTRY( n ) \
PVOID LdrpTagAllocateHeap##n( PVOID h, ULONG f, ULONG s ) {return LdrpTagAllocateHeap( h, f, s, n ); }

PVOID
LdrpTagAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN ULONG Size,
    IN ULONG n
    )
{
    if ((Flags & HEAP_TAG_MASK) == 0) {
        Flags |= LdrpDllTags[ n ];
        }

    return RtlAllocateHeap( HeapHandle, Flags, Size );
}

DEFINE_HEAPTAG_ENTRY(  0 );
DEFINE_HEAPTAG_ENTRY(  1 );
DEFINE_HEAPTAG_ENTRY(  2 );
DEFINE_HEAPTAG_ENTRY(  3 );
DEFINE_HEAPTAG_ENTRY(  4 );
DEFINE_HEAPTAG_ENTRY(  5 );
DEFINE_HEAPTAG_ENTRY(  6 );
DEFINE_HEAPTAG_ENTRY(  7 );
DEFINE_HEAPTAG_ENTRY(  8 );
DEFINE_HEAPTAG_ENTRY(  9 );
DEFINE_HEAPTAG_ENTRY( 10 );
DEFINE_HEAPTAG_ENTRY( 11 );
DEFINE_HEAPTAG_ENTRY( 12 );
DEFINE_HEAPTAG_ENTRY( 13 );
DEFINE_HEAPTAG_ENTRY( 14 );
DEFINE_HEAPTAG_ENTRY( 15 );
DEFINE_HEAPTAG_ENTRY( 16 );
DEFINE_HEAPTAG_ENTRY( 17 );
DEFINE_HEAPTAG_ENTRY( 18 );
DEFINE_HEAPTAG_ENTRY( 19 );
DEFINE_HEAPTAG_ENTRY( 20 );
DEFINE_HEAPTAG_ENTRY( 21 );
DEFINE_HEAPTAG_ENTRY( 22 );
DEFINE_HEAPTAG_ENTRY( 23 );
DEFINE_HEAPTAG_ENTRY( 24 );
DEFINE_HEAPTAG_ENTRY( 25 );
DEFINE_HEAPTAG_ENTRY( 26 );
DEFINE_HEAPTAG_ENTRY( 27 );
DEFINE_HEAPTAG_ENTRY( 28 );
DEFINE_HEAPTAG_ENTRY( 29 );
DEFINE_HEAPTAG_ENTRY( 30 );
DEFINE_HEAPTAG_ENTRY( 31 );
DEFINE_HEAPTAG_ENTRY( 32 );
DEFINE_HEAPTAG_ENTRY( 33 );
DEFINE_HEAPTAG_ENTRY( 34 );
DEFINE_HEAPTAG_ENTRY( 35 );
DEFINE_HEAPTAG_ENTRY( 36 );
DEFINE_HEAPTAG_ENTRY( 37 );
DEFINE_HEAPTAG_ENTRY( 38 );
DEFINE_HEAPTAG_ENTRY( 39 );
DEFINE_HEAPTAG_ENTRY( 40 );
DEFINE_HEAPTAG_ENTRY( 41 );
DEFINE_HEAPTAG_ENTRY( 42 );
DEFINE_HEAPTAG_ENTRY( 43 );
DEFINE_HEAPTAG_ENTRY( 44 );
DEFINE_HEAPTAG_ENTRY( 45 );
DEFINE_HEAPTAG_ENTRY( 46 );
DEFINE_HEAPTAG_ENTRY( 47 );
DEFINE_HEAPTAG_ENTRY( 48 );
DEFINE_HEAPTAG_ENTRY( 49 );
DEFINE_HEAPTAG_ENTRY( 50 );
DEFINE_HEAPTAG_ENTRY( 51 );
DEFINE_HEAPTAG_ENTRY( 52 );
DEFINE_HEAPTAG_ENTRY( 53 );
DEFINE_HEAPTAG_ENTRY( 54 );
DEFINE_HEAPTAG_ENTRY( 55 );
DEFINE_HEAPTAG_ENTRY( 56 );
DEFINE_HEAPTAG_ENTRY( 57 );
DEFINE_HEAPTAG_ENTRY( 58 );
DEFINE_HEAPTAG_ENTRY( 59 );
DEFINE_HEAPTAG_ENTRY( 60 );
DEFINE_HEAPTAG_ENTRY( 61 );
DEFINE_HEAPTAG_ENTRY( 62 );
DEFINE_HEAPTAG_ENTRY( 63 );

typedef PVOID (*PLDRP_DLL_TAG_PROCEDURE)(
    PVOID HeapHandle,
    ULONG Flags,
    ULONG Size
    );

const PLDRP_DLL_TAG_PROCEDURE LdrpDllTagProcedures[ LDRP_MAXIMUM_DLL_TAGS ] = {
    LdrpTagAllocateHeap0,
    LdrpTagAllocateHeap1,
    LdrpTagAllocateHeap2,
    LdrpTagAllocateHeap3,
    LdrpTagAllocateHeap4,
    LdrpTagAllocateHeap5,
    LdrpTagAllocateHeap6,
    LdrpTagAllocateHeap7,
    LdrpTagAllocateHeap8,
    LdrpTagAllocateHeap9,
    LdrpTagAllocateHeap10,
    LdrpTagAllocateHeap11,
    LdrpTagAllocateHeap12,
    LdrpTagAllocateHeap13,
    LdrpTagAllocateHeap14,
    LdrpTagAllocateHeap15,
    LdrpTagAllocateHeap16,
    LdrpTagAllocateHeap17,
    LdrpTagAllocateHeap18,
    LdrpTagAllocateHeap19,
    LdrpTagAllocateHeap20,
    LdrpTagAllocateHeap21,
    LdrpTagAllocateHeap22,
    LdrpTagAllocateHeap23,
    LdrpTagAllocateHeap24,
    LdrpTagAllocateHeap25,
    LdrpTagAllocateHeap26,
    LdrpTagAllocateHeap27,
    LdrpTagAllocateHeap28,
    LdrpTagAllocateHeap29,
    LdrpTagAllocateHeap30,
    LdrpTagAllocateHeap31,
    LdrpTagAllocateHeap32,
    LdrpTagAllocateHeap33,
    LdrpTagAllocateHeap34,
    LdrpTagAllocateHeap35,
    LdrpTagAllocateHeap36,
    LdrpTagAllocateHeap37,
    LdrpTagAllocateHeap38,
    LdrpTagAllocateHeap39,
    LdrpTagAllocateHeap40,
    LdrpTagAllocateHeap41,
    LdrpTagAllocateHeap42,
    LdrpTagAllocateHeap43,
    LdrpTagAllocateHeap44,
    LdrpTagAllocateHeap45,
    LdrpTagAllocateHeap46,
    LdrpTagAllocateHeap47,
    LdrpTagAllocateHeap48,
    LdrpTagAllocateHeap49,
    LdrpTagAllocateHeap50,
    LdrpTagAllocateHeap51,
    LdrpTagAllocateHeap52,
    LdrpTagAllocateHeap53,
    LdrpTagAllocateHeap54,
    LdrpTagAllocateHeap55,
    LdrpTagAllocateHeap56,
    LdrpTagAllocateHeap57,
    LdrpTagAllocateHeap58,
    LdrpTagAllocateHeap59,
    LdrpTagAllocateHeap60,
    LdrpTagAllocateHeap61,
    LdrpTagAllocateHeap62,
    LdrpTagAllocateHeap63
};

PVOID
LdrpDefineDllTag (
    PWSTR TagName,
    PUSHORT TagIndex
    )
{
    PVOID Result;
    WCHAR TagNameBuffer[ 260 ];

    if (RtlpGlobalTagHeap == NULL) {
        RtlpGlobalTagHeap = RtlAllocateHeap( RtlProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( HEAP ));
        if (RtlpGlobalTagHeap == NULL) {
            return NULL;
        }
    }
    
    if (!LdrpDllTagsInitialized) {
        //
        // Keep QUERY.C happy
        //
        InitializeListHead( &RtlpGlobalTagHeap->VirtualAllocdBlocks );
        LdrpDllTagsInitialized = TRUE;
    }

    Result = NULL;
    if (LdrpNumberOfDllTags < LDRP_MAXIMUM_DLL_TAGS) {
        memset( TagNameBuffer, 0, sizeof( TagNameBuffer ) );
        wcsncpy( TagNameBuffer, TagName, ( sizeof( TagNameBuffer ) / sizeof( TagNameBuffer[0] ) ) - 1 );
        LdrpDllTags[ LdrpNumberOfDllTags ] =
            RtlCreateTagHeap( NULL,
                              0,
                              NULL,
                              TagNameBuffer
                            );

        if (LdrpDllTags[ LdrpNumberOfDllTags ] != 0) {
            Result = (PVOID) (ULONG_PTR) LdrpDllTagProcedures[ LdrpNumberOfDllTags ];
        }

        if (Result != NULL) {
            *TagIndex = (USHORT)(LdrpDllTags[ LdrpNumberOfDllTags ] >> HEAP_TAG_SHIFT);
            LdrpNumberOfDllTags += 1;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\hotpatch.c ===
/*

Copyright (c) 2001  Microsoft Corporation

File name:

    hotpatch.c
   
Author:
    
    Adrian Marinescu (adrmarin)  Nov 14 2001

*/

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ldrp.h"

#include "hotpatch.h"

ULONG LdrpHotpatchCount = 0;
LIST_ENTRY LdrpHotPatchList;

NTSTATUS
LdrpSetupHotpatch (
    IN PRTL_PATCH_HEADER RtlPatchData
    )

/*++

Routine Description:

    This utility routine is used to:
        - find the targed module (the patch apply to)
        - search for an existing identical patch, and create a new one if not
            existent
        - Prepare the fixup code
    
    N.B. It assumes that the loader lock is held. 

Arguments:

    DllPatchHandle - The handle of the patch image

    Patch - The pointer to the patch header
    
    PatchFlags - The flags for the patch being applied.
    
Return Value:

    NTSTATUS

--*/

{
    PLIST_ENTRY Next;
    NTSTATUS Status;

    //
    //  walk the table entry list to find the dll
    //

    Next = PebLdr.InLoadOrderModuleList.Flink;

    for ( ; Next != &PebLdr.InLoadOrderModuleList; Next = Next->Flink) {

        PPATCH_LDR_DATA_TABLE_ENTRY Entry;

        Entry = CONTAINING_RECORD (Next, PATCH_LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

        //
        // when we unload, the memory order links flink field is nulled.
        // this is used to skip the entry pending list removal.
        //

        if ( !Entry->InMemoryOrderLinks.Flink ) {
            continue;
        }

        if (RtlpIsSameImage(RtlPatchData, Entry)) {

            break;
        }
    }
        
    if (RtlPatchData->TargetDllBase == NULL) {
        
        return STATUS_DLL_NOT_FOUND;
    }

    //
    //  Create the new structure rtl patch structure here
    //  This requires some relocation info to be processed,
    //  so we need to allow write access to the patch dll
    //

    Status = LdrpSetProtection (RtlPatchData->PatchLdrDataTableEntry->DllBase, FALSE);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    Status = RtlInitializeHotPatch (RtlPatchData, 0);

    //
    //  Restore the protection to RO
    //

    LdrpSetProtection (RtlPatchData->PatchLdrDataTableEntry->DllBase, TRUE);

    return Status;
}

NTSTATUS
LdrpApplyHotPatch(
    IN PRTL_PATCH_HEADER RtlPatchData,
    IN ULONG PatchFlags
    )

/*++

Routine Description:

    The function applies the changes to the target code.

Arguments:

    RtlPatchData - Supplies the patch information
    
    PatchFlags - Supplies the patch flags

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    //
    //  Check whether we change the status or not.
    //

    if (((PatchFlags ^ RtlPatchData->CodeInfo->Flags) & FLG_HOTPATCH_ACTIVE) == 0) {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  Unprotect the target binary pages
    //

    Status = LdrpSetProtection (RtlPatchData->TargetDllBase, FALSE);
    
    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    //
    //  Make the system call to modify the code from a DPC routine
    //

    Status = NtSetSystemInformation ( SystemHotpatchInformation, 
                                      RtlPatchData->CodeInfo, 
                                      RtlPatchData->CodeInfo->InfoSize);

    if (NT_SUCCESS(Status)) {

        //
        //  Update the flags to contain the new state
        //

        RtlPatchData->CodeInfo->Flags ^= FLG_HOTPATCH_ACTIVE;
    }

    LdrpSetProtection (RtlPatchData->TargetDllBase, TRUE);

    return Status;
}

LONG
LdrHotPatchRoutine (
    PVOID PatchInfo
    )

/*++

Routine Description:

    This is the worker routine that an external program can use for 
    thread injection. 

Arguments:

    Patch - The pointer to the patch header. The application which calls
            this routine should never free or unmap this structure, as the current
            process can start using the code located inside this blob.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PHOTPATCH_HEADER Patch;
    ULONG PatchFlags;
    PVOID DllHandle = NULL;
    LOGICAL FirstLoad;
    UNICODE_STRING PatchImageName, TargetImageName;
    PSYSTEM_HOTPATCH_CODE_INFORMATION RemoteInfo;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY PatchLdrTableEntry;
    PRTL_PATCH_HEADER RtlPatchData;
    BOOLEAN LoaderLockAcquired = FALSE;

    FirstLoad = FALSE;
    Status = STATUS_SUCCESS;
    
    __try {

        RemoteInfo = (PSYSTEM_HOTPATCH_CODE_INFORMATION)PatchInfo;

        if (!(RemoteInfo->Flags & FLG_HOTPATCH_NAME_INFO)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        PatchImageName.Buffer = (PWCHAR)((PUCHAR)RemoteInfo + RemoteInfo->UserModeInfo.NameOffset);
        PatchImageName.Length = (USHORT)RemoteInfo->UserModeInfo.NameLength;
        PatchImageName.MaximumLength = PatchImageName.Length;

        TargetImageName.Buffer = (PWCHAR)((PUCHAR)RemoteInfo + RemoteInfo->UserModeInfo.TargetNameOffset);
        TargetImageName.Length = (USHORT)RemoteInfo->UserModeInfo.TargetNameLength;
        TargetImageName.MaximumLength = TargetImageName.Length;

        PatchFlags = RemoteInfo->Flags;
        
        RtlEnterCriticalSection (&LdrpLoaderLock);
        LoaderLockAcquired = TRUE;

        if (TargetImageName.Length) {
            
            Status = STATUS_DLL_NOT_FOUND;

            Next = PebLdr.InLoadOrderModuleList.Flink;

            for ( ; Next != &PebLdr.InLoadOrderModuleList; Next = Next->Flink) {

                PLDR_DATA_TABLE_ENTRY Entry;

                Entry = CONTAINING_RECORD (Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

                //
                // when we unload, the memory order links flink field is nulled.
                // this is used to skip the entry pending list removal.
                //

                if ( !Entry->InMemoryOrderLinks.Flink ) {
                    continue;
                }

                if (RtlEqualUnicodeString (&TargetImageName, &Entry->BaseDllName, TRUE)) {

                    Status = STATUS_SUCCESS;
                    break;
                }
            }

            if (!NT_SUCCESS(Status)) {

                leave;
            }
        }

        //
        //  Load the module in memory. If this is not the first time
        //  we apply the patch, the load will reference the LoadCount for
        //  the existing module.
        //

        if (LdrpHotpatchCount == 0) {

            InitializeListHead (&LdrpHotPatchList);
        }

        Status = LdrLoadDll (NULL, NULL, &PatchImageName, &DllHandle );

        if (!NT_SUCCESS(Status)) {

            leave;
        }

        //
        //  Search the loader table entry for the patch data
        //

        PatchLdrTableEntry = NULL;
        Next = PebLdr.InLoadOrderModuleList.Flink;

        for ( ; Next != &PebLdr.InLoadOrderModuleList; Next = Next->Flink) {

            PLDR_DATA_TABLE_ENTRY Entry;

            Entry = CONTAINING_RECORD (Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

            //
            // when we unload, the memory order links flink field is nulled.
            // this is used to skip the entry pending list removal.
            //

            if ( !Entry->InMemoryOrderLinks.Flink ) {
                continue;
            }

            if (DllHandle == Entry->DllBase) {

                PatchLdrTableEntry = Entry;
                break;
            }
        }

        if (PatchLdrTableEntry == NULL) {

            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        Patch = RtlGetHotpatchHeader(DllHandle);

        if (Patch == NULL) {

            Status = STATUS_INVALID_IMAGE_FORMAT;
            leave;
        }

        RtlPatchData = RtlFindRtlPatchHeader(&LdrpHotPatchList, PatchLdrTableEntry);

        if (RtlPatchData == NULL) {

            Status = RtlCreateHotPatch(&RtlPatchData, Patch, PatchLdrTableEntry, PatchFlags);

            if (!NT_SUCCESS(Status)) {
                
                leave;
            }

            Status = LdrpSetupHotpatch(RtlPatchData);

            if (!NT_SUCCESS(Status)) {

                RtlFreeHotPatchData(RtlPatchData);
                leave;
            }

            FirstLoad = TRUE;

        } else {

            //
            //  Existing hotpatch case. 
            //  Rebuild the hook information, if the hotpatch was not active
            //

            if ((RtlPatchData->CodeInfo->Flags & FLG_HOTPATCH_ACTIVE) == 0) {

                Status = RtlReadHookInformation( RtlPatchData );

                if (!NT_SUCCESS(Status)) {

                    leave;
                }
            }
        }

        Status = LdrpApplyHotPatch (RtlPatchData, PatchFlags);

        if (FirstLoad) {

            if (NT_SUCCESS(Status)) {

                //
                //  We succesfully applied the patch. Add it to the Patch list
                //

                RtlPatchData->NextPatch = (PRTL_PATCH_HEADER)RtlPatchData->TargetLdrDataTableEntry->PatchInformation;
                RtlPatchData->TargetLdrDataTableEntry->PatchInformation = RtlPatchData;

                InsertTailList (&LdrpHotPatchList, &RtlPatchData->PatchList);
                LdrpHotpatchCount += 1;

            } else {

                RtlFreeHotPatchData(RtlPatchData);
                FirstLoad = FALSE;  // force unload the module

                leave;
            }
        }

    } __finally {

        if (LoaderLockAcquired) {
            
            RtlLeaveCriticalSection (&LdrpLoaderLock);    
        }
        
        //
        //  Unload the patch dll. LdrpPerformHotPatch added a reference to the LoadCount
        //  if succesfully installed.
        //

        if ((!FirstLoad) && (DllHandle != NULL)) {

            LdrUnloadDll (DllHandle);
        }
    }

    RtlExitUserThread(Status);

//    return Status;
}

NTSTATUS
LdrpRundownHotpatchList (
    PRTL_PATCH_HEADER PatchHead
    )

/*++

Routine Description:

    This function cleans up the hotpatch data when the target dll is unloaded.
    The function assumes the loader lock is not held.

Arguments:
    
    PatchHead - The head of the patch list

Return Value:

    Returns the appropriate status
        
--*/

{
    while (PatchHead) {
        
        //
        //  Remove the patch data from the list
        //

        PRTL_PATCH_HEADER CrtPatch = PatchHead;
        PatchHead = PatchHead->NextPatch;

        RtlEnterCriticalSection (&LdrpLoaderLock);

        
        RemoveEntryList (&CrtPatch->PatchList);
        LdrpHotpatchCount -= 1;

        RtlLeaveCriticalSection (&LdrpLoaderLock);    

        //
        //  Unload all instances for that dll.
        //
        
        if (CrtPatch->PatchImageBase) {

            LdrUnloadDll (CrtPatch->PatchImageBase);
        }
        
        RtlFreeHotPatchData (CrtPatch);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\importtablehash.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ImportTableHash.h

Abstract:

    This module contains hash computation routine 
    RtlComputeImportTableHash to compute the hash 
    based on the import table of an exe.
    

Author:

    Vishnu Patankar (vishnup) 31-May-2001

Revision History:


--*/

#ifndef _ITH_
#define _ITH_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>
#include <md5.h>

//
// MD5 hashes are of size 16 bytes
//

#define ITH_REVISION_1  1

#define IMPORT_TABLE_MAX_HASH_SIZE 16

typedef struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY {
    struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY  *Next;
    PSZ String;
} IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY, *PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY;

typedef struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_LIST_ENTRY {
    struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_LIST_ENTRY *Next;
    PSZ String;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY FunctionList;
} IMPORTTABLEP_SORTED_LIST_ENTRY, *PIMPORTTABLEP_SORTED_LIST_ENTRY;

VOID
ImportTablepInsertModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY   pImportName,
    OUT PIMPORTTABLEP_SORTED_LIST_ENTRY * ppImportNameList
    );

VOID
ImportTablepFreeModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY pImportNameList
    );

VOID
ImportTablepInsertFunctionSorted(
    IN  PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY   pFunctionName,
    OUT PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY * ppFunctionNameList
    );

VOID
ImportTablepFreeFunctionSorted(
    IN PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pFunctionNameList
    );

NTSTATUS
ImportTablepHashCanonicalLists( 
    IN  PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList, 
    OUT PBYTE Hash
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrp.h

Abstract:

    Private types... for executive portion of loader

Author:

    Mark Lucovsky (markl) 26-Mar-1990

Revision History:

--*/

#ifndef _LDRP_
#define _LDRP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>
#include <sxstypes.h>

#if defined(_WIN64)
extern INVERTED_FUNCTION_TABLE LdrpInvertedFunctionTable;
#endif

#if DBG
#define LdrpShouldDbgPrintStatus(st) \
    (!NT_SUCCESS(st) \
        && (ShowSnaps \
            || (   (st) != STATUS_NO_SUCH_FILE \
                && (st) != STATUS_DLL_NOT_FOUND \
                && (st) != STATUS_OBJECT_NAME_NOT_FOUND \
                )))
#else
#define LdrpShouldDbgPrintStatus(st) (FALSE)
#endif

#if DBG
#define LDR_ERROR_DPFLTR DPFLTR_ERROR_LEVEL
#else
#define LDR_ERROR_DPFLTR ((ShowSnaps || ShowErrors) ? DPFLTR_ERROR_LEVEL : DPFLTR_INFO_LEVEL)
#endif // DBG

extern BOOLEAN LdrpImageHasTls;
extern UNICODE_STRING LdrpDefaultPath;
extern HANDLE LdrpKnownDllObjectDirectory;
#define LDRP_MAX_KNOWN_PATH 128
extern WCHAR LdrpKnownDllPathBuffer[LDRP_MAX_KNOWN_PATH];
extern UNICODE_STRING LdrpKnownDllPath;
extern PLDR_MANIFEST_PROBER_ROUTINE LdrpManifestProberRoutine;
extern PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION LdrpAppCompatDllRedirectionCallbackFunction;
extern PVOID LdrpAppCompatDllRedirectionCallbackData;
extern PVOID LdrpHeap;
extern RTL_CRITICAL_SECTION LdrpLoaderLock;
extern PCUNICODE_STRING LdrpTopLevelDllBeingLoaded;
extern PTEB LdrpTopLevelDllBeingLoadedTeb;
extern BOOLEAN LdrpBreakOnExceptions;
extern PLDR_DATA_TABLE_ENTRY LdrpNtDllDataTableEntry;
extern PLDR_DATA_TABLE_ENTRY LdrpCurrentDllInitializer;
extern BOOLEAN LdrpShowInitRoutines;
extern BOOLEAN LdrpShowRecursiveDllLoads;
extern BOOLEAN LdrpBreakOnRecursiveDllLoads;
extern BOOLEAN LdrpLoaderLockAcquisionCount;
extern BOOLEAN g_LdrBreakOnLdrpInitializeProcessFailure;
extern PEB_LDR_DATA PebLdr;
extern const UNICODE_STRING SlashSystem32SlashMscoreeDllString;
extern const UNICODE_STRING SlashSystem32SlashString;
extern const UNICODE_STRING MscoreeDllString;

#define ASCII_CHAR_IS_N(_ch) (((_ch) == 'n') || ((_ch) == 'N'))
#define ASCII_CHAR_IS_T(_ch) (((_ch) == 't') || ((_ch) == 'T'))
#define ASCII_CHAR_IS_D(_ch) (((_ch) == 'd') || ((_ch) == 'D'))
#define ASCII_CHAR_IS_L(_ch) (((_ch) == 'l') || ((_ch) == 'L'))
#define ASCII_CHAR_IS_DOT(_ch) ((_ch) == '.')

#define ASCII_STRING_IS_NTDLL(_p) \
    ((_p) != NULL) && \
    (((_p)->Length == (5 * sizeof(CHAR))) && \
     (ASCII_CHAR_IS_N((_p)->Buffer[0]) && \
      ASCII_CHAR_IS_T((_p)->Buffer[1]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[2]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[3]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[4])) || \
     ((_p)->Length == ((5 + 1 + 3) * sizeof(CHAR))) && \
     (ASCII_CHAR_IS_N((_p)->Buffer[0]) && \
      ASCII_CHAR_IS_T((_p)->Buffer[1]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[2]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[3]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[4]) && \
      ASCII_CHAR_IS_DOT((_p)->Buffer[5]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[6]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[7]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[8])))
      
//
// NOTICE-2002/08/01-JayKrell
// + 1 is to preserve that code was using 266
// after explaining why it should be 265. Note
// that sizeof("") includes a nul.
//   DOS_MAX_PATH_LENGTH is 260 (Win32 MAX_PATH)
//   LDR_MAX_PATH is 266
// We will be removing path length limits in the
// ldr in the future.
//

#define LDR_MAX_PATH (DOS_MAX_PATH_LENGTH + sizeof("\\??\\") + 1)

extern LIST_ENTRY RtlpCalloutEntryList;

#if defined(_AMD64_) || defined(_IA64_)

extern LIST_ENTRY RtlpDynamicFunctionTable;

#endif

extern RTL_CRITICAL_SECTION RtlpCalloutEntryLock;

typedef struct _LDRP_DLL_NOTIFICATION_BLOCK {
    LIST_ENTRY Links;
    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction;
    PVOID Context;
} LDRP_DLL_NOTIFICATION_BLOCK, *PLDRP_DLL_NOTIFICATION_BLOCK;

//
//  Synchronized via LdrpLoaderLock
//

extern LIST_ENTRY LdrpDllNotificationList;

#define LDR_NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#if defined (BUILD_WOW6432)
NTSTATUS
LdrpWx86FormatVirtualImage(
    IN PCUNICODE_STRING DosImagePathName OPTIONAL,
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID DllBase
    );

NTSTATUS
LdrpWx86ProtectImagePages (
    IN PVOID Base,
    IN BOOLEAN Reset
    );

NTSTATUS
Wx86SetRelocatedSharedProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    );

ULONG
LdrpWx86RelocatedFixupDiff(
    IN PUCHAR ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN ULONG  Offset
    );

BOOLEAN
LdrpWx86DllHasRelocatedSharedSection(
    IN PUCHAR ImageBase);

NTSTATUS
RtlpWow64GetNativeSystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID NativeSystemInformation,
    IN ULONG InformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

#define NATIVE_PAGE_SIZE NativePageSize
#define NATIVE_PAGE_SHIFT NativePageShift
#define NATIVE_BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> NATIVE_PAGE_SHIFT) + \
                                    (((ULONG)(Size) & (NATIVE_PAGE_SIZE - 1)) != 0))
#else
#define NATIVE_PAGE_SIZE PAGE_SIZE
#define NATIVE_PAGE_SHIFT PAGE_SHIFT
#define NATIVE_BYTES_TO_PAGES(Size) BYTES_TO_PAGES(Size)
#endif

#if defined(_WIN64) || defined(BUILD_WOW6432)
extern ULONG NativePageSize;
extern ULONG NativePageShift;
#endif

VOID
RtlpWaitForCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

VOID
RtlpUnWaitCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

#define LDRP_HASH_TABLE_SIZE 32
#define LDRP_HASH_MASK       (LDRP_HASH_TABLE_SIZE-1)
#define LDRP_COMPUTE_HASH_INDEX(wch) ( (RtlUpcaseUnicodeChar((wch)) - (WCHAR)'A') & LDRP_HASH_MASK )
extern LIST_ENTRY LdrpHashTable[LDRP_HASH_TABLE_SIZE];


// LDRP_BAD_DLL Sundown: sign-extended value.
#define LDRP_BAD_DLL LongToPtr(0xffbadd11)

extern LIST_ENTRY LdrpDefaultPathCache;
typedef struct _LDRP_PATH_CACHE {
    LIST_ENTRY Links;
    UNICODE_STRING Component;
    HANDLE Directory;
} LDRP_PATH_CACHE, *PLDRP_PATH_CACHE;


NTSTATUS
LdrpSnapIAT(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Export,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Import,
    IN PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    IN BOOLEAN SnapForwardersOnly
    );

NTSTATUS
LdrpSnapThunk(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA OriginalThunk,
    IN OUT PIMAGE_THUNK_DATA Thunk,
    IN PCIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN StaticSnap,
    IN PCSZ DllName OPTIONAL
    );

USHORT
LdrpNameToOrdinal(
    IN PCSZ Name,
    IN ULONG NumberOfNames,
    IN PVOID DllBase,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    );

PLDR_DATA_TABLE_ENTRY
LdrpAllocateDataTableEntry (
    IN PVOID DllBase
    );


__forceinline
VOID
LdrpDeallocateDataTableEntry (
    IN PLDR_DATA_TABLE_ENTRY Entry
    )
{
    ASSERT (Entry != NULL);
    RtlFreeHeap (LdrpHeap, 0, Entry);
}

VOID
LdrpFinalizeAndDeallocateDataTableEntry (
    IN PLDR_DATA_TABLE_ENTRY Entry
    );

BOOLEAN
LdrpCheckForLoadedDll(
    IN PCWSTR DllPath OPTIONAL,
    IN PCUNICODE_STRING DllName,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

BOOLEAN
LdrpCheckForLoadedDllHandle(
    IN PVOID DllHandle,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

NTSTATUS
LdrpMapDll(
    IN PCWSTR DllPath OPTIONAL,
    IN PCWSTR DllName,
    IN PULONG DllCharacteristics OPTIONAL,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

NTSTATUS
LdrpWalkImportDescriptor(
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

NTSTATUS
LdrpRunInitializeRoutines(
    IN PCONTEXT Context OPTIONAL
    );

int
LdrpInitializeProcessWrapperFilter(
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers
    );

int
LdrpGenericExceptionFilter(
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers,
    IN PCSZ FunctionName
    );


//
// ISSUE-2000/11/20-mgrier
//  These functions are VOID because they should really never be able to fail.
//
//  In the current implementation, they do perform ANSI -> UNICODE conversions
//  which may fail in the current code page (may have been changed since when
//  the DLL was loaded) and apply Fusion DLL redirection to DLLs which can
//  require a large filename buffer than is allocated on the stack.
//
//  These cases are ignored for now.  Both problems should be fixed by
//  reworking the LDR_DATA_TABLE_ENTRY to have an array of pointers to the
//  downstream LDR_DATA_TABLE_ENTRY structs and not have to do any work
//  later on, but that's a lot of work for now; the ANSI -> UNICODE thing
//  has been there for ages and in practice, the paths that Fusion
//  redirects to have to fix in DOS_MAX_PATH_LENGTH, so we'll emit some
//  debug spew in the failure case, but ignore the failures.
//
//  I started both fixes (returning status or allocating the array
//  at dll load time) but neither are trivial.  Returning a status will just
//  make FreeLibrary() fail and leave the refcounts of the DLLs after the
//  one that failed inconsistent.  Allocating the array is nontrivial
//  to do it the right way where the LDR_DATA_TABLE_ENTRY and the array
//  are allocated in a single allocation, and having the loader make more
//  even heap allocations seems like the wrong thing to do.
//


/*
VOID
LdrpReferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

VOID
LdrpDereferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

VOID
LdrpPinLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );
*/

#define LdrpReferenceLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2((LdrDataTableEntry), LDRP_UPDATE_LOAD_COUNT_INCREMENT)
#define LdrpDereferenceLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2((LdrDataTableEntry), LDRP_UPDATE_LOAD_COUNT_DECREMENT)
#define LdrpPinLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2((LdrDataTableEntry), LDRP_UPDATE_LOAD_COUNT_PIN)

#define LDRP_UPDATE_LOAD_COUNT_INCREMENT (1)
#define LDRP_UPDATE_LOAD_COUNT_DECREMENT (2)
#define LDRP_UPDATE_LOAD_COUNT_PIN       (3)

VOID
LdrpUpdateLoadCount3(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow,
    IN OUT PUNICODE_STRING PreAllocatedRedirectionBuffer OPTIONAL
    );

VOID
LdrpUpdateLoadCount2(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow
    );

NTSTATUS
LdrpInitializeProcess(
    IN PCONTEXT Context OPTIONAL,
    IN PVOID SystemDllBase
    );

VOID
LdrpInitialize(
    IN PCONTEXT Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
LdrpInsertMemoryTableEntry(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

NTSTATUS
LdrpResolveDllName(
    IN PCWSTR DllPath OPTIONAL,
    IN PCWSTR DllName,
    IN BOOLEAN Redirected,
    OUT PUNICODE_STRING FullDllName,
    OUT PUNICODE_STRING BaseDllName,
    OUT PHANDLE DllFile
    );

NTSTATUS
LdrpResolveDllNameForAppPrivateRedirection(
    IN PCUNICODE_STRING DllName,
    OUT PUNICODE_STRING FullDllName
    );

NTSTATUS
LdrpCreateDllSection(
    IN PCUNICODE_STRING FullDllName,
    IN HANDLE DllFile,
    IN PULONG DllCharacteristics OPTIONAL,
    OUT PHANDLE SectionHandle
    );

VOID
LdrpInitializePathCache(
    VOID
    );

PVOID
LdrpFetchAddressOfEntryPoint(
    IN PVOID Base
    );

NTSTATUS
LdrpCheckForKnownDll(
    IN PCWSTR DllName,
    OUT PUNICODE_STRING FullDllName,
    OUT PUNICODE_STRING BaseDllName,
    OUT HANDLE *Section
    );

NTSTATUS
LdrpSetProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    );

#if DBG
extern ULONG LdrpCompareCount;
extern ULONG LdrpSnapBypass;
extern ULONG LdrpNormalSnap;
extern ULONG LdrpSectionOpens;
extern ULONG LdrpSectionCreates;
extern ULONG LdrpSectionMaps;
extern ULONG LdrpSectionRelocates;
extern BOOLEAN LdrpDisplayLoadTime;
extern LARGE_INTEGER BeginTime, InitcTime, InitbTime, IniteTime, EndTime, ElapsedTime, Interval;

#endif // DBG

extern BOOLEAN ShowSnaps;
extern BOOLEAN ShowErrors;
extern BOOLEAN RtlpTimoutDisable;
extern LARGE_INTEGER RtlpTimeout;
extern ULONG NtGlobalFlag;
extern LIST_ENTRY RtlCriticalSectionList;
extern RTL_CRITICAL_SECTION RtlCriticalSectionLock;
extern BOOLEAN LdrpShutdownInProgress;
extern BOOLEAN LdrpInLdrInit;
extern BOOLEAN LdrpLdrDatabaseIsSetup;
extern BOOLEAN LdrpVerifyDlls;
extern BOOLEAN LdrpShutdownInProgress;
extern BOOLEAN LdrpImageHasTls;


extern PLDR_DATA_TABLE_ENTRY LdrpImageEntry;
extern LIST_ENTRY LdrpUnloadHead;
extern BOOLEAN LdrpActiveUnloadCount;
extern PLDR_DATA_TABLE_ENTRY LdrpGetModuleHandleCache;
extern PLDR_DATA_TABLE_ENTRY LdrpLoadedDllHandleCache;
extern ULONG LdrpFatalHardErrorCount;
extern UNICODE_STRING LdrpDefaultPath;
extern RTL_CRITICAL_SECTION FastPebLock;
extern HANDLE LdrpShutdownThreadId;
extern ULONG LdrpNumberOfProcessors;

extern UNICODE_STRING DefaultExtension;
extern UNICODE_STRING User32String;
extern UNICODE_STRING Kernel32String;

typedef struct _LDRP_TLS_ENTRY {
    LIST_ENTRY Links;
    IMAGE_TLS_DIRECTORY Tls;
} LDRP_TLS_ENTRY, *PLDRP_TLS_ENTRY;

extern LIST_ENTRY LdrpTlsList;
extern ULONG LdrpNumberOfTlsEntries;

NTSTATUS
LdrpInitializeTls(
        VOID
        );

NTSTATUS
LdrpAllocateTls(
        VOID
        );
VOID
LdrpFreeTls(
        VOID
        );

VOID
LdrpCallTlsInitializers(
    PVOID DllBase,
    ULONG Reason
    );

NTSTATUS
LdrpAllocateUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN USHORT Length
    );

NTSTATUS
LdrpCopyUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN PCUNICODE_STRING StringIn
    );

VOID
LdrpFreeUnicodeString(
    IN OUT PUNICODE_STRING String
    );

VOID
LdrpEnsureLoaderLockIsHeld(
    VOID
    );

#define LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED (0x00000001)

NTSTATUS
LdrpLoadDll(
    IN ULONG Flags OPTIONAL,
    IN PCWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PCUNICODE_STRING DllName,
    OUT PVOID *DllHandle,
    IN BOOLEAN RunInitRoutines
    );

NTSTATUS
NTAPI
LdrpGetProcedureAddress(
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress,
    IN BOOLEAN RunInitRoutines
    );

PLIST_ENTRY
RtlpLockProcessHeapsList( VOID );


VOID
RtlpUnlockProcessHeapsList( VOID );

BOOLEAN
RtlpSerializeHeap(
    IN PVOID HeapHandle
    );

ULONG NtdllBaseTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( NtdllBaseTag, (t) ))

#define CSR_TAG 0
#define LDR_TAG 1
#define CURDIR_TAG 2
#define TLS_TAG 3
#define DBG_TAG 4
#define SE_TAG 5
#define TEMP_TAG 6
#define ATOM_TAG 7

PVOID
LdrpDefineDllTag(
    PWSTR TagName,
    PUSHORT TagIndex
    );

#define LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpDllActivateActivationContext_TableEntry) \
    { \
        RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME LdrpDllActivateActivationContext_ActivationFrame = \
            {   sizeof(LdrpDllActivateActivationContext_ActivationFrame), \
                RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER \
            }; \
     \
        RtlActivateActivationContextUnsafeFast(&LdrpDllActivateActivationContext_ActivationFrame, (LdrpDllActivateActivationContext_TableEntry)->EntryPointActivationContext); \
        __try {

#define LDRP_DEACTIVATE_ACTIVATION_CONTEXT() \
        } __finally { \
            RtlDeactivateActivationContextUnsafeFast(&LdrpDllActivateActivationContext_ActivationFrame); \
        } \
    }

#if defined(_X86_)
BOOLEAN
LdrpCallInitRoutine(
    IN PDLL_INIT_ROUTINE InitRoutine,
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    );
#else

#define LdrpCallInitRoutine(InitRoutine, DllHandle, Reason, Context)    \
    (InitRoutine)((DllHandle), (Reason), (Context))

#endif

NTSTATUS
LdrpCorValidateImage(
    IN OUT PVOID *pImageBase,
    IN LPWSTR ImageName
    );

VOID
LdrpCorUnloadImage(
    IN PVOID ImageBase
    );

VOID
LdrpCorReplaceStartContext(
    IN PCONTEXT Context
    );

typedef VOID (*PCOR_EXE_MAIN)(VOID);
extern PCOR_EXE_MAIN CorExeMain;

VOID
LdrpSendDllNotifications (
    IN PLDR_DATA_TABLE_ENTRY Entry,
    IN ULONG NotificationType,
    IN ULONG Flags
    );

//
// The prototypes for the shim engine callback
//

typedef void (*PFNSE_INSTALLBEFOREINIT)(PUNICODE_STRING UnicodeImageName,
                                        PVOID           pShimExeData);

typedef BOOLEAN (*PFNSE_INSTALLAFTERINIT)(PUNICODE_STRING UnicodeImageName,
                                          PVOID           pShimExeData);

typedef void (*PFNSE_DLLLOADED)(PLDR_DATA_TABLE_ENTRY LdrEntry);

typedef void (*PFNSE_DLLUNLOADED)(PLDR_DATA_TABLE_ENTRY LdrEntry);

typedef void (*PFNSE_GETPROCADDRESS)(PVOID* pProcAddress);

typedef int (*PFNSE_ISSHIMDLL)(PVOID pDllBase);

typedef void (*PFNSE_PROCESSDYING)(void);

//
// Private function from ntos\rtl\stktrace.c needed to pickup the real address
// of a stack trace given an index.
//

PVOID
RtlpGetStackTraceAddress (
    USHORT Index
    );

//
// Function defined in ntos\rtl\stktrace.c needed to speedup
// RtlCaptureStackContext on x86.
//

VOID
RtlpStkMarkDllRange (
    PLDR_DATA_TABLE_ENTRY DllEntry
    );


//
// resource.c
//

extern BOOLEAN RtlpCriticalSectionVerifier;

BOOLEAN
RtlpCreateCriticalSectionSem(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

//
// Application verifier
//

#include "avrfp.h"

//
//  Hot-patching
//

#include "hotpatch.h"

NTSTATUS
LdrpRundownHotpatchList(
    PRTL_PATCH_HEADER PatchHead
    );


typedef NTSTATUS (NTAPI * PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION)(VOID);
extern PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION Kernel32ProcessInitPostImportFunction;

#endif // _LDRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrapi.c

Abstract:

    This module implements the Ldr APIs that can be linked with
    an application to perform loader services. All of the APIs in
    this component are implemented in a DLL. They are not part of the
    DLL snap procedure.

Author:

    Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

--*/

#include "ldrp.h"
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objidl.h"
#include <windows.h>
#include <apcompat.h>
#include <shimhapi.h>

#if defined(_WIN64)
#include <wow64t.h>
#endif // defined(_WIN64)

#define ULONG_PTR_IZE(_x) ((ULONG_PTR) (_x))
#define ULONG_PTR_IZE_SHIFT_AND_MASK(_x, _shift, _mask) ((ULONG_PTR) ((ULONG_PTR_IZE((_x)) & (_mask)) << (_shift)))

#define CHAR_BITS 8

#define LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH (4)
#define LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET ((CHAR_BITS * sizeof(PVOID)) - LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH)
#define LOADER_LOCK_COOKIE_TYPE_BIT_MASK ((1 << LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH) - 1)

#define LOADER_LOCK_COOKIE_TID_BIT_LENGTH (12)
#define LOADER_LOCK_COOKIE_TID_BIT_OFFSET (LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET - LOADER_LOCK_COOKIE_TID_BIT_LENGTH)
#define LOADER_LOCK_COOKIE_TID_BIT_MASK ((1 << LOADER_LOCK_COOKIE_TID_BIT_LENGTH) - 1)

#define LOADER_LOCK_COOKIE_CODE_BIT_LENGTH (16)
#define LOADER_LOCK_COOKIE_CODE_BIT_OFFSET (0)
#define LOADER_LOCK_COOKIE_CODE_BIT_MASK ((1 << LOADER_LOCK_COOKIE_CODE_BIT_LENGTH) - 1)

#define MAKE_LOADER_LOCK_COOKIE(_type, _code) \
    ((ULONG_PTR) (ULONG_PTR_IZE_SHIFT_AND_MASK((_type), LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET, LOADER_LOCK_COOKIE_TYPE_BIT_MASK) | \
                  ULONG_PTR_IZE_SHIFT_AND_MASK((HandleToUlong((NtCurrentTeb())->ClientId.UniqueThread)), LOADER_LOCK_COOKIE_TID_BIT_OFFSET, LOADER_LOCK_COOKIE_TID_BIT_MASK) | \
                  ULONG_PTR_IZE_SHIFT_AND_MASK((_code), LOADER_LOCK_COOKIE_CODE_BIT_OFFSET, LOADER_LOCK_COOKIE_CODE_BIT_MASK)))

#define EXTRACT_LOADER_LOCK_COOKIE_FIELD(_cookie, _shift, _mask) ((((ULONG_PTR) (_cookie)) >> (_shift)) & (_mask))
#define EXTRACT_LOADER_LOCK_COOKIE_TYPE(_cookie) EXTRACT_LOADER_LOCK_COOKIE_FIELD((_cookie), LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET, LOADER_LOCK_COOKIE_TYPE_BIT_MASK)
#define EXTRACT_LOADER_LOCK_COOKIE_TID(_cookie) EXTRACT_LOADER_LOCK_COOKIE_FIELD((_cookie), LOADER_LOCK_COOKIE_TID_BIT_OFFSET, LOADER_LOCK_COOKIE_TID_BIT_MASK)

#define LOADER_LOCK_COOKIE_TYPE_NORMAL (0)

LONG LdrpLoaderLockAcquisitionCount;

// Note the case inconsistency is due to preserving case from earlier versions.
WCHAR DllExtension[] = L".dll";
UNICODE_STRING LdrApiDefaultExtension = RTL_CONSTANT_STRING(L".DLL");

PLDR_MANIFEST_PROBER_ROUTINE LdrpManifestProberRoutine = NULL;

extern PFNSE_DLLLOADED         g_pfnSE_DllLoaded;
extern PFNSE_DLLUNLOADED       g_pfnSE_DllUnloaded;

PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION LdrpAppCompatDllRedirectionCallbackFunction = NULL;
PVOID LdrpAppCompatDllRedirectionCallbackData = NULL;
BOOLEAN LdrpShowRecursiveDllLoads;
BOOLEAN LdrpBreakOnRecursiveDllLoads;
PLDR_DATA_TABLE_ENTRY LdrpCurrentDllInitializer;

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

ULONG
LdrpClearLoadInProgress(
    VOID
    );


NTSTATUS
LdrLoadDll (
    IN PCWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PCUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )

/*++

Routine Description:

    This function loads a DLL into the calling process address space.

Arguments:

    DllPath - Supplies the search path to be used to locate the DLL.

    DllCharacteristics - Supplies an optional DLL characteristics flag,
        that if specified is used to match against the dll being loaded.

    DllName - Supplies the name of the DLL to load.

    DllHandle - Returns a handle to the loaded DLL.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    WCHAR StaticRedirectedDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectedDllName;
    UNICODE_STRING DynamicRedirectedDllName = {0};
    ULONG LoadDllFlags = 0;
    PCUNICODE_STRING OldTopLevelDllBeingLoaded = NULL;
    PVOID LockCookie = NULL;
    PTEB Teb;

    //
    // We need to disable page heap fault injection while loader is active.
    // This is important so that we avoid lots of hits(failures) in this
    // area. The Disable/Enable function have basically zero impact on
    // performance because they just increment/decrement a lock variable
    // that is checked when an actual allocation is performed (page heap
    // needs to be enabled for that).
    //

    RtlpDphDisableFaultInjection ();

    StaticRedirectedDllName.Length = 0;
    StaticRedirectedDllName.MaximumLength = sizeof(StaticRedirectedDllNameBuffer);
    StaticRedirectedDllName.Buffer = StaticRedirectedDllNameBuffer;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                DllName,                    // dll name to look up
                &LdrApiDefaultExtension,
                &StaticRedirectedDllName,
                &DynamicRedirectedDllName,
                (PUNICODE_STRING*)&DllName, // Result is either StaticRedirectedDllName or DynamicRedirectedDllName
                NULL,
                NULL,                       // not interested in where the filename starts
                NULL);                      // not interested in bytes required if we only had a static string
    if (NT_SUCCESS(Status)) {
        LoadDllFlags |= LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED;
    } else if (Status != STATUS_SXS_KEY_NOT_FOUND) {
#if DBG
        DbgPrint("%s(%wZ): RtlDosApplyFileIsolationRedirection_Ustr() failed with status %08lx\n", __FUNCTION__, DllName, Status);
#endif // DBG
        goto Exit;
    }

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    OldTopLevelDllBeingLoaded = LdrpTopLevelDllBeingLoaded;

    if (OldTopLevelDllBeingLoaded) {
        if (ShowSnaps || LdrpShowRecursiveDllLoads || LdrpBreakOnRecursiveDllLoads) {
            Teb = NtCurrentTeb();

            DbgPrint(
                "[%lx,%lx] LDR: Recursive DLL load\n",
                HandleToULong(Teb->ClientId.UniqueProcess),
                HandleToULong(Teb->ClientId.UniqueThread));

            DbgPrint(
                "[%lx,%lx]   Previous DLL being loaded: \"%wZ\"\n",
                HandleToULong(Teb->ClientId.UniqueProcess),
                HandleToULong(Teb->ClientId.UniqueThread),
                OldTopLevelDllBeingLoaded);

            DbgPrint(
                "[%lx,%lx]   DLL being requested: \"%wZ\"\n",
                HandleToULong(Teb->ClientId.UniqueProcess),
                HandleToULong(Teb->ClientId.UniqueThread),
                DllName);

            if (LdrpCurrentDllInitializer != NULL) {
                DbgPrint(
                    "[%lx,%lx]   DLL whose initializer was currently running: \"%wZ\"\n",
                    HandleToULong(Teb->ClientId.UniqueProcess),
                    HandleToULong(Teb->ClientId.UniqueThread),
                    &LdrpCurrentDllInitializer->FullDllName);
            } else {
                DbgPrint(
                    "[%lx,%lx]   No DLL initializer was running\n",
                    HandleToULong(Teb->ClientId.UniqueProcess),
                    HandleToULong(Teb->ClientId.UniqueThread));
            }
        }
    }

    LdrpTopLevelDllBeingLoaded = DllName;

    __try {

        Status = LdrpLoadDll (LoadDllFlags,
                              DllPath,
                              DllCharacteristics,
                              DllName,
                              DllHandle,
                              TRUE);

        if (!NT_SUCCESS(Status)) {
            if ((Status != STATUS_NO_SUCH_FILE) &&
                (Status != STATUS_DLL_NOT_FOUND) &&
                (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {

                // Dll initialization failure is common enough that we won't want to print unless snaps are turned on.
                if (ShowSnaps || (Status != STATUS_DLL_INIT_FAILED)) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - failing because LdrpLoadDll(%wZ) returned status %x\n",
                        __FUNCTION__,
                        DllName,
                        Status);
                }
            }

            __leave;
        }
        Status = STATUS_SUCCESS;
    } __finally {
        LdrpTopLevelDllBeingLoaded = OldTopLevelDllBeingLoaded;
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

Exit:
    if (DynamicRedirectedDllName.Buffer != NULL) {
        RtlFreeUnicodeString(&DynamicRedirectedDllName);
    }

    //
    // Reenable page heap fault injection.
    //

    RtlpDphEnableFaultInjection ();

    return Status;
}


NTSTATUS
NTAPI
LdrpLoadDll (
    IN ULONG Flags OPTIONAL,
    IN PCWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PCUNICODE_STRING DllName,
    OUT PVOID *DllHandle,
    IN BOOLEAN RunInitRoutines
    )
{
    NTSTATUS st;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PWSTR ActualDllName;
    PWCH p, pp;
    UNICODE_STRING ActualDllNameStr;
    WCHAR FreeBuffer[LDR_MAX_PATH + 1];
    BOOLEAN Redirected;
    ULONG DllNameLength;
    const InLdrInit = LdrpInLdrInit;

    if (Flags & LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED) {
        Redirected = TRUE;
    }
    else {
        Redirected = FALSE;
    }

    st = STATUS_SUCCESS;

    p = DllName->Buffer;
    pp = NULL;

    while (*p) {

        switch (*p++) {
        case L'.':
            //
            // pp will point to first character after the last '.', if
            // it occurs after the last '\'.
            //

            pp = p;
            break;
            
        case L'\\':

            pp = NULL;
            break;

        default:
            NOTHING;
        }
    }

    if (DllName->Length >= sizeof(FreeBuffer)) {
        return STATUS_NAME_TOO_LONG;
    }

    ActualDllName = FreeBuffer;

    RtlCopyMemory (ActualDllName, DllName->Buffer, DllName->Length);

    if (!pp || *pp == (WCHAR)'\\') {

        //
        // No extension found (just ..\)
        //

        DllNameLength = DllName->Length + sizeof(DllExtension) - sizeof(WCHAR);
        if ((DllNameLength + sizeof(WCHAR)) >= sizeof(FreeBuffer)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Dll name missing extension; with extension added the length is too long\n"
                "   DllName: (@ %p) \"%wZ\"\n"
                "   DllName->Length: %u\n",
                __FUNCTION__,
                DllName, DllName,
                DllName->Length);

            return STATUS_NAME_TOO_LONG;
        }

        RtlCopyMemory ((PCHAR)ActualDllName+DllName->Length, DllExtension, sizeof(DllExtension));
        ActualDllNameStr.Length = (USHORT)(DllNameLength);
    } else {
        ActualDllName[DllName->Length >> 1] = UNICODE_NULL;
        ActualDllNameStr.Length = DllName->Length;
    }

    ActualDllNameStr.MaximumLength = sizeof(FreeBuffer);
    ActualDllNameStr.Buffer = ActualDllName;
    LdrDataTableEntry = NULL;

    //
    // Except during process initialization, grab loader lock and
    // Snap all links to the specified DLL.
    //

    if (!InLdrInit) {
        RtlEnterCriticalSection (&LdrpLoaderLock);
    }

    try {

        if (ShowSnaps) {
            DbgPrint("LDR: LdrLoadDll, loading %ws from %ws\n",
                ActualDllName,
                ARGUMENT_PRESENT(DllPath) ? DllPath : L""
                );
        }

        if (!LdrpCheckForLoadedDll( DllPath,
                                    &ActualDllNameStr,
                                    FALSE,
                                    Redirected,
                                    &LdrDataTableEntry)) {

            st = LdrpMapDll(DllPath,
                            ActualDllName,
                            DllCharacteristics,
                            FALSE,
                            Redirected,
                            &LdrDataTableEntry);

            if (!NT_SUCCESS(st)) {
                leave;
            }

#if defined(_X86_)

            //
            // Register dll with the stack tracing module.
            // This is used for getting reliable stack traces on X86.
            //

            RtlpStkMarkDllRange (LdrDataTableEntry);
#endif

            if (ARGUMENT_PRESENT( DllCharacteristics ) &&
                *DllCharacteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {

                LdrDataTableEntry->EntryPoint = 0;
                LdrDataTableEntry->Flags &= ~LDRP_IMAGE_DLL;
            }

            //
            // walk the import descriptor table of the dll
            //

            if (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL) {

                try {
                    
                    //
                    // if the image is COR-ILONLY, then don't walk the import descriptor 
                    // as it is assumed that it only imports %windir%\system32\mscoree.dll, otherwise
                    // walk the import descriptor table of the dll.
                    //

                    if ((LdrDataTableEntry->Flags & LDRP_COR_IMAGE) == 0) {
                        st = LdrpWalkImportDescriptor(
                                  DllPath,
                                  LdrDataTableEntry
                                  );
                    }
                } __except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %x thrown by LdrpWalkImportDescriptor\n",
                        __FUNCTION__,
                        st);
                }

                if ( LdrDataTableEntry->LoadCount != 0xffff ) {
                    LdrDataTableEntry->LoadCount += 1;
                }

                LdrpReferenceLoadedDll (LdrDataTableEntry);

                if (!NT_SUCCESS(st)) {
                    LdrDataTableEntry->EntryPoint = NULL;
                    InsertTailList(
                        &PebLdr.InInitializationOrderModuleList,
                        &LdrDataTableEntry->InInitializationOrderLinks);

                    LdrpClearLoadInProgress();

                    if (ShowSnaps) {
                        DbgPrint("LDR: Unloading %wZ due to error %x walking import descriptors\n", DllName, st);
                    }

                    LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);
                    leave;
                }
            }
            else {
                if ( LdrDataTableEntry->LoadCount != 0xffff ) {
                    LdrDataTableEntry->LoadCount += 1;
                }
            }

            //
            // Add init routine to list
            //

            InsertTailList(&PebLdr.InInitializationOrderModuleList,
                           &LdrDataTableEntry->InInitializationOrderLinks);


            //
            // If the loader data base is not fully setup, this load was because
            // of a forwarder in the static load set. Can't run init routines
            // yet because the load counts are NOT set
            //

            if ( RunInitRoutines && LdrpLdrDatabaseIsSetup ) {

                //
                // Shim engine callback. This is the chance to patch
                // dynamically loaded modules.
                //

                if (g_pfnSE_DllLoaded != NULL) {
                    (*g_pfnSE_DllLoaded)(LdrDataTableEntry);
                }

                try {

                    st = LdrpRunInitializeRoutines (NULL);

                    if ( !NT_SUCCESS(st) ) {
                        if (ShowSnaps) {
                            DbgPrint("LDR: Unloading %wZ because either its init routine or one of its static imports failed; status = 0x%08lx", DllName, st);
                        }

                        LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);
                    }
                }
                __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %08lx thrown running initialization routines for %wZ\n",
                        __FUNCTION__,
                        st,
                        &LdrDataTableEntry->FullDllName);

                    LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);

                    leave;
                }
            }
            else {
                st = STATUS_SUCCESS;
            }
        }
        else {

            //
            // Count it and everything that it imports.
            //

            if ( LdrDataTableEntry->Flags & LDRP_IMAGE_DLL &&
                 LdrDataTableEntry->LoadCount != 0xffff  ) {

                LdrDataTableEntry->LoadCount += 1;

                LdrpReferenceLoadedDll(LdrDataTableEntry);

                //
                // Now clear the Load in progress bits
                //

                LdrpClearLoadInProgress();
            }
            else {
                if ( LdrDataTableEntry->LoadCount != 0xffff ) {
                    LdrDataTableEntry->LoadCount += 1;
                }
            }
        }
    }
    __finally {
        if (!InLdrInit) {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        }
    }

    if (NT_SUCCESS(st)) {
        *DllHandle = (PVOID)LdrDataTableEntry->DllBase;
    }
    else {
        *DllHandle = NULL;
    }

    return st;
}


NTSTATUS
LdrGetDllHandle(
    IN PCWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PCUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )
{
    //
    // Preserve the old behavior.
    //

    return LdrGetDllHandleEx (LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT,
                              DllPath,
                              DllCharacteristics,
                              DllName,
                              DllHandle);
}


NTSTATUS
LdrGetDllHandleEx(
    IN ULONG Flags,
    IN PCWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PCUNICODE_STRING ConstDllName,
    OUT PVOID *DllHandle OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified DLL and returns its handle.

Arguments:

    Flags - various bits to affect the behavior

        default: the returned handle is addrefed

        LDR_GET_DLL_HANDLE_EX_PIN - the dll will not be unloaded until
                the process exits

        LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT - the dll's reference
                count is not changed

    DllPath - Supplies the search path to be used to locate the DLL.

    DllCharacteristics - Supplies an optional DLL characteristics flag,
        that if specified is used to match against the dll being loaded.
        The currently supported flags are:

            IMAGE_FILE_EXECUTABLE_IMAGE - indicates that imported dll
                referenced by the DLL being loaded should not be followed.
                This corresponds to DONT_RESOLVE_DLL_REFERENCES

            IMAGE_FILE_SYSTEM - indicates that the DLL is a known trusted
                system component and that WinSafer sandbox checking
                should not be performed on the DLL before loading it.

    DllName - Supplies the name of the DLL to load.

    DllHandle - Returns a handle to the loaded DLL.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st = STATUS_ACCESS_VIOLATION;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    PWCH p, pp, pEnd;
    UNICODE_STRING ActualDllNameStr = {0, 0, NULL};
    UNICODE_STRING DynamicRedirectedDllName = {0, 0, NULL};
    BOOLEAN Redirected = FALSE;
    BOOLEAN HoldingLoaderLock = FALSE;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;
    const ULONG ValidFlags = LDR_GET_DLL_HANDLE_EX_PIN | LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT;    
    UNICODE_STRING xDllName;
    const PUNICODE_STRING DllName = &xDllName;

    UNREFERENCED_PARAMETER (DllCharacteristics);

    xDllName = *ConstDllName;

    __try {

        if (DllHandle != NULL) {
            *DllHandle = NULL;
        }

        if (Flags & ~ValidFlags) {
            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        //
        // DllHandle is optional if you are pinning the .dll, otherwise it is mandatory.
        //
        if ((DllHandle == NULL) &&
            (Flags & LDR_GET_DLL_HANDLE_EX_PIN) == 0) {

            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if ((Flags & LDR_GET_DLL_HANDLE_EX_PIN) &&
            (Flags & LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT)) {

            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        //
        // Grab Ldr lock
        //

        if (!InLdrInit) {
            st = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(st)) {
                goto Exit;
            }
            HoldingLoaderLock = TRUE;
        }

        st = RtlDosApplyFileIsolationRedirection_Ustr(
                    RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                    DllName,
                    &LdrApiDefaultExtension,
                    NULL,
                    &DynamicRedirectedDllName,
                    (PUNICODE_STRING*)&DllName,
                    NULL,
                    NULL,
                    NULL);
        if (NT_SUCCESS(st)) {
            Redirected = TRUE;
        } else if (st != STATUS_SXS_KEY_NOT_FOUND) {
            // Something unusual and bad happened.
            __leave;
        }

        st = STATUS_DLL_NOT_FOUND;

        if ( LdrpGetModuleHandleCache ) {
            if (Redirected) {
                if (((LdrpGetModuleHandleCache->Flags & LDRP_REDIRECTED) != 0) &&
                    RtlEqualUnicodeString(DllName, &LdrpGetModuleHandleCache->FullDllName, TRUE)) {

                    LdrDataTableEntry = LdrpGetModuleHandleCache;
                    st = STATUS_SUCCESS;
                    goto Exit;
                }
            } else {
                // Not redirected...
                if (((LdrpGetModuleHandleCache->Flags & LDRP_REDIRECTED) == 0) &&
                    RtlEqualUnicodeString(DllName, &LdrpGetModuleHandleCache->BaseDllName, TRUE)) {

                    LdrDataTableEntry = LdrpGetModuleHandleCache;
                    st = STATUS_SUCCESS;
                    goto Exit;
                }
            }
        }

        p = DllName->Buffer;
        pEnd = p + (DllName->Length / sizeof(WCHAR));

        pp = NULL;

        while (p != pEnd) {
            switch (*p++) {
            case L'.':
                //
                // pp will point to the first character after the last 
                // '.', if it occurs after the last '\'.
                //

                pp = p;
                break;

            case L'\\':

                pp = NULL;
                break;

            default:
                NOTHING;
            }
        }

        if ((pp == NULL) || (*pp == L'\\') || (*pp == L'/')) {

            //
            // The max length here must include the null-termination, but the length itself
            // should not.  NB that sizeof(DllExtension) will include the size for the
            // terminating UNICODE_NULL
            //
            ActualDllNameStr.MaximumLength = DllName->Length + sizeof(DllExtension);
            ActualDllNameStr.Length = ActualDllNameStr.MaximumLength - sizeof(WCHAR);

            ActualDllNameStr.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, ActualDllNameStr.MaximumLength);
            if (ActualDllNameStr.Buffer == NULL) {
                st = STATUS_NO_MEMORY;
                goto Exit;
            }

            //
            // Copy the name and the default extension onto the string  This magically null-terminates,
            // as DllExtension includes the unicode null character.
            //
            RtlCopyMemory(ActualDllNameStr.Buffer, DllName->Buffer, DllName->Length);
            RtlCopyMemory(((PCHAR)ActualDllNameStr.Buffer) + DllName->Length, DllExtension, sizeof(DllExtension));

        } else {

            //
            // Trim the trailing dot
            //
            if ((DllName->Length != 0) && (DllName->Buffer[(DllName->Length / sizeof(WCHAR)) - 1] == L'.')) {
                DllName->Length -= sizeof(WCHAR);
            }

            //
            // Size the buffer, allocate - set the max length to include the NULL character
            //
            ActualDllNameStr.MaximumLength = DllName->Length + sizeof(WCHAR);
            ActualDllNameStr.Length = DllName->Length;
            ActualDllNameStr.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, ActualDllNameStr.MaximumLength);
            if (ActualDllNameStr.Buffer == NULL) {
                st = STATUS_NO_MEMORY;
                goto Exit;
            }


            //
            // Copy data into it
            //
            RtlCopyMemory(ActualDllNameStr.Buffer, DllName->Buffer, DllName->Length);  

            //
            // And null-terminate by hand
            //
            ActualDllNameStr.Buffer[ActualDllNameStr.Length / sizeof(WCHAR)] = UNICODE_NULL;

        }

        
        //
        // Check the LdrTable to see if Dll has already been loaded
        // into this image.
        //
        if (ShowSnaps) {
            DbgPrint(
                "LDR: LdrGetDllHandle, searching for %wZ from %ws\n",
                &ActualDllNameStr,
                ARGUMENT_PRESENT(DllPath) ? (DllPath == (PWSTR)1 ? L"" : DllPath) : L""
                );
        }

        //
        // sort of a hack, but done to speed up GetModuleHandle. kernel32
        // now does a two pass call here to avoid computing
        // process dll path
        //

        if (LdrpCheckForLoadedDll(DllPath,
                                  &ActualDllNameStr,
                                  (BOOLEAN)(DllPath == (PWSTR)1 ? TRUE : FALSE),
                                  Redirected,
                                  &LdrDataTableEntry)) {
            LdrpGetModuleHandleCache = LdrDataTableEntry;
            st = STATUS_SUCCESS;
            goto Exit;
        }
        LdrDataTableEntry = NULL;
        RTL_SOFT_ASSERT(st == STATUS_DLL_NOT_FOUND);
Exit:
        ASSERT((LdrDataTableEntry != NULL) == NT_SUCCESS(st));

        if (LdrDataTableEntry != NULL && NT_SUCCESS(st)) {

            //
            // It's standard gross procedure to put the check for 0xffff,
            // and the updates of the root LoadCount outside the
            // call to LdrpUpdateLoadCount..
            //

            if (LdrDataTableEntry->LoadCount != 0xffff) {

                if ((Flags & LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT) != 0) {
                    // nothing
                }
                else {
                    if (Flags & LDR_GET_DLL_HANDLE_EX_PIN) {
                        LdrDataTableEntry->LoadCount = 0xffff;
                        LdrpPinLoadedDll(LdrDataTableEntry);
                    }
                    else {
                        LdrDataTableEntry->LoadCount++;
                        LdrpReferenceLoadedDll(LdrDataTableEntry);
                    }
                    LdrpClearLoadInProgress();
                }
            }
            if (DllHandle != NULL) {
                *DllHandle = (PVOID)LdrDataTableEntry->DllBase;
            }
        }
    } __finally {
        if (DynamicRedirectedDllName.Buffer != NULL) {
            RtlFreeUnicodeString(&DynamicRedirectedDllName);
        }

        if (ActualDllNameStr.Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)ActualDllNameStr.Buffer);
            ActualDllNameStr.Buffer = NULL;
        }

        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return st;
}


NTSTATUS
LdrDisableThreadCalloutsForDll (
    IN PVOID DllHandle
    )

/*++

Routine Description:

    This function disables thread attach and detach notification
    for the specified DLL.

Arguments:

    DllHandle - Supplies a handle to the DLL to disable.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st = STATUS_SUCCESS;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    BOOL HoldingLoaderLock = FALSE;
    PVOID LockCookie = NULL;

    if ( LdrpShutdownInProgress ) {
        return STATUS_SUCCESS;
        }

    try {

        if ( InLdrInit == FALSE ) {
            st = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(st))
                goto Exit;
            HoldingLoaderLock = TRUE;
            }

        if (LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)) {
            if ( LdrDataTableEntry->TlsIndex ) {
                st = STATUS_DLL_NOT_FOUND;
                }
            else {
                LdrDataTableEntry->Flags |= LDRP_DONT_CALL_FOR_THREADS;
                }
            }
Exit:
        ;
    }
    finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
            }
        }
    return st;
}

ULONG LdrpUnloadIndex = 0;
RTL_UNLOAD_EVENT_TRACE RtlpUnloadEventTrace[RTL_UNLOAD_EVENT_TRACE_NUMBER];


NTSYSAPI
PRTL_UNLOAD_EVENT_TRACE
NTAPI
RtlGetUnloadEventTrace (
    VOID
    )
{
    return RtlpUnloadEventTrace;
}


VOID
LdrpRecordUnloadEvent (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
/*++

Routine Description:

    This function records in a ring buffer the last few dll unloads

Arguments:

    LdrDataTableEntry - The ldr entry for this dll

Return Value:

    None.

--*/
{
    ULONG Seq, i, Len;
    PVOID BaseAddress;
    PIMAGE_NT_HEADERS NtHeaders;

    Seq = LdrpUnloadIndex++;
    i = Seq % RTL_UNLOAD_EVENT_TRACE_NUMBER;

    BaseAddress = LdrDataTableEntry->DllBase;
    RtlpUnloadEventTrace[i].Sequence    = Seq;
    RtlpUnloadEventTrace[i].BaseAddress = BaseAddress;
    RtlpUnloadEventTrace[i].SizeOfImage = LdrDataTableEntry->SizeOfImage;

    Len = LdrDataTableEntry->BaseDllName.Length;
    if (Len > sizeof (RtlpUnloadEventTrace[i].ImageName)) {
        Len = sizeof (RtlpUnloadEventTrace[i].ImageName);
    }
    RtlCopyMemory (RtlpUnloadEventTrace[i].ImageName,
                   LdrDataTableEntry->BaseDllName.Buffer,
                   Len);
    if (Len < sizeof (RtlpUnloadEventTrace[i].ImageName)) {
        RtlpUnloadEventTrace[i].ImageName[Len/sizeof (WCHAR)] = L'\0';
    }

    NtHeaders = RtlImageNtHeader (BaseAddress);
    if (NtHeaders != NULL) {
        RtlpUnloadEventTrace[i].TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        RtlpUnloadEventTrace[i].CheckSum      = NtHeaders->OptionalHeader.CheckSum;
    } else {
        RtlpUnloadEventTrace[i].TimeDateStamp = 0;
        RtlpUnloadEventTrace[i].CheckSum      = 0;
    }
}


NTSTATUS
LdrUnloadDll (
    IN PVOID DllHandle
    )

/*++

Routine Description:

    This function unloads the DLL from the specified process

Arguments:

    DllHandle - Supplies a handle to the DLL to unload.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PLDR_DATA_TABLE_ENTRY Entry;
    PDLL_INIT_ROUTINE InitRoutine;
    LIST_ENTRY LocalUnloadHead;
    PLIST_ENTRY Next;
    ULONG Cor20HeaderSize;
    PIMAGE_COR20_HEADER *Cor20Header;
    PRTL_PATCH_HEADER RundownPatchList = NULL;

    Peb = NtCurrentPeb();
    st = STATUS_SUCCESS;

    //
    // Grab Peb lock and decrement reference count of all affected DLLs
    //

    if (!LdrpInLdrInit) {
        RtlEnterCriticalSection(&LdrpLoaderLock);
    }

    try {

        LdrpActiveUnloadCount += 1;

        if (LdrpShutdownInProgress) {
            goto leave_finally;
        }

        if (!LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)) {
            st = STATUS_DLL_NOT_FOUND;
            goto leave_finally;
        }

        //
        // Now that we have the data table entry, unload it
        //

        if (LdrDataTableEntry->LoadCount != 0xffff) {
            LdrDataTableEntry->LoadCount -= 1;
            if (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL) {
                RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

                RtlActivateActivationContextUnsafeFast(&Frame, LdrDataTableEntry->EntryPointActivationContext);
                __try {
                    LdrpDereferenceLoadedDll(LdrDataTableEntry);
                } __finally {
                    RtlDeactivateActivationContextUnsafeFast(&Frame);
                }
            }
        } else {

            //
            // if the load count is 0xffff, then we do not need to recurse
            // through this DLL's import table.
            //
            // Additionally, we don't have to scan more LoadCount == 0
            // modules since nothing could have happened as a result of a free on this
            // DLL.

            goto leave_finally;
        }

        //
        // Now process init routines and then in a second pass, unload
        // DLLs
        //

        if (ShowSnaps) {
            DbgPrint("LDR: UNINIT LIST\n");
        }

        if (LdrpActiveUnloadCount == 1) {
            InitializeListHead(&LdrpUnloadHead);
        }

        //
        // Go in reverse order initialization order and build
        // the unload list
        //

        Next = PebLdr.InInitializationOrderModuleList.Blink;
        while ( Next != &PebLdr.InInitializationOrderModuleList) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));

            Next = Next->Blink;
            LdrDataTableEntry->Flags &= ~LDRP_UNLOAD_IN_PROGRESS;

            if (LdrDataTableEntry->LoadCount == 0) {

                if (ShowSnaps) {
                      DbgPrint("          (%d) [%ws] %ws (%lx) deinit %lx\n",
                              LdrpActiveUnloadCount,
                              LdrDataTableEntry->BaseDllName.Buffer,
                              LdrDataTableEntry->FullDllName.Buffer,
                              (ULONG)LdrDataTableEntry->LoadCount,
                              LdrDataTableEntry->EntryPoint
                              );
                }

                Entry = LdrDataTableEntry;

                //
                // Shim engine callback. Remove it from the shim list of hooked modules
                //

                if (g_pfnSE_DllUnloaded != NULL) {
                    (*g_pfnSE_DllUnloaded)(Entry);
                }

                RemoveEntryList(&Entry->InInitializationOrderLinks);
                RemoveEntryList(&Entry->InMemoryOrderLinks);
                RemoveEntryList(&Entry->HashLinks);

                if ( LdrpActiveUnloadCount > 1 ) {
                    LdrpLoadedDllHandleCache = NULL;
                    Entry->InMemoryOrderLinks.Flink = NULL;
                }
                InsertTailList(&LdrpUnloadHead,&Entry->HashLinks);
            }
        }
        //
        // End of new code
        //

        //
        // We only do init routine call's and module free's at the top level,
        // so if the active count is > 1, just return
        //

        if (LdrpActiveUnloadCount > 1 ) {
            goto leave_finally;
        }

        //
        // Now that the unload list is built, walk through the unload
        // list in order and call the init routine. The dll must remain
        // on the InLoadOrderLinks so that the pctoheader stuff will
        // still work
        //

        InitializeListHead(&LocalUnloadHead);
        Entry = NULL;
        Next = LdrpUnloadHead.Flink;
        while ( Next != &LdrpUnloadHead ) {
top:
            if ( Entry ) {

#if defined(_AMD64_) || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&(Entry->InLoadOrderLinks));
                Entry = NULL;
                Next = LdrpUnloadHead.Flink;
                if (Next == &LdrpUnloadHead ) {
                    goto bottom;
                }
            }
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,HashLinks));

            LdrpRecordUnloadEvent (LdrDataTableEntry);

            //
            // Remove dll from the global unload list and place
            // on the local unload list. This is because the global list
            // can change during the callout to the init routine
            //

            Entry = LdrDataTableEntry;
            LdrpLoadedDllHandleCache = NULL;
            Entry->InMemoryOrderLinks.Flink = NULL;

            RemoveEntryList(&Entry->HashLinks);
            InsertTailList(&LocalUnloadHead,&Entry->HashLinks);

            //
            // If the function has an init routine, call it.
            //

            InitRoutine = (PDLL_INIT_ROUTINE)(ULONG_PTR)LdrDataTableEntry->EntryPoint;

            if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                try {
                    if (ShowSnaps) {
                        DbgPrint("LDR: Calling deinit %lx\n",InitRoutine);
                    }

                    LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);

                    LdrpCallInitRoutine(InitRoutine,
                                        LdrDataTableEntry->DllBase,
                                        DLL_PROCESS_DETACH,
                                        NULL);

                    LDRP_DEACTIVATE_ACTIVATION_CONTEXT();

#if defined(_AMD64_) || defined(_IA64_)


                    RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                                   Entry->DllBase);

#endif

                    RemoveEntryList(&Entry->InLoadOrderLinks);
                    Entry = NULL;
                    Next = LdrpUnloadHead.Flink;
                }
                except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)){
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - exception %08lx caught while sending DLL_PROCESS_DETACH\n",
                        __FUNCTION__,
                        GetExceptionCode());

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   Dll Name: %wZ\n",
                        &LdrDataTableEntry->FullDllName);

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   InitRoutine: %p\n",
                        InitRoutine);

                    goto top;
                }
            } else {

#if defined(_AMD64_) || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&(Entry->InLoadOrderLinks));
                Entry = NULL;
                Next = LdrpUnloadHead.Flink;
            }
        }
bottom:

        //
        // Now, go through the modules and unmap them
        //

        Next = LocalUnloadHead.Flink;
        while ( Next != &LocalUnloadHead ) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,HashLinks));

            Next = Next->Flink;
            Entry = LdrDataTableEntry;

            //
            // Notify verifier that a dll will be unloaded.
            //
            // Now that we called the all the init routines with `detach' 
            // there is no excuse if we find a live CS in that region.
            //
            // Note: gdi32.dll's critical sections are deleted only on
            // user32.dll'd DllMain( DLL_PROCESS_DETACH ) so we cannot 
            // do this check for leaked critical sections prior to this point.
            //

            if (Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
                AVrfDllUnloadNotification (LdrDataTableEntry);
            }

            //
            // Unmap this DLL.
            //

            if (ShowSnaps) {
                  DbgPrint("LDR: Unmapping [%ws]\n",
                          LdrDataTableEntry->BaseDllName.Buffer
                          );
            }

            Cor20Header =  RtlImageDirectoryEntryToData(Entry->DllBase,
                                                        TRUE,
                                                        IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                        &Cor20HeaderSize);
            if (Cor20Header != NULL) {
                LdrpCorUnloadImage(Entry->DllBase);
            }
            if (!(Entry->Flags & LDRP_COR_OWNS_UNMAP)) {
                st = NtUnmapViewOfSection(NtCurrentProcess(),Entry->DllBase);
                ASSERT(NT_SUCCESS(st));
            }

            LdrUnloadAlternateResourceModule(Entry->DllBase);

            LdrpSendDllNotifications (Entry,
                                      LDR_DLL_NOTIFICATION_REASON_UNLOADED,
                                      (LdrpShutdownInProgress ? LDR_DLL_UNLOADED_FLAG_PROCESS_TERMINATION : 0));

            //
            //  See if we have hotpatch information and push each hotpatch block
            //  to the rundown list
            //

            while (Entry->PatchInformation) {

                PRTL_PATCH_HEADER PatchHead = Entry->PatchInformation;
                Entry->PatchInformation = PatchHead->NextPatch;

                PatchHead->NextPatch = RundownPatchList;
                RundownPatchList = PatchHead;
            }

            LdrpFinalizeAndDeallocateDataTableEntry(Entry);

            if ( Entry == LdrpGetModuleHandleCache ) {
                LdrpGetModuleHandleCache = NULL;
            }
        }

leave_finally:;
    }
    finally {
        LdrpActiveUnloadCount -= 1;
        if (!LdrpInLdrInit) {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        }
    }

    if ( RundownPatchList ) {

        LdrpRundownHotpatchList( RundownPatchList );
    }

    return st;
}


NTSTATUS
LdrGetProcedureAddress (
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    )
{
    return LdrpGetProcedureAddress(DllHandle,ProcedureName,ProcedureNumber,ProcedureAddress,TRUE);
}


NTSTATUS
LdrpGetProcedureAddress (
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress,
    IN BOOLEAN RunInitRoutines
    )

/*++

Routine Description:

    This function locates the address of the specified procedure in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the DLL that the address is being
        looked up in.

    ProcedureName - Supplies that address of a string that contains the
        name of the procedure to lookup in the DLL.  If this argument is
        not specified, then the ProcedureNumber is used.

    ProcedureNumber - Supplies the procedure number to lookup.  If
        ProcedureName is specified, then this argument is ignored.
        Otherwise, it specifies the procedure ordinal number to locate
        in the DLL.

    ProcedureAddress - Returns the address of the procedure found in
        the DLL.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    UCHAR FunctionNameBuffer[64];
    ULONG cb, ExportSize;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    IMAGE_THUNK_DATA Thunk;
    PVOID ImageBase;
    PIMAGE_IMPORT_BY_NAME FunctionName;
    PCIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PLIST_ENTRY Next;

    if (ShowSnaps) {
        DbgPrint("LDR: LdrGetProcedureAddress by ");
    }

    RtlZeroMemory( &Thunk, sizeof( Thunk ) );

    FunctionName = NULL;
    if ( ARGUMENT_PRESENT(ProcedureName) ) {

        if (ShowSnaps) {
            DbgPrint("NAME - %s\n", ProcedureName->Buffer);
        }

        cb = ProcedureName->Length + FIELD_OFFSET(IMAGE_IMPORT_BY_NAME, Name) +
                sizeof( UCHAR );
        if (cb > MAXUSHORT) {
            return STATUS_NAME_TOO_LONG;
        }

        if (cb > sizeof( FunctionNameBuffer )) {
            FunctionName = (PIMAGE_IMPORT_BY_NAME)RtlAllocateHeap(
                                                        RtlProcessHeap(),
                                                        MAKE_TAG( TEMP_TAG ),
                                                        cb
                                                        );
            if ( !FunctionName ) {
                return STATUS_INVALID_PARAMETER;
                }
        } else {
            FunctionName = (PIMAGE_IMPORT_BY_NAME) FunctionNameBuffer;
        }

        FunctionName->Hint = 0;

        cb = ProcedureName->Length;

        RtlCopyMemory (FunctionName->Name, ProcedureName->Buffer, cb);

        FunctionName->Name[cb] = '\0';

        //
        // Make sure we don't pass in address with high bit set so we
        // can still use it as ordinal flag
        //

        ImageBase = FunctionName;
        Thunk.u1.AddressOfData = 0;

    } else {
        ImageBase = NULL;
        if (ShowSnaps) {
            DbgPrint("ORDINAL - %lx\n", ProcedureNumber);
        }

        if (ProcedureNumber) {
            Thunk.u1.Ordinal = ProcedureNumber | IMAGE_ORDINAL_FLAG;
        } else {
            return STATUS_INVALID_PARAMETER;
        }
    }

    st = STATUS_ACCESS_VIOLATION;

    if (!LdrpInLdrInit) {
        RtlEnterCriticalSection (&LdrpLoaderLock);
    }

    try {

        if (!LdrpCheckForLoadedDllHandle (DllHandle, &LdrDataTableEntry)) {
            st = STATUS_DLL_NOT_FOUND;
            leave;
        }

        ExportDirectory = (PCIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                           LdrDataTableEntry->DllBase,
                           TRUE,
                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                           &ExportSize);

        if (!ExportDirectory) {
            st = STATUS_PROCEDURE_NOT_FOUND;
            leave;
        }

        st = LdrpSnapThunk(LdrDataTableEntry->DllBase,
                           ImageBase,
                           &Thunk,
                           &Thunk,
                           ExportDirectory,
                           ExportSize,
                           FALSE,
                           NULL);

        if (NT_SUCCESS(st) && RunInitRoutines) {

            PLDR_DATA_TABLE_ENTRY LdrInitEntry;

            //
            // Look at last entry in init order list. If entry processed
            // flag is not set, then a forwarded dll was loaded during the
            // getprocaddr call and we need to run init routines
            //

            Next = PebLdr.InInitializationOrderModuleList.Blink;

            LdrInitEntry = CONTAINING_RECORD(Next,
                                             LDR_DATA_TABLE_ENTRY,
                                             InInitializationOrderLinks);

            if ( !(LdrInitEntry->Flags & LDRP_ENTRY_PROCESSED) ) {
                
                //
                // Shim engine callback. This is the chance to patch
                // dynamically loaded modules.
                //

                try {
                    st = LdrpRunInitializeRoutines(NULL);
                }
                except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %x thrown by LdrpRunInitializeRoutines\n",
                        __FUNCTION__,
                        st);
                }
            }
        }

        if ( NT_SUCCESS(st) ) {
            *ProcedureAddress = (PVOID)Thunk.u1.Function;
        }
    } finally {
        if ( FunctionName && (FunctionName != (PIMAGE_IMPORT_BY_NAME) FunctionNameBuffer) ) {
            RtlFreeHeap(RtlProcessHeap(),0,FunctionName);
        }

        if (!LdrpInLdrInit) {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        }
    }
    return st;
}


NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum (
    IN HANDLE ImageFileHandle,
    IN PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine OPTIONAL,
    IN PVOID ImportCallbackParameter,
    OUT PUSHORT ImageCharacteristics OPTIONAL
    )
{
    NTSTATUS Status;
    HANDLE Section;
    PVOID ViewBase;
    SIZE_T ViewSize;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;
    PIMAGE_SECTION_HEADER LastRvaSection;
    BOOLEAN b = FALSE;
    BOOLEAN JustDoSideEffects;

    //
    // stevewo added all sorts of side effects to this API. We want to stop
    // doing checksums for known dll's, but really want the sideeffects
    // (ImageCharacteristics write, and Import descriptor walk).
    //

    if ( (UINT_PTR) ImageFileHandle & 1 ) {
        JustDoSideEffects = TRUE;
    }
    else {
        JustDoSideEffects = FALSE;
    }

    Status = NtCreateSection (&Section,
                              SECTION_MAP_EXECUTE,
                              NULL,
                              NULL,
                              PAGE_EXECUTE,
                              SEC_COMMIT,
                              ImageFileHandle);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ViewBase = NULL;
    ViewSize = 0;

    Status = NtMapViewOfSection (Section,
                                 NtCurrentProcess(),
                                 (PVOID *)&ViewBase,
                                 0L,
                                 0L,
                                 NULL,
                                 &ViewSize,
                                 ViewShare,
                                 0L,
                                 PAGE_EXECUTE);

    if ( !NT_SUCCESS(Status) ) {
        NtClose(Section);
        return Status;
    }

    //
    // now the image is mapped as a data file... Calculate it's size and then
    // check it's checksum
    //

    Status = NtQueryInformationFile(
                ImageFileHandle,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        NtClose(Section);
        return Status;
        }

    try {
        if ( JustDoSideEffects ) {
            b = TRUE;
            }
        else {
            b = LdrVerifyMappedImageMatchesChecksum(ViewBase,StandardInfo.EndOfFile.LowPart);
            }
        if (b && ARGUMENT_PRESENT( (ULONG_PTR)ImportCallbackRoutine )) {
            PIMAGE_NT_HEADERS NtHeaders;
            PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
            ULONG ImportSize;
            PCHAR ImportName;

            //
            // Caller wants to enumerate the import descriptors while we have
            // the image mapped.  Call back to their routine for each module
            // name in the import descriptor table.
            //
            LastRvaSection = NULL;
            NtHeaders = RtlImageNtHeader( ViewBase );
            if (! NtHeaders) {
                b = FALSE;
                leave;
            }
            if (ARGUMENT_PRESENT( ImageCharacteristics )) {
                *ImageCharacteristics = NtHeaders->FileHeader.Characteristics;
                }

            ImportDescriptor = (PCIMAGE_IMPORT_DESCRIPTOR)
                RtlImageDirectoryEntryToData( ViewBase,
                                              FALSE,
                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                              &ImportSize
                                            );
            if (ImportDescriptor != NULL) {
                while (ImportDescriptor->Name) {
                    ImportName = (PSZ)RtlImageRvaToVa( NtHeaders,
                                                       ViewBase,
                                                       ImportDescriptor->Name,
                                                       &LastRvaSection
                                                     );
                    (*ImportCallbackRoutine)( ImportCallbackParameter, ImportName );
                    ImportDescriptor += 1;
                    }
                }
            }
        }
    except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - caught exception %08lx while checking image checksums\n",
            __FUNCTION__,
            GetExceptionCode());

        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        NtClose(Section);
        return STATUS_IMAGE_CHECKSUM_MISMATCH;
        }
    NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    NtClose(Section);
    if ( !b ) {
        Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
        }
    return Status;
}


NTSTATUS 
LdrReadMemory(
    IN HANDLE Process OPTIONAL,
    IN PVOID BaseAddress,
    IN OUT PVOID Buffer,
    IN SIZE_T Size)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT( Process )) {
        SIZE_T nRead;
        Status = NtReadVirtualMemory(Process, BaseAddress, Buffer, Size, &nRead);

        if (NT_SUCCESS( Status ) && (Size != nRead)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        __try {
            RtlCopyMemory(Buffer, BaseAddress, Size);
        }
        __except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - exception %08lx caught while copying %u bytes from %p to %p\n",
                __FUNCTION__,
                GetExceptionCode(),
                BaseAddress,
                Buffer);

            if (NT_SUCCESS(Status = GetExceptionCode())) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }
    return Status;
}


NTSTATUS 
LdrGetModuleName(
    IN HANDLE Process OPTIONAL,
    IN PCUNICODE_STRING LdrFullDllName,
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN BOOL Wow64Redirect)
{
    NTSTATUS Status;
    UNICODE_STRING FullDllName;
    ANSI_STRING AnsiString;
    PCHAR s;
    WCHAR Buffer[ LDR_NUMBER_OF(ModuleInfo->FullPathName) + 1];
    USHORT Length = (USHORT)min(LdrFullDllName->Length, 
                                sizeof(Buffer) - sizeof(Buffer[0]));

    Status = LdrReadMemory(Process, 
                           LdrFullDllName->Buffer, 
                           Buffer,
                           Length);

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Buffer[LDR_NUMBER_OF(Buffer) - 1] = UNICODE_NULL;  // Ensure NULL termination
    
#if defined(_WIN64)
    if (Wow64Redirect) {
    
        C_ASSERT( WOW64_SYSTEM_DIRECTORY_U_SIZE == 
                  (sizeof(L"system32") - sizeof(WCHAR)));
                  
        // including preceding '\\' if exists
        SIZE_T System32Offset = wcslen(USER_SHARED_DATA->NtSystemRoot);
        ASSERT(System32Offset != 0);
        
        if (USER_SHARED_DATA->NtSystemRoot[System32Offset - 1] == L'\\') {
            --System32Offset;
        }

        if (!_wcsnicmp(Buffer, USER_SHARED_DATA->NtSystemRoot, System32Offset) &&
            !_wcsnicmp(Buffer + System32Offset, 
                       L"\\system32", 
                       WOW64_SYSTEM_DIRECTORY_U_SIZE / sizeof(WCHAR) + 1)) {
                       
            RtlCopyMemory(Buffer + System32Offset + 1,
                          WOW64_SYSTEM_DIRECTORY_U,
                          WOW64_SYSTEM_DIRECTORY_U_SIZE);
        }
    }
#else
    UNREFERENCED_PARAMETER (Wow64Redirect);
#endif // defined(_WIN64)
    
    FullDllName.Buffer = Buffer;
    FullDllName.Length = FullDllName.MaximumLength = Length;

    AnsiString.Buffer = (PCHAR)ModuleInfo->FullPathName;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );

    Status = RtlUnicodeStringToAnsiString(&AnsiString,
                                          &FullDllName,
                                          FALSE);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    s = AnsiString.Buffer + AnsiString.Length;
    while (s > AnsiString.Buffer && *--s) {
        if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
            s++;
            break;
        }
    }

    ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);
    return STATUS_SUCCESS;
}


NTSTATUS
LdrQueryProcessPeb (
    IN HANDLE Process OPTIONAL,
    IN OUT PPEB* Peb)
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInfo;

    if (ARGUMENT_PRESENT (Process)) {

        Status = NtQueryInformationProcess (Process, 
                                            ProcessBasicInformation,
                                            &BasicInfo,
                                            sizeof(BasicInfo),
                                            NULL);

        if (NT_SUCCESS (Status)) {
            *Peb = BasicInfo.PebBaseAddress;
        }
    }
    else {
        *Peb = NtCurrentPeb ();
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
LdrQueryInLoadOrderModuleList (
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY* Head,
    IN OUT PLIST_ENTRY* InInitOrderHead OPTIONAL
    )
{
    PPEB_LDR_DATA Ldr;

    UNREFERENCED_PARAMETER (Process);

    Ldr = &PebLdr;

    *Head = &Ldr->InLoadOrderModuleList;

    if (ARGUMENT_PRESENT (InInitOrderHead)) {
        *InInitOrderHead = &Ldr->InInitializationOrderModuleList;
    }

    return STATUS_SUCCESS;
}


NTSTATUS 
LdrQueryNextListEntry (
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY Head,
    IN OUT PLIST_ENTRY* Tail
    )
{
    return LdrReadMemory (Process, &Head->Flink, Tail, sizeof(*Tail));
}


NTSTATUS
LdrQueryModuleInfoFromLdrEntry (
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY LdrEntry,
    IN PLIST_ENTRY InitOrderList)
{
    NTSTATUS Status;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntryPtr;
    LDR_DATA_TABLE_ENTRY LdrDataTableEntry;

    UNREFERENCED_PARAMETER (ModuleInformation);

    LdrDataTableEntryPtr = CONTAINING_RECORD(LdrEntry, 
                                             LDR_DATA_TABLE_ENTRY, 
                                             InLoadOrderLinks);

    Status = LdrReadMemory(Process, 
                           LdrEntry, 
                           &LdrDataTableEntry, 
                           sizeof(LdrDataTableEntry));

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ModuleInfo->ImageBase = LdrDataTableEntry.DllBase;
    ModuleInfo->ImageSize = LdrDataTableEntry.SizeOfImage;
    ModuleInfo->Flags     = LdrDataTableEntry.Flags;
    ModuleInfo->LoadCount = LdrDataTableEntry.LoadCount;
    
    if (!ARGUMENT_PRESENT( Process )) {
        UINT LoopDetectorCount = 10240;  // 10K modules max
        PLIST_ENTRY Next1 = InitOrderList->Flink;

        while ( Next1 != InitOrderList ) {
            PLDR_DATA_TABLE_ENTRY Entry1 = 
                CONTAINING_RECORD(Next1,
                                  LDR_DATA_TABLE_ENTRY,
                                  InInitializationOrderLinks);

            ModuleInfo->InitOrderIndex++;

            if ((LdrDataTableEntryPtr == Entry1) ||
                (!LoopDetectorCount--)) 
            {
                break;
            }

            Next1 = Next1->Flink;
        } 
    }

    Status = LdrGetModuleName(Process, 
                              &LdrDataTableEntry.FullDllName, 
                              ModuleInfo, 
                              FALSE);

    return Status;
}


PRTL_CRITICAL_SECTION
LdrQueryModuleInfoLocalLoaderLock (
    VOID
    )
{
    PRTL_CRITICAL_SECTION LoaderLock = NULL;

    if (!LdrpInLdrInit) {
        LoaderLock = &LdrpLoaderLock;

        if (LoaderLock != NULL) {
            RtlEnterCriticalSection (LoaderLock);
        }
    }

    return LoaderLock;
}


VOID
LdrQueryModuleInfoLocalLoaderUnlock (
    IN PRTL_CRITICAL_SECTION LoaderLock
    )
{
    if (LoaderLock) {
        RtlLeaveCriticalSection(LoaderLock);
    }
}

#if defined(_WIN64)

NTSTATUS
LdrQueryProcessPeb32(
    IN HANDLE Process OPTIONAL,
    IN OUT PPEB32* Peb
    )
{
    NTSTATUS Status;
    HANDLE TargetProcess;

    if (ARGUMENT_PRESENT (Process)) {
        TargetProcess = Process;
    }
    else {
        TargetProcess = NtCurrentProcess ();
    }

    Status = NtQueryInformationProcess (TargetProcess,
                                        ProcessWow64Information,
                                        Peb,
                                        sizeof(*Peb),
                                        NULL);
    return Status;
}


NTSTATUS
LdrQueryInLoadOrderModuleList32(
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY32 *Head,
    IN OUT PLIST_ENTRY32 *InInitOrderHead OPTIONAL
    )
{
    NTSTATUS Status;
    PPEB32 Peb;
    PPEB_LDR_DATA32 Ldr;
    ULONG32 Ptr32;

    Status = LdrQueryProcessPeb32 (Process, &Peb);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    if (!Peb) {

        //
        // The process isn't a WOW process.
        //

        *Head = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Ldr = Peb->Ldr
    //

    Status = LdrReadMemory (Process, &Peb->Ldr, &Ptr32, sizeof(Ptr32));

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Ldr = (PPEB_LDR_DATA32)(ULONG_PTR) Ptr32;

    if (!Ldr) {
        *Head = NULL;
        return STATUS_SUCCESS;
    }

    *Head = &Ldr->InLoadOrderModuleList;

    if (ARGUMENT_PRESENT (InInitOrderHead)) {
        *InInitOrderHead = &Ldr->InInitializationOrderModuleList;
    }

    return Status;
}


NTSTATUS 
LdrQueryNextListEntry32 (
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY32 Head,
    IN OUT PLIST_ENTRY32 *Tail
    )
{
    NTSTATUS Status;
    ULONG32 Ptr32;

    Status = LdrReadMemory (Process, &Head->Flink, &Ptr32, sizeof(Ptr32));

    *Tail = (PLIST_ENTRY32)(ULONG_PTR)Ptr32;

    return Status;
}


NTSTATUS
LdrQueryModuleInfoFromLdrEntry32 (
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY32 LdrEntry,
    IN PLIST_ENTRY32 InitOrderList
    )
{
    NTSTATUS Status;
    PLDR_DATA_TABLE_ENTRY32 LdrDataTableEntryPtr;
    LDR_DATA_TABLE_ENTRY32 LdrDataTableEntry;
    UNICODE_STRING FullDllName;

    UNREFERENCED_PARAMETER (ModuleInformation);

    LdrDataTableEntryPtr = CONTAINING_RECORD(LdrEntry,
                                             LDR_DATA_TABLE_ENTRY32,
                                             InLoadOrderLinks);

    Status = LdrReadMemory (Process, 
                            LdrEntry, 
                            &LdrDataTableEntry, 
                            sizeof(LdrDataTableEntry));

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ModuleInfo->ImageBase = (PVOID)(ULONG_PTR) LdrDataTableEntry.DllBase;
    ModuleInfo->ImageSize = LdrDataTableEntry.SizeOfImage;
    ModuleInfo->Flags     = LdrDataTableEntry.Flags;
    ModuleInfo->LoadCount = LdrDataTableEntry.LoadCount;

    if (!ARGUMENT_PRESENT( Process )) {

        UINT LoopDetectorCount = 500;

        PLIST_ENTRY32 Next1 = (PLIST_ENTRY32)(ULONG_PTR)
            (InitOrderList->Flink);

        while (Next1 != InitOrderList) {
            PLDR_DATA_TABLE_ENTRY32 Entry1 = 
                CONTAINING_RECORD(Next1,
                                  LDR_DATA_TABLE_ENTRY32,
                                  InInitializationOrderLinks);

            ModuleInfo->InitOrderIndex++;

            if ((LdrDataTableEntryPtr == Entry1) ||
                (!LoopDetectorCount--)) 
            {
                break;
            }

            Next1 = (PLIST_ENTRY32)(ULONG_PTR)(Next1->Flink);
        }
    }

    FullDllName.Buffer = (PWSTR)(ULONG_PTR)LdrDataTableEntry.FullDllName.Buffer;
    FullDllName.Length = LdrDataTableEntry.FullDllName.Length;
    FullDllName.MaximumLength = LdrDataTableEntry.FullDllName.MaximumLength;

    Status = LdrGetModuleName(Process, &FullDllName, ModuleInfo, TRUE);

    return Status;
}


PRTL_CRITICAL_SECTION32
LdrQueryModuleInfoLocalLoaderLock32 (
    VOID
    )
{
    return NULL;
}


VOID
LdrQueryModuleInfoLocalLoaderUnlock32 (
    IN PRTL_CRITICAL_SECTION32 LoaderLock)
{
    UNREFERENCED_PARAMETER (LoaderLock);
}

#endif // defined(_WIN64)

typedef 
NTSTATUS
(*PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST)(
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY* Head,
    IN OUT PLIST_ENTRY* InInitOrderHead OPTIONAL);

typedef NTSTATUS 
(*PLDR_QUERY_NEXT_LIST_ENTRY)(
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY Head,
    IN OUT PLIST_ENTRY* Tail);

typedef 
NTSTATUS
(*PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY)(
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY LdrEntry,
    IN PLIST_ENTRY InitOrderList);

typedef
PRTL_CRITICAL_SECTION
(*PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK)(VOID);

typedef
VOID
(*PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK)(PRTL_CRITICAL_SECTION);

static struct {
    PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST LdrQueryInLoadOrderModuleList;
    PLDR_QUERY_NEXT_LIST_ENTRY LdrQueryNextListEntry;
    PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY LdrQueryModuleInfoFromLdrEntry;
    PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK LdrQueryModuleInfoLocalLoaderLock;
    PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK LdrQueryModuleInfoLocalLoaderUnlock;
} LdrQueryMethods[] = {
    { 
        LdrQueryInLoadOrderModuleList, 
        LdrQueryNextListEntry, 
        LdrQueryModuleInfoFromLdrEntry,
        LdrQueryModuleInfoLocalLoaderLock,
        LdrQueryModuleInfoLocalLoaderUnlock
    }
#if defined(_WIN64)
    ,
    { 
        (PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST)LdrQueryInLoadOrderModuleList32,
        (PLDR_QUERY_NEXT_LIST_ENTRY)LdrQueryNextListEntry32,
        (PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY)LdrQueryModuleInfoFromLdrEntry32,
        (PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK)LdrQueryModuleInfoLocalLoaderLock32,
        (PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK)LdrQueryModuleInfoLocalLoaderUnlock32
    }
#endif defined(_WIN64)
}; 


NTSTATUS
LdrQueryProcessModuleInformationEx(
    IN HANDLE Process OPTIONAL,
    IN ULONG_PTR Flags OPTIONAL,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PRTL_CRITICAL_SECTION LoaderLock = NULL;
    SIZE_T mid;

    ULONG RequiredLength = FIELD_OFFSET( RTL_PROCESS_MODULES, Modules );

    PLIST_ENTRY List;
    PLIST_ENTRY InInitOrderList;

    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;

    if (ModuleInformationLength < RequiredLength) {
        Status = STATUS_INFO_LENGTH_MISMATCH;
        ModuleInfo = NULL;
    }
    else {
        ModuleInformation->NumberOfModules = 0;
        ModuleInfo = &ModuleInformation->Modules[ 0 ];
        Status = STATUS_SUCCESS;
    }

    for (mid = 0;
         mid < (ARGUMENT_PRESENT( Flags ) ? LDR_NUMBER_OF(LdrQueryMethods) : 1);
         ++mid)
    {
        NTSTATUS Status1;
        PLIST_ENTRY Entry;

        __try {
            UINT LoopDetectorCount = 10240; // allow not more than 10K modules

            if ( !ARGUMENT_PRESENT( Process )) {
                LoaderLock = LdrQueryMethods[mid].LdrQueryModuleInfoLocalLoaderLock();
            } 

            Status1 = LdrQueryMethods[mid].LdrQueryInLoadOrderModuleList(Process, &List, &InInitOrderList);

            if (!NT_SUCCESS( Status1 )) {
                Status = Status1;
                __leave;
            }

            if (!List) {
                __leave;
            }

            Status1 = LdrQueryMethods[mid].LdrQueryNextListEntry(Process, 
                                                                 List, 
                                                                 &Entry);
            if (!NT_SUCCESS( Status1 )) {
                Status = Status1;
                __leave;
            }

            while (Entry != List) {
                if (!LoopDetectorCount--) {
                    Status = STATUS_FAIL_CHECK;
                    __leave;
                }

                RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );

                if (ModuleInformationLength < RequiredLength) {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    Status1 = LdrQueryMethods[mid].LdrQueryModuleInfoFromLdrEntry(Process, 
                                                                                  ModuleInformation, 
                                                                                  ModuleInfo, 
                                                                                  Entry, InInitOrderList);

                    if (!NT_SUCCESS( Status1 )) {
                        Status = Status1;
                        __leave;
                    }

                    ModuleInfo++;
                }

                //
                // NOTICE-2002/03/15-ELi
                // This chould be non-NULL and not a valid access
                // should check ModuleInfo or ModuleInformationLength instead
                // Assuming ModuleInfo is not NULL when the code can safely
                // reference ModuleInformation->NumberOfModules
                //
                if ((ModuleInfo != NULL) && (ModuleInformation != NULL)) {
                    ModuleInformation->NumberOfModules++;
                }

                Status1 = LdrQueryMethods[mid].LdrQueryNextListEntry(Process, 
                                                                     Entry, 
                                                                     &Entry);

                if (!NT_SUCCESS( Status1 )) {
                    Status = Status1;
                    __leave;
                }

            } // while
        }
        __finally {
            if (LoaderLock) {
                LdrQueryMethods[mid].LdrQueryModuleInfoLocalLoaderUnlock(LoaderLock);
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = RequiredLength;
            }
        }
    } // for

    return Status;
}


NTSTATUS
LdrQueryProcessModuleInformation(
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    return LdrQueryProcessModuleInformationEx(NULL,
                                              0,
                                              ModuleInformation,
                                              ModuleInformationLength,
                                              ReturnLength);
}


NTSTATUS
NTAPI
LdrRegisterDllNotification (
    ULONG Flags,
    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    PVOID Context,
    PVOID *Cookie
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLDRP_DLL_NOTIFICATION_BLOCK NotificationBlock = NULL;
    BOOLEAN HoldingLoaderLock = FALSE;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;

    __try {
        if (Cookie != NULL) {
            *Cookie = NULL;
        }

        if ((Flags != 0) ||
            (Cookie == NULL) ||
            (NotificationFunction == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        NotificationBlock = (PLDRP_DLL_NOTIFICATION_BLOCK)
                RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(LDRP_DLL_NOTIFICATION_BLOCK));
        if (NotificationBlock == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        NotificationBlock->NotificationFunction = NotificationFunction;
        NotificationBlock->Context = Context;

        if (!InLdrInit) {
            __try {
                Status = LdrLockLoaderLock(0, NULL, &LockCookie);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                HoldingLoaderLock = TRUE;
            } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                Status = GetExceptionCode();
                goto Exit;
            }
        }

        InsertTailList(&LdrpDllNotificationList, &NotificationBlock->Links);

        *Cookie = (PVOID) NotificationBlock;
        NotificationBlock = NULL;

        Status = STATUS_SUCCESS;
Exit:
        ;
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
        if (NotificationBlock != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, NotificationBlock);
        }
    }
    return Status;
}


NTSTATUS
NTAPI
LdrUnregisterDllNotification (
    PVOID Cookie
    )
{
    PLDRP_DLL_NOTIFICATION_BLOCK NotificationBlock;
    NTSTATUS Status;
    BOOLEAN HoldingLoaderLock;
    BOOLEAN InLdrInit;
    PVOID LockCookie;

    if (Cookie == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = STATUS_SUCCESS;
    HoldingLoaderLock = FALSE;
    InLdrInit = LdrpInLdrInit;
    LockCookie = NULL;

    __try {
        if (!InLdrInit) {
            __try {
                Status = LdrLockLoaderLock (0, NULL, &LockCookie);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                HoldingLoaderLock = TRUE;
            } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                Status = GetExceptionCode();
                goto Exit;
            }
        }

        NotificationBlock = CONTAINING_RECORD(LdrpDllNotificationList.Flink, LDRP_DLL_NOTIFICATION_BLOCK, Links);

        while (&NotificationBlock->Links != &LdrpDllNotificationList) {
            if (NotificationBlock == Cookie)
                break;
            NotificationBlock = CONTAINING_RECORD(NotificationBlock->Links.Flink, LDRP_DLL_NOTIFICATION_BLOCK, Links);
        }

        if (&NotificationBlock->Links != &LdrpDllNotificationList) {
            RemoveEntryList(&NotificationBlock->Links);
            RtlFreeHeap(RtlProcessHeap(), 0, NotificationBlock);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NOT_FOUND;
        }
Exit:
        ;
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return Status;
}


VOID
LdrpSendDllNotifications (
    IN PLDR_DATA_TABLE_ENTRY Entry,
    IN ULONG NotificationType,
    IN ULONG Flags
    )
{
    PLIST_ENTRY Next;
    LDR_DLL_NOTIFICATION_DATA Data;

    Data.Loaded.Flags = Flags;
    Data.Loaded.FullDllName = &Entry->FullDllName;
    Data.Loaded.BaseDllName = &Entry->BaseDllName;
    Data.Loaded.DllBase = Entry->DllBase;
    Data.Loaded.SizeOfImage = Entry->SizeOfImage;

    Next = LdrpDllNotificationList.Flink;

    while (Next != &LdrpDllNotificationList) {
        PLDRP_DLL_NOTIFICATION_BLOCK Block = CONTAINING_RECORD(Next, LDRP_DLL_NOTIFICATION_BLOCK, Links);
        __try {
            (*Block->NotificationFunction)(NotificationType, &Data, Block->Context);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            // just go on to the next one...
        }
        Next = Next->Flink;
    }
}


BOOLEAN
NTAPI
RtlDllShutdownInProgress (
    VOID
    )
/*++

Routine Description:

    This routine returns the status of DLL shutdown.

Arguments:

    None

Return Value:

    BOOLEAN - TRUE: Shutdown is in progress, FALSE: Shutdown is not currently in progress.

--*/
{
    if (LdrpShutdownInProgress) {
        return TRUE;
    } else {
        return FALSE;
    }
}


NTSTATUS
NTAPI
LdrLockLoaderLock (
    ULONG Flags,
    PULONG Disposition,
    PVOID *Cookie
    )
{
    NTSTATUS Status;
    BOOLEAN InLdrInit;

    InLdrInit = LdrpInLdrInit;

    if (Disposition != NULL) {
        *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID;
    }

    if (Cookie != NULL) {
        *Cookie = NULL;
    }

    if ((Flags & ~(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY | LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)) != 0) {

        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_1);
        }

        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (Cookie == NULL) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
            RtlRaiseStatus (STATUS_INVALID_PARAMETER_3);
        }

        Status = STATUS_INVALID_PARAMETER_3;
        goto Exit;
    }

    //
    // If you hit this assertion failure, you specified that you only wanted to
    // try acquiring the lock, but you forgot to specify a Disposition out where
    // this function could indicate whether the lock was actually acquired.
    //

    ASSERT((Disposition != NULL) || !(Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY));

    if ((Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) &&
        (Disposition == NULL)) {

        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);
        }

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (InLdrInit) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) {
            if (RtlTryEnterCriticalSection(&LdrpLoaderLock)) {
                *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
            } else {
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED;
            }
        } else {
            RtlEnterCriticalSection(&LdrpLoaderLock);
            if (Disposition != NULL) {
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
            }
            *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
        }
    } else {
        __try {
            if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) {
                if (RtlTryEnterCriticalSection(&LdrpLoaderLock)) {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
                    *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
                } else {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED;
                }
            } else {
                RtlEnterCriticalSection(&LdrpLoaderLock);
                if (Disposition != NULL) {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
                }
                *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
            }
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Caught exception %08lx\n",
                __FUNCTION__,
                Status);
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    ULONG Flags,
    PVOID CookieIn
    )
{
    NTSTATUS Status;
    const ULONG_PTR Cookie = (ULONG_PTR) CookieIn;

    if ((Flags & ~(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)) != 0) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_1);

        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (CookieIn == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    // A little validation on the cookie...
    if (EXTRACT_LOADER_LOCK_COOKIE_TYPE(Cookie) != LOADER_LOCK_COOKIE_TYPE_NORMAL) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (EXTRACT_LOADER_LOCK_COOKIE_TID(Cookie) != (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) & LOADER_LOCK_COOKIE_TID_BIT_MASK)) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
        RtlLeaveCriticalSection(&LdrpLoaderLock);
    } else {
        __try {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
NTAPI
LdrDoesCurrentThreadOwnLoaderLock(
    BOOLEAN *DoesOwnLock
    )
{
    NTSTATUS Status;
    PTEB Teb;

    if (DoesOwnLock != NULL)
        *DoesOwnLock = FALSE;

    if (DoesOwnLock == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Teb = NtCurrentTeb();

    if (LdrpLoaderLock.OwningThread == Teb->ClientId.UniqueThread)
        *DoesOwnLock = TRUE;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
NTAPI
LdrEnumerateLoadedModules (
    ULONG Flags,
    PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    PVOID Context
    )
{
    NTSTATUS Status;
    BOOLEAN LoaderLockLocked = FALSE;
    PLIST_ENTRY LoadOrderListHead = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN StopEnumeration = FALSE;
    PVOID   LockCookie = NULL;

    if ((Flags != 0) ||
        (CallbackFunction == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = LdrLockLoaderLock(0, NULL, &LockCookie);
    if (!NT_SUCCESS(Status))
        goto Exit;

    LoaderLockLocked = TRUE;
    LoadOrderListHead = &PebLdr.InLoadOrderModuleList;

    ListEntry = LoadOrderListHead->Flink;

    while (ListEntry != LoadOrderListHead) {
        __try {
            (*CallbackFunction)(
                CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks),
                Context,
                &StopEnumeration);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            goto Exit;
        }

        if (StopEnumeration)
            break;

        ListEntry = ListEntry->Flink;
    }

    Status = LdrUnlockLoaderLock(0, LockCookie);
    LoaderLockLocked = FALSE;

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = STATUS_SUCCESS;

Exit:

    if (LoaderLockLocked) {

        NTSTATUS Status2;
                
        Status2 = LdrUnlockLoaderLock(0, LockCookie);

        ASSERT(NT_SUCCESS(Status2));
    }

    return Status;
}


NTSTATUS
NTAPI
LdrAddRefDll(
    ULONG               Flags,
    PVOID               DllHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;
    BOOLEAN HoldingLoaderLock = FALSE;
    const ULONG ValidFlags = LDR_ADDREF_DLL_PIN;

    __try {

        if (Flags & ~ValidFlags
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (!InLdrInit
            ) {
            Status = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(Status))
                goto Exit;
            HoldingLoaderLock = TRUE;
        }
        if (!LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (!RTL_SOFT_VERIFY(LdrDataTableEntry != NULL)
            ) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }
        //
        // Gross. Everyone inlines the first part..
        //
        if (LdrDataTableEntry->LoadCount != 0xffff) {
            if (Flags & LDR_ADDREF_DLL_PIN
                ) {
                LdrDataTableEntry->LoadCount = 0xffff;
                LdrpPinLoadedDll(LdrDataTableEntry);
            } else {
                LdrDataTableEntry->LoadCount++;
                LdrpReferenceLoadedDll(LdrDataTableEntry);
            }
            LdrpClearLoadInProgress();
        }
Exit:
        if (LdrpShouldDbgPrintStatus(Status)
            ) {
            DbgPrint("LDR: "__FUNCTION__"(%p) 0x%08lx\n", DllHandle, Status);
        }
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return Status;
}


VOID
NTAPI
LdrSetDllManifestProber(
    IN PLDR_MANIFEST_PROBER_ROUTINE ManifestProberRoutine
    )
{
    LdrpManifestProberRoutine = ManifestProberRoutine;
}


NTSTATUS
NTAPI
LdrSetAppCompatDllRedirectionCallback(
    IN ULONG Flags,
    IN PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackData
    )
/*++

Routine Description:

    This routine allows the application compatibility facility to set a callback
    function that it can use to redirect DLL loads wherever it wants them to go.

Arguments:

    Flags - None defined now; must be zero.

    CallbackFunction - Function pointer to function which is called to resolve
        path names prior to actually loading the DLL.

    CallbackData - PVOID value passed through to the CallbackFunction when it is
        called.

Return Value:

    NTSTATUS indicating the success/failure of the function.

--*/
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID LockCookie = NULL;

    if (Flags != 0) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        LdrpAppCompatDllRedirectionCallbackFunction = CallbackFunction;
        LdrpAppCompatDllRedirectionCallbackData = CallbackData;
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}

PTEB LdrpTopLevelDllBeingLoadedTeb=NULL;


BOOLEAN
RtlIsThreadWithinLoaderCallout (
    VOID
    )
{
    if (LdrpTopLevelDllBeingLoadedTeb == NtCurrentTeb ()) {
        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrinit.c

Abstract:

    This module implements loader initialization.

Author:

    Mike O'Leary (mikeol) 26-Mar-1990

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <heappage.h>
#include <apcompat.h>
#include "ldrp.h"
#include <ctype.h>
#include <windows.h>
#if defined(_WIN64) || defined(BUILD_WOW6432)
#include <wow64t.h>
#endif
#include <stktrace.h>
#include "sxsp.h"

BOOLEAN LdrpShutdownInProgress = FALSE;
BOOLEAN LdrpImageHasTls = FALSE;
BOOLEAN LdrpVerifyDlls = FALSE;
BOOLEAN LdrpLdrDatabaseIsSetup = FALSE;
BOOLEAN LdrpInLdrInit = FALSE;
BOOLEAN LdrpShouldCreateStackTraceDb = FALSE;

BOOLEAN ShowSnaps = FALSE;
BOOLEAN ShowErrors = FALSE;

EXTERN_C BOOLEAN g_SxsKeepActivationContextsAlive;
EXTERN_C BOOLEAN g_SxsTrackReleaseStacks;
EXTERN_C ULONG g_SxsMaxDeadActivationContexts;

#if defined(_WIN64)
PVOID Wow64Handle;
ULONG UseWOW64;
typedef VOID (*tWOW64LdrpInitialize)(IN PCONTEXT Context);
tWOW64LdrpInitialize Wow64LdrpInitialize;
PVOID Wow64PrepareForException;
PVOID Wow64ApcRoutine;
INVERTED_FUNCTION_TABLE LdrpInvertedFunctionTable = {
    0, MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE, FALSE};
#endif

#if defined(_WIN64) || defined(BUILD_WOW6432)
ULONG NativePageSize;
ULONG NativePageShift;
#endif

#define SLASH_SYSTEM32_SLASH L"\\system32\\"
#define MSCOREE_DLL          L"mscoree.dll"
extern const WCHAR SlashSystem32SlashMscoreeDllWCharArray[] = SLASH_SYSTEM32_SLASH MSCOREE_DLL;
extern const UNICODE_STRING SlashSystem32SlashMscoreeDllString =
{
    sizeof(SlashSystem32SlashMscoreeDllWCharArray) - sizeof(SlashSystem32SlashMscoreeDllWCharArray[0]),
    sizeof(SlashSystem32SlashMscoreeDllWCharArray),
    (PWSTR)SlashSystem32SlashMscoreeDllWCharArray
};
extern const UNICODE_STRING SlashSystem32SlashString =
{
    sizeof(SLASH_SYSTEM32_SLASH) - sizeof(SLASH_SYSTEM32_SLASH[0]),
    sizeof(SLASH_SYSTEM32_SLASH),
    (PWSTR)SlashSystem32SlashMscoreeDllWCharArray
};
extern const UNICODE_STRING MscoreeDllString =
{
    sizeof(MSCOREE_DLL) - sizeof(MSCOREE_DLL[0]),
    sizeof(MSCOREE_DLL),
    (PWSTR)&SlashSystem32SlashMscoreeDllWCharArray[RTL_NUMBER_OF(SLASH_SYSTEM32_SLASH) - 1]
};

typedef NTSTATUS (*PCOR_VALIDATE_IMAGE)(PVOID *pImageBase, LPWSTR ImageName);
typedef VOID (*PCOR_IMAGE_UNLOADING)(PVOID ImageBase);

PVOID Cor20DllHandle;
PCOR_VALIDATE_IMAGE CorValidateImage;
PCOR_IMAGE_UNLOADING CorImageUnloading;
PCOR_EXE_MAIN CorExeMain;
DWORD CorImageCount;

PVOID NtDllBase;
extern const UNICODE_STRING NtDllName = RTL_CONSTANT_STRING(L"ntdll.dll");

#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"

extern ULONG RtlpDisableHeapLookaside;  // defined in rtl\heap.c
extern ULONG RtlpShutdownProcessFlags;

extern void ShutDownEtwHandles();
extern void CleanOnThreadExit();
extern ULONG EtwpInitializeDll(void);
extern void EtwpDeinitializeDll();

#if defined (_X86_)
void
LdrpValidateImageForMp(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );
#endif

PFNSE_INSTALLBEFOREINIT g_pfnSE_InstallBeforeInit;
PFNSE_INSTALLAFTERINIT  g_pfnSE_InstallAfterInit;
PFNSE_DLLLOADED         g_pfnSE_DllLoaded;
PFNSE_DLLUNLOADED       g_pfnSE_DllUnloaded;
PFNSE_ISSHIMDLL         g_pfnSE_IsShimDll;
PFNSE_PROCESSDYING      g_pfnSE_ProcessDying;

PVOID g_pShimEngineModule;

BOOLEAN g_LdrBreakOnLdrpInitializeProcessFailure;

PEB_LDR_DATA PebLdr;
PLDR_DATA_TABLE_ENTRY LdrpNtDllDataTableEntry;

#if DBG
// Debug helpers to figure out where in LdrpInitializeProcess() things go south
PCSTR g_LdrFunction;
LONG g_LdrLine;

#define LDRP_CHECKPOINT() { g_LdrFunction = __FUNCTION__; g_LdrLine = __LINE__; }

#else

#define LDRP_CHECKPOINT() /* nothing */

#endif // DBG


//
//  Defined in heappriv.h
//

VOID
RtlDetectHeapLeaks (
    VOID
    );

VOID
LdrpInitializationFailure (
    IN NTSTATUS FailureCode
    );

VOID
LdrpRelocateStartContext (
    IN PCONTEXT Context,
    IN LONG_PTR Diff
    );

NTSTATUS
LdrpForkProcess (
    VOID
    );

VOID
LdrpInitializeThread (
    IN PCONTEXT Context
    );

NTSTATUS
LdrpOpenImageFileOptionsKey (
    IN PCUNICODE_STRING ImagePathName,
    IN BOOLEAN Wow64Path,
    OUT PHANDLE KeyHandle
    );

VOID
LdrpInitializeApplicationVerifierPackage (
    PCUNICODE_STRING UnicodeImageName,
    PPEB Peb,
    BOOLEAN EnabledSystemWide,
    BOOLEAN OptionsKeyPresent
    );

BOOLEAN
LdrpInitializeExecutionOptions (
    IN PCUNICODE_STRING UnicodeImageName,
    IN PPEB Peb
    );

NTSTATUS
LdrpQueryImageFileKeyOption (
    IN HANDLE KeyHandle,
    IN PCWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    );

NTSTATUS
LdrpTouchThreadStack (
    IN SIZE_T EnforcedStackCommit
    );

NTSTATUS
LdrpEnforceExecuteForCurrentThreadStack (
    VOID
    );

NTSTATUS
RtlpInitDeferredCriticalSection (
    VOID
    );

VOID
LdrQueryApplicationCompatibilityGoo (
    IN PCUNICODE_STRING UnicodeImageName,
    IN BOOLEAN ImageFileOptionsPresent
    );

NTSTATUS
LdrFindAppCompatVariableInfo (
    IN  ULONG dwTypeSeeking,
    OUT PAPP_VARIABLE_INFO *AppVariableInfo
    );

NTSTATUS
LdrpSearchResourceSection_U (
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData (
    IN PVOID DllHandle,
    IN PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

VOID
LdrpUnloadShimEngine (
    VOID
    );



PVOID
NtdllpAllocateStringRoutine (
    SIZE_T NumberOfBytes
    )
{
    return RtlAllocateHeap (RtlProcessHeap(), 0, NumberOfBytes);
}


VOID
NtdllpFreeStringRoutine (
    PVOID Buffer
    )
{
    RtlFreeHeap (RtlProcessHeap(), 0, Buffer);
}

const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = NtdllpAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = NtdllpFreeStringRoutine;

RTL_BITMAP FlsBitMap;
RTL_BITMAP TlsBitMap;
RTL_BITMAP TlsExpansionBitMap;

RTL_CRITICAL_SECTION_DEBUG LoaderLockDebug;

RTL_CRITICAL_SECTION LdrpLoaderLock = {
    &LoaderLockDebug,
    -1
    };

BOOLEAN LoaderLockInitialized;

PVOID LdrpHeap;

//
// 0 means no thread has been tasked to initialize the process.
// 1 means a thread has been tasked but has not yet finished.
// 2 means a thread has been tasked and initialization is complete.
//

LONG LdrpProcessInitialized;

#define LDRP_PROCESS_INITIALIZATION_COMPLETE()              \
        LdrpProcessInitializationComplete();




VOID LdrpProcessInitializationComplete (
    VOID
    ) 
/*++

Routine Description:

    This function is called to trigger that process initialization has completed.
    Wow64 loader calls this entry after its process initialization part.

Arguments:

    None.
    
Return Value:

    None.  Raises an exception on failure.

--*/

{
    ASSERT (LdrpProcessInitialized == 1);
    InterlockedIncrement (&LdrpProcessInitialized);
}


VOID
LdrpInitialize (
    IN PCONTEXT Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This function is called as a User-Mode APC routine as the first
    user-mode code executed by a new thread. It's function is to initialize
    loader context, perform module initialization callouts...

Arguments:

    Context - Supplies an optional context buffer that will be restored
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

    SystemArgument1 - Supplies the base address of the System Dll.

    SystemArgument2 - not used.

Return Value:

    None.  Raises an exception on failure.

--*/

{
    NTSTATUS InitStatus;
    PPEB Peb;
    PTEB Teb;
    LONG ProcessInitialized;
    MEMORY_BASIC_INFORMATION MemInfo;
    LARGE_INTEGER DelayValue;

    UNREFERENCED_PARAMETER (SystemArgument2);

    LDRP_CHECKPOINT();

    Teb = NtCurrentTeb ();

    //
    // Initialize the DeallocationStack so that subsequent stack growth for
    // this thread can happen properly regardless of where the process is
    // with respect to initialization.
    //

    if (Teb->DeallocationStack == NULL) {

        LDRP_CHECKPOINT();

        InitStatus = NtQueryVirtualMemory (NtCurrentProcess(),
                                           Teb->NtTib.StackLimit,
                                           MemoryBasicInformation,
                                           (PVOID)&MemInfo,
                                           sizeof(MemInfo),
                                           NULL);

        if (!NT_SUCCESS (InitStatus)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Call to NtQueryVirtualMemory failed with ntstaus %x\n",
                __FUNCTION__,
                InitStatus);

            LdrpInitializationFailure (InitStatus);
            RtlRaiseStatus (InitStatus);
            return;
        }

        Teb->DeallocationStack = MemInfo.AllocationBase;

#if defined(_IA64_)
        Teb->DeallocationBStore = (PVOID)((ULONG_PTR)MemInfo.AllocationBase + MemInfo.RegionSize);
#endif

    }

    do {

        ProcessInitialized = InterlockedCompareExchange (&LdrpProcessInitialized,
                                                         1,
                                                         0);

        if (ProcessInitialized != 1) {
            ASSERT ((ProcessInitialized == 0) || (ProcessInitialized == 2));
            break;
        }

        //
        // This is not the thread responsible for initializing the process - 
        // some other thread has already begun this work but no telling how
        // far they have gone.  So delay rather than try to synchronize on
        // a notification event.
        //

        //
        // Drop into a 30ms delay loop.
        //

        DelayValue.QuadPart = Int32x32To64 (30, -10000);

        while (LdrpProcessInitialized == 1) {

            InitStatus = NtDelayExecution (FALSE, &DelayValue);

            if (!NT_SUCCESS(InitStatus)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: ***NONFATAL*** %s - call to NtDelayExecution waiting on loader lock failed; ntstatus = %x\n",
                    __FUNCTION__,
                    InitStatus);
            }
        }

    } while (TRUE);

    Peb = Teb->ProcessEnvironmentBlock;

    if (ProcessInitialized == 0) {

        //
        // We are executing this for the first thread in the process -
        // initialize processwide structures.
        //

        //
        // Initialize the LoaderLock field so kernel thread termination
        // can make an effort to release it if need be.
        //

        Peb->LoaderLock = (PVOID) &LdrpLoaderLock;

        //
        // We execute in the first thread of the process. We will do
        // some more process-wide initialization.
        //

        LdrpInLdrInit = TRUE;

#if DBG
        //
        // Time the load.
        //

        if (LdrpDisplayLoadTime) {
            NtQueryPerformanceCounter (&BeginTime, NULL);
        }
#endif

        LDRP_CHECKPOINT();

        //
        // First initialize minimal exception handling so we can at least
        // debug it as well as deliver a popup if this application fails
        // to launch during LdrpInitializeProcess.  Note this is very limited
        // as handlers cannot allocate from the heap until it is initialized,
        // etc, but this is good enough for LdrpInitializeProcessWrapperFilter.
        //

        InitializeListHead (&RtlpCalloutEntryList);

#if defined(_WIN64)
        InitializeListHead (&RtlpDynamicFunctionTable);
#endif

        __try {

            InitStatus = LdrpInitializeProcess (Context, SystemArgument1);

            if (!NT_SUCCESS(InitStatus)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - call to LdrpInitializeProcess() failed with ntstatus %x\n",
                    __FUNCTION__, InitStatus);
            }
            else if (Peb->MinimumStackCommit) {

                //
                // Make sure main thread gets the requested precommitted
                // stack size if such a value was specified system-wide
                // or for this process.
                //
                // This is a good point to do this since we just initialized
                // the process (among other things support for exception
                // dispatching).
                //

                InitStatus = LdrpTouchThreadStack (Peb->MinimumStackCommit);
            }

            LDRP_CHECKPOINT();

        } __except (LdrpInitializeProcessWrapperFilter(GetExceptionInformation()) ) {
            InitStatus = GetExceptionCode ();
        }

        LdrpInLdrInit = FALSE;

#if DBG
        if (LdrpDisplayLoadTime) {

            NtQueryPerformanceCounter(&EndTime, NULL);
            NtQueryPerformanceCounter(&ElapsedTime, &Interval);
            ElapsedTime.QuadPart = EndTime.QuadPart - BeginTime.QuadPart;

            DbgPrint("\nLoadTime %ld In units of %ld cycles/second \n",
                     ElapsedTime.LowPart,
                     Interval.LowPart);

            ElapsedTime.QuadPart = EndTime.QuadPart - InitbTime.QuadPart;

            DbgPrint("InitTime %ld\n", ElapsedTime.LowPart);

            DbgPrint("Compares %d Bypasses %d Normal Snaps %d\nSecOpens %d SecCreates %d Maps %d Relocates %d\n",
                     LdrpCompareCount,
                     LdrpSnapBypass,
                     LdrpNormalSnap,
                     LdrpSectionOpens,
                     LdrpSectionCreates,
                     LdrpSectionMaps,
                     LdrpSectionRelocates);
        }
#endif

#if defined(_WIN64)

        //
        // Wow64 will signal process initialization, so no need to do it twice.
        //

        if ((!UseWOW64) ||
            (NT_SUCCESS (InitStatus)) ||
            (LdrpProcessInitialized == 1)) {
#endif
            LDRP_PROCESS_INITIALIZATION_COMPLETE();
#if defined(_WIN64)
        }
#endif
    }
    else {

        if (Peb->InheritedAddressSpace) {
            InitStatus = LdrpForkProcess ();
        }
        else {

#if defined(_WIN64)

            //
            // Load in WOW64 if the image is supposed to run simulated.
            //

            if (UseWOW64) {

                //
                // This never returns.  It will destroy the process.
                //

                (*Wow64LdrpInitialize)(Context);

                //
                // NEVER REACHED
                //
            }
#endif
            InitStatus = STATUS_SUCCESS;

            LdrpInitializeThread (Context);
        }
    }

    NtTestAlert ();

    if (!NT_SUCCESS(InitStatus)) {
        LdrpInitializationFailure (InitStatus);
        RtlRaiseStatus (InitStatus);
    }

    //
    // The current thread is completely initialized. We will make sure
    // now that its stack has the right execute options. We avoid doing
    // this for Wow64 processes.
    //

#if defined(_WIN64)
    ASSERT (!UseWOW64);
#endif

    if (Peb->ExecuteOptions & (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA)) {
        LdrpEnforceExecuteForCurrentThreadStack ();
    }

}


NTSTATUS
LdrpForkProcess (
    VOID
    )
{
    PPEB Peb;
    NTSTATUS st;

    Peb = NtCurrentPeb ();

    ASSERT (LdrpLoaderLock.DebugInfo->CriticalSection == &LdrpLoaderLock);

    ASSERT (LoaderLockInitialized == TRUE);
    ASSERT (Peb->ProcessHeap != NULL);

    //
    // Initialize the critical section package.
    //
    // If you wanted to preserve the cloned critical sections, you'd have to
    // reinitialize all of them as the semaphore handles weren't
    // duplicated.  Unfortunately the threads aren't duplicated on fork either
    // so trying to recreate the OwningThread for owned critical sections
    // is pretty much impossible.  Just stay with the behavior NT has always
    // had, leaks and all) - NO critical sections are duplicated.
    //

    if (Peb->InheritedAddressSpace == FALSE) {
        return STATUS_SUCCESS;
    }

    st = RtlpInitDeferredCriticalSection ();

    if (!NT_SUCCESS (st)) {
        return st;
    }

    //
    // Manually add the loader lock to the critical section list.
    //

    InsertTailList (&RtlCriticalSectionList,
                    &LdrpLoaderLock.DebugInfo->ProcessLocksList);

    st = RtlInitializeCriticalSection (&FastPebLock);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    Peb->InheritedAddressSpace = FALSE;

    return st;
}


VOID
LdrpInitializationFailure (
    IN NTSTATUS FailureCode
    )
{
    ULONG_PTR ErrorParameter;
    ULONG ErrorResponse;

#if DBG
    DbgPrint("LDR: Process initialization failure; NTSTATUS = %08lx\n"
             "     Function: %s\n"
             "     Line: %d\n", FailureCode, g_LdrFunction, g_LdrLine);
#endif

    if (LdrpFatalHardErrorCount) {
        return;
    }

    //
    // It's error time...
    //

    ErrorParameter = (ULONG_PTR)FailureCode;

    NtRaiseHardError (STATUS_APP_INIT_FAILURE,
                      1,
                      0,
                      &ErrorParameter,
                      OptionOk,
                      &ErrorResponse);
}


INT
LdrpInitializeProcessWrapperFilter (
    const struct _EXCEPTION_POINTERS *ExceptionPointers
    )
/*++

Routine Description:

    Exception filter function used in __try block around invocation of
    LdrpInitializeProcess() so that if LdrpInitializeProcess() fails,
    we can set a breakpoint here and see why instead of just catching
    the exception and propogating the status.

Arguments:

    ExceptionCode
        Code returned from GetExceptionCode() in the __except()

    ExceptionPointers
        Pointer to exception information returned by GetExceptionInformation() in the __except()

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/
{
    if (DBG || g_LdrBreakOnLdrpInitializeProcessFailure) {
        DbgPrint ("LDR: LdrpInitializeProcess() threw an exception: %lu (0x%08lx)\n"
                 "     Exception record: .exr %p\n"
                 "     Context record: .cxr %p\n",
                 ExceptionPointers->ExceptionRecord->ExceptionCode,
                 ExceptionPointers->ExceptionRecord->ExceptionCode,
                 ExceptionPointers->ExceptionRecord,
                 ExceptionPointers->ContextRecord);
#if DBG
        DbgPrint ("     Last checkpoint: %s line %d\n",
                 g_LdrFunction, g_LdrLine);
#endif
        if (g_LdrBreakOnLdrpInitializeProcessFailure) {
            DbgBreakPoint ();
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

typedef struct _LDRP_PROCEDURE_NAME_ADDRESS_PAIR {
    STRING   Name;
    PVOID *  Address;
} LDRP_PROCEDURE_NAME_ADDRESS_PAIR, *PLDRP_PROCEDURE_NAME_ADDRESS_PAIR;
typedef CONST LDRP_PROCEDURE_NAME_ADDRESS_PAIR * PCLDRP_PROCEDURE_NAME_ADDRESS_PAIR;

const static LDRP_PROCEDURE_NAME_ADDRESS_PAIR LdrpShimEngineProcedures[] =
{
    { RTL_CONSTANT_STRING("SE_InstallBeforeInit"), (PVOID*)&g_pfnSE_InstallBeforeInit },
    { RTL_CONSTANT_STRING("SE_InstallAfterInit"), (PVOID*)&g_pfnSE_InstallAfterInit },
    { RTL_CONSTANT_STRING("SE_DllLoaded"), (PVOID*)&g_pfnSE_DllLoaded },
    { RTL_CONSTANT_STRING("SE_DllUnloaded"), (PVOID*)&g_pfnSE_DllUnloaded },
    { RTL_CONSTANT_STRING("SE_IsShimDll"), (PVOID*)&g_pfnSE_IsShimDll },
    { RTL_CONSTANT_STRING("SE_ProcessDying"), (PVOID*)&g_pfnSE_ProcessDying }
};


VOID
LdrpGetShimEngineInterface (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the interface to the shim engine.
    //
    SIZE_T i;
    for ( i = 0 ; i != RTL_NUMBER_OF(LdrpShimEngineProcedures); ++i ) {
        PCLDRP_PROCEDURE_NAME_ADDRESS_PAIR Procedure = &LdrpShimEngineProcedures[i];
        Status = LdrpGetProcedureAddress(g_pShimEngineModule, &Procedure->Name,
                                         0, Procedure->Address, FALSE);

        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrint("LdrpGetProcAddress failed to find %s in ShimEngine\n", 
                     Procedure->Name.Buffer);
#endif
            break;
        }
    }

    if (!NT_SUCCESS(Status)) {
        LdrpUnloadShimEngine();
    }
}


BOOL
LdrInitShimEngineDynamic (
    IN PVOID pShimEngineModule
    )
{
    PVOID    LockCookie = NULL;
    NTSTATUS Status;

    Status = LdrLockLoaderLock (0, NULL, &LockCookie);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (g_pShimEngineModule == NULL) {

        //
        // Set the global shim engine ptr.
        //

        g_pShimEngineModule = pShimEngineModule;

        //
        // Get shimengine interface.
        //

        LdrpGetShimEngineInterface ();
    }

    Status = LdrUnlockLoaderLock (0, LockCookie);

    ASSERT(NT_SUCCESS(Status));

    return TRUE;
}


VOID
LdrpLoadShimEngine (
    PWCHAR          pwszShimEngine,
    PUNICODE_STRING pstrExeFullPath,
    PVOID           pAppCompatExeData
    )
{
    UNICODE_STRING strEngine;
    NTSTATUS       status;

    RtlInitUnicodeString (&strEngine, pwszShimEngine);

    //
    // Load the specified shim engine.
    //

    status = LdrpLoadDll (0,
                          UNICODE_NULL,
                          NULL,
                          &strEngine,
                          &g_pShimEngineModule,
                          FALSE);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("LDR: Couldn't load the shim engine\n");
#endif
        return;
    }

    LdrpGetShimEngineInterface ();

    //
    // Call the shim engine to give it a chance to initialize.
    //

    if (g_pfnSE_InstallBeforeInit != NULL) {
        (*g_pfnSE_InstallBeforeInit) (pstrExeFullPath, pAppCompatExeData);
    }
}


VOID
LdrpUnloadShimEngine (
    VOID
    )
{
    SIZE_T i;

    LdrUnloadDll (g_pShimEngineModule);

    for ( i = 0 ; i != RTL_NUMBER_OF(LdrpShimEngineProcedures); ++i ) {
        *(LdrpShimEngineProcedures[i].Address) = NULL;
    }

    g_pShimEngineModule = NULL;
}

NTSTATUS
LdrpInitializeProcess (
    IN PCONTEXT Context OPTIONAL,
    IN PVOID SystemDllBase
    )

/*++

Routine Description:

    This function initializes the loader for the process.  This includes:

        - Initializing the loader data table

        - Connecting to the loader subsystem

        - Initializing all statically linked DLLs

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

    SystemDllBase - Supplies the base address of the system dll.

Return Value:

    NTSTATUS.

--*/

{
    PPEB_LDR_DATA Ldr;
    BOOLEAN ImageFileOptionsPresent;
    LOGICAL UseCOR;
#if !defined(_WIN64)
    IMAGE_COR20_HEADER *Cor20Header;
    ULONG Cor20HeaderSize;
#endif
    PWSTR pw;
    PTEB Teb;
    PPEB Peb;
    NTSTATUS st;
    PWCH p, pp;
    UNICODE_STRING CurDir;
    UNICODE_STRING FullImageName;
    UNICODE_STRING CommandLine;
    ULONG DebugProcessHeapOnly;
    HANDLE LinkHandle;
    static WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING SystemDllPath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    OBJECT_ATTRIBUTES Obja;
    LOGICAL StaticCurDir;
    ULONG i;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG ProcessHeapFlags;
    RTL_HEAP_PARAMETERS HeapParameters;
    NLSTABLEINFO xInitTableInfo;
    LARGE_INTEGER LongTimeout;
    UNICODE_STRING SystemRoot;
    LONG_PTR Diff;
    ULONG_PTR OldBase;
    PVOID pAppCompatExeData;
    RTL_HEAP_PARAMETERS LdrpHeapParameters;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    UNICODE_STRING UnicodeImageName;
    UNICODE_STRING ImagePathName; // for .local dll redirection, xwu
    PWCHAR ImagePathNameBuffer;
    BOOL DotLocalExists = FALSE;
    const static ANSI_STRING Kernel32ProcessInitPostImportFunctionName = RTL_CONSTANT_STRING("BaseProcessInitPostImport");
    const static UNICODE_STRING SlashKnownDllsString = RTL_CONSTANT_STRING(L"\\KnownDlls");
    const static UNICODE_STRING KnownDllPathString = RTL_CONSTANT_STRING(L"KnownDllPath");
    HANDLE ProcessHeap;

    LDRP_CHECKPOINT();

    //
    // Figure out process name.
    //

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;
    ProcessParameters = Peb->ProcessParameters;

    pw = ProcessParameters->ImagePathName.Buffer;

    if (!(ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
        pw = (PWSTR)((PCHAR)pw + (ULONG_PTR)(ProcessParameters));
    }

    //
    // UnicodeImageName holds the base name + extension of the image.
    //

    UnicodeImageName.Buffer = pw;
    UnicodeImageName.Length = ProcessParameters->ImagePathName.Length;
    UnicodeImageName.MaximumLength = UnicodeImageName.Length + sizeof(WCHAR);

    StaticCurDir = TRUE;
    UseCOR = FALSE;
    ImagePathNameBuffer = NULL;
    DebugProcessHeapOnly = 0;

    NtHeader = RtlImageNtHeader (Peb->ImageBaseAddress);

    if (!NtHeader) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing because we were unable to map the image base address (%p) to the PIMAGE_NT_HEADERS\n",
            __FUNCTION__,
            Peb->ImageBaseAddress);

        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Retrieve the native page size of the system
    //
#if defined(_WIN64) 
    NativePageSize = PAGE_SIZE;
    NativePageShift = PAGE_SHIFT;

#elif defined(BUILD_WOW6432)
    
    NativePageSize = Wow64GetSystemNativePageSize ();
    NativePageShift = 0;

    i = NativePageSize;
    while ((i & 1) == 0) {
        i >>= 1;
        NativePageShift++;
    }
#endif

    //
    // Parse `image file execution options' registry values if there
    // are any.  ImageFileOptionsPresent supplies a hint about any existing
    // ImageFileExecutionOption key.  If the key is missing, the
    // ApplicationCompatibilityGoo and DebugProcessHeapOnly entries won't
    // be checked again.
    //

    ImageFileOptionsPresent = LdrpInitializeExecutionOptions (&UnicodeImageName,
                                                              Peb);

    pAppCompatExeData = NULL;

#if defined(_WIN64)

    if ((NtHeader != NULL) &&
        (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)) {

        ULONG_PTR Wow64Info;

        //
        // 64-bit loader, but the exe image is 32-bit.  If
        // the Wow64Information is nonzero then use WOW64.
        // Othewise the image is a COM+ ILONLY image with
        // 32BITREQUIRED not set - the memory manager has
        // already checked the COR header and decided to
        // run the image in a full 64-bit process.
        //

        LDRP_CHECKPOINT();

        st = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessWow64Information,
                                        &Wow64Info,
                                        sizeof(Wow64Info),
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Wow64Info) {
            UseWOW64 = TRUE;
        }
        else {

            //
            // Set UseCOR to TRUE to indicate the image is a COM+ runtime image.
            //

            UseCOR = TRUE;
        }
    }
#else
    Cor20Header = RtlImageDirectoryEntryToData (Peb->ImageBaseAddress,
                                                TRUE,
                                                IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                &Cor20HeaderSize);
    if (Cor20Header) {
        UseCOR = TRUE;
    }
#endif

    LDRP_CHECKPOINT();

    ASSERT (Peb->Ldr == NULL);

    NtDllBase = SystemDllBase;

    if (NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE) {
#if defined(_WIN64)
        if (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
#endif
            //
            // Native subsystems load slower, but validate their DLLs.
            // This is to help CSR detect bad images faster.
            //

            LdrpVerifyDlls = TRUE;
    }

    //
    // Capture app compat data and clear shim data field.
    //

#if defined(_WIN64)

    //
    // If this is an x86 image, then let 32-bit ntdll read
    // and reset the appcompat pointer.
    //

    if (UseWOW64 == FALSE)
#endif
    {
        pAppCompatExeData = Peb->pShimData;
        Peb->pShimData = NULL;
    }

#if defined(BUILD_WOW6432)
    {
        //
        // The process is running in WOW64.  Sort out the optional header
        // format and reformat the image if its page size is smaller than
        // the native page size.
        //

        PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)NtHeader;

        if (NtHeader32->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 &&
            NtHeader32->OptionalHeader.SectionAlignment < NativePageSize) {

            SIZE_T ReturnLength;
            MEMORY_BASIC_INFORMATION MemoryInformation;

            st = NtQueryVirtualMemory (NtCurrentProcess(),
                                       NtHeader32,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof MemoryInformation,
                                       &ReturnLength);

            if (! NT_SUCCESS(st)) {

                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failing wow64 process initialization because:\n"
                    "   FileHeader.Machine (%u) != IMAGE_FILE_MACHINE_I386 (%u) or\n"
                    "   OptionalHeader.SectionAlignment (%u) >= NATIVE_PAGE_SIZE (%u) or\n"
                    "   NtQueryVirtualMemory on PE header failed (ntstatus %x)\n",
                    __FUNCTION__,
                    NtHeader32->FileHeader.Machine, IMAGE_FILE_MACHINE_I386,
                    NtHeader32->OptionalHeader.SectionAlignment, NativePageSize,
                    st);

                return st;
            }

            if ((MemoryInformation.Protect != PAGE_READONLY) &&
                (MemoryInformation.Protect != PAGE_EXECUTE_READ)) {

                st = LdrpWx86FormatVirtualImage (NULL,
                                                 NtHeader32,
                                                 Peb->ImageBaseAddress);

                if (!NT_SUCCESS(st)) {
    
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - failing wow64 process initialization because:\n"
                        "   FileHeader.Machine (%u) != IMAGE_FILE_MACHINE_I386 (%u) or\n"
                        "   OptionalHeader.SectionAlignment (%u) >= NATIVE_PAGE_SIZE (%u) or\n"
                        "   LdrpWxFormatVirtualImage failed (ntstatus %x)\n",
                        __FUNCTION__,
                        NtHeader32->FileHeader.Machine, IMAGE_FILE_MACHINE_I386,
                        NtHeader32->OptionalHeader.SectionAlignment, NativePageSize,
                        st);
    
                    if (st == STATUS_SUCCESS) {
                        st = STATUS_INVALID_IMAGE_FORMAT;
                    }
    
                    return st;
                }
            }
        }
    }
#endif

    LDRP_CHECKPOINT();

    LdrpNumberOfProcessors = Peb->NumberOfProcessors;
    RtlpTimeout = Peb->CriticalSectionTimeout;
    LongTimeout.QuadPart = Int32x32To64 (3600, -10000000);

    ProcessParameters = RtlNormalizeProcessParams (Peb->ProcessParameters);

    if (ProcessParameters) {
        FullImageName = ProcessParameters->ImagePathName;
        CommandLine = ProcessParameters->CommandLine;
    } else {
        RtlInitEmptyUnicodeString (&FullImageName, NULL, 0);
        RtlInitEmptyUnicodeString (&CommandLine, NULL, 0);
    }

    LDRP_CHECKPOINT();

    RtlInitNlsTables (Peb->AnsiCodePageData,
                      Peb->OemCodePageData,
                      Peb->UnicodeCaseTableData,
                      &xInitTableInfo);

    RtlResetRtlTranslations (&xInitTableInfo);

    i = 0;

#if defined(_WIN64)
    if (UseWOW64 || UseCOR) {
        //
        // Ignore image config data when initializing the 64-bit loader.
        // The 32-bit loader in ntdll32 will look at the config data
        // and do the right thing.
        //
        ImageConfigData = NULL;
    } else
#endif
    {

        ImageConfigData = RtlImageDirectoryEntryToData (Peb->ImageBaseAddress,
                                                        TRUE,
                                                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                        &i);
    }

    RtlZeroMemory (&HeapParameters, sizeof (HeapParameters));

    ProcessHeapFlags = HEAP_GROWABLE | HEAP_CLASS_0;

    HeapParameters.Length = sizeof (HeapParameters);

    if (ImageConfigData) {

        if (i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, GlobalFlagsClear)) {
            Peb->NtGlobalFlag &= ~ImageConfigData->GlobalFlagsClear;
        }

        if (i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, GlobalFlagsSet)) {
            Peb->NtGlobalFlag |= ImageConfigData->GlobalFlagsSet;
        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, CriticalSectionDefaultTimeout)) &&
            (ImageConfigData->CriticalSectionDefaultTimeout)) {

            //
            // Convert from milliseconds to NT time scale (100ns)
            //

            RtlpTimeout.QuadPart = Int32x32To64( (LONG)ImageConfigData->CriticalSectionDefaultTimeout,
                                                 -10000);

        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, ProcessHeapFlags)) &&
            (ImageConfigData->ProcessHeapFlags)) {
            ProcessHeapFlags = ImageConfigData->ProcessHeapFlags;
        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, DeCommitFreeBlockThreshold)) &&
            (ImageConfigData->DeCommitFreeBlockThreshold)) {
            HeapParameters.DeCommitFreeBlockThreshold = ImageConfigData->DeCommitFreeBlockThreshold;
        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, DeCommitTotalFreeThreshold)) &&
            (ImageConfigData->DeCommitTotalFreeThreshold)) {
            HeapParameters.DeCommitTotalFreeThreshold = ImageConfigData->DeCommitTotalFreeThreshold;
        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, MaximumAllocationSize)) &&
            (ImageConfigData->MaximumAllocationSize)) {
            HeapParameters.MaximumAllocationSize = ImageConfigData->MaximumAllocationSize;
        }

        if ((i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, VirtualMemoryThreshold)) &&
            (ImageConfigData->VirtualMemoryThreshold)) {
            HeapParameters.VirtualMemoryThreshold = ImageConfigData->VirtualMemoryThreshold;
        }
    }

    LDRP_CHECKPOINT();

    //
    // This field is non-zero if the image file that was used to create this
    // process contained a non-zero value in its image header.  If so, then
    // set the affinity mask for the process using this value.  It could also
    // be non-zero if the parent process created us suspended and poked our
    // PEB with a non-zero value before resuming.
    //

    if (Peb->ImageProcessAffinityMask) {
        st = NtSetInformationProcess (NtCurrentProcess(),
                                      ProcessAffinityMask,
                                      &Peb->ImageProcessAffinityMask,
                                      sizeof (Peb->ImageProcessAffinityMask));

        if (NT_SUCCESS (st)) {
            KdPrint (("LDR: Using ProcessAffinityMask of 0x%Ix from image.\n",
                      Peb->ImageProcessAffinityMask));
        }
        else {
            KdPrint (("LDR: Failed to set ProcessAffinityMask of 0x%Ix from image (Status == %08x).\n",
                      Peb->ImageProcessAffinityMask, st));
        }
    }

    ShowSnaps = (BOOLEAN)((FLG_SHOW_LDR_SNAPS & Peb->NtGlobalFlag) != 0);

    if (ShowSnaps) {
        DbgPrint ("LDR: PID: 0x%x started - '%wZ'\n",
                  Teb->ClientId.UniqueProcess,
                  &CommandLine);
    }

    //
    // Initialize the critical section package.
    //

    LDRP_CHECKPOINT();

    if (RtlpTimeout.QuadPart < LongTimeout.QuadPart) {
        RtlpTimoutDisable = TRUE;
    }

    st = RtlpInitDeferredCriticalSection ();

    if (!NT_SUCCESS (st)) {
        return st;
    }

    Peb->FlsBitmap = &FlsBitMap;
    Peb->TlsBitmap = &TlsBitMap;
    Peb->TlsExpansionBitmap = &TlsExpansionBitMap;

    RtlInitializeBitMap (&FlsBitMap,
                         &Peb->FlsBitmapBits[0],
                         RTL_BITS_OF (Peb->FlsBitmapBits));

    RtlSetBit (&FlsBitMap, 0);

    InitializeListHead (&Peb->FlsListHead);

    RtlInitializeBitMap (&TlsBitMap,
                         &Peb->TlsBitmapBits[0],
                         RTL_BITS_OF (Peb->TlsBitmapBits));

    RtlSetBit (&TlsBitMap, 0);

    RtlInitializeBitMap (&TlsExpansionBitMap,
                         &Peb->TlsExpansionBitmapBits[0],
                         RTL_BITS_OF (Peb->TlsExpansionBitmapBits));

    RtlSetBit (&TlsExpansionBitMap, 0);

#if defined(_WIN64)
    
    //
    // Allocate the predefined Wow64 TLS slots.
    //

    if (UseWOW64) {
        RtlSetBits (Peb->TlsBitmap, 0, WOW64_TLS_MAX_NUMBER);
    }
#endif 

    //
    // Mark the loader lock as initialized.
    //

    for (i = 0; i < LDRP_HASH_TABLE_SIZE; i += 1) {
        InitializeListHead (&LdrpHashTable[i]);
    }

    InsertTailList (&RtlCriticalSectionList,
                    &LdrpLoaderLock.DebugInfo->ProcessLocksList);

    LdrpLoaderLock.DebugInfo->CriticalSection = &LdrpLoaderLock;
    LoaderLockInitialized = TRUE;

    LDRP_CHECKPOINT();

    //
    // Initialize the stack trace data base if requested
    //

    if ((Peb->NtGlobalFlag & FLG_USER_STACK_TRACE_DB)
        || LdrpShouldCreateStackTraceDb) {

        PVOID BaseAddress = NULL;
        SIZE_T ReserveSize = 8 * RTL_MEG;

        st = LdrQueryImageFileExecutionOptions (&UnicodeImageName,
                                                L"StackTraceDatabaseSizeInMb",
                                                REG_DWORD,
                                                &ReserveSize,
                                                sizeof (ReserveSize),
                                                NULL);

        //
        // Sanity check the value read from registry.
        //

        if (! NT_SUCCESS(st)) {
            ReserveSize = 8 * RTL_MEG;
        }
        else {
            if (ReserveSize < 8) {
                ReserveSize = 8 * RTL_MEG;
            }
            else if (ReserveSize > 128) {
                ReserveSize = 128 * RTL_MEG;
            }
            else {
                ReserveSize *= RTL_MEG;
            }

            DbgPrint ("LDR: Stack trace database size is %u Mb \n",
                            ReserveSize / RTL_MEG);
        }

        st = NtAllocateVirtualMemory (NtCurrentProcess(),
                                     (PVOID *)&BaseAddress,
                                     0,
                                     &ReserveSize,
                                     MEM_RESERVE,
                                     PAGE_READWRITE);

        if (NT_SUCCESS(st)) {

            st = RtlInitializeStackTraceDataBase (BaseAddress,
                                                  0,
                                                  ReserveSize);

            if (!NT_SUCCESS (st)) {

                NtFreeVirtualMemory (NtCurrentProcess(),
                                     (PVOID *)&BaseAddress,
                                     &ReserveSize,
                                     MEM_RELEASE);
            }
            else {

                //
                // If the stack trace db is not created due to page heap
                // enabling then we can set the NT heap debugging flags.
                // If we create it due to page heap then we should not
                // enable these flags because page heap and NT debug heap
                // do not coexist peacefully.
                //

                if (!LdrpShouldCreateStackTraceDb) {
                    Peb->NtGlobalFlag |= FLG_HEAP_VALIDATE_PARAMETERS;
                }
            }
        }
    }

    //
    // Initialize the loader data based in the PEB.
    //

    st = RtlInitializeCriticalSection (&FastPebLock);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    st = RtlInitializeCriticalSection (&RtlpCalloutEntryLock);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    LDRP_CHECKPOINT();

    //
    // Initialize the Etw stuff.
    //

    st = EtwpInitializeDll ();

    if (!NT_SUCCESS(st)) {
        return st;
    }

    InitializeListHead (&LdrpDllNotificationList);

    Peb->FastPebLock = &FastPebLock;

    LDRP_CHECKPOINT();

    RtlInitializeHeapManager ();

    LDRP_CHECKPOINT();

#if defined(_WIN64)
    if ((UseWOW64) ||
        (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)) {

        //
        // Create a heap using all defaults.  The 32-bit process heap
        // will be created later by ntdll32 using the parameters from the exe.
        //

        ProcessHeap = RtlCreateHeap (ProcessHeapFlags,
                                          NULL,
                                          0,
                                          0,
                                          NULL,
                                          &HeapParameters);
    } else
#endif
    {
        if (NtHeader->OptionalHeader.MajorSubsystemVersion <= 3 &&
            NtHeader->OptionalHeader.MinorSubsystemVersion < 51
           ) {
            ProcessHeapFlags |= HEAP_CREATE_ALIGN_16;
        }

        ProcessHeap = RtlCreateHeap (ProcessHeapFlags,
                                          NULL,
                                          NtHeader->OptionalHeader.SizeOfHeapReserve,
                                          NtHeader->OptionalHeader.SizeOfHeapCommit,
                                          NULL, // Lock to use for serialization
                                          &HeapParameters);
    }

    if (ProcessHeap == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to create process heap\n",
            __FUNCTION__);

        return STATUS_NO_MEMORY;
    }

    Peb->ProcessHeap = ProcessHeap;

    //
    // Create the loader private heap.
    //

    RtlZeroMemory (&LdrpHeapParameters, sizeof(LdrpHeapParameters));
    LdrpHeapParameters.Length = sizeof (LdrpHeapParameters);

    LdrpHeap = RtlCreateHeap (
                        HEAP_GROWABLE | HEAP_CLASS_1,
                        NULL,
                        64 * 1024, // 0 is ok here, 64k is a chosen tuned number
                        24 * 1024, // 0 is ok here, 24k is a chosen tuned number
                        NULL,
                        &LdrpHeapParameters);

    if (LdrpHeap == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s failing process initialization due to inability to create loader private heap.\n",
            __FUNCTION__);
        return STATUS_NO_MEMORY;
    }

    LDRP_CHECKPOINT();

    NtdllBaseTag = RtlCreateTagHeap (ProcessHeap,
                                     0,
                                     L"NTDLL!",
                                     L"!Process\0"                  // Heap Name
                                     L"CSRSS Client\0"
                                     L"LDR Database\0"
                                     L"Current Directory\0"
                                     L"TLS Storage\0"
                                     L"DBGSS Client\0"
                                     L"SE Temporary\0"
                                     L"Temporary\0"
                                     L"LocalAtom\0");

    RtlInitializeAtomPackage (MAKE_TAG(ATOM_TAG));

    LDRP_CHECKPOINT();

    //
    // Allow only the process heap to have page allocations turned on.
    //

    if (ImageFileOptionsPresent) {

        st = LdrQueryImageFileExecutionOptions (&UnicodeImageName,
                                                L"DebugProcessHeapOnly",
                                                REG_DWORD,
                                                &DebugProcessHeapOnly,
                                                sizeof (DebugProcessHeapOnly),
                                                NULL);
        if (NT_SUCCESS (st)) {
            if (RtlpDebugPageHeap && (DebugProcessHeapOnly != 0)) {
                
                //
                // The process heap was created while `pageheap' was on
                // so now we just disable `pageheap' boolean and everything
                // will be quiet. Note that actually we get two heaps
                // `pageheap-ed' because there is also the loader heap 
                // that gets created. This is ok. We need to verify that too.
                //
                
                RtlpDebugPageHeap = FALSE;
                
                //
                // If `DebugProcessHeapOnly' is on we need to disable per dll
                // page heap because the new thunks replacing allocation
                // functions call directly page heap APIs which do not check
                // if page heap is on or not. They just assume it is on since
                // they are called from NT heap manager properly. We cannot 
                // just put a check in all page heap APIs because there is
                // no meaningful value to return in case the page heap is not
                // on.
                //

                RtlpDphGlobalFlags &= ~PAGE_HEAP_USE_DLL_NAMES;
            }
        }
    }

    LDRP_CHECKPOINT();

    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof (SystemDllPathBuffer);

    RtlInitUnicodeString (&SystemRoot, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeStringToString (&SystemDllPath, &SystemRoot);
    RtlAppendUnicodeStringToString (&SystemDllPath, &SlashSystem32SlashString);

    InitializeObjectAttributes (&Obja,
                                (PUNICODE_STRING)&SlashKnownDllsString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    st = NtOpenDirectoryObject (&LdrpKnownDllObjectDirectory,
                                DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
                                &Obja);

    if (!NT_SUCCESS(st)) {

        LdrpKnownDllObjectDirectory = NULL;

        //
        // KnownDlls directory doesn't exist - assume it's system32.
        //

        RtlInitUnicodeString (&LdrpKnownDllPath, SystemDllPath.Buffer);
        LdrpKnownDllPath.Length -= sizeof(WCHAR);    // remove trailing '\'
    } else {

        //
        // Open up the known dll pathname link and query its value.
        //

        InitializeObjectAttributes (&Obja,
                                    (PUNICODE_STRING)&KnownDllPathString,
                                    OBJ_CASE_INSENSITIVE,
                                    LdrpKnownDllObjectDirectory,
                                    NULL);

        st = NtOpenSymbolicLinkObject (&LinkHandle, SYMBOLIC_LINK_QUERY, &Obja);

        if (NT_SUCCESS (st)) {

            LdrpKnownDllPath.Length = 0;
            LdrpKnownDllPath.MaximumLength = sizeof(LdrpKnownDllPathBuffer);
            LdrpKnownDllPath.Buffer = LdrpKnownDllPathBuffer;

            st = NtQuerySymbolicLinkObject (LinkHandle,
                                            &LdrpKnownDllPath,
                                            NULL);

            NtClose(LinkHandle);

            if (!NT_SUCCESS(st)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed call to NtQuerySymbolicLinkObject with status %x\n",
                    __FUNCTION__,
                    st);

                return st;
            }
        } else {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - failed call to NtOpenSymbolicLinkObject with status %x\n",
                __FUNCTION__,
                st);
            return st;
        }
    }

    LDRP_CHECKPOINT();

    if (ProcessParameters) {

        //
        // If the process was created with process parameters,
        // then extract:
        //
        //      - Library Search Path
        //
        //      - Starting Current Directory
        //

        if (ProcessParameters->DllPath.Length) {
            LdrpDefaultPath = ProcessParameters->DllPath;
        }
        else {
            LdrpInitializationFailure(STATUS_INVALID_PARAMETER);
        }

        CurDir = ProcessParameters->CurrentDirectory.DosPath;

#define DRIVE_ROOT_DIRECTORY_LENGTH 3 /* (sizeof("X:\\") - 1) */
        if (CurDir.Buffer == NULL || CurDir.Length == 0 || CurDir.Buffer[ 0 ] == UNICODE_NULL) {

            CurDir.Buffer = RtlAllocateHeap (ProcessHeap,
                                             0,
                                             (DRIVE_ROOT_DIRECTORY_LENGTH + 1) * sizeof(WCHAR));
            if (CurDir.Buffer == NULL) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - unable to allocate current working directory buffer\n",
                    __FUNCTION__);

                return STATUS_NO_MEMORY;
            }

            StaticCurDir = FALSE;

            RtlCopyMemory (CurDir.Buffer,
                           USER_SHARED_DATA->NtSystemRoot,
                           DRIVE_ROOT_DIRECTORY_LENGTH * sizeof(WCHAR));

            CurDir.Buffer[DRIVE_ROOT_DIRECTORY_LENGTH] = UNICODE_NULL;

            CurDir.Length = DRIVE_ROOT_DIRECTORY_LENGTH * sizeof(WCHAR);
            CurDir.MaximumLength = CurDir.Length + sizeof(WCHAR);
        }
    }
    else {
        CurDir = SystemRoot;
    }

    //
    // Make sure the module data base is initialized before we take any
    // exceptions.
    //

    LDRP_CHECKPOINT();

    Ldr = &PebLdr;

    Peb->Ldr = Ldr;

    Ldr->Length = sizeof(PEB_LDR_DATA);
    Ldr->Initialized = TRUE;
    ASSERT (Ldr->SsHandle == NULL);
    ASSERT (Ldr->EntryInProgress == NULL);
    ASSERT (Ldr->InLoadOrderModuleList.Flink == NULL);
    ASSERT (Ldr->InLoadOrderModuleList.Blink == NULL);
    ASSERT (Ldr->InMemoryOrderModuleList.Flink == NULL);
    ASSERT (Ldr->InMemoryOrderModuleList.Blink == NULL);
    ASSERT (Ldr->InInitializationOrderModuleList.Flink == NULL);
    ASSERT (Ldr->InInitializationOrderModuleList.Blink == NULL);

    InitializeListHead (&Ldr->InLoadOrderModuleList);
    InitializeListHead (&Ldr->InMemoryOrderModuleList);
    InitializeListHead (&Ldr->InInitializationOrderModuleList);

    //
    // Allocate the first data table entry for the image.  Since we
    // have already mapped this one, we need to do the allocation by hand.
    // Its characteristics identify it as not a Dll, but it is linked
    // into the table so that pc correlation searching doesn't have to
    // be special cased.
    //

    LdrpImageEntry = LdrpAllocateDataTableEntry (Peb->ImageBaseAddress);
    LdrDataTableEntry = LdrpImageEntry;

    if (LdrDataTableEntry == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing process initialization due to inability allocate \"%wZ\"'s LDR_DATA_TABLE_ENTRY\n",
            __FUNCTION__,
            &FullImageName);

        if (!StaticCurDir) {
            RtlFreeUnicodeString (&CurDir);
        }

        return STATUS_NO_MEMORY;
    }

    LdrDataTableEntry->LoadCount = (USHORT)0xffff;
    LdrDataTableEntry->EntryPoint = LdrpFetchAddressOfEntryPoint(LdrDataTableEntry->DllBase);
    LdrDataTableEntry->FullDllName = FullImageName;
    LdrDataTableEntry->Flags = (UseCOR) ? LDRP_COR_IMAGE : 0;
    LdrDataTableEntry->EntryPointActivationContext = NULL;

    //
    // p = strrchr(FullImageName, '\\');
    // but not necessarily null terminated
    //

    pp = UNICODE_NULL;
    p = FullImageName.Buffer;
    while (*p) {
        if (*p++ == (WCHAR)'\\') {
            pp = p;
        }
    }

    if (pp != UNICODE_NULL) {
        LdrDataTableEntry->BaseDllName.Length = (USHORT)((ULONG_PTR)p - (ULONG_PTR)pp);
        LdrDataTableEntry->BaseDllName.MaximumLength = LdrDataTableEntry->BaseDllName.Length + sizeof(WCHAR);
        LdrDataTableEntry->BaseDllName.Buffer =
            (PWSTR)
                (((ULONG_PTR) LdrDataTableEntry->FullDllName.Buffer) +
                    (LdrDataTableEntry->FullDllName.Length - LdrDataTableEntry->BaseDllName.Length));

    } else {
        LdrDataTableEntry->BaseDllName = LdrDataTableEntry->FullDllName;
    }

    LdrDataTableEntry->Flags |= LDRP_ENTRY_PROCESSED;

    LdrpInsertMemoryTableEntry (LdrDataTableEntry);

    //
    // The process references the system DLL, so insert this next into the
    // loader table. Since we have already mapped this one, we need to do
    // the allocation by hand. Since every application will be statically
    // linked to the system Dll, keep the LoadCount initialized to 0.
    //

    LdrDataTableEntry = LdrpAllocateDataTableEntry (SystemDllBase);

    if (LdrDataTableEntry == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing process initialization due to inability to allocate NTDLL's LDR_DATA_TABLE_ENTRY\n",
            __FUNCTION__);

        if (!StaticCurDir) {
            RtlFreeUnicodeString (&CurDir);
        }

        return STATUS_NO_MEMORY;
    }


    LdrDataTableEntry->Flags = (USHORT)LDRP_IMAGE_DLL;
    LdrDataTableEntry->EntryPoint = LdrpFetchAddressOfEntryPoint(LdrDataTableEntry->DllBase);
    LdrDataTableEntry->LoadCount = (USHORT)0xffff;
    LdrDataTableEntry->EntryPointActivationContext = NULL;

    LdrDataTableEntry->FullDllName = SystemDllPath;
    RtlAppendUnicodeStringToString(&LdrDataTableEntry->FullDllName, &NtDllName);
    LdrDataTableEntry->BaseDllName = NtDllName;

    LdrpInsertMemoryTableEntry (LdrDataTableEntry);

#if defined(_WIN64)

    RtlInitializeHistoryTable ();

#endif

    LdrpNtDllDataTableEntry = LdrDataTableEntry;

    if (ShowSnaps) {
        DbgPrint( "LDR: NEW PROCESS\n" );
        DbgPrint( "     Image Path: %wZ (%wZ)\n",
                  &LdrpImageEntry->FullDllName,
                  &LdrpImageEntry->BaseDllName
                );
        DbgPrint( "     Current Directory: %wZ\n", &CurDir );
        DbgPrint( "     Search Path: %wZ\n", &LdrpDefaultPath );
    }

    //
    // Add init routine to list
    //

    InsertHeadList (&Ldr->InInitializationOrderModuleList,
                    &LdrDataTableEntry->InInitializationOrderLinks);

    //
    // Inherit the current directory
    //

    LDRP_CHECKPOINT();

    st = RtlSetCurrentDirectory_U (&CurDir);

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to set current directory to \"%wZ\"; status = %x\n",
            __FUNCTION__,
            &CurDir,
            st);

        if (!StaticCurDir) {
            RtlFreeUnicodeString (&CurDir);
        }

        CurDir = SystemRoot;

        st = RtlSetCurrentDirectory_U (&CurDir);

        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - unable to set current directory to NtSystemRoot; status = %x\n",
                __FUNCTION__,
                st);
        }
    }
    else {
        if (!StaticCurDir) {
            RtlFreeUnicodeString (&CurDir);
        }
    }

    if (ProcessParameters->Flags & RTL_USER_PROC_APP_MANIFEST_PRESENT) {
        // Application manifests prevent .local detection.
        //
        // Note that we don't clear the flag so that someone like app compat
        // can forcibly set it to reenable .local + app manifest behavior.
    } else {
        //
        // Fusion 1.0 fixup : check the existence of .local, and set
        // a flag in PPeb->ProcessParameters.Flags
        //
        // Setup the global for this process that decides whether we want DLL
        // redirection on or not. LoadLibrary() and GetModuleHandle() look at this
        // boolean.
        //

        if (ProcessParameters->ImagePathName.Length > (MAXUSHORT -
            sizeof(DLL_REDIRECTION_LOCAL_SUFFIX))) {
            return STATUS_NAME_TOO_LONG;
        }

        ImagePathName.Length = ProcessParameters->ImagePathName.Length;
        ImagePathName.MaximumLength = ProcessParameters->ImagePathName.Length + sizeof(DLL_REDIRECTION_LOCAL_SUFFIX);
        ImagePathNameBuffer = (PWCHAR) RtlAllocateHeap (ProcessHeap, MAKE_TAG( TEMP_TAG ), ImagePathName.MaximumLength);

        if (ImagePathNameBuffer == NULL) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - unable to allocate heap for the image's .local path\n",
                __FUNCTION__);

            return STATUS_NO_MEMORY;
        }

        RtlCopyMemory (ImagePathNameBuffer,
                    pw,
                    ProcessParameters->ImagePathName.Length);

        ImagePathName.Buffer = ImagePathNameBuffer;

        //
        // Now append the suffix:
        //

        st = RtlAppendUnicodeToString(&ImagePathName, DLL_REDIRECTION_LOCAL_SUFFIX);

        if (!NT_SUCCESS(st)) {
    #if DBG
            DbgPrint("RtlAppendUnicodeToString fails with status %lx\n", st);
    #endif
            RtlFreeHeap(ProcessHeap, 0, ImagePathNameBuffer);
            return st;
        }

        //
        // RtlDoesFileExists_U() wants a null-terminated string.
        //

        ImagePathNameBuffer[ImagePathName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        DotLocalExists = RtlDoesFileExists_U(ImagePathNameBuffer);

        if (DotLocalExists) { // set the flag in Peb->ProcessParameters->flags
            ProcessParameters->Flags |=  RTL_USER_PROC_DLL_REDIRECTION_LOCAL;
        }

        RtlFreeHeap (ProcessHeap, 0, ImagePathNameBuffer); //cleanup
    }

    //
    // Second round of application verifier initialization. We need to split 
    // this into two phases because some verifier things must happen very early
    // and other things rely on other things being already initialized
    // (exception dispatching, system heap, etc).
    //

    if (Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
        AVrfInitializeVerifier (FALSE, NULL, 1);
    }

#if defined(_WIN64)

    //
    // Load in WOW64 if the image is supposed to run simulated
    //

    if (UseWOW64) {
        static UNICODE_STRING Wow64DllName = RTL_CONSTANT_STRING(L"wow64.dll");
        CONST static ANSI_STRING Wow64LdrpInitializeProcName = RTL_CONSTANT_STRING("Wow64LdrpInitialize");
        CONST static ANSI_STRING Wow64PrepareForExceptionProcName = RTL_CONSTANT_STRING("Wow64PrepareForException");
        CONST static ANSI_STRING Wow64ApcRoutineProcName = RTL_CONSTANT_STRING("Wow64ApcRoutine");

        st = LdrLoadDll(NULL, NULL, &Wow64DllName, &Wow64Handle);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: wow64.dll not found.  Status=%x\n", st);
            }
            return st;
        }

        //
        // Get the entrypoints.  They are roughly cloned from ntos\ps\psinit.c
        // PspInitSystemDll().
        //

        st = LdrGetProcedureAddress (Wow64Handle,
                                     &Wow64LdrpInitializeProcName,
                                     0,
                                     (PVOID *)&Wow64LdrpInitialize);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64LdrpInitialize not found.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress (Wow64Handle,
                                     &Wow64PrepareForExceptionProcName,
                                     0,
                                     (PVOID *)&Wow64PrepareForException);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64PrepareForException not found.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress (Wow64Handle,
                                     &Wow64ApcRoutineProcName,
                                     0,
                                     (PVOID *)&Wow64ApcRoutine);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64ApcRoutine not found.  Status=%x\n", st);
            }
            return st;
        }

        //
        // Now that all DLLs are loaded, if the process is being debugged,
        // signal the debugger with an exception
        //

        if (Peb->BeingDebugged) {
             DbgBreakPoint ();
        }

        //
        // Mark the process as initialized so subsequent threads that
        // get created know not to wait.
        //

        LdrpInLdrInit = FALSE;

        //
        // Call wow64 to load and run 32-bit ntdll.dll.
        //

        (*Wow64LdrpInitialize)(Context);

        //
        // This never returns.  It will destroy the process.
        //
    }
#endif

    LDRP_CHECKPOINT();

    //
    // Check if image is COM+.
    //

    if (UseCOR) {

        //
        // The image is COM+ so notify the runtime that the image was loaded
        // and allow it to verify the image for correctness.
        //

        PVOID OriginalViewBase;

        OriginalViewBase = Peb->ImageBaseAddress;

        st = LdrpCorValidateImage (&Peb->ImageBaseAddress,
                                   LdrpImageEntry->FullDllName.Buffer);

        if (!NT_SUCCESS(st)) {
            return st;
        }

        if (OriginalViewBase != Peb->ImageBaseAddress) {

            //
            // Mscoree has substituted a new image at a new base in place
            // of the original image.  Unmap the original image and use
            // the new image from now on.
            //

            NtUnmapViewOfSection (NtCurrentProcess(), OriginalViewBase);

            NtHeader = RtlImageNtHeader (Peb->ImageBaseAddress);

            if (!NtHeader) {
                LdrpCorUnloadImage (Peb->ImageBaseAddress);
                return STATUS_INVALID_IMAGE_FORMAT;
            }

            //
            // Update the exe's LDR_DATA_TABLE_ENTRY.
            //

            LdrpImageEntry->DllBase = Peb->ImageBaseAddress;
            LdrpImageEntry->EntryPoint = LdrpFetchAddressOfEntryPoint (LdrpImageEntry->DllBase);
        }

        //
        // Edit the initial instruction pointer to point into mscoree.dll.
        //

        LdrpCorReplaceStartContext (Context);
    }

    LDRP_CHECKPOINT();

    //
    // If this is a windows subsystem app, load kernel32 so that it
    // can handle processing activation contexts found in DLLs and the .exe.
    //

    if ((NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) ||
        (NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)) {

        PVOID Kernel32Handle;
        const static UNICODE_STRING Kernel32DllName = RTL_CONSTANT_STRING(L"kernel32.dll");

        st = LdrLoadDll (NULL,               // DllPath
                         NULL,               // DllCharacteristics
                         &Kernel32DllName,   // DllName
                         &Kernel32Handle     // DllHandle
                         );

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Unable to load kernel32.dll.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress (Kernel32Handle,
                                     &Kernel32ProcessInitPostImportFunctionName,
                                     0,
                                     (PVOID *) &Kernel32ProcessInitPostImportFunction);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint(
                    "LDR: Failed to find post-import process init function in kernel32; ntstatus 0x%08lx\n", st);
            }

            Kernel32ProcessInitPostImportFunction = NULL;

            if (st != STATUS_PROCEDURE_NOT_FOUND) {
                return st;
            }
        }
    }

    LDRP_CHECKPOINT();

    st = LdrpWalkImportDescriptor (LdrpDefaultPath.Buffer, LdrpImageEntry);

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - call to LdrpWalkImportDescriptor failed with status %x\n",
            __FUNCTION__,
            st);

        //
        // This failure is fatal and we must not run the process.
        //

        return st;
    }

    LDRP_CHECKPOINT();

    if ((PVOID)NtHeader->OptionalHeader.ImageBase != Peb->ImageBaseAddress) {

        //
        // The executable is not at its original address.  It must be
        // relocated now.
        //

        PVOID ViewBase;

        ViewBase = Peb->ImageBaseAddress;

        st = LdrpSetProtection (ViewBase, FALSE);

        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrpSetProtection(%p, FALSE) failed with status %x\n",
                __FUNCTION__,
                ViewBase,
                st);

            return st;
        }

        st = LdrRelocateImage (ViewBase,
                               "LDR",
                               STATUS_SUCCESS,
                               STATUS_CONFLICTING_ADDRESSES,
                               STATUS_INVALID_IMAGE_FORMAT);

        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrRelocateImage failed with status %x\n",
                __FUNCTION__,
                st);

            return st;
        }

        //
        // Update the initial thread context record as per the relocation.
        //

        if ((Context != NULL) && (UseCOR == FALSE)) {

            OldBase = NtHeader->OptionalHeader.ImageBase;
            Diff = (PCHAR)ViewBase - (PCHAR)OldBase;

            LdrpRelocateStartContext (Context, Diff);
        }

        st = LdrpSetProtection (ViewBase, TRUE);

        if (!NT_SUCCESS (st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrpSetProtection(%p, TRUE) failed with status %x\n",
                __FUNCTION__,
                ViewBase,
                st);

            return st;
        }
    }

    LDRP_CHECKPOINT();

    LdrpReferenceLoadedDll (LdrpImageEntry);

    //
    // Lock the loaded DLLs to prevent dlls that back link to the exe from
    // causing problems when they are unloaded.
    //

    Head = &Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next,
                                   LDR_DATA_TABLE_ENTRY,
                                   InLoadOrderLinks);

        Entry->LoadCount = 0xffff;
        Next = Next->Flink;
    }

    //
    // All static DLLs are now pinned in place. No init routines
    // have been run yet.
    //

    LdrpLdrDatabaseIsSetup = TRUE;

    LDRP_CHECKPOINT();

    st = LdrpInitializeTls ();

    if (!NT_SUCCESS(st)) {

        DbgPrintEx (DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed to initialize TLS slots; status %x\n",
                    __FUNCTION__,
                    st);

        return st;
    }

#if defined(_X86_)

    //
    // Register initial dll ranges with the stack tracing module.
    // This is used for getting reliable stack traces on X86.
    //

    Head = &Ldr->InMemoryOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next,
                                   LDR_DATA_TABLE_ENTRY,
                                   InMemoryOrderLinks);

        RtlpStkMarkDllRange (Entry);
        Next = Next->Flink;
    }
#endif

    //
    // Now that all DLLs are loaded, if the process is being debugged,
    // signal the debugger with an exception.
    //

    if (Peb->BeingDebugged) {
         DbgBreakPoint ();
         ShowSnaps = (BOOLEAN)((FLG_SHOW_LDR_SNAPS & Peb->NtGlobalFlag) != 0);
    }

    LDRP_CHECKPOINT();

#if defined (_X86_)
    if (LdrpNumberOfProcessors > 1) {
        LdrpValidateImageForMp (LdrDataTableEntry);
    }
#endif

#if DBG
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter (&InitbTime, NULL);
    }
#endif

    //
    // Check for shimmed apps if necessary
    //

    if (pAppCompatExeData != NULL) {

        Peb->AppCompatInfo = NULL;

        //
        // The name of the engine is the first thing in the appcompat structure.
        //

        LdrpLoadShimEngine ((WCHAR*)pAppCompatExeData,
                            &UnicodeImageName,
                            pAppCompatExeData);
    }
    else {

        //
        // Get all application goo here (hacks, flags, etc.)
        //

        LdrQueryApplicationCompatibilityGoo (&UnicodeImageName,
                                             ImageFileOptionsPresent);
    }

    LDRP_CHECKPOINT();

    st = LdrpRunInitializeRoutines (Context);

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - Failed running initialization routines; status %x\n",
            __FUNCTION__,
            st);

        return st;
    }

    //
    // Shim engine callback.
    //

    if (g_pfnSE_InstallAfterInit != NULL) {
        if (!(*g_pfnSE_InstallAfterInit) (&UnicodeImageName, pAppCompatExeData)) {
            LdrpUnloadShimEngine ();
        }
    }

    if (Peb->PostProcessInitRoutine != NULL) {
        (Peb->PostProcessInitRoutine) ();
    }

    LDRP_CHECKPOINT();

    return STATUS_SUCCESS;
}


VOID
LdrShutdownProcess (
    VOID
    )

/*++

Routine Description:

    This function is called by a process that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the process is detaching.

Arguments:

    None

Return Value:

    None.

--*/

{
    PTEB Teb;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;
    UNICODE_STRING CommandLine;

    //
    // Only unload once - ie: guard against Dll termination routines that
    // might call exit process in fatal situations.
    //

    if (LdrpShutdownInProgress) {
        return;
    }

    //
    // Notify the shim engine that the process is exiting.
    //

    if (g_pfnSE_ProcessDying) {
        (*g_pfnSE_ProcessDying) ();
    }

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;

    if (ShowSnaps) {

        CommandLine = Peb->ProcessParameters->CommandLine;
        if (!(Peb->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
            CommandLine.Buffer = (PWSTR)((PCHAR)CommandLine.Buffer + (ULONG_PTR)(Peb->ProcessParameters));
        }

        DbgPrint ("LDR: PID: 0x%x finished - '%wZ'\n",
                  Teb->ClientId.UniqueProcess,
                  &CommandLine);
    }

    LdrpShutdownThreadId = Teb->ClientId.UniqueThread;
    LdrpShutdownInProgress = TRUE;

    RtlEnterCriticalSection (&LdrpLoaderLock);

    try {

        //
        // NTRAID#NTBUG9-399703-2001/05/21-SilviuC
        // check for process heap lock does not
        // offer enough protection.  The if below is not enough to prevent
        // deadlocks in dll init code due to waiting for critical sections
        // orphaned by terminating all threads (except this one).
        //
        // A better way to implement this would be to iterate all
        // critical sections and figure out if any of them is abandoned
        // with an owner thread different than this one. If yes then we
        // probably should not call dll init routines.  The code
        // right now is deadlock-prone.
        //
        // Check to see if the heap is locked. If so, do not do ANY
        // dll processing since it is very likely that a dll will need
        // to do heap operations, but that the heap is not in good shape.
        // ExitProcess called in a very active app can leave threads
        // terminated in the middle of the heap code or in other very
        // bad places. Checking the heap lock is a good indication that
        // the process was very active when it called ExitProcess.
        //

        if (RtlpHeapIsLocked (Peb->ProcessHeap) == FALSE) {

            //
            // If tracing was ever turned on then cleanup the things here.
            //

            if (USER_SHARED_DATA->TraceLogging) {
                ShutDownEtwHandles ();
            }

            //
            // NOTICE-2001/05/21-SilviuC
            // IMPORTANT NOTE. We cannot do heap validation here no matter
            // how much we would like to because we have just unconditionally
            // terminated all the other threads and this could have left
            // heaps in some weird state. For instance a heap might have
            // been destroyed but we did not manage to get it out of the
            // process heap list and we will still try to validate it.
            // In the future all this type of code should be implemented
            // in appverifier.
            //

            //
            // Go in reverse order initialization order and build
            // the unload list.
            //

            Next = PebLdr.InInitializationOrderModuleList.Blink;

            while (Next != &PebLdr.InInitializationOrderModuleList) {

                LdrDataTableEntry
                    = (PLDR_DATA_TABLE_ENTRY)
                      (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));

                Next = Next->Blink;

                //
                // Walk through the entire list looking for
                // entries. For each entry that has an init
                // routine, call it.
                //

                if (Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) {
                    InitRoutine = (PDLL_INIT_ROUTINE)(ULONG_PTR)LdrDataTableEntry->EntryPoint;
                    if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                        LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                        if ( LdrDataTableEntry->TlsIndex) {
                            LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_PROCESS_DETACH);
                        }

                        LdrpCallInitRoutine(InitRoutine,
                                            LdrDataTableEntry->DllBase,
                                            DLL_PROCESS_DETACH,
                                            (PVOID)1);
                        LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                    }
                }
            }

            //
            // If the image has tls than call its initializers
            //

            if (LdrpImageHasTls) {
                LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);
                LdrpCallTlsInitializers(Peb->ImageBaseAddress,DLL_PROCESS_DETACH);
                LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
            }
        }

        //
        // This is a good moment to call automated heap leak detection since
        // we just called all DllMain's with PROCESS_DETACH and therefore we
        // offered all cleanup opportunities we can offer.
        //

        RtlDetectHeapLeaks ();

        //
        // Now Deinitialize the Etw stuff. This needs to happen
        // AFTER DLL_PROCESS_DETACH because the critsect cannot
        // be deleted for DLLs who de-register during detach.
        //

        EtwpDeinitializeDll ();

    } finally {
        RtlLeaveCriticalSection (&LdrpLoaderLock);
    }

}


VOID
LdrShutdownThread (
    VOID
    )

/*++

Routine Description:

    This function is called by a thread that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the thread is detaching.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;
    ULONG Flags;

    Peb = NtCurrentPeb ();

    //
    // If the heap tracing was ever turned on then do the cleaning
    // stuff here.
    //

    if (USER_SHARED_DATA->TraceLogging){
        CleanOnThreadExit ();
    }

    RtlEnterCriticalSection (&LdrpLoaderLock);

    __try {

        //
        // Walk in the reverse direction of initialization order to build
        // the unload list.
        //

        Next = PebLdr.InInitializationOrderModuleList.Blink;

        while (Next != &PebLdr.InInitializationOrderModuleList) {

            LdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD (Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InInitializationOrderLinks));

            Next = Next->Blink;
            Flags = LdrDataTableEntry->Flags;

            //
            // Walk through the entire list looking for
            // entries. For each entry, that has an init
            // routine, call it.
            //

            if ((Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) &&
                (!(Flags & LDRP_DONT_CALL_FOR_THREADS)) &&
                (LdrDataTableEntry->EntryPoint != NULL) &&
                (Flags & LDRP_PROCESS_ATTACH_CALLED) &&
                (Flags & LDRP_IMAGE_DLL)) {

                InitRoutine = (PDLL_INIT_ROUTINE)(ULONG_PTR)LdrDataTableEntry->EntryPoint;
                LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);

                if (LdrDataTableEntry->TlsIndex) {
                    LdrpCallTlsInitializers (LdrDataTableEntry->DllBase,
                                             DLL_THREAD_DETACH);
                }

                LdrpCallInitRoutine (InitRoutine,
                                     LdrDataTableEntry->DllBase,
                                     DLL_THREAD_DETACH,
                                     NULL);

                LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
            }
        }

        //
        // If the image has TLS than call its initializers.
        //

        if (LdrpImageHasTls) {

            LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);

            LdrpCallTlsInitializers (Peb->ImageBaseAddress, DLL_THREAD_DETACH);

            LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
        }

        LdrpFreeTls ();

    } __finally {
        RtlLeaveCriticalSection (&LdrpLoaderLock);
    }
}


VOID
LdrpInitializeThread (
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called by each thread as it starts.
    Its purpose is to call all of the process' DLLs to notify them
    that the thread is starting up.

Arguments:

    Context - Context that will be restored after loader initializes.

Return Value:

    None.

--*/

{
    PPEB Peb;
    PLIST_ENTRY Next;
    PDLL_INIT_ROUTINE InitRoutine;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;

    UNREFERENCED_PARAMETER (Context);

    Peb = NtCurrentPeb ();

    if (LdrpShutdownInProgress) {
        return;
    }

    RtlEnterCriticalSection (&LdrpLoaderLock);

    __try {

        LdrpAllocateTls ();

        Next = PebLdr.InMemoryOrderModuleList.Flink;

        while (Next != &PebLdr.InMemoryOrderModuleList) {

            LdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)
            (CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));

            //
            // Walk through the entire list looking for
            // entries. For each entry, that has an init
            // routine, call it.
            //

            if ((Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) &&
                (!(LdrDataTableEntry->Flags & LDRP_DONT_CALL_FOR_THREADS))) {

                InitRoutine = (PDLL_INIT_ROUTINE)(ULONG_PTR)LdrDataTableEntry->EntryPoint;
                if ((InitRoutine) &&
                    (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) &&
                    (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL)) {

                    LDRP_ACTIVATE_ACTIVATION_CONTEXT (LdrDataTableEntry);

                    if (LdrDataTableEntry->TlsIndex) {
                        if (!LdrpShutdownInProgress) {
                            LdrpCallTlsInitializers (LdrDataTableEntry->DllBase,
                                                     DLL_THREAD_ATTACH);
                        }
                    }

                    if (!LdrpShutdownInProgress) {

                        LdrpCallInitRoutine (InitRoutine,
                                             LdrDataTableEntry->DllBase,
                                             DLL_THREAD_ATTACH,
                                             NULL);
                    }
                    LDRP_DEACTIVATE_ACTIVATION_CONTEXT ();
                }
            }
            Next = Next->Flink;
        }

        //
        // If the image has TLS than call its initializers.
        //

        if (LdrpImageHasTls && !LdrpShutdownInProgress) {

            LDRP_ACTIVATE_ACTIVATION_CONTEXT (LdrpImageEntry);

            LdrpCallTlsInitializers (Peb->ImageBaseAddress, DLL_THREAD_ATTACH);

            LDRP_DEACTIVATE_ACTIVATION_CONTEXT ();
        }

    } __finally {
        RtlLeaveCriticalSection (&LdrpLoaderLock);
    }
}


NTSTATUS
LdrpOpenImageFileOptionsKey (
    IN PCUNICODE_STRING ImagePathName,
    IN BOOLEAN Wow64Path,
    OUT PHANDLE KeyHandle
    )
{
    ULONG UnicodeStringLength, l;
    PWSTR pw;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath;
    WCHAR KeyPathBuffer[ DOS_MAX_COMPONENT_LENGTH + 100 ];
    PWCHAR p;
    PWCHAR BasePath;


    p = KeyPathBuffer;

#define STRTMP L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\"
#define STRTMP_WOW64 L"\\Registry\\Machine\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\"

    if (Wow64Path == TRUE) {
        BasePath = STRTMP_WOW64;
        l = sizeof (STRTMP_WOW64) - sizeof (WCHAR);
    } else {
        BasePath = STRTMP;
        l = sizeof (STRTMP) - sizeof (WCHAR);
    }

    if (l > sizeof (KeyPathBuffer)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory (p, BasePath, l);
    p += (l / sizeof (WCHAR));

    UnicodeStringLength = ImagePathName->Length;
    pw = (PWSTR)((PCHAR)ImagePathName->Buffer + UnicodeStringLength);

    while (UnicodeStringLength != 0) {
        if (pw[ -1 ] == OBJ_NAME_PATH_SEPARATOR) {
            break;
        }
        pw--;
        UnicodeStringLength -= sizeof( *pw );
    }

    UnicodeStringLength = ImagePathName->Length - UnicodeStringLength;

    l = l + UnicodeStringLength;
    if (l > sizeof (KeyPathBuffer)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory (p, pw, UnicodeStringLength);

    KeyPath.Buffer = KeyPathBuffer;
    KeyPath.Length = (USHORT) l;

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    return NtOpenKey (KeyHandle, GENERIC_READ, &ObjectAttributes);
}


NTSTATUS
LdrpQueryImageFileKeyOption (
    IN HANDLE KeyHandle,
    IN PCWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG KeyValueBuffer [256];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG AllocLength;
    ULONG ResultLength;
    HANDLE ProcessHeap = 0;

    Status = RtlInitUnicodeStringEx (&UnicodeString, OptionName);

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) &KeyValueBuffer[0];

    Status = NtQueryValueKey (KeyHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              sizeof (KeyValueBuffer),
                              &ResultLength);

    if (Status == STATUS_BUFFER_OVERFLOW) {

        //
        // This function can be called before the process heap gets created
        // therefore we need to protect against this case. The majority of the
        // code will not hit this code path because they read just strings
        // containing hex numbers and for this the size of KeyValueBuffer is
        // more than sufficient.
        //

        ProcessHeap = RtlProcessHeap ();
        if (!ProcessHeap) {
            return STATUS_NO_MEMORY;
        }

        AllocLength = sizeof (*KeyValueInformation) +
            KeyValueInformation->DataLength;

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap (ProcessHeap,
                                               MAKE_TAG (TEMP_TAG),
                                               AllocLength);

        if (KeyValueInformation == NULL) {
            return STATUS_NO_MEMORY;
        }

        Status = NtQueryValueKey (KeyHandle,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  AllocLength,
                                  &ResultLength);
    }

    if (NT_SUCCESS( Status )) {
        if (KeyValueInformation->Type == REG_BINARY) {
            if ((Buffer) && (KeyValueInformation->DataLength <= BufferSize)) {
                RtlCopyMemory (Buffer,
                               &KeyValueInformation->Data,
                               KeyValueInformation->DataLength);
            }
            else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
            if (ARGUMENT_PRESENT( ResultSize )) {
                *ResultSize = KeyValueInformation->DataLength;
            }
        }
        else if (KeyValueInformation->Type == REG_DWORD) {

            if (Type != REG_DWORD) {
                Status = STATUS_OBJECT_TYPE_MISMATCH;
            }
            else {
                if ((Buffer)
                    && (BufferSize == sizeof(ULONG))
                    && (KeyValueInformation->DataLength == BufferSize)) {

                    RtlCopyMemory (Buffer,
                                   &KeyValueInformation->Data,
                                   KeyValueInformation->DataLength);
                }
                else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }

                if (ARGUMENT_PRESENT( ResultSize )) {
                    *ResultSize = KeyValueInformation->DataLength;
                }
            }
        }
        else if (KeyValueInformation->Type != REG_SZ) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }
        else {
            if (Type == REG_DWORD) {
                if (BufferSize != sizeof( ULONG )) {
                    BufferSize = 0;
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    UnicodeString.Buffer = (PWSTR)&KeyValueInformation->Data;
                    UnicodeString.Length = (USHORT)
                        (KeyValueInformation->DataLength - sizeof( UNICODE_NULL ));
                    UnicodeString.MaximumLength = (USHORT)KeyValueInformation->DataLength;
                    Status = RtlUnicodeStringToInteger( &UnicodeString, 0, (PULONG)Buffer );
                }
            }
            else {
                if (KeyValueInformation->DataLength > BufferSize) {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                else {
                    BufferSize = KeyValueInformation->DataLength;
                }

                RtlCopyMemory (Buffer, &KeyValueInformation->Data, BufferSize);
            }

            if (ARGUMENT_PRESENT( ResultSize )) {
                *ResultSize = BufferSize;
            }
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_PARTIAL_INFORMATION) &KeyValueBuffer[0]) {
        RtlFreeHeap (ProcessHeap, 0, KeyValueInformation);
    }

    return Status;
}


NTSTATUS
LdrQueryImageFileExecutionOptionsEx(
    IN PCUNICODE_STRING ImagePathName,
    IN PCWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL,
    IN BOOLEAN Wow64Path 
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;

    Status = LdrpOpenImageFileOptionsKey (ImagePathName, Wow64Path, &KeyHandle);

    if (NT_SUCCESS (Status)) {

        Status = LdrpQueryImageFileKeyOption (KeyHandle,
                                              OptionName,
                                              Type,
                                              Buffer,
                                              BufferSize,
                                              ResultSize);

        NtClose (KeyHandle);
    }

    return Status;
}

NTSTATUS
LdrQueryImageFileExecutionOptions(
    IN PCUNICODE_STRING ImagePathName,
    IN PCWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    )

{
    return LdrQueryImageFileExecutionOptionsEx (
        ImagePathName,
        OptionName,
        Type,
        Buffer,
        BufferSize,
        ResultSize,
        FALSE
        );
}


NTSTATUS
LdrpInitializeTls (
    VOID
    )
{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    PIMAGE_TLS_DIRECTORY TlsImage;
    PLDRP_TLS_ENTRY TlsEntry;
    ULONG TlsSize;
    LOGICAL FirstTimeThru;
    HANDLE ProcessHeap;
            
    ProcessHeap = RtlProcessHeap();
    FirstTimeThru = TRUE;

    InitializeListHead (&LdrpTlsList);

    //
    // Walk through the loaded modules and look for TLS. If we find TLS,
    // lock in the module and add to the TLS chain.
    //

    Head = &PebLdr.InLoadOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
                           Entry->DllBase,
                           TRUE,
                           IMAGE_DIRECTORY_ENTRY_TLS,
                           &TlsSize);

        //
        // Mark whether or not the image file has TLS.
        //

        if (FirstTimeThru) {
            FirstTimeThru = FALSE;
            if (TlsImage && !LdrpImageHasTls) {
                RtlpSerializeHeap (ProcessHeap);
                LdrpImageHasTls = TRUE;
            }
        }

        if (TlsImage) {

            if (ShowSnaps) {
                DbgPrint( "LDR: Tls Found in %wZ at %p\n",
                            &Entry->BaseDllName,
                            TlsImage);
            }

            TlsEntry = (PLDRP_TLS_ENTRY)RtlAllocateHeap(ProcessHeap,MAKE_TAG( TLS_TAG ),sizeof(*TlsEntry));
            if ( !TlsEntry ) {
                return STATUS_NO_MEMORY;
            }

            //
            // Since this DLL has TLS, lock it in
            //

            Entry->LoadCount = (USHORT)0xffff;

            //
            // Mark this as having thread local storage
            //

            Entry->TlsIndex = (USHORT)0xffff;

            TlsEntry->Tls = *TlsImage;
            InsertTailList(&LdrpTlsList,&TlsEntry->Links);

            //
            // Update the index for this dll's thread local storage
            //


            *(PLONG)TlsEntry->Tls.AddressOfIndex = LdrpNumberOfTlsEntries;
            TlsEntry->Tls.Characteristics = LdrpNumberOfTlsEntries++;
        }
    }

    //
    // We now have walked through all static DLLs and know
    // all DLLs that reference thread local storage. Now we
    // just have to allocate the thread local storage for the current
    // thread and for all subsequent threads.
    //

    return LdrpAllocateTls ();
}


NTSTATUS
LdrpAllocateTls (
    VOID
    )
{
    PTEB Teb;
    PLIST_ENTRY Head, Next;
    PLDRP_TLS_ENTRY TlsEntry;
    PVOID *TlsVector;
    HANDLE ProcessHeap;

    //
    // Allocate the array of thread local storage pointers
    //

    if (LdrpNumberOfTlsEntries) {

        Teb = NtCurrentTeb();
        ProcessHeap = Teb->ProcessEnvironmentBlock->ProcessHeap;

        TlsVector = (PVOID *)RtlAllocateHeap(ProcessHeap,MAKE_TAG( TLS_TAG ),sizeof(PVOID)*LdrpNumberOfTlsEntries);

        if (!TlsVector) {
            return STATUS_NO_MEMORY;
        }
        //
        // NOTICE-2002/03/14-ELi
        // Zero out the new array of pointers, LdrpFreeTls frees the pointers
        // if the pointers are non-NULL
        //
        RtlZeroMemory( TlsVector, sizeof(PVOID)*LdrpNumberOfTlsEntries );

        Teb->ThreadLocalStoragePointer = TlsVector;
        Head = &LdrpTlsList;
        Next = Head->Flink;

        while (Next != Head) {
            TlsEntry = CONTAINING_RECORD(Next, LDRP_TLS_ENTRY, Links);
            Next = Next->Flink;
            TlsVector[TlsEntry->Tls.Characteristics] = RtlAllocateHeap(
                                                        ProcessHeap,
                                                        MAKE_TAG( TLS_TAG ),
                                                        TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
                                                        );
            if (!TlsVector[TlsEntry->Tls.Characteristics] ) {
                return STATUS_NO_MEMORY;
            }

            if (ShowSnaps) {
                DbgPrint("LDR: TlsVector %x Index %d = %x copied from %x to %x\n",
                    TlsVector,
                    TlsEntry->Tls.Characteristics,
                    &TlsVector[TlsEntry->Tls.Characteristics],
                    TlsEntry->Tls.StartAddressOfRawData,
                    TlsVector[TlsEntry->Tls.Characteristics]);
            }

            //
            // Do the TLS Callouts
            //

            RtlCopyMemory (
                TlsVector[TlsEntry->Tls.Characteristics],
                (PVOID)TlsEntry->Tls.StartAddressOfRawData,
                TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
            );
        }
    }
    return STATUS_SUCCESS;
}


VOID
LdrpFreeTls (
    VOID
    )
{
    PTEB Teb;
    PLIST_ENTRY Head, Next;
    PLDRP_TLS_ENTRY TlsEntry;
    PVOID *TlsVector;
    HANDLE ProcessHeap;

    Teb = NtCurrentTeb();

    TlsVector = Teb->ThreadLocalStoragePointer;

    if (TlsVector) {

        ProcessHeap = Teb->ProcessEnvironmentBlock->ProcessHeap;

        Head = &LdrpTlsList;
        Next = Head->Flink;

        while (Next != Head) {

            TlsEntry = CONTAINING_RECORD(Next, LDRP_TLS_ENTRY, Links);
            Next = Next->Flink;

            //
            // Do the TLS callouts
            //

            if (TlsVector[TlsEntry->Tls.Characteristics]) {

                RtlFreeHeap (ProcessHeap,
                             0,
                             TlsVector[TlsEntry->Tls.Characteristics]);
            }
        }

        RtlFreeHeap (ProcessHeap, 0, TlsVector);
    }
}


VOID
LdrpCallTlsInitializers (
    IN PVOID DllBase,
    IN ULONG Reason
    )
{
    PIMAGE_TLS_DIRECTORY TlsImage;
    ULONG TlsSize;
    PIMAGE_TLS_CALLBACK *CallBackArray;
    PIMAGE_TLS_CALLBACK InitRoutine;

    TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
                       DllBase,
                       TRUE,
                       IMAGE_DIRECTORY_ENTRY_TLS,
                       &TlsSize
                       );


    if (TlsImage) {

        try {
            CallBackArray = (PIMAGE_TLS_CALLBACK *)TlsImage->AddressOfCallBacks;
            if ( CallBackArray ) {
                if (ShowSnaps) {
                    DbgPrint( "LDR: Tls Callbacks Found. Imagebase %p Tls %p CallBacks %p\n",
                                DllBase,
                                TlsImage,
                                CallBackArray
                            );
                }

                while (*CallBackArray) {

                    InitRoutine = *CallBackArray++;

                    if (ShowSnaps) {
                        DbgPrint( "LDR: Calling Tls Callback Imagebase %p Function %p\n",
                                    DllBase,
                                    InitRoutine
                                );
                    }

                    LdrpCallInitRoutine((PDLL_INIT_ROUTINE)InitRoutine,
                                        DllBase,
                                        Reason,
                                        0);
                }
            }
        }

        except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - caught exception %08lx calling TLS callbacks\n",
                __FUNCTION__,
                GetExceptionCode());
        }
    }
}



ULONG
GetNextCommaValue (
    IN OUT WCHAR **p,
    IN OUT ULONG *len
    )
{
    ULONG Number;

    Number = 0;

    while (*len && (UNICODE_NULL != **p) && **p != L',') {

        //
        // Ignore spaces.
        //

        if ( L' ' != **p ) {
            Number = (Number * 10) + ( (ULONG)**p - L'0' );
        }

        (*p)++;
        (*len)--;
    }

    //
    // If we're at a comma, get past it for the next call
    //

    if ((*len) && (L',' == **p)) {
        (*p)++;
        (*len)--;
    }

    return Number;
}



VOID
LdrQueryApplicationCompatibilityGoo (
    IN PCUNICODE_STRING UnicodeImageName,
    IN BOOLEAN ImageFileOptionsPresent
    )

/*++

Routine Description:

    This function is called by LdrpInitialize after its initialized the
    process.  It's purpose is to query any application specific flags,
    hacks, etc.  If any app specific information is found, its hung off
    the PEB for other components to test against.

    Besides setting hanging the AppCompatInfo struct off the PEB, the
    only other action that will occur in here is setting OS version
    numbers in the PEB if the appropriate Version lie app flag is set.

Arguments:

    UnicodeImageName - Actual image name (including path)

Return Value:

    None.

--*/

{
    PPEB Peb;
    PVOID ResourceInfo;
    ULONG TotalGooLength;
    ULONG AppCompatLength;
    ULONG ResultSize;
    ULONG ResourceSize;
    ULONG InputCompareLength;
    ULONG OutputCompareLength;
    NTSTATUS st;
    LOGICAL ImageContainsVersionResourceInfo;
    ULONG_PTR IdPath[3];
    APP_COMPAT_GOO LocalAppCompatGoo;
    PAPP_COMPAT_GOO AppCompatGoo;
    PAPP_COMPAT_INFO AppCompatInfo;
    PAPP_VARIABLE_INFO AppVariableInfo;
    PPRE_APP_COMPAT_INFO AppCompatEntry;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    PEFFICIENTOSVERSIONINFOEXW OSVerInfo;
    UNICODE_STRING EnvValue;
    WCHAR *NewCSDString;
    WCHAR TempString[ 128 ];   // is the size of szCSDVersion in OSVERSIONINFOW
    LOGICAL fNewCSDVersionBuffer;
    HANDLE ProcessHeap;

    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode nul
    } *Resource;

    //
    // Check execution options to see if there's any Goo for this app.
    // We purposely feed a small struct to LdrQueryImageFileExecOptions,
    // so that it can come back with success/failure, and if success we see
    // how much we need to alloc.  As the results coming back will be of
    // variable length.
    //

    fNewCSDVersionBuffer = FALSE;
    Peb = NtCurrentPeb();
    Peb->AppCompatInfo = NULL;
    Peb->AppCompatFlags.QuadPart = 0;
    ProcessHeap = Peb->ProcessHeap;
    
    if (ImageFileOptionsPresent) {

        st = LdrQueryImageFileExecutionOptions (UnicodeImageName,
                                                L"ApplicationGoo",
                                                REG_BINARY,
                                                &LocalAppCompatGoo,
                                                sizeof(APP_COMPAT_GOO),
                                                &ResultSize);

        //
        // If there's an entry there, we're guaranteed to get overflow error.
        //

        if (st == STATUS_BUFFER_OVERFLOW) {

            //
            // Something is there, alloc memory for the "Pre" Goo struct
            // right now.
            //

            AppCompatGoo =
                RtlAllocateHeap(ProcessHeap, HEAP_ZERO_MEMORY, ResultSize);

            if (!AppCompatGoo) {
                return;
            }

            //
            // Now that we've got the memory, hit it again
            //
            st = LdrQueryImageFileExecutionOptions (UnicodeImageName,
                                                    L"ApplicationGoo",
                                                    REG_BINARY,
                                                    AppCompatGoo,
                                                    ResultSize,
                                                    &ResultSize);

            if (!NT_SUCCESS (st)) {
                RtlFreeHeap (ProcessHeap, 0, AppCompatGoo);
                return;
            }

            //
            // Got a hit on this key, however we don't know fer sure that its
            // an exact match.  There could be multiple App Compat entries
            // within this Goo.  So we get the version resource information out
            // of the Image hdr (if avail) and later we compare it against
            // all of the entries found within the Goo hoping for a match.
            //
            // Need Language Id in order to query the resource info.
            //

            ImageContainsVersionResourceInfo = FALSE;

            IdPath[0] = 16;                             // RT_VERSION
            IdPath[1] = 1;                              // VS_VERSION_INFO
            IdPath[2] = 0; // LangId;

            //
            // Search for version resource information
            //

            DataEntry = NULL;
            Resource = NULL;

            try {
                st = LdrpSearchResourceSection_U (Peb->ImageBaseAddress,
                                                  IdPath,
                                                  3,
                                                  0,
                                                  &DataEntry);

            } except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS( st )) {

                //
                // Give us a pointer to the resource information
                //
                try {
                    st = LdrpAccessResourceData(
                            Peb->ImageBaseAddress,
                            DataEntry,
                            &Resource,
                            &ResourceSize
                            );

                } except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS( st )) {
                    ImageContainsVersionResourceInfo = TRUE;
                }
            }

            //
            // Now that we either have (or have not) the version resource info,
            // bounce down each app compat entry looking for a match.  If there
            // wasn't any version resource info in the image hdr, it's going to
            // be an automatic match to an entry that also doesn't have
            // anything for its version resource info.  Obviously there can
            // be only one of these "empty" entries within the Goo (as the
            // first one will always be matched first).
            //

            st = STATUS_SUCCESS;
            AppCompatEntry = AppCompatGoo->AppCompatEntry;

            //
            // NTRAID#NTBUG9-550610-2002/02/21-DavidFie
            // Trusting registry data too much
            //

            TotalGooLength =
                AppCompatGoo->dwTotalGooSize - sizeof(AppCompatGoo->dwTotalGooSize);
            while (TotalGooLength) {

                ResourceInfo = NULL;
                InputCompareLength = 0;
                OutputCompareLength = 0;

                try {

                    //
                    // Compare what we're told to by the resource info size.
                    // The ResourceInfo (if avail) is directly behind the
                    // AppCompatEntry.
                    //

                    InputCompareLength = AppCompatEntry->dwResourceInfoSize;
                    ResourceInfo = AppCompatEntry + 1;

                    if (ImageContainsVersionResourceInfo) {

                        if (InputCompareLength > Resource->TotalSize) {
                            InputCompareLength = Resource->TotalSize;
                        }

                        OutputCompareLength = (ULONG) RtlCompareMemory(
                                                        ResourceInfo,
                                                        Resource,
                                                        InputCompareLength);
                    }
                    else {

                        //
                        // In this case, we don't have any version resource
                        // info in the image header, so set OutputCompareLength
                        // to zero.  If InputCompareLength was set to zero
                        // above due to the AppCompatEntry also having no
                        // version resource info, then the test will succeed
                        // (below) and we've found our match.  Otherwise,
                        // this is not the same app and it won't be a match.
                        //

                        ASSERT (OutputCompareLength == 0);
                    }


                } except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = STATUS_UNSUCCESSFUL;
                }

                if ((!NT_SUCCESS( st )) ||
                    (InputCompareLength != OutputCompareLength)) {

                    //
                    // Wasn't a match, go to the next entry.
                    //

                    //
                    // NTRAID#NTBUG9-550610-2002/02/21-DavidFie
                    // Trusting registry data too much
                    //

                    TotalGooLength -= AppCompatEntry->dwEntryTotalSize;

                    AppCompatEntry = (PPRE_APP_COMPAT_INFO) (
                      (PUCHAR)AppCompatEntry + AppCompatEntry->dwEntryTotalSize);
                    continue;
                }

                //
                // We're a match - now we have to create the final "Post"
                // app compat structure that will be used by everyone to follow.
                // This guy hangs off the Peb and it doesn't have the resource
                // info still lying around in there.
                //

                AppCompatLength = AppCompatEntry->dwEntryTotalSize;
                AppCompatLength -= AppCompatEntry->dwResourceInfoSize;
                Peb->AppCompatInfo =
                    RtlAllocateHeap(ProcessHeap, HEAP_ZERO_MEMORY, AppCompatLength);

                if (!Peb->AppCompatInfo) {
                    break;
                }

                AppCompatInfo = Peb->AppCompatInfo;
                AppCompatInfo->dwTotalSize = AppCompatLength;

                //
                // Copy what was beyond the resource info to near the top
                // starting at the Application compat flags.
                //

                RtlCopyMemory(
                    &AppCompatInfo->CompatibilityFlags,
                    (PUCHAR) ResourceInfo + AppCompatEntry->dwResourceInfoSize,
                    AppCompatInfo->dwTotalSize - FIELD_OFFSET(APP_COMPAT_INFO, CompatibilityFlags)
                    );

                //
                // Copy the flags into the PEB. Temporary until we remove
                // the compat goo altogether.
                //

                Peb->AppCompatFlags.QuadPart = AppCompatInfo->CompatibilityFlags.QuadPart;

                //
                // Now that we've created the "Post" app compat info struct
                // to be used by everyone, we need to check if version
                // lying for this app is requested.  If so, we need to
                // stuff the Peb right now.
                //

                if (AppCompatInfo->CompatibilityFlags.QuadPart & KACF_VERSIONLIE) {

                    //
                    // Find the variable version lie struct somewhere within.
                    //

                    if (LdrFindAppCompatVariableInfo (AVT_OSVERSIONINFO, &AppVariableInfo) != STATUS_SUCCESS) {
                        break;
                    }

                    //
                    // The variable length information itself comes at the end
                    // of the normal struct and could be of any arbitrary
                    // length.
                    //

                    AppVariableInfo += 1;
                    OSVerInfo = (PEFFICIENTOSVERSIONINFOEXW) AppVariableInfo;
                    Peb->OSMajorVersion = OSVerInfo->dwMajorVersion;
                    Peb->OSMinorVersion = OSVerInfo->dwMinorVersion;
                    Peb->OSBuildNumber = (USHORT) OSVerInfo->dwBuildNumber;
                    Peb->OSCSDVersion = (OSVerInfo->wServicePackMajor << 8) & 0xFF00;
                    Peb->OSCSDVersion |= OSVerInfo->wServicePackMinor;
                    Peb->OSPlatformId = OSVerInfo->dwPlatformId;

                    //
                    // NTRAID#NTBUG9-550610-2002/02/21-DavidFie
                    // Trusting registry data too much
                    //
                    Peb->CSDVersion.Length = (USHORT)wcslen(&OSVerInfo->szCSDVersion[0])*sizeof(WCHAR);
                    Peb->CSDVersion.MaximumLength = Peb->CSDVersion.Length + sizeof(WCHAR);
                    Peb->CSDVersion.Buffer = (PWSTR)RtlAllocateHeap (
                                                ProcessHeap,
                                                0,
                                                Peb->CSDVersion.MaximumLength);

                    if (!Peb->CSDVersion.Buffer) {
                        break;
                    }

                    RtlCopyMemory(Peb->CSDVersion.Buffer, &OSVerInfo->szCSDVersion[0], Peb->CSDVersion.Length);
                    RTL_STRING_NUL_TERMINATE(&Peb->CSDVersion);
                    fNewCSDVersionBuffer = TRUE;
                }

                break;
            }

            RtlFreeHeap (ProcessHeap, 0, AppCompatGoo);
        }
    }

    //
    // Only look at the ENV stuff if haven't already gotten new
    // version info from the registry
    //

    if (fNewCSDVersionBuffer == FALSE) {

        const static UNICODE_STRING COMPAT_VER_NN_String = RTL_CONSTANT_STRING(L"_COMPAT_VER_NNN");

        //
        // The format of this string is:
        // _COMPAT_VER_NNN = MajOSVer, MinOSVer, OSBldNum, MajCSD, MinCSD, PlatformID, CSDString
        //  eg:  _COMPAT_VER_NNN=4,0,1381,3,0,2,Service Pack 3
        //   (for NT 4 SP3)

        EnvValue.Buffer = TempString;
        EnvValue.Length = 0;
        EnvValue.MaximumLength = sizeof(TempString);

        st = RtlQueryEnvironmentVariable_U (NULL, &COMPAT_VER_NN_String, &EnvValue);

        //
        // One of the possible error codes is BUFFER_TOO_SMALL - this
        // indicates a string that's wacko - they should not be larger
        // than the size we define/expect.  In this case, we'll ignore
        // that string.
        //

        if (st == STATUS_SUCCESS) {

            PWCHAR p = EnvValue.Buffer;
            ULONG len = EnvValue.Length / sizeof(WCHAR);  // (Length is bytes, not chars)

            //
            // Ok, someone wants different version info.
            //
            Peb->OSMajorVersion = GetNextCommaValue( &p, &len );
            Peb->OSMinorVersion = GetNextCommaValue( &p, &len );
            Peb->OSBuildNumber = (USHORT)GetNextCommaValue( &p, &len );
            Peb->OSCSDVersion = (USHORT)(GetNextCommaValue( &p, &len )) << 8;
            Peb->OSCSDVersion |= (USHORT)GetNextCommaValue( &p, &len );
            Peb->OSPlatformId = GetNextCommaValue( &p, &len );

            //
            // Need to free the old buffer if there is one...
            //

            if (fNewCSDVersionBuffer) {
                RtlFreeHeap( ProcessHeap, 0, Peb->CSDVersion.Buffer );
                Peb->CSDVersion.Buffer = NULL;
            }

            if (len) {

                NewCSDString = (PWSTR)RtlAllocateHeap (ProcessHeap,
                                                0,
                                                (len + 1) * sizeof(WCHAR));

                if (NULL == NewCSDString) {
                    return;
                }

                //
                // Now copy the string to memory that we'll keep.
                //

                //
                // NOTICE-1999/07/07-berniem
                // We do a copy here rather than a string copy
                // because current comments in RtlQueryEnvironmentVariable()
                // indicate that in an edge case, we might not
                // have a trailing NULL
                //

                RtlCopyMemory (NewCSDString, p, len * sizeof(WCHAR));
                NewCSDString[len] = 0;
            }
            else {
                NewCSDString = NULL;
            }

            RtlInitUnicodeString (&Peb->CSDVersion, NewCSDString);
        }
    }

    return;
}


NTSTATUS
LdrFindAppCompatVariableInfo (
    IN  ULONG dwTypeSeeking,
    OUT PAPP_VARIABLE_INFO *AppVariableInfo
    )

/*++

Routine Description:

    This function is used to find a variable length struct by its type.
    The caller specifies what type its looking for and this function chews
    thru all the variable length structs to find it.  If it does it returns
    the pointer and TRUE, else FALSE.

Arguments:

    dwTypeSeeking - AVT that you are looking for

    AppVariableInfo - pointer to pointer of variable info to be returned

Return Value:

    NTSTATUS.

--*/

{
    PPEB Peb;
    ULONG TotalSize;
    ULONG CurOffset;
    PAPP_VARIABLE_INFO pCurrentEntry;

    Peb = NtCurrentPeb();

    if (Peb->AppCompatInfo) {

        //
        // Since we're not dealing with a fixed-size structure, TotalSize
        // will keep us from running off the end of the data list.
        //

        TotalSize = ((PAPP_COMPAT_INFO) Peb->AppCompatInfo)->dwTotalSize;

        //
        // The first variable structure (if there is one) will start
        // immediately after the fixed stuff
        //

        CurOffset = sizeof(APP_COMPAT_INFO);

        while (CurOffset < TotalSize) {

            pCurrentEntry = (PAPP_VARIABLE_INFO) ((PUCHAR)(Peb->AppCompatInfo) + CurOffset);

            //
            // Have we found what we're looking for?
            //
            if (dwTypeSeeking == pCurrentEntry->dwVariableType) {
                *AppVariableInfo = pCurrentEntry;
                return STATUS_SUCCESS;
            }

            //
            // Let's go look at the next blob
            //

            CurOffset += (ULONG)(pCurrentEntry->dwVariableInfoSize);
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
LdrpCorValidateImage (
    IN OUT PVOID *pImageBase,
    IN LPWSTR ImageName
    )
{
    NTSTATUS st;
    UNICODE_STRING SystemRoot;
    UNICODE_STRING MscoreePath;
    WCHAR PathBuffer [ 128 ];

    //
    // Load %windir%\system32\mscoree.dll and hold onto it until all COM+ images are unloaded.
    //

    MscoreePath.Buffer = PathBuffer;
    MscoreePath.Length = 0;
    MscoreePath.MaximumLength = sizeof (PathBuffer);

    RtlInitUnicodeString (&SystemRoot, USER_SHARED_DATA->NtSystemRoot);

    st = RtlAppendUnicodeStringToString (&MscoreePath, &SystemRoot);
    if (NT_SUCCESS (st)) {
        st = RtlAppendUnicodeStringToString (&MscoreePath, &SlashSystem32SlashMscoreeDllString);

        if (NT_SUCCESS (st)) {
            st = LdrLoadDll (NULL, NULL, &MscoreePath, &Cor20DllHandle);
        }
    }

    if (!NT_SUCCESS (st)) {
        if (ShowSnaps) {
            DbgPrint("LDR: failed to load mscoree.dll, status=%x\n", st);
        }
        return st;
    }

    if (CorImageCount == 0) {

        SIZE_T i;
        const static LDRP_PROCEDURE_NAME_ADDRESS_PAIR CorProcedures[] = {
            { RTL_CONSTANT_STRING("_CorValidateImage"), (PVOID *)&CorValidateImage },
            { RTL_CONSTANT_STRING("_CorImageUnloading"), (PVOID *)&CorImageUnloading },
            { RTL_CONSTANT_STRING("_CorExeMain"), (PVOID *)&CorExeMain }
        };
        for ( i = 0 ; i != RTL_NUMBER_OF(CorProcedures) ; ++i ) {
            st = LdrGetProcedureAddress (Cor20DllHandle,
                                         &CorProcedures[i].Name,
                                         0,
                                         CorProcedures[i].Address
                                        );
            if (!NT_SUCCESS (st)) {
                LdrUnloadDll (Cor20DllHandle);
                return st;
            }
        }
    }

    //
    // Call mscoree to validate the image.
    //

    st = (*CorValidateImage) (pImageBase, ImageName);

    if (NT_SUCCESS(st)) {

        //
        // Success - bump the count of valid COM+ images.
        //

        CorImageCount += 1;

    } else if (CorImageCount == 0) {

        //
        // Failure, and no other COM+ images are loaded, so unload mscoree.
        //

        LdrUnloadDll (Cor20DllHandle);
    }

    return st;
}


VOID
LdrpCorUnloadImage (
    IN PVOID ImageBase
    )
{
    //
    // Notify mscoree that the image is about be unmapped.
    //

    (*CorImageUnloading) (ImageBase);

    if (--CorImageCount) {

        //
        // The count of loaded COM+ images is zero, so unload mscoree.
        //

        LdrUnloadDll (Cor20DllHandle);
    }
}


VOID
LdrpInitializeApplicationVerifierPackage (
    PCUNICODE_STRING UnicodeImageName,
    PPEB Peb,
    BOOLEAN EnabledSystemWide,
    BOOLEAN OptionsKeyPresent
    )
{
    ULONG SavedPageHeapFlags;
    NTSTATUS Status;
    extern ULONG AVrfpVerifierFlags;

    //
    // If we are in safe boot mode we ignore all verification
    // options.
    //

    if (USER_SHARED_DATA->SafeBootMode) {

        Peb->NtGlobalFlag &= ~FLG_APPLICATION_VERIFIER;
        Peb->NtGlobalFlag &= ~FLG_HEAP_PAGE_ALLOCS;

        return;
    }

    //
    // Call into the verifier proper.
    //

    //
    // FUTURE-2002/04/02-SilviuC
    // in time (soon) all should migrate in there.
    //

    if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

        //
        // If application verifier is enabled force creation of stack trace
        // database. It is something really nice to have around for debugging
        // critical sections issues or heap issues.
        //

        LdrpShouldCreateStackTraceDb = TRUE;

        AVrfInitializeVerifier (EnabledSystemWide,
                                UnicodeImageName,
                                0);
    }

    //
    // Note that if application verifier is on, this automatically enables
    // page heap.
    //

    if ((Peb->NtGlobalFlag & FLG_HEAP_PAGE_ALLOCS)) {

        //
        // We will enable page heap (RtlpDebugPageHeap) only after
        // all other initializations for page heap are finished.
        //
        // No matter if the user mode stack trace database flag is set
        // or not we will create the database. Page heap is so often
        // used with +ust flag (traces) that it makes sense to tie
        // them together.
        //

        LdrpShouldCreateStackTraceDb = TRUE;

        //
        // If page heap is enabled we need to disable any flag that
        // might force creation of debug heaps for normal NT heaps.
        // This is due to a dependency between page heap and NT heap
        // where the page heap within PageHeapCreate tries to create
        // a normal NT heap to accomodate some of the allocations.
        // If we do not disable these flags we will get an infinite
        // recursion between RtlpDebugPageHeapCreate and RtlCreateHeap.
        //

        Peb->NtGlobalFlag &=
            ~( FLG_HEAP_ENABLE_TAGGING      |
               FLG_HEAP_ENABLE_TAG_BY_DLL   |
               FLG_HEAP_ENABLE_TAIL_CHECK   |
               FLG_HEAP_ENABLE_FREE_CHECK   |
               FLG_HEAP_VALIDATE_PARAMETERS |
               FLG_HEAP_VALIDATE_ALL        |
               FLG_USER_STACK_TRACE_DB      );

        //
        // Read page heap per process global flags. If we fail
        // to read a value, the default ones are kept.
        //

        SavedPageHeapFlags = RtlpDphGlobalFlags;
        RtlpDphGlobalFlags = 0xFFFFFFFF;

        if (OptionsKeyPresent) {

            Status = LdrQueryImageFileExecutionOptions(
                                              UnicodeImageName,
                                              L"PageHeapFlags",
                                              REG_DWORD,
                                              &RtlpDphGlobalFlags,
                                              sizeof(RtlpDphGlobalFlags),
                                              NULL);

            if (!NT_SUCCESS(Status)) {
                RtlpDphGlobalFlags = 0xFFFFFFFF;
            }
        }

        //
        // If app_verifier flag is on and there are no special settings for
        // page heap then we will use full page heap with stack trace collection.
        //

        if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

            if (RtlpDphGlobalFlags == 0xFFFFFFFF) {

                //
                // We did not pick up new settings from registry.
                //

                RtlpDphGlobalFlags = SavedPageHeapFlags;
            }
        }
        else {

            //
            // Restore page heap options if we did not pick up new
            // settings from registry.
            //

            if (RtlpDphGlobalFlags == 0xFFFFFFFF) {

                RtlpDphGlobalFlags = SavedPageHeapFlags;
            }
        }

        //
        // If page heap is enabled and we have an image options key
        // read more page heap parameters.
        //

        if (OptionsKeyPresent) {

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapSizeRangeStart",
                REG_DWORD,
                &RtlpDphSizeRangeStart,
                sizeof(RtlpDphSizeRangeStart),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapSizeRangeEnd",
                REG_DWORD,
                &RtlpDphSizeRangeEnd,
                sizeof(RtlpDphSizeRangeEnd),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapRandomProbability",
                REG_DWORD,
                &RtlpDphRandomProbability,
                sizeof(RtlpDphRandomProbability),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapFaultProbability",
                REG_DWORD,
                &RtlpDphFaultProbability,
                sizeof(RtlpDphFaultProbability),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapFaultTimeOut",
                REG_DWORD,
                &RtlpDphFaultTimeOut,
                sizeof(RtlpDphFaultTimeOut),
                NULL
                );

            //
            // The two values below should be read as PVOIDs so that
            // this works on 64-bit architetures. However since this
            // feature relies on good stack traces and since we can get
            // reliable stack traces only on X86 architectures we will
            // leave it as it is.
            //

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapDllRangeStart",
                REG_DWORD,
                &RtlpDphDllRangeStart,
                sizeof(RtlpDphDllRangeStart),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapDllRangeEnd",
                REG_DWORD,
                &RtlpDphDllRangeEnd,
                sizeof(RtlpDphDllRangeEnd),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapTargetDlls",
                REG_SZ,
                &RtlpDphTargetDlls,
                512*sizeof(WCHAR),
                NULL
                );

        }

        //
        // Per dll page heap option is not supported if fast fill heap is enabled.
        //

        if ((RtlpDphGlobalFlags & PAGE_HEAP_USE_DLL_NAMES) &&
            (AVrfpVerifierFlags & RTL_VRF_FLG_FAST_FILL_HEAP)) {

            DbgPrint ("AVRF: per dll page heap option disabled because fast fill heap is enabled. \n");
            RtlpDphGlobalFlags &= ~PAGE_HEAP_USE_DLL_NAMES;
        }

        //
        //  Turn on BOOLEAN RtlpDebugPageHeap to indicate that
        //  new heaps should be created with debug page heap manager
        //  when possible.
        //

        RtlpDebugPageHeap = TRUE;
    }
}


NTSTATUS
LdrpTouchThreadStack (
    IN SIZE_T EnforcedStackCommit
    )
/*++

Routine description:

    This routine is called if precommitted stacks are enforced for the process.
    It will determine how much stack needs to be touched (therefore committed)
    and then it will touch it. For any kind of error (e.g. stack overflow for
    out of memory conditions it will return STATUS_NO_MEMORY.

Parameters:

    EnforcedStackCommit - Supplies the amount of committed stack that should
                          be enforced for the main thread. This value can be
                          decreased in reality if it goes over the virtual
                          region reserved for the stack. It is not worth
                          taking care of this special case because it will
                          require either switching the stack or support in
                          the target process for detecting the enforced
                          stack commit requirement. The image can always be
                          changed to have a bigger stack reserve.

Return value:

    STATUS_SUCCESS if the stack was successfully touched and STATUS_NO_MEMORY
    otherwise.

--*/
{
    ULONG_PTR TouchAddress;
    ULONG_PTR TouchLimit;
    ULONG_PTR LowStackLimit;
    ULONG_PTR HighStackLimit;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    SIZE_T ReturnLength;
    PTEB   Teb;

    Teb = NtCurrentTeb();

    Status = NtQueryVirtualMemory (NtCurrentProcess(),
                                   Teb->NtTib.StackLimit,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof MemoryInformation,
                                   &ReturnLength);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    LowStackLimit = (ULONG_PTR)(MemoryInformation.AllocationBase);
    LowStackLimit += 3 * PAGE_SIZE;

    HighStackLimit = (ULONG_PTR)(Teb->NtTib.StackBase);
    TouchAddress =  HighStackLimit - PAGE_SIZE;

    if (TouchAddress > EnforcedStackCommit) {

        if (TouchAddress - EnforcedStackCommit > LowStackLimit) {
            TouchLimit = TouchAddress - EnforcedStackCommit;
        }
        else {
            TouchLimit = LowStackLimit;
        }
    }
    else {
        TouchLimit = LowStackLimit;
    }

    try {

        while (TouchAddress >= TouchLimit) {

            *((volatile UCHAR * const) TouchAddress);
            TouchAddress -= PAGE_SIZE;
        }
    }
    except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
        //
        // If we get a stack overflow we will report it as no memory.
        //

        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
LdrpInitializeExecutionOptions (
    IN PCUNICODE_STRING UnicodeImageName,
    IN PPEB Peb
    )
/*++

Routine description:

    This routine reads the `image file execution options' key for the
    current process and interprets all the values under the key.

Parameters:



Return value:

    True if there is a registry key for this process.

--*/
{
    NTSTATUS st;
    BOOLEAN ImageFileOptionsPresent;
    HANDLE KeyHandle;

    ImageFileOptionsPresent = FALSE;

    //
    // Open the "Image File Execution Options" key for this program.
    //

    st = LdrpOpenImageFileOptionsKey (UnicodeImageName, FALSE, &KeyHandle);

    if (NT_SUCCESS(st)) {

        //
        // We have image file execution options for this process
        //

        ImageFileOptionsPresent = TRUE;

        //
        //  Hack for NT4 SP4.  So we don't overload another GlobalFlag
        //  bit that we have to be "compatible" with for NT5, look for
        //  another value named "DisableHeapLookaside".
        //

        LdrpQueryImageFileKeyOption (KeyHandle,
                                     L"DisableHeapLookaside",
                                     REG_DWORD,
                                     &RtlpDisableHeapLookaside,
                                     sizeof( RtlpDisableHeapLookaside ),
                                     NULL);

        //
        // Verification options during process shutdown (heap leaks, etc.).
        //

        LdrpQueryImageFileKeyOption (KeyHandle,
                                     L"ShutdownFlags",
                                     REG_DWORD,
                                     &RtlpShutdownProcessFlags,
                                     sizeof( RtlpShutdownProcessFlags ),
                                     NULL);

        //
        // Check if there is a minimal stack commit enforced
        // for this image. This will affect all threads but the
        // one executing this code (initial thread).
        //

        {
            DWORD MinimumStackCommitInBytes = 0;

            LdrpQueryImageFileKeyOption (KeyHandle,
                                         L"MinimumStackCommitInBytes",
                                         REG_DWORD,
                                         &MinimumStackCommitInBytes,
                                         sizeof( MinimumStackCommitInBytes ),
                                         NULL);

            if (Peb->MinimumStackCommit < (SIZE_T)MinimumStackCommitInBytes) {
                Peb->MinimumStackCommit = (SIZE_T)MinimumStackCommitInBytes;
            }
        }

        
        //
        // Check if ExecuteOptions is specified for this image. If yes
        // we will transfer the options into the PEB. Later we will
        // make sure the stack region has exactly the protection
        // requested.
        // There is no need to initialize this field at this as Wow64 
        // already done that. We only update it if there is a value set in
        // there.
        //

        {
            ULONG ExecuteOptions = 0;
            NTSTATUS NtStatus;

            NtStatus = LdrpQueryImageFileKeyOption (KeyHandle,
                                                    L"ExecuteOptions",
                                                    REG_DWORD,
                                                    &(ExecuteOptions),
                                                    sizeof (ExecuteOptions),
                                                    NULL);

#if defined(BUILD_WOW6432)
            if (NT_SUCCESS (NtStatus)) {
#endif
                Peb->ExecuteOptions = ExecuteOptions & (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA);
#if defined(BUILD_WOW6432)
            }
#endif
        }


        //
        // Pickup the global_flags value from registry
        //

        {
            BOOLEAN EnabledSystemWide = FALSE;
            ULONG ProcessFlags;

            if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
                EnabledSystemWide = TRUE;
            }

            st = LdrpQueryImageFileKeyOption (KeyHandle,
                                              L"GlobalFlag",
                                              REG_DWORD,
                                              &ProcessFlags,
                                              sizeof( Peb->NtGlobalFlag ),
                                              NULL);

            //
            // If we read a global value whatever is in there will
            // take precedence over the systemwide settings. Only if no
            // value is read the systemwide setting will kick in.
            //

            if (NT_SUCCESS(st)) {
                Peb->NtGlobalFlag = ProcessFlags;
            }

            //
            // If pageheap or appverifier is enabled we need to initialize the
            // verifier package.
            //

            if ((Peb->NtGlobalFlag & (FLG_APPLICATION_VERIFIER | FLG_HEAP_PAGE_ALLOCS))) {

                LdrpInitializeApplicationVerifierPackage (UnicodeImageName,
                                                          Peb,
                                                          EnabledSystemWide,
                                                          TRUE);
            }
        }

        {
            const static struct {
                PCWSTR Name;
                PBOOLEAN Variable;
            } Options[] = {
                { L"ShowRecursiveDllLoads", &LdrpShowRecursiveDllLoads },
                { L"BreakOnRecursiveDllLoads", &LdrpBreakOnRecursiveDllLoads },
                { L"ShowLoaderErrors", &ShowErrors },
                { L"BreakOnInitializeProcessFailure", &g_LdrBreakOnLdrpInitializeProcessFailure },
                { L"KeepActivationContextsAlive", &g_SxsKeepActivationContextsAlive },
                { L"TrackActivationContextReleases", &g_SxsTrackReleaseStacks },
            };
            SIZE_T i;
            ULONG Temp;

            for (i = 0 ; i != RTL_NUMBER_OF(Options) ; ++i) {
                Temp = 0;
                LdrpQueryImageFileKeyOption (KeyHandle, Options[i].Name, REG_DWORD, &Temp, sizeof(Temp), NULL);
                if (Temp != 0) {
                    *Options[i].Variable = TRUE;
                }
                else {
                    *Options[i].Variable = FALSE;
                }
            }

            // This is an actual ULONG that we're reading, but we don't want to set it unless
            // it's there - it starts out at the right magic value.
            Temp = 0;
            LdrpQueryImageFileKeyOption(
                KeyHandle, 
                L"MaxDeadActivationContexts", 
                REG_DWORD, 
                &Temp, 
                sizeof(Temp),
                NULL);

            if (Temp != 0) {
                g_SxsMaxDeadActivationContexts = Temp;
            }
        }

        NtClose(KeyHandle);
    }
    else {

        //
        // We do not have image file execution options for this process.
        //
        // If pageheap or appverifier is enabled system-wide we will enable
        // them with default settings and ignore the options used when
        // running process under debugger. If these are not set and process
        // runs under debugger we will enable a few extra things (e.g.
        // debug heap).
        //

        if ((Peb->NtGlobalFlag & (FLG_APPLICATION_VERIFIER | FLG_HEAP_PAGE_ALLOCS))) {

            LdrpInitializeApplicationVerifierPackage (UnicodeImageName,
                                                      Peb,
                                                      TRUE,
                                                      FALSE);
        }
        else {

            if (Peb->BeingDebugged) {

                const static UNICODE_STRING DebugVarName = RTL_CONSTANT_STRING(L"_NO_DEBUG_HEAP");
                UNICODE_STRING DebugVarValue;
                WCHAR TempString[ 16 ];
                LOGICAL UseDebugHeap = TRUE;

                DebugVarValue.Buffer = TempString;
                DebugVarValue.Length = 0;
                DebugVarValue.MaximumLength = sizeof(TempString);

                //
                //  The PebLockRoutine is not initialized at this point
                //  We need to pass the explicit environment block.
                //

                st = RtlQueryEnvironmentVariable_U (Peb->ProcessParameters->Environment,
                                                    &DebugVarName,
                                                    &DebugVarValue);

                if (NT_SUCCESS(st)) {

                    ULONG ULongValue;

                    st = RtlUnicodeStringToInteger (&DebugVarValue, 0, &ULongValue);

                    if (NT_SUCCESS(st) && ULongValue) {

                        UseDebugHeap = FALSE;
                    }
                }

                if (UseDebugHeap) {

                    Peb->NtGlobalFlag |= FLG_HEAP_ENABLE_FREE_CHECK |
                                         FLG_HEAP_ENABLE_TAIL_CHECK |
                                         FLG_HEAP_VALIDATE_PARAMETERS;
                }
            }
        }
    }

    return ImageFileOptionsPresent;
}


NTSTATUS
LdrpEnforceExecuteForCurrentThreadStack (
    VOID
    )

/*++

Routine description:

    This routine is called if execute rights must be granted for the
    current thread's stack. It will determine the committed area of the
    stack and add execute flag. It will also examine the rights for the
    guard page on top of the stack. The reserved portion of the stack does
    not need to be changed because once MEM_EXECUTE_OPTION_STACK is enabled
    in the PEB the memory manager will take care of OR-ing the execute flag
    for every new commit.

    The function is also called if we have DATA execution but we do not want
    STACK execution. In this case  by default (due to DATA) any committed
    area gets execute right and we want to revert this for stack areas.

    Note. Even if the process has data execution set the stack might not have
    the correct settings because the stack sometimes is allocated in a different
    process (this is the case for the first thread of a process and for remote
    threads).

Parameters:

    None.

Return value:

    STATUS_SUCCESS if we successfully changed execute rights.

--*/

{
    MEMORY_BASIC_INFORMATION MemoryInformation;
    NTSTATUS Status;
    SIZE_T Length;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG StackProtect;
    ULONG OldProtect;
    ULONG ExecuteOptions;
    PTEB Teb;

    Teb = NtCurrentTeb();

    ExecuteOptions = Teb->ProcessEnvironmentBlock->ExecuteOptions;
    ExecuteOptions &= (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA);
    ASSERT (ExecuteOptions != 0);

    if (ExecuteOptions & MEM_EXECUTE_OPTION_STACK) {

        //
        // Data = X and Stack = 1: we need to set EXECUTE bit on the stack
        // Even if Data = 1 we cannot be sure the stack has the right
        // protection because it could have been allocated in a different
        // process.
        //

        StackProtect = PAGE_EXECUTE_READWRITE;
    }
    else {

        //
        // Data = 1 and Stack = 0: we need to reset EXECUTE bit on the stack.
        // Again it might be that Data is one but the stack does not have
        // execution rights if this was a cross-process allocation.
        //

        StackProtect = PAGE_READWRITE;
        ASSERT ((ExecuteOptions & MEM_EXECUTE_OPTION_DATA) != 0);
    }

    //
    // Set the protection for the committed portion of the stack. Note
    // that we cannot query the region and conclude there is nothing to do
    // if execute bit is set for the bottom page of the stack (the one near
    // the guard page) because the stack at this stage can have two regions:
    // an upper one created by a parent process (this will not have execute bit
    // set) and a lower portion that was created due to stack extensions (this
    // one will have execute bit set). Therefore we will move directly to setting
    // the new desired protection.
    //

    Address = (ULONG_PTR)(Teb->NtTib.StackLimit);
    Size = (ULONG_PTR)(Teb->NtTib.StackBase) - (ULONG_PTR)(Teb->NtTib.StackLimit);

    Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                     (PVOID)&Address,
                                     &Size,
                                     StackProtect,
                                     &OldProtect);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Check protection for the guard page of the stack. If the
    // protection is correct we will avoid a more expensive protect() call.
    //

    Address = Address - PAGE_SIZE;

    Status = NtQueryVirtualMemory (NtCurrentProcess(),
                                   (PVOID)Address,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof MemoryInformation,
                                   &Length);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    ASSERT (MemoryInformation.AllocationBase == Teb->DeallocationStack);
    ASSERT (MemoryInformation.BaseAddress == (PVOID)Address);
    ASSERT ((MemoryInformation.Protect & PAGE_GUARD) != 0);

    if (MemoryInformation.Protect != (StackProtect | PAGE_GUARD)) {

        //
        // Set the proper protection flags for the guard page of the stack.
        //

        Size = PAGE_SIZE;
        ASSERT (MemoryInformation.RegionSize == Size);

        Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                         (PVOID)&Address,
                                         &Size,
                                         StackProtect | PAGE_GUARD,
                                         &OldProtect);

        if (! NT_SUCCESS(Status)) {
            return Status;
        }

        ASSERT (OldProtect == MemoryInformation.Protect);
    }

    return STATUS_SUCCESS;
}

#include <ntverp.h>
const ULONG NtMajorVersion = VER_PRODUCTMAJORVERSION;
const ULONG NtMinorVersion = VER_PRODUCTMINORVERSION;
#if DBG
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xC0000000; // C for "checked"
#else
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xF0000000; // F for "free"
#endif


VOID 
RtlGetNtVersionNumbers(
    PULONG pNtMajorVersion,
    PULONG pNtMinorVersion,
    PULONG pNtBuildNumber
    )
/*++

Routine description:

    This routine will return the real OS build number, major and minor version
    as compiled.  It's used by code that needs to get a real version number
    that can't be easily spoofed.
        
Parameters:

    pNtMajorVersion - Pointer to ULONG that will hold major version.
    pNtMinorVersion - Pointer to ULONG that will hold minor version.
    pNtBuildNumber  - Pointer to ULONG that will hold the build number (with 'C' or 'F' in high nibble to indicate free/checked)
        
Return value:

    None

--*/
{
    if (pNtMajorVersion) {
        *pNtMajorVersion = NtMajorVersion;
    }
    if (pNtMinorVersion) {
        *pNtMinorVersion = NtMinorVersion;
    }
    if (pNtBuildNumber) {
        *pNtBuildNumber  = NtBuildNumber;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\importtablehash.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ImportTableHash.c

Abstract:

    This module contains hash computation routine 
    RtlComputeImportTableHash to compute the hash 
    based on the import table of an exe.

Author:

    Vishnu Patankar (VishnuP) 31-May-2001

Revision History:

--*/

#include "ImportTableHash.h"

NTSTATUS
RtlComputeImportTableHash(
    IN  HANDLE hFile,
    IN  PCHAR Hash,
    IN  ULONG ImportTableHashRevision
    )
/*++

Routine Description:

    This routine computes the limited MD5 hash.
    
    First, the image is memory mapped and a canonical 
    sorted list of module name and function name is created
    from the exe's import table.
    
    Second, the hash value is computed using the canonical
    information.
    
Arguments:

    hFile       -   the handle of the file to compute the hash for
    
    Hash        -   the hash value returned - this has to be atleast 16 bytes long
    
    ImportTableHashRevision -   the revision of the computation method for compatibility
                                only ITH_REVISION_1 is supported today

Return Value:

    The status of the hash computation.

--*/
{
    PIMPORTTABLEP_SORTED_LIST_ENTRY ListEntry = NULL;
    PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList = NULL;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY FunctionListEntry;
    
    ULONG ImportDescriptorSize = 0;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    LPVOID FileMapping = NULL;
    PIMAGE_THUNK_DATA OriginalFirstThunk;
    PIMAGE_IMPORT_BY_NAME AddressOfData;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ACCESS_MASK DesiredAccess;
    ULONG AllocationAttributes;
    DWORD flProtect = PAGE_READONLY;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    
    NTSTATUS    Status = STATUS_SUCCESS;

    if ( ITH_REVISION_1 != ImportTableHashRevision ) {
        Status = STATUS_UNKNOWN_REVISION;
        goto ExitHandler;
    }

    //
    // Unwrap CreateFileMappingW (since that API is not available in ntdll.dll)
    //

    DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ;
    AllocationAttributes = flProtect & (SEC_FILE | SEC_IMAGE | SEC_RESERVE | SEC_COMMIT | SEC_NOCACHE);
    flProtect ^= AllocationAttributes;

    if (AllocationAttributes == 0) {
        AllocationAttributes = SEC_COMMIT;        
    }

    Status = NtCreateSection(
                &hMap,
                DesiredAccess,
                NULL,
                NULL,
                flProtect,
                AllocationAttributes,
                hFile
                );

    if ( hMap == INVALID_HANDLE_VALUE || !NT_SUCCESS(Status) ) {

        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    


    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
        
    Status = NtMapViewOfSection(
                hMap,
                NtCurrentProcess(),
                &FileMapping,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READONLY
                );

    NtClose(hMap);

    if (FileMapping == NULL || !NT_SUCCESS(Status) ) {

        Status = STATUS_NOT_MAPPED_VIEW;
        goto ExitHandler;
    }

    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData (
                                                                              FileMapping,
                                                                              FALSE,
                                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                                              &ImportDescriptorSize
                                                                              );

    if (ImportDescriptor == NULL) {

        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        goto ExitHandler;
    }

    //
    // outer loop that iterates over all modules in the import table of the exe
    //

    while (ImportDescriptor && ImportDescriptor->Name != 0 && ImportDescriptor->FirstThunk != 0) {

        PSZ ImportName = (PSZ)RtlAddressInSectionTable(
                                                      RtlImageNtHeader(FileMapping),
                                                      FileMapping,
                                                      ImportDescriptor->Name
                                                      );

        if ( ImportName == NULL ) {

            Status = STATUS_RESOURCE_NAME_NOT_FOUND;
            goto ExitHandler;
        }


        ListEntry = (PIMPORTTABLEP_SORTED_LIST_ENTRY)RtlAllocateHeap(RtlProcessHeap(), 0, sizeof( IMPORTTABLEP_SORTED_LIST_ENTRY ));

        if ( ListEntry == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto ExitHandler;

        }

        ListEntry->String       = ImportName;
        ListEntry->FunctionList = NULL;
        ListEntry->Next         = NULL;

        ImportTablepInsertModuleSorted( ListEntry, &ImportedNameList );

        OriginalFirstThunk = (PIMAGE_THUNK_DATA)RtlAddressInSectionTable(
                                                                        RtlImageNtHeader(FileMapping),
                                                                        FileMapping,
                                                                        ImportDescriptor->OriginalFirstThunk
                                                                        );

        //
        // inner loop that iterates over all functions for a given module
        //
        
        while (OriginalFirstThunk && OriginalFirstThunk->u1.Ordinal) {

            if (!IMAGE_SNAP_BY_ORDINAL( OriginalFirstThunk->u1.Ordinal)) {

                AddressOfData = (PIMAGE_IMPORT_BY_NAME)RtlAddressInSectionTable(
                                                                               RtlImageNtHeader(FileMapping),
                                                                               FileMapping,
                                                                               (ULONG)OriginalFirstThunk->u1.AddressOfData
                                                                               );

                if ( AddressOfData == NULL || AddressOfData->Name == NULL ) {

                    Status = STATUS_RESOURCE_NAME_NOT_FOUND;
                    goto ExitHandler;

                }

                FunctionListEntry = (PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY)RtlAllocateHeap(RtlProcessHeap(), 0, sizeof( IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY ));
                
                if (FunctionListEntry == NULL ) {

                    Status = STATUS_NO_MEMORY;
                    goto ExitHandler;
                }


                FunctionListEntry->Next   = NULL;
                FunctionListEntry->String = (PSZ)AddressOfData->Name;

                ImportTablepInsertFunctionSorted( FunctionListEntry, &ListEntry->FunctionList );
            }

            OriginalFirstThunk++;
        }


        ImportDescriptor++;
    }

    //
    // finally hash the canonical information (sorted module and sorted function list)
    //

    Status = ImportTablepHashCanonicalLists( ImportedNameList, (PBYTE) Hash );

ExitHandler:

    ImportTablepFreeModuleSorted( ImportedNameList );

    if (FileMapping) {

        NTSTATUS    StatusUnmap;
        //
        // unwrap UnmapViewOfFile (since that API is not available in ntdll.dll)
        //

        StatusUnmap = NtUnmapViewOfSection(NtCurrentProcess(),(PVOID)FileMapping);

        if ( !NT_SUCCESS(StatusUnmap) ) {
            if (StatusUnmap == STATUS_INVALID_PAGE_PROTECTION) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache((PVOID)FileMapping, 0)) {
                    StatusUnmap = NtUnmapViewOfSection(NtCurrentProcess(),
                                                  (PVOID)FileMapping
                                                 );

                }

            }

        }

    }

    return Status;
}


VOID
ImportTablepInsertFunctionSorted(
    IN  PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY   pFunctionName,
    OUT PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY * ppFunctionNameList
    )
/*++

Routine Description:

    This routine inserts a function name in a sorted order.

Arguments:

    pFunctionName       -   name of the function
    
    ppFunctionNameList  -   pointer to the head of the function list to be updated

Return Value:

    None:

--*/
{

    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pPrev;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pTemp;

    //
    // Special case, list is empty, insert at the front.
    //
    
    if (*ppFunctionNameList == NULL
           || _stricmp((*ppFunctionNameList)->String, pFunctionName->String) > 0) {

        pFunctionName->Next = *ppFunctionNameList;
        *ppFunctionNameList = pFunctionName;
        return;
    }

    pPrev = *ppFunctionNameList;
    pTemp = (*ppFunctionNameList)->Next;

    while (pTemp) {

        if (_stricmp(pTemp->String, pFunctionName->String) >= 0) {
            pFunctionName->Next = pTemp;
            pPrev->Next = pFunctionName;
            return;
        }

        pPrev = pTemp;
        pTemp = pTemp->Next;
    }

    pFunctionName->Next = NULL;
    pPrev->Next = pFunctionName;

    return;

}

VOID
ImportTablepInsertModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY   pImportName,
    OUT PIMPORTTABLEP_SORTED_LIST_ENTRY * ppImportNameList
    )
/*++

Routine Description:

    This routine inserts a module name (dll) in a sorted order.

Arguments:

    pImportName         -   the import name that needs to be inserted
       
    ppImportNameList    -   pointer to the head of the list to be updated

Return Value:

    None:

--*/
{

    PIMPORTTABLEP_SORTED_LIST_ENTRY pPrev;
    PIMPORTTABLEP_SORTED_LIST_ENTRY pTemp;
    
    //
    // Special case, list is empty, insert at the front.
    //
    
    if (*ppImportNameList == NULL
           || _stricmp((*ppImportNameList)->String, pImportName->String) > 0) {

        pImportName->Next = *ppImportNameList;
        *ppImportNameList = pImportName;
        return;
    }

    pPrev = *ppImportNameList;
    pTemp = (*ppImportNameList)->Next;

    while (pTemp) {

        if (_stricmp(pTemp->String, pImportName->String) >= 0) {
            pImportName->Next = pTemp;
            pPrev->Next = pImportName;
            return;
        }

        pPrev = pTemp;
        pTemp = pTemp->Next;
    }

    pImportName->Next = NULL;
    pPrev->Next = pImportName;

    return;
}

static HANDLE AdvApi32ModuleHandle = (HANDLE) (ULONG_PTR) -1;

NTSTATUS
ImportTablepHashCanonicalLists( 
    IN  PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList, 
    OUT PBYTE Hash
    )

/*++

Routine Description:

    This routine computes the hash values from a given import list. 
    
    advapi32.dll is dynamically loaded - once only per process,
    and the md5 APIs are used to compute the hash value.

Arguments:

    ImportedNameList    -   the head of the module name/function name list
    
    Hash                -   the buffer to use to fill in the hash value

Return Value:

    STATUS_SUCCESS if the hash value is calculated, otherwise the error status

--*/                                                                          

{

    NTSTATUS Status = STATUS_SUCCESS;
    PIMPORTTABLEP_SORTED_LIST_ENTRY pTemp;
    
    MD5_CTX md5ctx;
    
    typedef VOID (RSA32API *MD5Init) (
				     MD5_CTX *
                                     );

    typedef VOID (RSA32API *MD5Update) (
                                       MD5_CTX *, 
                                       const unsigned char *, 
                                       unsigned int
                                       );

    typedef VOID (RSA32API *MD5Final) (                                              
                                      MD5_CTX *
                                      );

    const static UNICODE_STRING ModuleName =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");

    const static ANSI_STRING ProcedureNameMD5Init =
        RTL_CONSTANT_STRING("MD5Init");
         
    const static ANSI_STRING ProcedureNameMD5Update =
        RTL_CONSTANT_STRING("MD5Update");
    
    const static ANSI_STRING ProcedureNameMD5Final =
        RTL_CONSTANT_STRING("MD5Final");

    static MD5Init      lpfnMD5Init;
    static MD5Update    lpfnMD5Update;
    static MD5Final     lpfnMD5Final;

    if (AdvApi32ModuleHandle == NULL) {
        
        //
        // We tried to load ADVAPI32.DLL once before, but failed.
        //
        
        return STATUS_ENTRYPOINT_NOT_FOUND;
    }

    if (AdvApi32ModuleHandle == LongToHandle(-1)) {
        
        HANDLE TempModuleHandle;
        
        //
        // Load advapi32.dll for MD5 functions.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi.
        //

        {
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            
            Status = LdrLoadDll(NULL,
                                &DllCharacteristics,
                                &ModuleName,
                                &TempModuleHandle);
            
            if (!NT_SUCCESS(Status)) {
                AdvApi32ModuleHandle = NULL;
                return STATUS_DLL_NOT_FOUND;
            }
        }

        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameMD5Init,
                                       0,
                                       (PVOID*)&lpfnMD5Init);

        if (!NT_SUCCESS(Status) || !lpfnMD5Init) {
            //
            // Couldn't get the fn ptr. Make sure we won't try again
            //
AdvapiLoadFailure:
            LdrUnloadDll(TempModuleHandle);
            AdvApi32ModuleHandle = NULL;
            return STATUS_ENTRYPOINT_NOT_FOUND;
        }

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameMD5Update,
                                       0,
                                       (PVOID*)&lpfnMD5Update);

        if (!NT_SUCCESS(Status) || !lpfnMD5Update) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameMD5Final,
                                       0,
                                       (PVOID*)&lpfnMD5Final);

        if (!NT_SUCCESS(Status) || !lpfnMD5Final) {
            goto AdvapiLoadFailure;
        }

        AdvApi32ModuleHandle = TempModuleHandle;
    }

    ASSERT(lpfnMD5Init != NULL);

    lpfnMD5Init(&md5ctx);

    //
    // Loop though all of the module names and function names and create a hash
    //

    pTemp = ImportedNameList;

    //
    // loop through each module
    //

    while (pTemp != NULL) {

        PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pTemp2 = pTemp->FunctionList;

        ASSERT(lpfnMD5Update != NULL);

        lpfnMD5Update(&md5ctx, 
                      (LPBYTE) pTemp->String, 
                      (ULONG) strlen( pTemp->String ) 
                     );

        //
        // loop through each function
        //
        
        while (pTemp2 != NULL) {

            ASSERT(lpfnMD5Update != NULL);
            
            lpfnMD5Update(&md5ctx, 
                          (LPBYTE) pTemp2->String, 
                          (ULONG) strlen( pTemp2->String ) 
                          );
         
            pTemp2 = pTemp2->Next;

        }

        pTemp = pTemp->Next;

    }

    ASSERT(lpfnMD5Final != NULL);

    lpfnMD5Final( &md5ctx );

    //
    // Copy the hash to the user's buffer.
    //
        
    RtlCopyMemory(Hash, &md5ctx.digest[0], IMPORT_TABLE_MAX_HASH_SIZE);

    return Status;

}

VOID
ImportTablepFreeModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY pImportNameList
    )
/*++

Routine Description:

    This routine frees the entire module/function list.

Arguments:

    pImportNameList -   head of the two level singly linked list

Return Value:
    
    None:

--*/
{
    PIMPORTTABLEP_SORTED_LIST_ENTRY pToFree, pTemp;

    if ( !pImportNameList ) {
        return;
    }

    pToFree = pImportNameList;
    pTemp = pToFree->Next;

    while ( pToFree ) {

        ImportTablepFreeFunctionSorted( pToFree->FunctionList );
            
        RtlFreeHeap(RtlProcessHeap(), 0, pToFree);

        pToFree = pTemp;

        if ( pTemp ) {
            pTemp = pTemp->Next;
        }

    }

    return;

}

VOID
ImportTablepFreeFunctionSorted(
    IN PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pFunctionNameList
    )
/*++

Routine Description:

    This routine frees function list.

Arguments:

    pFunctionNameList -   head of function name list

Return Value:
    
    None:

--*/
{
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pToFree, pTemp;

    if ( !pFunctionNameList ) {
        return;
    }

    pToFree = pFunctionNameList;
    pTemp = pToFree->Next;

    while ( pToFree ) {
            
        RtlFreeHeap(RtlProcessHeap(), 0, pToFree);

        pToFree = pTemp;

        if ( pTemp ) {
            pTemp = pTemp->Next;
        }

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\makefile.inc ===
$(O)\sxsactctxcpp.obj : ..\sxsactctx.c
$(O)\sxsctxactcpp.obj : ..\sxsctxact.c
$(O)\sxsctxsrchcpp.obj : ..\sxsctxsrch.c
$(O)\sxsquerycpp.obj : ..\sxsquery.c
$(O)\sxsstoragecpp.obj : ..\sxsstorage.c
$(O)\sxsstoragemapcpp.obj : ..\sxsstoragemap.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\memstm.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    memstm.c

Abstract:

    This modules implements IStream over a block of memory.

Author:

    Jay Krell (JayKrell) June 2000

Revision History:

--*/

#define RTL_DECLARE_STREAMS 1
#define RTL_DECLARE_MEMORY_STREAM 1

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objidl.h"
#include "ntrtlmmapio.h"

#define RTLP_MEMORY_STREAM_NOT_IMPL(x) \
  ASSERT(MemoryStream != NULL); \
  KdPrintEx((DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "NTDLL: %s() E_NOTIMPL", __FUNCTION__)); \
  return E_NOTIMPL;

#if !defined(RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS)
  #if defined(RTLP_HRESULT_FROM_STATUS)
    #define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) RTLP_HRESULT_FROM_STATUS(x)
  #else
    #define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosErrorNoTeb(x))
    //#define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosError(x))
    //#define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x)   HRESULT_FROM_NT(x)
  #endif
#endif

const static RTL_STREAM_VTABLE_TEMPLATE(RTL_MEMORY_STREAM_WITH_VTABLE)
MemoryStreamVTable =
{
    RtlQueryInterfaceMemoryStream,
    RtlAddRefMemoryStream,
    RtlReleaseMemoryStream,
    RtlReadMemoryStream,
    RtlWriteMemoryStream,
    RtlSeekMemoryStream,
    RtlSetMemoryStreamSize,
    RtlCopyMemoryStreamTo,
    RtlCommitMemoryStream,
    RtlRevertMemoryStream,
    RtlLockMemoryStreamRegion,
    RtlUnlockMemoryStreamRegion,
    RtlStatMemoryStream,
    RtlCloneMemoryStream
};

const static RTL_STREAM_VTABLE_TEMPLATE(RTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE)
OutOfProcessMemoryStreamVTable =
{
    RtlQueryInterfaceOutOfProcessMemoryStream,
    RtlAddRefOutOfProcessMemoryStream,
    RtlReleaseOutOfProcessMemoryStream,
    RtlReadOutOfProcessMemoryStream,
    RtlWriteOutOfProcessMemoryStream,
    RtlSeekOutOfProcessMemoryStream,
    RtlSetOutOfProcessMemoryStreamSize,
    RtlCopyOutOfProcessMemoryStreamTo,
    RtlCommitOutOfProcessMemoryStream,
    RtlRevertOutOfProcessMemoryStream,
    RtlLockOutOfProcessMemoryStreamRegion,
    RtlUnlockOutOfProcessMemoryStreamRegion,
    RtlStatOutOfProcessMemoryStream,
    RtlCloneOutOfProcessMemoryStream
};

VOID
STDMETHODCALLTYPE
RtlInitOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    ASSERT(MemoryStream != NULL);
    RtlZeroMemory(&MemoryStream->Data, sizeof(MemoryStream->Data));
    MemoryStream->Data.FinalRelease = RtlFinalReleaseOutOfProcessMemoryStream;
    MemoryStream->StreamVTable = (const IStreamVtbl*)&OutOfProcessMemoryStreamVTable;
}

VOID
STDMETHODCALLTYPE
RtlFinalReleaseOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(MemoryStream != NULL);
    if (MemoryStream->Data.Process != NULL) {
        Status = NtClose(MemoryStream->Data.Process);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status));
        MemoryStream->Data.Process = NULL;
    }
}

VOID
STDMETHODCALLTYPE
RtlInitMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    ASSERT(MemoryStream != NULL);
    RtlZeroMemory(&MemoryStream->Data, sizeof(MemoryStream->Data));
    MemoryStream->StreamVTable = (const IStreamVtbl*)&MemoryStreamVTable;
}

ULONG
STDMETHODCALLTYPE
RtlAddRefMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    LONG ReferenceCount;

    ASSERT(MemoryStream != NULL);

    ReferenceCount = InterlockedIncrement(&MemoryStream->Data.ReferenceCount);
    return ReferenceCount;
}

ULONG
STDMETHODCALLTYPE
RtlReleaseMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    LONG ReferenceCount;
    ASSERT(MemoryStream != NULL);

    ReferenceCount = InterlockedDecrement(&MemoryStream->Data.ReferenceCount);
    if (ReferenceCount == 0 && MemoryStream->Data.FinalRelease != NULL) {
        MemoryStream->Data.FinalRelease(MemoryStream);
    }
    return ReferenceCount;
}

HRESULT
STDMETHODCALLTYPE
RtlQueryInterfaceMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    const IID*                     Interface,
    PVOID*                         Object
    )
{
    ASSERT(MemoryStream != NULL);
    ASSERT(Interface != NULL);
    ASSERT(Object != NULL);

    if (IsEqualGUID(Interface, &IID_IUnknown)
        || IsEqualGUID(Interface, &IID_IStream)
        || IsEqualGUID(Interface, &IID_ISequentialStream)
        )
    {
        InterlockedIncrement(&MemoryStream->Data.ReferenceCount);
        *Object = (IStream*)(&MemoryStream->StreamVTable);
        return NOERROR;
    }
    return E_NOINTERFACE;
}

HRESULT
STDMETHODCALLTYPE
RtlReadOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    PVOID              Buffer,
    ULONG              BytesToRead,
    ULONG*             BytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT Hr = NOERROR;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);
    SIZE_T NumberOfBytesReadSizeT = 0;

    ASSERT(MemoryStream != NULL);

    if (BytesRemaining < BytesToRead) {
        BytesToRead = (ULONG)BytesRemaining;
    }
    Status = NtReadVirtualMemory(
        MemoryStream->Data.Process,
        MemoryStream->Data.Current,
        Buffer,
        BytesToRead,
        &NumberOfBytesReadSizeT);
    if (Status == STATUS_PARTIAL_COPY) {
        Status = STATUS_SUCCESS;
        }
    if (!NT_SUCCESS(Status)) {
        Hr = RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(Status);
        goto Exit;
    }
    MemoryStream->Data.Current += NumberOfBytesReadSizeT;
    *BytesRead = (ULONG)NumberOfBytesReadSizeT;
Exit:
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlReadMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    PVOID              Buffer,
    ULONG              BytesToRead,
    ULONG*             BytesRead
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    HRESULT Hr = NOERROR;
    NTSTATUS Status = STATUS_SUCCESS;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);

    // this is so the compiler doesn't give a bogus warning about using
    // an uninitialized local
    ExceptionRecord.ExceptionCode = 0;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionInformation[RTL_IN_PAGE_ERROR_EXCEPTION_INFO_UNDERLYING_STATUS_INDEX] = 0;

    ASSERT(MemoryStream != NULL);
    ASSERT(MemoryStream->Data.End >= MemoryStream->Data.Current);

    if (BytesRemaining < BytesToRead) {
        BytesToRead = (ULONG)BytesRemaining;
    }

    Status = RtlCopyMappedMemory(Buffer, MemoryStream->Data.Current, BytesToRead);

    //
    // We could find how many bytes were successfully copied and return STATUS_PARTIAL_COPY,
    // but it does not seem worthwhile.
    //

    if (NT_SUCCESS(Status)) {
        MemoryStream->Data.Current += BytesToRead;
        *BytesRead = BytesToRead;
    } else {
        Hr = RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(Status);
        *BytesRead = 0;
    }
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlWriteMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    const VOID*      Buffer,
    ULONG            BytesToWrite,
    ULONG*           BytesWritten
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (Buffer);
    UNREFERENCED_PARAMETER (BytesToWrite);
    UNREFERENCED_PARAMETER (BytesWritten);

    RTLP_MEMORY_STREAM_NOT_IMPL(Write);
}

HRESULT
STDMETHODCALLTYPE
RtlSeekMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    LARGE_INTEGER      Distance,
    DWORD              Origin,
    ULARGE_INTEGER*    NewPosition
    )
{
    HRESULT Hr = NOERROR;
    PUCHAR  NewPointer;

    ASSERT(MemoryStream != NULL);

    //
    // "It is not, however, an error to seek past the end of the stream.
    // Seeking past the end of the stream is useful for subsequent write
    // operations, as the stream will at that time be extended to the seek
    // position immediately before the write is done."
    //
    // As long as we don't allow writing, we are not going to allow this.
    //

    switch (Origin) {
    case STREAM_SEEK_SET:
        NewPointer = MemoryStream->Data.Begin + Distance.QuadPart;
        break;
    case STREAM_SEEK_CUR:
        NewPointer = MemoryStream->Data.Current + Distance.QuadPart;
        break;
    case STREAM_SEEK_END:
        NewPointer = MemoryStream->Data.End - Distance.QuadPart;
        break;
    default:
        Hr = STG_E_INVALIDFUNCTION;
        goto Exit;
    }
   
    if (NewPointer < MemoryStream->Data.Begin || NewPointer > MemoryStream->Data.End) {
        Hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    MemoryStream->Data.Current = NewPointer;
    NewPosition->QuadPart = NewPointer - MemoryStream->Data.Begin;
    Hr = NOERROR;
Exit:
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlSetMemoryStreamSize(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     NewSize
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (NewSize);

    RTLP_MEMORY_STREAM_NOT_IMPL(SetSize);
}

HRESULT
STDMETHODCALLTYPE
RtlCopyOutOfProcessMemoryStreamTo(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream*           AnotherStream,
    ULARGE_INTEGER     NumberOfBytesToCopyLargeInteger,
    ULARGE_INTEGER*    NumberOfBytesRead,
    ULARGE_INTEGER*    NumberOfBytesWrittenLargeInteger
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (AnotherStream);
    UNREFERENCED_PARAMETER (NumberOfBytesToCopyLargeInteger);
    UNREFERENCED_PARAMETER (NumberOfBytesRead);
    UNREFERENCED_PARAMETER (NumberOfBytesWrittenLargeInteger);

    RTLP_MEMORY_STREAM_NOT_IMPL(CopyTo);
}
 
HRESULT
STDMETHODCALLTYPE
RtlCopyMemoryStreamTo(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream*           AnotherStream,
    ULARGE_INTEGER     NumberOfBytesToCopyLargeInteger,
    ULARGE_INTEGER*    NumberOfBytesRead,
    ULARGE_INTEGER*    NumberOfBytesWrittenLargeInteger
    )
{
    HRESULT Hr = NOERROR;
    ULONG  NumberOfBytesToCopyUlong = 0;
    ULONG  NumberOfBytesWrittenUlong = 0;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);

    ASSERT(MemoryStream != NULL);

    if (NumberOfBytesToCopyLargeInteger.HighPart != 0) {
        NumberOfBytesToCopyUlong = MAXULONG;
    } else {
        NumberOfBytesToCopyUlong = (ULONG)NumberOfBytesToCopyLargeInteger.QuadPart;
    }

    if (BytesRemaining < NumberOfBytesToCopyUlong) {
        NumberOfBytesToCopyUlong = (ULONG)BytesRemaining;
    }

    Hr = AnotherStream->lpVtbl->Write(AnotherStream, MemoryStream->Data.Current, NumberOfBytesToCopyUlong, &NumberOfBytesWrittenUlong);
    if (FAILED(Hr)) {
        NumberOfBytesRead->QuadPart = 0;
        NumberOfBytesWrittenLargeInteger->QuadPart = 0;
    } else {
        NumberOfBytesRead->QuadPart = NumberOfBytesWrittenUlong;
        NumberOfBytesWrittenLargeInteger->QuadPart = NumberOfBytesWrittenUlong;
    }
    Hr = NOERROR;
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlCommitMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULONG              Flags
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (Flags);

    RTLP_MEMORY_STREAM_NOT_IMPL(Commit);
}

HRESULT
STDMETHODCALLTYPE
RtlRevertMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds

    RTLP_MEMORY_STREAM_NOT_IMPL(Revert);
}

HRESULT
STDMETHODCALLTYPE
RtlLockMemoryStreamRegion(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     Offset,
    ULARGE_INTEGER     NumberOfBytes,
    ULONG              LockType
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (Offset);
    UNREFERENCED_PARAMETER (NumberOfBytes);
    UNREFERENCED_PARAMETER (LockType);

    RTLP_MEMORY_STREAM_NOT_IMPL(LockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlUnlockMemoryStreamRegion(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     Offset,
    ULARGE_INTEGER     NumberOfBytes,
    ULONG              LockType
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (Offset);
    UNREFERENCED_PARAMETER (NumberOfBytes);
    UNREFERENCED_PARAMETER (LockType);

    RTLP_MEMORY_STREAM_NOT_IMPL(UnlockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlStatMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    STATSTG*           StatusInformation,
    ULONG              Flags
    )
{
    HRESULT hr = NOERROR;

    ASSERT(MemoryStream != NULL);

    if (StatusInformation == NULL) {
        hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    if (Flags != STATFLAG_NONAME) {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    //
    // This struct is defined in objidl.h.
    //
    StatusInformation->pwcsName = NULL;
    StatusInformation->type = STGTY_STREAM;
    StatusInformation->cbSize.QuadPart = ((ULONG_PTR) MemoryStream->Data.End) - ((ULONG_PTR) MemoryStream->Data.Begin);
    StatusInformation->mtime.dwLowDateTime = 0;
    StatusInformation->mtime.dwHighDateTime = 0;
    StatusInformation->ctime.dwLowDateTime = 0;
    StatusInformation->ctime.dwHighDateTime = 0;
    StatusInformation->atime.dwLowDateTime = 0;
    StatusInformation->atime.dwHighDateTime = 0;
    StatusInformation->grfMode = STGM_READ;
    StatusInformation->grfLocksSupported = 0;
    StatusInformation->clsid = CLSID_NULL;
    StatusInformation->grfStateBits = 0;
    StatusInformation->reserved = 0;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
STDMETHODCALLTYPE
RtlCloneMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream**          NewStream
    )
{
    UNREFERENCED_PARAMETER (MemoryStream);      // on free builds
    UNREFERENCED_PARAMETER (NewStream);

    RTLP_MEMORY_STREAM_NOT_IMPL(Clone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ntdllp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntdllp.h

Abstract:

    Private definitions for ntdll.

Author:

    Michael J. Grier (mgrier) 6/30/2000

Revision History:

--*/

#ifndef _NTDLLP_
#define _NTDLLP_

#pragma once

#if defined(__cplusplus)
extern "C" {
#endif


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#include <sxstypes.h>
#include <ntrtlpath.h>

VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    ULONG Reason,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA Data,
    PVOID Context
    );

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    HANDLE KeyHandle,
    PCUNICODE_STRING SubKeyName,
    PUNICODE_STRING Root
    );

VOID
RtlpCheckRelativeDrive(
    WCHAR NewDrive
    );

ULONG
RtlIsDosDeviceName_Ustr(
    IN PCUNICODE_STRING DosFileName
    );

ULONG
RtlGetFullPathName_Ustr(
    PCUNICODE_STRING FileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType
    );

NTSTATUS
RtlGetFullPathName_UstrEx(
    PCUNICODE_STRING FileName,
    PUNICODE_STRING StaticString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    SIZE_T *FilePartPrefixCch OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType,
    OUT SIZE_T *BytesRequired OPTIONAL
    );

BOOLEAN
RtlDosPathNameToNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    IN PVOID Reserved // Must be NULL
    );

BOOLEAN
RtlDosPathNameToRelativeNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    );

BOOLEAN
RtlDoesFileExists_UStr(
    IN PCUNICODE_STRING FileName
    );

BOOLEAN
RtlDoesFileExists_UstrEx(
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN TreatDeniedOrSharingAsHit
    );

ULONG
RtlpComputeBackupIndex(
    IN PCURDIR CurDir
    );

ULONG
RtlGetLongestNtPathLength(
    VOID
    );

VOID
RtlpResetDriveEnvironment(
    IN WCHAR DriveLetter
    );

VOID
RtlpValidateCurrentDirectory(
    PCURDIR CurDir
    );

NTSTATUS
RtlpCheckDeviceName(
    PCUNICODE_STRING DevName,
    ULONG DeviceNameOffset,
    BOOLEAN* NameInvalid
    );

NTSTATUS
RtlpWin32NTNameToNtPathName_U(
    IN PCUNICODE_STRING DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    );

#define RTLP_GOOD_DOS_ROOT_PATH                                            0
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX                              1 /* \\?\ */
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX                          2 /* \\?\unc */
#define RTLP_BAD_DOS_ROOT_PATH_NT_PATH                                     3 /* \??\, this is only rough */
#define RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE                            4 /* \\machine or \\?\unc\machine */

CONST CHAR*
RtlpDbgBadDosRootPathTypeToString(
    IN ULONG     Flags,
    IN ULONG     RootType
    );

NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  RootString,
    OUT ULONG*           RootType
    );

NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    );

#define RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD (0x00000010)

//
// This bit means to do extra validation on \\? paths, to reject \\?\a\b,
// To only allow \\? followed by the documented forms \\?\unc\foo and \\?\c:
//
#define RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT (0x00000020)

#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_TYPE_MASK                    (0x0000000F)

//
// These bits add more information to RtlPathTypeUncAbsolute, which is what \\?
// is reported as.
//

//
// The path starts "\\?".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT                 (0x00000010)

//
// The path starts "\\?\x:".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE  (0x00000020)

//
// The path starts "\\?\unc".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_ABSOLUTE    (0x00000040)

//
//future this would indicate \\machine instead of \\machine\share
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_MACHINE_ONLY (0x00000080)
//future this would indicate \\ or \\?\unc
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_EMPTY        (0x00000100)
//

//
// So far, this means something like \\?\a was seen, instead of \\?\unc or \\?\a:
// You have to request it with RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT.
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID       (0x00000200)

//
// stuff like \\ \\? \\?\unc \\?\unc\
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INCOMPLETE_ROOT (0x00000400)

NTSTATUS
NTAPI
RtlpDetermineDosPathNameType4(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    );

#define RTLP_IMPLIES(x,y) ((x) ? (y) : TRUE)

extern RTL_CRITICAL_SECTION FastPebLock;

#define RtlAcquirePebLock() ((VOID)RtlEnterCriticalSection (&FastPebLock))

#define RtlReleasePebLock() ((VOID)RtlLeaveCriticalSection (&FastPebLock))

#if defined(__cplusplus)
}
#endif

#endif // _NTDLLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ntdll.inc ===
!if defined(BUILD_CHECKED_KERNEL)
NTDEBUG=ntsd
FREEBUILD=0
!endif

!include $(PROJECT_ROOT)\prerelease.inc

# No overflow checking for ntdll.dll
BUFFER_OVERFLOW_CHECKS=0

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ntdll_data.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntdll_data.c

Abstract:

    data previously defined in ldrp.h

Author:

    Jay Krell (Jaykrell) March 2002

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ldrp.h"

HANDLE LdrpKnownDllObjectDirectory;
WCHAR LdrpKnownDllPathBuffer[LDRP_MAX_KNOWN_PATH];
UNICODE_STRING LdrpKnownDllPath;
LIST_ENTRY LdrpHashTable[LDRP_HASH_TABLE_SIZE];
LIST_ENTRY RtlpCalloutEntryList;
RTL_CRITICAL_SECTION RtlpCalloutEntryLock;
LIST_ENTRY LdrpDllNotificationList;

#if DBG
ULONG LdrpCompareCount;
ULONG LdrpSnapBypass;
ULONG LdrpNormalSnap;
ULONG LdrpSectionOpens;
ULONG LdrpSectionCreates;
ULONG LdrpSectionMaps;
ULONG LdrpSectionRelocates;
BOOLEAN LdrpDisplayLoadTime;
LARGE_INTEGER BeginTime, InitcTime, InitbTime, IniteTime, EndTime, ElapsedTime, Interval;
#endif // DBG

BOOLEAN RtlpTimoutDisable;
LARGE_INTEGER RtlpTimeout;
ULONG NtGlobalFlag;
LIST_ENTRY RtlCriticalSectionList;
RTL_CRITICAL_SECTION RtlCriticalSectionLock;
BOOLEAN LdrpShutdownInProgress;
PLDR_DATA_TABLE_ENTRY LdrpImageEntry;
LIST_ENTRY LdrpUnloadHead;
BOOLEAN LdrpActiveUnloadCount;
PLDR_DATA_TABLE_ENTRY LdrpGetModuleHandleCache;
PLDR_DATA_TABLE_ENTRY LdrpLoadedDllHandleCache;
ULONG LdrpFatalHardErrorCount;
UNICODE_STRING LdrpDefaultPath;
RTL_CRITICAL_SECTION FastPebLock;
HANDLE LdrpShutdownThreadId;
ULONG LdrpNumberOfProcessors;

LIST_ENTRY LdrpTlsList;
ULONG LdrpNumberOfTlsEntries;

PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION Kernel32ProcessInitPostImportFunction;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrutil.c

Abstract:

    This module implements utility functions used by the NT loader (forked
    from ldrsnap.c).

Author:

    Michael Grier (MGrier) 04-Apr-2001, derived mostly from
        Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

--*/

#include "ldrp.h"
#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpsapi.h>
#include <heap.h>
#include "sxstypes.h"
#include <limits.h>

#define DLL_EXTENSION L".DLL"
#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"

#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)

BOOLEAN LdrpBreakOnExceptions = FALSE;


PLDR_DATA_TABLE_ENTRY
LdrpAllocateDataTableEntry (
    IN PVOID DllBase
    )

/*++

Routine Description:

    This function allocates a new loader data table entry.

Arguments:

    DllBase - Supplies the address of the base of the DLL image
              to be added to the loader data table.

Return Value:

    Returns the address of the allocated loader data table entry.

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader (DllBase);

    if (NtHeaders) {

        Entry = RtlAllocateHeap (LdrpHeap,
                                 MAKE_TAG( LDR_TAG ) | HEAP_ZERO_MEMORY,
                                 sizeof(*Entry));

        if (Entry) {
            Entry->DllBase = DllBase;
            Entry->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
            Entry->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
            Entry->PatchInformation = NULL;
            return Entry;
        }
    }

    return NULL;
}


VOID
LdrpFinalizeAndDeallocateDataTableEntry (
    IN PLDR_DATA_TABLE_ENTRY Entry
    )
{
    ASSERT (Entry != NULL);

    if ((Entry->EntryPointActivationContext != NULL) &&
        (Entry->EntryPointActivationContext != INVALID_HANDLE_VALUE)) {

        RtlReleaseActivationContext (Entry->EntryPointActivationContext);
        Entry->EntryPointActivationContext = INVALID_HANDLE_VALUE;
    }

    if (Entry->FullDllName.Buffer != NULL) {
        LdrpFreeUnicodeString (&Entry->FullDllName);
    }

    LdrpDeallocateDataTableEntry (Entry);
}


NTSTATUS
LdrpAllocateUnicodeString (
    OUT PUNICODE_STRING StringOut,
    IN USHORT Length
    )
/*++

Routine Description:

    This routine allocates space for a UNICODE_STRING from the loader
    private heap.

Arguments:

    StringOut - Supplies a pointer to a UNICODE_STRING in which the
                information about the allocated string is written.  Any
                previous contents of StringOut are overwritten and lost.

    Length - Supplies the number of bytes of the string which StringOut
             must be able to hold.

Return Value:

    NTSTATUS indicating success or failure of this function.  In general
    the only reasons it fails are STATUS_NO_MEMORY when the heap allocation
    cannot be performed or STATUS_INVALID_PARAMETER when an invalid parameter
    value is passed in.

--*/
{
    ASSERT (StringOut != NULL);
    ASSERT (Length <= UNICODE_STRING_MAX_BYTES);

    StringOut->Length = 0;

    if ((Length % sizeof(WCHAR)) != 0) {
        StringOut->Buffer = NULL;
        StringOut->MaximumLength = 0;
        return STATUS_INVALID_PARAMETER;
    }

    StringOut->Buffer = RtlAllocateHeap (LdrpHeap, 0, Length + sizeof(WCHAR));

    if (StringOut->Buffer == NULL) {
        StringOut->MaximumLength = 0;
        return STATUS_NO_MEMORY;
    }

    StringOut->Buffer[Length / sizeof(WCHAR)] = L'\0';

    //
    // If the true length of the buffer can be represented in 16 bits,
    // store it; otherwise store the biggest number we can.
    //

    if (Length != UNICODE_STRING_MAX_BYTES) {
        StringOut->MaximumLength = Length + sizeof(WCHAR);
    }
    else {
        StringOut->MaximumLength = Length;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LdrpCopyUnicodeString (
    OUT PUNICODE_STRING StringOut,
    IN PCUNICODE_STRING StringIn
    )
/*++

Routine Description:

    This function makes a copy of a unicode string; the important aspect
    of it is that the string is allocated from the loader private heap.

Arguments:

    StringOut - Pointer to UNICODE_STRING in which the information about
        the copied string is written.  Any previous contents of StringOut
        are overwritten and lost.

    StringIn - Pointer to constant UNICODE_STRING which is copied.

Return Value:

    NTSTATUS indicating success or failure of this function.  In general
    the only reason it fails is STATUS_NO_MEMORY when the heap allocation
    cannot be performed.

--*/

{
    NTSTATUS st;

    ASSERT (StringOut != NULL);
    ASSERT (StringIn != NULL);

    st = RtlValidateUnicodeString (0, StringIn);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    StringOut->Length = 0;
    StringOut->MaximumLength = 0;
    StringOut->Buffer = NULL;

    st = LdrpAllocateUnicodeString (StringOut, StringIn->Length);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    RtlCopyMemory (StringOut->Buffer, StringIn->Buffer, StringIn->Length);
    StringOut->Length = StringIn->Length;

    return STATUS_SUCCESS;
}


VOID
LdrpFreeUnicodeString (
    IN OUT PUNICODE_STRING StringIn
    )
/*++

Routine Description:

    This function deallocates a string that was allocated using
    LdrpCopyUnicodeString.

Arguments:

    String - Pointer to UNICODE_STRING which is to be freed.  On exit,
                all the members are set to 0/null as appropriate.

Return Value:

    None

--*/

{
    ASSERT (StringIn != NULL);

    if (StringIn->Buffer != NULL) {
        RtlFreeHeap(LdrpHeap, 0, StringIn->Buffer);
    }

    StringIn->Length = 0;
    StringIn->MaximumLength = 0;
    StringIn->Buffer = NULL;
}


VOID
LdrpEnsureLoaderLockIsHeld (
    VOID
    )
{
    LOGICAL LoaderLockIsHeld =
        ((LdrpInLdrInit) ||
         ((LdrpShutdownInProgress) &&
          (LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread)) ||
         (LdrpLoaderLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread));

    ASSERT(LoaderLockIsHeld);

    if (!LoaderLockIsHeld) {
        RtlRaiseStatus(STATUS_NOT_LOCKED);
    }
}


int
LdrpGenericExceptionFilter (
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers,
    IN PCSTR FunctionName
    )
/*++

Routine Description:

    Exception filter function used in __try block throughout the loader
    code instead of just specifying __except(EXCEPTION_EXECUTE_HANDLER).

Arguments:

    ExceptionPointers
        Pointer to exception information returned by GetExceptionInformation() in the __except()

    FunctionName
        Name of the function in which the __try block appears.


Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/
{
    const ULONG ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    DbgPrintEx(
        DPFLTR_LDR_ID,
        LDR_ERROR_DPFLTR,
        "LDR: exception %08lx thrown within function %s\n"
        "   Exception record: %p\n"
        "   Context record: %p\n",
        ExceptionCode, FunctionName,
        ExceptionPointers->ExceptionRecord,
        ExceptionPointers->ContextRecord);

#ifdef _X86_
    // It would be nice to have a generic context dumper but right now I'm just trying to
    // debug X86 and this is the quick thing to do.  -mgrier 4/8/2001
    DbgPrintEx(
        DPFLTR_LDR_ID,
        LDR_ERROR_DPFLTR,
        "   Context->Eip = %p\n"
        "   Context->Ebp = %p\n"
        "   Context->Esp = %p\n",
        ExceptionPointers->ContextRecord->Eip,
        ExceptionPointers->ContextRecord->Ebp,
        ExceptionPointers->ContextRecord->Esp);
#endif // _X86_

    if (LdrpBreakOnExceptions) {

        char Response[2];

        do {
            DbgPrint ("\n***Exception thrown within loader***\n");
            DbgPrompt (
                "Break repeatedly, break Once, Ignore, terminate Process or terminate Thread (boipt)? ",
                Response,
                sizeof(Response));

            switch (Response[0]) {
            case 'b':
            case 'B':
            case 'o':
            case 'O':
                DbgPrint ("Execute '.cxr %p' to dump context\n", ExceptionPointers->ContextRecord);

                DbgBreakPoint ();

                if ((Response[0] == 'o') || (Response[0] == 'O')) {
                    return EXCEPTION_EXECUTE_HANDLER;
                }

            case 'I':
            case 'i':
                return EXCEPTION_EXECUTE_HANDLER;

            case 'P':
            case 'p':
                NtTerminateProcess (NtCurrentProcess(), ExceptionCode);
                break;

            case 'T':
            case 't':
                NtTerminateThread (NtCurrentThread(), ExceptionCode);
                break;
            }
        } while (TRUE);
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
RtlComputePrivatizedDllName_U (
    IN PCUNICODE_STRING DllName,
    IN OUT PUNICODE_STRING NewDllNameUnderImageDir,
    IN OUT PUNICODE_STRING NewDllNameUnderLocalDir
    )

/*++

Routine Description:

    This function computes a fully qualified path to a DLL name. It takes
    the path of the current process and the base name from DllName and
    puts these together. DllName can have '\' or '/' as separator.

Arguments:

    DllName - Points to a string that names the library file. This can be
              a fully qualified name or just a base name. We will parse for
              the base name (the portion after the last '\' or '/' char.
              Caller guarantees that DllName->Buffer is not a NULL pointer!

    NewDllName - Has fully qualified path based on GetModuleFileNameW(NULL...)
                 and the base name from above.

Return Value:

    NTSTATUS: Currently: STATUS_NO_MEMORY or STATUS_SUCCESS.

--*/

{
    LPWSTR p, pp1, pp2;
    PWSTR  Dot;
    LPWSTR pFullImageName;
    USHORT cbFullImageNameLength;
    USHORT cbFullImagePathLengthWithTrailingSlash, cbDllFileNameLengthWithTrailingNULL;
    USHORT cbDllNameUnderImageDir, cbDllNameUnderLocalDir;
    ULONG  cbStringLength;
    PWSTR  Cursor = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    LPWSTR pDllNameUnderImageDir = NULL;
    LPWSTR pDllNameUnderLocalDir = NULL;
    LPCWSTR pBuf1 = NewDllNameUnderImageDir->Buffer;
    LPCWSTR pBuf2 = NewDllNameUnderLocalDir->Buffer;

    cbFullImageNameLength = NtCurrentPeb()->ProcessParameters->ImagePathName.Length;
    pFullImageName = (PWSTR)NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer;

    if (!(NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
        pFullImageName = (PWSTR)((PCHAR)pFullImageName + (ULONG_PTR)(NtCurrentPeb()->ProcessParameters));
    }

    ASSERT(pFullImageName != NULL);

    //
    // Find the end of the EXE path (start of its base-name) in pp1.
    // Size1 is number of bytes.
    //

    p = pFullImageName + cbFullImageNameLength/sizeof(WCHAR) - 1; // point to last character of this name
    pp1 = pFullImageName;
    while (p > pFullImageName) {
        if (RTL_IS_PATH_SEPARATOR(*p)) {
            pp1 = p + 1;
            break;
        }
        p -= 1;
    }

    //
    // Find the basename portion of the DLL to be loaded in pp2 and the
    // last '.' character if present in the basename.
    //

    pp2 = DllName->Buffer;
    Dot = NULL;

    if (DllName->Length) {

        ASSERT(RTL_STRING_IS_NUL_TERMINATED(DllName)); // temporary debugging

        p = DllName->Buffer + (DllName->Length>>1) - 1; // point to last char

        while (p > DllName->Buffer) {

            if (*p == (WCHAR) '.') {
                if (!Dot) {
                    Dot = p;
                }
            }
            else {
                if ((*p == (WCHAR) '\\') || (*p == (WCHAR) '/')) {
                    pp2 = p + 1;
                    break;
                }
            }
            p -= 1;
        }
    }

    //
    // Create a fully qualified path to the DLL name (using pp1 and pp2)
    // Number of bytes (not including NULL or EXE/process folder)
    //

    if (((pp1 - pFullImageName) * sizeof(WCHAR)) > ULONG_MAX) {
        DbgPrint ("ntdll: wants more than ULONG_MAX bytes \n");
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbStringLength = (ULONG)((pp1 - pFullImageName) * sizeof(WCHAR));

    if (cbStringLength > UNICODE_STRING_MAX_BYTES) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbFullImagePathLengthWithTrailingSlash = (USHORT)cbStringLength;

    //
    // Number of bytes in base DLL name (including trailing null char).
    //

    if (DllName->Length > (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbDllFileNameLengthWithTrailingNULL = (USHORT)(DllName->Length + sizeof(WCHAR) - ((pp2 - DllName->Buffer) * sizeof(WCHAR)));

    cbStringLength = cbFullImagePathLengthWithTrailingSlash
                     + cbDllFileNameLengthWithTrailingNULL;

    //
    // Allocate room for L".DLL"
    //

    if (Dot == NULL) {
        cbStringLength += sizeof(DLL_EXTENSION) - sizeof(WCHAR);
    }

    if (cbStringLength > UNICODE_STRING_MAX_BYTES) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbDllNameUnderImageDir = (USHORT)cbStringLength;

    if (cbDllNameUnderImageDir > NewDllNameUnderImageDir->MaximumLength) {
        pDllNameUnderImageDir = (*RtlAllocateStringRoutine)(cbDllNameUnderImageDir);
        if (pDllNameUnderImageDir == NULL) {
            status = STATUS_NO_MEMORY;
            goto Exit;
        }
    }
    else {
        pDllNameUnderImageDir = NewDllNameUnderImageDir->Buffer;
    }

    Cursor = pDllNameUnderImageDir;
    RtlCopyMemory(Cursor, pFullImageName, cbFullImagePathLengthWithTrailingSlash);
    Cursor = pDllNameUnderImageDir + cbFullImagePathLengthWithTrailingSlash / sizeof(WCHAR);

    RtlCopyMemory(Cursor, pp2, cbDllFileNameLengthWithTrailingNULL - sizeof(WCHAR));
    Cursor += (cbDllFileNameLengthWithTrailingNULL - sizeof(WCHAR)) / sizeof(WCHAR);

    if (!Dot) {

        //
        // If there is no '.' in the basename add the ".DLL" to it.
        //
        // The -1 will work just as well as - sizeof(WCHAR) as we are
        // dividing by sizeof(WCHAR) and it will be rounded down
        // correctly as Size1 and Size2 are even.  The -1 could be
        // more optimal than subtracting sizeof(WCHAR).
        //

        RtlCopyMemory(Cursor, DLL_EXTENSION, sizeof(DLL_EXTENSION));

        cbDllFileNameLengthWithTrailingNULL += sizeof(DLL_EXTENSION) - sizeof(WCHAR); // Mark base name as being 8 bytes bigger.
    }
    else {
        *Cursor = L'\0';
    }

    cbStringLength = cbFullImageNameLength
                + sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR) //.local
                + sizeof(WCHAR) // "\\"
                + cbDllFileNameLengthWithTrailingNULL;

    if (cbStringLength > UNICODE_STRING_MAX_BYTES) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbDllNameUnderLocalDir = (USHORT)cbStringLength;

    if ( cbDllNameUnderLocalDir > NewDllNameUnderLocalDir->MaximumLength) {
        pDllNameUnderLocalDir = (RtlAllocateStringRoutine)(cbDllNameUnderLocalDir);
        if (!pDllNameUnderLocalDir) {
            status = STATUS_NO_MEMORY;
            goto Exit;
        }
    }
    else {
        pDllNameUnderLocalDir = NewDllNameUnderLocalDir->Buffer;
    }

    Cursor = pDllNameUnderLocalDir;
    RtlCopyMemory(Cursor, pFullImageName, cbFullImageNameLength);
    Cursor = pDllNameUnderLocalDir + cbFullImageNameLength / sizeof(WCHAR);

    RtlCopyMemory(Cursor, DLL_REDIRECTION_LOCAL_SUFFIX, sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR));
    Cursor += (sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR)) / sizeof(WCHAR);

    *Cursor = L'\\';
    Cursor += 1;

    RtlCopyMemory(Cursor,
                  pDllNameUnderImageDir + cbFullImagePathLengthWithTrailingSlash/sizeof(WCHAR),
                  cbDllFileNameLengthWithTrailingNULL);


    NewDllNameUnderImageDir->Buffer = pDllNameUnderImageDir;

    if (pDllNameUnderImageDir != pBuf1) { // if memory is not-reallocated, MaximumLength should be untouched

        NewDllNameUnderImageDir->MaximumLength = cbDllNameUnderImageDir;
    }

    NewDllNameUnderImageDir->Length = (USHORT)(cbDllNameUnderImageDir - sizeof(WCHAR));

    NewDllNameUnderLocalDir->Buffer = pDllNameUnderLocalDir;

    if (pDllNameUnderLocalDir != pBuf2) {
        NewDllNameUnderLocalDir->MaximumLength = cbDllNameUnderLocalDir;
    }

    NewDllNameUnderLocalDir->Length = (USHORT)(cbDllNameUnderLocalDir - sizeof(WCHAR));

    return STATUS_SUCCESS;

Exit:
    if (!NT_SUCCESS(status)) {
        if (pDllNameUnderImageDir != NULL && pDllNameUnderImageDir != pBuf1) {
           (RtlFreeStringRoutine)(pDllNameUnderImageDir);
        }
        if (pDllNameUnderLocalDir != NULL && pDllNameUnderLocalDir != pBuf2) {
           (RtlFreeStringRoutine)(pDllNameUnderLocalDir);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrwx86.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrwx86.c

Abstract:

    This module implements the wx86 specific ldr functions.

Author:

    13-Jan-1995 Jonle , created

Revision History:

    15-Oct-1998 CBiks   Modified the code that throws the architecture
                        mismatch exception so the exception is only
                        thrown for NT 3,0 and lower executables.  This was
                        changed to make the Wx86 loader behave like the
                        real loader, which does not throw this exception.

                        Also added a call to the cleanup function when
                        LdrpWx86LoadDll() fails.  There were cases where the
                        CPU failed to initialize but the Wx86 global pointers
                        were not cleared and pointed to a invalid memory because
                        wx86.dll was unloaded.
                        
    13-Mar-2001 SamerA  Fix sharing of varialbes inside a SHARED read/write section.
    
    20-May-2001 SamerA  Fix mapping of image sections that have their PointerToRawData
                        RVA overlap with other sections virtual addresses.
                        (Fixed corel's WP2002 intro.exe)
                        
    18-Sep-2001 SamerA  Change page protection of image-pages to be compatible with what
                        the section header says (x86 compatibility).
                        
    24-Oct-2001 SamerA  Correct calculation of variables offsets inside the relocated
                        shared section.                    
--*/

#include "ldrp.h"
#include "ntos.h"

#define PAGE_SIZE_X86   (0x1000)

#if defined(BUILD_WOW6432)

//
// This table is indexed by the last 3 bits of the SectionHeader->Characteristics to get the page protection
// from the section protection value. The result value is to be passed to NtProtectVirtualMemory ()
//
ULONG SectionToPageProtection [8] =
{
    PAGE_NOACCESS,
    PAGE_EXECUTE,
    PAGE_READONLY,
    PAGE_EXECUTE_READ,
    PAGE_READWRITE,
    PAGE_EXECUTE_READWRITE,
    PAGE_READWRITE,
    PAGE_EXECUTE_READWRITE
};

//   
// From mi\mi.h:
//

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \
                    (((LENGTH) + ((ALIGNMENT) - 1)) & ~((ALIGNMENT) - 1))
                    
PIMAGE_BASE_RELOCATION
LdrpWx86ProcessRelocationBlock (
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN ULONG Diff,
    IN ULONG_PTR SectionStartVA,
    IN ULONG_PTR SectionEndVA);

NTSTATUS 
FixupBlockList(
    IN PUCHAR ImageBase);

VOID 
FixupSectionHeader(
    IN PUCHAR ImageBase);


NTSTATUS
LdrpWx86FixupExportedSharedSection (
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders
    );


BOOLEAN
LdrpWx86DetectSectionOverlap (
    IN PIMAGE_NT_HEADERS NtHeaders
    )
{
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SrcRawData;
    ULONG SrcEndRawData;
    ULONG SrcSize;
    ULONG Section;
    ULONG SectionCheck;
    ULONG Count;
    BOOLEAN Result = FALSE;


    //
    // Run through the section and see if any one need to be moved down (higher in address space),
    // then for each one of those, check if it overlap with any section
    // that has already been moved up.
    //

    SectionHeader = IMAGE_FIRST_SECTION (NtHeaders);

    if (NtHeaders->FileHeader.NumberOfSections == 0) {
        return FALSE;
    }

    for (Section = NtHeaders->FileHeader.NumberOfSections-1, Count=0 ; 
         Count < NtHeaders->FileHeader.NumberOfSections ; Section--, Count++) {

        SrcRawData = SectionHeader[Section].PointerToRawData;
        SrcSize = SectionHeader[Section].SizeOfRawData;
        if ((SectionHeader[Section].Misc.VirtualSize > 0) &&
            (SrcRawData > MI_ROUND_TO_SIZE(SectionHeader[Section].Misc.VirtualSize, PAGE_SIZE_X86))) {
           SrcSize = MI_ROUND_TO_SIZE(SectionHeader[Section].Misc.VirtualSize, PAGE_SIZE_X86);
        }


        if (SrcRawData > (MAXULONG - SrcSize)) {
            break;
        }

        SrcEndRawData = SrcRawData + SrcSize;

        //
        // This section needs to be moved down
        //
        for (SectionCheck = 0 ; SectionCheck < NtHeaders->FileHeader.NumberOfSections ; SectionCheck++) {

            if (Section == SectionCheck) {
                continue;
            }

            SrcSize = SectionHeader[SectionCheck].SizeOfRawData;
            if ((SectionHeader[SectionCheck].Misc.VirtualSize > 0) &&
                (SrcSize > MI_ROUND_TO_SIZE(SectionHeader[SectionCheck].Misc.VirtualSize, PAGE_SIZE_X86))) {
               SrcSize = MI_ROUND_TO_SIZE(SectionHeader[SectionCheck].Misc.VirtualSize, PAGE_SIZE_X86);
            }

#if WOW6432_DBG
            DbgPrint("SrcRawData=%lx, SrcEndRawData=%lx, SectionFirstVA=%lx, SectionEndVA=%lx\n",
                      SrcRawData, SrcEndRawData, SectionHeader[SectionCheck].VirtualAddress,
                      SectionHeader[SectionCheck].VirtualAddress + SrcSize);
#endif

            if (SectionHeader[SectionCheck].VirtualAddress > (MAXULONG - SrcSize)) {
                break;
            }

            if (((SrcRawData >= SectionHeader[SectionCheck].VirtualAddress) && 
                (SrcRawData < (SectionHeader[SectionCheck].VirtualAddress + SrcSize))) || 
                ((SrcEndRawData >= SectionHeader[SectionCheck].VirtualAddress) &&
                 (SrcEndRawData < (SectionHeader[SectionCheck].VirtualAddress + SrcSize)))) {

                Result = TRUE;
                break;
            }
        }

        if (Result == TRUE) {
            break;
        }
    }

    return Result;
}


NTSTATUS
LdrpWx86CheckVirtualSectionOverlap (
    IN PCUNICODE_STRING ImageName OPTIONAL,
    IN PIMAGE_NT_HEADERS NtHeaders,
    OUT PVOID *SrcImageMap
    )

/*++

Routine Description:


    This function goes through the image sections based at ImageBase and looks
    for any overlap between the section physical locations and their updated virtual
    locations.

Arguments:

    ImageName - Unicode string pointer to the full path to the image.
    
    ImageBase - Base of image.

    SrcImageMap - Pointer to pointer to receive a base pointer to the image mapped
        as read-only pages inside this process. The mapped pages need to be released
        when done.

Return Value:

    NTSTATUS.
    SUCCESS - Means the image has been found to have overlapped sections, and an 
              alternate section has been mapped in.
              
    FAILURE - The image mapping failed or the image doesn't have overlapped sections.

--*/

{
    PUNICODE_STRING NtPathName;
    PVOID FreeBuffer;
    BOOLEAN Result;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID ViewBase;
    SIZE_T ViewSize;
    LARGE_INTEGER SectionOffset;
    UCHAR Buffer[ DOS_MAX_PATH_LENGTH ];
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    //
    // Check for any overlap inside the image.
    //
    
    Result = LdrpWx86DetectSectionOverlap (NtHeaders);

    if (Result == FALSE) {
        return NtStatus;
    }

    FreeBuffer = NULL;

    //
    // Make sure we have a path.
    //
    
    NtPathName = (PUNICODE_STRING)Buffer;
    if (ARGUMENT_PRESENT (ImageName) == 0) {

        NtStatus = NtQueryInformationProcess(
                       NtCurrentProcess(),
                       ProcessImageFileName,
                       NtPathName,
                       sizeof (Buffer),
                       NULL
                       );
    } else {

        Result = RtlDosPathNameToNtPathName_U(
                     ImageName->Buffer,
                     NtPathName,
                     NULL,
                     NULL
                     );
        
        if (Result != FALSE) {
            
            FreeBuffer = NtPathName->Buffer;
            NtStatus = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS (NtStatus)) {

        InitializeObjectAttributes(
            &ObjectAttributes,
            NtPathName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        NtStatus = NtCreateFile(
                       &FileHandle,
                       (ACCESS_MASK) GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       NULL,
                       0L,
                       FILE_SHARE_READ | FILE_SHARE_DELETE,
                       FILE_OPEN,
                       0L,
                       NULL,
                       0L
                       );

        if (FreeBuffer != NULL) {
            RtlFreeHeap (RtlProcessHeap(), 0, FreeBuffer);
        }

        if (NT_SUCCESS (NtStatus)) {

            NtStatus = NtCreateSection(
                           &MappingHandle,
                           STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
                           NULL,
                           NULL,
                           PAGE_READONLY,
                           SEC_COMMIT,
                           FileHandle
                           );

            NtClose (FileHandle);

            if (NT_SUCCESS (NtStatus)) {

                SectionOffset.LowPart = 0;
                SectionOffset.HighPart = 0;
                ViewSize = 0;
                ViewBase = NULL;

                NtStatus = NtMapViewOfSection(
                               MappingHandle,
                               NtCurrentProcess(),
                               &ViewBase,
                               0L,
                               0L,
                               &SectionOffset,
                               &ViewSize,
                               ViewShare,
                               0L,
                               PAGE_READONLY
                               );

                NtClose (MappingHandle);

                if (NT_SUCCESS (NtStatus)) {
                    *SrcImageMap = ViewBase;
                }
            }
        }
    }

    return NtStatus;
}


NTSTATUS
LdrpWx86ProtectImagePages (
    IN PVOID Base,
    IN BOOLEAN Reset
    )

/*++

Routine Description:


    This function loops through the image sections, and reset the page protection
    to what is specified inside the section header.

Arguments:

    Base - Base of image.
    
    Reset - Indicate whether to reset to original section protection.

Return Value:

    SUCCESS or reason NtProtectVirtualMemory failed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG SectionIndex;
    ULONG RegionSize;
    ULONG SectionCharacteristics;
    ULONG PageProtection;
    ULONG OldProtection;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER Section;
    PVOID VirtualAddress;
    
    
    
    NtHeaders = RtlImageNtHeader (Base);

    if (NtHeaders == NULL) {
        if (ShowSnaps) {
            DbgPrint ("LdrpWx86ProtectImagePages - Failed to read NtImageHeaders. Base=%p\n", Base);
        }
        return STATUS_INTERNAL_ERROR;
    }

    NtStatus = Wx86SetRelocatedSharedProtection (Base, Reset);

    if (!NT_SUCCESS (NtStatus)) {
        if (ShowSnaps) {
            DbgPrint("LdrpWx86ProtectImagePages - Wx86SetRelocatedSharedProtection(%p, TRUE) failed - NtStatus\n",
                     Base, NtStatus);
        }

        return NtStatus;
    }

    Section = (PIMAGE_SECTION_HEADER) ((ULONG_PTR)NtHeaders + sizeof (ULONG) +
                                       sizeof (IMAGE_FILE_HEADER) +
                                       NtHeaders->FileHeader.SizeOfOptionalHeader);

    //
    // Loop through available sections, making sure not to touch sharable pages, as they are relocated to the
    // the end of the image.
    //

    for (SectionIndex = 0 ; SectionIndex < NtHeaders->FileHeader.NumberOfSections ; SectionIndex++, Section++) {

        RegionSize = Section->SizeOfRawData;

        if (Section->Misc.VirtualSize != 0) {
            RegionSize = Section->Misc.VirtualSize;
        }

        RegionSize = MI_ROUND_TO_SIZE (RegionSize, PAGE_SIZE_X86);

        if (RegionSize != 0) {
            SectionCharacteristics = Section->Characteristics;
            if ((SectionCharacteristics & IMAGE_SCN_MEM_SHARED) == 0) {
                    
                if (Reset) {
                    PageProtection = SectionToPageProtection [SectionCharacteristics >> 29];
                } else {
                    PageProtection = PAGE_READWRITE;
                }

                VirtualAddress = (PVOID)((ULONG_PTR)Base + Section->VirtualAddress);
                NtStatus = NtProtectVirtualMemory (NtCurrentProcess (),
                                                   &VirtualAddress,
                                                   &RegionSize,
                                                   PageProtection,
                                                   &OldProtection);

#if WOW6432_DBG
                DbgPrint("Protecting %lx - VA=%lx, Prot=%lx, SectionProt=%lx, Size = %lx, ST=%lx\n",
                         Base, ((ULONG_PTR)Base + Section->VirtualAddress), PageProtection, SectionCharacteristics,
                         RegionSize, NtStatus);
#endif

                if (!NT_SUCCESS (NtStatus)) {
                    if (ShowSnaps) {
                        DbgPrint ("LdrpWx86ProtectImagePages - Failed to protect section %lx at %lx with protection %lx\n",
                                   SectionIndex, ((ULONG_PTR)Base + Section->VirtualAddress), PageProtection);
                    }
                    return NtStatus;
                }
            }
        }
    }

    return NtStatus;
}


NTSTATUS
Wx86SetRelocatedSharedProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    )

/*++

Routine Description:


    This function loops thru the images sections/objects, setting
    all relocated shared sections/objects marked r/o to r/w. It also resets the
    original section/object protections.

Arguments:

    Base - Base of image.

    Reset - If TRUE, reset section/object protection to original
            protection described by the section/object headers.
            If FALSE, then set all sections/objects to r/w.

Return Value:

    SUCCESS or reason NtProtectVirtualMemory failed.

--*/

{
    HANDLE CurrentProcessHandle;
    SIZE_T RegionSize;
    ULONG NewProtect, OldProtect;
    PVOID VirtualAddress;
    ULONG i;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER SectionHeader;
    NTSTATUS st;
    ULONG NumberOfSharedDataPages;
    SIZE_T NumberOfNativePagesForImage;

    CurrentProcessHandle = NtCurrentProcess();

    NtHeaders = RtlImageNtHeader(Base);

    if (NtHeaders == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                        sizeof(IMAGE_FILE_HEADER) +
                        NtHeaders->FileHeader.SizeOfOptionalHeader
                        );

    NumberOfSharedDataPages = 0;
    NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) {
        
        RegionSize = SectionHeader->SizeOfRawData;
        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
            (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
             (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE)) &&
            (RegionSize != 0)) {
            
            VirtualAddress = (PVOID)((ULONG_PTR)Base + 
                                    ((NumberOfNativePagesForImage + NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT));
            NumberOfNativePagesForImage +=  MI_ROUND_TO_SIZE (RegionSize, NATIVE_PAGE_SIZE) >> NATIVE_PAGE_SHIFT;

            if (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE)) {
                
                //
                // Object isn't writeable, so change it.
                //

                if (Reset) {
                    if (SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                        NewProtect = PAGE_EXECUTE;
                    } 
                    else {
                        NewProtect = PAGE_READONLY;
                    }
                    NewProtect |= (SectionHeader->Characteristics & IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOCACHE : 0;
                } 
                else {
                    NewProtect = PAGE_READWRITE;
                }

                st = NtProtectVirtualMemory(CurrentProcessHandle, &VirtualAddress,
                                            &RegionSize, NewProtect, &OldProtect);

                if (!NT_SUCCESS(st)) {
                    if (ShowSnaps) {
                        DbgPrint("Wx86SetRelocatedSharedProtection - Failed to protect memory: Va=%p, RegionSize=%lx, NewProtect=%lx - %lx\n",
                                 VirtualAddress, RegionSize, NewProtect, st);
                    }
                    return st;
                }
            }
        }
    }

    if (Reset) {
        st = NtFlushInstructionCache(
                        NtCurrentProcess(),
                        Base,
                        NumberOfNativePagesForImage << NATIVE_PAGE_SHIFT
                        );

        if (!NT_SUCCESS(st)) {
            return st;
        }
    }

    return STATUS_SUCCESS;
}

VOID
LdrpWx86RelocateImageDirectoryEntries (
    IN PVOID Base,
    IN PIMAGE_NT_HEADERS32 NtHeaders
    )

{
    ULONG Rva;
    ULONG DirectoryEntry;


    DirectoryEntry = 0;
    while (DirectoryEntry < NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

        //
        // [askhalid] - don't relocate resource entries. Somecode check that against imagezise
        // if you must relocate resource entry then must change image size that might cause more appcompat.
        //
        if ((NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress != 0) &&
            (NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].Size > 0)&&
            ( DirectoryEntry != IMAGE_DIRECTORY_ENTRY_RESOURCE) ) { 

            Rva = NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress;

            NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress +=
                LdrpWx86RelocatedFixupDiff (Base, 
                                            NtHeaders,
                                            NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress
                                            );
            if (ShowSnaps) {
                if (Rva != NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress) {
                    DbgPrint("LdrpWx86RelocateImageDirectoryEntry (%p) - Relocating DirEntry %lx from %lx to %lx\n",
                             Base, DirectoryEntry, Rva, NtHeaders->OptionalHeader.DataDirectory [DirectoryEntry].VirtualAddress);
                }
            }
        }
        
        DirectoryEntry++;
    }
    
    return;
}

NTSTATUS
LdrpWx86FormatVirtualImage (
    IN PCUNICODE_STRING DosImagePathName OPTIONAL,
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID DllBase
    )
{
   PIMAGE_SECTION_HEADER SectionTable, Section, LastSection, FirstSection;
   PUCHAR NextVirtualAddress, SrcVirtualAddress, DestVirtualAddress;
   PUCHAR ImageBase= DllBase;
   LONG Size;
   ULONG NumberOfSharedDataPages;
   ULONG NumberOfNativePagesForImage;
   ULONG NumberOfExtraPagesForImage;
   ULONG_PTR PreferredImageBase;
   BOOLEAN ImageHasRelocatedSharedSection = FALSE;
   ULONG bFirst;
   ULONG SubSectionSize;
   PVOID AlternateBase;
   NTSTATUS st;
   
   AlternateBase = NULL;
   
   st = LdrpWx86CheckVirtualSectionOverlap (DosImagePathName,
                                            NtHeaders,
                                            &AlternateBase);
   
#if WOW6432_DBG
   if (NT_SUCCESS (st) && (AlternateBase != NULL))
   {
       DbgPrint("Mapping in %wZ with AlternateBase = %p\n", DosImagePathName, AlternateBase);
   }
#endif

   st = Wx86SetRelocatedSharedProtection (DllBase, FALSE);

   if (!NT_SUCCESS(st)) {
       DbgPrint("Wx86SetRelocatedSharedProtection failed with return status %x\n", st);

       Wx86SetRelocatedSharedProtection(DllBase, TRUE);
       if (AlternateBase != NULL) {
           NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
       }
       return st;
   }

   //
   // Copy each section from its raw file address to its virtual address
   //

   SectionTable = IMAGE_FIRST_SECTION(NtHeaders);
   LastSection = SectionTable + NtHeaders->FileHeader.NumberOfSections;

   if (SectionTable->PointerToRawData == SectionTable->VirtualAddress) {
       // If the first section does not need to be moved then we exclude it
       // from consideration in passes 1 and 2
       FirstSection = SectionTable + 1;
   }
   else {
       FirstSection = SectionTable;
   }

   //
   // First pass starts at the top and works down moving up each section that
   // is to be moved up.
   //
   Section = FirstSection;
   while (Section < LastSection) {
       SrcVirtualAddress = ImageBase + Section->PointerToRawData;
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

       if (DestVirtualAddress >= SrcVirtualAddress) {
           // Section needs to be moved down
           break;
       }

       // Section needs to be moved up
      if (Section->SizeOfRawData != 0) {
          if (Section->PointerToRawData != 0) {
              RtlMoveMemory(DestVirtualAddress,
                            SrcVirtualAddress,
                            Section->SizeOfRawData);
          }
      }
      else {
          Section->PointerToRawData = 0;
      }

       Section++;
   }

   //
   // Second pass is from the end of the image and work backwards since src and
   // dst overlap
   //
   Section = --LastSection;
   NextVirtualAddress = ImageBase + MI_ROUND_TO_SIZE(NtHeaders->OptionalHeader.SizeOfImage, PAGE_SIZE_X86);

   while (Section >= FirstSection) {
       SrcVirtualAddress = ImageBase + Section->PointerToRawData;
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

       //
       // Compute the subsection size.  The mm is really flexible here...
       // it will allow a SizeOfRawData that far exceeds the virtual size,
       // so we can't trust that.  If that happens, just use the page-aligned
       // virtual size, since that is all that the mm will map in.
       //
       SubSectionSize = Section->SizeOfRawData;
       if (Section->Misc.VirtualSize &&
           SubSectionSize > MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86)) {
          SubSectionSize = MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86);
       }

      //
      // ensure Virtual section doesn't overlap the next section
      //
      if (DestVirtualAddress + SubSectionSize > NextVirtualAddress) {
          Wx86SetRelocatedSharedProtection(DllBase, TRUE);
          if (AlternateBase != NULL) {
              NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
          }
          return STATUS_INVALID_IMAGE_FORMAT;
      }

      if ((DestVirtualAddress <= SrcVirtualAddress) && 
          (AlternateBase == NULL)) {
           
          //
          // Section needs to be moved up
          //
          break;
      }

      // 
      // Section needs to be moved down
      //
      if (Section->SizeOfRawData != 0) {
         if (Section->PointerToRawData != 0) {
             RtlMoveMemory(DestVirtualAddress,
                    (AlternateBase != NULL) ? 
                           ((PUCHAR)AlternateBase + Section->PointerToRawData) : SrcVirtualAddress,
                    SubSectionSize);
          }
      }
      else {
          Section->PointerToRawData = 0;
      }

      NextVirtualAddress = DestVirtualAddress;
      Section--;
   }

   //
   // Third pass is for zeroing out any memory left between the end of a
   // section and the end of the page. We'll do this from end to top
   //
   Section = LastSection;
   NextVirtualAddress = ImageBase + MI_ROUND_TO_SIZE(NtHeaders->OptionalHeader.SizeOfImage, PAGE_SIZE_X86);

   NumberOfSharedDataPages = 0;  
   while (Section >= SectionTable) {
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

      //
      // Shared Data sections cannot be shared, because of
      // page misalignment, and are treated as Exec- Copy on Write.
      //
       if ((Section->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (Section->Characteristics & IMAGE_SCN_MEM_WRITE))) {
          ImageHasRelocatedSharedSection = TRUE;

          if (ShowSnaps) {
              DbgPrint("Unsupported IMAGE_SCN_MEM_SHARED %x\n",
                       Section->Characteristics
                       );
          }
      }

      //
      // If section was empty zero it out
      //
      if (Section->SizeOfRawData != 0) {
          if (Section->PointerToRawData == 0) {
              RtlZeroMemory(DestVirtualAddress,
                            Section->SizeOfRawData
                            );
          }
      }


      SubSectionSize = Section->SizeOfRawData;
      if (Section->Misc.VirtualSize &&
          SubSectionSize > MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86)) {
          SubSectionSize = MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86);
      }


      //
      // Zero out remaining bytes up to the next section
      //
      RtlZeroMemory(DestVirtualAddress + Section->SizeOfRawData,
                    (ULONG)(NextVirtualAddress - DestVirtualAddress - SubSectionSize)
                    );

       NextVirtualAddress = DestVirtualAddress;
       Section--;
   }

   //
   // Unmap the alternate base if it is there
   //
   if (AlternateBase != NULL) {
       NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
   }

   // Pass 4: if the dll has any shared sections, change the shared data
   // references to point to additional shared pages at the end of the image.
   //
   // Note that our fixups are applied assuming that the dll is loaded at
   // its preferred base; if it is loaded at some other address, it will
   // be relocated again along will all other addresses.


   if (!ImageHasRelocatedSharedSection) {
       goto LdrwWx86FormatVirtualImageDone;
   }

   st = FixupBlockList(DllBase);
   if (!NT_SUCCESS(st)) {
       Wx86SetRelocatedSharedProtection(DllBase, TRUE);
       return st;
   }

   LdrpWx86RelocateImageDirectoryEntries (DllBase, NtHeaders);

   NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
   NumberOfExtraPagesForImage = 0;

   // Account for raw data that extends beyond SizeOfImage

   for (Section = SectionTable; Section <= LastSection; Section++)
   {
       ULONG EndOfSection;
       ULONG ExtraPages;
       ULONG ImagePages = NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
       
       EndOfSection = Section->PointerToRawData + Section->SizeOfRawData;
       
       if (NATIVE_BYTES_TO_PAGES (EndOfSection) > ImagePages) {
           
           ExtraPages = NATIVE_BYTES_TO_PAGES (EndOfSection) - ImagePages;
           if (ExtraPages > NumberOfExtraPagesForImage) {
               NumberOfExtraPagesForImage = ExtraPages;
           }
       }
   }

   PreferredImageBase = NtHeaders->OptionalHeader.ImageBase;

   NumberOfNativePagesForImage += NumberOfExtraPagesForImage;
   NumberOfSharedDataPages = 0;

   bFirst = 1;
   for (Section = SectionTable; Section <= LastSection; Section++) {

        if ((Section->Characteristics & IMAGE_SCN_MEM_SHARED) && 
            (!(Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
             (Section->Characteristics & IMAGE_SCN_MEM_WRITE))) 
        {
            PIMAGE_BASE_RELOCATION NextBlock;
            PUSHORT NextOffset;
            ULONG TotalBytes;
            ULONG SizeOfBlock;
            ULONG_PTR VA;
            ULONG_PTR SectionStartVA;
            ULONG_PTR SectionEndVA;
            ULONG SectionVirtualSize;
            ULONG Diff;

            SectionVirtualSize = Section->Misc.VirtualSize;
            if (SectionVirtualSize == 0)
            {
                SectionVirtualSize = Section->SizeOfRawData;
            }

            SectionStartVA = PreferredImageBase + Section->VirtualAddress;
            SectionEndVA = SectionStartVA + SectionVirtualSize;


            NextBlock = RtlImageDirectoryEntryToData(DllBase, TRUE,
                                        IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                        &TotalBytes);
            if (!NextBlock || !TotalBytes)
            {
                // Note that if this fails, it should fail in the very
                // first iteration and no fixups would have been performed

                if (!bFirst)
                {
                    // Trouble
                    if (ShowSnaps)
                    {
                        DbgPrint("LdrpWx86FormatVirtualImage: failure "
                        "after relocating some sections for image at %x\n",
                                DllBase);
                    }
                    Wx86SetRelocatedSharedProtection(DllBase, TRUE);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }

                if (ShowSnaps)
                {
                    DbgPrint("LdrpWx86FormatVirtualImage: No fixup info "
                                "for image at %x; private sections will be "
                                "used for shared data sections.\n",
                            DllBase);
                }
                break;
            }

            bFirst = 0;

            Diff = (NumberOfNativePagesForImage +
                                NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT;
            Diff -= (ULONG) (SectionStartVA - PreferredImageBase);

            if (ShowSnaps)
            {
                DbgPrint("LdrpWx86FormatVirtualImage: Relocating shared "
                         "data for shared data section 0x%x of image "
                         "at %x by 0x%lx bytes\n",
                         Section - SectionTable + 1, DllBase, Diff);
            }

            while (TotalBytes)
            {
                SizeOfBlock = NextBlock->SizeOfBlock;
                if (SizeOfBlock == 0) {
                    
                    if (ShowSnaps) {
                        DbgPrint("Image at %lx contains invalid block size. Stopping fixups\n", 
                                 ImageBase);
                    }
                    break;
                }
                TotalBytes -= SizeOfBlock;
                SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
                SizeOfBlock /= sizeof(USHORT);
                NextOffset = (PUSHORT) ((PCHAR)NextBlock +
                                        sizeof(IMAGE_BASE_RELOCATION));
                VA = (ULONG_PTR) DllBase + NextBlock->VirtualAddress;

                NextBlock = LdrpWx86ProcessRelocationBlock (VA,
                                                            SizeOfBlock,
                                                            NextOffset,
                                                            Diff,
                                                            SectionStartVA,
                                                            SectionEndVA);
                if (NextBlock == NULL)
                {
                    // Trouble
                    if (ShowSnaps)
                    {
                        DbgPrint("LdrpWx86FormatVirtualImage: failure "
                        "after relocating some sections for image at %x; "
                        "Relocation information invalid\n",
                                DllBase);
                    }
                    Wx86SetRelocatedSharedProtection(DllBase, TRUE);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }
            }
            NumberOfSharedDataPages += MI_ROUND_TO_SIZE (SectionVirtualSize,
                                                        NATIVE_PAGE_SIZE) >>
                                                        NATIVE_PAGE_SHIFT;

        }
   }


   //
   // If any of the variables inside the shared section is exported, then
   // we need to fix up its RVA to point to the proper location at
   // the end of the image.
   //

   LdrpWx86FixupExportedSharedSection (DllBase, NtHeaders);

LdrwWx86FormatVirtualImageDone:

   //
   // Zero out first section's Raw Data up to its VirtualAddress
   //
   if (SectionTable->PointerToRawData != 0) {
       DestVirtualAddress = SectionTable->PointerToRawData + ImageBase;
       Size = (LONG)(NextVirtualAddress - DestVirtualAddress);
       if (Size > 0) {
           RtlZeroMemory(DestVirtualAddress, (ULONG)Size);
       }
   }

   //
   // Protect the shared pages
   //
   
   st = LdrpWx86ProtectImagePages (DllBase, TRUE);

   if (!NT_SUCCESS(st)) {
       return st;
   }

   return STATUS_SUCCESS;

}


NTSTATUS
LdrpWx86FixupExportedSharedSection (
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders
    )

/*++

Routine Description:


    This function goes through the exported entries from this module,
    and relocates (fixup) any address that lie inside any shared
    read/write to the end of the image.

Arguments:

    ImageBase - Virtual address for image base.
    
    NtHeaders - Address of the image's header.

Return Value:

    NTSTATUS.

--*/

{
    PIMAGE_EXPORT_DIRECTORY ImageExportDirectory;
    ULONG TotalBytes;
    ULONG SharedRelocFixup;
    ULONG Export;
    PULONG ExportEntry;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    ImageExportDirectory = RtlImageDirectoryEntryToData (
        ImageBase, 
        TRUE,                                            
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &TotalBytes);

    if ((ImageExportDirectory == NULL) || (TotalBytes == 0)) {
        return NtStatus;
    }

    ExportEntry = (PULONG)((ULONG)ImageBase + ImageExportDirectory->AddressOfFunctions);

    for (Export = 0 ; Export < ImageExportDirectory->NumberOfFunctions ; Export++) {

        SharedRelocFixup = LdrpWx86RelocatedFixupDiff (
            ImageBase,
            NtHeaders,
            ExportEntry[Export]
            );

        if (SharedRelocFixup != 0) {

            if (ShowSnaps) {
                DbgPrint("LdrpWx86FixupExportedSharedSection: Changing export Export[%lx] from %lx to %lx\n", 
                         Export, 
                         ExportEntry[Export], 
                         ExportEntry [Export] + SharedRelocFixup);
            }
            ExportEntry [Export] += SharedRelocFixup;
        }

    }

    return NtStatus;
}

////////////////////////////////////////////////////


ULONG
LdrpWx86RelocatedFixupDiff(
    IN PUCHAR ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN ULONG  Offset
    )
{
   PIMAGE_SECTION_HEADER SectionHeader;
   ULONG i;
   ULONG NumberOfSharedDataPages;
   ULONG NumberOfNativePagesForImage;
   ULONG Diff = 0;
   ULONG_PTR FixupAddr = (ULONG_PTR)(ImageBase + Offset);
   
   SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                    sizeof(IMAGE_FILE_HEADER) +
                    NtHeaders->FileHeader.SizeOfOptionalHeader
                    );

   NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
   NumberOfSharedDataPages = 0;

   for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) 
   {
       ULONG_PTR SectionStartVA;
       ULONG_PTR SectionEndVA;
       ULONG SectionVirtualSize;

       SectionVirtualSize = SectionHeader->Misc.VirtualSize;
       if (SectionVirtualSize == 0) {
           SectionVirtualSize = SectionHeader->SizeOfRawData;
       }

       SectionStartVA = (ULONG_PTR)ImageBase + SectionHeader->VirtualAddress;
       SectionEndVA = SectionStartVA + SectionVirtualSize;

       if (((ULONG_PTR)FixupAddr >= SectionStartVA) && ((ULONG_PTR)FixupAddr < SectionEndVA)) {
           if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
               (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
                (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
               Diff = (NumberOfNativePagesForImage +
                       NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT;
               Diff -= (ULONG)SectionHeader->VirtualAddress;
           }
           break;
       }
 
       if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
           NumberOfSharedDataPages += MI_ROUND_TO_SIZE (SectionVirtualSize,
                                                        NATIVE_PAGE_SIZE) >>
                                                        NATIVE_PAGE_SHIFT;
       }
   }

   return Diff;
}


NTSTATUS 
FixupBlockList (
    IN PUCHAR ImageBase)
{
   PIMAGE_BASE_RELOCATION NextBlock;
   PUSHORT NextOffset;
   ULONG TotalBytes;
   ULONG SizeOfBlock;
   PIMAGE_NT_HEADERS NtHeaders;

   NextBlock = RtlImageDirectoryEntryToData(ImageBase, TRUE,
                                            IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                            &TotalBytes);

   if (!NextBlock || !TotalBytes) {
       if (ShowSnaps) {
           DbgPrint("LdrpWx86FixupBlockList: No fixup info "
                    "for image at %x; private sections will be "
                    "used for shared data sections.\n",
                    ImageBase);
       }
       return STATUS_SUCCESS;
   }

   NtHeaders = RtlImageNtHeader (ImageBase);
   if (! NtHeaders) {
       if (ShowSnaps) {
           DbgPrint("LdrpWx86FixupBlockList: failure "
                    "to locate image header for image at %x.\n",
                    ImageBase);
       }
       return STATUS_INVALID_IMAGE_FORMAT;
   }

   while (TotalBytes) {
       
       SizeOfBlock = NextBlock->SizeOfBlock;
       
       if (SizeOfBlock == 0) {

           if (ShowSnaps) {
               DbgPrint("Image at %lx contains invalid block size. Stopping fixups\n", 
                        ImageBase);
           }
           break;
       }
       TotalBytes -= SizeOfBlock;
       SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
       SizeOfBlock /= sizeof(USHORT);
       NextOffset = (PUSHORT) ((PCHAR)NextBlock +
                               sizeof(IMAGE_BASE_RELOCATION));
       
       NextBlock->VirtualAddress += LdrpWx86RelocatedFixupDiff (
           ImageBase, 
           NtHeaders,
           NextBlock->VirtualAddress
           );

       while (SizeOfBlock--) {
           switch ((*NextOffset) >> 12) {
               case IMAGE_REL_BASED_HIGHLOW :
               case IMAGE_REL_BASED_HIGH :
               case IMAGE_REL_BASED_LOW :
                   break;

               case IMAGE_REL_BASED_HIGHADJ :
                   ++NextOffset;
                   --SizeOfBlock;
                   break;

               case IMAGE_REL_BASED_IA64_IMM64:
               case IMAGE_REL_BASED_DIR64:
               case IMAGE_REL_BASED_MIPS_JMPADDR :
               case IMAGE_REL_BASED_ABSOLUTE :
               case IMAGE_REL_BASED_SECTION :
               case IMAGE_REL_BASED_REL32 :
                   break;

               default :
                   return STATUS_INVALID_IMAGE_FORMAT;
           }
           ++NextOffset;
       }

       NextBlock = (PIMAGE_BASE_RELOCATION)NextOffset;

       if (NextBlock == NULL) {
           // Trouble
           if (ShowSnaps) {
               DbgPrint("LdrpWx86FixupBlockList: failure "
                        "after relocating some sections for image at %x; "
                        "Relocation information invalid\n",
                        ImageBase);
           }
           return STATUS_INVALID_IMAGE_FORMAT;
      }
   }

   return STATUS_SUCCESS;
}


BOOLEAN
LdrpWx86DllHasRelocatedSharedSection(
    IN PUCHAR ImageBase)
{
   PIMAGE_SECTION_HEADER SectionHeader;
   ULONG i;
   PIMAGE_NT_HEADERS32 NtHeaders = (PIMAGE_NT_HEADERS32)RtlImageNtHeader(ImageBase);

   if (! NtHeaders) {
       return FALSE;
   }

   SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                    sizeof(IMAGE_FILE_HEADER) +
                    NtHeaders->FileHeader.SizeOfOptionalHeader
                    );

   for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) 
   {
       if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
           return TRUE;
       }
   }

   return FALSE;
}


////////////////////////////////////////////////

// Following fn is adapted from rtl\ldrreloc.c; it should be updated when
// that function changes. Eliminated 64 bit address relocations.
//
// Note: Instead of calling this routine, we could call
//     LdrpProcessRelocationBlock(VA, 1, NextOffset, Diff)
//
// but we should do that only if the address to be relocated is between
// SectionStartVA and SectionEndVA. So we would have to replicate all the
// code in the switch stmt below that computes the address of the data item -
// which is pretty much the entire function. So we chose to replicate the
// function as it was and change it to make the test.


PIMAGE_BASE_RELOCATION
LdrpWx86ProcessRelocationBlock (
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN ULONG Diff,
    IN ULONG_PTR SectionStartVA,
    IN ULONG_PTR SectionEndVA)
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG_PTR DataVA;


    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);
       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                Temp = *(LONG UNALIGNED *)FixupVA;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(LONG UNALIGNED *)FixupVA = Temp;
                }

                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                }
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    Temp += 0x8000;
                    *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                }
                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(PUSHORT)FixupVA = (USHORT)Temp;
                }
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                // No need to support

                break;

            case IMAGE_REL_BASED_DIR64:

                //
                // Update 32-bit address
                //

                // No need to support

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //

                // No need to support
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#endif  // BUILD_WOW6432
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\ldrsnap.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ldrsnap.c

Abstract:

    This module implements the guts of the Ldr Dll Snap Routine.
    This code is executed only in user mode; the kernel mode
    loader is implemented as part of the memory manager kernel
    component.

Author:

    Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

    Michael Grier (mgrier) 5/4/2000

        Isolate static (import) library loads when activation contexts
        are used to redirect so that a dynamically loaded library
        does not bind to whatever component dll may already be
        loaded for the process.  When redirection is in effect,
        the full path names of the loads must match, not just the
        base names of the dlls.

        Also clean up path allocation policy so that we should be
        clean for 64k paths in the loader.

--*/

#define LDRDBG 0

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4221)   // use automatic variable for initialization
#pragma warning(disable:4204)   // non-constant aggregate initializer
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <winsnmp.h>
#include <winsafer.h>
#include "ldrp.h"
#include "ntdllp.h"
#include <sxstypes.h>
#include <ntrtlpath.h>

#define DLL_EXTENSION L".DLL"
#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"
UNICODE_STRING DefaultExtension = RTL_CONSTANT_STRING(L".DLL");
UNICODE_STRING User32String = RTL_CONSTANT_STRING(L"user32.dll");
UNICODE_STRING Kernel32String = RTL_CONSTANT_STRING(L"kernel32.dll");

#if DBG // DBG
LARGE_INTEGER MapBeginTime, MapEndTime, MapElapsedTime;
#endif // DBG

PCUNICODE_STRING LdrpTopLevelDllBeingLoaded;
BOOLEAN LdrpShowInitRoutines = FALSE;

#if defined(_WIN64)
extern ULONG UseWOW64;
#endif


#if defined (_X86_)
extern PVOID LdrpLockPrefixTable;
extern PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */
//
// Specify address of kernel32 lock prefixes
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),     // size
    0,                             // Reserved
    0,                             // Reserved
    0,                             // Reserved
    0,                             // GlobalFlagsClear
    0,                             // GlobalFlagsSet
    0,                             // CriticalSectionTimeout (milliseconds)
    0,                             // DeCommitFreeBlockThreshold
    0,                             // DeCommitTotalFreeThreshold
    (ULONG_PTR) &LdrpLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0,            // Reserved
    0,                             // & security_cookie
    (ULONG_PTR)__safe_se_handler_table,
    (ULONG_PTR)&__safe_se_handler_count
};


VOID
LdrpValidateImageForMp (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    PUCHAR *pb;
    ULONG ErrorParameters;
    ULONG ErrorResponse;

    //
    // If we are on an MP system and the DLL has image config info,
    // check to see if it has a lock prefix table and make sure the
    // locks have not been converted to NOPs.
    //

    ImageConfigData = RtlImageDirectoryEntryToData (LdrDataTableEntry->DllBase,
                                                    TRUE,
                                                    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                    &i);

    if (ImageConfigData != NULL &&
        (i >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, LockPrefixTable)) &&
        ImageConfigData->LockPrefixTable) {

        pb = (PUCHAR *)ImageConfigData->LockPrefixTable;

        while (*pb) {

            if (**pb == (UCHAR)0x90) {

                if (LdrpNumberOfProcessors > 1) {

                    //
                    // Hard error time. One of the known DLLs is corrupt !
                    //

                    ErrorParameters = (ULONG)&LdrDataTableEntry->BaseDllName;

                    NtRaiseHardError (STATUS_IMAGE_MP_UP_MISMATCH,
                                      1,
                                      1,
                                      &ErrorParameters,
                                      OptionOk,
                                      &ErrorResponse);

                    if (LdrpInLdrInit) {
                        LdrpFatalHardErrorCount += 1;
                    }
                }
            }
            pb += 1;
        }
    }
}
#endif

NTSTATUS
LdrpWalkImportDescriptor (
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );


NTSTATUS
LdrpLoadImportModule (
    IN PCWSTR DllPath OPTIONAL,
    IN PCSTR ImportName,
    OUT PLDR_DATA_TABLE_ENTRY *DataTableEntry,
    OUT PBOOLEAN AlreadyLoaded
    )
{
    NTSTATUS st;
    ANSI_STRING AnsiString;
    PUNICODE_STRING ImportDescriptorName_U;
    WCHAR StaticRedirectedDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectedDllName;
    UNICODE_STRING DynamicRedirectedDllName;
    BOOLEAN Redirected;
    
    Redirected = FALSE;
    DynamicRedirectedDllName.Buffer = NULL;

    ImportDescriptorName_U = &NtCurrentTeb()->StaticUnicodeString;

    RtlInitAnsiString (&AnsiString, ImportName);

    st = RtlAnsiStringToUnicodeString (ImportDescriptorName_U,
                                       &AnsiString,
                                       FALSE);
    if (!NT_SUCCESS(st)) {
        goto Exit;
    }

    //
    // If the module name has no '.' in the name then it can't have
    // an extension.  Add .dll in this case as 9x does this and some
    // apps rely on it.
    //

    if (strchr (ImportName, '.') == NULL) {
        RtlAppendUnicodeToString (ImportDescriptorName_U, L".dll");
    }

    RtlInitUnicodeString (&DynamicRedirectedDllName, NULL);

    StaticRedirectedDllName.Length = 0;
    StaticRedirectedDllName.MaximumLength = sizeof(StaticRedirectedDllNameBuffer);
    StaticRedirectedDllName.Buffer = StaticRedirectedDllNameBuffer;

    st = RtlDosApplyFileIsolationRedirection_Ustr(
                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                ImportDescriptorName_U,
                &DefaultExtension,
                &StaticRedirectedDllName,
                &DynamicRedirectedDllName,
                &ImportDescriptorName_U,
                NULL,
                NULL,
                NULL);

    if (NT_SUCCESS(st)){
        Redirected = TRUE;
    } else if (st != STATUS_SXS_KEY_NOT_FOUND) {
        if (ShowSnaps) {
            DbgPrint("LDR: %s - RtlDosApplyFileIsolationRedirection_Ustr failed with status %x\n", __FUNCTION__, st);
        }

        goto Exit;
    }

    st = STATUS_SUCCESS;

    //
    // Check the LdrTable to see if the DLL has already been mapped
    // into this image. If not, map it.
    //

    if (LdrpCheckForLoadedDll (DllPath,
                               ImportDescriptorName_U,
                               TRUE,
                               Redirected,
                               DataTableEntry)) {
        *AlreadyLoaded = TRUE;
    } else {
        *AlreadyLoaded = FALSE;

        st = LdrpMapDll (DllPath,
                         ImportDescriptorName_U->Buffer,
                         NULL,       // MOOCOW
                         TRUE,
                         Redirected,
                         DataTableEntry);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: %s - LdrpMapDll(%p, %ls, NULL, TRUE, %d, %p) failed with status %x\n", __FUNCTION__, DllPath, ImportDescriptorName_U->Buffer, Redirected, DataTableEntry, st);
            }

            goto Exit;
        }
        
        //
        // Register dll with the stack tracing module.
        // This is used for getting reliable stack traces on X86.
        //

#if defined(_X86_)
        RtlpStkMarkDllRange (*DataTableEntry);
#endif

        st = LdrpWalkImportDescriptor (DllPath, *DataTableEntry);

        if (!NT_SUCCESS(st)) {

            if (ShowSnaps) {
                DbgPrint("LDR: %s - LdrpWalkImportDescriptor [dll %ls]  failed with status %x\n", __FUNCTION__, ImportDescriptorName_U->Buffer, st);
            }

            InsertTailList(&PebLdr.InInitializationOrderModuleList,
                           &(*DataTableEntry)->InInitializationOrderLinks);
        }
    }

Exit:
    if (DynamicRedirectedDllName.Buffer != NULL) {
        RtlFreeUnicodeString (&DynamicRedirectedDllName);
    }

    return st;
}


NTSTATUS
LdrpHandleOneNewFormatImportDescriptor (
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PCIMAGE_BOUND_IMPORT_DESCRIPTOR *NewImportDescriptorInOut,
    PCSZ NewImportStringBase
    )
{
    NTSTATUS st;
    PCIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor = *NewImportDescriptorInOut;
    PCIMAGE_BOUND_FORWARDER_REF NewImportForwarder;
    PCSZ ImportName;
    PCSZ NewImportName;
    PCSZ NewFwdImportName;
    BOOLEAN AlreadyLoaded = FALSE;
    BOOLEAN StaleBinding = FALSE;
    PLDR_DATA_TABLE_ENTRY DataTableEntry, FwdDataTableEntry;
    ULONG i;
    PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportSize;

    NewImportName = NewImportStringBase + NewImportDescriptor->OffsetModuleName;

    if (ShowSnaps) {
        DbgPrint("LDR: %wZ bound to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);
    }

    st = LdrpLoadImportModule (DllPath,
                               NewImportName,
                               &DataTableEntry,
                               &AlreadyLoaded);

    if (!NT_SUCCESS(st)) {
        if (ShowSnaps)
            DbgPrint("LDR: %wZ failed to load import module %s; status = %x\n", &LdrDataTableEntry->BaseDllName, NewImportName, st);

        goto Exit;
    }

    //
    // Add to initialization list.
    //

    if (!AlreadyLoaded) {
        InsertTailList (&PebLdr.InInitializationOrderModuleList,
                        &DataTableEntry->InInitializationOrderLinks);
    }

    if ((NewImportDescriptor->TimeDateStamp != DataTableEntry->TimeDateStamp) ||
        (DataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE)) {

        if (ShowSnaps) {
            DbgPrint("LDR: %wZ has stale binding to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);
        }

        StaleBinding = TRUE;
    } else {
#if DBG
        LdrpSnapBypass += 1;
#endif
        if (ShowSnaps) {
            DbgPrint("LDR: %wZ has correct binding to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);
        }

        StaleBinding = FALSE;
    }

    NewImportForwarder = (PCIMAGE_BOUND_FORWARDER_REF) (NewImportDescriptor + 1);
    for (i=0; i<NewImportDescriptor->NumberOfModuleForwarderRefs; i++) {
        NewFwdImportName = NewImportStringBase + NewImportForwarder->OffsetModuleName;
        if (ShowSnaps) {
            DbgPrint("LDR: %wZ bound to %s via forwarder(s) from %wZ\n",
                &LdrDataTableEntry->BaseDllName,
                NewFwdImportName,
                &DataTableEntry->BaseDllName);
        }

        st = LdrpLoadImportModule (DllPath,
                                   NewFwdImportName,
                                   &FwdDataTableEntry,
                                   &AlreadyLoaded);

        if ( NT_SUCCESS(st) ) {
            if (!AlreadyLoaded) {
                InsertTailList (&PebLdr.InInitializationOrderModuleList,
                                &FwdDataTableEntry->InInitializationOrderLinks);
            }
        }

        if ( (!NT_SUCCESS(st)) ||
             (NewImportForwarder->TimeDateStamp != FwdDataTableEntry->TimeDateStamp) ||
             (FwdDataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE)) {

            if (ShowSnaps) {
                DbgPrint("LDR: %wZ has stale binding to %s\n", &LdrDataTableEntry->BaseDllName, NewFwdImportName);
            }

            StaleBinding = TRUE;
        } else {
#if DBG
            LdrpSnapBypass += 1;
#endif
            if (ShowSnaps) {
                DbgPrint("LDR: %wZ has correct binding to %s\n",
                        &LdrDataTableEntry->BaseDllName,
                        NewFwdImportName);
            }
        }

        NewImportForwarder += 1;
    }

    NewImportDescriptor = (PCIMAGE_BOUND_IMPORT_DESCRIPTOR) NewImportForwarder;

    if (StaleBinding) {
#if DBG
        LdrpNormalSnap += 1;
#endif
        //
        // Find the unbound import descriptor that matches this bound
        // import descriptor
        //

        ImportDescriptor = (PCIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize);

        ImportName = NULL;
        while (ImportDescriptor->Name != 0) {
            ImportName = (PCSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);
            if (_stricmp(ImportName, NewImportName) == 0) {
                break;
            }

            ImportDescriptor += 1;
        }

        if (ImportDescriptor->Name == 0) {
            if (ShowSnaps) {
                DbgPrint("LDR: LdrpWalkImportTable - failing with STATUS_OBJECT_NAME_INVALID due to no import descriptor name\n");
            }

            st = STATUS_OBJECT_NAME_INVALID;
            goto Exit;
        }

        if (ShowSnaps) {
            DbgPrint("LDR: Stale Bind %s from %wZ\n", ImportName, &LdrDataTableEntry->BaseDllName);
        }

        st = LdrpSnapIAT (DataTableEntry,
                          LdrDataTableEntry,
                          ImportDescriptor,
                          FALSE);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: LdrpWalkImportTable - LdrpSnapIAT failed with status %x\n", st);
            }
            
            goto Exit;
        }
    }

    st = STATUS_SUCCESS;

Exit:
    *NewImportDescriptorInOut = NewImportDescriptor;
    return st;
}


NTSTATUS
LdrpHandleNewFormatImportDescriptors (
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PCIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor
    )
{
    NTSTATUS st;
    PCSZ NewImportStringBase;

    NewImportStringBase = (PCSZ) NewImportDescriptor;

    while (NewImportDescriptor->OffsetModuleName) {

        st = LdrpHandleOneNewFormatImportDescriptor (DllPath,
                                                     LdrDataTableEntry,
                                                     &NewImportDescriptor,
                                                     NewImportStringBase);

        if (!NT_SUCCESS(st)) {
            return st;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LdrpHandleOneOldFormatImportDescriptor (
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PCIMAGE_IMPORT_DESCRIPTOR *ImportDescriptorInOut
    )
{
    NTSTATUS st;
    PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = *ImportDescriptorInOut;
    PIMAGE_THUNK_DATA FirstThunk = NULL;
    PCSTR ImportName = NULL;
    PLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    BOOLEAN AlreadyLoaded = FALSE;
    BOOLEAN SnapForwardersOnly = FALSE;

    ImportName = (PCSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);

    //
    // check for import that has no references
    //

    FirstThunk = (PIMAGE_THUNK_DATA) ((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->FirstThunk);

    if (FirstThunk->u1.Function != 0) {

        if (ShowSnaps) {
            DbgPrint("LDR: %s used by %wZ\n", ImportName, &LdrDataTableEntry->BaseDllName);
        }

        st = LdrpLoadImportModule (DllPath,
                                   ImportName,
                                   &DataTableEntry,
                                   &AlreadyLoaded);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps)
                DbgPrint("LDR: LdrpWalkImportTable - LdrpLoadImportModule failed on import %s with status %x\n", ImportName, st);

            goto Exit;
        }

        if (ShowSnaps) {
            DbgPrint("LDR: Snapping imports for %wZ from %s\n", &LdrDataTableEntry->BaseDllName, ImportName);
        }

        //
        // If the image has been bound and the import date stamp
        // matches the date time stamp in the export modules header,
        // and the image was mapped at it's prefered base address,
        // then we are done.
        //

        SnapForwardersOnly = FALSE;

#if DBG
        LdrpNormalSnap++;
#endif
        //
        // Add to initialization list.
        //

        if (!AlreadyLoaded) {
            InsertTailList (&PebLdr.InInitializationOrderModuleList,
                            &DataTableEntry->InInitializationOrderLinks);
        }

        st = LdrpSnapIAT (DataTableEntry,
                          LdrDataTableEntry,
                          ImportDescriptor,
                          SnapForwardersOnly);

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: LdrpWalkImportTable - LdrpSnapIAT #2 failed with status %x\n", st);
            }

            goto Exit;
        }
    }

    ImportDescriptor += 1;

    st = STATUS_SUCCESS;
Exit:
    *ImportDescriptorInOut = ImportDescriptor;
    return st;
}


NTSTATUS
LdrpHandleOldFormatImportDescriptors(
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;

    //
    // For each DLL used by this DLL, load the dll. Then snap
    // the IAT, and call the DLL's init routine.
    //

    while (ImportDescriptor->Name && ImportDescriptor->FirstThunk) {
        st = LdrpHandleOneOldFormatImportDescriptor(DllPath, LdrDataTableEntry, &ImportDescriptor);
        if (!NT_SUCCESS(st))
            goto Exit;
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}


NTSTATUS
LdrpMungHeapImportsForTagging (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;
    USHORT TagIndex;

    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to RtlAllocateHeap.  If so
    // replace when with a pointer to a unique thunk function that will
    // replace the tag with a unique tag for this image.
    //

    IATBase = RtlImageDirectoryEntryToData (LdrDataTableEntry->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize);

    if (IATBase == NULL) {
        return STATUS_SUCCESS;
    }

    BigIATSize = LittleIATSize;

    st = NtProtectVirtualMemory (NtCurrentProcess(),
                                 &IATBase,
                                 &BigIATSize,
                                 PAGE_READWRITE,
                                 &OldProtect);

    if (!NT_SUCCESS(st)) {
        DbgPrint( "LDR: Unable to unprotect IAT to enable tagging by DLL.\n");
        return STATUS_SUCCESS;
    }

    ProcAddresses = (PVOID *)IATBase;
    NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));

    while (NumberOfProcAddresses--) {
        if (*ProcAddresses == RtlAllocateHeap) {
            *ProcAddresses = LdrpDefineDllTag(LdrDataTableEntry->BaseDllName.Buffer, &TagIndex);
            if (*ProcAddresses == NULL) {
                *ProcAddresses = (PVOID) (ULONG_PTR) RtlAllocateHeap;
            }
        }

        ProcAddresses += 1;
    }

    NtProtectVirtualMemory (NtCurrentProcess(),
                            &IATBase,
                            &BigIATSize,
                            OldProtect,
                            &OldProtect);

    return STATUS_SUCCESS;
}


NTSTATUS
LdrpWalkImportDescriptor (
    IN PCWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )

/*++

Routine Description:

    This is a recursive routine which walks the Import Descriptor
    Table and loads each DLL that is referenced.

Arguments:

    DllPath - Supplies an optional search path to be used to locate
        the DLL.

    LdrDataTableEntry - Supplies the address of the data table entry
        to initialize.

Return Value:

    Status value.

--*/

{
    ULONG ImportSize, NewImportSize;
    PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = NULL;
    PCIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor = NULL;
    NTSTATUS st = STATUS_SUCCESS;
    PPEB Peb = NtCurrentPeb();
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    CONST PLDR_DATA_TABLE_ENTRY Entry = LdrDataTableEntry;

    if (LdrpManifestProberRoutine != NULL) {

        PVOID SavedEntry = PebLdr.EntryInProgress;

        __try {

            //
            // don't check .exes that have id 1 manifest, id 1 in an .exe makes Peb->ActivationContextData not NULL
            //
            if (Peb->ActivationContextData == NULL || LdrDataTableEntry != LdrpImageEntry) {
                CONST PVOID ViewBase = LdrDataTableEntry->DllBase;
                PVOID ResourceViewBase = ViewBase;
                NTSTATUS stTemp;
                PCWSTR DllName;
#if defined(_WIN64)
                SIZE_T ReturnLength;
                MEMORY_BASIC_INFORMATION MemoryInformation;
                PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ViewBase);

                if (NtHeaders->OptionalHeader.SectionAlignment < NativePageSize) {
                    stTemp = NtQueryVirtualMemory (NtCurrentProcess(),
                                                   ViewBase,
                                                   MemoryBasicInformation,
                                                   &MemoryInformation,
                                                   sizeof MemoryInformation,
                                                      &ReturnLength);

                    if ((! NT_SUCCESS(stTemp)) ||
                        ((MemoryInformation.Protect != PAGE_READONLY) &&
                        (MemoryInformation.Protect != PAGE_EXECUTE_READ))) {

                        ResourceViewBase = LDR_VIEW_TO_DATAFILE(ViewBase);
                    }
                }
#endif
                DllName = Entry->FullDllName.Buffer;
                //
                // RtlCreateUserProcess() causes this.
                //

                if (LdrDataTableEntry == LdrpImageEntry &&
                    DllName[0] == L'\\' &&
                    DllName[1] == L'?' &&
                    DllName[2] == L'?' &&
                    DllName[3] == L'\\' &&
                    DllName[4] != UNICODE_NULL &&
                    DllName[5] == ':' &&
                    DllName[6] == L'\\'
                    ) {
                    DllName += 4;
                }

                PebLdr.EntryInProgress = Entry;

                stTemp = (*LdrpManifestProberRoutine)(ResourceViewBase, DllName, &Entry->EntryPointActivationContext);
                if (!NT_SUCCESS(stTemp)) {
                    if ((stTemp != STATUS_NO_SUCH_FILE) &&
                        (stTemp != STATUS_RESOURCE_DATA_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_TYPE_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_LANG_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_NAME_NOT_FOUND)) {
                        DbgPrintEx(
                            DPFLTR_SXS_ID,
                            DPFLTR_ERROR_LEVEL,
                            "LDR: LdrpWalkImportDescriptor() failed to probe %wZ for its manifest, ntstatus 0x%08lx\n", &LdrDataTableEntry->FullDllName, stTemp);
                        st = stTemp;
                        __leave;
                    }
                }
            }
        } __finally {
            PebLdr.EntryInProgress = SavedEntry;
        }
    }

    if (!NT_SUCCESS(st)) {
        goto Exit;
    }

    // If we didn't start a private activation context for the DLL, let's use the currently/previously active one.
    if (Entry->EntryPointActivationContext == NULL) {
        st = RtlGetActiveActivationContext((PACTIVATION_CONTEXT *) &LdrDataTableEntry->EntryPointActivationContext);
        if (!NT_SUCCESS(st)) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "LDR: RtlGetActiveActivationContext() failed; ntstatus = 0x%08lx\n", st);
#endif
            goto Exit;
        }
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, LdrDataTableEntry->EntryPointActivationContext);

    __try {
        //
        // See if there is a bound import table.  If so, walk that to
        // verify if the binding is good.  If so, then succeed with
        // having touched the .idata section, as all the information
        // in the bound imports table is stored in the header.  If any
        // are stale, then fall out into the unbound case.
        //

        //
        // NOTICE-2000/09/30-JayKrell
        // Don't allow binding to redirected .dlls, because the Bind machinery
        // is too weak. It breaks when different files with the same leaf name
        // are built at the same time. This has been seen to happen,
        // with comctl32.dll and comctlv6.dll.
        //
        if ((LdrDataTableEntry->Flags & LDRP_REDIRECTED) == 0) {
            NewImportDescriptor = (PCIMAGE_BOUND_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                                   LdrDataTableEntry->DllBase,
                                   TRUE,
                                   IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                                   &NewImportSize
                                   );
        }

        ImportDescriptor = (PCIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize
                            );


        if (NewImportDescriptor != NULL) {
            st = LdrpHandleNewFormatImportDescriptors(DllPath, LdrDataTableEntry, NewImportDescriptor);
            if (!NT_SUCCESS(st)) {
                __leave;
            }
        } else if (ImportDescriptor != NULL) {
            st = LdrpHandleOldFormatImportDescriptors(DllPath, LdrDataTableEntry, ImportDescriptor);
            if (!NT_SUCCESS(st)) {
                __leave;
            }
        }

        if (Peb->NtGlobalFlag & FLG_HEAP_ENABLE_TAG_BY_DLL) {
            st = LdrpMungHeapImportsForTagging(LdrDataTableEntry);
            if (!NT_SUCCESS(st)) {
                __leave;
            }
        }

        //
        // Notify page heap per dll part of verifier that a dll got loaded.
        // It is important to call this before the main verifier hook so that
        // heap related imports are redirected before any redirection from
        // verifier providers. In time all this logic should move into
        // verifier.dll.
        //

        if (Peb->NtGlobalFlag & FLG_HEAP_PAGE_ALLOCS) {
            st = AVrfPageHeapDllNotification (LdrDataTableEntry);

            if (!NT_SUCCESS(st)) {
                __leave;
            }
        }

        //
        // Notify verifier that a dll got loaded.
        //

        if (Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
            st = AVrfDllLoadNotification (LdrDataTableEntry);

            if (!NT_SUCCESS(st)) {
                __leave;
            }
        }
        st = STATUS_SUCCESS;
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }

Exit:
    return st;
}


ULONG
LdrpClearLoadInProgress (
    VOID
    )
{
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    ULONG i;

    i = 0;
    Head = &PebLdr.InInitializationOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        LdrDataTableEntry = CONTAINING_RECORD (Next,
                                               LDR_DATA_TABLE_ENTRY,
                                               InInitializationOrderLinks);

        LdrDataTableEntry->Flags &= ~LDRP_LOAD_IN_PROGRESS;

        //
        // Return the number of entries that have not been processed, but
        // have init routines.
        //

        if (!(LdrDataTableEntry->Flags & LDRP_ENTRY_PROCESSED) && LdrDataTableEntry->EntryPoint) {
            i += 1;
        }

        Next = Next->Flink;
    }
    return i;
}


NTSTATUS
LdrpRunInitializeRoutines (
    IN PCONTEXT Context OPTIONAL
    )
{
    PPEB Peb;
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PLDR_DATA_TABLE_ENTRY *LdrDataTableBase;
    PDLL_INIT_ROUTINE InitRoutine;
    BOOLEAN InitStatus;
    ULONG NumberOfRoutines;
    ULONG i;
    NTSTATUS Status;
    ULONG BreakOnDllLoad;
    PLDR_DATA_TABLE_ENTRY StackLdrDataTable[16];
    PTEB OldTopLevelDllBeingLoadedTeb;

    LdrpEnsureLoaderLockIsHeld();

    //
    // Run the Init routines
    // Capture the entries that have init routines
    //

    NumberOfRoutines = LdrpClearLoadInProgress();

    if (NumberOfRoutines != 0) {
        if (NumberOfRoutines <= RTL_NUMBER_OF(StackLdrDataTable)) {
            LdrDataTableBase = StackLdrDataTable;
        }
        else {
            LdrDataTableBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TEMP_TAG), NumberOfRoutines * sizeof(PLDR_DATA_TABLE_ENTRY));
            if (LdrDataTableBase == NULL) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed to allocate dynamic array of %u DLL initializers to run\n",
                    __FUNCTION__,
                    NumberOfRoutines);

                return STATUS_NO_MEMORY;
            }
        }
    } else {
        LdrDataTableBase = NULL;
    }

    Peb = NtCurrentPeb ();

    Head = &PebLdr.InInitializationOrderModuleList;
    Next = Head->Flink;

    if (ShowSnaps || LdrpShowInitRoutines) {
        DbgPrint("[%x,%x] LDR: Real INIT LIST for process %wZ pid %u 0x%x\n",
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
            &Peb->ProcessParameters->ImagePathName,
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess)
            );
    }

    i = 0;
    while ( Next != Head ) {
        LdrDataTableEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        if (LdrDataTableBase && !(LdrDataTableEntry->Flags & LDRP_ENTRY_PROCESSED) && LdrDataTableEntry->EntryPoint) {
            ASSERT(i < NumberOfRoutines);
            LdrDataTableBase[i] = LdrDataTableEntry;

            if (ShowSnaps || LdrpShowInitRoutines) {
                DbgPrint("[%x,%x]    %wZ init routine %p\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                    &LdrDataTableEntry->FullDllName,
                    LdrDataTableEntry->EntryPoint);
            }

            i++;
        }
        LdrDataTableEntry->Flags |= LDRP_ENTRY_PROCESSED;

        Next = Next->Flink;
    }

    ASSERT(i == NumberOfRoutines);

    if (LdrDataTableBase == NULL) {
        return STATUS_SUCCESS;
    }

    i = 0;

    OldTopLevelDllBeingLoadedTeb = LdrpTopLevelDllBeingLoadedTeb;
    LdrpTopLevelDllBeingLoadedTeb = NtCurrentTeb();

    //
    // If we are in LdrpInitializeProcess then call into
    // kernel32.dll's "post import" function so Terminal Server can do
    // various patching of import address tables.
    //
    if (Context != NULL &&
        Kernel32ProcessInitPostImportFunction != NULL) {

        PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION LocalFunction;

        LocalFunction = Kernel32ProcessInitPostImportFunction;
        Kernel32ProcessInitPostImportFunction = NULL;

        if (LocalFunction != NULL) {
            Status = (*LocalFunction)();

            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - Failed running kernel32 post-import function; status 0x%08lx\n",
                    __FUNCTION__,
                    Status);

                return Status;
            }
        }
    }

    Status = STATUS_SUCCESS;
    try {
        while ( i < NumberOfRoutines ) {
            LdrDataTableEntry = LdrDataTableBase[i];
            i += 1;
            InitRoutine = (PDLL_INIT_ROUTINE)(ULONG_PTR)LdrDataTableEntry->EntryPoint;

            //
            // Walk through the entire list looking for un-processed
            // entries. For each entry, set the processed flag
            // and optionally call it's init routine
            //

            BreakOnDllLoad = 0;
#if DBG
            if (TRUE)
#else
            if (Peb->BeingDebugged || Peb->ReadImageFileExecOptions)
#endif
            {
                Status = LdrQueryImageFileExecutionOptions( &LdrDataTableEntry->BaseDllName,
                                                            L"BreakOnDllLoad",
                                                            REG_DWORD,
                                                            &BreakOnDllLoad,
                                                            sizeof( BreakOnDllLoad ),
                                                            NULL
                                                          );
                if (!NT_SUCCESS( Status )) {
                    BreakOnDllLoad = 0;
                    Status = STATUS_SUCCESS;
                }
            }

            if (BreakOnDllLoad) {
                if (ShowSnaps) {
                    DbgPrint( "LDR: %wZ loaded.", &LdrDataTableEntry->BaseDllName );
                    DbgPrint( " - About to call init routine at %p\n", InitRoutine );
                }
                DbgBreakPoint();

            } else if (ShowSnaps) {
                if ( InitRoutine ) {
                    DbgPrint( "[%x,%x] LDR: %wZ loaded",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                        &LdrDataTableEntry->BaseDllName);

                    DbgPrint(" - Calling init routine at %p\n", InitRoutine);
                }
            }

            if ( InitRoutine ) {
                PLDR_DATA_TABLE_ENTRY SavedInitializer = LdrpCurrentDllInitializer;
                LdrpCurrentDllInitializer = LdrDataTableEntry;

                InitStatus = FALSE;

                __try {
                    LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                    //
                    // If the DLL has TLS data, then call the optional initializers
                    //
                    if ((LdrDataTableEntry->TlsIndex != 0) && (Context != NULL))
                        LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_PROCESS_ATTACH);

                    if (LdrpShowInitRoutines) {
                        DbgPrint("[%x,%x] LDR: calling init routine %p for DLL_PROCESS_ATTACH\n",
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                            InitRoutine);
                    }

                    InitStatus = LdrpCallInitRoutine(InitRoutine,
                                                     LdrDataTableEntry->DllBase,
                                                     DLL_PROCESS_ATTACH,
                                                     Context);
                    LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                } __finally {
                    LdrpCurrentDllInitializer = SavedInitializer;
                }

                LdrDataTableEntry->Flags |= LDRP_PROCESS_ATTACH_CALLED;

                if (!InitStatus) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "[%x,%x] LDR: DLL_PROCESS_ATTACH for dll \"%wZ\" (InitRoutine: %p) failed\n",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                        &LdrDataTableEntry->FullDllName,
                        InitRoutine);

                    Status = STATUS_DLL_INIT_FAILED;
                    __leave;
                }
            }
        }

        //
        // If the image has tls than call its initializers
        //

        if (LdrpImageHasTls && (Context != NULL))
        {
            LDRP_ACTIVATE_ACTIVATION_CONTEXT (LdrpImageEntry);

            LdrpCallTlsInitializers (Peb->ImageBaseAddress,DLL_PROCESS_ATTACH);

            LDRP_DEACTIVATE_ACTIVATION_CONTEXT ();
        }
    } finally {
        LdrpTopLevelDllBeingLoadedTeb = OldTopLevelDllBeingLoadedTeb;

        if ((LdrDataTableBase != NULL) &&
            (LdrDataTableBase != StackLdrDataTable)) {

            RtlFreeHeap(RtlProcessHeap(),0,LdrDataTableBase);
        }
    }

    return Status;
}

NTSTATUS
LdrpResolveFullName(
    IN PCUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING StaticString,
    IN OUT PUNICODE_STRING DynamicString,
    OUT PUNICODE_STRING *StringUsed
    )
{
    BOOLEAN NameInvalid;
    RTL_PATH_TYPE InputPathType;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD Length;

    if (ShowSnaps) {
        DbgPrintEx(DPFLTR_LDR_ID,
                   LDR_ERROR_DPFLTR,
                   "LDR: %s - Expanding full name of %wZ\n",
                   __FUNCTION__,
                   FileName);
    }

    RtlAcquirePebLock();

    // Try with static buffer first
    Length = RtlGetFullPathName_Ustr(FileName,
                                     StaticString->MaximumLength,
                                     StaticString->Buffer,
                                     NULL,
                                     &NameInvalid,
                                     &InputPathType);

    if (!Length || UNICODE_STRING_MAX_BYTES < Length) {
        Status = STATUS_DLL_NOT_FOUND;
    } else if (Length < StaticString->MaximumLength) {
        *StringUsed = StaticString;
        StaticString->Length = (USHORT) Length;
    } else {

        // Didn't work -- try dynamic buffer.  Subtract off a char
        // because LdrpAllocateUnicodeString takes the length of the
        // string without the trailing NULL, and
        // RtlGetFullPathName_Ustr includes the trailing NULL.

        ASSERT(Length >= sizeof(WCHAR));
        Status = LdrpAllocateUnicodeString(DynamicString, (USHORT)Length - sizeof(WCHAR));
        if (NT_SUCCESS(Status)) {
            Length = RtlGetFullPathName_Ustr(FileName,
                                             DynamicString->MaximumLength,
                                             DynamicString->Buffer,
                                             NULL,
                                             &NameInvalid,
                                             &InputPathType);
            if (!Length || DynamicString->MaximumLength <= Length) {
                LdrpFreeUnicodeString(DynamicString);
                Status = STATUS_DLL_NOT_FOUND;
            } else {
                *StringUsed = DynamicString;
                DynamicString->Length = (USHORT) Length;
            }
        }
    }

    RtlReleasePebLock();

    if (ShowSnaps) {
        if (NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_LDR_ID,
                       LDR_ERROR_DPFLTR,
                       "LDR: %s - Expanded to %wZ\n",
                       __FUNCTION__,
                       *StringUsed);
        } else {
            DbgPrintEx(DPFLTR_LDR_ID,
                       LDR_ERROR_DPFLTR,
                       "LDR: %s - Failed to expand %wZ; 0x%08x\n",
                       __FUNCTION__,
                       FileName,
                       Status);
        }
    }

    if (! NT_SUCCESS(Status)) {
        *StringUsed = NULL;
    }

    return Status;
}

NTSTATUS
LdrpSearchPath(
    IN PCWSTR lpPath,
    IN PCWSTR lpFileName,
    IN OUT PUNICODE_STRING StaticString,
    IN OUT PUNICODE_STRING DynamicString,
    OUT PUNICODE_STRING *StringUsed
    )
{
    PCWSTR EltStart, EltEnd, NamePtr;
    PWSTR Buffer = NULL, BufEnd;
    ULONG BufferCchLen;
    ULONG FileCchLen;
    NTSTATUS Status;
    UNICODE_STRING TestName;
    BOOLEAN FoundInPath = FALSE;
    BOOLEAN FoundEnd = FALSE;

    if (! ARGUMENT_PRESENT(lpPath)) {
        lpPath = LdrpDefaultPath.Buffer;
    }

    if (ShowSnaps) {
        DbgPrintEx(DPFLTR_LDR_ID,
                   LDR_ERROR_DPFLTR,
                   "LDR: %s - Looking for %ws in %ws\n",
                   __FUNCTION__,
                   lpFileName,
                   lpPath);
    }

    if (RtlDetermineDosPathNameType_U(lpFileName) != RtlPathTypeRelative) {

        Status = RtlInitUnicodeStringEx(&TestName, lpFileName);
        if (! NT_SUCCESS(Status)) {
            goto cleanup;
        }

        if (! RtlDoesFileExists_UstrEx(&TestName, TRUE)) {
            Status = STATUS_DLL_NOT_FOUND;
            goto cleanup;
        }

        Status = LdrpResolveFullName(&TestName,
                                     StaticString,
                                     DynamicString,
                                     StringUsed);
        goto cleanup;
    }

    BufferCchLen = 0;

    // For each ';' or NULL-terminated element, find the length; save
    // the max length found.
    EltStart = EltEnd = lpPath;
    for (;;) {
        if (! *EltEnd || *EltEnd == L';') {
            if (BufferCchLen < ((ULONG)(EltEnd - EltStart))) {
                BufferCchLen = ((ULONG)(EltEnd - EltStart));
            }
            EltStart = EltEnd + 1;
        }

        if (! *EltEnd) {
            break;
        }

        EltEnd++;
    }

    // Add in the length of the file name, a char for a '\', and a
    // char for the trailing NULL.
    FileCchLen = (LONG) wcslen(lpFileName);
    BufferCchLen += FileCchLen + 2;

    if (UNICODE_STRING_MAX_CHARS < BufferCchLen) {
        Status = STATUS_NAME_TOO_LONG;
        goto cleanup;
    }

    // Allocate the buffer
    Buffer = RtlAllocateHeap(RtlProcessHeap(),
                             0,
                             BufferCchLen * sizeof(WCHAR));
    if (! Buffer) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    RtlInitEmptyUnicodeString(&TestName,
                              Buffer,
                              BufferCchLen * sizeof(WCHAR));

    // For each ';' or NULL-terminated path element, copy it into our
    // buffer, and see if it exists.
    EltStart = EltEnd = lpPath;
    BufEnd = Buffer;

    Status = STATUS_NOT_FOUND;

    while (!FoundEnd && !FoundInPath) {
        if (! *EltEnd || *EltEnd == L';') {
            if (EltEnd != EltStart) { // ignore empty elements
                ASSERT(BufEnd > Buffer);
                if (BufEnd[-1] != L'\\') {
                    *BufEnd++ = L'\\';
                }
                NamePtr = lpFileName;

                while (*NamePtr) {
                    *BufEnd++ = *NamePtr++;
                }
                *BufEnd = UNICODE_NULL;

                if (ShowSnaps) {
                    DbgPrintEx(DPFLTR_LDR_ID,
                               LDR_ERROR_DPFLTR,
                               "LDR: %s - Looking for %ws\n",
                               __FUNCTION__,
                               Buffer);
                }
                TestName.Length = (USHORT)((BufEnd - Buffer) * sizeof(WCHAR));
                ASSERT(TestName.Length < TestName.MaximumLength);

                if (RtlDoesFileExists_UstrEx(&TestName, FALSE)) {
                    TestName.MaximumLength = (USHORT)((BufEnd - Buffer + 1) * sizeof(WCHAR));
                    TestName.Buffer = RtlReAllocateHeap(RtlProcessHeap(),
                                                        0,
                                                        Buffer,
                                                        TestName.MaximumLength);
                    if (! TestName.Buffer) {
                        TestName.Buffer = Buffer;
                    } else {
                        Buffer = TestName.Buffer;
                    }
                    ASSERT(TestName.Buffer);
                    FoundInPath = TRUE;
                    break;
                }
                BufEnd = Buffer;
            }
            EltStart = EltEnd + 1;
        } else {
            *BufEnd++ = *EltEnd;
        }

        if (! *EltEnd) {
            FoundEnd = TRUE;
        }

        EltEnd++;
    }

    if (FoundInPath) {
        Status = LdrpResolveFullName(&TestName,
                                     StaticString,
                                     DynamicString,
                                     StringUsed);
    }

cleanup:
    if (Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
    }

    if (! NT_SUCCESS(Status)) {
        *StringUsed = NULL;
    }

    if (ShowSnaps) {
        if (NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_LDR_ID,
                       LDR_ERROR_DPFLTR,
                       "LDR: %s - Returning %Z\n",
                       __FUNCTION__,
                       *StringUsed);
        } else {
            DbgPrintEx(DPFLTR_LDR_ID,
                       LDR_ERROR_DPFLTR,
                       "LDR: %s - Unable to locate %ws in %ws: 0x%08x\n",
                       __FUNCTION__,
                       lpFileName,
                       lpPath,
                       Status);
        }
    }

    return Status;
}

BOOLEAN
LdrpCheckForLoadedDll (
    IN PCWSTR DllPath OPTIONAL,
    IN PCUNICODE_STRING DllName,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This function scans the loader data table looking to see if
    the specified DLL has already been mapped into the image. If
    the dll has been loaded, the address of its data table entry
    is returned.

Arguments:

    DllPath - Supplies an optional search path used to locate the DLL.

    DllName - Supplies the name to search for.

    StaticLink - TRUE if performing a static link.

    LdrDataTableEntry - Returns the address of the loader data table
        entry that describes the first dll section that implements the
        dll.

Return Value:

    TRUE- The dll is already loaded.  The address of the data table
        entries that implement the dll, and the number of data table
        entries are returned.

    FALSE - The dll is not already mapped.

--*/

{
    HANDLE CurrentProcess;
    BOOLEAN Result = FALSE;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head, Next;
    PUNICODE_STRING FullDllName;
    BOOLEAN HardCodedPath;
    PWCH p;
    ULONG i;
    WCHAR FullDllNameStaticBuffer[40]; // Arbitrary short length so most
                                       // d:\windows\system32\foobar.dll loads
                                       // don't need to search the search path twice
    UNICODE_STRING FullDllNameStaticString;
    UNICODE_STRING FullDllNameDynamicString;
    NTSTATUS Status;

    RtlInitEmptyUnicodeString(&FullDllNameStaticString,
                              FullDllNameStaticBuffer,
                              sizeof(FullDllNameStaticBuffer));

    RtlInitUnicodeString(&FullDllNameDynamicString, NULL);

    FullDllName = NULL;

    if (!DllName->Buffer || !DllName->Buffer[0]) {
        return FALSE;
    }

    Status = STATUS_SUCCESS;

    //
    // for static links, just go to the hash table
    //

staticlink:

    if (StaticLink) {

        //
        // If this is a redirected static load, the dll name is a
        // fully qualified path.  The hash table is maintained based on
        // the first character of the base dll name, so find the base dll name.
        //

        if (Redirected) {

            PWSTR LastChar;

            LastChar = DllName->Buffer + (DllName->Length / sizeof(WCHAR)) - (DllName->Length == 0 ? 0 : 1);

            while (LastChar != DllName->Buffer) {
                const WCHAR wch = *LastChar;

                if ((wch == L'\\') || (wch == L'/'))
                    break;

                LastChar -= 1;
            }

            //
            // This assert ignores the "possibility" that the first and
            // only slash is the first character, but that's
            // an error, too.  The redirection should be a complete DOS path.
            //

            ASSERTMSG(
                "Redirected DLL name does not have full path; either caller lied or redirection info is in error",
                LastChar != DllName->Buffer);

            if (LastChar == DllName->Buffer) {
                if (ShowSnaps) {
                    DbgPrint("LDR: Failing LdrpCheckForLoadedDll because redirected DLL name %wZ does not include a slash\n", DllName);
                }

                Result = FALSE;
                goto alldone;
            }

            LastChar += 1;

            i = LDRP_COMPUTE_HASH_INDEX(*LastChar);
        } else {
            i = LDRP_COMPUTE_HASH_INDEX(DllName->Buffer[0]);
        }

        Head = &LdrpHashTable[i];
        Next = Head->Flink;
        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, HashLinks);
#if DBG
            LdrpCompareCount += 1;
#endif            
            //
            // Redirected static loads never match unredirected entries
            // and vice versa.
            //

            if (Redirected) {
                if (((Entry->Flags & LDRP_REDIRECTED) != 0) &&
                    RtlEqualUnicodeString(DllName, &Entry->FullDllName, TRUE)) {
                    *LdrDataTableEntry = Entry;
                    Result = TRUE;
                    goto alldone;
                }
            } else {
                // Not redirected...
                if (((Entry->Flags & LDRP_REDIRECTED) == 0) &&
                    RtlEqualUnicodeString(DllName, &Entry->BaseDllName, TRUE)) {
                    *LdrDataTableEntry = Entry;
                    Result = TRUE;
                    goto alldone;
                }
            }

            Next = Next->Flink;
        }
        Result = FALSE;
        goto alldone;
    }

    //
    // If the DLL name contained a hard coded path
    // (dynamic link only), then the fully qualified
    // name needs to be compared to make sure we
    // have the correct DLL.
    //

    p = DllName->Buffer;
    HardCodedPath = FALSE;

    if (Redirected) {
        HardCodedPath = TRUE;
        FullDllNameStaticString.Length = DllName->Length;
        FullDllNameStaticString.MaximumLength = DllName->MaximumLength;
        FullDllNameStaticString.Buffer = DllName->Buffer;
        FullDllName = &FullDllNameStaticString;
    } else {
        while (*p) {
            const WCHAR wch = *p++;
            if (wch == (WCHAR)'\\' || wch == (WCHAR)'/' ) {

                HardCodedPath = TRUE;

                //
                // We have a hard coded path, so we have to search path
                // for the DLL. We need the full DLL name.
                //

                Status = LdrpSearchPath(DllPath,
                                        DllName->Buffer,
                                        &FullDllNameStaticString,
                                        &FullDllNameDynamicString,
                                        &FullDllName);

                if (! NT_SUCCESS(Status)) {
                    if (ShowSnaps) {
                        DbgPrint("LDR: LdrpCheckForLoadedDll - Unable To Locate "
                                 "%ws: 0x%08x\n",
                                 DllName->Buffer,
                                 Status);
                    }

                    Result = FALSE;
                    goto alldone;
                }

                break;
            }
        }
    }

    //
    // If this is a dynamic load lib, and there is not a hard
    // coded path, then go to the static lib hash table for resolution
    //

    if ( !HardCodedPath ) {

        //
        // If we're redirecting this DLL, don't check if there's
        // another DLL by the same name already loaded.
        //

        if (NT_SUCCESS(RtlFindActivationContextSectionString(0, NULL, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, DllName, NULL))) {
            Result = FALSE;
            goto alldone;
        }

        StaticLink = TRUE;

        goto staticlink;
    }

    Result = FALSE;
    Head = &PebLdr.InLoadOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {
        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        //
        // When we unload, the memory order links flink field is nulled.
        // this is used to skip the entry pending list removal.
        //

        if (!Entry->InMemoryOrderLinks.Flink) {
            continue;
        }

        //
        // Since this is a full string comparison, we don't worry
        // about redirection - we don't want to load the dll from
        // a particular path more than once just because one of them
        // explicitly (and erroneously) specified the magic side-by-side
        // location of the DLL and the other loaded it via side-by-side
        // isolation automagically.
        //

        if (RtlEqualUnicodeString (FullDllName,
                                   &Entry->FullDllName,
                                   TRUE)) {

            Result = TRUE;
            *LdrDataTableEntry = Entry;
            break;
        }
    }

    if ( !Result ) {

        //
        // No names matched. This might be a long short name mismatch or
        // any kind of alias pathname. Deal with this by opening and mapping
        // full dll name and then repeat the scan this time checking for
        // timedatestamp matches
        //

        HANDLE File;
        HANDLE Section;
        NTSTATUS st;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatus;
        PVOID ViewBase;
        SIZE_T ViewSize;
        PIMAGE_NT_HEADERS NtHeadersSrc,NtHeadersE;
        UNICODE_STRING NtFileName;

        if (!RtlDosPathNameToNtPathName_U (FullDllName->Buffer,
                                           &NtFileName,
                                           NULL,
                                           NULL)) {
            goto alldone;
        }

        InitializeObjectAttributes (&ObjectAttributes,
                                    &NtFileName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        st = NtOpenFile (&File,
                         SYNCHRONIZE | FILE_EXECUTE,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
        RtlFreeHeap (RtlProcessHeap(), 0, NtFileName.Buffer);

        if (!NT_SUCCESS(st)) {
            goto alldone;
        }

        st = NtCreateSection(
                &Section,
                SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                NULL,
                NULL,
                PAGE_EXECUTE,
                SEC_COMMIT,
                File);

        NtClose (File);

        if (!NT_SUCCESS(st)) {
            goto alldone;
        }

        ViewBase = NULL;
        ViewSize = 0;

        CurrentProcess = NtCurrentProcess();

        st = NtMapViewOfSection (Section,
                                 CurrentProcess,
                                 (PVOID *)&ViewBase,
                                 0L,
                                 0L,
                                 NULL,
                                 &ViewSize,
                                 ViewShare,
                                 0L,
                                 PAGE_EXECUTE);

        NtClose(Section);

        if (!NT_SUCCESS(st)) {
            goto alldone;
        }

        //
        // The section is mapped. Now find the headers
        //
        
        st = RtlImageNtHeaderEx(0, ViewBase, ViewSize, &NtHeadersSrc);
        if (!NT_SUCCESS(st) || !NtHeadersSrc) {
            NtUnmapViewOfSection(CurrentProcess,ViewBase);
            goto alldone;
        }

        Head = &PebLdr.InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            Next = Next->Flink;

            //
            // When we unload, the memory order links flink field is nulled.
            // this is used to skip the entry pending list removal.
            //

            if ( !Entry->InMemoryOrderLinks.Flink ) {
                continue;
            }

            try {
                if (Entry->TimeDateStamp == NtHeadersSrc->FileHeader.TimeDateStamp &&
                    Entry->SizeOfImage == NtHeadersSrc->OptionalHeader.SizeOfImage ) {

                    //
                    // There is a very good chance we have an image match.
                    // Check the entire file header and optional header. If
                    // they match, declare this a match.
                    //

                    NtHeadersE = RtlImageNtHeader(Entry->DllBase);

                    if ( RtlCompareMemory(NtHeadersE,NtHeadersSrc,sizeof(*NtHeadersE)) == sizeof(*NtHeadersE) ) {

                        //
                        // Now that it looks like we have a match, compare
                        // volume serial numbers and file indexes.
                        //

                        st = NtAreMappedFilesTheSame(Entry->DllBase,ViewBase);

                        if ( !NT_SUCCESS(st) ) {
                            continue;
                        }
                        else {
                            Result = TRUE;
                            *LdrDataTableEntry = Entry;
                            break;
                        }
                    }
                }
            }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - Caught exception %08lx\n",
                    __FUNCTION__,
                    GetExceptionCode());

                break;
            }
        }
        NtUnmapViewOfSection(CurrentProcess,ViewBase);
    }

alldone:
    LdrpFreeUnicodeString(&FullDllNameDynamicString);

    return Result;
}


BOOLEAN
LdrpCheckForLoadedDllHandle (
    IN PVOID DllHandle,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This function scans the loader data table looking to see if
    the specified DLL has already been mapped into the image address
    space. If the dll has been loaded, the address of its data table
    entry that describes the dll is returned.

Arguments:

    DllHandle - Supplies the DllHandle of the DLL being searched for.

    LdrDataTableEntry - Returns the address of the loader data table
        entry that describes the dll.

Return Value:

    TRUE- The dll is loaded.  The address of the data table entry is
        returned.

    FALSE - The dll is not loaded.

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;

    if ( LdrpLoadedDllHandleCache &&
        (PVOID) LdrpLoadedDllHandleCache->DllBase == DllHandle ) {
        *LdrDataTableEntry = LdrpLoadedDllHandleCache;
        return TRUE;
    }

    Head = &PebLdr.InLoadOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        //
        // when we unload, the memory order links flink field is nulled.
        // this is used to skip the entry pending list removal.
        //

        if ( !Entry->InMemoryOrderLinks.Flink ) {
            continue;
        }

        if (DllHandle == (PVOID)Entry->DllBase ){
            LdrpLoadedDllHandleCache = Entry;
            *LdrDataTableEntry = Entry;
            return TRUE;
        }
    }
    return FALSE;
}


NTSTATUS
LdrpCheckCorImage (
    IN PIMAGE_COR20_HEADER Cor20Header,
    IN PCUNICODE_STRING FullDllName,
    IN OUT PVOID *ViewBase,
    OUT PBOOLEAN Cor20ILOnly
    )

{
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID OriginalViewBase = *ViewBase;

    
    if (Cor20Header) {

        //
        // The image is COM+ so notify the runtime that the image was loaded
        // and allow it to verify the image for correctness.
        //

        NtStatus = LdrpCorValidateImage(ViewBase, FullDllName->Buffer);
        if (!NT_SUCCESS (NtStatus)) {
            
            //
            // Image is bad, or mscoree failed, etc.
            //

            *ViewBase = OriginalViewBase;
            goto return_result;
        }
        
        //
        // Indicates it's an ILONLY image if the flag is set in the header.
        //

        if ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) == COMIMAGE_FLAGS_ILONLY) {
            *Cor20ILOnly = TRUE;
        }

        if (*ViewBase != OriginalViewBase) {
            
            //
            // Mscoree has substituted a new image at a new base in place
            // of the original image.  Unmap the original image and use
            // the new image from now on.
            //

            NtUnmapViewOfSection(NtCurrentProcess(), OriginalViewBase);
            NtHeaders = RtlImageNtHeader(*ViewBase);
            
            if (!NtHeaders) {
                NtStatus = STATUS_INVALID_IMAGE_FORMAT;
                goto return_result;
            }
        }
    }

return_result:

    return NtStatus;
}


NTSTATUS
LdrpMapDll (
    IN PCWSTR DllPath OPTIONAL,
    IN PCWSTR DllName,
    IN PULONG DllCharacteristics OPTIONAL,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This routine maps the DLL into the users address space.

Arguments:

    DllPath - Supplies an optional search path to be used to locate the DLL.

    DllName - Supplies the name of the DLL to load.

    StaticLink - TRUE if this DLL has a static link to it.

    LdrDataTableEntry - Supplies the address of the data table entry.

Return Value:

    Status value.

--*/

{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID ViewBase = NULL;
    const PTEB Teb = NtCurrentTeb();
    SIZE_T ViewSize;
    HANDLE Section, DllFile;
    UNICODE_STRING FullDllName, BaseDllName;
    UNICODE_STRING NtFileName;
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID ArbitraryUserPointer;
    BOOLEAN KnownDll;
    PCUNICODE_STRING CollidingDll = NULL;
    const static UNICODE_STRING DynamicallyAllocatedMemoryString = RTL_CONSTANT_STRING(L"Dynamically Allocated Memory");
    PUCHAR ImageBase, ImageBounds, ScanBase, ScanTop;
    PLDR_DATA_TABLE_ENTRY ScanEntry;
    PLIST_ENTRY ScanHead,ScanNext;
    BOOLEAN CollidingDllFound;
    NTSTATUS ErrorStatus;
    ULONG_PTR ErrorParameters[2];
    ULONG ErrorResponse;
    IMAGE_COR20_HEADER *Cor20Header;
    ULONG Cor20HeaderSize;
    BOOLEAN Cor20ILOnly = FALSE;
    PVOID OriginalViewBase = NULL;
    PWSTR AppCompatDllName = NULL;

    RtlZeroMemory (&BaseDllName, sizeof (UNICODE_STRING));
    FullDllName.Buffer = NULL;

    //
    // Get section handle of DLL being snapped
    //

#if LDRDBG
    if (ShowSnaps) {
        DbgPrint("LDR: LdrpMapDll: Image Name %ws, Search Path %ws\n",
                DllName,
                ARGUMENT_PRESENT(DllPath) ? DllPath : L""
                );
    }
#endif

    Entry = NULL;
    KnownDll = FALSE;
    Section = NULL;

    LdrpEnsureLoaderLockIsHeld();

    // No capturing etc. of the globals since we "know" that the loader lock is taken to synchronize access.
    if (LdrpAppCompatDllRedirectionCallbackFunction != NULL) {
        st = (*LdrpAppCompatDllRedirectionCallbackFunction)(
                0,              // Flags - reserved for the future
                DllName,
                DllPath,
                DllCharacteristics,
                LdrpAppCompatDllRedirectionCallbackData,
                &AppCompatDllName);
        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call back to app compat redirection function @ %p (cb data: %p) failed with status %x\n",
                __FUNCTION__,
                LdrpAppCompatDllRedirectionCallbackFunction,
                LdrpAppCompatDllRedirectionCallbackData,
                st);

            goto Exit;
        }

        if (AppCompatDllName != NULL) {
            Redirected = TRUE;
            DllName = AppCompatDllName;
        }
    }

    if ((LdrpKnownDllObjectDirectory != NULL) && !Redirected) {
        PCWCH p = DllName;
        WCHAR wch;

        //
        // Skip the KnownDll check if this is an explicit path.
        //

        while ((wch = *p) != L'\0') {
            p++;
            if (RTL_IS_PATH_SEPARATOR(wch))
                break;
        }

        // If we hit the end of the string, there must have not been a path separator.
        if (wch == L'\0') {
            st = LdrpCheckForKnownDll(DllName, &FullDllName, &BaseDllName, &Section);
            if ((!NT_SUCCESS(st)) && (st != STATUS_DLL_NOT_FOUND)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - call to LdrpCheckForKnownDll(\"%ws\", ...) failed with status %x\n",
                    __FUNCTION__,
                    DllName,
                    st);

                goto Exit;
            }
        }
    }

    if (Section == NULL) {
        st = LdrpResolveDllName(DllPath, DllName, Redirected, &FullDllName, &BaseDllName, &DllFile);
        //
        // NOTICE-2002/03/06-ELi
        // assuming DllFile is also NULL when returning from LdrpResolveDllName
        // not a handle leak in the error paths below
        //
        if (!NT_SUCCESS(st)) {
            if (st == STATUS_DLL_NOT_FOUND) {
                if (StaticLink) {
                    UNICODE_STRING ErrorDllName, ErrorDllPath;
                    PUNICODE_STRING ErrorStrings[2] = { &ErrorDllName, &ErrorDllPath };
                    ULONG xErrorResponse;

                    RtlInitUnicodeString(&ErrorDllName,DllName);
                    RtlInitUnicodeString(&ErrorDllPath,ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer);

                    NtRaiseHardError(
                        STATUS_DLL_NOT_FOUND,
                        2,              // Number of error strings
                        0x00000003,
                        (PULONG_PTR)ErrorStrings,
                        OptionOk,
                        &xErrorResponse);

                    if (LdrpInLdrInit)
                        LdrpFatalHardErrorCount++;
                }
            } else {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - call to LdrpResolveDllName on dll \"%ws\" failed with status %x\n",
                    __FUNCTION__,
                    DllName,
                    st);
            }



            goto Exit;
        }

        if (ShowSnaps) {
            PCSZ type;
            PCSZ type2;
            type = StaticLink ? "STATIC" : "DYNAMIC";
            type2 = Redirected ? "REDIRECTED" : "NON_REDIRECTED";

            DbgPrint(
                "LDR: Loading (%s, %s) %wZ\n",
                type,
                type2,
                &FullDllName);
        }

        if (!RtlDosPathNameToNtPathName_U(
                FullDllName.Buffer,
                &NtFileName,
                NULL,
                NULL)) {
            st = STATUS_OBJECT_PATH_SYNTAX_BAD;
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to RtlDosPathNameToNtPathName_U on path \"%wZ\" failed; returning status %x\n",
                __FUNCTION__,
                &FullDllName,
                st);
            goto Exit;
        }

        st = LdrpCreateDllSection(&NtFileName,
                                  DllFile,
                                  DllCharacteristics,
                                  &Section);

        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - LdrpCreateDllSection (%wZ) failed with status %x\n",
                __FUNCTION__,
                &NtFileName,
                st);

            LdrpFreeUnicodeString(&FullDllName);
            // We do not free BaseDllName since it's just a substring of FullDllName.

            RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
            goto Exit;
        }
        RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
#if DBG
        LdrpSectionCreates++;
#endif
    } else {
        KnownDll = TRUE;
    }

    ViewBase = NULL;
    ViewSize = 0;

#if DBG
    LdrpSectionMaps++;
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter(&MapBeginTime, NULL);
    }
#endif

    //
    // arrange for debugger to pick up the image name
    //

    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
    st = NtMapViewOfSection(
            Section,
            NtCurrentProcess(),
            (PVOID *)&ViewBase,
            0L,
            0L,
            NULL,
            &ViewSize,
            ViewShare,
            0L,
            PAGE_READWRITE
            );
    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to map view of section; status = %x\n",
            __FUNCTION__,
            st);

        goto Exit;
    }

    NtHeaders = RtlImageNtHeader(ViewBase);
    if ( !NtHeaders ) {
        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        st = STATUS_INVALID_IMAGE_FORMAT;
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to map ViewBase (%p) to image headers; failing with status %x\n",
            __FUNCTION__,
            ViewBase,
            st);
        goto Exit;
        }

#if _WIN64
    if (st != STATUS_IMAGE_NOT_AT_BASE &&
        (NtCurrentPeb()->NtGlobalFlag & FLG_LDR_TOP_DOWN) &&
        !(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)) {

        // The image was loaded at its preferred base and has relocs.  Map
        // it again using the default ViewBase.  This will collide with the
        // initial mapping, and force the mm to choose a new base address.
        // On Win64, the mm will do this top-down, forcing the DLL to
        // be mapped above 4gb if possible, to catch pointer truncations.
        PCUNICODE_STRING SystemDll;
        PVOID AlternateViewBase;
        ULONG_PTR AlternateViewSize;
        NTSTATUS AlternateSt;
        BOOLEAN LoadTopDown;

        LoadTopDown = TRUE;
        SystemDll = &User32String;
        if (RtlEqualUnicodeString(&BaseDllName, &User32String, TRUE)) {
            LoadTopDown = FALSE;
        } else {
            SystemDll = &Kernel32String;
            if (RtlEqualUnicodeString(&BaseDllName, &Kernel32String, TRUE)) {
                LoadTopDown = FALSE;
            }
        }
        if (LoadTopDown) {
            //
            // Map the image again.  It will collide with itself, and
            // the 64-bit mm will find a new base address for it,
            // working top-down
            //
            AlternateViewBase = NULL;
            AlternateViewSize = 0;
            ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
            Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
            AlternateSt = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    (PVOID *)&AlternateViewBase,
                    0L,
                    0L,
                    NULL,
                    &AlternateViewSize,
                    ViewShare,
                    0L,
                    PAGE_READWRITE
                    );
            Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;
            if (NT_SUCCESS(AlternateSt)) {
                //
                // Success.  Unmap the original image from the low
                // part of the address space and keep the new mapping
                // which was allocated top-down.
                //
                NtUnmapViewOfSection(NtCurrentProcess(), ViewBase);
                ViewSize = AlternateViewSize;
                ViewBase = AlternateViewBase;
                NtHeaders = RtlImageNtHeader(ViewBase);
                st = AlternateSt;
                if ( !NtHeaders ) {
                    NtUnmapViewOfSection(NtCurrentProcess(),AlternateViewBase);
                    st = STATUS_INVALID_IMAGE_FORMAT;
                    goto Exit;
                }
            }
        }
    }
#endif

#if defined (BUILD_WOW6432)
    if (NtHeaders->OptionalHeader.SectionAlignment < NativePageSize) {

        NTSTATUS stTemp;
        SIZE_T ReturnLength;
        MEMORY_BASIC_INFORMATION MemoryInformation;

        stTemp = NtQueryVirtualMemory (NtCurrentProcess(),
                                       NtHeaders,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof MemoryInformation,
                                       &ReturnLength);

        if (! NT_SUCCESS(stTemp)) {

            st = stTemp;
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Call to NtQueryVirtualMemory (%ls) failed with status 0x%08lx\n",
                __FUNCTION__,
                FullDllName.Buffer,
                st);

            NtUnmapViewOfSection(NtCurrentProcess(), ViewBase);
            ViewBase = NULL;
            goto Exit;
        }

        if ((MemoryInformation.Protect != PAGE_READONLY) &&
            (MemoryInformation.Protect != PAGE_EXECUTE_READ)) {

            stTemp = LdrpWx86FormatVirtualImage (&FullDllName,
                                                 (PIMAGE_NT_HEADERS32)NtHeaders,
                                                 ViewBase);

             if (!NT_SUCCESS(stTemp)) {
                 st = stTemp;
                 DbgPrintEx(
                     DPFLTR_LDR_ID,
                     LDR_ERROR_DPFLTR,
                     "LDR: %s - Call to LdrpWx86FormatVirtualImage(%ls) failed with status 0x%08lx\n",
                     __FUNCTION__,
                     FullDllName.Buffer,
                     st);

                 NtUnmapViewOfSection(NtCurrentProcess(), ViewBase);
                 ViewBase = NULL;
                 goto Exit;
             }
        }
    }
#endif

    Cor20Header = RtlImageDirectoryEntryToData(ViewBase,
                                               TRUE,
                                               IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                               &Cor20HeaderSize);
    OriginalViewBase = ViewBase;

    //
    // if this is an IL_ONLY image, then validate the image now
    //

    if ((Cor20Header != NULL) && 
        ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) != 0)) {
        
        //
        // NOTICE-2001/05/21-MGrier
        // This is wacky but code later on depends on the fact that st *was* STATUS_IMAGE_MACHINE_TYPE_MISMATCH
        // and got overwritten with STATUS_SUCCESS.  This in effect means that COR images can never have
        // relocation information.  XP Bug #400007.
        //
        st = LdrpCheckCorImage (Cor20Header,
                                &FullDllName,
                                &ViewBase,
                                &Cor20ILOnly);

        if (!NT_SUCCESS(st))
            goto Exit;
    }


#if DBG
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter(&MapEndTime, NULL);
        MapElapsedTime.QuadPart = MapEndTime.QuadPart - MapBeginTime.QuadPart;
        DbgPrint("Map View of Section Time %ld %ws\n", MapElapsedTime.LowPart, DllName);
    }
#endif

    //
    // Allocate a data table entry.
    //

    Entry = LdrpAllocateDataTableEntry(ViewBase);

    if (!Entry) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to allocate new data table entry for %p\n",
            __FUNCTION__,
            ViewBase);

        st = STATUS_NO_MEMORY;
        goto Exit;
    }

    Entry->Flags = 0;

    if (StaticLink)
        Entry->Flags |= LDRP_STATIC_LINK;

    if (Redirected)
        Entry->Flags |= LDRP_REDIRECTED;

    Entry->LoadCount = 0;

    Entry->FullDllName = FullDllName;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = 0;
    FullDllName.Buffer = NULL;

    Entry->BaseDllName = BaseDllName;
    BaseDllName.Length = 0;
    BaseDllName.MaximumLength = 0;
    BaseDllName.Buffer = NULL;

    Entry->EntryPoint = LdrpFetchAddressOfEntryPoint(Entry->DllBase);

#if LDRDBG
    if (ShowSnaps)
        DbgPrint(
            "LDR: LdrpMapDll: Full Name %wZ, Base Name %wZ\n",
            &Entry->FullDllName,
            &Entry->BaseDllName);
#endif

    LdrpInsertMemoryTableEntry(Entry);

    LdrpSendDllNotifications (Entry,
                              LDR_DLL_NOTIFICATION_REASON_LOADED,
                              (st == STATUS_IMAGE_NOT_AT_BASE) ? LDR_DLL_LOADED_FLAG_RELOCATED : 0);

    if ( st == STATUS_IMAGE_MACHINE_TYPE_MISMATCH ) {

        PIMAGE_NT_HEADERS ImageHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

        //
        // apps compiled for NT 3.x and below can load cross architecture
        // images
        //

        ErrorStatus = STATUS_SUCCESS;
        ErrorResponse = ResponseCancel;

        if ( ImageHeader->OptionalHeader.MajorSubsystemVersion <= 3 ) {

            Entry->EntryPoint = 0;

            //
            // Hard Error Time
            //

            //
            // Its error time...
            //

            ErrorParameters[0] = (ULONG_PTR)&FullDllName;

            ErrorStatus = NtRaiseHardError(
                            STATUS_IMAGE_MACHINE_TYPE_MISMATCH,
                            1,
                            1,
                            ErrorParameters,
                            OptionOkCancel,
                            &ErrorResponse
                            );
            }
        if ( NT_SUCCESS(ErrorStatus) && ErrorResponse == ResponseCancel ) {


#if defined(_AMD64_) || defined(_IA64_)


            RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                           Entry->DllBase);

#endif

            RemoveEntryList(&Entry->InLoadOrderLinks);
            RemoveEntryList(&Entry->InMemoryOrderLinks);
            RemoveEntryList(&Entry->HashLinks);
            LdrpDeallocateDataTableEntry(Entry);

            if ( ImageHeader->OptionalHeader.MajorSubsystemVersion <= 3 ) {
                if ( LdrpInLdrInit ) {
                    LdrpFatalHardErrorCount++;
                    }
                }
            st = STATUS_INVALID_IMAGE_FORMAT;
            goto Exit;
            }
        }
    else {
        if (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL) {
            Entry->Flags |= LDRP_IMAGE_DLL;
            }

        if (!(Entry->Flags & LDRP_IMAGE_DLL)) {
            Entry->EntryPoint = 0;
            }
        }

    *LdrDataTableEntry = Entry;

    if (st == STATUS_IMAGE_NOT_AT_BASE) {

        Entry->Flags |= LDRP_IMAGE_NOT_AT_BASE;

        //
        // now find the colliding dll. If we can not find a dll,
        // then the colliding dll must be dynamic memory
        //

        ImageBase = (PUCHAR)NtHeaders->OptionalHeader.ImageBase;
        ImageBounds = ImageBase + ViewSize;

        CollidingDllFound = FALSE;

        ScanHead = &PebLdr.InLoadOrderModuleList;
        ScanNext = ScanHead->Flink;

        while ( ScanNext != ScanHead ) {
            ScanEntry = CONTAINING_RECORD(ScanNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            ScanNext = ScanNext->Flink;

            ScanBase = (PUCHAR)ScanEntry->DllBase;
            ScanTop = ScanBase + ScanEntry->SizeOfImage;

            //
            // when we unload, the memory order links flink field is nulled.
            // this is used to skip the entry pending list removal.
            //

            if ( !ScanEntry->InMemoryOrderLinks.Flink ) {
                continue;
                }

            //
            // See if the base address of the scan image is within the relocating dll
            // or if the top address of the scan image is within the relocating dll
            //

            if ( (ImageBase >= ScanBase && ImageBase <= ScanTop)

                 ||

                 (ImageBounds >= ScanBase && ImageBounds <= ScanTop)

                 ||

                 (ScanBase >= ImageBase && ScanBase <= ImageBounds)

                 ){

                CollidingDllFound = TRUE;
                CollidingDll = &ScanEntry->FullDllName;
                break;
                }
            }

        if ( !CollidingDllFound ) {
            CollidingDll = &DynamicallyAllocatedMemoryString;
            }

#if DBG
        if ( BeginTime.LowPart || BeginTime.HighPart ) {
            DbgPrint(
                "\nLDR: %s Relocating Image Name %ws\n",
                __FUNCTION__,
                DllName
                );
        }
        LdrpSectionRelocates++;
#endif

        if (Entry->Flags & LDRP_IMAGE_DLL) {

            BOOLEAN AllowRelocation;
            PCUNICODE_STRING SystemDll;

            if (!(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)) {
                PVOID pBaseRelocs;
                ULONG BaseRelocCountBytes = 0;

                //
                // If the image doesn't have the reloc stripped bit set and there's no
                // relocs in the data directory, allow this through.  This is probably
                // a pure forwarder dll or data w/o relocs.
                //

                pBaseRelocs = RtlImageDirectoryEntryToData(
                        ViewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &BaseRelocCountBytes);

                if (!pBaseRelocs && !BaseRelocCountBytes)
                    goto NoRelocNeeded;
            }

            //
            // decide whether or not to allow the relocation
            // certain system dll's like user32 and kernel32 are not relocatable
            // since addresses within these dll's are not always stored per process
            // do not allow these dll's to be relocated
            //

            AllowRelocation = TRUE;
            SystemDll = &User32String;
            if ( RtlEqualUnicodeString(&Entry->BaseDllName, SystemDll, TRUE)) {
                AllowRelocation = FALSE;
            } else {
                SystemDll = &Kernel32String;
                if (RtlEqualUnicodeString(&Entry->BaseDllName, SystemDll, TRUE))
                    AllowRelocation = FALSE;
            }

            if ( !AllowRelocation && KnownDll ) {

                //
                // totally disallow the relocation since this is a knowndll
                // that matches our system binaries and is being relocated
                //

                //
                // Hard Error Time
                //

                ErrorParameters[0] = (ULONG_PTR)SystemDll;
                ErrorParameters[1] = (ULONG_PTR)CollidingDll;

                NtRaiseHardError(
                    STATUS_ILLEGAL_DLL_RELOCATION,
                    2,
                    3,
                    ErrorParameters,
                    OptionOk,
                    &ErrorResponse);

                if ( LdrpInLdrInit ) {
                    LdrpFatalHardErrorCount++;
                }

                st = STATUS_CONFLICTING_ADDRESSES;
                goto skipreloc;
            }

            st = LdrpSetProtection (ViewBase, FALSE);
            if (NT_SUCCESS(st)) {
                __try {
                    st = LdrRelocateImage(ViewBase,
                                "LDR",
                                STATUS_SUCCESS,
                                STATUS_CONFLICTING_ADDRESSES,
                                STATUS_INVALID_IMAGE_FORMAT);
                } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();
                }

                if (NT_SUCCESS(st)) {
                    //
                    // If we did relocations, then map the section again.
                    // this will force the debug event
                    //

                    //
                    // arrange for debugger to pick up the image name
                    //

                    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
                    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;

                    st = NtMapViewOfSection(
                        Section,
                        NtCurrentProcess(),
                        (PVOID *)&ViewBase,
                        0L,
                        0L,
                        NULL,
                        &ViewSize,
                        ViewShare,
                        0L,
                        PAGE_READWRITE);

                    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

                    if ((st != STATUS_CONFLICTING_ADDRESSES) && !NT_SUCCESS(st)) {
                        DbgPrintEx(
                            DPFLTR_LDR_ID,
                            LDR_ERROR_DPFLTR,
                            "[%x,%x] LDR: Failed to map view of section; ntstatus = %x\n",
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                            st);

                        goto Exit;
                    }

                    st = LdrpSetProtection (ViewBase, TRUE);
                }
            }
skipreloc:
            //
            // if the set protection failed, or if the relocation failed, then
            // remove the partially loaded dll from the lists and clear entry
            // that it has been freed.
            //

            if ( !NT_SUCCESS(st) ) {

#if defined(_AMD64_) || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&Entry->InLoadOrderLinks);
                RemoveEntryList(&Entry->InMemoryOrderLinks);
                RemoveEntryList(&Entry->HashLinks);
                if (ShowSnaps) {
                    DbgPrint("LDR: Fixups unsuccessfully re-applied @ %p\n",
                           ViewBase);
                }
                goto Exit;
            }

            if (ShowSnaps) {                
                DbgPrint("LDR: Fixups successfully re-applied @ %p\n",
                       ViewBase);               
            }
        } else {
NoRelocNeeded:

            st = STATUS_SUCCESS;

            //
            // arrange for debugger to pick up the image name
            //

            ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
            Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;

            st = NtMapViewOfSection(
                Section,
                NtCurrentProcess(),
                (PVOID *)&ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE
                );
            Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

            //
            // NOTICE-2001/04/09-MGrier
            // If the thing was relocated, we get back the failure status STATUS_CONFLICTING_ADDRESSES
            // but of all the strange things, the relocations aren't done.  I have questions in to folks
            // asking about this behavior but who knows how many legacy apps depend on dlls that statically
            // link to EXEs which from time to time are not loaded at their default addresses.
            //
            if ((st != STATUS_CONFLICTING_ADDRESSES) && !NT_SUCCESS(st))
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "[%x,%x] LDR: %s - NtMapViewOfSection on no reloc needed dll failed with status %x\n",
                    HandleToULong(Teb->ClientId.UniqueProcess),
                    HandleToULong(Teb->ClientId.UniqueThread),
                    __FUNCTION__,
                    st);
            else
                st = STATUS_SUCCESS;

            if (ShowSnaps)
                DbgPrint("LDR: Fixups won't be re-applied to non-Dll @ %p\n", ViewBase);
        }
    }

    //
    // if this is NOT an IL_ONLY image, then validate the image now after applying the
    // fixups
    //

    if ((Cor20Header != NULL) && 
        ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) == 0)) {
        
        st = LdrpCheckCorImage (Cor20Header,
                                &Entry->FullDllName,
                                &ViewBase,
                                &Cor20ILOnly);
        if (!NT_SUCCESS (st)) {
            goto Exit;
        }
    }

    if (Cor20ILOnly) {
        Entry->Flags |= LDRP_COR_IMAGE;
    }

    if (ViewBase != OriginalViewBase) {
        Entry->Flags |= LDRP_COR_OWNS_UNMAP;
    }

#if defined(_X86_)
    if ( LdrpNumberOfProcessors > 1 && (Entry->Flags & LDRP_IMAGE_DLL) ) {
        LdrpValidateImageForMp(Entry);
        }
#endif

    ViewBase = NULL;

Exit:
    if (ViewBase != NULL) {

        if (Cor20ILOnly) {
            LdrpCorUnloadImage(ViewBase);
        }

        if (ViewBase == OriginalViewBase) {
            NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        }
    }

    if (Section != NULL) {
        NtClose(Section);
    }

    if (AppCompatDllName != NULL) {
        (*RtlFreeStringRoutine)(AppCompatDllName);
    }

    if (FullDllName.Buffer != NULL) {
        LdrpFreeUnicodeString(&FullDllName);
    }

#if DBG
    if (!NT_SUCCESS(st) && (ShowSnaps || st != STATUS_DLL_NOT_FOUND))
        DbgPrint("LDR: %s(%ws) failing 0x%lx\n", __FUNCTION__, DllName, st);
#endif

    return st;
}

//#define SAFER_DEBUGGING
//#define SAFER_ERRORS_ARE_FATAL


NTSTATUS
LdrpCodeAuthzCheckDllAllowed(
    IN PCUNICODE_STRING  FileName,
    IN HANDLE           FileImageHandle
    )
/*++

Routine Description:

    This routine dynamically loads ADVAPI32.DLL and obtains entry points
    to the WinSafer sandboxing APIs, so that the trustworthiness of the
    requested library can be determined.  Libraries that are equally
    or greater "trusted" than the Access Token of the process loading
    the library are allowed to be loaded.  Libraries that are less
    trusted than the process will be denied.

    Care must be taken to ensure that this function is kept threadsafe
    without requiring the use of critical sections.  In particular,
    the usage of the variable "AdvApi32ModuleHandleMaster" needs to be
    accessed only through a copy, since it may be changed unexpected by
    another thread.

Arguments:

    FileName - the fully qualified NT filename of the library being loaded.
        The filename will be used to perform path validation checks.

    FileImageHandle - the opened file handle of the library being loaded.
        This handle will be used to read the contents of the library to
        perform size and hash validation checks by WinSafer.

Return Value:

    STATUS_SUCCESS - the library is of equal or greater trustworthiness
        than that process it is being loaded into, and should be allowed.

    STATUS_NOT_FOUND - the library does not have a trust level configured
        and no default rule in in effect (treat same as STATUS_SUCCESS).

    STATUS_ACCESS_DENIED - the library is less trustworthy than the
        process and the load should be denied.

    Other non-success - an error occurred trying to load/determine the
        trust of the library, so the load should be denied.
        (including STATUS_ENTRY_POINT_NOT_FOUND)

--*/
{


#define SAFER_USER_KEY_NAME L"\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers"

    typedef BOOL (WINAPI *ComputeAccessTokenFromCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      LevelObject,
        IN HANDLE           InAccessToken         OPTIONAL,
        OUT PHANDLE         OutAccessToken,
        IN DWORD            dwFlags,
        IN LPVOID           lpReserved
        );

    typedef BOOL (WINAPI *IdentifyCodeAuthzLevelWT) (
        IN DWORD                dwCheckFlags,
        IN PSAFER_CODE_PROPERTIES    CodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelObject,
        IN LPVOID               lpReserved
        );

    typedef BOOL (WINAPI *CloseCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      hLevelObject);

    NTSTATUS Status;
    SAFER_LEVEL_HANDLE hAuthzLevel = NULL;
    SAFER_CODE_PROPERTIES codeproperties;
    DWORD dwCompareResult = 0;
    HANDLE hProcessToken= NULL;
    HANDLE TempAdvApi32Handle = NULL;

    const static SID_IDENTIFIER_AUTHORITY NtAuthority =
            SECURITY_NT_AUTHORITY;
    const static UNICODE_STRING UnicodeSafeBootKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    const static UNICODE_STRING UnicodeSafeBootValueName =
        RTL_CONSTANT_STRING(L"OptionValue");
    const static OBJECT_ATTRIBUTES ObjectAttributesSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeSafeBootKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING UnicodeKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static UNICODE_STRING UnicodeTransparentValueName =
        RTL_CONSTANT_STRING(L"TransparentEnabled");
    const static OBJECT_ATTRIBUTES ObjectAttributesCodeIdentifiers =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING ModuleNameAdvapi =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");
    const static ANSI_STRING ProcedureNameIdentify =
        RTL_CONSTANT_STRING("SaferIdentifyLevel");
    const static ANSI_STRING ProcedureNameCompute =
        RTL_CONSTANT_STRING("SaferComputeTokenFromLevel");
    const static ANSI_STRING ProcedureNameClose =
        RTL_CONSTANT_STRING("SaferCloseLevel");

    static volatile HANDLE AdvApi32ModuleHandleMaster = (HANDLE) (ULONG_PTR) -1;
    static IdentifyCodeAuthzLevelWT lpfnIdentifyCodeAuthzLevelW;
    static ComputeAccessTokenFromCodeAuthzLevelT
            lpfnComputeAccessTokenFromCodeAuthzLevel;
    static CloseCodeAuthzLevelT lpfnCloseCodeAuthzLevel;


    PIMAGE_NT_HEADERS NtHeader;

    NtHeader = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

    // Check for NULL header.

    if (!NtHeader) {
        return STATUS_SUCCESS;
    }

    // Continue only if this is a windows subsystem app. We run into all sorts
    // of problems because kernel32 might not initialize for others.

    if (!((NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) ||
        (NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI))) {
        return STATUS_SUCCESS;
    }

    //
    // If either of these two cases are true, then we should bail out
    // as quickly as possible because we know that WinSafer evaluations
    // should definitely not occur for this process anymore.
    //
    TempAdvApi32Handle = AdvApi32ModuleHandleMaster;
    if (TempAdvApi32Handle == NULL) {
        // We tried to load ADVAPI32.DLL once before, but failed.
        Status = STATUS_ACCESS_DENIED;
        goto ExitHandler;
    } else if (TempAdvApi32Handle == LongToHandle(-2)) {
        // Indicates that DLL checking should never be done for this process.
        Status = STATUS_SUCCESS;
        goto ExitHandler;
    }


    //
    // Open a handle to the current process's access token.
    // We care only about the process token, and not the
    // thread impersonation token.
    //
    Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    TOKEN_QUERY,
                    &hProcessToken);
    if (!NT_SUCCESS(Status)) {
#ifdef SAFER_ERRORS_ARE_FATAL
        AdvApi32ModuleHandleMaster = NULL;
        Status = STATUS_ACCESS_DENIED;
#else
        AdvApi32ModuleHandleMaster = LongToHandle(-2);
        Status = STATUS_SUCCESS;
#endif
        goto ExitHandler;
    }


    //
    // If this is our first time through here, then we need to
    // load ADVAPI32.DLL and get pointers to our functions.
    //
    if (TempAdvApi32Handle == LongToHandle(-1))
    {
        static LONG LoadInProgress = 0;


        //
        // We need to prevent multiple threads from simultaneously
        // getting stuck and trying to load advapi at the same time.
        //
        if (InterlockedCompareExchange(&LoadInProgress, 1, 0) != 0) {
            Status = STATUS_SUCCESS;
            goto ExitHandler2;
        }

        //
        // Check if this process's access token is running as
        // the Local SYSTEM, LOCAL SERVICE or NETWORK SERVICE account, 
        // and disable enforcement if so.
        //
        {
            BYTE tokenuserbuff[sizeof(TOKEN_USER) + 128];
            PTOKEN_USER ptokenuser = (PTOKEN_USER) tokenuserbuff;
            BYTE localsystembuff[128];
            PSID LocalSystemSid = (PSID) localsystembuff;
            ULONG ulReturnLength;


            Status = NtQueryInformationToken(
                            hProcessToken, TokenUser,
                            tokenuserbuff, sizeof(tokenuserbuff),
                            &ulReturnLength);
            if (NT_SUCCESS(Status)) {
                Status = RtlInitializeSid(
                            LocalSystemSid,
                            (PSID_IDENTIFIER_AUTHORITY) &NtAuthority, 1);
                ASSERTMSG("InitializeSid should not fail.", NT_SUCCESS(Status));
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SYSTEM_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SERVICE_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_NETWORK_SERVICE_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }
            }
        }


        //
        // If we are booting in safe mode and the user is a member of
        // the local Administrators group, then disable enforcement.
        // Notice that Windows itself does not perform any implicit
        // restriction of only allowing Administrators to log in during
        // Safe mode boot, so we must perform the test ourself.
        //
        {
            HANDLE hKeySafeBoot;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bSafeModeBoot = FALSE;

            // We open the key for SET access (in addition to QUERY)
            // because only Administrators should be able to modify values
            // under this key.  This allows us to combine our test of
            // being an Administrator and having booted in Safe mode.
            Status = NtOpenKey(&hKeySafeBoot, KEY_QUERY_VALUE | KEY_SET_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesSafeBoot);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeySafeBoot,
                            (PUNICODE_STRING) &UnicodeSafeBootValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo,
                            sizeof(QueryBuffer),
                            &dwActualSize);
                NtClose(hKeySafeBoot);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bSafeModeBoot = TRUE;
                    }
                }
            }

            if (bSafeModeBoot) {
FailSuccessfully:
                AdvApi32ModuleHandleMaster = LongToHandle(-2);
                Status = STATUS_SUCCESS;
                goto ExitHandler2;
            }
        }



        //
        // Allow a way for policy to enable whether transparent
        // enforcement should be enabled or not (default to disable).
        // Note that the following values have meanings:
        //      0 = Transparent WinSafer enforcement disabled.
        //      1 = means enable transparent EXE enforcement
        //     >1 = means enable transparent EXE and DLL enforcement.
        //
        {
            //
            // FUTURE-2001/01/09-kedard
            // see BUG 240635: change to use existence of policy instead.
            //
            HANDLE hKeyEnabled;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bPolicyEnabled = FALSE;

            Status = NtOpenKey(&hKeyEnabled, KEY_QUERY_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesCodeIdentifiers);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &UnicodeTransparentValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                NtClose(hKeyEnabled);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 1) {
                        bPolicyEnabled = TRUE;
                    }
                }
            }


            //
            // There was no machine policy. Check if user policy is enabled.
            //

            if (!bPolicyEnabled) {
                UNICODE_STRING CurrentUserKeyPath;
                UNICODE_STRING SubKeyNameUser;
                OBJECT_ATTRIBUTES ObjectAttributesUser;
                ULONG SubKeyLength;

                //
                // Get the prefix for the user key.
                //

                Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );

                if (NT_SUCCESS( Status ) ) {

                    SubKeyNameUser.Length = 0;
                    SubKeyLength = CurrentUserKeyPath.Length + sizeof(WCHAR) +
                                                   sizeof(SAFER_USER_KEY_NAME);

                    if (SubKeyLength > UNICODE_STRING_MAX_BYTES) {
                        Status = STATUS_NAME_TOO_LONG;
                        goto UserKeyCleanup;
                    }

                    SubKeyNameUser.MaximumLength = (USHORT)SubKeyLength;

                    //
                    // Allocate memory big enough to hold the unicode string.
                    //

                    SubKeyNameUser.Buffer = RtlAllocateHeap( 
                                                RtlProcessHeap(),
                                                MAKE_TAG( TEMP_TAG ),
                                                SubKeyNameUser.MaximumLength);

                    if (SubKeyNameUser.Buffer != NULL) {

                        //
                        // Copy the prefix into the string.
                        // This is of the type Registry\S-1-5-21-xxx-xxx-xxx-xxx.
                        //

                        Status = RtlAppendUnicodeStringToString(
                                    &SubKeyNameUser, 
                                    &CurrentUserKeyPath );

                        if (NT_SUCCESS( Status ) ) {

                            //
                            // Append the Safer suffix.
                            //

                            Status = RtlAppendUnicodeToString( 
                                         &SubKeyNameUser,
                                         SAFER_USER_KEY_NAME );

                            if (NT_SUCCESS( Status ) ) {

                                InitializeObjectAttributes(
                                    &ObjectAttributesUser,
                                    &SubKeyNameUser,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

                                Status = NtOpenKey( &hKeyEnabled,KEY_QUERY_VALUE,
                                             (POBJECT_ATTRIBUTES) &ObjectAttributesUser);

                                if (NT_SUCCESS(Status)) {
                                    Status = NtQueryValueKey(
                                                hKeyEnabled,
                                                (PUNICODE_STRING) &UnicodeTransparentValueName,
                                                KeyValuePartialInformation,
                                                pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                                    NtClose (hKeyEnabled);
                                    if (NT_SUCCESS(Status)) {
                                        if (pKeyValueInfo->Type == REG_DWORD &&
                                            pKeyValueInfo->DataLength == sizeof(DWORD) &&
                                            *((PDWORD) pKeyValueInfo->Data) > 1) {
                                            bPolicyEnabled = TRUE;
                                        }
                                    }
                                }
                            }

                        }
                        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameUser.Buffer);
                    }

UserKeyCleanup:
                    RtlFreeUnicodeString( &CurrentUserKeyPath );
                }
            }



            if (!bPolicyEnabled) {
                goto FailSuccessfully;
            }
        }


        //
        // Finally load the library.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi
        // itself, but that (currently) doesn't affect dependent DLLs
        // so we still depend on the above LoadInProgress flag to
        // prevent unintended recursion.
        //
        {
            //
            // NTRAID#NTBUG9-241835-2000/11/27-johnla
            // the WinSafer supression doesn't affect dependencies.
            //
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            Status = LdrLoadDll(UNICODE_NULL,
                                &DllCharacteristics,  // prevents recursion too
                                &ModuleNameAdvapi,
                                &TempAdvApi32Handle);
            if (!NT_SUCCESS(Status)) {
                #if DBG
                DbgPrint("LDR: AuthzCheck: load failure on advapi (Status=%d) inside %d for %wZ\n",
                         Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
                #endif
                AdvApi32ModuleHandleMaster = NULL;
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
                goto ExitHandler2;
            }
        }



        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //
        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameIdentify,
                0,
                (PVOID*)&lpfnIdentifyCodeAuthzLevelW, 
                FALSE);

        if (!NT_SUCCESS(Status) || !lpfnIdentifyCodeAuthzLevelW) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress identify (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameCompute,
                0,
                (PVOID*)&lpfnComputeAccessTokenFromCodeAuthzLevel,
                FALSE);

        if (!NT_SUCCESS(Status) ||
            !lpfnComputeAccessTokenFromCodeAuthzLevel) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress compute (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameClose,
                0,
                (PVOID*)&lpfnCloseCodeAuthzLevel,
                FALSE);

        if (!NT_SUCCESS(Status) || !lpfnCloseCodeAuthzLevel) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress close (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }
        AdvApi32ModuleHandleMaster = TempAdvApi32Handle;
    }


    //
    // Prepare the code properties struct.
    //
    RtlZeroMemory(&codeproperties, sizeof(codeproperties));
    codeproperties.cbSize = sizeof(codeproperties);
    codeproperties.dwCheckFlags =
            (SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH |
             SAFER_CRITERIA_IMAGEPATH_NT | SAFER_CRITERIA_NOSIGNEDHASH);
    ASSERTMSG("FileName not null terminated",
              FileName->Buffer[FileName->Length / sizeof(WCHAR)] == UNICODE_NULL);
    codeproperties.ImagePath = FileName->Buffer;
    codeproperties.hImageFileHandle = FileImageHandle;


    //
    // Ask the system to find the Authorization Level that classifies it.
    //
    ASSERT(lpfnIdentifyCodeAuthzLevelW != NULL);
    if (lpfnIdentifyCodeAuthzLevelW(
            1,                      // 1 structure
            &codeproperties,        // details to identify
            &hAuthzLevel,           // Safer level
            NULL))                  // reserved.
    {
        //
        // We found an Authorization Level applicable to this application.
        // See if this Level represents something less trusted than us.
        //

        ASSERT(lpfnComputeAccessTokenFromCodeAuthzLevel != NULL);
        if (!lpfnComputeAccessTokenFromCodeAuthzLevel(
                hAuthzLevel,                // Safer Level
                hProcessToken,              // source token.
                NULL,                       // output token not used for compare.
                SAFER_TOKEN_COMPARE_ONLY,    // we want to compare
                &dwCompareResult))          // reserved
        {
            // failed to compare, for some reason.
            #if DBG
            DbgPrint("LDR: AuthzCheck: compute failed in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT;
        } else if (dwCompareResult == -1) {
            // less privileged, deny access.
            #ifdef SAFER_DEBUGGING
            DbgPrint("LDR: AuthzCheck: compute access denied in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT;
        } else {
            // greater or equally privileged, allow access to load.
            #ifdef SAFER_DEBUGGING
            DbgPrint("LDR: AuthzCheck: compute access ok in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_SUCCESS;
        }

        ASSERT(lpfnCloseCodeAuthzLevel != NULL);
        lpfnCloseCodeAuthzLevel(hAuthzLevel);

    } else {
        // No authorization level found for this DLL, and the
        // policy does not have a Default Level in effect.
        Status = STATUS_NOT_FOUND;
    }

ExitHandler2:
    NtClose(hProcessToken);

ExitHandler:
    return Status;
}




NTSTATUS
LdrpCreateDllSection (
    IN PCUNICODE_STRING NtFullDllName,
    IN HANDLE DllFile,
    IN PULONG DllCharacteristics OPTIONAL,
    OUT PHANDLE SectionHandle
    )
{
    HANDLE File;
    NTSTATUS st;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    SECTION_IMAGE_INFORMATION ImageInformation;

    //
    // NOTICE-2002/03/10-ELi
    // If DllFile is specified, then it will be closed before returning from
    // the function
    //

    if (!DllFile) {

        //
        // Since ntsd does not search paths well, we can't use
        // relative object names.
        //

        InitializeObjectAttributes (&ObjectAttributes,
                                    (PUNICODE_STRING)NtFullDllName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        //
        // Open for FILE_GENERIC_READ as well. This is needed in case Safer hash
        // policy exists for DLLs. If we do not have READ access we will continue
        // with lesses access. Safer code, if it needs to be executed will fail
        // later on.
        //

        st = NtOpenFile (&File,
                         SYNCHRONIZE | FILE_EXECUTE | FILE_READ_DATA,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

        if (!NT_SUCCESS(st)) {

            st = NtOpenFile (&File,
                             SYNCHRONIZE | FILE_EXECUTE,
                             &ObjectAttributes,
                             &IoStatus,
                             FILE_SHARE_READ | FILE_SHARE_DELETE,
                             FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

        }

        if (!NT_SUCCESS(st)) {

            if (ShowSnaps) {
                DbgPrint ("LDR: %s - NtOpenFile failed; status = %x\n", __FUNCTION__, st);
            }

            //
            // Swizzle the return value. If we got STATUS_OBJECT_NAME_NOT_FOUND,
            // it should really be STATUS_DLL_NOT_FOUND.
            //
            if (st == STATUS_OBJECT_NAME_NOT_FOUND) {
                if (ShowSnaps) {
                    DbgPrint("LDR: %s - Turning NtOpenFile's %x into %x\n", __FUNCTION__, st, STATUS_DLL_NOT_FOUND);
                }
                st = STATUS_DLL_NOT_FOUND;
            }
            
            *SectionHandle = NULL;
            return st;
        }
    }
    else {
        File = DllFile;
    }

    //
    // Create a memory section of the library file's contents.
    //

    st = NtCreateSection (SectionHandle,
                          SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE | SECTION_QUERY,
                          NULL,
                          NULL,
                          PAGE_EXECUTE,
                          SEC_IMAGE,
                          File);

    if (NT_SUCCESS(st)) {

        if ((ARGUMENT_PRESENT(DllCharacteristics)) &&
            (*DllCharacteristics & IMAGE_FILE_SYSTEM)) {
#if DBG
            DbgPrint("LDR: WinSafer AuthzCheck on %wZ skipped by request\n",
                     &NtFullDllName);
#endif
        }
        else {

#if defined(_WIN64)

            //
            // WOW64 processes should not load 64-bit dlls (advapi32.dll)
            // but the DLLs will get SAFERized when the 32-bit load kicks in.
            //

            if (UseWOW64 == FALSE) {
#endif

                //
                // Ask the WinSafer code authorization sandboxing
                // infrastructure if the library load should be permitted.
                //
                // The Winsafer check is here since the
                // IMAGE_LOADER_FLAGS_COMPLUS information from the image
                // will be made available shortly.
                //
                // Query the section to determine whether or not this is a
                // .NET image.  On failure to query, the error will be returned.
                //

                st = NtQuerySection (*SectionHandle,
                                     SectionImageInformation,
                                     &ImageInformation,
                                     sizeof (ImageInformation),
                                     NULL);

                if (!NT_SUCCESS (st)) {
                    NtClose (*SectionHandle);
                    *SectionHandle = NULL;
                    NtClose (File);
                    return st;
                }

                if ((ImageInformation.LoaderFlags & IMAGE_LOADER_FLAGS_COMPLUS) == 0) {

                    st = LdrpCodeAuthzCheckDllAllowed (NtFullDllName, File);

                    if ((!NT_SUCCESS(st)) && (st != STATUS_NOT_FOUND)) {
#if !DBG
                        if (ShowSnaps)
#endif
                        {
                            DbgPrint("LDR: Loading of (%wZ) blocked by WinSafer\n",
                                     &NtFullDllName);
                        }

                        NtClose (*SectionHandle);
                        *SectionHandle = NULL;
                        NtClose (File);
                        return st;
                    }
                    st = STATUS_SUCCESS;
                }
#if defined(_WIN64)        
            }
#endif
        }
    }
    else {

        //
        // Hard error time.
        //

        ULONG_PTR ErrorParameters[1];
        ULONG ErrorResponse;

        *SectionHandle = NULL;
        ErrorParameters[0] = (ULONG_PTR)NtFullDllName;

        NtRaiseHardError (STATUS_INVALID_IMAGE_FORMAT,
                          1,
                          1,
                          ErrorParameters,
                          OptionOk,
                          &ErrorResponse);

        if (LdrpInLdrInit)  {
            LdrpFatalHardErrorCount += 1;
        }

#if DBG
        if (st != STATUS_INVALID_IMAGE_NE_FORMAT &&
            st != STATUS_INVALID_IMAGE_LE_FORMAT &&
            st != STATUS_INVALID_IMAGE_WIN_16    &&
            st != STATUS_INVALID_IMAGE_WIN_32    &&
            st != STATUS_INVALID_IMAGE_WIN_64    &&
            LdrpShouldDbgPrintStatus(st)) {

            DbgPrint("LDR: " __FUNCTION__ " - NtCreateSection %wZ failed. Status == 0x%08lx\n",
                     NtFullDllName,
                     st
                    );
        }
#endif
    }

    NtClose (File);
    
    return st;
}


NTSTATUS
LdrpSnapIAT (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Export,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Import,
    IN PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    IN BOOLEAN SnapForwardersOnly
    )

/*++

Routine Description:

    This function snaps the Import Address Table for this
    Import Descriptor.

Arguments:

    LdrDataTableEntry_Export - Information about the image to import from.

    LdrDataTableEntry_Import - Information about the image to import to.

    ImportDescriptor - Contains a pointer to the IAT to snap.

    SnapForwardersOnly - TRUE if just snapping forwarders only.

Return Value:

    Status value

--*/

{
    NTSTATUS st;
    ULONG ExportSize;
    PCIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_THUNK_DATA Thunk, OriginalThunk;
    PCSZ ImportName;
    ULONG ForwarderChain;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG i, Rva;
    PVOID IATBase;
    SIZE_T IATSize;
    ULONG LittleIATSize;
    ULONG OldProtect;

    ExportDirectory = (PCIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                       LdrDataTableEntry_Export->DllBase,
                       TRUE,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       &ExportSize
                       );

    if (!ExportDirectory) {
        KdPrint(("LDR: %wZ doesn't contain an EXPORT table\n", &LdrDataTableEntry_Export->BaseDllName));
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Determine the location and size of the IAT.  If the linker did
    // not tell use explicitly, then use the location and size of the
    // image section that contains the import table.
    //

    IATBase = RtlImageDirectoryEntryToData( LdrDataTableEntry_Import->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize
                                          );
    if (IATBase == NULL) {
        NtHeaders = RtlImageNtHeader( LdrDataTableEntry_Import->DllBase );
        if (! NtHeaders) {
            return STATUS_INVALID_IMAGE_FORMAT;
        }
        NtSection = IMAGE_FIRST_SECTION( NtHeaders );
        Rva = NtHeaders->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].VirtualAddress;
        if (Rva != 0) {
            for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
                if (Rva >= NtSection->VirtualAddress &&
                    Rva < (NtSection->VirtualAddress + NtSection->SizeOfRawData)
                   ) {
                    IATBase = (PVOID)
                        ((ULONG_PTR)(LdrDataTableEntry_Import->DllBase) + NtSection->VirtualAddress);

                    LittleIATSize = NtSection->Misc.VirtualSize;
                    if (LittleIATSize == 0) {
                        LittleIATSize = NtSection->SizeOfRawData;
                    }
                    break;
                }

                ++NtSection;
            }
        }

        if (IATBase == NULL) {
            KdPrint(( "LDR: Unable to unprotect IAT for %wZ (Image Base %p)\n",
                      &LdrDataTableEntry_Import->BaseDllName,
                      LdrDataTableEntry_Import->DllBase
                   ));
            return STATUS_INVALID_IMAGE_FORMAT;
        }
    }
    IATSize = LittleIATSize;

    st = NtProtectVirtualMemory( NtCurrentProcess(),
                                 &IATBase,
                                 &IATSize,
                                 PAGE_READWRITE,
                                 &OldProtect
                               );
    if (!NT_SUCCESS(st)) {
        KdPrint(( "LDR: Unable to unprotect IAT for %wZ (Status %x)\n",
                  &LdrDataTableEntry_Import->BaseDllName,
                  st
               ));
        return st;
    }

    //
    // If just snapping forwarded entries, walk that list
    //
    if (SnapForwardersOnly) {
        ImportName = (PCSZ)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->Name);
        ForwarderChain = ImportDescriptor->ForwarderChain;
        while (ForwarderChain != -1) {
            OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->OriginalFirstThunk +
                            (ForwarderChain * sizeof(IMAGE_THUNK_DATA)));
            Thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->FirstThunk +
                            (ForwarderChain * sizeof(IMAGE_THUNK_DATA)));
            ForwarderChain = (ULONG) Thunk->u1.Ordinal;
            try {
                st = LdrpSnapThunk(LdrDataTableEntry_Export->DllBase,
                        LdrDataTableEntry_Import->DllBase,
                        OriginalThunk,
                        Thunk,
                        ExportDirectory,
                        ExportSize,
                        TRUE,
                        ImportName
                        );
                Thunk++;
            }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = GetExceptionCode();
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - caught exception %08lx snapping thunks (#1)\n",
                    __FUNCTION__,
                    st);
            }
            if (!NT_SUCCESS(st) ) {
                break;
            }
        }
    }
    else if (ImportDescriptor->FirstThunk) {

        //
        // Otherwise, walk through the IAT and snap all the thunks.
        //

        Thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->FirstThunk);

        NtHeaders = RtlImageNtHeader( LdrDataTableEntry_Import->DllBase );

        //
        // If the OriginalFirstThunk field does not point inside the image, then ignore
        // it.  This is will detect bogus Borland Linker 2.25 images that did not fill
        // this field in.
        //

        if (ImportDescriptor->Characteristics < NtHeaders->OptionalHeader.SizeOfHeaders ||
            ImportDescriptor->Characteristics >= NtHeaders->OptionalHeader.SizeOfImage
           ) {
            OriginalThunk = Thunk;
        } else {
            OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->OriginalFirstThunk);
        }
        ImportName = (PCSZ)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->Name);
        while (OriginalThunk->u1.AddressOfData) {
            try {
                st = LdrpSnapThunk(LdrDataTableEntry_Export->DllBase,
                        LdrDataTableEntry_Import->DllBase,
                        OriginalThunk,
                        Thunk,
                        ExportDirectory,
                        ExportSize,
                        TRUE,
                        ImportName
                        );
                OriginalThunk += 1;
                Thunk += 1;
            }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = GetExceptionCode();
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - caught exception %08lx snapping thunks (#2)\n",
                    __FUNCTION__,
                    st);
            }

            if (!NT_SUCCESS(st) ) {
                break;
            }
        }
    }

    //
    // Restore protection for IAT and flush instruction cache.
    //

    NtProtectVirtualMemory (NtCurrentProcess(),
                            &IATBase,
                            &IATSize,
                            OldProtect,
                            &OldProtect);

    NtFlushInstructionCache (NtCurrentProcess(), IATBase, LittleIATSize);

    return st;
}


NTSTATUS
LdrpSnapThunk (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA OriginalThunk,
    IN OUT PIMAGE_THUNK_DATA Thunk,
    IN PCIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN StaticSnap,
    IN PCSZ DllName
    )

/*++

Routine Description:

    This function snaps a thunk using the specified Export Section data.
    If the section data does not support the thunk, then the thunk is
    partially snapped (Dll field is still non-null, but snap address is
    set).

Arguments:

    DllBase - Base of Dll.

    ImageBase - Base of image that contains the thunks to snap.

    Thunk - On input, supplies the thunk to snap.  When successfully
        snapped, the function field is set to point to the address in
        the DLL, and the DLL field is set to NULL.

    ExportDirectory - Supplies the Export Section data from a DLL.

    StaticSnap - If TRUE, then loader is attempting a static snap,
                 and any ordinal/name lookup failure will be reported.

Return Value:

    STATUS_SUCCESS or STATUS_PROCEDURE_NOT_FOUND

--*/

{
    BOOLEAN Ordinal;
    USHORT OrdinalNumber;
    ULONG OriginalOrdinalNumber;
    PCIMAGE_IMPORT_BY_NAME AddressOfData;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    USHORT HintIndex;
    NTSTATUS st;
    PCSZ ImportString;

    //
    // Determine if snap is by name, or by ordinal.
    //

    Ordinal = (BOOLEAN)IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal);

    if (Ordinal) {
        OriginalOrdinalNumber = (ULONG)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);
        OrdinalNumber = (USHORT)(OriginalOrdinalNumber - ExportDirectory->Base);
        ImportString = NULL;
    } else {

        //
        // NOTICE-2000/08/27-DavePr
        // This should never happen, because we will only be called if either
        // Ordinal is set or ImageBase is not NULL.  But to satisfy prefix...
        //

        if (ImageBase == NULL) {
#if LDRDBG
            DbgPrint("LDR: ImageBase=NULL and !Ordinal\n");
#endif
            return STATUS_PROCEDURE_NOT_FOUND;
        }

        OriginalOrdinalNumber = 0;

         //
         // Change AddressOfData from an RVA to a VA.
         //

         AddressOfData = (PCIMAGE_IMPORT_BY_NAME)((ULONG_PTR)ImageBase + ((ULONG_PTR)OriginalThunk->u1.AddressOfData & 0xffffffff));
         ImportString = (PCSZ)AddressOfData->Name;

         //
         // Lookup Name in NameTable
         //

         NameTableBase = (PULONG)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfNames);
         NameOrdinalTableBase = (PUSHORT)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

         //
         // Before dropping into binary search, see if
         // the hint index results in a successful
         // match. If the hint index is zero, then
         // drop into binary search.
         //

        HintIndex = AddressOfData->Hint;
        if ((ULONG)HintIndex < ExportDirectory->NumberOfNames &&
            !strcmp(ImportString, (PSZ)((ULONG_PTR)DllBase + NameTableBase[HintIndex]))) {
            OrdinalNumber = NameOrdinalTableBase[HintIndex];
#if LDRDBG
            if (ShowSnaps) {
                DbgPrint("LDR: Snapping %s\n", ImportString);
            }
#endif
        } else {
#if LDRDBG
             if (HintIndex) {
                 DbgPrint("LDR: Warning HintIndex Failure. Name %s (%lx) Hint 0x%lx\n",
                     ImportString,
                     (ULONG)ImportString,
                     (ULONG)HintIndex);
             }
#endif
             OrdinalNumber = LdrpNameToOrdinal(
                               ImportString,
                               ExportDirectory->NumberOfNames,
                               DllBase,
                               NameTableBase,
                               NameOrdinalTableBase);
        }
    }

    //
    // If OrdinalNumber is not within the Export Address Table,
    // then DLL does not implement function. Snap to LDRP_BAD_DLL.
    //

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
baddllref:
#if DBG
        if (StaticSnap) {
            if (Ordinal) {
                DbgPrint("LDR: Can't locate ordinal 0x%lx\n", OriginalOrdinalNumber);
            }
            else {
                DbgPrint("LDR: Can't locate %s\n", ImportString);
            }
        }
#endif
        if ( StaticSnap ) {
            //
            // Hard Error Time
            //

            ULONG_PTR ErrorParameters[3];
            UNICODE_STRING ErrorDllName, ErrorEntryPointName;
            ANSI_STRING AnsiScratch;
            ULONG ParameterStringMask;
            ULONG ErrorResponse;
            NTSTATUS Status;

            RtlInitAnsiString(&AnsiScratch,DllName ? DllName : "Unknown");
            Status = RtlAnsiStringToUnicodeString(&ErrorDllName,&AnsiScratch,TRUE);
            if (NT_SUCCESS (Status)) {

                ErrorParameters[1] = (ULONG_PTR)&ErrorDllName;
                ParameterStringMask = 2;

                if ( Ordinal ) {
                    ErrorParameters[0] = OriginalOrdinalNumber;
                } else {
                    RtlInitAnsiString (&AnsiScratch, ImportString);
                    Status = RtlAnsiStringToUnicodeString(&ErrorEntryPointName,&AnsiScratch,TRUE);
                    if (NT_SUCCESS (Status)) {

                        ErrorParameters[0] = (ULONG_PTR)&ErrorEntryPointName;
                        ParameterStringMask = 3;
                    }
                }

                if (NT_SUCCESS (Status)) {
                    NtRaiseHardError(
                      Ordinal ? STATUS_ORDINAL_NOT_FOUND : STATUS_ENTRYPOINT_NOT_FOUND,
                      2,
                      ParameterStringMask,
                      ErrorParameters,
                      OptionOk,
                      &ErrorResponse
                      );

                    if (LdrpInLdrInit) {
                        LdrpFatalHardErrorCount += 1;
                    }
                    if (!Ordinal) {
                        RtlFreeUnicodeString (&ErrorEntryPointName);
                        RtlRaiseStatus (STATUS_ENTRYPOINT_NOT_FOUND);
                    }
                }

                RtlFreeUnicodeString(&ErrorDllName);

            }

            RtlRaiseStatus(STATUS_ORDINAL_NOT_FOUND);
        }

        Thunk->u1.Function = (ULONG_PTR)LDRP_BAD_DLL;
        st = Ordinal ? STATUS_ORDINAL_NOT_FOUND : STATUS_ENTRYPOINT_NOT_FOUND;

    } else {
        Addr = (PULONG)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
        Thunk->u1.Function = ((ULONG_PTR)DllBase + Addr[OrdinalNumber]);
        if (Thunk->u1.Function > (ULONG_PTR)ExportDirectory &&
            Thunk->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) {

            UNICODE_STRING UnicodeString;
            ANSI_STRING ForwardDllName;
            PVOID ForwardDllHandle;
            PANSI_STRING ForwardProcName;
            ULONG ForwardProcOrdinal;

            ImportString = (PCSZ)Thunk->u1.Function;
            ForwardDllName.Buffer = (PSZ)ImportString;
            // We should handle the case where strchr returns NULL or >32k.

            ForwardDllName.Length = (USHORT)(strchr(ImportString, '.') - ImportString);
            ForwardDllName.MaximumLength = ForwardDllName.Length;

            //
            // Most forwarders seem to point to NTDLL and since we know
            // that every process has ntdll already loaded and pinned
            // let's optimize away all the calls to load it.
            //

            if (ASCII_STRING_IS_NTDLL(&ForwardDllName)) {
                ForwardDllHandle = LdrpNtDllDataTableEntry->DllBase;
                st = STATUS_SUCCESS;
            } else {
                ForwardDllHandle = NULL;
                st = RtlAnsiStringToUnicodeString(&UnicodeString, &ForwardDllName, TRUE);

                if (NT_SUCCESS(st)) {
                    UNICODE_STRING AnotherUnicodeString = {0, 0, NULL};
                    PUNICODE_STRING UnicodeStringToUse = &UnicodeString;
                    ULONG LdrpLoadDllFlags = 0;

                    st = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            &UnicodeString,
                            &DefaultExtension,
                            NULL,
                            &AnotherUnicodeString,
                            &UnicodeStringToUse,
                            NULL,
                            NULL,
                            NULL);

                    if (NT_SUCCESS(st)) {
                        LdrpLoadDllFlags |= LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED;
                    }

                    if (st == STATUS_SXS_KEY_NOT_FOUND) {
                        st = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(st)) {
                        st = LdrpLoadDll(LdrpLoadDllFlags, NULL, NULL, UnicodeStringToUse, &ForwardDllHandle, FALSE);
                    }

                    if (AnotherUnicodeString.Buffer != NULL) {
                        RtlFreeUnicodeString(&AnotherUnicodeString);
                    }
                    RtlFreeUnicodeString(&UnicodeString);
                }
            }

            if (!NT_SUCCESS(st)) {
                goto baddllref;
            }

            RtlInitAnsiString (&ForwardDllName,
                               ImportString + ForwardDllName.Length + 1);

            if (ForwardDllName.Length > 1 &&
                *ForwardDllName.Buffer == '#') {

                ForwardProcName = NULL;

                st = RtlCharToInteger (ForwardDllName.Buffer+1,
                                       0,
                                       &ForwardProcOrdinal);

                if (!NT_SUCCESS(st)) {
                    goto baddllref;
                }
            }
            else {
                ForwardProcName = &ForwardDllName;

                //
                // Following line is not needed since this is a by name lookup,
                // but keep it in so the code can compile W4.
                //

                ForwardProcOrdinal = 0;
            }

            st = LdrpGetProcedureAddress (ForwardDllHandle,
                                          ForwardProcName,
                                          ForwardProcOrdinal,
                                          (PVOID*)&Thunk->u1.Function,
                                          FALSE);

            if (!NT_SUCCESS(st)) {
                goto baddllref;
            }
        }
        else {
            if ( !Addr[OrdinalNumber] ) {
                goto baddllref;
            }
        }
        st = STATUS_SUCCESS;
    }

    return st;
}


USHORT
LdrpNameToOrdinal (
    IN PCSZ Name,
    IN ULONG NumberOfNames,
    IN PVOID DllBase,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    )
{
    LONG High;
    LONG Low;
    LONG Middle;
    LONG Result;

    //
    // Lookup the import name in the name table using a binary search.
    //

    Low = 0;
    Middle = 0;
    High = NumberOfNames - 1;
    while (High >= Low) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;
        Result = strcmp(Name, (PCHAR)((ULONG_PTR)DllBase + NameTableBase[Middle]));

        if (Result < 0) {
            High = Middle - 1;

        } else if (Result > 0) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    //
    // If the high index is less than the low index, then a matching
    // table entry was not found. Otherwise, get the ordinal number
    // from the ordinal table.
    //

    if (High < Low) {
        return (USHORT)-1;
    } else {
        return NameOrdinalTableBase[Middle];
    }

}


VOID
LdrpUpdateLoadCount2 (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow
    )
{
    WCHAR PreAllocatedStringBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING PreAllocatedString = {0, sizeof(PreAllocatedStringBuffer), PreAllocatedStringBuffer};

    LdrpUpdateLoadCount3(LdrDataTableEntry, UpdateCountHow, &PreAllocatedString);
}


VOID
LdrpUpdateLoadCount3(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow,
    IN OUT PUNICODE_STRING PreAllocatedRedirectionBuffer OPTIONAL
    )
/*++

Routine Description:

    This function dereferences a loaded DLL adjusting its reference
    count.  It then dereferences each dll referenced by this dll.

Arguments:

    LdrDataTableEntry - Supplies the address of the DLL to dereference

    UpdateCountHow - 
        LDRP_UPDATE_LOAD_COUNT_INCREMENT add one
        LDRP_UPDATE_LOAD_COUNT_DECREMENT subtract one
        LDRP_UPDATE_LOAD_COUNT_PIN       set to 0xffff

    PreAllocatedRedirectionBuffer - optional pointer to a caller-allocated
        (usually on the stack) fixed-sized buffer to use for redirection
        to avoid having a large buffer on our stack used during recursion.

Return Value:

    None.

--*/

{
    PCIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    PCIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor;
    PCIMAGE_BOUND_FORWARDER_REF NewImportForwarder;
    PCSZ ImportName, NewImportStringBase;
    ULONG i, ImportSize, NewImportSize;
    ANSI_STRING AnsiString;
    PUNICODE_STRING ImportDescriptorName_U;
    PUNICODE_STRING ImportDescriptorNameToUse; // overrides ImportDescriptorName_U when redirection is turned on for a DLL
    PLDR_DATA_TABLE_ENTRY Entry;
    NTSTATUS st;
    PIMAGE_THUNK_DATA FirstThunk;
    UNICODE_STRING DynamicRedirectionString;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, LdrDataTableEntry->EntryPointActivationContext);
    __try {
        switch (UpdateCountHow
            ) {
            case LDRP_UPDATE_LOAD_COUNT_PIN:
            case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                if (LdrDataTableEntry->Flags & LDRP_LOAD_IN_PROGRESS) {
                    __leave;
                } else {
                    LdrDataTableEntry->Flags |= LDRP_LOAD_IN_PROGRESS;
                }
                break;
            case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                if (LdrDataTableEntry->Flags & LDRP_UNLOAD_IN_PROGRESS) {
                    __leave;
                } else {
                    LdrDataTableEntry->Flags |= LDRP_UNLOAD_IN_PROGRESS;
                }
                break;
        }

        //
        // For each DLL used by this DLL, reference or dereference the DLL.
        //

        if (LdrDataTableEntry->Flags & LDRP_COR_IMAGE) {
            //
            // The image is COR.  Ignore its import table and make it import
            // mscoree only.
            //
            const PCUNICODE_STRING xImportName = &MscoreeDllString;

            if (LdrpCheckForLoadedDll( NULL,
                                       xImportName,
                                       TRUE,
                                       FALSE,
                                       &Entry
                                     )
               ) {
                if ( Entry->LoadCount != 0xffff ) {
                    PCSTR SnapString = NULL;
                    switch (UpdateCountHow) {
                    case LDRP_UPDATE_LOAD_COUNT_PIN:
                        Entry->LoadCount = 0xffff;
                        SnapString = "Pin";
                        break;
                    case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                        Entry->LoadCount++;
                        SnapString = "Refcount";
                        break;
                    case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                        Entry->LoadCount--;
                        SnapString = "Derefcount";
                        break;
                    }
                    if (ShowSnaps) {
                        DbgPrint("LDR: %s %wZ (%lx)\n",
                                SnapString,
                                xImportName,
                                (ULONG)Entry->LoadCount
                                );
                    }
                }
                LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
            }
            __leave;
        }

        ImportDescriptorName_U = &NtCurrentTeb()->StaticUnicodeString;

        //
        // See if there is a bound import table.  If so, walk that to
        // determine DLL names to reference or dereference.  Avoids touching
        // the .idata section
        //
        NewImportDescriptor = (PCIMAGE_BOUND_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                               LdrDataTableEntry->DllBase,
                               TRUE,
                               IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                               &NewImportSize
                               );
        if (NewImportDescriptor) {
            switch (UpdateCountHow) {
                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                case LDRP_UPDATE_LOAD_COUNT_PIN:
                    LdrDataTableEntry->Flags |= LDRP_LOAD_IN_PROGRESS;
                    break;
                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                    LdrDataTableEntry->Flags |= LDRP_UNLOAD_IN_PROGRESS;
                    break;
            }
            NewImportStringBase = (LPSTR)NewImportDescriptor;
            while (NewImportDescriptor->OffsetModuleName) {
                ImportName = NewImportStringBase +
                             NewImportDescriptor->OffsetModuleName;
                RtlInitAnsiString(&AnsiString, ImportName);
                st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                if ( NT_SUCCESS(st) ) {
                    BOOLEAN Redirected = FALSE;

                    ImportDescriptorNameToUse = ImportDescriptorName_U;

                    RtlInitEmptyUnicodeString(&DynamicRedirectionString, NULL, 0);

                    st = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            ImportDescriptorName_U,
                            &DefaultExtension,
                            PreAllocatedRedirectionBuffer,
                            &DynamicRedirectionString,
                            &ImportDescriptorNameToUse,
                            NULL,
                            NULL,
                            NULL);
                    if (NT_SUCCESS(st)) {
                        Redirected = TRUE;
                    } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                        st = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(st)) {
                        if (LdrpCheckForLoadedDll( NULL,
                                                   ImportDescriptorNameToUse,
                                                   TRUE,
                                                   Redirected,
                                                   &Entry
                                                 )
                           ) {
                            if ( Entry->LoadCount != 0xffff ) {
                                PCSTR SnapString = NULL;
                                switch (UpdateCountHow) {
                                case LDRP_UPDATE_LOAD_COUNT_PIN:
                                    Entry->LoadCount = 0xffff;
                                    SnapString = "Pin";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                    Entry->LoadCount++;
                                    SnapString = "Refcount";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                    Entry->LoadCount--;
                                    SnapString = "Derefcount";
                                    break;
                                }
                                if (ShowSnaps) {
                                    DbgPrint("LDR: %s %wZ (%lx)\n",
                                            SnapString,
                                            ImportDescriptorNameToUse,
                                            (ULONG)Entry->LoadCount
                                            );
                                }
                            }
                            LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                        }

                        if (DynamicRedirectionString.Buffer != NULL)
                            RtlFreeUnicodeString(&DynamicRedirectionString);
                    }
                }

                NewImportForwarder = (PCIMAGE_BOUND_FORWARDER_REF)(NewImportDescriptor+1);
                for (i=0; i<NewImportDescriptor->NumberOfModuleForwarderRefs; i++) {
                    ImportName = NewImportStringBase +
                                 NewImportForwarder->OffsetModuleName;

                    RtlInitAnsiString(&AnsiString, ImportName);
                    st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                    if ( NT_SUCCESS(st) ) {
                        BOOLEAN Redirected = FALSE;

                        ImportDescriptorNameToUse = ImportDescriptorName_U;
                        RtlInitEmptyUnicodeString(&DynamicRedirectionString, NULL, 0);

                        st = RtlDosApplyFileIsolationRedirection_Ustr(
                                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                                ImportDescriptorName_U,
                                &DefaultExtension,
                                PreAllocatedRedirectionBuffer,
                                &DynamicRedirectionString,
                                &ImportDescriptorNameToUse,
                                NULL,
                                NULL,
                                NULL);
                        if (NT_SUCCESS(st)) {
                            Redirected = TRUE;
                        } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                            st = STATUS_SUCCESS;
                        }

                        if (NT_SUCCESS(st)) {
                            if (LdrpCheckForLoadedDll( NULL,
                                                       ImportDescriptorNameToUse,
                                                       TRUE,
                                                       Redirected,
                                                       &Entry
                                                     )
                               ) {
                                if ( Entry->LoadCount != 0xffff ) {
                                    PCSTR SnapString = NULL;
                                    switch (UpdateCountHow) {
                                    case LDRP_UPDATE_LOAD_COUNT_PIN:
                                        Entry->LoadCount = 0xffff;
                                        SnapString = "Pin";
                                        break;
                                    case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                        Entry->LoadCount++;
                                        SnapString = "Refcount";
                                        break;
                                    case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                        Entry->LoadCount--;
                                        SnapString = "Derefcount";
                                        break;
                                    }
                                    if (ShowSnaps) {
                                        DbgPrint("LDR: %s %wZ (%lx)\n",
                                                SnapString,
                                                ImportDescriptorNameToUse,
                                                (ULONG)Entry->LoadCount
                                                );
                                    }
                                }
                                LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                            }

                            if (DynamicRedirectionString.Buffer != NULL)
                                RtlFreeUnicodeString(&DynamicRedirectionString);
                        }
                    }

                    NewImportForwarder += 1;
                }

                NewImportDescriptor = (PCIMAGE_BOUND_IMPORT_DESCRIPTOR)NewImportForwarder;
            }

            __leave;
        }

        ImportDescriptor = (PCIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize
                            );
        if (ImportDescriptor) {

            while (ImportDescriptor->Name && ImportDescriptor->FirstThunk) {

                //
                // Match code in walk that skips references like this. IE3 had
                // some dll's with these bogus links to url.dll. On load, the url.dll
                // ref was skipped. On unload, it was not skipped because
                // this code was missing.
                //
                // Since the skip logic is only in the old style import
                // descriptor path, it is only duplicated here.
                //
                // check for import that has no references
                //
                FirstThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->FirstThunk);
                if ( !FirstThunk->u1.Function ) {
                    goto skipskippedimport;
                    }

                ImportName = (PCSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);

                RtlInitAnsiString(&AnsiString, ImportName);
                st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                if ( NT_SUCCESS(st) ) {
                    BOOLEAN Redirected = FALSE;                    

                    ImportDescriptorNameToUse = ImportDescriptorName_U;
                    RtlInitEmptyUnicodeString(&DynamicRedirectionString, NULL, 0);

                    st = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            ImportDescriptorName_U,
                            &DefaultExtension,
                            PreAllocatedRedirectionBuffer,
                            &DynamicRedirectionString,
                            &ImportDescriptorNameToUse,
                            NULL,
                            NULL,
                            NULL);
                    if (NT_SUCCESS(st)) {
                        Redirected = TRUE;
                    } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                        st = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(st)) {
                        if (LdrpCheckForLoadedDll( NULL,
                                                   ImportDescriptorNameToUse,
                                                   TRUE,
                                                   Redirected,
                                                   &Entry
                                                 )
                           ) {
                            if ( Entry->LoadCount != 0xffff ) {
                                PCSTR SnapString = NULL;
                                switch (UpdateCountHow) {
                                case LDRP_UPDATE_LOAD_COUNT_PIN:
                                    Entry->LoadCount = 0xffff;
                                    SnapString = "Pin";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                    Entry->LoadCount++;
                                    SnapString = "Refcount";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                    Entry->LoadCount--;
                                    SnapString = "Derefcount";
                                    break;
                                }
                                if (ShowSnaps) {
                                    DbgPrint("LDR: %s %wZ (%lx)\n",
                                            SnapString,
                                            ImportDescriptorNameToUse,
                                            (ULONG)Entry->LoadCount
                                            );
                                }
                            }
                            LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                        }

                        if (DynamicRedirectionString.Buffer != NULL) {
                            RtlFreeUnicodeString(&DynamicRedirectionString);
                        }
                    }
                }
    skipskippedimport:
                ++ImportDescriptor;
            }
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }
}


VOID
LdrpInsertMemoryTableEntry (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )

/*++

Routine Description:

    This function inserts a loader data table entry into the
    list of loaded modules for this process. The insertion is
    done in "image memory base order".

Arguments:

    LdrDataTableEntry - Supplies the address of the loader data table
        entry to insert in the list of loaded modules for this process.

Return Value:

    None.

--*/
{
    PPEB_LDR_DATA Ldr;
    ULONG i;

    Ldr = &PebLdr;

    i = LDRP_COMPUTE_HASH_INDEX(LdrDataTableEntry->BaseDllName.Buffer[0]);
    InsertTailList(&LdrpHashTable[i],&LdrDataTableEntry->HashLinks);
    InsertTailList(&Ldr->InLoadOrderModuleList, &LdrDataTableEntry->InLoadOrderLinks);

#if defined(_AMD64_) || defined(_IA64_)

    RtlInsertInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                   LdrDataTableEntry->DllBase,
                                   LdrDataTableEntry->SizeOfImage);

#endif

    InsertTailList(&Ldr->InMemoryOrderModuleList, &LdrDataTableEntry->InMemoryOrderLinks);
}


NTSTATUS
LdrpResolveDllName (
    IN PCWSTR DllPath OPTIONAL,
    IN PCWSTR DllName,
    IN BOOLEAN Redirected,
    OUT PUNICODE_STRING FullDllNameOut,
    OUT PUNICODE_STRING BaseDllNameOut,
    OUT PHANDLE DllFile
    )

/*++

Routine Description:

    This function computes the DLL pathname and base dll name (the
    unqualified, extensionless portion of the file name) for the specified
    DLL.

Arguments:

    DllPath - Supplies the DLL search path.

    DllName - Supplies the name of the DLL.

    FullDllName - Returns the fully qualified pathname of the
        DLL. The Buffer field of this string is dynamically
        allocated from the loader heap.

    BaseDLLName - Returns the base dll name of the dll.  The base name
        is the file name portion of the dll path without the trailing
        extension. The Buffer field of this string points into the
        FullDllName since the one is a substring of the other.

    DllFile - Returns an open handle to the DLL file. This parameter may
        still be NULL even upon success.

Return Value:

    TRUE - The operation was successful. A DLL file was found, and the
        FullDllName->Buffer & BaseDllName->Buffer field points to the
        base of process heap allocated memory.

    FALSE - The DLL could not be found.

--*/

{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    UNICODE_STRING DllNameString = { 0, 0, NULL };
    PUNICODE_STRING FullDllName;
    USHORT PrefixLength = 0;
    PCWSTR EffectiveDllPath = (DllPath != NULL) ? DllPath : LdrpDefaultPath.Buffer;
    WCHAR FullDllNameStaticBuffer[40]; // Arbitrary short length so most
                                       // d:\windows\system32\foobar.dll loads
                                       // don't need to search the search path twice
    UNICODE_STRING FullDllNameStaticString;
    UNICODE_STRING FullDllNameDynamicString;

    RtlInitEmptyUnicodeString(&FullDllNameStaticString,
                              FullDllNameStaticBuffer,
                              sizeof(FullDllNameStaticBuffer));

    RtlInitUnicodeString(&FullDllNameDynamicString, NULL);

    FullDllName = NULL;

    if (DllFile != NULL) {
        *DllFile = NULL;
    }

    if (FullDllNameOut != NULL) {
        FullDllNameOut->Length = 0;
        FullDllNameOut->MaximumLength = 0;
        FullDllNameOut->Buffer = NULL;
    }

    if (BaseDllNameOut != NULL) {
        BaseDllNameOut->Length = 0;
        BaseDllNameOut->MaximumLength = 0;
        BaseDllNameOut->Buffer = NULL;
    }

    if ((DllFile == NULL) ||
        (FullDllNameOut == NULL) ||
        (BaseDllNameOut == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&DllNameString, DllName);

    //
    // Look for ".local" redirection for this DLL.
    //

    st = LdrpResolveDllNameForAppPrivateRedirection (&DllNameString,
                                                     &FullDllNameDynamicString);

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s failed calling LdrpResolveDllNameForAppPrivateRediretion with status %lx\n",
            __FUNCTION__,
            st);
        return st;
    }

    //
    // .local always wins, so only search other solutions if that wasn't
    // the answer.
    //

    if (FullDllNameDynamicString.Length != 0) {

        *FullDllNameOut = FullDllNameDynamicString;

    } else {

        if (Redirected) {

            //
            // If the path was redirected, we assume that DllNameString is
            // an absolute path to the DLL so there's nothing more to do.
            //

            st = LdrpCopyUnicodeString (FullDllNameOut, &DllNameString);

            if (!NT_SUCCESS(st)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s failed call to LdrpCopyUnicodeString() in redirected case; status = %lx\n",
                    __FUNCTION__,
                    st);
                return st;
            }
        } else {

            //
            // Not redirected; search the search path.
            //

            if (! NT_SUCCESS( LdrpSearchPath (EffectiveDllPath,
                                              DllName,
                                              &FullDllNameStaticString,
                                              &FullDllNameDynamicString,
                                              &FullDllName))) {
                return STATUS_DLL_NOT_FOUND;
            }

            if (FullDllName == &FullDllNameStaticString) {
                st = LdrpCopyUnicodeString(FullDllNameOut,
                                           FullDllName);
                if (!NT_SUCCESS(st)) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s failed call to LdrpCopyUnicodeString() in redirected case; status = %lx\n",
                        __FUNCTION__,
                        st);
                    return st;
                }
            } else {
                *FullDllNameOut = *FullDllName;
            }
        }
    }

    //
    // Compute Length of base dll name
    //

    st = RtlFindCharInUnicodeString(
            RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
            FullDllNameOut,
            &RtlDosPathSeperatorsString,
            &PrefixLength);

    if (st == STATUS_NOT_FOUND) {

        *BaseDllNameOut = *FullDllNameOut;

    } else if (!NT_SUCCESS(st)) {

        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing because RtlFindCharInUnicodeString failed with status %x\n",
            __FUNCTION__,
            st);

        LdrpFreeUnicodeString (FullDllNameOut);
        RtlInitEmptyUnicodeString (FullDllNameOut, NULL, 0);
        return st;

    } else {

        //
        // The prefixlength is the number of bytes prior to the
        // path separator.  We also want to skip the path separator.
        //

        PrefixLength += sizeof(WCHAR);

        BaseDllNameOut->Length = FullDllNameOut->Length - PrefixLength;
        BaseDllNameOut->MaximumLength = FullDllNameOut->MaximumLength - PrefixLength;
        BaseDllNameOut->Buffer = (PWSTR) (((ULONG_PTR) FullDllNameOut->Buffer) + PrefixLength);
    }

    return STATUS_SUCCESS;
}


PVOID
LdrpFetchAddressOfEntryPoint (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the initialization routine.

Arguments:

    Base - Base of image.

Return Value:

    Status value

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG_PTR ep;

    NtHeaders = RtlImageNtHeader(Base);
    if (NtHeaders == NULL) {
        return NULL;
    }

    ep = NtHeaders->OptionalHeader.AddressOfEntryPoint;
    if (ep != 0) {
        ep += (ULONG_PTR) Base;
    }

    return (PVOID) ep;
}


NTSTATUS
LdrpCheckForKnownDll (
    IN PCWSTR DllName,
    OUT PUNICODE_STRING FullDllNameOut,
    OUT PUNICODE_STRING BaseDllNameOut,
    OUT HANDLE *SectionOut
    )

/*++

Routine Description:

    This function checks to see if the specified DLL is a known DLL.
    It assumes it is only called for static DLL's, and when
    the known DLL directory structure has been set up.

Arguments:

    DllName - Supplies the name of the DLL.

    FullDllName - Returns the fully qualified pathname of the
        DLL. The Buffer field of this string is dynamically
        allocated from the processes heap.

    BaseDLLName - Returns the base dll name of the dll.  The base name
        is the file name portion of the dll path without the trailing
        extension. The Buffer field of this string is dynamically
        allocated from the processes heap.

    SectionOut - Returns an open handle to the section associated with
        the DLL

Return Value:

    Appropriate NTSTATUS code

--*/

{
    UNICODE_STRING Unicode;
    HANDLE Section = NULL;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    ULONG FullLength = 0;
    UNICODE_STRING FullDllName = { 0, 0, NULL };
    PPEB Peb;

    if (SectionOut != NULL) {
        *SectionOut = NULL;
    }

    if (FullDllNameOut != NULL) {
        FullDllNameOut->Length = 0;
        FullDllNameOut->MaximumLength = 0;
        FullDllNameOut->Buffer = NULL;
    }

    if (BaseDllNameOut != NULL) {
        BaseDllNameOut->Length = 0;
        BaseDllNameOut->MaximumLength = 0;
        BaseDllNameOut->Buffer = NULL;
    }

    if ((SectionOut == NULL) ||
        (FullDllNameOut == NULL) ||
        (BaseDllNameOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    LdrpEnsureLoaderLockIsHeld ();

    //
    // calculate base name
    //

    RtlInitUnicodeString(&Unicode, DllName);

    Peb = NtCurrentPeb ();

    //check DLL_REDIRECTION by .local file
    if ((Peb->ProcessParameters != NULL) &&
        (Peb->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL) &&
        (Unicode.Length != 0)) { // dll redirection with .local

        UNICODE_STRING NewDllNameUnderImageDir, NewDllNameUnderLocalDir;
        static WCHAR DllNameUnderImageDirBuffer[DOS_MAX_PATH_LENGTH];
        static WCHAR DllNameUnderLocalDirBuffer[DOS_MAX_PATH_LENGTH];
        BOOLEAN fIsKnownDll = TRUE;  // not known yet,

        NewDllNameUnderImageDir.Buffer = DllNameUnderImageDirBuffer;
        NewDllNameUnderImageDir.Length = 0 ;
        NewDllNameUnderImageDir.MaximumLength = sizeof(DllNameUnderImageDirBuffer) ;

        NewDllNameUnderLocalDir.Buffer = DllNameUnderLocalDirBuffer;
        NewDllNameUnderLocalDir.Length = 0 ;
        NewDllNameUnderLocalDir.MaximumLength = sizeof(DllNameUnderLocalDirBuffer) ;

        Status = RtlComputePrivatizedDllName_U(&Unicode, &NewDllNameUnderImageDir, &NewDllNameUnderLocalDir) ;
        if(!NT_SUCCESS(Status)) {
            goto Exit;
        }

        if ((RtlDoesFileExists_U(NewDllNameUnderLocalDir.Buffer)) ||
            (RtlDoesFileExists_U(NewDllNameUnderImageDir.Buffer))) {
            fIsKnownDll = FALSE;
        }

        //cleanup
        if (NewDllNameUnderLocalDir.Buffer != DllNameUnderLocalDirBuffer) {
            (*RtlFreeStringRoutine)(NewDllNameUnderLocalDir.Buffer);
        }

        if (NewDllNameUnderImageDir.Buffer != DllNameUnderImageDirBuffer) {
            (*RtlFreeStringRoutine)(NewDllNameUnderImageDir.Buffer);
        }

        if (!fIsKnownDll) { // must not be a known dll
            Status = STATUS_SUCCESS;
            goto Exit;
        }
    }

    // If the DLL is being redirected via Fusion/Side-by-Side support, don't bother with the
    // KnownDLL mechanism.
    Status = RtlFindActivationContextSectionString(
            0,              // flags - none for now
            NULL,           // default section group
            ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
            &Unicode,       // string to look for
            NULL);          // we don't want any data back, just look for existence

    if ((Status != STATUS_SXS_SECTION_NOT_FOUND) &&
        (Status != STATUS_SXS_KEY_NOT_FOUND))
    {
        if (NT_SUCCESS(Status)) {
            Status = STATUS_SUCCESS;
        }

        goto Exit;
    }

    //
    // now compute the full name for the dll
    //

    FullLength = LdrpKnownDllPath.Length +  // path prefix e.g. c:\windows\system32
                 RtlCanonicalDosPathSeperatorString.Length +
                 Unicode.Length; // base

    if (FullLength > UNICODE_STRING_MAX_BYTES) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    Status = LdrpAllocateUnicodeString(&FullDllName, (USHORT) FullLength);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    RtlAppendUnicodeStringToString(&FullDllName, &LdrpKnownDllPath);
    RtlAppendUnicodeStringToString(&FullDllName, &RtlCanonicalDosPathSeperatorString);
    RtlAppendUnicodeStringToString(&FullDllName, &Unicode);

    ASSERT(FullDllName.Length == FullLength);

    //
    // open the section object
    //

    InitializeObjectAttributes (&Obja,
                                &Unicode,
                                OBJ_CASE_INSENSITIVE,
                                LdrpKnownDllObjectDirectory,
                                NULL);

    Status = NtOpenSection (&Section,
                            SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                            &Obja);

    if (!NT_SUCCESS(Status)) {
        // STATUS_OBJECT_NAME_NOT_FOUND is the expected reason to fail, so it's OK
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }

        goto Exit;
    }

#if DBG
    LdrpSectionOpens += 1;
#endif // DBG

    BaseDllNameOut->Length = Unicode.Length;
    BaseDllNameOut->MaximumLength = Unicode.Length + sizeof(WCHAR);
    BaseDllNameOut->Buffer = (PWSTR) (((ULONG_PTR) FullDllName.Buffer) + (FullDllName.Length - Unicode.Length));

    *FullDllNameOut = FullDllName;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = 0;
    FullDllName.Buffer = NULL;

    *SectionOut = Section;
    Section = NULL;

    Status = STATUS_SUCCESS;

Exit:
    if (Section != NULL) {
        NtClose(Section);
    }

    if (FullDllName.Buffer != NULL) {
        LdrpFreeUnicodeString(&FullDllName);
    }

    return Status;
}


NTSTATUS
LdrpSetProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    This function loops thru the images sections/objects, setting
    all sections/objects marked r/o to r/w. It also resets the
    original section/object protections.

Arguments:

    Base - Base of image.

    Reset - If TRUE, reset section/object protection to original
            protection described by the section/object headers.
            If FALSE, then set all sections/objects to r/w.

Return Value:

    SUCCESS or reason NtProtectVirtualMemory failed.

--*/

{
    HANDLE CurrentProcessHandle;
    SIZE_T RegionSize;
    ULONG NewProtect, OldProtect;
    PVOID VirtualAddress;
    ULONG i;
    PIMAGE_NT_HEADERS NtHeaders;
    PCIMAGE_SECTION_HEADER SectionHeader;
    NTSTATUS st;

    CurrentProcessHandle = NtCurrentProcess();

    NtHeaders = RtlImageNtHeader(Base);

    if (! NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

#if defined(BUILD_WOW6432)

    if (NtHeaders->OptionalHeader.SectionAlignment < NativePageSize) {
        
        SIZE_T ReturnLength;
        MEMORY_BASIC_INFORMATION MemoryInformation;

        st = NtQueryVirtualMemory (CurrentProcessHandle,
                                   Base,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof MemoryInformation,
                                   &ReturnLength);

        if ((NT_SUCCESS(st)) &&
            ((MemoryInformation.Protect == PAGE_READONLY) ||
            (MemoryInformation.Protect == PAGE_EXECUTE_READ))) {

            //
            // March on and make sections writable as this image is natively
            // formatted with proper protections.
            //

            NOTHING;
        }
        else {

            //
            // Reset protection on the image pages if this is a Wow64 image.
            //

            return LdrpWx86ProtectImagePages (Base, Reset);
        }
    }
#endif

    SectionHeader = (PCIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                        sizeof(IMAGE_FILE_HEADER) +
                        NtHeaders->FileHeader.SizeOfOptionalHeader
                        );

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {

        if (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE) &&
            (SectionHeader->SizeOfRawData)) {

            //
            // Object isn't writable and has a non-zero on disk size, change it.
            //
            if (Reset) {
                if (SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                    NewProtect = PAGE_EXECUTE;
                } else {
                    NewProtect = PAGE_READONLY;
                }
                NewProtect |= (SectionHeader->Characteristics & IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOCACHE : 0;
            } else {
                NewProtect = PAGE_READWRITE;
            }

            VirtualAddress = (PVOID)((ULONG_PTR)Base + SectionHeader->VirtualAddress);
            RegionSize = SectionHeader->SizeOfRawData;

            if (RegionSize != 0) {
                st = NtProtectVirtualMemory (CurrentProcessHandle,
                                             &VirtualAddress,
                                             &RegionSize,
                                             NewProtect, 
                                             &OldProtect);

                if (!NT_SUCCESS(st)) {
                    return st;
                }
            }

        }
        ++SectionHeader;
    }

    if (Reset) {
        NtFlushInstructionCache(CurrentProcessHandle, NULL, 0);
    }
    return STATUS_SUCCESS;
}


NTSTATUS
LdrpResolveDllNameForAppPrivateRedirection(
    PCUNICODE_STRING DllNameString,
    PUNICODE_STRING FullDllName
    )
/*++

Routine Description:

    This function takes a DLL name that's to be loaded, and if there was
    a .local file in the app dir to cause redirection, returns the full
    path to the file.

Arguments:

    DllNameString - Name of the DLL under consideration.  May be a full or
        partially qualified path.

    FullDllName - output string.  Must be deallocated using
        LdrpFreeUnicodeString().  If no redirection was present, the
        length will be left zero.

Return Value:

    NTSTATUS indicating the success/failure of this function.

--*/

{
    PPEB Peb;
    NTSTATUS st = STATUS_INTERNAL_ERROR;

    UNICODE_STRING FullDllNameUnderImageDir;
    UNICODE_STRING FullDllNameUnderLocalDir;

    // These two are static to relieve some stack size issues; this function is only called with the
    // loader lock taken so access is properly synchronized.
    static WCHAR DllNameUnderImageDirBuffer[DOS_MAX_PATH_LENGTH];
    static WCHAR DllNameUnderLocalDirBuffer[DOS_MAX_PATH_LENGTH];

    // Initialize these so that cleanup at the Exit: label an always just check whether
    // they're not null and don't point to the static buffers and then free them.

    FullDllNameUnderImageDir.Buffer = DllNameUnderImageDirBuffer;
    FullDllNameUnderImageDir.Length = 0 ;
    FullDllNameUnderImageDir.MaximumLength = sizeof(DllNameUnderImageDirBuffer);

    FullDllNameUnderLocalDir.Buffer = DllNameUnderLocalDirBuffer;
    FullDllNameUnderLocalDir.Length = 0 ;
    FullDllNameUnderLocalDir.MaximumLength = sizeof(DllNameUnderLocalDirBuffer);

    if (FullDllName != NULL) {
        FullDllName->Length = 0;
        FullDllName->MaximumLength = 0;
        FullDllName->Buffer = NULL;
    }

    if ((FullDllName == NULL) ||
        (DllNameString == NULL)) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    st = RtlValidateUnicodeString(0, DllNameString);
    if (!NT_SUCCESS(st)) {
        goto Exit;
    }

    Peb = NtCurrentPeb ();

    if ((Peb->ProcessParameters != NULL) &&
        (Peb->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL) &&
        (DllNameString->Length != 0)) { // dll redirection with .local

        st = RtlComputePrivatizedDllName_U(DllNameString, &FullDllNameUnderImageDir, &FullDllNameUnderLocalDir);

        if(!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                DPFLTR_ERROR_LEVEL,
                "LDR: %s call to RtlComputePrivatizedDllName_U() failed with status %lx\n",
                __FUNCTION__,
                st);
            goto Exit;
        }

        if (RtlDoesFileExists_U(FullDllNameUnderLocalDir.Buffer)) {// there is a local dll, use it
            st = LdrpCopyUnicodeString(FullDllName, &FullDllNameUnderLocalDir);
            if (!NT_SUCCESS(st)) {
                if (ShowSnaps)
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        DPFLTR_ERROR_LEVEL,
                        "LDR: %s calling LdrpCopyUnicodeString() failed; exiting with status %lx\n",
                        __FUNCTION__,
                        st);

                goto Exit;
            }
        } else if (RtlDoesFileExists_U(FullDllNameUnderImageDir.Buffer)) { // there is a local dll, use it
            st = LdrpCopyUnicodeString(FullDllName, &FullDllNameUnderImageDir);
            if (!NT_SUCCESS(st)) {
                if (ShowSnaps)
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        DPFLTR_ERROR_LEVEL,
                        "LDR: %s calling LdrpCopyUnicodeString() failed; exiting with status %lx\n",
                        __FUNCTION__,
                        st);

                goto Exit;
            }
        }
    }

    st = STATUS_SUCCESS;
Exit:
    if ((FullDllNameUnderImageDir.Buffer != NULL) &&
        (FullDllNameUnderImageDir.Buffer != DllNameUnderImageDirBuffer))
        (*RtlFreeStringRoutine)(FullDllNameUnderImageDir.Buffer);

    if ((FullDllNameUnderLocalDir.Buffer != NULL) &&
        (FullDllNameUnderLocalDir.Buffer != DllNameUnderLocalDirBuffer))
        (*RtlFreeStringRoutine)(FullDllNameUnderLocalDir.Buffer);

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\propset.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:	propset.h
//
// Contents:	OLE Appendix B property set structure definitions
//
// History:	15-Jul-94       brianb    created
//		15-Aug-94       SethuR    revised
//              22-Feb-96       MikeHill  Changed cb in tagENTRY to cch.
//              28-May-96       MikeHill  Changed OSVER_* to OSKIND_*.
//
//---------------------------------------------------------------------------

#ifndef _PROPSET_H_
#define _PROPSET_H_

// CBMAXPROPSETSTREAM must be a power of 2.
#define CBMAXPROPSETSTREAM	(256 * 1024)

#define IsIndirectVarType(vt)			\
	    ((vt) == VT_STREAM ||		\
	     (vt) == VT_STREAMED_OBJECT ||	\
	     (vt) == VT_STORAGE ||		\
	     (vt) == VT_STORED_OBJECT)


// Defines for the high order WORD of dwOSVer:

#define OSKIND_WINDOWS      0x0000
#define OSKIND_MACINTOSH    0x0001
#define OSKIND_WIN32        0x0002


typedef struct tagFORMATIDOFFSET	// fo
{
    FMTID	fmtid;
    DWORD	dwOffset;
} FORMATIDOFFSET;

#define CB_FORMATIDOFFSET	sizeof(FORMATIDOFFSET)


typedef struct tagPROPERTYSETHEADER	// ph
{
    WORD        wByteOrder;	// Always 0xfffe
    WORD        wFormat;	// Always 0
    DWORD       dwOSVer;	// System version
    CLSID       clsid;		// Application CLSID
    DWORD       reserved;	// reserved (must be at least 1)
} PROPERTYSETHEADER;

#define CB_PROPERTYSETHEADER	sizeof(PROPERTYSETHEADER)
#define PROPSET_BYTEORDER       0xFFFE


typedef struct tagPROPERTYIDOFFSET	// po
{
    DWORD       propid;
    DWORD       dwOffset;
} PROPERTYIDOFFSET;

#define CB_PROPERTYIDOFFSET	sizeof(PROPERTYIDOFFSET)


typedef struct tagPROPERTYSECTIONHEADER	// sh
{
    DWORD       cbSection;
    DWORD       cProperties;
    PROPERTYIDOFFSET rgprop[1];
} PROPERTYSECTIONHEADER;

#define CB_PROPERTYSECTIONHEADER FIELD_OFFSET(PROPERTYSECTIONHEADER, rgprop)


typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;

#define CB_SERIALIZEDPROPERTYVALUE  FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb)


typedef struct tagENTRY			// ent
{
    DWORD propid;
    DWORD cch;			// Includes trailing '\0' or L'\0'
    char  sz[1];		// WCHAR if UNICODE CodePage
} ENTRY;

#define CB_ENTRY		FIELD_OFFSET(ENTRY, sz)


typedef struct tagDICTIONARY		// dy
{
    DWORD	cEntries;
    ENTRY	rgEntry[1];
} DICTIONARY;

#define CB_DICTIONARY		FIELD_OFFSET(DICTIONARY, rgEntry)

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\pch.cxx ===
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4100)   // unreferenced formal parameter
#pragma warning(disable:4512)   // assignment operator could not be generated

extern "C" {
#include <ntos.h>
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
}

#if defined(__cplusplus)
__forceinline
int
IsEqualGUID(
    const GUID UNALIGNED * pa,
    const GUID UNALIGNED * pb
    )
{
    return (!memcmp(pa, pb, sizeof(GUID)));
}
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\propvar.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:        propvar.h
//
// Contents:    PROPVARIANT manipulation code
//
// History:     15-Aug-95   vich        created
//              01-Jul-96   MikeHill    Updated to allow Win32 SEH removal
//
//---------------------------------------------------------------------------

#ifndef _PROPVAR_H_
#define _PROPVAR_H_

#include <debnot.h>
#include <propset.h>

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect);

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus);

BOOLEAN
RtlConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN
RtlConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);




SERIALIZEDPROPERTYVALUE *
PrConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect);

SERIALIZEDPROPERTYVALUE *
PrConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus);

BOOLEAN
PrConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN
PrConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);





#ifndef KERNEL
VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma);
#endif

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif


//+--------------------------------------------------------------------------
// Function:    SignalOverflow, SignalInvalidParameter, SignalStatus
//
// Synopsis:    ASSERT and raise data corrupt/overflow/specified error
//
// Arguments:   [szReason]              -- string explanation
//              [Status]                -- Status to raise (SignalStatus only)
//
// Returns:     None
//+--------------------------------------------------------------------------


#define StatusOverflow(pstatus, szReason)           \
          *(pstatus) = STATUS_BUFFER_OVERFLOW;      \
          TraceStatus(szReason)

#define StatusAccessDenied(pstatus, szReason)   \
          *(pstatus) = STATUS_ACCESS_DENIED;        \
          TraceStatus(szReason);

#define StatusInvalidParameter(pstatus, szReason)   \
          *(pstatus) = STATUS_INVALID_PARAMETER;    \
          TraceStatus(szReason);

#define StatusNoMemory(pstatus, szReason)           \
          *(pstatus) = STATUS_INSUFFICIENT_RESOURCES;\
          TraceStatus(szReason);

#define StatusDiskFull(pstatus, szReason)           \
          *(pstatus) = STATUS_DISK_FULL;            \
          TraceStatus(szReason);

#define StatusError(pstatus, szReason, Status)      \
          *(pstatus) = Status;                      \
          TraceStatus(szReason);

#ifdef KERNEL
#define StatusKBufferOverflow(pstatus, szReason) StatusOverflow(pstatus, szReason)
#else
#define StatusKBufferOverflow(pstatus, szReason) StatusNoMemory(pstatus, szReason)
#endif


#ifdef KERNEL
#define KERNELSELECT(k, u)      k
#else
#define KERNELSELECT(k, u)      u
#endif

#define DBGPROPASSERT   KERNELSELECT(DBGPROP, DBG)

#if DBGPROPASSERT
#define TraceStatus(szReason)                                   \
	{							\
	    DebugTrace(0, DEBTRACE_ERROR, (szReason "\n"));     \
	    PROPASSERTMSG(szReason, !(DebugLevel & DEBTRACE_WARN)); \
	}


#else
#define TraceStatus(szReason)
#endif



#define AssertVarField(field, cb) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, iVal) == FIELD_OFFSET(PROPVARIANT, field) && \
	 sizeof(((PROPVARIANT *) 0)->field) == (cb))

#define AssertVarVector(field, cbElem) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, cai.cElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.cElems) && \
         FIELD_OFFSET(PROPVARIANT, cai.pElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.pElems) && \
	 sizeof(((PROPVARIANT *) 0)->field.pElems[0]) == (cbElem))

#define AssertByteField(field)	    AssertVarField(field, sizeof(BYTE))
#define AssertShortField(field)	    AssertVarField(field, sizeof(SHORT))
#define AssertLongField(field)	    AssertVarField(field, sizeof(LONG))
#define AssertLongLongField(field)  AssertVarField(field, sizeof(LONGLONG))
#define AssertStringField(field)    AssertVarField(field, sizeof(VOID *))

#define AssertByteVector(field)	    AssertVarVector(field, sizeof(BYTE))
#define AssertShortVector(field)    AssertVarVector(field, sizeof(SHORT))
#define AssertLongVector(field)	    AssertVarVector(field, sizeof(LONG))
#define AssertLongLongVector(field) AssertVarVector(field, sizeof(LONGLONG))
#define AssertStringVector(field)   AssertVarVector(field, sizeof(VOID *))
#define AssertVariantVector(field)  AssertVarVector(field, sizeof(PROPVARIANT))


#define BSTRLEN(bstrVal)	*((ULONG *) bstrVal - 1)


//+-------------------------------------------------------------------
// Class:       CBufferAllocator, private
//
// Synopsis:    allocation from a buffer
//
// Notes:       The Summary catalog APIs use a single buffer to serialize row
//              values on input and deserialize them on output.  This class
//              encapsulates the memory allocation routines for these APIs.
//--------------------------------------------------------------------

class CBufferAllocator : public PMemoryAllocator
{
public:
    inline CBufferAllocator(ULONG cbBuffer, VOID *pvBuffer)
    {
	_cbFree = cbBuffer;
	_pvCur = _pvBuffer = pvBuffer;
#if defined(_X86_)
	PROPASSERT(((ULONG) _pvCur & (sizeof(LONG) - 1)) == 0);
#else
	PROPASSERT(((ULONG_PTR) _pvCur & (sizeof(LONGLONG) - 1)) == 0);
#endif // defined(_X86_)
    }

    VOID *Allocate(ULONG cbSize);
    VOID Free(VOID *pv) { }

    inline ULONG GetFreeSize(VOID) { return(_cbFree); }

private:
    ULONG  _cbFree;
    VOID  *_pvCur;
    VOID  *_pvBuffer;
};

//+-------------------------------------------------------------------
// Member:      CBufferAllocator::Allocate, private
//
// Synopsis:    allocation from a buffer
//
// Arguments:   [cb]	-- Count of bytes to be allocated.
//
// Returns:     pointer to 'allocated' memory -- NULL if no space left
//--------------------------------------------------------------------

#define DEFINE_CBufferAllocator__Allocate			\
VOID *								\
CBufferAllocator::Allocate(ULONG cb)				\
{								\
    VOID *pv;							\
								\
    if (cb > (MAXULONG - sizeof(LONGLONG) + 1))			\
    {								\
        return(NULL);						\
    }								\
    cb = (cb + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);	\
    if (cb > _cbFree)						\
    {								\
        return(NULL);						\
    }								\
    pv = _pvCur;						\
    _pvCur = (BYTE *) _pvCur + cb;				\
    _cbFree -= cb;						\
    return(pv);							\
}

#endif // !_PROPVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\query.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the RtlQueryProcessInformation function

Author:

    Steve Wood (stevewo) 01-Apr-1994

Revision History:

--*/

#include "ldrp.h"
#include <ntos.h>
#include <stktrace.h>
#include <heap.h>
#include <stdio.h>

#define AdjustPointer( t, p, d ) (p); if ((p) != NULL) (p) = (t)((ULONG_PTR)(p) + (d))

//
// Define the offset from the real control data to the copy thats mapped into target processes.
// We need to copies so the target process can't corrupt the information.
//
#define CONTROL_OFFSET (0x10000)

#define CONTROL_TO_FAKE(Buffer) ((PRTL_DEBUG_INFORMATION)((PUCHAR)(Buffer) + CONTROL_OFFSET))
#define FAKE_TO_CONTROL(Buffer) ((PRTL_DEBUG_INFORMATION)((PUCHAR)(Buffer) - CONTROL_OFFSET))


NTSYSAPI
NTSTATUS
NTAPI
RtlpQueryProcessDebugInformationRemote(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    This is the target routine for a remote query. It runds in the context of an injected thread.
    If event pairs are used then this code loops repeatedly as an optimization.

Arguments:

    Buffer - Query buffer to fill out with the query results

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;
    ULONG i;
    ULONG_PTR Delta;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;
    HANDLE EventPairTarget;

    EventPairTarget = Buffer->EventPairTarget;

    if (EventPairTarget != NULL) {
        Status = NtWaitLowEventPair (EventPairTarget);
    } else {
        Status = STATUS_SUCCESS;
    }

    while (NT_SUCCESS (Status)) {
        Status = RtlQueryProcessDebugInformation (NtCurrentTeb()->ClientId.UniqueProcess,
                                                  Buffer->Flags,
                                                  Buffer);
        if (NT_SUCCESS (Status)) {
            Delta = Buffer->ViewBaseDelta;
            if (Delta) {
                //
                // Need to relocate buffer pointers back to client addresses
                //
                AdjustPointer (PRTL_PROCESS_MODULES, Buffer->Modules, Delta);
                AdjustPointer (PRTL_PROCESS_BACKTRACES, Buffer->BackTraces, Delta);
                Heaps = AdjustPointer (PRTL_PROCESS_HEAPS, Buffer->Heaps, Delta);
                if (Heaps != NULL) {
                    for (i=0; i<Heaps->NumberOfHeaps; i++) {
                        HeapInfo = &Heaps->Heaps[ i ];
                        AdjustPointer (PRTL_HEAP_TAG, HeapInfo->Tags, Delta);
                        AdjustPointer (PRTL_HEAP_ENTRY, HeapInfo->Entries, Delta);
                    }
                }

                AdjustPointer (PRTL_PROCESS_LOCKS, Buffer->Locks, Delta);
            }
        }


        //
        // If we were supposed to be a one shot then exit now.
        //
        if (EventPairTarget == NULL) {
            //
            // If no event pair handle, then exit loop and terminate
            //
            break;
        }

        Status = NtSetHighWaitLowEventPair (EventPairTarget);

        //
        // The client side will clear this variable to signal we should exit
        //
        if (Buffer->EventPairTarget == NULL) {
            //
            // If no event pair handle, then exit loop and terminate
            //
            break;
        }

    }

    //
    // All done with buffer, remove from our address space
    // then terminate ourselves so client wakes up.
    //
    Buffer->ViewBaseTarget = NULL;
    Status1 = NtUnmapViewOfSection (NtCurrentProcess(), Buffer);
    ASSERT (NT_SUCCESS (Status1));
    RtlExitUserThread (Status);

    //
    // NEVER REACHED.
    //
}


NTSTATUS
RtlpChangeQueryDebugBufferTarget(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN HANDLE TargetProcessId,
    OUT PHANDLE ReturnedTargetProcessHandle OPTIONAL
    )
/*++

Routine Description:

    This routine changes the target process being queried. If the current target is set then we 
    cleanup any state assocuated with this query. If we are using event pairs then we causes the
    cached thread to exit the target.

Arguments:

    Buffer - Query buffer to be assigned and deassigned from the processes.

    TargetProcessId - New target to be queueried. If NULL then just clear current context

    ReturnedProcessHandle - OPTIONAL, If present receives the process handle of the new target
                            if there is one.

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;
    CLIENT_ID OldTargetClientId, NewTargetClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE OldTargetProcess, NewTargetProcess, NewHandle;
    PRTL_DEBUG_INFORMATION TargetBuffer;
    LARGE_INTEGER SectionOffset;
    HANDLE EventPairTarget = NULL;

    TargetBuffer = CONTROL_TO_FAKE (Buffer);

    if (Buffer->EventPairClient != NULL &&
        Buffer->TargetProcessId == TargetProcessId) {
        return STATUS_SUCCESS;
    }

    if (Buffer->TargetThreadHandle != NULL) {

        EventPairTarget = Buffer->EventPairTarget;
        TargetBuffer->EventPairTarget = NULL;
        Buffer->EventPairTarget = NULL;
        if (Buffer->EventPairClient != NULL) {
            Status = NtSetLowEventPair (Buffer->EventPairClient);
            ASSERT (NT_SUCCESS (Status));
        }
        Status = NtWaitForSingleObject (Buffer->TargetThreadHandle,
                                        TRUE,
                                        NULL);

        Status = NtClose (Buffer->TargetThreadHandle);
        Buffer->TargetThreadHandle = NULL;

        ASSERT (NT_SUCCESS (Status));

        Status = NtClose (Buffer->TargetProcessHandle);
        Buffer->TargetProcessHandle = NULL;
        ASSERT (NT_SUCCESS (Status));
    }


    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL
                              );


    if (Buffer->TargetProcessId != NULL) {
        OldTargetClientId.UniqueProcess = Buffer->TargetProcessId;
        OldTargetClientId.UniqueThread = 0;
        Status = NtOpenProcess (&OldTargetProcess,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                &OldTargetClientId);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        OldTargetProcess = NtCurrentProcess ();
    }

    if (ARGUMENT_PRESENT( TargetProcessId )) {
        NewTargetClientId.UniqueProcess = TargetProcessId;
        NewTargetClientId.UniqueThread = 0;
        Status = NtOpenProcess( &NewTargetProcess,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                &NewTargetClientId
                              );
        if (!NT_SUCCESS( Status )) {
            if (EventPairTarget != NULL) {
                Status = NtDuplicateObject (OldTargetProcess,
                                            EventPairTarget,
                                            NULL,
                                            NULL,
                                            0,
                                            0,
                                            DUPLICATE_CLOSE_SOURCE);
                //
                // The target process could have closed the handle to cause us problems.
                // We ignore this error as the target is only damaging itself.
                //
            }
            if (OldTargetProcess != NtCurrentProcess()) {
                Status1 = NtClose (OldTargetProcess);
                ASSERT (NT_SUCCESS (Status1));
            }
            return Status;
        }
    } else {
        NewTargetProcess = NULL;
    }

    NewHandle = NULL;
    if (Buffer->EventPairClient) {
        if (EventPairTarget != NULL) {
            Status = NtDuplicateObject (OldTargetProcess,
                                        EventPairTarget,
                                        NULL,
                                        NULL,
                                        0,
                                        0,
                                        DUPLICATE_CLOSE_SOURCE);
            //
            // The target process could have closed the handle to cause us problems.
            // We ignore this error as the target is only damaging itself.
            //
        }
        if (NewTargetProcess != NULL) {
            Status = NtDuplicateObject (NtCurrentProcess (),
                                        Buffer->EventPairClient,
                                        NewTargetProcess,
                                        &NewHandle,
                                        0,
                                        0,
                                        DUPLICATE_SAME_ACCESS);
            if (!NT_SUCCESS (Status)) {
                if (OldTargetProcess != NtCurrentProcess()) {
                    Status1 = NtClose (OldTargetProcess);
                    ASSERT (NT_SUCCESS (Status1));
                }
                NtClose (NewTargetProcess);
                return Status;
            }
        }

    }

    if (OldTargetProcess != NtCurrentProcess()) {
        if (TargetBuffer->ViewBaseTarget != NULL) {
            Status1 = NtUnmapViewOfSection (OldTargetProcess, TargetBuffer->ViewBaseTarget);
            TargetBuffer->ViewBaseTarget = NULL;
        }
        Status1 = NtClose (OldTargetProcess);
        ASSERT (NT_SUCCESS (Status1));
    } else {
        Buffer->ViewBaseTarget = Buffer->ViewBaseClient;
    }

    SectionOffset.QuadPart = CONTROL_OFFSET;
    if (NewTargetProcess != NULL) {
        Status = NtMapViewOfSection( Buffer->SectionHandleClient,
                                     NewTargetProcess,
                                     &Buffer->ViewBaseTarget,
                                     0,
                                     0,
                                     &SectionOffset,
                                     &Buffer->ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE
                                   );
        if (Status == STATUS_CONFLICTING_ADDRESSES) {
            Buffer->ViewBaseTarget = NULL;
            Status = NtMapViewOfSection( Buffer->SectionHandleClient,
                                         NewTargetProcess,
                                         &Buffer->ViewBaseTarget,
                                         0,
                                         0,
                                         &SectionOffset,
                                         &Buffer->ViewSize,
                                         ViewUnmap,
                                         0,
                                         PAGE_READWRITE
                                       );
        }

        if (!NT_SUCCESS( Status )) {
            if (NewHandle != NULL) {
                NtDuplicateObject (NewTargetProcess,
                                   &NewHandle,
                                   NULL,
                                   NULL,
                                   0,
                                   0,
                                   DUPLICATE_CLOSE_SOURCE);
            }

            NtClose( NewTargetProcess );
            return Status;
        }

        if (ARGUMENT_PRESENT( ReturnedTargetProcessHandle )) {
            *ReturnedTargetProcessHandle = NewTargetProcess;
        } else {
            Status = NtClose (NewTargetProcess);
            ASSERT (NT_SUCCESS (Status));
        }
    }

    Buffer->EventPairTarget = NewHandle;
    Buffer->ViewBaseDelta = (ULONG_PTR)Buffer->ViewBaseClient - (ULONG_PTR)Buffer->ViewBaseTarget;
    Buffer->TargetProcessId = TargetProcessId;
    *TargetBuffer = *Buffer;
    return STATUS_SUCCESS;
}


PVOID
RtlpCommitQueryDebugInfo(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine commits a range of memory in the buffer and returns its address.

Arguments:

    Buffer - Query buffer to have space allocated to.
             If there is not enough commited space then we expand.

    Size - Size of data to return

Return Value:

    PVOID - Pointer to the commited space.

--*/
{
    NTSTATUS Status;
    PVOID Result;
    PVOID CommitBase;
    SIZE_T CommitSize;
    SIZE_T NeededSize;

    if (Size > (MAXULONG - sizeof(PVOID) + 1)) {
        return NULL;
    }

    Size = (Size + sizeof (PVOID) - 1) & ~(sizeof (PVOID) - 1);
    NeededSize = Buffer->OffsetFree + Size;
    if (NeededSize > Buffer->CommitSize) {
        if (NeededSize >= Buffer->ViewSize) {
            return NULL;
        }

        CommitBase = (PCHAR)Buffer + Buffer->CommitSize;
        CommitSize =  NeededSize - Buffer->CommitSize;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &CommitBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            return NULL;
        }

        Buffer->CommitSize += CommitSize;
    }

    Result = (PCHAR)Buffer + Buffer->OffsetFree;
    Buffer->OffsetFree = NeededSize;
    return Result;
}


VOID
RtlpDeCommitQueryDebugInfo(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN PVOID p,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine returns a range of previously commited data to the buffer.

Arguments:

    Buffer - Query buffer to have space returned to.

    Size - Size of data to return

Return Value:

    None.

--*/
{
    if (Size > (MAXULONG - sizeof(PVOID) + 1)) {
        return;
    }

    Size = (Size + sizeof(PVOID) - 1) & ~(sizeof (PVOID) - 1);
    if (p == (PVOID)(Buffer->OffsetFree - Size)) {
        Buffer->OffsetFree -= Size;
    }
}


NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    IN ULONG MaximumCommit OPTIONAL,
    IN BOOLEAN UseEventPair
    )
/*++

Routine Description:

    Creates a new query buffer to allow a remote of local query to be done.

Arguments:

    MaximumCommit - Largest query buffer size allowed

    UseEventPair - If TRUE the codes caches a single thread in the target to make repeated queries fast.

Return Value:

    PRTL_DEBUG_INFORMATION - NULL on failure, non-NULL otherwise.

--*/
{
    NTSTATUS Status;
    HANDLE Section;
    PRTL_DEBUG_INFORMATION Buffer, ReturnBuffer;
    LARGE_INTEGER MaximumSize;
    ULONG_PTR ViewSize, CommitSize;

    if (!ARGUMENT_PRESENT( (PVOID)(ULONG_PTR)MaximumCommit )) { // Sundown Note: ULONG zero-extended.
        MaximumCommit = 4 * 1024 * 1024;
    }
    ViewSize = MaximumCommit + CONTROL_OFFSET;
    MaximumSize.QuadPart = ViewSize;
    Status = NtCreateSection( &Section,
                              SECTION_ALL_ACCESS,
                              NULL,
                              &MaximumSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return NULL;
    }

    Buffer = NULL;
    Status = NtMapViewOfSection( Section,
                                 NtCurrentProcess(),
                                 &Buffer,
                                 0,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_READWRITE
                               );
    if (!NT_SUCCESS (Status)) {
        NtClose (Section);
        return NULL;
    }

    CommitSize = 1 + CONTROL_OFFSET;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      &Buffer,
                                      0,
                                      &CommitSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (!NT_SUCCESS( Status )) {
        NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
        NtClose( Section );
        return NULL;
    }

    if (UseEventPair) {
        Status = NtCreateEventPair( &Buffer->EventPairClient,
                                    EVENT_PAIR_ALL_ACCESS,
                                    NULL
                                  );
        if (!NT_SUCCESS( Status )) {
            NtFreeVirtualMemory( NtCurrentProcess(), &Buffer, &CommitSize,
                                 MEM_RELEASE );
            NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
            NtClose( Section );
            return NULL;
        }
    }

    ReturnBuffer = CONTROL_TO_FAKE (Buffer);

    Buffer->SectionHandleClient = Section;
    Buffer->ViewBaseClient = ReturnBuffer;
    Buffer->OffsetFree = sizeof (RTL_DEBUG_INFORMATION);
    Buffer->CommitSize = CommitSize - CONTROL_OFFSET;
    Buffer->ViewSize = ViewSize - CONTROL_OFFSET;
    *ReturnBuffer = *Buffer;
    return ReturnBuffer;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    IN PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    Destroys a previously created buffer that was returned by RtlCreateQueryDebugBuffer

Arguments:

    Buffer - Buffer pointer obtained from RtlCreateQueryDebugBuffer

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION RealBuffer;

    RealBuffer = FAKE_TO_CONTROL (Buffer);

    RtlpChangeQueryDebugBufferTarget (RealBuffer, NULL, NULL);

    if (RealBuffer->EventPairClient != NULL) {
        Status = NtClose (RealBuffer->EventPairClient);
        ASSERT (NT_SUCCESS (Status));
    }

    Status = NtClose (RealBuffer->SectionHandleClient);
    ASSERT (NT_SUCCESS (Status));
    Status = NtUnmapViewOfSection (NtCurrentProcess(), RealBuffer);
    ASSERT (NT_SUCCESS (Status));
    return STATUS_SUCCESS;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    IN HANDLE UniqueProcessId,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    Queries the current or a remote process for the specified debug information

Arguments:

    UniqueProcessId - ProcessId of process to query

    Flags - Flags mask describing what to query

    Buffer - Buffer pointer obtained from RtlCreateQueryDebugBuffer

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ProcessHandle, ThreadHandle;
    THREAD_BASIC_INFORMATION BasicInformation;
    PRTL_DEBUG_INFORMATION RealBuffer;

    HANDLE hNiProcess = NULL;

    Buffer->Flags = Flags;
    if (Buffer->OffsetFree != 0) {
        RtlZeroMemory( (Buffer+1), Buffer->OffsetFree - (SIZE_T)sizeof(*Buffer) );
    }
    Buffer->OffsetFree = sizeof( *Buffer );

    //
    // Get process handle for noninvasive query if required
    //
    if ( (NtCurrentTeb()->ClientId.UniqueProcess != UniqueProcessId) &&
         (Flags & RTL_QUERY_PROCESS_NONINVASIVE) &&
         (Flags & ( RTL_QUERY_PROCESS_MODULES | 
                    RTL_QUERY_PROCESS_MODULES32
                  )
         ) &&
         !(Flags & ~( RTL_QUERY_PROCESS_MODULES | 
                      RTL_QUERY_PROCESS_MODULES32 | 
                      RTL_QUERY_PROCESS_NONINVASIVE
                    )
          )
       ) {
            OBJECT_ATTRIBUTES ObjectAttributes;
            CLIENT_ID NiProcessId;

            InitializeObjectAttributes( &ObjectAttributes,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL
                                      );
            NiProcessId.UniqueProcess = UniqueProcessId;
            NiProcessId.UniqueThread = 0;

            if (!NT_SUCCESS( NtOpenProcess( &hNiProcess,
                                            PROCESS_ALL_ACCESS,
                                            &ObjectAttributes,
                                            &NiProcessId
                                          )
                            )
               ) {
                hNiProcess = NULL;
            }
    }


    if ( (NtCurrentTeb()->ClientId.UniqueProcess != UniqueProcessId) &&
         !hNiProcess) {

        RealBuffer = FAKE_TO_CONTROL (Buffer);

        RealBuffer->Flags = Flags;
        RealBuffer->OffsetFree = sizeof (*Buffer);

        //
        //  Perform remote query
        //
        ProcessHandle = NULL;
        Status = RtlpChangeQueryDebugBufferTarget (RealBuffer, UniqueProcessId, &ProcessHandle);
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        if (ProcessHandle == NULL) {
waitForDump:
            Status = NtSetLowWaitHighEventPair( RealBuffer->EventPairClient );
        } else {
            //
            // don't let the debugger see this remote thread !
            // This is a very ugly but effective way to prevent
            // the debugger deadlocking with the target process when calling
            // this function.
            //

            Status = RtlCreateUserThread( ProcessHandle,
                                          NULL,
                                          TRUE,
                                          0,
                                          0,
                                          0,
                                          RtlpQueryProcessDebugInformationRemote,
                                          RealBuffer->ViewBaseTarget,
                                          &ThreadHandle,
                                          NULL
                                        );
            if (NT_SUCCESS( Status )) {

                Status = NtSetInformationThread( ThreadHandle,
                                                 ThreadHideFromDebugger,
                                                 NULL,
                                                 0
                                               );

                if ( !NT_SUCCESS(Status) ) {
                    NtTerminateThread(ThreadHandle,Status);
                    NtClose(ThreadHandle);
                    NtClose(ProcessHandle);
                    return Status;
                }

                NtResumeThread(ThreadHandle,NULL);

                if (RealBuffer->EventPairClient != NULL) {
                    RealBuffer->TargetThreadHandle = ThreadHandle;
                    RealBuffer->TargetProcessHandle = ProcessHandle;
                    goto waitForDump;
                }


                Status = NtWaitForSingleObject( ThreadHandle,
                                                TRUE,
                                                NULL
                                              );

                if (NT_SUCCESS( Status )) {
                    Status = NtQueryInformationThread( ThreadHandle,
                                                       ThreadBasicInformation,
                                                       &BasicInformation,
                                                       sizeof( BasicInformation ),
                                                       NULL
                                                     );
                    if (NT_SUCCESS( Status )) {
                        Status = BasicInformation.ExitStatus;
                    }
                    if (NT_SUCCESS (Status) &&
                        (Flags&(RTL_QUERY_PROCESS_MODULES|RTL_QUERY_PROCESS_MODULES32)) != 0 &&
                        Buffer->Modules == NULL) {
                        Status = STATUS_PROCESS_IS_TERMINATING;
                    }
                }

                NtClose( ThreadHandle );

            }


            NtClose( ProcessHandle );
        }
    } else {
        if (Flags & (RTL_QUERY_PROCESS_MODULES | RTL_QUERY_PROCESS_MODULES32)) {
            Status = RtlQueryProcessModuleInformation( hNiProcess, Flags, Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & RTL_QUERY_PROCESS_BACKTRACES) {
            Status = RtlQueryProcessBackTraceInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & RTL_QUERY_PROCESS_LOCKS) {
            Status = RtlQueryProcessLockInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & (RTL_QUERY_PROCESS_HEAP_SUMMARY |
                     RTL_QUERY_PROCESS_HEAP_TAGS |
                     RTL_QUERY_PROCESS_HEAP_ENTRIES
                    )
           ) {
            Status = RtlQueryProcessHeapInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

closeNiProcessAndBreak:
            if ( hNiProcess ) {
                NtClose( hNiProcess );
            }
    }

    return Status;
}

NTSTATUS
LdrQueryProcessModuleInformationEx(
    IN HANDLE hProcess OPTIONAL,
    IN ULONG_PTR Flags OPTIONAL,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSTATUS
NTAPI
RtlQueryProcessModuleInformation
(
    IN HANDLE hProcess OPTIONAL,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    Queries the current or a remote process for loaded module information

Arguments:

    hProcess - Handle to the process being queuried

    Flags - Flags mask describing what to query

    Buffer - Buffer pointer obtained from RtlCreateQueryDebugBuffer

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    ULONG RequiredLength, BufferSize;
    PRTL_PROCESS_MODULES Modules;
    ULONG LdrFlags = (Flags & RTL_QUERY_PROCESS_MODULES32) != 0;

    Status = LdrQueryProcessModuleInformationEx( hProcess,
                                                 LdrFlags,
                                                 NULL,
                                                 0,
                                                 &BufferSize
                                               );
    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Modules = RtlpCommitQueryDebugInfo( Buffer, BufferSize );
        if (Modules != NULL) {
            RtlZeroMemory( Modules, BufferSize );
            Status = LdrQueryProcessModuleInformationEx( hProcess,
                                                         LdrFlags,
                                                         Modules,
                                                         BufferSize,
                                                         &RequiredLength
                                                       );
            if (NT_SUCCESS( Status )) {
                Buffer->Modules = Modules;
                return STATUS_SUCCESS;
            }
            RtlpDeCommitQueryDebugInfo( Buffer, Modules, BufferSize );
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}


NTSTATUS
RtlQueryProcessBackTraceInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    Queries the current process for back trace information

Arguments:

    Buffer - Buffer pointer obtained from RtlCreateQueryDebugBuffer

Return Value:

    NTSTATUS - Status of operation.

--*/
{
#if i386
    NTSTATUS Status;
    OUT PRTL_PROCESS_BACKTRACES BackTraces;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG n;

    DataBase = RtlpAcquireStackTraceDataBase();
    if (DataBase == NULL) {
        return STATUS_SUCCESS;
    }

    BackTraces = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces ) );
    if (BackTraces == NULL) {
        return STATUS_NO_MEMORY;
    }

    DataBase->DumpInProgress = TRUE;
    RtlpReleaseStackTraceDataBase();
    Status = STATUS_ACCESS_VIOLATION;
    try {
        BackTraces->CommittedMemory = (ULONG)DataBase->CurrentUpperCommitLimit -
                                      (ULONG)DataBase->CommitBase;
        BackTraces->ReservedMemory =  (ULONG)DataBase->EntryIndexArray -
                                      (ULONG)DataBase->CommitBase;
        BackTraces->NumberOfBackTraceLookups = DataBase->NumberOfEntriesLookedUp;
        BackTraces->NumberOfBackTraces = DataBase->NumberOfEntriesAdded;
        BackTraceInfo = RtlpCommitQueryDebugInfo( Buffer, (sizeof( *BackTraceInfo ) * BackTraces->NumberOfBackTraces) );
        if (BackTraceInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            RtlpDeCommitQueryDebugInfo(
                        Buffer,
                        BackTraces,
                        FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces )
                        );
        }
        else {
            Status = STATUS_SUCCESS;
            n = DataBase->NumberOfEntriesAdded;
            pp = DataBase->EntryIndexArray;
            while (n--) {
                p = *--pp;
                BackTraceInfo->SymbolicBackTrace = NULL;
                BackTraceInfo->TraceCount = p->TraceCount;
                BackTraceInfo->Index = p->Index;
                BackTraceInfo->Depth = p->Depth;
                RtlMoveMemory( BackTraceInfo->BackTrace,
                               p->BackTrace,
                               p->Depth * sizeof( PVOID )
                             );
                BackTraceInfo++;
            }
        }
    }
    finally {
        DataBase->DumpInProgress = FALSE;
    }

    if (NT_SUCCESS( Status )) {
        Buffer->BackTraces = BackTraces;
    }

    return Status;
#else
    UNREFERENCED_PARAMETER (Buffer);
    return STATUS_SUCCESS;
#endif // i386
}


NTSTATUS
RtlpQueryProcessEnumHeapsRoutine(
    PVOID HeapHandle,
    PVOID Parameter
    )
{
    PRTL_DEBUG_INFORMATION Buffer = (PRTL_DEBUG_INFORMATION)Parameter;
    PRTL_PROCESS_HEAPS Heaps = Buffer->Heaps;
    PHEAP Heap = (PHEAP)HeapHandle;
    PRTL_HEAP_INFORMATION HeapInfo;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;

    //
    // NOTICE-2002/03/24-ELi
    // This function assumes that HeapInfo is allocated immediately following
    // the Buffer->Heaps allocation.  Therefore, HeapInfo is not leaked.
    //
    HeapInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( *HeapInfo ) );
    if (HeapInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( HeapInfo, sizeof( *HeapInfo ) );

    HeapInfo->BaseAddress = Heap;
    HeapInfo->Flags = Heap->Flags;
    HeapInfo->EntryOverhead = sizeof( HEAP_ENTRY );
    HeapInfo->CreatorBackTraceIndex = Heap->AllocatorBackTraceIndex;
    SegmentIndex = HEAP_MAXIMUM_SEGMENTS;
    while (SegmentIndex--) {
        Segment = Heap->Segments[ SegmentIndex ];
        if (Segment) {
            HeapInfo->BytesCommitted += (Segment->NumberOfPages -
                                         Segment->NumberOfUnCommittedPages
                                        ) * PAGE_SIZE;

        }
    }
    HeapInfo->BytesAllocated = HeapInfo->BytesCommitted -
                               (Heap->TotalFreeSize << HEAP_GRANULARITY_SHIFT);
    Heaps->NumberOfHeaps += 1;
    return STATUS_SUCCESS;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    PHEAP Heap;
    BOOLEAN LockAcquired;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;
    UCHAR SegmentIndex;
    ULONG i, n, TagIndex;
    PHEAP_SEGMENT Segment;
    PRTL_HEAP_TAG Tags;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTags;
    PRTL_HEAP_ENTRY Entries;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PLIST_ENTRY Head, Next;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    ULONG Size;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    Heaps = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_HEAPS, Heaps ) );
    if (Heaps == NULL) {
        return STATUS_NO_MEMORY;
    }

    Heaps->NumberOfHeaps = 0;

    Buffer->Heaps = Heaps;
    Status = RtlEnumProcessHeaps( RtlpQueryProcessEnumHeapsRoutine, Buffer );
    if (NT_SUCCESS( Status )) {
        if (Buffer->Flags & RTL_QUERY_PROCESS_HEAP_TAGS) {
            Heap = RtlpGlobalTagHeap;
            if (Heap->TagEntries != NULL) {
                HeapInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( *HeapInfo ) );
                if (HeapInfo == NULL) {
                    return STATUS_NO_MEMORY;
                }

                RtlZeroMemory( HeapInfo, sizeof( *HeapInfo ) );

                HeapInfo->BaseAddress = Heap;
                HeapInfo->Flags = Heap->Flags;
                HeapInfo->EntryOverhead = sizeof( HEAP_ENTRY );
                Heaps->NumberOfHeaps += 1;
            }

            for (i=0; i<Heaps->NumberOfHeaps; i++) {
                HeapInfo = &Heaps->Heaps[ i ];
                if (Buffer->SpecificHeap == NULL ||
                    Buffer->SpecificHeap == HeapInfo->BaseAddress
                   ) {
                    Heap = HeapInfo->BaseAddress;
                    HeapInfo->NumberOfTags = Heap->NextAvailableTagIndex;
                    n = HeapInfo->NumberOfTags * sizeof( RTL_HEAP_TAG );
                    if (Heap->PseudoTagEntries != NULL) {
                        HeapInfo->NumberOfTags += HEAP_MAXIMUM_FREELISTS + 1;
                        n += (HEAP_MAXIMUM_FREELISTS + 1) * sizeof( RTL_HEAP_TAG );
                    }
                    Tags = RtlpCommitQueryDebugInfo( Buffer, n );
                    if (Tags == NULL) {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                    RtlZeroMemory( Tags, n );
                    HeapInfo->Tags = Tags;
                    if ((PseudoTags = Heap->PseudoTagEntries) != NULL) {
                        HeapInfo->NumberOfPseudoTags = HEAP_NUMBER_OF_PSEUDO_TAG;
                        HeapInfo->PseudoTagGranularity = HEAP_GRANULARITY;
                        for (TagIndex=0; TagIndex<=HEAP_MAXIMUM_FREELISTS; TagIndex++) {
                            Tags->NumberOfAllocations = PseudoTags->Allocs;
                            Tags->NumberOfFrees = PseudoTags->Frees;
                            Tags->BytesAllocated = PseudoTags->Size << HEAP_GRANULARITY_SHIFT;
                            Tags->TagIndex = (USHORT)(TagIndex | HEAP_PSEUDO_TAG_FLAG);

                            if (TagIndex == 0) {
                                swprintf( Tags->TagName, L"Objects>%4u",
                                          HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                                        );
                            }
                            else
                            if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
                                swprintf( Tags->TagName, L"Objects=%4u",
                                          TagIndex << HEAP_GRANULARITY_SHIFT
                                        );
                            }
                            else {
                                swprintf( Tags->TagName, L"VirtualAlloc" );
                            }

                            Tags += 1;
                            PseudoTags += 1;
                        }
                    }

                    RtlMoveMemory( Tags,
                                   Heap->TagEntries,
                                   Heap->NextAvailableTagIndex * sizeof( RTL_HEAP_TAG )
                                 );
                    for (TagIndex=0; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {
                        Tags->BytesAllocated <<= HEAP_GRANULARITY_SHIFT;
                        Tags += 1;
                    }
                }
            }
        }
    }
    else {
        Buffer->Heaps = NULL;
    }

    if (NT_SUCCESS( Status )) {
        if (Buffer->Flags & RTL_QUERY_PROCESS_HEAP_ENTRIES) {
            for (i=0; i<Heaps->NumberOfHeaps; i++) {
                HeapInfo = &Heaps->Heaps[ i ];
                Heap = HeapInfo->BaseAddress;
                if (Buffer->SpecificHeap == NULL ||
                    Buffer->SpecificHeap == Heap
                   ) {
                    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {
                        RtlEnterCriticalSection( (PRTL_CRITICAL_SECTION)Heap->LockVariable );
                        LockAcquired = TRUE;
                    }
                    else {
                        LockAcquired = FALSE;
                    }

                    try {
                        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {
                            Segment = Heap->Segments[ SegmentIndex ];
                            if (!Segment) {
                                continue;
                            }

                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                leave;
                            }
                            else
                            if (HeapInfo->Entries == NULL) {
                                HeapInfo->Entries = Entries;
                            }

                            RtlZeroMemory( Entries, sizeof( *Entries ) );

                            Entries->Flags = RTL_HEAP_SEGMENT;
                            Entries->AllocatorBackTraceIndex = Segment->AllocatorBackTraceIndex;
                            Entries->Size = Segment->NumberOfPages * PAGE_SIZE;
                            Entries->u.s2.CommittedSize = (Segment->NumberOfPages -
                                                           Segment->NumberOfUnCommittedPages
                                                          ) * PAGE_SIZE;
                            Entries->u.s2.FirstBlock = Segment->FirstEntry;
                            HeapInfo->NumberOfEntries++;

                            UnCommittedRange = Segment->UnCommittedRanges;
                            CurrentBlock = Segment->FirstEntry;
                            while (CurrentBlock < Segment->LastValidEntry) {
                                Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                                if (Entries == NULL) {
                                    Status = STATUS_NO_MEMORY;
                                    leave;
                                }

                                RtlZeroMemory( Entries, sizeof( *Entries ) );

                                Size = CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;
                                Entries->Size = Size;
                                HeapInfo->NumberOfEntries++;
                                if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {
                                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
                                        ExtraStuff = (PHEAP_ENTRY_EXTRA)(CurrentBlock + CurrentBlock->Size - 1);
#if i386
                                        Entries->AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;
#endif // i386
                                        Entries->Flags |= RTL_HEAP_SETTABLE_VALUE;
                                        Entries->u.s1.Settable = ExtraStuff->Settable;
                                        Entries->u.s1.Tag = ExtraStuff->TagIndex;
                                    }
                                    else {
                                        Entries->u.s1.Tag = CurrentBlock->SmallTagIndex;
                                        }

                                    Entries->Flags |= RTL_HEAP_BUSY | (CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS);
                                }
                                else
                                if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
                                    PHEAP_FREE_ENTRY_EXTRA FreeExtra;

                                    FreeExtra = (PHEAP_FREE_ENTRY_EXTRA)(CurrentBlock + CurrentBlock->Size) - 1;
                                    Entries->u.s1.Tag = FreeExtra->TagIndex;
                                    Entries->AllocatorBackTraceIndex = FreeExtra->FreeBackTraceIndex;
                                }

                                if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {
                                    CurrentBlock += CurrentBlock->Size;
                                    if (UnCommittedRange == NULL) {
                                        CurrentBlock = Segment->LastValidEntry;
                                    }
                                    else {
                                        Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                                        if (Entries == NULL) {
                                            Status = STATUS_NO_MEMORY;
                                            leave;
                                        }

                                        RtlZeroMemory( Entries, sizeof( *Entries ) );

                                        Entries->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                                        Entries->Size = UnCommittedRange->Size;
                                        HeapInfo->NumberOfEntries++;

                                        CurrentBlock = (PHEAP_ENTRY)
                                            ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);
                                        UnCommittedRange = UnCommittedRange->Next;
                                    }
                                }
                                else {
                                    CurrentBlock += CurrentBlock->Size;
                                }
                            }
                        }

                        Head = &Heap->VirtualAllocdBlocks;
                        Next = Head->Flink;
                        while (Head != Next) {
                            VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );
                            CurrentBlock = &VirtualAllocBlock->BusyBlock;
                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                leave;
                            }
                            else
                            if (HeapInfo->Entries == NULL) {
                                HeapInfo->Entries = Entries;
                            }

                            RtlZeroMemory( Entries, sizeof( *Entries ) );

                            Entries->Flags = RTL_HEAP_SEGMENT;
                            Entries->Size = VirtualAllocBlock->ReserveSize;
                            Entries->u.s2.CommittedSize = VirtualAllocBlock->CommitSize;
                            Entries->u.s2.FirstBlock = CurrentBlock;
                            HeapInfo->NumberOfEntries++;
                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                leave;
                            }

                            RtlZeroMemory( Entries, sizeof( *Entries ) );

                            Entries->Size = VirtualAllocBlock->CommitSize;
                            Entries->Flags = RTL_HEAP_BUSY | (CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS);
#if i386
                            Entries->AllocatorBackTraceIndex = VirtualAllocBlock->ExtraStuff.AllocatorBackTraceIndex;
#endif // i386
                            Entries->Flags |= RTL_HEAP_SETTABLE_VALUE;
                            Entries->u.s1.Settable = VirtualAllocBlock->ExtraStuff.Settable;
                            Entries->u.s1.Tag = VirtualAllocBlock->ExtraStuff.TagIndex;
                            HeapInfo->NumberOfEntries++;

                            Next = Next->Flink;
                        }
                    }
                    finally {
                        //
                        // Unlock the heap
                        //

                        if (LockAcquired) {
                            RtlLeaveCriticalSection( (PRTL_CRITICAL_SECTION)Heap->LockVariable );
                        }
                    }
                }

                if (!NT_SUCCESS( Status )) {
                    break;
                }
            }
        }
    }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessLockInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine Description:

    Queries the current process for ciritcal section information

Arguments:

    Buffer - Buffer pointer obtained from RtlCreateQueryDebugBuffer

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PRTL_PROCESS_LOCKS Locks;
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PRTL_CRITICAL_SECTION CriticalSection;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    PRTL_RESOURCE Resource;
    PRTL_RESOURCE_DEBUG ResourceDebugInfo;

    Locks = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_LOCKS, Locks ) );
    if (Locks == NULL) {
        return STATUS_NO_MEMORY;
    }

    Locks->NumberOfLocks = 0;

    Head = &RtlCriticalSectionList;

    RtlEnterCriticalSection( &RtlCriticalSectionLock );
    Next = Head->Flink;
    Status = STATUS_SUCCESS;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next,
                                       RTL_CRITICAL_SECTION_DEBUG,
                                       ProcessLocksList
                                     );
        LockInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( RTL_PROCESS_LOCK_INFORMATION ) );
        if (LockInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        CriticalSection = DebugInfo->CriticalSection;
        try {
            LockInfo->Address = CriticalSection;
            LockInfo->Type = DebugInfo->Type;
            LockInfo->CreatorBackTraceIndex = DebugInfo->CreatorBackTraceIndex;
            if (LockInfo->Type == RTL_CRITSECT_TYPE) {
                LockInfo->OwningThread = CriticalSection->OwningThread;
                LockInfo->LockCount = CriticalSection->LockCount;
                LockInfo->RecursionCount = CriticalSection->RecursionCount;
                LockInfo->ContentionCount = DebugInfo->ContentionCount;
                LockInfo->EntryCount = DebugInfo->EntryCount;

                LockInfo->NumberOfWaitingShared = 0;
                LockInfo->NumberOfWaitingExclusive = 0;
            }
            else {
                Resource = (PRTL_RESOURCE)CriticalSection;
                ResourceDebugInfo = Resource->DebugInfo;
                LockInfo->ContentionCount = ResourceDebugInfo->ContentionCount;
                LockInfo->OwningThread = Resource->ExclusiveOwnerThread;
                LockInfo->LockCount = Resource->NumberOfActive;
                LockInfo->NumberOfWaitingShared    = Resource->NumberOfWaitingShared;
                LockInfo->NumberOfWaitingExclusive = Resource->NumberOfWaitingExclusive;

                LockInfo->EntryCount = 0;
                LockInfo->RecursionCount = 0;
            }

            Locks->NumberOfLocks++;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            DbgPrint("NTDLL: Lost critical section %08lX\n", CriticalSection);
            RtlpDeCommitQueryDebugInfo( Buffer, LockInfo, sizeof( RTL_PROCESS_LOCK_INFORMATION ) );
        }

        if (Next == Next->Flink) {
            //
            // Bail if list is circular
            //

            Status = STATUS_INTERNAL_ERROR;
            break;
        }
        else {
            Next = Next->Flink;
        }
    }

    RtlLeaveCriticalSection( &RtlCriticalSectionLock );

    if (NT_SUCCESS( Status )) {
        Buffer->Locks = Locks;
    }
    else {
        RtlpDeCommitQueryDebugInfo( Buffer, Locks, 
                FIELD_OFFSET( RTL_PROCESS_LOCKS, Locks ) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\rtlgetactivationcontextdata.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rtlgetactivationcontextdata.c

Abstract:

    Side-by-side activation support for Windows NT

Author:

    Jay Krell (JayKrell) November 2001

Revision History:


--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"
#include "ldrp.h"
typedef const void *PCVOID;

NTSTATUS
RtlpGetActivationContextData(
    IN ULONG                           Flags,
    IN PCACTIVATION_CONTEXT            ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION  FindContext, OPTIONAL /* This is used for its flags. */
    OUT PCACTIVATION_CONTEXT_DATA*  ActivationContextData
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR; // in case someone forgets to set it...
    SIZE_T PebOffset;

    if (ActivationContextData == NULL) {
        Status = STATUS_INVALID_PARAMETER_4;
        goto Exit;
    }
    if (Flags & ~(RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }
    *ActivationContextData = NULL;
    PebOffset = 0;

    //
    // We should use RtlpMapSpecialValuesToBuiltInActivationContexts here, but
    // it doesn't handle all the values and it isn't worth fixing it right now.
    //
    switch ((ULONG_PTR)ActivationContext)
    {
        case ((ULONG_PTR)NULL):
            if (FindContext == NULL) {
                PebOffset = FIELD_OFFSET(PEB, ActivationContextData);
            } else {
                switch (
                    FindContext->OutFlags
                        & (   FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT
                            | FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT
                    )) {
                    case 0: // FALLTHROUGH
                    case FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT:
                        PebOffset = FIELD_OFFSET(PEB, ActivationContextData);
                        break;
                    case FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT:
                        PebOffset = FIELD_OFFSET(PEB, SystemDefaultActivationContextData);
                        break;
                    case (FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT 
                        | FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT):
                        Status = STATUS_INVALID_PARAMETER_2;
                        goto Exit;
                        break;
                }
            }
            break;

        case ((ULONG_PTR)ACTCTX_EMPTY):
            *ActivationContextData = &RtlpTheEmptyActivationContextData;
            break;

        case ((ULONG_PTR)ACTCTX_SYSTEM_DEFAULT):
            PebOffset = FIELD_OFFSET(PEB, SystemDefaultActivationContextData);
            break;

        default:
            *ActivationContextData = ActivationContext->ActivationContextData;
            break;
    }
    if (PebOffset != 0)
        *ActivationContextData = *(PCACTIVATION_CONTEXT_DATA*)(((ULONG_PTR)NtCurrentPeb()) + PebOffset);

    //
    // special transmutation of lack of actctx into the empty actctx
    //
    if (*ActivationContextData == NULL)
        if ((Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY) != 0)
            *ActivationContextData = &RtlpTheEmptyActivationContextData;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1998.
//
//  File:       propapi.h
//
//  Contents:   Stuff needed to make properties build for Nashville and
//              NT... definitions of Nt property api.
//
//
//  History:    07-Aug-95   BillMo      Created.
//              22-Feb-96   MikeHill    Fixed the non-WINNT version of
//                                      PROPASSERTMSG.
//              09-May-96   MikeHill    Update define to allow PropSet names
//                                      to be 255 characters (from 127).
//              31-May-96   MikeHill    Add OSVersion to RtlCreatePropSet.
//              18-Jun-96   MikeHill    Add OleAut32 wrappers to Unicode callouts.
//              15-Jul-96   MikeHill    - Remvd Win32 SEH exception-related code.
//                                      - WCHAR=>OLECHAR where applicable.
//                                      - Added RtlOnMappedStreamEvent
//                                      - Added Mac versions of PROPASSERT
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// typedef the function prototypes necessary
// for the UNICODECALLOUTS structure.
//

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef BSTR FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef VOID FNSYSFREESTRING(
    BSTR pwsz);

//
// The UNICODECALLOUTS structure holds function
// pointers for routines needed by the property
// set routines in NTDLL.
//

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


//
// Define the default UNICODECALLOUTS
// values.
//

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz);

STDAPI_(VOID)
PropSysFreeString(BSTR bstr);

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    PropSysAllocString,       \
    PropSysFreeString


// Is this pure NT (the IProp DLL needs to run on Win95)?
#if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI NTSYSAPI
#   define PROPAPI NTAPI

    // How do we free mem allocated in the low-level propset routines?
#   define PropFreeHeap(h, z, p) RtlFreeHeap(h, z, p)

    // Assert implementations
#   define PROPASSERT ASSERT
#   define PROPASSERTMSG ASSERTMSG

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) swprintf ((s), L"prop%lu", (n))

    // Ansi sprintf implementations
#   define PropSprintfA sprintf
#   define PropVsprintfA vsprintf

// Otherwise this is either the IProp DLL (NT, Win95, Mac),
// or it's the Win95 OLE32build.

#else // #if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI
#   define PROPAPI

    // How do we free mem allocated in low-level propset routines?
#   define PropFreeHeap(h, z, p) CoTaskMemFree(p)

    // Assert implementations
#   if DBG==1
#       ifdef _MAC_NODOC
#           define PROPASSERT(f)                { if (!(f)) FnAssert(#f, NULL, __FILE__, __LINE__); }
#           define PROPASSERTMSG(szReason, f)   { if (!(f)) FnAssert(#f, szReason, __FILE__, __LINE__); }
#       else
#           define PROPASSERT(f) Win4Assert((f))
#           define PROPASSERTMSG(szReason, f) Win4Assert( (szReason && FALSE) || (f))
#       endif
#   else
#       define PROPASSERT(f)
#       define PROPASSERTMSG(szReason, f)
#   endif // #if DBG==1

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) \
    { \
        memcpy ((s), OLESTR("prop"), sizeof (OLESTR("prop"))); \
        ULTOO  ((n), &(s)[sizeof("prop") - 1], 10); \
    }

    // Ansi sprintf implementations
#   ifdef IPROPERTY_DLL
#       define PropSprintfA sprintf
#       define PropVsprintfA vsprintf
#   else
#       define PropSprintfA wsprintfA
#       define PropVsprintfA wvsprintfA
#   endif	// #ifdef _MAC_NODOC

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL) ... #else


#ifdef IPROPERTY_DLL
#define MAX_ULONG ((ULONG) -1)
#endif


#define WC_PROPSET0     ((WCHAR) 0x0005)
#define OC_PROPSET0     ((OLECHAR) 0x0005)

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

// Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CCH_PROPSET + 1)            // allow null
#define CCH_PROPSETCOLONSZ (1 + CCH_PROPSET + 1)        // allow colon and null

// Define the max property name in units of characters
// (and synonomously in wchars).

#define CCH_MAXPROPNAME    255                          // Matches Shell & Office
#define CCH_MAXPROPNAMESZ  (CCH_MAXPROPNAME + 1)        // allow null
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ

#define MAX_DOCFILE_ENTRY_NAME  31

//+--------------------------------------------------------------------------
// Property Access APIs:
//---------------------------------------------------------------------------

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);

VOID 
PrSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG 
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS 
PrPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


// RtlCreatePropertySet Flags:

#define CREATEPROP_READ         0x0000 // request read access (must exist)
#define CREATEPROP_WRITE        0x0001 // request write access (must exist)
#define CREATEPROP_CREATE       0x0002 // create (overwrite if exists)
#define CREATEPROP_CREATEIF     0x0003 // create (open existing if exists)
#define CREATEPROP_DELETE       0x0004 // delete
#define CREATEPROP_MODEMASK     0x000f // open mode mask

#define CREATEPROP_NONSIMPLE    0x0010 // Is non-simple propset (in a storage)


// RtlCreateMappedStream Flags:

#define CMS_READONLY      0x00000000    // Opened for read-only
#define CMS_WRITE         0x00000001    // Opened for write access
#define CMS_TRANSACTED    0x00000002    // Is transacted


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              // property set context

NTSTATUS 
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS 
PrClosePropertySet(
    IN NTPROP np);              // property set context

// *NOTE* RtlOnMappedStreamEvent assumes that the caller has
// already taken the CPropertySetStream::Lock.
#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN
NTSTATUS 
PrOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              // property set context
NTSTATUS 
PrFlushPropertySet(
    IN NTPROP np);              // property set context

typedef struct _INDIRECTPROPERTY        // ip
{
    ULONG       Index;          // Index into Variant and PropId arrays
    LPOLESTR    poszName;       // Old indirect name, RtlSetProperties() only
} INDIRECTPROPERTY;

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values
NTSTATUS 
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved
NTSTATUS 
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved



#define ENUMPROP_NONAMES        0x00000001      // return property IDs only

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );





NTSTATUS 
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS 
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS 
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS 
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS 
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS 
PrEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );



#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\propfwd.cxx ===
//+============================================================================
//
//  propfwd.cxx
//
//  This file provides (slow) forwarders of the NT4 property APIs
//  from NTDLL to OLE32.  At one time, these APIs were used in both
//  kernel mode and user mode.  They're now only used in user mode,
//  so all the property code has been consolidated into ole32.  Older
//  copies of Index Server (CI), however, still link to NTDLL, thus
//  the need for these forwarders.
//
//+============================================================================

#include <pch.cxx>
#include <windows.h>
#include <ddeml.h>      // for CP_WINUNICODE
#include <objidl.h>
#include <propidl.h>
extern "C"
{
#include <propapi.h>
}
#include <stgprop.h>
class PMemoryAllocator;
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>
#include "propmac.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   LoadOle32Export
//
//  Synopsis:   Load ole32.dll and get one of its exports.
//              Raises on error.
//
//+----------------------------------------------------------------------------

PVOID
LoadOle32Export( PVOID* Ole32, const PCHAR ProcedureName )
{
    NTSTATUS Status;
    const static UNICODE_STRING Ole32DllName_U = RTL_CONSTANT_STRING(L"ole32.dll");
    STRING ProcedureNameString;
    PVOID ProcedureAddress = NULL;

    Status = LdrLoadDll( NULL, NULL, &Ole32DllName_U, Ole32 );
    if( !NT_SUCCESS(Status) )
        RtlRaiseStatus( Status );

    RtlInitString( &ProcedureNameString, ProcedureName );
    Status = LdrGetProcedureAddress(
                    *Ole32,
                    &ProcedureNameString,
                    0,
                    (PVOID*) &ProcedureAddress
                    );
    if( !NT_SUCCESS(Status) )
        RtlRaiseStatus(Status);

    return( ProcedureAddress );
}


//+----------------------------------------------------------------------------
//
//  Function:   RtlConvertVariantToProperty
//
//  Synopsis:   Serialize a variant.
//
//+----------------------------------------------------------------------------

typedef SERIALIZEDPROPERTYVALUE* (*PFNStgConvertVariantToProperty) (
                                        IN PROPVARIANT const *pvar,
                                        IN USHORT CodePage,
                                        OUT SERIALIZEDPROPERTYVALUE *pprop,
                                        IN OUT ULONG *pcb,
                                        IN PROPID pid,
                                        IN BOOLEAN fVariantVector,
                                        OPTIONAL OUT ULONG *pcIndirect);


SERIALIZEDPROPERTYVALUE * PROPSYSAPI PROPAPI
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect)
{
    PVOID Ole32 = NULL;
    PFNStgConvertVariantToProperty ProcedureAddress;
    SERIALIZEDPROPERTYVALUE *ppropRet = NULL;

    __try
    {
        ProcedureAddress = (PFNStgConvertVariantToProperty)
                           LoadOle32Export( &Ole32, "StgConvertVariantToProperty" );

        ppropRet = ProcedureAddress( pvar,
                                     CodePage,
                                     pprop,
                                     pcb,
                                     pid,
                                     fVariantVector,
                                     pcIndirect );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return (ppropRet );

}




//+----------------------------------------------------------------------------
//
//  Function:   RtlConvertPropertyToVariant
//
//  Synopsis:   De-serialize a variant.
//
//+----------------------------------------------------------------------------

typedef BOOLEAN (* PFNStgConvertPropertyToVariant) (
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN PROPSYSAPI PROPAPI
RtlConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma)
{
    BOOLEAN Ret = FALSE;
    PVOID Ole32 = NULL;
    PFNStgConvertPropertyToVariant ProcedureAddress;

    __try
    {
        ProcedureAddress = (PFNStgConvertPropertyToVariant)
                           LoadOle32Export( &Ole32, "StgConvertPropertyToVariant" );
    
        Ret = ProcedureAddress( pprop, CodePage, pvar, pma );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return (Ret);

}




//+----------------------------------------------------------------------------
//
//  Function:   PropertyLengthAsVariant
//
//  Synopsis:   Returns the amount of external memory will need to be
//              allocated for this variant when RtlPropertyToVariant is called.
//
//+----------------------------------------------------------------------------

typedef ULONG (*PFNStgPropertyLengthAsVariant)(
        IN SERIALIZEDPROPERTYVALUE const *pprop,
        IN ULONG cbprop,
        IN USHORT CodePage,
        IN BYTE flags);

ULONG PROPSYSAPI PROPAPI
PropertyLengthAsVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags)
{
    ULONG Length = 0;
    PVOID Ole32 = NULL;
    PFNStgPropertyLengthAsVariant ProcedureAddress;

    __try
    {
        ProcedureAddress = (PFNStgPropertyLengthAsVariant)
                           LoadOle32Export( &Ole32, "StgPropertyLengthAsVariant" );

        Length = ProcedureAddress( pprop, cbprop, CodePage, flags );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return( Length);
}

//+---------------------------------------------------------------------------
//
//  Function:   RtlSetUnicodeCallouts, public
//
//  Synopsis:   Set the Unicode conversion function pointers, used by
//              RtlConvertVarianttoProperty, RtlConvertPropertyToVariant,
//              and PropertyLengthAsVariant.
//
//              These functions are no longer settable (they're defaulted by
//              ole32).
//
//---------------------------------------------------------------------------

VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\resource.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include "ldrp.h"

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include "wmiumkm.h"
#include "NtdllTrc.h"


//
// Define the desired access for semaphores.
//

#define DESIRED_EVENT_ACCESS \
                (EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE)

#define DESIRED_SEMAPHORE_ACCESS \
                (SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE | SYNCHRONIZE)

VOID RtlDumpResource( IN PRTL_RESOURCE Resource );

extern BOOLEAN LdrpShutdownInProgress;
extern HANDLE LdrpShutdownThreadId;

RTL_CRITICAL_SECTION DeferredCriticalSection;

HANDLE GlobalKeyedEventHandle=NULL;

//#define RTLP_USE_GLOBAL_KEYED_EVENT 1

#define RtlpIsKeyedEvent(xxHandle) ((((ULONG_PTR)xxHandle)&1) != 0)
#define RtlpSetKeyedEventHandle(xxHandle) ((HANDLE)(((ULONG_PTR)xxHandle)|1))

#define MAX_SLIST_DEPTH 10


BOOLEAN
ProtectHandle (
    IN HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject (hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof (HandleInfo),
                            NULL);

    if (NT_SUCCESS(Status)) {

        HandleInfo.ProtectFromClose = TRUE;

        Status = NtSetInformationObject (hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof (HandleInfo));
        if (NT_SUCCESS( Status )) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
UnProtectHandle (
    IN HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject (hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof (HandleInfo),
                            NULL);

    if (NT_SUCCESS(Status)) {

        HandleInfo.ProtectFromClose = FALSE;

        Status = NtSetInformationObject (hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof (HandleInfo));
        if (NT_SUCCESS(Status)) {
            return TRUE;
        }
    }

    return FALSE;
}


SLIST_HEADER RtlCriticalSectionDebugSList;

RTL_CRITICAL_SECTION_DEBUG RtlpStaticDebugInfo[64];
PRTL_CRITICAL_SECTION_DEBUG RtlpStaticDebugInfoEnd;


PVOID
RtlpAllocateDebugInfo (
    VOID
    )
{
    PVOID p;

    p = RtlInterlockedPopEntrySList (&RtlCriticalSectionDebugSList);

    if (p == NULL) {

        p = RtlAllocateHeap (NtCurrentPeb()->ProcessHeap,
                             0,
                             sizeof(RTL_CRITICAL_SECTION_DEBUG));

        if (p == NULL) {
            KdPrint(( "NTDLL: Unable to allocate debug information from heap\n"));
        }
    }

    return p;
}


VOID
RtlpFreeDebugInfo (
    IN PRTL_CRITICAL_SECTION_DEBUG DebugInfo
    )
{
    ASSERT (RtlpStaticDebugInfoEnd != NULL);

    if ((RtlQueryDepthSList (&RtlCriticalSectionDebugSList) < MAX_SLIST_DEPTH) ||
        ((DebugInfo >= RtlpStaticDebugInfo) &&
         (DebugInfo < RtlpStaticDebugInfoEnd))) {

        RtlInterlockedPushEntrySList (&RtlCriticalSectionDebugSList,
                                      (PSLIST_ENTRY) DebugInfo);
    } else {

        //
        // Free it to the heap.
        //

        RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, DebugInfo);
    }

    return;
}


NTSTATUS
RtlpInitDeferredCriticalSection (
    VOID
    )
{
    ULONG Size;
    NTSTATUS Status;
    PRTL_CRITICAL_SECTION_DEBUG p;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING Name;
    HANDLE Handle;


    //
    // Open the global out of memory keyed event if it's not already set up.
    //

    Name.Buffer = L"\\KernelObjects\\CritSecOutOfMemoryEvent";
    Name.Length = sizeof (L"\\KernelObjects\\CritSecOutOfMemoryEvent") - sizeof (WCHAR);
    InitializeObjectAttributes (&oa, &Name, 0, NULL, NULL);

    Status = NtOpenKeyedEvent (&Handle,
                               KEYEDEVENT_WAKE|KEYEDEVENT_WAIT,
                               &oa);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

#if DBG
    ProtectHandle (Handle);
#endif // DBG

    GlobalKeyedEventHandle = RtlpSetKeyedEventHandle (Handle);


    InitializeListHead (&RtlCriticalSectionList);

    //
    // Create the critical section SLIST.  Populate it with initial entries
    // so it can be used by ntdll routines before the first heap is created.
    //

    RtlInitializeSListHead (&RtlCriticalSectionDebugSList);

    Size = sizeof (RtlpStaticDebugInfo) / sizeof (RtlpStaticDebugInfo[0]);

    RtlpStaticDebugInfoEnd = RtlpStaticDebugInfo + Size;

    //
    // Chain all the free blocks together and then push them as a set.
    //
    for (p = RtlpStaticDebugInfo; p <= RtlpStaticDebugInfo + Size - 2; p++) {
        ((PSLIST_ENTRY) p)->Next = (PSLIST_ENTRY)(p + 1);
    }

    ((PSLIST_ENTRY) p)->Next = NULL;
    

    InterlockedPushListSList (&RtlCriticalSectionDebugSList,
                              (PSLIST_ENTRY) &RtlpStaticDebugInfo[0],
                              (PSLIST_ENTRY) &RtlpStaticDebugInfo[Size - 1],
                              Size);

    //
    // Initialize the critical section lock & the deferred critical section.
    //

    ASSERT (sizeof (RTL_CRITICAL_SECTION_DEBUG) == sizeof (RTL_RESOURCE_DEBUG));

    Status = RtlInitializeCriticalSectionAndSpinCount (&RtlCriticalSectionLock,
                                                       1000);

    if (NT_SUCCESS (Status)) {
        Status = RtlInitializeCriticalSectionAndSpinCount (&DeferredCriticalSection,
                                                           1000);
    }

    return Status;
}


BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    )
{
    UNREFERENCED_PARAMETER (Lock);

    return TRUE;
}


VOID
RtlInitializeResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{
    NTSTATUS Status;
    PRTL_RESOURCE_DEBUG ResourceDebugInfo;
    ULONG SpinCount;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    SpinCount = 1024 * (NtCurrentPeb()->NumberOfProcessors - 1);
    if (SpinCount > 12000) {
        SpinCount = 12000;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount (&Resource->CriticalSection, SpinCount);
    if (!NT_SUCCESS (Status)) {
        RtlRaiseStatus(Status);
    }

    Resource->CriticalSection.DebugInfo->Type = RTL_RESOURCE_TYPE;
    ResourceDebugInfo = (PRTL_RESOURCE_DEBUG) RtlpAllocateDebugInfo();

    if (ResourceDebugInfo == NULL) {
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        RtlRaiseStatus(STATUS_NO_MEMORY);
    }

    //
    // NOTICE-2002/03/21-ELi
    // Only the ResourceDebugInfo->ContentionCount is used by the resource
    // code, so the other fields are not initialized
    //
    ResourceDebugInfo->ContentionCount = 0;
    Resource->DebugInfo = ResourceDebugInfo;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;


    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

    Status = NtCreateSemaphore (&Resource->SharedSemaphore,
                                DESIRED_SEMAPHORE_ACCESS,
                                NULL,
                                0,
                                MAXLONG);

    if (!NT_SUCCESS(Status)) {
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        RtlpFreeDebugInfo (Resource->DebugInfo);
        RtlRaiseStatus (Status);
    }

    Resource->NumberOfWaitingShared = 0;

    Status = NtCreateSemaphore (&Resource->ExclusiveSemaphore,
                                DESIRED_SEMAPHORE_ACCESS,
                                NULL,
                                0,
                                MAXLONG);

    if (!NT_SUCCESS(Status)) {
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        NtClose (Resource->SharedSemaphore);
        RtlpFreeDebugInfo (Resource->DebugInfo);
        RtlRaiseStatus (Status);
    }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

    return;
}


VOID
RtlpPossibleDeadlock (
    IN PVOID ResourceOrCritSect
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    EXCEPTION_RECORD ExceptionRecord;

    NtHeaders = RtlImageNtHeader (NtCurrentPeb()->ImageBaseAddress);

    //
    // If the image is a Win32 image, then raise an exception
    // and try to get to the uae popup.
    //

    try {
        if (NtHeaders != NULL &&
            (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||
             NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI)) {

            ExceptionRecord.ExceptionCode = STATUS_POSSIBLE_DEADLOCK;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.ExceptionAddress = (PVOID)(ULONG_PTR) RtlRaiseException;
            ExceptionRecord.NumberParameters = 1;
            ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)ResourceOrCritSect;
            RtlRaiseException(&ExceptionRecord);
        } else {
            DbgBreakPoint();
        }
    } finally {
        ASSERT (!AbnormalTermination ());
#if !DBG
        if (AbnormalTermination ()) {

            //
            // Somebody tried to handle this exception.
            // This is illegal as it will corrupt the critical section.
            //

            DbgBreakPoint ();
        }
#endif
    }

    return;
}


BOOLEAN
RtlAcquireResourceShared (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available or must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount;
    PLARGE_INTEGER TimeoutTime;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection (&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recursively shared but is blocked by an exclusive waiter.
    //
    //  The test to reenable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recursive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

        //
        //  The resource is ours (recursively) so indicate that we have it
        //  and exit the critical section
        //

        Resource->NumberOfActive -= 1;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immediately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;
        Resource->DebugInfo->ContentionCount += 1;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        TimeoutCount = 0;

rewait:
        if (Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM) {
            TimeoutTime = NULL;
        }
        else {
            TimeoutTime = &RtlpTimeout;
        }

        Status = NtWaitForSingleObject (Resource->SharedSemaphore,
                                        FALSE,
                                        TimeoutTime);

        if (Status == STATUS_TIMEOUT) {

            DbgPrint("RTL: Acquire Shared Sem Timeout %d(%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));

            DbgPrint("RTL: Resource at %p\n",Resource);

            TimeoutCount += 1;

            if (TimeoutCount > 2) {

                //
                // If the image is a Win32 image, then raise an exception
                // and try to get to the uae popup
                //

                RtlpPossibleDeadlock ((PVOID) Resource);
            }
            DbgPrint("RTL: Re-Waiting\n");
            goto rewait;
        }

        if (!NT_SUCCESS(Status)) {
            RtlRaiseStatus(Status);
        }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;
}


BOOLEAN
RtlAcquireResourceExclusive (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available or must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount;
    PLARGE_INTEGER TimeoutTime;
    HANDLE Thread;
    
    Thread = NtCurrentTeb()->ClientId.UniqueThread;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    do {

        //
        //  Enter the critical section
        //

        RtlEnterCriticalSection (&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = Thread;

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recursively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == Thread) {

            //
            //  The resource is ours (recursively) so indicate that we have it
            //  and exit the critical section
            //

            Resource->NumberOfActive -= 1;

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immediately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;
        Resource->DebugInfo->ContentionCount += 1;

        RtlLeaveCriticalSection (&Resource->CriticalSection);

        TimeoutCount = 0;

rewait:
        if (Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM) {
            TimeoutTime = NULL;
        }
        else {
            TimeoutTime = &RtlpTimeout;
        }

        Status = NtWaitForSingleObject (Resource->ExclusiveSemaphore,
                                        FALSE,
                                        TimeoutTime);

        if (Status == STATUS_TIMEOUT) {

            DbgPrint("RTL: Acquire Exclusive Sem Timeout %d (%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));

            DbgPrint("RTL: Resource at %p\n",Resource);

            TimeoutCount += 1;

            if (TimeoutCount > 2) {

                //
                // If the image is a Win32 image, then raise an exception
                // and try to get to the uae popup.
                //

                RtlpPossibleDeadlock ((PVOID) Resource);
            }

            DbgPrint("RTL: Re-Waiting\n");
            goto rewait;
        }
        if (!NT_SUCCESS(Status)) {
            RtlRaiseStatus(Status);
        }
    } while (TRUE);
}


VOID
RtlReleaseResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection (&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            Status = NtReleaseSemaphore (Resource->ExclusiveSemaphore,
                                         1,
                                         &PreviousCount);

            if (!NT_SUCCESS(Status)) {
                RtlLeaveCriticalSection (&Resource->CriticalSection);
                RtlRaiseStatus(Status);
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                Status = NtReleaseSemaphore (Resource->ExclusiveSemaphore,
                                             1,
                                             &PreviousCount);

                if ( !NT_SUCCESS(Status) ) {
                    RtlLeaveCriticalSection (&Resource->CriticalSection);
                    RtlRaiseStatus(Status);
                }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                Status = NtReleaseSemaphore (Resource->SharedSemaphore,
                                             Resource->NumberOfActive,
                                             &PreviousCount);

                if (!NT_SUCCESS(Status)) {
                    RtlLeaveCriticalSection (&Resource->CriticalSection);
                    RtlRaiseStatus(Status);
                }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't currently acquired, there is nothing to release
        //  so tell the user the mistake
        //


        DbgPrint("NTDLL - Resource released too many times %lx\n", Resource);
        DbgBreakPoint();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    RtlLeaveCriticalSection (&Resource->CriticalSection);

    return;
}


VOID
RtlConvertSharedToExclusive (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount;
    HANDLE Thread;

    Thread = NtCurrentTeb()->ClientId.UniqueThread;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = Thread;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == Thread)) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        TimeoutCount = 0;

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;
            Resource->DebugInfo->ContentionCount += 1;

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            do {
                Status = NtWaitForSingleObject (Resource->ExclusiveSemaphore,
                                                FALSE,
                                                &RtlpTimeout);

                if (NT_SUCCESS(Status)) {

                    if (Status != STATUS_TIMEOUT) {

                        //
                        // Success !
                        //

                        break;
                    }

                    DbgPrint("RTL: Convert Exclusive Sem Timeout %d (%I64u secs)\n",
                        TimeoutCount, RtlpTimeout.QuadPart / (-10000000));

                    DbgPrint("RTL: Resource at %p\n",Resource);

                    TimeoutCount += 1;

                    if (TimeoutCount > 2) {

                        //
                        // If the image is a Win32 image, then raise an
                        // exception and try to get to the uae popup.
                        //

                        RtlpPossibleDeadlock ((PVOID) Resource);
                    }

                    DbgPrint("RTL: Re-Waiting\n");
                }
                else {
                    RtlRaiseStatus (Status);
                }

            } while (TRUE);

            //
            //  Enter the critical section
            //

            RtlEnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

                RtlLeaveCriticalSection(&Resource->CriticalSection);

                return;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recursively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

                //
                //  The resource is ours (recursively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                RtlLeaveCriticalSection(&Resource->CriticalSection);

                return;
            }
        }
    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
    DbgBreakPoint();
#endif
    RtlLeaveCriticalSection(&Resource->CriticalSection);
}


VOID
RtlConvertExclusiveToShared (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;
    NTSTATUS Status;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  Release our exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            Status = NtReleaseSemaphore (Resource->SharedSemaphore,
                                         Resource->NumberOfActive - 1,
                                         &PreviousCount);

            if (!NT_SUCCESS(Status)) {
                RtlLeaveCriticalSection(&Resource->CriticalSection);
                RtlRaiseStatus(Status);
            }

        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;
        }

    }
    else {

        //
        //  The resource is not currently acquired for exclusive, or we've
        //  recursively acquired it, so this must be a spurious call
        //

#if DBG
        DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
        DbgBreakPoint();
#endif
    }

    RtlLeaveCriticalSection(&Resource->CriticalSection);

    return;
}


VOID
RtlDeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    RtlDeleteCriticalSection (&Resource->CriticalSection);

    NtClose (Resource->SharedSemaphore);
    NtClose (Resource->ExclusiveSemaphore);

    RtlpFreeDebugInfo (Resource->DebugInfo);
    RtlZeroMemory (Resource, sizeof(*Resource));

    return;
}


VOID
RtlDumpResource (
    IN PRTL_RESOURCE Resource
    )

{
    DbgPrint("Resource @ %lx\n", Resource);

    DbgPrint(" NumberOfWaitingShared = %lx\n", Resource->NumberOfWaitingShared);
    DbgPrint(" NumberOfWaitingExclusive = %lx\n", Resource->NumberOfWaitingExclusive);

    DbgPrint(" NumberOfActive = %lx\n", Resource->NumberOfActive);

    return;
}


NTSTATUS
RtlInitializeCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    NTSTATUS.

--*/

{
    return RtlInitializeCriticalSectionAndSpinCount (CriticalSection, 0);
}



#define MAX_SPIN_COUNT          0x00ffffff
#define PREALLOCATE_EVENT_MASK  0x80000000


VOID
RtlEnableEarlyCriticalSectionEventCreation (
    VOID
    )
/*++

Routine Description:

    This routine marks the PEB of the calling process so critical section events
    are created at critical section creation time rather than at contention time.
    This allows critical processes not to have to worry about error paths later
    on at the expense of extra pool consumed.

Arguments:

    None

Return Value:

    None

--*/
{
    NtCurrentPeb ()->NtGlobalFlag |= FLG_CRITSEC_EVENT_CREATION;
}


NTSTATUS
RtlInitializeCriticalSectionAndSpinCount (
    IN PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

    SpinCount - Supplies the spincount to use for MP collisions.

Return Value:

    NTSTATUS - Status of semaphore creation.

--*/

{
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction. Recursion count is the number of
    //  times the critical section has been recursively entered.
    //

    CriticalSection->LockCount = -1;
    CriticalSection->RecursionCount = 0;
    CriticalSection->OwningThread = 0;
    CriticalSection->LockSemaphore = 0;
    if ( NtCurrentPeb()->NumberOfProcessors > 1 ) {
        CriticalSection->SpinCount = SpinCount & MAX_SPIN_COUNT;
    } else {
        CriticalSection->SpinCount = 0;
    }

    ASSERT (GlobalKeyedEventHandle != NULL);

    //
    // Initialize debugging information.
    //

    DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG) RtlpAllocateDebugInfo ();

    if (DebugInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    DebugInfo->Type = RTL_CRITSECT_TYPE;
    DebugInfo->ContentionCount = 0;
    DebugInfo->EntryCount = 0;

    //
    // It is important to set critical section pointers and potential
    // stack trace before we insert the resource in the process' 
    // resource list because the list can be randomly traversed from
    // other threads that check for orphaned resources.
    //

    DebugInfo->CriticalSection = CriticalSection;
    CriticalSection->DebugInfo = DebugInfo;

    //
    // Try to get a stack trace. If no trace database was created
    // then the log() function is a no op.
    //

    DebugInfo->CreatorBackTraceIndex = (USHORT) RtlLogStackBackTrace();

    //
    // If the critical section lock itself is not being initialized, then
    // synchronize the insert of the critical section in the process locks
    // list. Otherwise, insert the critical section with no synchronization.
    //

    if (CriticalSection != &RtlCriticalSectionLock) {

        RtlEnterCriticalSection(&RtlCriticalSectionLock);
        InsertTailList(&RtlCriticalSectionList, &DebugInfo->ProcessLocksList);
        RtlLeaveCriticalSection(&RtlCriticalSectionLock );

    } else {
        InsertTailList(&RtlCriticalSectionList, &DebugInfo->ProcessLocksList);
    }

    if (IsCritSecLogging(CriticalSection)) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(CRIT_SEC_INITIALIZE_EVENT_DATA) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation (&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PCRIT_SEC_INITIALIZE_EVENT_DATA pCritSecInitializeEvent = (PCRIT_SEC_INITIALIZE_EVENT_DATA)
                ((SIZE_T)pEventHeader + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = ReqSize;
            pEventHeader->Packet.HookId= (USHORT) PERFINFO_LOG_TYPE_CRITSEC_INITIALIZE;

            pCritSecInitializeEvent->Address = (PVOID)CriticalSection;
            pCritSecInitializeEvent->SpinCount = (PVOID)CriticalSection->SpinCount;

            ReleaseBufferLocation(pThreadLocalData);
        }
    }

    return STATUS_SUCCESS;
}


ULONG
RtlSetCriticalSectionSpinCount (
    IN PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    Returns the previous critical section spin count

--*/

{
    ULONG OldSpinCount;

    OldSpinCount = (ULONG)CriticalSection->SpinCount;

    if ( NtCurrentPeb()->NumberOfProcessors > 1 ) {
        CriticalSection->SpinCount = SpinCount & MAX_SPIN_COUNT;
    } else {
        CriticalSection->SpinCount = 0;
    }

    return OldSpinCount;
}


BOOLEAN
RtlpCreateCriticalSectionSem (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS Status, Status1;
    HANDLE SemHandle;

#if defined (RTLP_USE_GLOBAL_KEYED_EVENT)
    Status = STATUS_INSUFFICIENT_RESOURCES;
    SemHandle = NULL;
#else
    Status = NtCreateEvent (&SemHandle,
                            DESIRED_EVENT_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE);

#endif
    if (NT_SUCCESS (Status)) {
        if (InterlockedCompareExchangePointer (&CriticalSection->LockSemaphore,  SemHandle, NULL) != NULL) {
            Status1 = NtClose (SemHandle);
            ASSERT (NT_SUCCESS (Status1));
        } else {
#if DBG
            ProtectHandle(SemHandle);
#endif // DBG
        }
    } else {
        ASSERT (GlobalKeyedEventHandle != NULL);
        InterlockedCompareExchangePointer (&CriticalSection->LockSemaphore,
                                           GlobalKeyedEventHandle,
                                           NULL);
    }
    return TRUE;
}


VOID
RtlpCheckDeferredCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    if (CriticalSection->LockSemaphore == NULL) {
        RtlpCreateCriticalSectionSem(CriticalSection);
    }
    return;
}


NTSTATUS
RtlDeleteCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input critical
    section variable


Arguments:

    CriticalSection - Supplies the resource variable being deleted

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    HANDLE LockSemaphore;

    LockSemaphore = CriticalSection->LockSemaphore;

    if (LockSemaphore != NULL && !RtlpIsKeyedEvent (LockSemaphore)) {
#if DBG
        UnProtectHandle (LockSemaphore);
#endif // DBG
        Status = NtClose (LockSemaphore);
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Remove critical section from the list
    //

    DebugInfo = NULL;
    RtlEnterCriticalSection (&RtlCriticalSectionLock);

    try {
        DebugInfo = CriticalSection->DebugInfo;
        if (DebugInfo != NULL) {
            RemoveEntryList (&DebugInfo->ProcessLocksList);
            RtlZeroMemory (DebugInfo, sizeof (*DebugInfo));
        }
    } finally {
        RtlLeaveCriticalSection (&RtlCriticalSectionLock);
    }
    if (DebugInfo != NULL) {
        RtlpFreeDebugInfo( DebugInfo );
    }
    RtlZeroMemory (CriticalSection,
                   sizeof(RTL_CRITICAL_SECTION));

    return Status;
}



//
// The following support routines are called from the machine language
// implementations of RtlEnterCriticalSection and RtlLeaveCriticalSection
// to execute the slow path logic of either waiting for a critical section
// or releasing a critical section to a waiting thread.
//
void
RtlpWaitForCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS st;
    ULONG TimeoutCount = 0;
    PLARGE_INTEGER TimeoutTime;
    LOGICAL CsIsLoaderLock;
    HANDLE LockSemaphore;
    PTEB Teb;

    //
    // Critical sections are disabled during exit process so that
    // apps that are not careful during shutdown don't hang
    //

    CsIsLoaderLock = (CriticalSection == &LdrpLoaderLock);

    Teb = NtCurrentTeb ();
    Teb->WaitingOnLoaderLock = (ULONG)CsIsLoaderLock;

    if ( LdrpShutdownInProgress &&
        ((!CsIsLoaderLock) ||
         (CsIsLoaderLock && LdrpShutdownThreadId == Teb->ClientId.UniqueThread) ) ) {

        //
        // Slimy reinitialization of the critical section with the count
        // biased by one.  This is how the critical section would normally
        // look to the thread coming out of this function. Note that the
        // semaphore handle is leaked, but since the app is exiting, it's ok
        //

        CriticalSection->LockCount = 0;
        CriticalSection->RecursionCount = 0;
        CriticalSection->OwningThread = 0;
        CriticalSection->LockSemaphore = 0;

        Teb->WaitingOnLoaderLock = 0;

        return;
    }

    if (RtlpTimoutDisable) {
        TimeoutTime = NULL;
    } else {
        TimeoutTime = &RtlpTimeout;
    }

    LockSemaphore = CriticalSection->LockSemaphore;

    if (LockSemaphore == NULL) {
        RtlpCheckDeferredCriticalSection (CriticalSection);
        LockSemaphore = CriticalSection->LockSemaphore;
    }

    CriticalSection->DebugInfo->EntryCount++;

    do {

        CriticalSection->DebugInfo->ContentionCount++;

#if 0
        DbgPrint( "NTDLL: Waiting for CritSect: %p  owned by ThreadId: %X  Count: %u  Level: %u\n",
                  CriticalSection,
                  CriticalSection->OwningThread,
                  CriticalSection->LockCount,
                  CriticalSection->RecursionCount
                );
#endif

        if( IsCritSecLogging(CriticalSection)){

            PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
            PPERFINFO_TRACE_HEADER pEventHeader = NULL;
            USHORT ReqSize = sizeof(CRIT_SEC_COLLISION_EVENT_DATA) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

            AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize );

            if(pEventHeader && pThreadLocalData) {

                PCRIT_SEC_COLLISION_EVENT_DATA pCritSecCollEvent = (PCRIT_SEC_COLLISION_EVENT_DATA)( (SIZE_T)pEventHeader
                                                           +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                pEventHeader->Packet.Size = ReqSize;
                pEventHeader->Packet.HookId= (USHORT) PERFINFO_LOG_TYPE_CRITSEC_COLLISION;

                pCritSecCollEvent->Address		    = (PVOID)CriticalSection;
                pCritSecCollEvent->SpinCount	    = (PVOID)CriticalSection->SpinCount;
                pCritSecCollEvent->LockCount	    = CriticalSection->LockCount;
                pCritSecCollEvent->OwningThread	    = (PVOID)CriticalSection->OwningThread;

                ReleaseBufferLocation(pThreadLocalData);
            }

        }

        if (!RtlpIsKeyedEvent (LockSemaphore)) {
            st = NtWaitForSingleObject (LockSemaphore,
                                        FALSE,
                                        TimeoutTime);
        } else {
            st = NtWaitForKeyedEvent (LockSemaphore,
                                      CriticalSection,
                                      FALSE,
                                      TimeoutTime);
        }
        if ( st == STATUS_TIMEOUT ) {

            //
            // This code path will be taken only if the TimeoutTime parameter for
            // Wait() was not null.
            //

            DbgPrint( "RTL: Enter Critical Section Timeout (%I64u secs) %d\n",
                      TimeoutTime->QuadPart / (-10000000), TimeoutCount
                    );
            DbgPrint( "RTL: Pid.Tid %x.%x, owner tid %x Critical Section %p - ContentionCount == %lu\n",
                    Teb->ClientId.UniqueProcess,
                    Teb->ClientId.UniqueThread,
                    CriticalSection->OwningThread,
                    CriticalSection, CriticalSection->DebugInfo->ContentionCount
                    );

            TimeoutCount += 1;

            if ((TimeoutCount > 2) && (CriticalSection != &LdrpLoaderLock)) {

                //
                // If the image is a Win32 image, then raise an exception
                // and try to get to the uae popup
                //

                RtlpPossibleDeadlock ((PVOID) CriticalSection);
            }
            DbgPrint("RTL: Re-Waiting\n");

        } else {

            if (NT_SUCCESS(st)) {

                //
                // If some errant thread calls SetEvent on a bogus handle
                // which happens to match the handle we are using in the
                // critical section, everything gets really messed up since
                // two threads now own the lock at the same time. ASSERT
                // that no other thread owns the lock if we have been
                // granted ownership.
                //

                ASSERT(CriticalSection->OwningThread == 0);

                if (CsIsLoaderLock) {
                    CriticalSection->OwningThread = Teb->ClientId.UniqueThread;
                    Teb->WaitingOnLoaderLock = 0;
                }
                return;
            }

            RtlRaiseStatus(st);
        }
    } while (TRUE);
}


VOID
RtlpUnWaitCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS st;
    HANDLE LockSemaphore;

    LockSemaphore = CriticalSection->LockSemaphore;

    if (LockSemaphore == NULL) {
        RtlpCheckDeferredCriticalSection (CriticalSection);
        LockSemaphore = CriticalSection->LockSemaphore;
    }

    if (!RtlpIsKeyedEvent (LockSemaphore)) {
        st = NtSetEventBoostPriority (LockSemaphore);
    } else {
        st = NtReleaseKeyedEvent (LockSemaphore,
                                  CriticalSection,
                                  FALSE,
                                  0);
    }

    if (!NT_SUCCESS (st)) {
        RtlRaiseStatus(st);
    }
}


VOID
RtlpNotOwnerCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    LOGICAL CsIsLoaderLock;

    //
    // Critical sections are disabled during exit process so that
    // apps that are not careful during shutdown don't hang
    //

    CsIsLoaderLock = (CriticalSection == &LdrpLoaderLock);

    if ( LdrpShutdownInProgress &&
        ((!CsIsLoaderLock) ||
         (CsIsLoaderLock && LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread) ) ) {
        return;
    }

    if (NtCurrentPeb()->BeingDebugged) {
        DbgPrint( "NTDLL: Calling thread (%X) not owner of CritSect: %p  Owner ThreadId: %X\n",
                  NtCurrentTeb()->ClientId.UniqueThread,
                  CriticalSection,
                  CriticalSection->OwningThread
                );
        DbgBreakPoint();
    }

    RtlRaiseStatus (STATUS_RESOURCE_NOT_OWNED);
}


#if DBG

void
RtlpCriticalSectionIsOwned (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    //
    // The loader lock gets handled differently, so don't assert on it
    //

    if ((CriticalSection == &LdrpLoaderLock) &&
        (CriticalSection->OwningThread == NtCurrentTeb()->ClientId.UniqueThread))
        return;

    //
    // If we're being debugged, throw up a warning
    //

    if (NtCurrentPeb()->BeingDebugged) {
        DbgPrint( "NTDLL: Calling thread (%X) shouldn't enter CritSect: %p  Owner ThreadId: %X\n",
                  NtCurrentTeb()->ClientId.UniqueThread,
                  CriticalSection,
                  CriticalSection->OwningThread
                );
        DbgBreakPoint();
    }
}
#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Critical section verifier
/////////////////////////////////////////////////////////////////////

//
// This variable enables the critical section verifier (abandoned locks,
// terminatethread() while holding locks, etc.). 
//

BOOLEAN RtlpCriticalSectionVerifier = FALSE;

//
// Settable from debugger to avoid a flurry of similar failures.
//

BOOLEAN RtlpCsVerifyDoNotBreak = FALSE;


VOID
RtlCheckHeldCriticalSections (
    IN HANDLE hThread,
    IN PRTL_CRITICAL_SECTION const *LocksHeld
    )
/*++

Routine Description:

    This routine is called to ensure that the given thread does not
    hold any locks other than the ones in a specified list of
    known-held locks.

Arguments:

    hThread     -- the thread to check

    LocksHeld   -- Locks known to be held by the thread

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInfo;
    PLIST_ENTRY Entry;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    RTL_CRITICAL_SECTION_DEBUG ExtraDebugInfoCopy = {0}; // initialized because of W4 warning
    PRTL_CRITICAL_SECTION CriticalSection;
    RTL_CRITICAL_SECTION CritSectCopy = {0}; // initialized because of W4 warning
    PRTL_CRITICAL_SECTION const *LockHeld;
    BOOLEAN Copied;

    //
    // We do not check anything if critical section verifier is not on.
    //

    if (RtlpCriticalSectionVerifier == FALSE || RtlpCsVerifyDoNotBreak == TRUE ) {
        return;
    }

    //
    // We do not do anything if we are shutting down the process.
    //

    if (LdrpShutdownInProgress) {
        return;
    }

    //
    // Query the thread ID and TEB address.
    //

    Status = NtQueryInformationThread (hThread,
                                       ThreadBasicInformation,
                                       &ThreadInfo,
                                       sizeof(ThreadInfo),
                                       NULL);
    if (! NT_SUCCESS(Status)) {
        return;
    }

    //
    // Don't do anything else if number of owned critical sections
    // stored in the TEB is zero. The app verifier keeps this TEB
    // counter updated on all platforms instead of just x86 chk 
    // without the verifier, at least for critical sections that were not
    // entered from ntdll.
    //

    if (ThreadInfo.TebBaseAddress->CountOfOwnedCriticalSections < 1) {

        return;
    }

    //
    // Iterate the global list of critical sections
    //

    RtlEnterCriticalSection (&RtlCriticalSectionLock);

    try {

        for (Entry = RtlCriticalSectionList.Flink;
            Entry != &RtlCriticalSectionList;
            Entry = Entry->Flink) {

            DebugInfo = CONTAINING_RECORD (Entry,
                                           RTL_CRITICAL_SECTION_DEBUG,
                                           ProcessLocksList);

            CriticalSection = DebugInfo->CriticalSection;

            if (CriticalSection == &RtlCriticalSectionLock) {

                //
                // We know that we're holding this one, so there's no
                // problem -- continue on.
                //

                continue;
            }

            if (LocksHeld) {

                //
                // We have a list of okay-to-hold critical sections;
                // scan through it, looking for this critical section.
                // If we find it, we'll skip it and continue walking
                // ProcessLocksList.
                //
                
                for (LockHeld = LocksHeld;
                     *LockHeld;
                     LockHeld++) {

                    if (CriticalSection == *LockHeld) {

                        //
                        // We've found this critical section in the
                        // LocksHeld array.
                        //

                        break;
                    }
                }

                if (*LockHeld) {

                    //
                    // Our caller expected the thread to be holding
                    // this critical section; skip it, and continue
                    // walking through ProcessLocksList.
                    //

                    continue;
                }
            }

            Copied = TRUE;

            try {

                CritSectCopy = *CriticalSection;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {

                Copied = FALSE;
            }

            if (Copied == FALSE) {

                //
                // Exception while reading the contents of the critsect.  
                // The critsect has probably been decommitted without a call to
                // RtlDeleteCriticalSection.
                //
                // You might think the entry could be deleted from the list,
                // but it can't... there may be another RTL_CRITICAL_SECTION out
                // there that is truly allocated, and whose DebugInfo pointer
                // points at this DebugInfo.  In that case, when that critsect
                // is deleted, the RtlCriticalSectionList is corrupted.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY,
                                "undeleted critical section in freed memory",
                                CriticalSection, "Critical section address",
                                DebugInfo, "Critical section debug info address",
                                RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                "Initialization stack trace. Use dds to dump it if non-NULL.",
                                NULL, "" );
            }
            else if(CritSectCopy.DebugInfo != DebugInfo) {

                //
                // Successfully read the critical section structure but
                // the current debug info field of this critical section
                // doesn't point to the current DebugInfo - it was probably
                // initialized more than one time or simply corrupted.
                // 
                // Try to make a copy of the DebugInfo currently pointed 
                // by our critical section. This might fail if the critical
                // section is corrupted.
                //

                Copied = TRUE;

                try {

                    ExtraDebugInfoCopy = *(CritSectCopy.DebugInfo);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    Copied = FALSE;
                }

                if (Copied == FALSE) {

                    //
                    // Exception while reading the contents of the debug info.
                    // The current critical section structure is corrupted.
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_CORRUPTED,
                                   "corrupted critical section",
                                   CriticalSection, 
                                   "Critical section address",
                                   CritSectCopy.DebugInfo, 
                                   "Invalid debug info address of this critical section",
                                   DebugInfo, 
                                   "Address of the debug info found in the active list.",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                   "Initialization stack trace. Use dds to dump it if non-NULL." );
                }
                else {

                    // 
                    // Successfully read this second debug info 
                    // of the same critical section. 
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_DOUBLE_INITIALIZE,
                                   "double initialized or corrupted critical section",
                                   CriticalSection, 
                                   "Critical section address.",
                                   DebugInfo, 
                                   "Address of the debug info found in the active list.",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                   "First initialization stack trace. Use dds to dump it if non-NULL.",
                                   RtlpGetStackTraceAddress (ExtraDebugInfoCopy.CreatorBackTraceIndex), 
                                   "Second initialization stack trace. Use dds to dump it if non-NULL.");
                }
            }
            else if (CritSectCopy.OwningThread == ThreadInfo.ClientId.UniqueThread
                     && CritSectCopy.LockCount != -1) {

                //
                // The thread has a critical section locked. Since this API is called
                // whenever the thread is in a context that does not allow this
                // we will have to report the issue (e.g. thread exits or is 
                // terminated, a thread pool work item finished, etc.).
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_EXIT_THREAD_OWNS_LOCK,
                               "Thread is in a state in which it cannot own a critical section",
                               ThreadInfo.ClientId.UniqueThread, "Thread identifier",
                               CriticalSection, "Critical section address",
                               DebugInfo, "Critical section debug info address",
                               RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), "Initialization stack trace. Use dds to dump it if non-NULL." );
            }
        }
    }
    finally {

        //
        // Release the CS list lock.
        //

        RtlLeaveCriticalSection (&RtlCriticalSectionLock);
    }
}


VOID
RtlCheckForOrphanedCriticalSections (
    IN HANDLE hThread
    )
/*++

Routine Description:

    This routine is called from kernel32's ExitThread, TerminateThread
    and SuspendThread in an effort to track calls that kill threads while 
    they own critical sections.

Arguments:

    hThread     -- thread to be killed

Return Value:

    None.

--*/
{
    // The work is performed by RtlCheckHeldCriticalSections, which we
    // call with the following okay-to-be-held critical section.

    PRTL_CRITICAL_SECTION const LocksHeld[] = {
        &LdrpLoaderLock,
        NULL
    };

    RtlCheckHeldCriticalSections(hThread, LocksHeld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\rtltheemptyactivationcontextdata.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rtltheemptyactivationcontextdata.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of the application context object.

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include <limits.h>
#include "sxsp.h"

extern const ACTIVATION_CONTEXT_DATA RtlpTheEmptyActivationContextData =
{
    ACTIVATION_CONTEXT_DATA_MAGIC,
    sizeof(ACTIVATION_CONTEXT_DATA), // header size
    ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER,
    sizeof(ACTIVATION_CONTEXT_DATA), // total size
    0, // default toc offset
    0, // extended toc offset
    0  // assembly roster index
};

extern const ACTIVATION_CONTEXT_WRAPPED RtlpTheEmptyActivationContextWrapped =
{
    ACTCTX_MAGIC_MARKER,
    {
        LONG_MAX, // ref count, pinned
        ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED, // flags
        (PVOID)&RtlpTheEmptyActivationContextData
        // the rest zeros and NULLs
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\seurtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    seurtl.c

Abstract:

    This Module implements many security rtl routines defined in nturtl.h

Author:

    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine
    User mode callable only

Revision History:

--*/


#include "ldrp.h"
#include <ntos.h>
#include <nturtl.h>
#include <ntlsa.h>      // needed for RtlGetPrimaryDomain
#include "seopaque.h"
#include "sertlp.h"





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#if WHEN_LSAUDLL_MOVED_TO_NTDLL
NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    )

/*++

Routine Description:

    This procedure opens the LSA policy object and retrieves
    the primary domain information for this machine.

Arguments:

    SidLength - Specifies the length of the PrimaryDomainSid
        parameter.

    PrimaryDomainPresent - Receives a boolean value indicating
        whether this machine has a primary domain or not. TRUE
        indicates the machine does have a primary domain. FALSE
        indicates the machine does not.

    PrimaryDomainName - Points to the unicode string to receive
        the primary domain name.  This parameter will only be
        used if there is a primary domain.

    RequiredNameLength - Recevies the length of the primary
        domain name (in bytes).  This parameter will only be
        used if there is a primary domain.

    PrimaryDomainSid - This optional parameter, if present,
        points to a buffer to receive the primary domain's
        SID.  This parameter will only be used if there is a
        primary domain.

    RequiredSidLength - Recevies the length of the primary
        domain SID (in bytes).  This parameter will only be
        used if there is a primary domain.


Return Value:

    STATUS_SUCCESS - The requested information has been retrieved.

    STATUS_BUFFER_TOO_SMALL - One of the return buffers was not
        large enough to receive the corresponding information.
        The RequiredNameLength and RequiredSidLength parameter
        values have been set to indicate the needed length.

    Other status values as may be returned by:

        LsaOpenPolicy()
        LsaQueryInformationPolicy()
        RtlCopySid()


--*/




{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;


    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (NT_SUCCESS(Status)) {

        //
        // Get the primary domain info
        //
        Status = LsaQueryInformationPolicy(LsaHandle,
                                           PolicyPrimaryDomainInformation,
                                           (PVOID *)&PrimaryDomainInfo);
        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (NT_SUCCESS(Status)) {

        //
        // Is there a primary domain?
        //

        if (PrimaryDomainInfo->Sid != NULL) {

            //
            // Yes
            //

            (*PrimaryDomainPresent) = TRUE;
            (*RequiredNameLength) = PrimaryDomainInfo->Name.Length;
            (*RequiredSidLength)  = RtlLengthSid(PrimaryDomainInfo->Sid);



            //
            // Copy the name
            //

            if (PrimaryDomainName->MaximumLength >=
                PrimaryDomainInfo->Name.Length) {
                RtlCopyUnicodeString(
                    PrimaryDomainName,
                    &PrimaryDomainInfo->Name
                    );
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }


            //
            // Copy the SID (if appropriate)
            //

            if (PrimaryDomainSid != NULL && NT_SUCCESS(Status)) {

                Status = RtlCopySid(SidLength,
                                    PrimaryDomainSid,
                                    PrimaryDomainInfo->Sid
                                    );
            }
        } else {

            (*PrimaryDomainPresent) = FALSE;
        }

        //
        // We're finished with the buffer returned by LSA
        //

        IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }


    return(Status);
}
#endif //WHEN_LSAUDLL_MOVED_TO_NTDLL


NTSTATUS
RtlNewSecurityObjectWithMultipleInheritance (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                pObjectType,
                GuidCount,
                IsDirectoryObject,
                AutoInheritFlags,
                Token,
                GenericMapping );

}



NTSTATUS
RtlNewSecurityObjectEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                ObjectType ? &ObjectType : NULL,
                ObjectType ? 1 : 0,
                IsDirectoryObject,
                AutoInheritFlags,
                Token,
                GenericMapping );

}


NTSTATUS
RtlNewSecurityObject (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                NULL,   // No ObjectType
                0,  
                IsDirectoryObject,
                0,      // No Automatic inheritance
                Token,
                GenericMapping );

}



NTSTATUS
RtlSetSecurityObject (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    See RtlpSetSecurityObject.

Arguments:

    See RtlpSetSecurityObject.

Return Value:

    See RtlpSetSecurityObject.

--*/

{

    //
    // Simply call RtlpSetSecurityObject specifying no auto inheritance.
    //

    return RtlpSetSecurityObject( NULL,
                                  SecurityInformation,
                                  ModificationDescriptor,
                                  ObjectsSecurityDescriptor,
                                  0,   // No AutoInheritance
                                  PagedPool,
                                  GenericMapping,
                                  Token );
}



NTSTATUS
RtlSetSecurityObjectEx (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    See RtlpSetSecurityObject.

Arguments:

    See RtlpSetSecurityObject.

Return Value:

    See RtlpSetSecurityObject.

--*/

{

    //
    // Simply call RtlpSetSecurityObject specifying no auto inheritance.
    //

    return RtlpSetSecurityObject( NULL,
                                  SecurityInformation,
                                  ModificationDescriptor,
                                  ObjectsSecurityDescriptor,
                                  AutoInheritFlags,
                                  PagedPool,
                                  GenericMapping,
                                  Token );
}





NTSTATUS
RtlQuerySecurityObject (
    IN PSECURITY_DESCRIPTOR ObjectDescriptor,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR ResultantDescriptor,
    IN ULONG DescriptorLength,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    Query information from a protected server object's existing security
    descriptor.

    This procedure, called only from user mode, is used to retrieve
    information from a security descriptor on an existing protected
    server's object.  All access checking is expected to be done before
    calling this routine.  This includes checking for READ_CONTROL, and
    privilege to read a system ACL as appropriate.

                          - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.


Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        queried.

    SecurityInformation - Identifies the security information being
        requested.

    ResultantDescriptor - Points to buffer to receive the resultant
        security descriptor.  The resultant security descriptor will
        contain all information requested by the SecurityInformation
        parameter.

    DescriptorLength - Is an unsigned integer which indicates the length,
        in bytes, of the buffer provided to receive the resultant
        descriptor.

    ReturnLength - Receives an unsigned integer indicating the actual
        number of bytes needed in the ResultantDescriptor to store the
        requested information.  If the value returned is greater than the
        value passed via the DescriptorLength parameter, then
        STATUS_BUFFER_TOO_SMALL is returned and no information is returned.


Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_BUFFER_TOO_SMALL - The buffer provided to receive the requested
        information was not large enough to hold the information.  No
        information has been returned.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates the provided object's security
        descriptor was not in self-relative format.

--*/

{

    PSID Group;
    PSID Owner;
    PACL Dacl;
    PACL Sacl;

    ULONG GroupSize = 0;
    ULONG DaclSize = 0;
    ULONG SaclSize = 0;
    ULONG OwnerSize = 0;

    PCHAR Field;
    PCHAR Base;


    PISECURITY_DESCRIPTOR IObjectDescriptor;
    PISECURITY_DESCRIPTOR_RELATIVE IResultantDescriptor;

    Dacl = NULL;
    Sacl = NULL;
    Group = NULL;
    Owner = NULL;

    IResultantDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE)ResultantDescriptor;
    IObjectDescriptor = (PISECURITY_DESCRIPTOR)ObjectDescriptor;

    //
    // For each item specified in the SecurityInformation, extract it
    // and get it to the point where it can be copied into a new
    // descriptor.
    //

    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        Group = RtlpGroupAddrSecurityDescriptor(IObjectDescriptor);

        if (Group != NULL) {
            GroupSize = LongAlignSize(SeLengthSid(Group));
        }
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

        Dacl = RtlpDaclAddrSecurityDescriptor( IObjectDescriptor );

        if (Dacl != NULL) {
            DaclSize = LongAlignSize(Dacl->AclSize);
        }
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {

        Sacl = RtlpSaclAddrSecurityDescriptor( IObjectDescriptor );

        if (Sacl != NULL) {
            SaclSize = LongAlignSize(Sacl->AclSize);
        }

    }

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        Owner = RtlpOwnerAddrSecurityDescriptor ( IObjectDescriptor );

        if (Owner != NULL) {
            OwnerSize = LongAlignSize(SeLengthSid(Owner));
        }
    }

    *ReturnLength = sizeof( SECURITY_DESCRIPTOR_RELATIVE ) +
                    GroupSize +
                    DaclSize  +
                    SaclSize  +
                    OwnerSize;

    if (*ReturnLength > DescriptorLength) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    RtlCreateSecurityDescriptorRelative(
        IResultantDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( IResultantDescriptor, SE_SELF_RELATIVE );

    Base = (PCHAR)(IResultantDescriptor);
    Field =  Base + (ULONG)sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {

        if (SaclSize > 0) {
            RtlMoveMemory( Field, Sacl, SaclSize );
            IResultantDescriptor->Sacl = RtlPointerToOffset(Base,Field);
            Field += SaclSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_SACL_PRESENT | SE_SACL_DEFAULTED
            );
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

        if (DaclSize > 0) {
            RtlMoveMemory( Field, Dacl, DaclSize );
            IResultantDescriptor->Dacl = RtlPointerToOffset(Base,Field);
            Field += DaclSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_DACL_PRESENT | SE_DACL_DEFAULTED
            );
    }

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        if (OwnerSize > 0) {
            RtlMoveMemory( Field, Owner, OwnerSize );
            IResultantDescriptor->Owner = RtlPointerToOffset(Base,Field);
            Field += OwnerSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_OWNER_DEFAULTED
            );

    }

    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        if (GroupSize > 0) {
            RtlMoveMemory( Field, Group, GroupSize );
            IResultantDescriptor->Group = RtlPointerToOffset(Base,Field);
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_GROUP_DEFAULTED
            );
    }

    return( STATUS_SUCCESS );

}





NTSTATUS
RtlDeleteSecurityObject (
    IN OUT PSECURITY_DESCRIPTOR * ObjectDescriptor
    )


/*++

Routine Description:

    Delete a protected server object's security descriptor.

    This procedure, called only from user mode, is used to delete a
    security descriptor associated with a protected server's object.  This
    routine will normally be called by a protected server during object
    deletion.

                                  - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.


Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        deleted.


Return Value:

    STATUS_SUCCESS - The operation was successful.

--*/

{
    RtlFreeHeap( RtlProcessHeap(), 0, (PVOID)*ObjectDescriptor );

    return( STATUS_SUCCESS );

}




NTSTATUS
RtlNewInstanceSecurityObject(
    IN BOOLEAN ParentDescriptorChanged,
    IN BOOLEAN CreatorDescriptorChanged,
    IN PLUID OldClientTokenModifiedId,
    OUT PLUID NewClientTokenModifiedId,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    If the return status is STATUS_SUCCESS and the NewSecurity return
    value is NULL, then the security desscriptor of the original
    instance of the object is valid for this instance as well.

Arguments:

    ParentDescriptorChanged - Supplies a flag indicating whether the
        parent security descriptor has changed since the last time
        this set of parameters was used.

    CreatorDescriptorChanged - Supplies a flag indicating whether the
        creator security descriptor has changed since the last time
        this set of parameters was used.

    OldClientTokenModifiedId - Supplies the ModifiedId from the passed
        token that was in effect when this call was last made with
        these parameters.  If the current ModifiedId is different from
        the one passed in here, the security descriptor must be
        rebuilt.

    NewClientTokenModifiedId - Returns the current ModifiedId from the
        passed token.

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    TOKEN_STATISTICS ClientTokenStatistics;
    ULONG ReturnLength;
    NTSTATUS Status;



    //
    // Get the current token modified LUID
    //


    Status = NtQueryInformationToken(
                 Token,                        // Handle
                 TokenStatistics,              // TokenInformationClass
                 &ClientTokenStatistics,       // TokenInformation
                 sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                 &ReturnLength                 // ReturnLength
                 );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    *NewClientTokenModifiedId = ClientTokenStatistics.ModifiedId;

    if ( RtlEqualLuid(NewClientTokenModifiedId, OldClientTokenModifiedId) ) {

        if ( !(ParentDescriptorChanged || CreatorDescriptorChanged) ) {

            //
            // The old security descriptor is valid for this new instance
            // of the object type as well.  Pass back success and NULL for
            // the NewDescriptor.
            //

            *NewDescriptor = NULL;
            return( STATUS_SUCCESS );

        }
    }

    //
    // Something has changed, take the long route and build a new
    // descriptor
    //

    return( RtlNewSecurityObject( ParentDescriptor,
                                  CreatorDescriptor,
                                  NewDescriptor,
                                  IsDirectoryObject,
                                  Token,
                                  GenericMapping
                                  ));
}




NTSTATUS
RtlNewSecurityGrantedAccess(
    IN ACCESS_MASK DesiredAccess,
    OUT PPRIVILEGE_SET Privileges,
    IN OUT PULONG Length,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK RemainingDesiredAccess
    )

/*++

Routine Description:

    This routine implements privilege policy by examining the bits in
    a DesiredAccess mask and adjusting them based on privilege checks.

    Currently, a request for ACCESS_SYSTEM_SECURITY may only be satisfied
    by the caller having SeSecurityPrivilege.

    Note that this routine is only to be called when an object is being
    created.  When an object is being opened, it is expected that
    NtAccessCheck will be called, and that routine will implement
    another policy for substituting privileges for DACL access.

Arguments:

    DesiredAccess - Supplies the user's desired access mask

    Privileges - Supplies a pointer to an empty buffer in which will
        be returned a privilege set describing any privileges that were
        used to gain access.

        Note that this is not an optional parameter, that is, enough
        room for a single privilege must always be passed.

    Length - Supplies the length of the Privileges parameter in bytes.
        If the supplies length is not adequate to store the entire
        privilege set, this field will return the minimum length required.

    Token - (optionally) Supplies the token for the client on whose
        behalf the object is being accessed.  If this value is
        specified as null, then the token on the thread is opened and
        examined to see if it is an impersonation token.  If it is,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    RemainingDesiredAccess - Returns the DesiredAccess mask after any bits
        have been masked off.  If no access types could be granted, this
        mask will be identical to the one passed in.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_BAD_IMPERSONATION_LEVEL - The caller or passed token was
        impersonating, but not at a high enough level.


--*/

{
    PRIVILEGE_SET RequiredPrivilege;
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    HANDLE ThreadToken;
    BOOLEAN TokenPassed;
    TOKEN_STATISTICS ThreadTokenStatistics;
    ULONG ReturnLength;
    ULONG SizeRequired;
    ULONG PrivilegeNumber = 0;


    //
    //  If the caller hasn't passed a token, call the kernel and get
    //  his impersonation token.  This call will fail if the caller is
    //  not impersonating a client, so if the caller is not
    //  impersonating someone, he'd better have passed in an explicit
    //  token.
    //

    if (!ARGUMENT_PRESENT( Token )) {

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ThreadToken
                     );

        TokenPassed = FALSE;

        if (!NT_SUCCESS( Status )) {
            return( Status );
        }

    } else {

        ThreadToken = Token;
        TokenPassed = TRUE;
    }

    Status = NtQueryInformationToken(
                 ThreadToken,                  // Handle
                 TokenStatistics,              // TokenInformationClass
                 &ThreadTokenStatistics,       // TokenInformation
                 sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                 &ReturnLength                 // ReturnLength
                 );

    ASSERT( NT_SUCCESS(Status) );

    RtlMapGenericMask(
        &DesiredAccess,
        GenericMapping
        );

    *RemainingDesiredAccess = DesiredAccess;

    if ( DesiredAccess & ACCESS_SYSTEM_SECURITY ) {

        RequiredPrivilege.PrivilegeCount = 1;
        RequiredPrivilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
        RequiredPrivilege.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
        RequiredPrivilege.Privilege[0].Attributes = 0;

        //
        // NtPrivilegeCheck will make sure we are impersonating
        // properly.
        //

        Status = NtPrivilegeCheck(
                     ThreadToken,
                     &RequiredPrivilege,
                     &Result
                     );

        if ( (!NT_SUCCESS ( Status )) || (!Result) ) {

            if (!TokenPassed) {
                NtClose( ThreadToken );
            }

            if ( !NT_SUCCESS( Status )) {
                return( Status );
            }

            if ( !Result ) {
                return( STATUS_PRIVILEGE_NOT_HELD );
            }

        }

        //
        // We have the required privilege, turn off the bit in
        // copy of the input mask and remember that we need to return
        // this privilege.
        //

        *RemainingDesiredAccess &= ~ACCESS_SYSTEM_SECURITY;
    }

    if (!TokenPassed) {
        NtClose( ThreadToken );
    }

    SizeRequired = sizeof(PRIVILEGE_SET);

    if ( SizeRequired > *Length ) {
        *Length = SizeRequired;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    if (Result) {

        Privileges->PrivilegeCount = 1;
        Privileges->Control = 0;
        Privileges->Privilege[PrivilegeNumber].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
        Privileges->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

    } else {

        Privileges->PrivilegeCount = 0;
        Privileges->Control = 0;
        Privileges->Privilege[PrivilegeNumber].Luid = RtlConvertLongToLuid(0);
        Privileges->Privilege[PrivilegeNumber].Attributes = 0;

    }

    return( STATUS_SUCCESS );

}



NTSTATUS
RtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    )

/*++

Routine Description:

    This routine will copy a self-relative security descriptor from
    any memory into the correct type of memory required by security
    descriptor Rtl routines.

    This allows security descriptors to be kept in whatever kind of
    storage is most convenient for the current application.  A security
    descriptor should be copied via this routine and the copy passed
    into any Rtl routine that in any way modify the security descriptor
    (eg RtlSetSecurityObject).

    The storage allocated by this routine must be freed by
    RtlDeleteSecurityObject.

Arguments:

    InputSecurityDescriptor - contains the source security descriptor

    OutputSecurityDescriptor - returns a copy of the security descriptor
        in the correct kind of memory.


Return Value:

    STATUS_NO_MEMORY - There was not enough memory available to the current
        process to complete this operation.

--*/

{

    PACL Dacl;
    PACL Sacl;

    PSID Owner;
    PSID PrimaryGroup;

    ULONG DaclSize;
    ULONG OwnerSize;
    ULONG PrimaryGroupSize;
    ULONG SaclSize;
    ULONG TotalSize;

    PISECURITY_DESCRIPTOR ISecurityDescriptor =
                            (PISECURITY_DESCRIPTOR)InputSecurityDescriptor;


    RtlpQuerySecurityDescriptor(
        ISecurityDescriptor,
        &Owner,
        &OwnerSize,
        &PrimaryGroup,
        &PrimaryGroupSize,
        &Dacl,
        &DaclSize,
        &Sacl,
        &SaclSize
        );

    TotalSize = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
                OwnerSize +
                PrimaryGroupSize +
                DaclSize +
                SaclSize;

    *OutputSecurityDescriptor = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( SE_TAG ), TotalSize );

    if ( *OutputSecurityDescriptor == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    RtlCopyMemory( *OutputSecurityDescriptor,
                   ISecurityDescriptor,
                   TotalSize
                   );

    return( STATUS_SUCCESS );

}


NTSTATUS
RtlpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AllowedSid),
               &(AllowedAce->SidStart),
               AllowedSid
               );
}


NTSTATUS
RtlpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(DeniedSid),
               &(DeniedAce->SidStart),
               DeniedSid
               );
}


NTSTATUS
RtlpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid
               );
}

NTSTATUS
RtlCreateAndSetSD(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolute security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        RTL_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityDescriptor;


        return RtlCreateAndSetSD(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   &WkstaSecurityDescriptor
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute security descriptor
        allocated using RtlAllocateHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus = STATUS_SUCCESS;
    ULONG i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    ULONG DaclSize = sizeof(ACL);
    ULONG SaclSize = sizeof(ACL);
    ULONG MaxAceSize = 0;
    PVOID MaxAce = NULL;

    PCHAR CurrentAvailable;
    ULONG Size;

    PVOID HeapHandle = RtlProcessHeap();


    ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            SaclSize += AceSize;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        MaxAceSize = MaxAceSize > AceSize ? MaxAceSize : AceSize;
    }

    //
    // Allocate a chunk of memory large enough for the security descriptor,
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;
    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }
    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = RtlAllocateHeap(
                          HeapHandle, MAKE_TAG( SE_TAG ),
                          Size
                          )) == NULL) {
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (PCHAR)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        ntstatus = RtlCreateAcl( Dacl, DaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {
        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        ntstatus = RtlCreateAcl( Sacl, SaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = RtlAllocateHeap(
                      HeapHandle, MAKE_TAG( SE_TAG ),
                      MaxAceSize
                      )) == NULL ) {
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;
        PACL CurrentAcl;

        CurrentAcl = NULL;
        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            CurrentAcl = Dacl;
            ntstatus = RtlpInitializeAllowedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            CurrentAcl = Dacl;
            ntstatus = RtlpInitializeDeniedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            CurrentAcl = Sacl;
            ntstatus = RtlpInitializeAuditAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;
        }

        if ( !NT_SUCCESS( ntstatus ) ) {
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        ntstatus = RtlAddAce(
                         CurrentAcl,
                         ACL_REVISION,
                         MAXULONG,
                         MaxAce,
                         AceSize
                         );

        if (! NT_SUCCESS ( ntstatus ) ) {
            goto Cleanup;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if (! NT_SUCCESS(ntstatus = RtlCreateSecurityDescriptor(
                                    AbsoluteSd,
                                    SECURITY_DESCRIPTOR_REVISION
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetOwnerSecurityDescriptor(
                                    AbsoluteSd,
                                    OwnerSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetGroupSecurityDescriptor(
                                    AbsoluteSd,
                                    GroupSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetDaclSecurityDescriptor(
                                    AbsoluteSd,
                                    TRUE,
                                    Dacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetSaclSecurityDescriptor(
                                    AbsoluteSd,
                                    Sacl ? TRUE : FALSE,
                                    Sacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    //
    // Done
    //

    ntstatus = STATUS_SUCCESS;

    //
    // Clean up
    //

Cleanup:
    //
    // Either return the security descriptor to the caller or delete it
    //

    if ( NT_SUCCESS( ntstatus ) ) {
        *NewDescriptor = AbsoluteSd;
    } else if ( AbsoluteSd != NULL ) {
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {
        (void) RtlFreeHeap(HeapHandle, 0, MaxAce);
    }
    return ntstatus;
}


NTSTATUS
RtlCreateUserSecurityObject(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        RTL_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityObject;


        return RtlCreateUserSecurityObject(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   FALSE,
                   &WsConfigInfoMapping,
                   &WkstaSecurityObject
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    IsDirectoryObject - Supplies the flag which indicates whether the
        user-mode object is a directory object.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR AbsoluteSd;
    HANDLE TokenHandle;
    PVOID HeapHandle = RtlProcessHeap();

    ntstatus = RtlCreateAndSetSD(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        return ntstatus;
    }

    ntstatus = NtOpenProcessToken(
                   NtCurrentProcess(),
                   TOKEN_QUERY,
                   &TokenHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
        return ntstatus;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    ntstatus = RtlNewSecurityObject(
                   NULL,                   // Parent descriptor
                   AbsoluteSd,             // Creator descriptor
                   NewDescriptor,          // Pointer to new descriptor
                   IsDirectoryObject,      // Is directory object
                   TokenHandle,            // Token
                   GenericMapping          // Generic mapping
                   );

    (void) NtClose(TokenHandle);

    //
    // Free dynamic memory before returning
    //
    (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    return ntstatus;
}





NTSTATUS
RtlConvertToAutoInheritSecurityObject(
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This is a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    See further detailed description on ConvertToAutoInheritPrivateObjectSecurity.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.  (Only revision 2 ACLs are support by this routine.)

    STATUS_INVALID_ACL - The structure of one of the ACLs in invalid.



--*/
{

    //
    // Simply call the corresponding Rtlp routine telling it which allocator
    //  to use.
    //

    return RtlpConvertToAutoInheritSecurityObject(
                            ParentDescriptor,
                            CurrentSecurityDescriptor,
                            NewSecurityDescriptor,
                            ObjectType,
                            IsDirectoryObject,
                            GenericMapping );

}


NTSTATUS
RtlDefaultNpAcl(
    OUT PACL * pAcl
    )
/*++

Routine Description:

    This routine constructs a default ACL to be applied to
    named pipe objects when the caller has not specified one.
    See NT bug 131090.

    The ACL constructed is as follows:

    Need to build an ACL that looks like the following:

     Local System : F
     Administrators: F
     Owner: F
     Everyone: R
     Anonymous: R

     The owner is determined by querying the currently effective
     token and extracting the default owner.

Arguments:

    pAcl - Receives a pointer to an ACL to apply to the named pipe
        being created.  Guaranteed to be NULL on return if an error
        occurs.

        This must be freed by calling RtlFreeHeap.

Return Value:

    NT Status.

--*/
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority         = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;

    ULONG AclSize         = 0;
    NTSTATUS Status       = STATUS_SUCCESS;
    ULONG ReturnLength    = 0;
    PTOKEN_OWNER OwnerSid = NULL;

    HANDLE hToken;

    //
    // Initialize OUT parameters
    //

    *pAcl = NULL;

    //
    // Open thread token
    //

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &hToken
                 );

    if (STATUS_NO_TOKEN == Status) {

        //
        // Not impersonating, get process token
        //

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     &hToken
                     );
    }

    if (NT_SUCCESS( Status )) {

        //
        // Get the default owner
        //

        Status = NtQueryInformationToken (
                     hToken,
                     TokenOwner,
                     NULL,
                     0,
                     &ReturnLength
                     );

        if (STATUS_BUFFER_TOO_SMALL == Status) {

            OwnerSid = (PTOKEN_OWNER)RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );

            if (OwnerSid) {

                Status = NtQueryInformationToken (
                             hToken,
                             TokenOwner,
                             OwnerSid,
                             ReturnLength,
                             &ReturnLength
                             );

                if (NT_SUCCESS( Status )) {

                    //
                    // Compute the size needed
                    //

                    UCHAR SidBuffer[16];
                    ASSERT( 16 == RtlLengthRequiredSid( 2 ));

                    AclSize += RtlLengthRequiredSid( 1 );   // LocalSystem Sid
                    AclSize += RtlLengthRequiredSid( 2 );   // Administrators
                    AclSize += RtlLengthRequiredSid( 1 );   // Everyone (World)
                    AclSize += RtlLengthRequiredSid( 1 );   // Anonymous Logon Sid

                    AclSize += RtlLengthSid( OwnerSid->Owner );   // Owner

                    AclSize += sizeof( ACL );               // Header
                    AclSize += 5 * (sizeof( ACCESS_ALLOWED_ACE ) - sizeof( ULONG ));

                    //
                    // Allocate the Acl out of the local process heap
                    //

                    *pAcl = (PACL)RtlAllocateHeap( RtlProcessHeap(), 0, AclSize );

                    if (*pAcl != NULL) {

                        RtlCreateAcl( *pAcl, AclSize, ACL_REVISION );

                        //
                        // Create each SID in turn and copy the resultant ACE into
                        // the new ACL
                        //

                        //
                        // Local System - Generic All
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 1);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, (PSID)SidBuffer );

                        //
                        // Admins - Generic All
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 2);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
                        *(RtlSubAuthoritySid( SidBuffer, 1 )) = DOMAIN_ALIAS_RID_ADMINS;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, (PSID)SidBuffer );

                        //
                        // Owner - Generic All
                        //

                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, OwnerSid->Owner );

                        //
                        // World - Generic Read
                        //

                        RtlInitializeSid( SidBuffer, &WorldSidAuthority, 1 );
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_WORLD_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_READ, (PSID)SidBuffer );

                        //
                        // Anonymous Logon - Generic Read
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 1);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_ANONYMOUS_LOGON_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_READ, (PSID)SidBuffer );

                    } else {

                        Status = STATUS_NO_MEMORY;
                    }
                }

                RtlFreeHeap( RtlProcessHeap(), 0, OwnerSid );

            } else {

                Status = STATUS_NO_MEMORY;
            }
        }

        NtClose( hToken );
    }

    if (!NT_SUCCESS( Status )) {

        //
        // Something failed, clean up OUT
        // parameters.
        //

        if (*pAcl != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, *pAcl );
            *pAcl = NULL;
        }
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsctxactcpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsctxactcpp.cpp

Abstract:

    C++ wrapper source file for sxsctxact.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsctxact.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsctxact.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsctxact.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of context activation/deactivation

Author:

    Michael Grier (MGrier) 2/2/2000

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"

#if NT_SXS_PERF_COUNTERS_ENABLED
#if defined(_X86_)
__inline
ULONGLONG
RtlpGetCycleCount(void)
{
	__asm {
		RDTSC
	}
}
#else
__inline
ULONGLONG
RtlpGetCycleCount(void)
{
    return 0;
}
#endif // defined(_X86_)
#endif // NT_SXS_PERF_COUNTERS_ENABLED

// DWORD just so that in the debugger we don't have to guess the size...
ULONG RtlpCaptureActivationContextActivationStacks = 
#if DBG
    TRUE
#else
    FALSE
#endif
;


//
// APPCOMPAT: Setting this flag to TRUE indicates that we no longer allow
// skipping over "unactivated" (ie: multiple activation) context frames.
// The default action should be FALSE, which will let multiply-activated
// contexts slide by.
//
// WARNING: This allows app authors to be a little sleazy about their activate
// and deactivate pairs.
//
#if DBG
BOOLEAN RtlpNotAllowingMultipleActivation = FALSE;
#else
#define RtlpNotAllowingMultipleActivation FALSE
#endif

NTSTATUS
RtlpAllocateActivationContextStackFrame(
    IN ULONG Flags,
    PTEB Teb,
    OUT PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME *FrameOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    LIST_ENTRY *ple;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = NULL;
    ULONG i;
    EXCEPTION_RECORD ExceptionRecord;

    if (FrameOut != NULL)
        *FrameOut = NULL;

    ASSERT((Flags == 0) && (FrameOut != NULL) && (Teb != NULL));
    if ((Flags != 0) || (FrameOut == NULL) || (Teb == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    for (ple = Teb->ActivationContextStack.FrameListCache.Flink; ple != &Teb->ActivationContextStack.FrameListCache; ple = ple->Flink) {
        PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);

        // Someone trashed our framelist!
        ASSERT(FrameList->Magic == ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC);
        if (FrameList->Magic != ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = SXS_CORRUPTION_CODE_FRAMELIST;
            ExceptionRecord.ExceptionInformation[1] = SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Teb->ActivationContextStack.FrameListCache;
            ExceptionRecord.ExceptionInformation[3] = (ULONG_PTR) FrameList;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPTION;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
        }

        if (FrameList->FramesInUse != RTL_NUMBER_OF(FrameList->Frames)) {
            for (i=0; i<RTL_NUMBER_OF(FrameList->Frames); i++) {
                if (FrameList->Frames[i].Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST) {
                    ASSERT(FrameList->FramesInUse != NUMBER_OF(FrameList->Frames));
                    FrameList->FramesInUse++;
                    FrameList->NotFramesInUse = ~FrameList->FramesInUse;
                    Frame = &FrameList->Frames[i];
                    break;
                }
            }
        }

        if (Frame != NULL)
            break;
    }

    if (Frame == NULL) {
        // No space left; allocate a new framelist...
        PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = (PACTIVATION_CONTEXT_STACK_FRAMELIST)RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ACTIVATION_CONTEXT_STACK_FRAMELIST));

        if (FrameList == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        FrameList->Magic = ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC;
        FrameList->Flags = 0;

        for (i=0; i<RTL_NUMBER_OF(FrameList->Frames); i++) {
            FrameList->Frames[i].Frame.Previous = NULL;
            FrameList->Frames[i].Frame.ActivationContext = NULL;
            FrameList->Frames[i].Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST | RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED;
            FrameList->Frames[i].Cookie = 0;
        }

        Frame = &FrameList->Frames[0];

        FrameList->FramesInUse = 1;
        FrameList->NotFramesInUse = ~FrameList->FramesInUse;

        InsertHeadList(&Teb->ActivationContextStack.FrameListCache, &FrameList->Links);
    }

    ASSERT((Frame != NULL) && (Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST));

    Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED;
    *FrameOut = Frame;
    Status = STATUS_SUCCESS;

Exit:
    return Status;
}

VOID
RtlpFreeActivationContextStackFrame(
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    )
{
    LIST_ENTRY *ple = NULL;
    EXCEPTION_RECORD ExceptionRecord;
    PTEB Teb = NtCurrentTeb();

    ASSERT(Frame != NULL);
    if (Frame != NULL) {
        // If this assert fires, someone's trying to free an already freed frame.  Or someone's set the
        // "I'm on the free list" flag in the frame data.
        ASSERT(!(Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST));
        if (!(Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST)) {
            for (ple = Teb->ActivationContextStack.FrameListCache.Flink; ple != &Teb->ActivationContextStack.FrameListCache; ple = ple->Flink) {
                PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);

                ASSERT(FrameList->Magic == ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC);
                if (FrameList->Magic != ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC) {
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.NumberParameters = 4;
                    ExceptionRecord.ExceptionInformation[0] = SXS_CORRUPTION_CODE_FRAMELIST;
                    ExceptionRecord.ExceptionInformation[1] = SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC;
                    ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Teb->ActivationContextStack.FrameListCache;
                    ExceptionRecord.ExceptionInformation[3] = (ULONG_PTR) FrameList;
                    ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPTION;
                    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                    RtlRaiseException(&ExceptionRecord);
                }

                ASSERT(FrameList->NotFramesInUse == (ULONG) (~FrameList->FramesInUse));
                if (FrameList->NotFramesInUse != (ULONG) (~FrameList->FramesInUse)) {
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.NumberParameters = 4;
                    ExceptionRecord.ExceptionInformation[0] = SXS_CORRUPTION_CODE_FRAMELIST;
                    ExceptionRecord.ExceptionInformation[1] = SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT;
                    ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Teb->ActivationContextStack.FrameListCache;
                    ExceptionRecord.ExceptionInformation[3] = (ULONG_PTR) FrameList;
                    ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPTION;
                    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                    RtlRaiseException(&ExceptionRecord);
                }

                if ((Frame >= &FrameList->Frames[0]) &&
                    (Frame < &FrameList->Frames[RTL_NUMBER_OF(FrameList->Frames)])) {
                    // It's in this frame list; look for it!
                    ULONG i = (ULONG)(Frame - FrameList->Frames);

                    // If this assert fires, it means that the frame pointer passed in should have been a frame
                    // in this framelist, but it actually didn't point to any of the array entries exactly.
                    // Probably someone munged the pointer.
                    ASSERT(Frame == &FrameList->Frames[i]);

                    if ((Frame == &FrameList->Frames[i]) && (FrameList->FramesInUse > 0)) {
                        FrameList->FramesInUse--;
                        FrameList->NotFramesInUse = ~FrameList->FramesInUse;

                        Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST;

                        // These are allocated in reverse order - the youngest
                        // frames are at the head of the list, rather than the tail,
                        // to speed up activation/deactivation.  So, we have to walk from the
                        // current framelist toward the front of the list, freeing entries
                        // as necessary.
                        if (FrameList->FramesInUse == 0) {
                            // Keep an extra framelist allocated to avoid heap allocation thrashing.  Be good and check
                            // that the framelists don't have entries in use.
                            LIST_ENTRY *ple2 = ple->Blink;

                            while (ple2 != &Teb->ActivationContextStack.FrameListCache) {
                                PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList2 = CONTAINING_RECORD(ple2, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);
                                LIST_ENTRY *ple2_Blink = ple2->Blink;

                                ASSERT(FrameList->Magic == ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC);
                                ASSERT(FrameList->NotFramesInUse == (ULONG) (~FrameList->FramesInUse));

                                // This assert is saying that the in-use count for a framelist after the current one is not
                                // zero.  This shouldn't be able to happen; there should be at most 1 framelist after the
                                // current one and it should have no entries in use.  Probably this indicates heap
                                // corruption.
                                ASSERT(FrameList2->FramesInUse == 0);
                                if (FrameList2->FramesInUse == 0) {
                                    RemoveEntryList(ple2);
                                    RtlFreeHeap(RtlProcessHeap(), 0, FrameList2);
                                }
                                ple2 = ple2_Blink;
                            }
                        }
                    }

                    // No sense continuing the search on the list; we've found the one.
                    break;
                }
            }

            // If we ran off the end of the list, it must have been a bogus frame pointer.
            ASSERT(ple != &Teb->ActivationContextStack.FrameListCache);
        }
    }
}



#if !defined(INVALID_HANDLE_VALUE)
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif // !defined(INVALID_HANDLE_VALUE)

//
//  Define magic cookie values returned by RtlActivateActivationContext*() that
//  represent a failure to activate the requested context.  The notable thing
//  is that on deactivation via the cookie, we need to know whether to leave
//  querying disabled or whether to enable it, thus the two magic values.
//

// The top nibble of the cookie denotes its type: normal, default-pushed or failed
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL                        (1)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_DUPLICATE_ACTIVATION          (2)

#define ULONG_PTR_IZE(_x) ((ULONG_PTR) (_x))
#define ULONG_PTR_IZE_SHIFT_AND_MASK(_x, _shift, _mask) ((ULONG_PTR) ((ULONG_PTR_IZE((_x)) & (_mask)) << (_shift)))

//
//  We only use the lower 12 bits of the thread id, but that should be unique enough;
//  this is really for debugging aids; if your tests pass such that you're
//  erroneously passing activation context cookies between threads that happen to
//  match up in their lower 12 bits of their thread id, you're pretty darned
//  lucky.
//

#define CHAR_BITS 8

#define BIT_LENGTH(x) (sizeof(x) * CHAR_BITS)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH (4)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET (BIT_LENGTH(PVOID) - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH) - 1)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH ((BIT_LENGTH(PVOID) / 2) - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_OFFSET (ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH) - 1)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_LENGTH (BIT_LENGTH(PVOID) - (ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH + ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH))
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_OFFSET (0)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_LENGTH) - 1)

// Never try to use more than 32 bits for the TID field.
C_ASSERT(ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH <= BIT_LENGTH(ULONG));

#define MAKE_ACTIVATION_CONTEXT_ACTIVATION_COOKIE(_type, _teb, _code) \
    ((ULONG_PTR) ( \
        ULONG_PTR_IZE_SHIFT_AND_MASK((_type), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_MASK) | \
        ULONG_PTR_IZE_SHIFT_AND_MASK((HandleToUlong((_teb)->ClientId.UniqueThread)), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK) | \
        ULONG_PTR_IZE_SHIFT_AND_MASK((_code), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_MASK)))

#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD(_x, _fieldname) (ULONG_PTR_IZE((ULONG_PTR_IZE((_x)) >> ACTIVATION_CONTEXT_ACTIVATION_COOKIE_ ## _fieldname ## _BIT_OFFSET)) & ACTIVATION_CONTEXT_ACTIVATION_COOKIE_ ## _fieldname ## _BIT_MASK)

#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), TYPE)
#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), TID)
#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), CODE)

#define ACTIVATION_CONTEXT_TRUNCATED_TID_(_teb) (HandleToUlong((_teb)->ClientId.UniqueThread) & ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK)
#define ACTIVATION_CONTEXT_TRUNCATED_TID() ACTIVATION_CONTEXT_TRUNCATED_TID_(NtCurrentTeb())

PACTIVATION_CONTEXT
RtlpMapSpecialValuesToBuiltInActivationContexts(
    PACTIVATION_CONTEXT ActivationContext
    )
{
    if (ActivationContext == ACTCTX_EMPTY) {
        ActivationContext = const_cast<PACTIVATION_CONTEXT>(&RtlpTheEmptyActivationContext);
    }
    return ActivationContext;
}

// Disable FPO optimization so that captured call stacks are more complete
#if defined(_X86_)
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

NTSTATUS
NTAPI
RtlActivateActivationContext(
    ULONG Flags,
    PACTIVATION_CONTEXT ActivationContext,
    ULONG_PTR *CookieOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    ASSERT(Flags == 0);
    ASSERT(CookieOut != NULL);

    if (CookieOut != NULL)
        *CookieOut = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;

    if ((Flags != 0) || (CookieOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (!NT_SUCCESS(Status = RtlActivateActivationContextEx(
                0,
                NtCurrentTeb(),
                ActivationContext,
                CookieOut)))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlActivateActivationContextEx(
    ULONG Flags,
    PTEB Teb,
    PACTIVATION_CONTEXT ActivationContext,
    ULONG_PTR *Cookie
    )
{
#if NT_SXS_PERF_COUNTERS_ENABLED
	ULONGLONG InitialCycleCount = RtlpGetCycleCount();
#endif
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG_PTR NewCookie = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    ULONG CapturedFrameCount, CapturedFrameHash;

    ASSERT(Cookie != NULL);

    if (Cookie != NULL)
        *Cookie = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;

    ASSERT((Flags & ~(RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION)) == 0);
    ASSERT(Teb != NULL);
    ASSERT(ActivationContext != INVALID_HANDLE_VALUE);

    ActivationContext = RtlpMapSpecialValuesToBuiltInActivationContexts(ActivationContext);

    if (((Flags & ~(RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION)) != 0) ||
        (Teb == NULL) ||
        (ActivationContext == INVALID_HANDLE_VALUE) ||
        (Cookie == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpAllocateActivationContextStackFrame(0, Teb, &Frame);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED | RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED;

    if (Flags & RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION) {
        Frame->Frame.Flags |= RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE |
                              RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION;
        RtlAddRefActivationContext(ActivationContext);
    }

    if (RtlpCaptureActivationContextActivationStacks)
        CapturedFrameCount = RtlCaptureStackBackTrace(2, NUMBER_OF(Frame->ActivationStackBackTrace), Frame->ActivationStackBackTrace, &CapturedFrameHash);
    else
        CapturedFrameCount = 0;

    while (CapturedFrameCount < NUMBER_OF(Frame->ActivationStackBackTrace))
        Frame->ActivationStackBackTrace[CapturedFrameCount++] = NULL;

    Frame->Frame.Previous = Teb->ActivationContextStack.ActiveFrame;
    Frame->Frame.ActivationContext = ActivationContext;

    NewCookie = MAKE_ACTIVATION_CONTEXT_ACTIVATION_COOKIE(ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL, Teb, Teb->ActivationContextStack.NextCookieSequenceNumber);
    Teb->ActivationContextStack.NextCookieSequenceNumber++;
    Frame->Cookie = NewCookie;
    *Cookie = NewCookie;
    Teb->ActivationContextStack.ActiveFrame = &Frame->Frame;

    Status = STATUS_SUCCESS;

Exit:
#if NT_SXS_PERF_COUNTERS_ENABLED
    Teb->ActivationContextCounters.ActivationCycles += RtlpGetCycleCount() - InitialCycleCount;
	Teb->ActivationContextCounters.Activations++;
#endif // NT_SXS_PERF_COUNTERS_ENABLED

	return Status;
}

#if defined(_X86_)
#pragma optimize("", on)
#endif

VOID
NTAPI
RtlDeactivateActivationContext(
    ULONG Flags,
    ULONG_PTR Cookie
    )
{
#if NT_SXS_PERF_COUNTERS_ENABLED
	ULONGLONG InitialCycleCount = RtlpGetCycleCount();
#endif // NT_SXS_PERF_COUNTERS_ENABLED
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME UnwindEndFrame = NULL;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME HeapFrame = NULL;

    if ((Flags & ~(RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION)) != 0) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid flags 0x%08lx\n", __FUNCTION__, Flags);
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    // Fast exit
    if (Cookie == INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE)
        return;

    if (EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE(Cookie) != ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid cookie type 0x%08I64x\n", __FUNCTION__, Cookie);
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    if (EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID(Cookie) != ACTIVATION_CONTEXT_TRUNCATED_TID()) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid cookie tid 0x%08I64x - should be %08lx\n", __FUNCTION__, Cookie, ACTIVATION_CONTEXT_TRUNCATED_TID());
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    Frame = Teb->ActivationContextStack.ActiveFrame;
    // Do the "downcast", but don't use HeapFrame unless the RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED
    // flag is set...
    if (Frame != NULL) {
        HeapFrame = (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ? CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) : NULL;
    }

    RTL_SOFT_ASSERT((Frame != NULL) && (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) && (HeapFrame->Cookie == Cookie));

    if (Frame != NULL)
    {
        if (((Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) ||
            (HeapFrame->Cookie != Cookie))
        {
            ULONG InterveningFrameCount = 0;

            // The cookie wasn't current.  Let's see if we can figure out what frame it was for...

            PRTL_ACTIVATION_CONTEXT_STACK_FRAME CandidateFrame = Frame->Previous;
            PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME CandidateHeapFrame =
                (CandidateFrame != NULL) ?
                    (CandidateFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ?
                        CONTAINING_RECORD(CandidateFrame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) :
                        NULL :
                    NULL;

            while ((CandidateFrame != NULL) &&
                   ((CandidateHeapFrame == NULL) ||
                    (CandidateHeapFrame->Cookie != Cookie))) {
                InterveningFrameCount++;
                CandidateFrame = CandidateFrame->Previous;
                CandidateHeapFrame =
                    (CandidateFrame != NULL) ?
                        (CandidateFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ?
                            CONTAINING_RECORD(CandidateFrame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) :
                            NULL :
                        NULL;
            }

            RTL_SOFT_ASSERT(CandidateFrame != NULL);
            if (CandidateFrame == NULL) {
                RtlRaiseStatus(STATUS_SXS_INVALID_DEACTIVATION);
            } else {
                // Otherwise someone left some dirt around.

                EXCEPTION_RECORD ExceptionRecord;

                ExceptionRecord.ExceptionRecord = NULL;
                ExceptionRecord.NumberParameters = 3;
                ExceptionRecord.ExceptionInformation[0] = InterveningFrameCount;
                ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) CandidateFrame;
                ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) Teb->ActivationContextStack.ActiveFrame;
                ExceptionRecord.ExceptionCode = STATUS_SXS_EARLY_DEACTIVATION;
                ExceptionRecord.ExceptionFlags = 0; // this exception *is* continuable since we can actually put the activation stack into a reasonable state
                RtlRaiseException(&ExceptionRecord);

                // If they continue the exception, just do the unwinds.

                UnwindEndFrame = CandidateFrame->Previous;
            }
        } else {
            UnwindEndFrame = Frame->Previous;
        }

        do {
            PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Previous;

            // This is a weird one.  A no-deactivate frame is typically only used to propogate
            // active activation context state to a newly created thread.  As such, it'll always
            // be the topmost frame... thus how did we come to decide to deactivate it?

            ASSERTMSG(
                "Unwinding through a no-deactivate frame",
                !(Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE));

            if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION) {
                RtlReleaseActivationContext(Frame->ActivationContext);
            }

            if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) {
                RtlpFreeActivationContextStackFrame(CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame));
            }

            Frame = Previous;
        } while (Frame != UnwindEndFrame);

        Teb->ActivationContextStack.ActiveFrame = UnwindEndFrame;
    }

#if NT_SXS_PERF_COUNTERS_ENABLED
	Teb->ActivationContextCounters.DeactivationCycles += RtlpGetCycleCount() - InitialCycleCount;
	Teb->ActivationContextCounters.Deactivations++;
#endif
}

VOID
FASTCALL
RtlActivateActivationContextUnsafeFast(
    PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame,
    PACTIVATION_CONTEXT ActivationContext
    )
{
    const PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) NtCurrentTeb()->ActivationContextStack.ActiveFrame;
    EXCEPTION_RECORD ExceptionRecord;

    ASSERT(Frame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
    ASSERT(Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_BASIC));

    if (Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED))
    {
        Frame->Extra1 = (PVOID) (~((ULONG_PTR) ActiveFrame));
        Frame->Extra2 = (PVOID) (~((ULONG_PTR) ActivationContext));
        Frame->Extra3 = _ReturnAddress();
    }

    if (ActiveFrame != NULL) {
        ASSERT(
            (ActiveFrame->Flags &
                (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) == RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);
        if (
            ((ActiveFrame->Flags &
                (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) != RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED)) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
            ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) ActiveFrame;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) ActiveFrame;
            ExceptionRecord.ExceptionInformation[3] = ActiveFrame->Flags;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
            return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
        }

        if ((ActiveFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) {
            PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActiveFastFrame = CONTAINING_RECORD(ActiveFrame, RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame);

            ASSERT(ActiveFastFrame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
            ASSERT(ActiveFastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_BASIC));

            if (ActiveFastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED)) {
                ASSERT(ActiveFastFrame->Extra1 == (PVOID) (~((ULONG_PTR) ActiveFrame->Previous)));
                ASSERT(ActiveFastFrame->Extra2 == (PVOID) (~((ULONG_PTR) ActiveFrame->ActivationContext)));
            }
        }
    }

    Frame->Frame.Previous = NtCurrentTeb()->ActivationContextStack.ActiveFrame;
    Frame->Frame.ActivationContext = ActivationContext;
    Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED;

    if ((((ActiveFrame == NULL) && (ActivationContext == NULL)) ||
         ((ActiveFrame != NULL) && (ActiveFrame->ActivationContext == ActivationContext))) &&
        !RtlpNotAllowingMultipleActivation)
    {
        Frame->Frame.Flags |= RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED;
    }
    else
    {
        NtCurrentTeb()->ActivationContextStack.ActiveFrame = &Frame->Frame;
    }
}

VOID
FASTCALL
RtlDeactivateActivationContextUnsafeFast(
    PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    const PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame = NtCurrentTeb()->ActivationContextStack.ActiveFrame;

    ASSERT(Frame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
    ASSERT(Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_BASIC));

    ASSERT((Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED) == 0);
    if (Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED)
    {
        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.NumberParameters = 3;
        ExceptionRecord.ExceptionInformation[0] = 0;
        ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) &Frame->Frame;
        ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) NtCurrentTeb()->ActivationContextStack.ActiveFrame;
        ExceptionRecord.ExceptionCode = STATUS_SXS_MULTIPLE_DEACTIVATION;
        ExceptionRecord.ExceptionFlags = 0;
        RtlRaiseException(&ExceptionRecord);
        return; // in case someone is cute and continues the exception
    }

    ASSERT(Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);
    if ((Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED) == 0)
    {
        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.NumberParameters = 3;
        ExceptionRecord.ExceptionInformation[0] = 0;
        ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) &Frame->Frame;
        ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) NtCurrentTeb()->ActivationContextStack.ActiveFrame;
        ExceptionRecord.ExceptionCode = STATUS_SXS_INVALID_DEACTIVATION;
        ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE; // this exception is NOT continuable
        RtlRaiseException(&ExceptionRecord);
        return; // in case someone is cute and continues the exception
    }

    ASSERT(
        (Frame->Frame.Flags &
            (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED)) == RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);

    if (
        ((Frame->Frame.Flags &
            (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
             RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED)) != RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED)) {
        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.NumberParameters = 4;
        ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
        ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) ActiveFrame;
        ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Frame->Frame;
        ExceptionRecord.ExceptionInformation[3] = Frame->Frame.Flags;
        ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
        ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
        RtlRaiseException(&ExceptionRecord);
        return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
    }

    if (Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED))
    {
        ASSERT(Frame->Extra1 == (PVOID) (~((ULONG_PTR) Frame->Frame.Previous)));
        ASSERT(Frame->Extra2 == (PVOID) (~((ULONG_PTR) Frame->Frame.ActivationContext)));
        if ((Frame->Extra1 != (PVOID) (~((ULONG_PTR) Frame->Frame.Previous))) ||
            (Frame->Extra2 != (PVOID) (~((ULONG_PTR) Frame->Frame.ActivationContext)))) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
            ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) ActiveFrame;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Frame->Frame;
            ExceptionRecord.ExceptionInformation[3] = Frame->Frame.Flags;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
            return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
        }
    }

    if (ActiveFrame != NULL) {
        ASSERT(
            (ActiveFrame->Flags &
                (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) == RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);
        if (
            ((ActiveFrame->Flags &
                (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                 RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) != RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED)) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
            ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) ActiveFrame;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) ActiveFrame;
            ExceptionRecord.ExceptionInformation[3] = ActiveFrame->Flags;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
            return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
        }

        if ((ActiveFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) {
            PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActiveFastFrame = CONTAINING_RECORD(ActiveFrame, RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame);

            ASSERT(ActiveFastFrame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
            ASSERT(ActiveFastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_BASIC));

            if (ActiveFastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED)) {
                ASSERT(ActiveFastFrame->Extra1 == (PVOID) (~((ULONG_PTR) ActiveFrame->Previous)));
                ASSERT(ActiveFastFrame->Extra2 == (PVOID) (~((ULONG_PTR) ActiveFrame->ActivationContext)));

                if ((ActiveFastFrame->Extra1 != (PVOID) (~((ULONG_PTR) ActiveFrame->Previous))) ||
                    (ActiveFastFrame->Extra2 != (PVOID) (~((ULONG_PTR) ActiveFrame->ActivationContext)))) {
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.NumberParameters = 4;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
                    ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) ActiveFrame;
                    ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) ActiveFrame;
                    ExceptionRecord.ExceptionInformation[3] = ActiveFrame->Flags;
                    ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
                    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                    RtlRaiseException(&ExceptionRecord);
                    return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
                }
            }
        }
    }

    //
    // Was this "not really activated" above (AppCompat problem) from above?
    //
    if (Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)
    {
        // Nothing special to do
    }
    else
    {
        // Make sure that the deactivation matches.  If it does not (the exceptional
        // condition) we'll throw an exception to make people deal with their
        // coding errors.
        if (NtCurrentTeb()->ActivationContextStack.ActiveFrame != &Frame->Frame) 
        {
            ULONG InterveningFrameCount = 0;

            // What's the deal?  Look to see if we're further up the stack.
            // Actually, what we'll do is see if we can find our parent up the stack.
            // This will also handle the double-deactivation case and let us continue
            // nicely.

            PRTL_ACTIVATION_CONTEXT_STACK_FRAME SearchFrame = NtCurrentTeb()->ActivationContextStack.ActiveFrame;
            const PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Frame.Previous;

            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: %s() Active frame is not the frame being deactivated %p != %p\n",
                __FUNCTION__,
                NtCurrentTeb()->ActivationContextStack.ActiveFrame,
                &Frame->Frame);

            while ((SearchFrame != NULL) && (SearchFrame != Previous)) {
                // Validate the stack frame while we're here...
                ASSERT(
                    (SearchFrame->Flags &
                        (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) == RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);

                if (
                    ((SearchFrame->Flags &
                        (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) != RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED)) {
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.NumberParameters = 4;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
                    ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) SearchFrame;
                    ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Frame->Frame;
                    ExceptionRecord.ExceptionInformation[3] = SearchFrame->Flags;
                    ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
                    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                    RtlRaiseException(&ExceptionRecord);
                    return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
                }

                if ((SearchFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) {
                    PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME FastSearchFrame =
                        CONTAINING_RECORD(SearchFrame, RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame);
                    ASSERT(FastSearchFrame->Extra1 == (PVOID) (~((ULONG_PTR) SearchFrame->Previous)));
                    ASSERT(FastSearchFrame->Extra2 == (PVOID) (~((ULONG_PTR) SearchFrame->ActivationContext)));
                    if ((FastSearchFrame->Extra1 != (PVOID) (~((ULONG_PTR) SearchFrame->Previous))) ||
                        (FastSearchFrame->Extra2 != (PVOID) (~((ULONG_PTR) SearchFrame->ActivationContext)))) {
                        ExceptionRecord.ExceptionRecord = NULL;
                        ExceptionRecord.NumberParameters = 4;
                        ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
                        ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) SearchFrame;
                        ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Frame->Frame;
                        ExceptionRecord.ExceptionInformation[3] = SearchFrame->Flags;
                        ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
                        ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                        RtlRaiseException(&ExceptionRecord);
                        return; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
                    }
                }

                InterveningFrameCount++;
                SearchFrame = SearchFrame->Previous;
            }

            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 3;
            ExceptionRecord.ExceptionInformation[0] = InterveningFrameCount;
            ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) &Frame->Frame;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) NtCurrentTeb()->ActivationContextStack.ActiveFrame;

            if (SearchFrame != NULL) {
                // We're there.  That's actually good; it just probably means that a function that our caller called
                // activated an activation context and forgot to deactivate.  Throw the exception and if it's continued,
                // we're good to go.

                if (InterveningFrameCount == 0) {
                    // Wow, the frame-to-deactivate's previous is the active one.  It must be that the caller
                    // already deactivated and is now deactivating again.
                    ExceptionRecord.ExceptionCode = STATUS_SXS_MULTIPLE_DEACTIVATION;
                } else {
                    // Otherwise someone left some dirt around.
                    ExceptionRecord.ExceptionCode = STATUS_SXS_EARLY_DEACTIVATION;
                }

                ExceptionRecord.ExceptionFlags = 0; // this exception *is* continuable since we can actually put the activation stack into a reasonable state
            } else {
                // It wasn't there.  It's almost certainly the wrong thing to try to set this
                ExceptionRecord.ExceptionCode = STATUS_SXS_INVALID_DEACTIVATION;
                ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE; // this exception is NOT continuable
            }

            RtlRaiseException(&ExceptionRecord);
        }

        NtCurrentTeb()->ActivationContextStack.ActiveFrame = Frame->Frame.Previous;
    }

    Frame->Frame.Flags |= RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED;

    if (Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED))
        Frame->Extra4 = _ReturnAddress();
}

NTSTATUS
NTAPI
RtlGetActiveActivationContext(
    PACTIVATION_CONTEXT *ActivationContext
    )
{
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    EXCEPTION_RECORD ExceptionRecord;

    if (ActivationContext != NULL) {
        *ActivationContext = NULL;
    }
    else {
        return STATUS_INVALID_PARAMETER;
    }

    Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) NtCurrentTeb()->ActivationContextStack.ActiveFrame;

    if (Frame != NULL) {
        ASSERT(
            (Frame->Flags & (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED | RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED | RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) ==
            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED);
        if ((Frame->Flags & (RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED |
                             RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED |
                             RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED)) !=
            RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED) { 
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
            ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) Frame;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) Frame;
            ExceptionRecord.ExceptionInformation[3] = Frame->Flags;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
            return STATUS_INTERNAL_ERROR; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
        }

        if ((Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) {
            PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME FastFrame = CONTAINING_RECORD(Frame, RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame);

            ASSERT(FastFrame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
            ASSERT(FastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_BASIC));

            if (FastFrame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED)) {
                ASSERT(FastFrame->Extra1 == (PVOID) (~((ULONG_PTR) Frame->Previous)));
                ASSERT(FastFrame->Extra2 == (PVOID) (~((ULONG_PTR) Frame->ActivationContext)));

                if ((FastFrame->Extra1 != (PVOID) (~((ULONG_PTR) Frame->Previous))) ||
                    (FastFrame->Extra2 != (PVOID) (~((ULONG_PTR) Frame->ActivationContext)))) {
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.NumberParameters = 4;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR) &NtCurrentTeb()->ActivationContextStack;
                    ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) Frame;
                    ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) Frame;
                    ExceptionRecord.ExceptionInformation[3] = Frame->Flags;
                    ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPT_ACTIVATION_STACK;
                    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                    RtlRaiseException(&ExceptionRecord);
                    return STATUS_INTERNAL_ERROR; // shouldn't be able to happen with EXCEPTION_NONCONTINUABLE set
                }
            }
        }
        RtlAddRefActivationContext(Frame->ActivationContext);
        *ActivationContext = Frame->ActivationContext;
    }

    return STATUS_SUCCESS;
}

VOID
NTAPI
RtlFreeThreadActivationContextStack(
    VOID
    )
{
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = Teb->ActivationContextStack.ActiveFrame;
#if RTL_CATCH_PEOPLE_TWIDDLING_FRAMELISTS_OR_HEAP_CORRUPTION        
    EXCEPTION_RECORD ExceptionRecord;
#endif
    LIST_ENTRY *ple = NULL;

    while (Frame != NULL) {
        PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Previous;

        // Release any lingering frames.  The notable case when this happens is when a thread that
        // has a non-default activation context active creates another thread which inherits the
        // first thread's activation context, adding a reference to the activation context.  When
        // the new thread eventually dies, that initial frame is still active.

        if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION) {
            RtlReleaseActivationContext(Frame->ActivationContext);
        }

        if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) {
            RtlpFreeActivationContextStackFrame(CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame));
        }

        Frame = Previous;
    }

    Teb->ActivationContextStack.ActiveFrame = NULL;

    // Spin through the frame list cache and free any items left over.  There should be
    // only one, but who knows if the gc algorithm above will changes sometime.
    ple = Teb->ActivationContextStack.FrameListCache.Flink;
    
    while (ple != &Teb->ActivationContextStack.FrameListCache) {
        LIST_ENTRY *pleNext = ple->Flink;
        PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);

#if RTL_CATCH_PEOPLE_TWIDDLING_FRAMELISTS_OR_HEAP_CORRUPTION        
        // If these fire, then something bad happened to the frame list cache; the list
        // got its magic twiddled, there were frames left active in the list, or
        // the frames in use count wasn't properly updated
        ASSERT(FrameList->Magic == ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC);
        ASSERT(FrameList->FramesInUse == 0);
        ASSERT(FrameList->NotFramesInUse == (ULONG)~FrameList->FramesInUse);
        
        if (FrameList->Magic != ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = SXS_CORRUPTION_CODE_FRAMELIST;
            ExceptionRecord.ExceptionInformation[1] = SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Teb->ActivationContextStack.FrameListCache;
            ExceptionRecord.ExceptionInformation[3] = (ULONG_PTR) FrameList;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPTION;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
        }
        else if ((FrameList->FramesInUse > 0) || ((ULONG)~FrameList->FramesInUse != FrameList->NotFramesInUse)) {
            ExceptionRecord.ExceptionRecord = NULL;
            ExceptionRecord.NumberParameters = 4;
            ExceptionRecord.ExceptionInformation[0] = SXS_CORRUPTION_CODE_FRAMELIST;
            ExceptionRecord.ExceptionInformation[1] = SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT;
            ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) &Teb->ActivationContextStack.FrameListCache;
            ExceptionRecord.ExceptionInformation[3] = (ULONG_PTR) FrameList;
            ExceptionRecord.ExceptionCode = STATUS_SXS_CORRUPTION;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            RtlRaiseException(&ExceptionRecord);
        }
#endif

        RemoveEntryList(ple);
        ple = pleNext;
        
        RtlFreeHeap(RtlProcessHeap(), 0, FrameList);
    }

    ASSERT(IsListEmpty(&Teb->ActivationContextStack.FrameListCache));}

BOOLEAN
NTAPI
RtlIsActivationContextActive(
    PACTIVATION_CONTEXT ActivationContext
    )
{
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = Teb->ActivationContextStack.ActiveFrame;

    while (Frame != NULL) {
        if (Frame->ActivationContext == ActivationContext) {
            return TRUE;
        }

        Frame = Frame->Previous;
    }

    return FALSE;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsactctxcpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsactctxcpp.cpp

Abstract:

    C++ wrapper source file for sxsactctx.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsactctx.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsctxsrchcpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsctxsrchcpp.cpp

Abstract:

    C++ wrapper source file for sxsctxsrch.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsctxsrch.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsctxsrch.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsctxsrch.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of context stack searching

Author:

    Michael Grier (MGrier) 2/2/2000

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxsp.h>
#include <stdlib.h>

//#undef DBG_SXS
#define DBG_SXS 0
//#if DBG_SXS
//#undef DPFLTR_TRACE_LEVEL
//#undef DPFLTR_INFO_LEVEL
//#define DPFLTR_TRACE_LEVEL DPFLTR_ERROR_LEVEL
//#define DPFLTR_INFO_LEVEL DPFLTR_ERROR_LEVEL
//#endif

#define ARRAY_FITS(_base, _count, _elemtype, _limit) ((((ULONG) (_base)) < (_limit)) && ((((ULONG) ((_base) + ((_count) * (sizeof(_elemtype)))))) <= (_limit)))
#define SINGLETON_FITS(_base, _elemtype, _limit) ARRAY_FITS((_base), 1, _elemtype, (_limit))

//
// Comparison of unsigned numbers by subtraction does Not work!
//
#define RTLP_COMPARE_NUMBER(x, y) \
    (((x) < (y)) ? -1 : ((x) > (y)) ? +1 : 0)

int
__cdecl
RtlpCompareActivationContextDataTOCEntryById(
    CONST VOID* VoidElement1,
    CONST VOID* VoidElement2
    )
/*++
This code must kinda sorta mimic code in sxs.dll.
base\win32\fusion\dll\whistler\actctxgenctxctb.cpp
    CActivationContextGenerationContextContributor::Compare
But we handle extended sections differently.
--*/
{
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * Element1 = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)VoidElement1;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * Element2 = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)VoidElement2;

    return RTLP_COMPARE_NUMBER(Element1->Id, Element2->Id);
}

NTSTATUS
RtlpLocateActivationContextSection(
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN CONST GUID *ExtensionGuid,
    IN ULONG Id,
    OUT PCVOID *SectionData,
    OUT ULONG *SectionLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    const ACTIVATION_CONTEXT_DATA_TOC_HEADER UNALIGNED * TocHeader = NULL;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * TocEntries = NULL;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * TocEntry = NULL;
    ULONG i;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpLocateActivationContextSection() Id = %u\n", Id);
#endif

    if ((ActivationContextData->TotalSize < sizeof(ACTIVATION_CONTEXT_DATA)) ||
        (ActivationContextData->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA)))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: Activation context data at %p too small; TotalSize = %lu; HeaderSize = %lu\n",
            ActivationContextData,
            ActivationContextData->TotalSize,
            ActivationContextData->HeaderSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }
    
    if (ExtensionGuid != NULL)
    {
        if (ActivationContextData->ExtendedTocOffset != 0)
        {
            const ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER UNALIGNED * ExtHeader = NULL;
            const ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY UNALIGNED * ExtEntry = NULL;

            if (!SINGLETON_FITS(ActivationContextData->ExtendedTocOffset, ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER, ActivationContextData->TotalSize))
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS/RTL: Extended TOC offset (%ld) is outside bounds of activation context data (%lu bytes)\n",
                    ActivationContextData->ExtendedTocOffset, ActivationContextData->TotalSize);
                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            ExtHeader = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ActivationContextData->ExtendedTocOffset);

            if (!ARRAY_FITS(ExtHeader->FirstEntryOffset, ExtHeader->EntryCount, ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY, ActivationContextData->TotalSize))
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS/RTL: Extended TOC entry array (starting at offset %ld; count = %lu; entry size = %u) is outside bounds of activation context data (%lu bytes)\n",
                    ExtHeader->FirstEntryOffset,
                    ExtHeader->EntryCount,
                    sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY),
                    ActivationContextData->TotalSize);
                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            ExtEntry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((LONG_PTR) ActivationContextData) + ExtHeader->FirstEntryOffset);

            // No fancy searching for the extension; just a dumb linear search.
            for (i=0; i<ExtHeader->EntryCount; i++)
            {
                if (IsEqualGUID(ExtensionGuid, &ExtEntry[i].ExtensionGuid))
                {
                    if (!SINGLETON_FITS(ExtEntry[i].TocOffset, ACTIVATION_CONTEXT_DATA_TOC_HEADER, ActivationContextData->TotalSize))
                    {
                        DbgPrintEx(
                            DPFLTR_SXS_ID,
                            DPFLTR_ERROR_LEVEL,
                            "SXS/RTL: Extended TOC section TOC %d (offset: %ld, size: %u) is outside activation context data bounds (%lu bytes)\n",
                            i,
                            ExtEntry[i].TocOffset,
                            sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER),
                            ActivationContextData->TotalSize);
                        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                        goto Exit;
                    }

                    TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ExtEntry[i].TocOffset);
                    break;
                }
            }
        }
    }
    else if (ActivationContextData->DefaultTocOffset != 0)
    {
        TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ActivationContextData->DefaultTocOffset);
    }

    if ((TocHeader == NULL) || (TocHeader->EntryCount == 0))
    {
        Status = STATUS_SXS_SECTION_NOT_FOUND;
        goto Exit;
    }

    if (!ARRAY_FITS(TocHeader->FirstEntryOffset, TocHeader->EntryCount, ACTIVATION_CONTEXT_DATA_TOC_ENTRY, ActivationContextData->TotalSize))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: TOC entry array (offset: %ld; count = %lu; entry size = %u) is outside bounds of activation context data (%lu bytes)\n",
            TocHeader->FirstEntryOffset,
            TocHeader->EntryCount,
            sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY),
            ActivationContextData->TotalSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    TocEntries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((LONG_PTR) ActivationContextData) + TocHeader->FirstEntryOffset);

    if (TocHeader->Flags & ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER)
    {
#if DBG
        // Paranoia while we're writing the code to encode the data structure...
        ULONG j;

        for (j=1; j<TocHeader->EntryCount; j++)
            ASSERT(TocEntries[j-1].Id < TocEntries[j].Id);
#endif // DBG

        if (Id < TocEntries[0].Id)
        {
            Status = STATUS_SXS_SECTION_NOT_FOUND;
            goto Exit;
        }

        if (TocHeader->Flags & ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE)
        {
            const ULONG Index = Id - TocEntries[0].Id;

#if DBG
            ULONG jx;
            for (jx=1; jx<TocHeader->EntryCount; jx++)
                ASSERT((TocEntries[jx-1].Id + 1) == TocEntries[jx].Id);
#endif // DBG

            if (Index >= TocHeader->EntryCount)
            {
                Status = STATUS_SXS_SECTION_NOT_FOUND;
                goto Exit;
            }

            // The entries are dense and in order; we can just do an array index.
            TocEntry = &TocEntries[Index];
        }
        else
        {
            ACTIVATION_CONTEXT_DATA_TOC_ENTRY Key;

            Key.Id = Id;

            TocEntry = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)
                bsearch(
                    &Key,
                    TocEntries,
                    TocHeader->EntryCount,
                    sizeof(*TocEntries),
                    RtlpCompareActivationContextDataTOCEntryById
                    );
        }
    }
    else
    {
        // They're not in order; just do a linear search.
        for (i=0; i<TocHeader->EntryCount; i++)
        {
            if (TocEntries[i].Id == Id)
            {
                TocEntry = &TocEntries[i];
                break;
            }
        }
    }

    if ((TocEntry == NULL) || (TocEntry->Offset == 0))
    {
        Status = STATUS_SXS_SECTION_NOT_FOUND;
        goto Exit;
    }

    if (!SINGLETON_FITS(TocEntry->Offset, TocEntry->Length, ActivationContextData->TotalSize))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: Section found (offset %ld; length %lu) extends past end of activation context data (%lu bytes)\n",
            TocEntry->Offset,
            TocEntry->Length,
            ActivationContextData->TotalSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    *SectionData = (PVOID) (((LONG_PTR) ActivationContextData) + TocEntry->Offset);
    *SectionLength = TocEntry->Length;

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpLocateActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
RtlpFindNextActivationContextSection(
    PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PCVOID *SectionData,
    ULONG *SectionLength,
    PACTIVATION_CONTEXT *ActivationContextOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PACTIVATION_CONTEXT ActivationContextWeAreTrying = NULL;
    const PTEB Teb = NtCurrentTeb();
    const PPEB Peb = Teb->ProcessEnvironmentBlock;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpFindNextActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextOut != NULL)
        *ActivationContextOut = NULL;

    for (;;)
    {
        switch (Context->Depth)
        {
        case 0:
            // first time through; select the activation context at the head of the stack.
            if (Teb->ActivationContextStack.ActiveFrame != NULL) {
                PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = Teb->ActivationContextStack.ActiveFrame;

                ActivationContextWeAreTrying = Frame->ActivationContext;

                if ((ActivationContextWeAreTrying != NULL) &&
                    (ActivationContextWeAreTrying != ACTCTX_PROCESS_DEFAULT)) {
                    if (ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT) {
                        ActivationContextData = Peb->SystemDefaultActivationContextData;
                    } else {
                        ActivationContextData = ActivationContextWeAreTrying->ActivationContextData;
                    }

                }

                if (ActivationContextData != NULL) {
                    // We got what we were looking for...
                    Context->Depth = 1;
                    break;
                }

                // We explicitly fall through in the other case...
            }

        case 1: // try the process default
            ActivationContextWeAreTrying = (PACTIVATION_CONTEXT)ACTCTX_PROCESS_DEFAULT;
            ActivationContextData = Peb->ActivationContextData;

            if (ActivationContextData != NULL) {
                Context->Depth = 2;
                break;
            }

            // explicit fall through...

        case 2: // try system default
            ActivationContextWeAreTrying = (PACTIVATION_CONTEXT)ACTCTX_SYSTEM_DEFAULT;
            ActivationContextData = Peb->SystemDefaultActivationContextData;

            if (ActivationContextData != NULL) {
                Context->Depth = 3;
                break;
            }

        default:
            ASSERT(Context->Depth <= 3);
            if (Context->Depth > 3) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            break;
        }

        // Hmm... no data.
        if (ActivationContextData == NULL) {
            Status = STATUS_SXS_SECTION_NOT_FOUND;
            goto Exit;
        }

        Status = RtlpLocateActivationContextSection(
                        ActivationContextData,
                        Context->ExtensionGuid,
                        Context->Id,
                        SectionData,
                        SectionLength);

        if (NT_SUCCESS(Status))
            break;

        // If we're not at the end of the search list and we get an error other
        // than STATUS_SXS_SECTION_NOT_FOUND, report it.  If it is
        // STATUS_SXS_SECTION_NOT_FOUND and we're not at the end of the list,
        // iterate again.
        if ((Status != STATUS_SXS_SECTION_NOT_FOUND) ||
            (Context->Depth == 3))
             goto Exit;
    }

    Context->OutFlags = 
        ((ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT)
        ? FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT
        : 0)
        |
        ((ActivationContextWeAreTrying == ACTCTX_PROCESS_DEFAULT)
        ? FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT
        : 0)
        ;

    if (ActivationContextOut != NULL)
    {
        if (ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT)
        {
            // Hide this new value from old code that doesn't understand it.
            ActivationContextWeAreTrying = (PACTIVATION_CONTEXT)ACTCTX_PROCESS_DEFAULT;
        }
        *ActivationContextOut = ActivationContextWeAreTrying;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpFindNextActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindFirstActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PACTIVATION_CONTEXT ActivationContextTemp = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindFirstActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Context->Depth = 0;

    Status = RtlpFindNextActivationContextSection(Context, (PCVOID*)SectionData, SectionLength, &ActivationContextTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextFound != NULL)
    {
        RtlAddRefActivationContext(ActivationContextTemp);
        *ActivationContextFound = ActivationContextTemp;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindFirstActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
RtlpFindFirstActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered %s()\n", __FUNCTION__);
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Context->Depth = 0;

    Status = RtlpFindNextActivationContextSection(Context, (PCVOID*)SectionData, SectionLength, ActivationContextFound);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving %s() with NTSTATUS 0x%08lx\n", __FUNCTION__, Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindNextActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PACTIVATION_CONTEXT ActivationContextTemp = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindNextActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpFindNextActivationContextSection(
                    Context,
                    (PCVOID*)SectionData,
                    SectionLength,
                    &ActivationContextTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextFound != NULL) {
        RtlAddRefActivationContext(ActivationContextTemp);
        *ActivationContextFound = ActivationContextTemp;
    }

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindNextActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

VOID
NTAPI
RtlEndFindActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context
    )
{
    // We don't maintain any state, so nothing to do today.  Who knows what we might
    // do in the future however...
    UNREFERENCED_PARAMETER (Context);
}

NTSTATUS
RtlpFindActivationContextSection_FillOutReturnedData(
    IN ULONG                                    Flags,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA  ReturnedData,
    IN OUT PACTIVATION_CONTEXT                  ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION      Context,
    IN const VOID * UNALIGNED                   Header,
    IN ULONG                                    Header_UserDataOffset,
    IN ULONG                                    Header_UserDataSize,
    IN ULONG                                    SectionLength
    )
{
    NTSTATUS Status;
    PCACTIVATION_CONTEXT_DATA                           ActivationContextData;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER    AssemblyRosterHeader;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY     AssemblyRosterEntryList;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION      AssemblyDataInfo;

#if DBG
    Status = STATUS_INTERNAL_ERROR;
#if !defined(INVALID_HANDLE_VALUE)
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif
    ActivationContextData =     (PCACTIVATION_CONTEXT_DATA)INVALID_HANDLE_VALUE;
    AssemblyRosterHeader =      (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)INVALID_HANDLE_VALUE;
    AssemblyRosterEntryList =   (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)INVALID_HANDLE_VALUE;
    AssemblyDataInfo =          (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)INVALID_HANDLE_VALUE;
#endif

    if (Context == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Header == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (ReturnedData == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (Header_UserDataOffset != 0) {
        ReturnedData->SectionGlobalData = (PVOID) (((ULONG_PTR) Header) + Header_UserDataOffset);
        ReturnedData->SectionGlobalDataLength = Header_UserDataSize;
    }

    ReturnedData->SectionBase = (PVOID)Header;
    ReturnedData->SectionTotalLength = SectionLength;

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT) {

        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, ActivationContext));

        RtlAddRefActivationContext(ActivationContext);
        ReturnedData->ActivationContext = ActivationContext;
    }

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS) {

        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, Flags));

        ReturnedData->Flags =
            ((Context->OutFlags & FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT)
            ? ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT
            : 0)
            |
            ((Context->OutFlags & FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT)
            ? ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT
            : 0)
            ;
    }

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA) {

        typedef ACTIVATION_CONTEXT_SECTION_KEYED_DATA RETURNED_DATA;

        PCACTIVATION_CONTEXT_STRING_SECTION_HEADER AssemblyMetadataStringSectionHeader;
        PCVOID AssemblyMetadataSectionBase;
        ULONG AssemblyMetadataSectionLength;
        ULONG AssemblyRosterIndex;

#if DBG
        AssemblyRosterIndex =       ~0UL;
        AssemblyMetadataStringSectionHeader = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER)INVALID_HANDLE_VALUE;
        AssemblyMetadataSectionBase = (PVOID)INVALID_HANDLE_VALUE;
        AssemblyMetadataSectionLength = ~0UL;
#endif


        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, AssemblyMetadata));

        Status = RtlpGetActivationContextData(
                0,
                ActivationContext,
                Context, /* for its flags */
                &ActivationContextData
                );
        if (!NT_SUCCESS(Status))
            goto Exit;

        if (!RTL_VERIFY(ActivationContextData != NULL)) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        AssemblyRosterIndex = ReturnedData->AssemblyRosterIndex;
        ASSERT(AssemblyRosterIndex >= 1);

        AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
        ASSERT(AssemblyRosterIndex < AssemblyRosterHeader->EntryCount);

        AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);
        AssemblyDataInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)((ULONG_PTR)ActivationContextData + AssemblyRosterEntryList[AssemblyRosterIndex].AssemblyInformationOffset);

        ReturnedData->AssemblyMetadata.Information = RTL_CONST_CAST(PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)(AssemblyDataInfo);

        Status =
            RtlpLocateActivationContextSection(
                ActivationContextData,
                NULL, // ExtensionGuid
                ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
                &AssemblyMetadataSectionBase,
                &AssemblyMetadataSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;

        ReturnedData->AssemblyMetadata.SectionBase = (PVOID)AssemblyMetadataSectionBase;
        ReturnedData->AssemblyMetadata.SectionLength = AssemblyMetadataSectionLength;

        if (AssemblyMetadataSectionBase != NULL
            && AssemblyMetadataSectionLength != 0) {

            ULONG HeaderSize;
            ULONG Magic;

            AssemblyMetadataStringSectionHeader = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER)(((ULONG_PTR)AssemblyMetadataSectionBase) + AssemblyMetadataSectionLength);

            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, AssemblyMetadataSectionLength, Magic)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, AssemblyMetadataSectionLength, HeaderSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            Magic = AssemblyMetadataStringSectionHeader->Magic;
            if (AssemblyMetadataStringSectionHeader->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            HeaderSize = AssemblyMetadataStringSectionHeader->HeaderSize;
            if (HeaderSize > AssemblyMetadataSectionLength) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (AssemblyMetadataSectionLength < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (HeaderSize < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, Magic)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, HeaderSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, UserDataOffset)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, UserDataSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            ReturnedData->AssemblyMetadata.SectionGlobalDataBase = (PVOID)(((ULONG_PTR)AssemblyMetadataStringSectionHeader) + AssemblyMetadataStringSectionHeader->UserDataOffset);
            ReturnedData->AssemblyMetadata.SectionGlobalDataLength = AssemblyMetadataStringSectionHeader->UserDataSize;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpFindActivationContextSection_CheckParameters(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN PCVOID ThingToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    UNREFERENCED_PARAMETER(ExtensionGuid);
    UNREFERENCED_PARAMETER(SectionId);

    if ((ThingToFind == NULL) ||
            ((Flags & ~(
                FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                )) != 0) ||
            (((Flags & (
                FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                )) != 0) &&
            (ReturnedData == NULL)) ||
            ((ReturnedData != NULL) &&
             (ReturnedData->Size < (FIELD_OFFSET(ACTIVATION_CONTEXT_SECTION_KEYED_DATA, ActivationContext) + sizeof(ReturnedData->ActivationContext)))
             )) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS) != 0
        && !RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, Flags)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() flags contains return_flags but they don't fit in size, return invalid_parameter 0x%08lx.\n", __FUNCTION__, STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA) != 0
        && !RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, AssemblyMetadata)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() flags contains return_assembly_metadata but they don't fit in size, return invalid_parameter 0x%08lx.\n", __FUNCTION__, STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindActivationContextSectionString() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindActivationContextSectionString(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN PCUNICODE_STRING StringToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    FINDFIRSTACTIVATIONCONTEXTSECTION Context;
    const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header;
    ULONG StringSectionLength;
    BOOLEAN EndSearch;
    ULONG HashAlgorithm;
    ULONG PseudoKey;
    PACTIVATION_CONTEXT ActivationContext;
#if DBG_SXS
    CHAR ExtensionGuidBuffer[39];
#endif
    const PTEB Teb = NtCurrentTeb();
    const PPEB Peb = Teb->ProcessEnvironmentBlock;

    // Super short circuit...
    if ((Peb->ActivationContextData == NULL) &&
        (Peb->SystemDefaultActivationContextData == NULL) &&
        (Teb->ActivationContextStack.ActiveFrame == NULL))
        return STATUS_SXS_SECTION_NOT_FOUND;

    // Move variable initialization after the short-circuiting so that we truly
    // do the least amount of work possible prior to the early exit.
    StringSectionLength = 0;
    EndSearch = FALSE;
    HashAlgorithm = HASH_STRING_ALGORITHM_INVALID;
    PseudoKey = 0;
    ActivationContext = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindActivationContextSectionString()\n"
        "   Flags = 0x%08lx\n"
        "   ExtensionGuid = %s\n"
        "   SectionId = %lu\n"
        "   StringToFind = %wZ\n"
        "   ReturnedData = %p\n",
        Flags,
        RtlpFormatGuidANSI(ExtensionGuid, ExtensionGuidBuffer, sizeof(ExtensionGuidBuffer)),
        SectionId,
        StringToFind,
        ReturnedData);
#endif // DBG_SXS

    Status = RtlpFindActivationContextSection_CheckParameters(Flags, ExtensionGuid, SectionId, StringToFind, ReturnedData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Context.Size = sizeof(Context);
    Context.Flags = Flags;
    Context.OutFlags = 0;
    Context.ExtensionGuid = ExtensionGuid;
    Context.Id = SectionId;

    Status = RtlpFindFirstActivationContextSection(&Context, (PVOID *) &Header, &StringSectionLength, &ActivationContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    for (;;) {
        // Validate that this actually looks like a string section...
        if ((StringSectionLength < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) ||
            (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "RtlFindActivationContextSectionString() found section at %p (length %lu) which is not a string section\n",
                Header,
                StringSectionLength);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        Status = RtlpFindUnicodeStringInSection(
                        Header,
                        StringSectionLength,
                        StringToFind,
                        ReturnedData,
                        &HashAlgorithm,
                        &PseudoKey,
                        NULL,
                        NULL);
        if (NT_SUCCESS(Status))
            break;

        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        Status = RtlFindNextActivationContextSection(&Context, (PVOID *) &Header, &StringSectionLength, &ActivationContext);
        if (!NT_SUCCESS(Status)) {
            // Convert from section not found to string not found so that the
            // caller can get an indication that at least some indirection
            // information was available but just not the particular key that
            // they're looking for.
            if (Status == STATUS_SXS_SECTION_NOT_FOUND)
                Status = STATUS_SXS_KEY_NOT_FOUND;

            goto Exit;
        }
    }

    SEND_ACTIVATION_CONTEXT_NOTIFICATION(ActivationContext, USED, NULL);

    if (ReturnedData != NULL) {
        Status =
            RtlpFindActivationContextSection_FillOutReturnedData(
                Flags,
                ReturnedData,
                ActivationContext,
                &Context,
                Header,
                Header->UserDataOffset,
                Header->UserDataSize,
                StringSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindActivationContextSectionString() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

int
__cdecl
RtlpCompareActivationContextStringSectionEntryByPseudoKey(
    const void *elem1, 
    const void *elem2
    )
/*++
This code must mimic code in sxs.dll
(base\win32\fusion\dll\whistler\ssgenctx.cpp CSSGenCtx::CompareStringSectionEntries)
--*/
{
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * pEntry1 =
        (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)elem1;
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * pEntry2 =
        (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)elem2;

    return RTLP_COMPARE_NUMBER(pEntry1->PseudoKey, pEntry2->PseudoKey);
}

NTSTATUS
RtlpFindUnicodeStringInSection(
    const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header,
    SIZE_T SectionSize,
    PCUNICODE_STRING String,
    PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut,
    PULONG HashAlgorithm,
    PULONG PseudoKey,
    PULONG UserDataSize,
    PCVOID *UserData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN CaseInsensitiveFlag;
    BOOLEAN UseHashTable = TRUE;
    BOOLEAN UsePseudoKey = TRUE;
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * Entry = NULL;

    if (Header->Flags & ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE) {
        CaseInsensitiveFlag = TRUE;
    }
    else {
        CaseInsensitiveFlag = FALSE;
    }

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpFindUnicodeStringInSection() for string %p (->Length = %u; ->Buffer = %p) \"%wZ\"\n",
            String,
            (String != NULL) ? String->Length : 0,
            (String != NULL) ? String->Buffer : 0,
            String);
#endif // DBG_SXS

    if (UserDataSize != NULL)
        *UserDataSize = 0;

    if (UserData != NULL)
        *UserData = NULL;

    ASSERT(HashAlgorithm != NULL);
    ASSERT(PseudoKey != NULL);

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC)
    {
#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "RtlpFindUnicodeStringInSection: String section header has invalid .Magic value.\n");
#endif
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Eliminate the zero element case to make later code simpler.
    if (Header->ElementCount == 0)
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (Header->HashAlgorithm == HASH_STRING_ALGORITHM_INVALID)
    {
        UseHashTable = FALSE;
        UsePseudoKey = FALSE;
    }
    else if (*HashAlgorithm != Header->HashAlgorithm)
    {
        Status = RtlHashUnicodeString(String, CaseInsensitiveFlag, Header->HashAlgorithm, PseudoKey);
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_INVALID_PARAMETER)
            {
                ULONG TempPseudoKey = 0;

                // The only likely reason for invalid parameter is that the hash algorithm
                // wasn't understood.  We'll be pedantic and see if everything else is OK...
                Status = RtlHashUnicodeString(String, CaseInsensitiveFlag, HASH_STRING_ALGORITHM_DEFAULT, &TempPseudoKey);
                if (!NT_SUCCESS(Status))
                {
                    // Something's wrong, probably with the "String" parameter.  Punt.
                    goto Exit;
                }

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "RtlpFindUnicodeStringInSection: Unsupported hash algorithm %lu found in string section.\n",
                    Header->HashAlgorithm);

                // Ok, it's an algorithm ID that we don't understand.  We can't use the hash
                // table or the pseudokey.
                UseHashTable = FALSE;
                UsePseudoKey = FALSE;
            }
            else
                goto Exit;
        }
        else
        {
            // Record the hash algorithm we used so that we can avoid re-hashing if we have
            // to search another section.
            *HashAlgorithm = Header->HashAlgorithm;
        }
    }

    // If we don't understand the format version, we have to do the manual search.
    if (Header->FormatVersion != ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER)
        UseHashTable = FALSE;

    // If there's no hash table, we can't use it!
    if (Header->SearchStructureOffset == 0)
        UseHashTable = FALSE;

    if (UseHashTable)
    {
        ULONG i;

        const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE UNALIGNED * Table = (const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE UNALIGNED *)
            (((LONG_PTR) Header) + Header->SearchStructureOffset);
        ULONG Index = ((*PseudoKey) % Table->BucketTableEntryCount);
        const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET UNALIGNED * Bucket = ((const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET UNALIGNED *)
            (((LONG_PTR) Header) + Table->BucketTableOffset)) + Index;
        const LONG UNALIGNED *Chain = (const LONG UNALIGNED *) (((LONG_PTR) Header) + Bucket->ChainOffset);

        for (i=0; i<Bucket->ChainCount; i++)
        {
            const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *TmpEntry = NULL;
            UNICODE_STRING TmpEntryString;

            if (((SIZE_T) Chain[i]) > SectionSize)
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: String hash collision chain offset at %p (= %ld) out of bounds\n", &Chain[i], Chain[i]);

                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            TmpEntry = (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *) (((LONG_PTR) Header) + Chain[i]);

#if DBG_SXS
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_INFO_LEVEL,
                "SXS: Searching bucket collision %d; Chain[%d] = %ld\n"
                "   TmpEntry = %p; ->KeyLength = %lu; ->KeyOffset = %lu\n",
                i, i, Chain[i], TmpEntry, TmpEntry->KeyLength, TmpEntry->KeyOffset);
#endif DBG_SXS

            if (!UsePseudoKey || (TmpEntry->PseudoKey == *PseudoKey))
            {
                if (((SIZE_T) TmpEntry->KeyOffset) > SectionSize)
                {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: String hash table entry at %p has invalid key offset (= %ld)\n"
                        "   Header = %p; Index = %lu; Bucket = %p; Chain = %p\n",
                        TmpEntry, TmpEntry->KeyOffset, Header, Index, Bucket, Chain);

                    Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                    goto Exit;
                }

                TmpEntryString.Length = (USHORT) TmpEntry->KeyLength;
                TmpEntryString.MaximumLength = TmpEntryString.Length;
                TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + TmpEntry->KeyOffset);

                if (RtlCompareUnicodeString(String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                {
                    Entry = TmpEntry;
                    break;
                }
            }
        }
    }
    else if (UsePseudoKey && ((Header->Flags & ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER) != 0))
    {
	    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * const first = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);

        const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * const last = first + (Header->ElementCount - 1);

        ACTIVATION_CONTEXT_STRING_SECTION_ENTRY Key;

        Key.PseudoKey = *PseudoKey;

        Entry = (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)
            bsearch(
                &Key,
                first,
                Header->ElementCount,
                sizeof(*first),
                RtlpCompareActivationContextStringSectionEntryByPseudoKey
                );
     
        if (Entry != NULL)
        {
            // Wow, we found the same pseudokey.  We need to search all the equal
            // pseudokeys, so back off to the first entry with this PK

            while ((Entry != first) && (Entry->PseudoKey == *PseudoKey))
                Entry--;

            // We may have stopped because we found a different pseudokey, or we may
            // have stopped because we hit the beginning of the list.  If we found a
            // different PK, move ahead one entry.
            if (Entry->PseudoKey != *PseudoKey)
                Entry++;

            do
            {
                UNICODE_STRING TmpEntryString;
                TmpEntryString.Length = (USHORT) Entry->KeyLength;
                TmpEntryString.MaximumLength = TmpEntryString.Length;
                TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + Entry->KeyOffset);

                if (RtlCompareUnicodeString(String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                    break;
                Entry++;
            } while ((Entry <= last) && (Entry->PseudoKey == *PseudoKey));

            if ((Entry > last) || (Entry->PseudoKey != *PseudoKey))
                Entry = NULL;
        }
    }
    else
    {
        // Argh; we just have to do it the hard way.
        const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * TmpEntry = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);
        ULONG Count;

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            "RtlpFindUnicodeStringInSection: About to do linear search of %d entries.\n", Header->ElementCount);
#endif // DBG_SXS

        for (Count = Header->ElementCount; Count != 0; Count--, TmpEntry++)
        {
            UNICODE_STRING TmpEntryString;

            TmpEntryString.Length = (USHORT) TmpEntry->KeyLength;
            TmpEntryString.MaximumLength = TmpEntryString.Length;
            TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + TmpEntry->KeyOffset);

            if (!UsePseudoKey || (TmpEntry->PseudoKey == *PseudoKey))
            {
                if (RtlCompareUnicodeString(String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                {
                    Entry = TmpEntry;
                    break;
                }
            }
        }
    }

    if ((Entry == NULL) || (Entry->Offset == 0))
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (DataOut != NULL) {
        DataOut->DataFormatVersion = Header->DataFormatVersion;
        DataOut->Data = (PVOID) (((ULONG_PTR) Header) + Entry->Offset);
        DataOut->Length = Entry->Length;

        if (RTL_CONTAINS_FIELD(DataOut, DataOut->Size, AssemblyRosterIndex))
            DataOut->AssemblyRosterIndex = Entry->AssemblyRosterIndex;
    }

    if (UserDataSize != NULL)
        *UserDataSize = Header->UserDataSize;

    if ((UserData != NULL) && (Header->UserDataOffset != 0))
        *UserData = (PCVOID) (((ULONG_PTR) Header) + Header->UserDataOffset);

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpFindUnicodeStringInSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindActivationContextSectionGuid(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN const GUID *GuidToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData
    )
{
    NTSTATUS Status;
    FINDFIRSTACTIVATIONCONTEXTSECTION Context;
    const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED *Header;
    ULONG GuidSectionLength;
    BOOLEAN EndSearch;
    PACTIVATION_CONTEXT ActivationContext;
#if DBG
    CHAR GuidBuffer[39];
    CHAR ExtensionGuidBuffer[39];
    BOOLEAN DbgPrintSxsTraceLevel;
#endif
    PTEB Teb = NtCurrentTeb();
    PPEB Peb = Teb->ProcessEnvironmentBlock;

    // Super short circuit...
    if ((Peb->ActivationContextData == NULL) &&
        (Peb->SystemDefaultActivationContextData == NULL) &&
        (Teb->ActivationContextStack.ActiveFrame == NULL)) {

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            __FUNCTION__"({%s}) super short circuited\n",
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer));
            );
#endif
        return STATUS_SXS_SECTION_NOT_FOUND;
    }

    // Perform initialization after the above test so that we really do the minimal amount of
    // work before bailing out when there's no side-by-side stuff going on in either the
    // process or thread.
    Status = STATUS_INTERNAL_ERROR;
    GuidSectionLength = 0;
    EndSearch = FALSE;
    ActivationContext = NULL;

#if DBG
    //
    // Comparison to TRUE is odd, but such is NtQueryDebugFilterState.
    //
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE) {
        DbgPrintSxsTraceLevel = TRUE;
    }
    else {
        DbgPrintSxsTraceLevel = FALSE;
    }

    if (DbgPrintSxsTraceLevel) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "Entered RtlFindActivationContextSectionGuid()\n"
            "   Flags = 0x%08lx\n"
            "   ExtensionGuid = %s\n"
            "   SectionId = %lu\n"
            "   GuidToFind = %s\n"
            "   ReturnedData = %p\n",
            Flags,
            RtlpFormatGuidANSI(ExtensionGuid, ExtensionGuidBuffer, sizeof(ExtensionGuidBuffer)),
            SectionId,
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer)),
            ReturnedData);
    }
#endif

    Status = RtlpFindActivationContextSection_CheckParameters(Flags, ExtensionGuid, SectionId, GuidToFind, ReturnedData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Context.Size = sizeof(Context);
    Context.Flags = 0;
    Context.ExtensionGuid = ExtensionGuid;
    Context.Id = SectionId;
    Context.OutFlags = 0;

    Status = RtlpFindFirstActivationContextSection(&Context, (PVOID *) &Header, &GuidSectionLength, &ActivationContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    for (;;) {
        // Validate that this actually looks like a guid section...
        if ((GuidSectionLength < sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER)) ||
            (Header->Magic != ACTIVATION_CONTEXT_GUID_SECTION_MAGIC)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "RtlFindActivationContextSectionGuid() found section at %p (length %lu) which is not a GUID section\n",
                Header,
                GuidSectionLength);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        Status = RtlpFindGuidInSection(
                        Header,
                        GuidToFind,
                        ReturnedData);
        if (NT_SUCCESS(Status))
            break;

        // If we failed for any reason other than not finding the key in the section, bail out.
        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        Status = RtlpFindNextActivationContextSection(&Context, (PCVOID *) &Header, &GuidSectionLength, &ActivationContext);
        if (!NT_SUCCESS(Status)) {
            // Convert from section not found to key not found so that the
            // caller can get an indication that at least some indirection
            // information was available but just not the particular key that
            // they're looking for.
            if (Status == STATUS_SXS_SECTION_NOT_FOUND)
                Status = STATUS_SXS_KEY_NOT_FOUND;

            goto Exit;
        }
    }

    SEND_ACTIVATION_CONTEXT_NOTIFICATION(ActivationContext, USED, NULL);

    if (ReturnedData != NULL) {
        Status =
            RtlpFindActivationContextSection_FillOutReturnedData(
                Flags,
                ReturnedData,
                ActivationContext,
                &Context,
                Header,
                Header->UserDataOffset,
                Header->UserDataSize,
                GuidSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    if (DbgPrintSxsTraceLevel) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "Leaving "__FUNCTION__"(%s) with NTSTATUS 0x%08lx\n",
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer)),
            Status);
    }
#endif

    return Status;
}

int
__cdecl
RtlpCompareActivationContextGuidSectionEntryByGuid(
    const void *elem1, 
    const void *elem2
    )
/*++
This code must mimic code in sxs.dll
(base\win32\fusion\dll\whistler\gsgenctx.cpp CGSGenCtx::SortGuidSectionEntries)
--*/
{
    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * pLeft =
            (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY*)elem1;

    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * pRight =
        (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY*)elem2;

    return memcmp( &pLeft->Guid, &pRight->Guid, sizeof(GUID) );
}

NTSTATUS
RtlpFindGuidInSection(
    const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED *Header,
    const GUID *Guid,
    PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN UseHashTable = TRUE;
    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *Entry = NULL;

#if DBG_SXS
    CHAR GuidBuffer[39];

    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered "__FUNCTION__"({%s})\n",
        RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer))
        );
#endif

    if (Header->Magic != ACTIVATION_CONTEXT_GUID_SECTION_MAGIC)
    {
#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "RtlpFindGuidInSection: Guid section header has invalid .Magic value.\n");
#endif
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Eliminate the zero element case to make later code simpler.
    if (Header->ElementCount == 0)
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    // If we don't understand the format version, we have to do the manual search.
    if (Header->FormatVersion != ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER)
        UseHashTable = FALSE;

    // If there's no hash table, we can't use it!
    if (Header->SearchStructureOffset == 0)
        UseHashTable = FALSE;

    if (UseHashTable)
    {
        ULONG i;

        const ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE UNALIGNED *Table = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE)
            (((LONG_PTR) Header) + Header->SearchStructureOffset);
        ULONG Index = ((Guid->Data1) % Table->BucketTableEntryCount);
        const ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET UNALIGNED *Bucket = ((PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET)
            (((LONG_PTR) Header) + Table->BucketTableOffset)) + Index;
        const ULONG UNALIGNED *Chain = (PULONG) (((LONG_PTR) Header) + Bucket->ChainOffset);

        for (i=0; i<Bucket->ChainCount; i++)
        {
            const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * TmpEntry = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY)
                (((LONG_PTR) Header) + *Chain++);

            if (RtlCompareMemory(&TmpEntry->Guid, Guid, sizeof(GUID)) == sizeof(GUID))
            {
                Entry = TmpEntry;
                break;
            }
        }
    }
    else if ((Header->Flags & ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER) != 0)
    {
	    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * const first = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);

        ACTIVATION_CONTEXT_GUID_SECTION_ENTRY Key;

        Key.Guid = *Guid;

        Entry = (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *)
            bsearch(
                &Key,
                first,
                Header->ElementCount,
                sizeof(*first),
                RtlpCompareActivationContextGuidSectionEntryByGuid
                );
    }
    else
    {
        // Argh; we just have to do it the hard way.
        const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * TmpEntry = (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *)
            (((LONG_PTR) Header) + Header->ElementListOffset);
        ULONG Count;

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            __FUNCTION__"({%s}): About to do linear search of %d entries.\n",
            RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer)),
            Header->ElementCount);
#endif // DBG_SXS

        for (Count = Header->ElementCount; Count != 0; Count--, TmpEntry++) {
            if (RtlCompareMemory(&TmpEntry->Guid, Guid, sizeof(GUID)) == sizeof(GUID)) {
                Entry = TmpEntry;
                break;
            }
        }
    }

    if ((Entry == NULL) || (Entry->Offset == 0)) {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (DataOut != NULL) {
        DataOut->DataFormatVersion = Header->DataFormatVersion;
        DataOut->Data = (PVOID) (((ULONG_PTR) Header) + Entry->Offset);
        DataOut->Length = Entry->Length;

        if (RTL_CONTAINS_FIELD(DataOut, DataOut->Size, AssemblyRosterIndex))
            DataOut->AssemblyRosterIndex = Entry->AssemblyRosterIndex;
    }

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving "__FUNCTION__"({%s}) with NTSTATUS 0x%08lx\n",
        RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer)),
        Status);
#endif // DBG_SXS

    return Status;
}

#define tohexdigit(_x) ((CHAR) (((_x) < 10) ? ((_x) + '0') : ((_x) + 'A' - 10)))

PSTR
RtlpFormatGuidANSI(
    const GUID *Guid,
    PSTR Buffer,
    SIZE_T BufferLength
    )
{
    CHAR *pch = Buffer;

    ASSERT(BufferLength > 38);
    if (BufferLength <= 38)
    {
        return "<GUID buffer too small>";
    }

    if (Guid == NULL)
        return "<null>";

    pch = Buffer;

    *pch++ = '{';
    *pch++ = tohexdigit((Guid->Data1 >> 28) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 24) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 20) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 16) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data2 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data3 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data4[0] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[0] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[1] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[1] >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data4[2] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[2] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[3] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[3] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[4] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[4] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[5] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[5] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[6] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[6] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[7] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[7] >> 0) & 0xf);
    *pch++ = '}';
    *pch++ = '\0';

    return Buffer;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsactctx.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsactctx.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of the application context object.

Author:

    Michael Grier (MGrier) 2/1/2000

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"
#include "limits.h"

#define IS_ALIGNED(_p, _n) ((((ULONG_PTR) (_p)) & ((_n) - 1)) == 0)
#define IS_WORD_ALIGNED(_p) IS_ALIGNED((_p), 2)
#define IS_DWORD_ALIGNED(_p) IS_ALIGNED((_p), 4)

BOOLEAN g_SxsKeepActivationContextsAlive;
BOOLEAN g_SxsTrackReleaseStacks;

// These must be accessed -only- with the peb lock held
LIST_ENTRY g_SxsLiveActivationContexts;
LIST_ENTRY g_SxsFreeActivationContexts;
ULONG g_SxsMaxDeadActivationContexts = ULONG_MAX;
ULONG g_SxsCurrentDeadActivationContexts;

#if DBG
VOID RtlpSxsBreakOnInvalidMarker(PCACTIVATION_CONTEXT ActivationContext, ULONG FailureCode);
static CHAR *SxsSteppedOnMarkerText = 
        "%s : Invalid activation context marker %p found in activation context %p\n"
        "     This means someone stepped on the allocation, or someone is using a\n"
        "     deallocated activation context\n";
    
#define VALIDATE_ACTCTX(pA) do { \
    const PACTIVATION_CONTEXT_WRAPPED pActual = CONTAINING_RECORD(pA, ACTIVATION_CONTEXT_WRAPPED, ActivationContext); \
    if (pActual->MagicMarker != ACTCTX_MAGIC_MARKER) { \
        DbgPrint(SxsSteppedOnMarkerText, __FUNCTION__, pActual->MagicMarker, pA); \
        ASSERT(pActual->MagicMarker == ACTCTX_MAGIC_MARKER); \
        RtlpSxsBreakOnInvalidMarker((pA), SXS_CORRUPTION_ACTCTX_MAGIC_NOT_MATCHED); \
    } \
} while (0)
#else
#define VALIDATE_ACTCTX(pA)
#endif


VOID
FASTCALL
RtlpMoveActCtxToFreeList(
    PACTIVATION_CONTEXT ActCtx
    );

VOID
FASTCALL
RtlpPlaceActivationContextOnLiveList(
    PACTIVATION_CONTEXT ActCtx
    );

NTSTATUS
RtlpValidateActivationContextData(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN SIZE_T BufferSize OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER TocHeader;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Data->Magic != ACTIVATION_CONTEXT_DATA_MAGIC) ||
        (Data->FormatVersion != ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER) ||
        ((BufferSize != 0) &&
         (BufferSize < Data->TotalSize))) {
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Check required elements...
    if ((Data->DefaultTocOffset == 0) ||
        !IS_DWORD_ALIGNED(Data->DefaultTocOffset)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Warning: Activation context data at %p missing default TOC\n", Data);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // How can we not have an assembly roster?
    if ((Data->AssemblyRosterOffset == 0) ||
        !IS_DWORD_ALIGNED(Data->AssemblyRosterOffset)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Warning: Activation context data at %p lacks assembly roster\n", Data);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Data->DefaultTocOffset != 0) {
        if ((Data->DefaultTocOffset >= Data->TotalSize) ||
            ((Data->DefaultTocOffset + sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER)) > Data->TotalSize)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has invalid TOC header offset\n", Data);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset);

        if (TocHeader->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has TOC header too small (%lu)\n", Data, TocHeader->HeaderSize);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if ((TocHeader->FirstEntryOffset >= Data->TotalSize) ||
            (!IS_DWORD_ALIGNED(TocHeader->FirstEntryOffset)) ||
            ((TocHeader->FirstEntryOffset + (TocHeader->EntryCount * sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY))) > Data->TotalSize)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has invalid TOC entry array offset\n", Data);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }
    }

    // we should finish validating the rest of the structure...

    if ((Data->AssemblyRosterOffset >= Data->TotalSize) ||
        ((Data->AssemblyRosterOffset + sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)) > Data->TotalSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Activation context data at %p has invalid assembly roster offset\n", Data);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset);

    if (Data->AssemblyRosterOffset != 0) {
        if (AssemblyRosterHeader->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has assembly roster header too small (%lu)\n", Data, AssemblyRosterHeader->HeaderSize);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlCreateActivationContext(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,    
    IN ULONG ExtraBytes,
    IN PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine,
    IN PVOID NotificationContext,
    OUT PACTIVATION_CONTEXT *ActCtx
    )
{
    PACTIVATION_CONTEXT NewActCtx = NULL;
    PACTIVATION_CONTEXT_WRAPPED AllocatedActCtx = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i, j;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader;
    BOOLEAN UninitializeStorageMapOnExit = FALSE;

    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: RtlCreateActivationContext() called with parameters:\n"
        "   Flags = 0x%08lx\n"
        "   ActivationContextData = %p\n"
        "   ExtraBytes = %lu\n"
        "   NotificationRoutine = %p\n"
        "   NotificationContext = %p\n"
        "   ActCtx = %p\n",
        Flags,
        ActivationContextData,
        ExtraBytes,
        NotificationRoutine,
        NotificationContext,
        ActCtx);

    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT_DATA(ActivationContextData);

    if (ActCtx != NULL)
        *ActCtx = NULL;

    if ((Flags != 0) ||
        (ActivationContextData == NULL) ||
        (ExtraBytes > 65536) ||
        (ActCtx == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Make sure that the activation context data passes muster
    Status = RtlpValidateActivationContextData(0, ActivationContextData, 0);
    if (!NT_SUCCESS(Status))
        goto Exit;

    // Allocate enough space to hold the new activation context, plus space for the 'magic'
    // marker
    AllocatedActCtx = (PACTIVATION_CONTEXT_WRAPPED)RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                sizeof(ACTIVATION_CONTEXT_WRAPPED) + ExtraBytes);
    if (AllocatedActCtx == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Get the new activation context object, then stamp in the magic signature
    NewActCtx = &AllocatedActCtx->ActivationContext;
    AllocatedActCtx->MagicMarker = ACTCTX_MAGIC_MARKER;

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);

    Status = RtlpInitializeAssemblyStorageMap(
                    &NewActCtx->StorageMap,
                    AssemblyRosterHeader->EntryCount,
                    (AssemblyRosterHeader->EntryCount > NUMBER_OF(NewActCtx->InlineStorageMapEntries)) ? NULL : NewActCtx->InlineStorageMapEntries);
    if (!NT_SUCCESS(Status))
        goto Exit;

    UninitializeStorageMapOnExit = TRUE;

    NewActCtx->RefCount = 1;
    NewActCtx->Flags = 0;
    NewActCtx->ActivationContextData = (PCACTIVATION_CONTEXT_DATA) ActivationContextData;
    NewActCtx->NotificationRoutine = NotificationRoutine;
    NewActCtx->NotificationContext = NotificationContext;

    for (i=0; i<NUMBER_OF(NewActCtx->SentNotifications); i++)
        NewActCtx->SentNotifications[i] = 0;

    for (i=0; i<NUMBER_OF(NewActCtx->DisabledNotifications); i++)
        NewActCtx->DisabledNotifications[i] = 0;

    for (i=0; i<ACTCTX_RELEASE_STACK_SLOTS; i++)
        for (j=0; j<ACTCTX_RELEASE_STACK_DEPTH; j++)
            NewActCtx->StackTraces[i][j] = NULL;
        
    NewActCtx->StackTraceIndex = 0;

    if (g_SxsKeepActivationContextsAlive) {
        RtlpPlaceActivationContextOnLiveList(NewActCtx);
    }


    *ActCtx = &AllocatedActCtx->ActivationContext;
    AllocatedActCtx = NULL;

    UninitializeStorageMapOnExit = FALSE;

    Status = STATUS_SUCCESS;

Exit:
    if (AllocatedActCtx != NULL) {
        if (UninitializeStorageMapOnExit) {
            RtlpUninitializeAssemblyStorageMap(&AllocatedActCtx->ActivationContext.StorageMap);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedActCtx);
    }

    return Status;
}

VOID
NTAPI
RtlAddRefActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    if ((ActCtx != NULL) &&
        (!IS_SPECIAL_ACTCTX(ActCtx)) &&
        (ActCtx->RefCount != LONG_MAX))
    {
        LONG NewRefCount = LONG_MAX;

        VALIDATE_ACTCTX(ActCtx);

        for (;;)
        {
            LONG OldRefCount = ActCtx->RefCount;

            ASSERT(OldRefCount > 0);

            if (OldRefCount == LONG_MAX)
            {
                NewRefCount = LONG_MAX;
                break;
            }

            NewRefCount = OldRefCount + 1;

            if (InterlockedCompareExchange(&ActCtx->RefCount, NewRefCount, OldRefCount) == OldRefCount)
                break;
        }

        ASSERT(NewRefCount > 0);
    }
}

VOID
NTAPI
RtlpFreeActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    VALIDATE_ACTCTX(ActCtx);
    
    ASSERT(ActCtx->RefCount == 0);
    BOOLEAN DisableNotification = FALSE;

    if (ActCtx->NotificationRoutine != NULL) {
        
        // There's no need to check for the notification being disabled; destroy
        // notifications are sent only once, so if the notification routine is not
        // null, we can just call it.
        (*(ActCtx->NotificationRoutine))(
            ACTIVATION_CONTEXT_NOTIFICATION_DESTROY,
            ActCtx,
            ActCtx->ActivationContextData,
            ActCtx->NotificationContext,
            NULL,
            &DisableNotification);
    }

    RtlpUninitializeAssemblyStorageMap(&ActCtx->StorageMap);

    //
    // This predates the MAXULONG refcount, maybe we can get rid of the the flag now?
    //
    if ((ActCtx->Flags & ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED) == 0) {
        RtlFreeHeap(RtlProcessHeap(), 0, CONTAINING_RECORD(ActCtx, ACTIVATION_CONTEXT_WRAPPED, ActivationContext));
    }
}

VOID
NTAPI
RtlReleaseActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    if ((ActCtx != NULL) &&
        (!IS_SPECIAL_ACTCTX(ActCtx)) &&
        (ActCtx->RefCount > 0) &&
        (ActCtx->RefCount != LONG_MAX))
    {
        LONG NewRefCount = LONG_MAX;
        ULONG StackTraceSlot = 0;

        VALIDATE_ACTCTX(ActCtx);
        
        // Complicated version of InterlockedDecrement that won't decrement LONG_MAX
        for (;;)
        {
            LONG OldRefCount = ActCtx->RefCount;
            ASSERT(OldRefCount != 0);

            if (OldRefCount == LONG_MAX)
            {
                NewRefCount = OldRefCount;
                break;
            }

            NewRefCount = OldRefCount - 1;

            if (InterlockedCompareExchange(&ActCtx->RefCount, NewRefCount, OldRefCount) == OldRefCount)
                break;
        }

                
        // This spiffiness will capture the last N releases of this activation context, in
        // a circular list fashion.  Just look at ((ActCtx->StackTraceIndex - 1) % ACTCTX_RELEASE_STACK_SLOTS)
        // to find the most recent release call.  This is especially handy for people who over-release.
        if (g_SxsTrackReleaseStacks)
        {
            StackTraceSlot = ((ULONG)InterlockedIncrement((LONG*)&ActCtx->StackTraceIndex)) % ACTCTX_RELEASE_STACK_SLOTS;
            RtlCaptureStackBackTrace(1, ACTCTX_RELEASE_STACK_DEPTH, ActCtx->StackTraces[StackTraceSlot], NULL);
        }

        if (NewRefCount == 0)
        {
            // If this flag is set, then we need to put "dead" activation
            // contexts into this special list.  This should help us diagnose
            // actctx over-releasing better.  Don't do this if we haven't
            // initialized the list head yet.
            if (g_SxsKeepActivationContextsAlive) {
                RtlpMoveActCtxToFreeList(ActCtx);
            }
            // Otherwise, just free it.
            else {
                RtlpFreeActivationContext(ActCtx);
            }
        }
    }
}

NTSTATUS
NTAPI
RtlZombifyActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((ActCtx == NULL) || IS_SPECIAL_ACTCTX(ActCtx))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    VALIDATE_ACTCTX(ActCtx);

    if ((ActCtx->Flags & ACTIVATION_CONTEXT_ZOMBIFIED) == 0)
    {
        if (ActCtx->NotificationRoutine != NULL)
        {
            // Since disable is sent only once, there's no need to check for
            // disabled notifications.

            BOOLEAN DisableNotification = FALSE;

            (*(ActCtx->NotificationRoutine))(
                        ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY,
                        ActCtx,
                        ActCtx->ActivationContextData,
                        ActCtx->NotificationContext,
                        NULL,
                        &DisableNotification);
        }
        ActCtx->Flags |= ACTIVATION_CONTEXT_ZOMBIFIED;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


VOID
FASTCALL
RtlpEnsureLiveDeadListsInitialized(
    VOID
    )
{
    if (g_SxsLiveActivationContexts.Flink == NULL) {
        RtlAcquirePebLock();
        __try {
            if (g_SxsLiveActivationContexts.Flink != NULL)
                __leave;

            InitializeListHead(&g_SxsLiveActivationContexts);
            InitializeListHead(&g_SxsFreeActivationContexts);
        }
        __finally {
            RtlReleasePebLock();
        }
    }
}

// PRECONDITION: Called only when g_SxsKeepActivationContextsAlive is set, but not dangerous
// to call at other times, just nonperformant
VOID
FASTCALL
RtlpMoveActCtxToFreeList(
    PACTIVATION_CONTEXT ActCtx
    )
{
    RtlpEnsureLiveDeadListsInitialized();
    
    RtlAcquirePebLock();
    __try {
        // Remove this entry from whatever list it's on.  This works fine for entries that were
        // never on any list as well.
        RemoveEntryList(&ActCtx->Links);

        // If we are about to overflow the "max dead count" and there's items on the
        // dead list to clear out, start clearing out entries until we're underwater
        // again.
        while ((g_SxsCurrentDeadActivationContexts != 0) && 
               (g_SxsCurrentDeadActivationContexts >= g_SxsMaxDeadActivationContexts)) {

            LIST_ENTRY *ple2 = RemoveHeadList(&g_SxsFreeActivationContexts);
            PACTIVATION_CONTEXT ActToFree = CONTAINING_RECORD(ple2, ACTIVATION_CONTEXT, Links);

            // If this assert fires, then "something bad" happened while walking the list
            ASSERT(ple2 != &g_SxsFreeActivationContexts);
            
            RtlpFreeActivationContext(ActToFree);
            
            g_SxsCurrentDeadActivationContexts--;
        }

        // Now, if the max dead count is greater than zero, add this to the dead list
        if (g_SxsMaxDeadActivationContexts > 0) {
            
            InsertTailList(&g_SxsFreeActivationContexts, &ActCtx->Links);
            
            g_SxsCurrentDeadActivationContexts++;
            
        }
        // Otherwise, just free it
        else {
            
            RtlpFreeActivationContext(ActCtx);
            
        }
        
    }
    __finally {
        RtlReleasePebLock();
    }
}

// PRECONDITION: g_SxsKeepActivationContextsAlive set.  Not dangerous to call when not set,
// just underperformant.
VOID
FASTCALL
RtlpPlaceActivationContextOnLiveList(
    PACTIVATION_CONTEXT ActCtx
    )
{
    // Ensure these are initialized.
    RtlpEnsureLiveDeadListsInitialized();

    RtlAcquirePebLock();
    __try {
        InsertHeadList(&g_SxsLiveActivationContexts, &ActCtx->Links);
    }
    __finally {
        RtlReleasePebLock();
    }
}


VOID
FASTCALL
RtlpFreeCachedActivationContexts(
    VOID
    )
{
    LIST_ENTRY *ple = NULL;

    // Don't bother if these were never initialized
    if ((g_SxsLiveActivationContexts.Flink == NULL) || (g_SxsFreeActivationContexts.Flink == NULL))
        return;

    RtlAcquirePebLock();
    __try {
        ple = g_SxsLiveActivationContexts.Flink;

        while (ple != &g_SxsLiveActivationContexts) {
            PACTIVATION_CONTEXT ActCtx = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT, Links);
            ple = ActCtx->Links.Flink;

            RemoveEntryList(&ActCtx->Links);
            RtlpFreeActivationContext(ActCtx);
        }

        ple = g_SxsFreeActivationContexts.Flink;

        while (ple != &g_SxsFreeActivationContexts) {
            PACTIVATION_CONTEXT ActCtx = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT, Links);
            ple = ActCtx->Links.Flink;
            
            RemoveEntryList(&ActCtx->Links);
            RtlpFreeActivationContext(ActCtx);            
        }
    }
    __finally {
        RtlReleasePebLock();
    }
}


#if DBG
VOID 
RtlpSxsBreakOnInvalidMarker(
    PCACTIVATION_CONTEXT ActivationContext,
    ULONG FailureCode
    )
{
    EXCEPTION_RECORD Exr;

    Exr.ExceptionRecord = NULL;
    Exr.ExceptionCode = STATUS_SXS_CORRUPTION;
    Exr.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    Exr.NumberParameters = 3;
    Exr.ExceptionInformation[0] = SXS_CORRUPTION_ACTCTX_MAGIC;
    Exr.ExceptionInformation[1] = FailureCode;
    Exr.ExceptionInformation[2] = (ULONG_PTR)ActivationContext;
    RtlRaiseException(&Exr);        
}
#endif

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsquerycpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsquerycpp.cpp

Abstract:

    C++ wrapper source file for sxsquery.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsquery.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsisol.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsisol.c

Abstract:

    Current directory support

Author:

    sxsdev(mgrier, jaykrell, xiaoyuw, jonwis) 04-Jun-2002

Revision History:

--*/

#include "pch.cxx"
#include "nt.h"
#include "ntos.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"
#include "ctype.h"
#include "sxstypes.h"
#include "ntdllp.h"

//
//  This seems bizarre that these constants are here but I don't see them elsewhere.

#define SXSISOL_DOT L"."
#define SXSISOL_CONSTANT_STRING_U(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)(s) }
const static UNICODE_STRING sxsisol_ExtensionDelimiters = SXSISOL_CONSTANT_STRING_U(SXSISOL_DOT);

#define IFNOT_NTSUCCESS_EXIT(x)     \
    do {                            \
        Status = (x);               \
        if (!NT_SUCCESS(Status))    \
            goto Exit;              \
    } while (0)

#define PARAMETER_CHECK(x) \
    do { \
        if (!(x)) { \
            Status = STATUS_INVALID_PARAMETER; \
            goto Exit; \
        } \
    } while (0)

#define INTERNAL_ERROR_CHECK(x) \
    do { \
        if (!(x)) { \
            RtlAssert("Internal error check failed", __FILE__, __LINE__, #x); \
            Status = STATUS_INTERNAL_ERROR; \
            goto Exit; \
        } \
    } while (0)

typedef struct _SXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS {
    RTL_UNICODE_STRING_BUFFER PublicUnicodeStringBuffer;
    PUNICODE_STRING PrivatePreallocatedString;
    PUNICODE_STRING PrivateDynamicallyAllocatedString;
    PUNICODE_STRING *PrivateUsedString;
    BOOLEAN          Valid;
} SXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS, *PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS;

typedef RTL_STRING_LENGTH_TYPE *PRTL_STRING_LENGTH_TYPE;

static
void
sxsisol_InitUnicodeStringBufferAroundUnicodeStrings(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This,
    PUNICODE_STRING PreallocatedString,
    PUNICODE_STRING DynamicallyAllocatedString,
    PUNICODE_STRING *UsedString
    );

static
NTSTATUS
sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Success(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This
    );

static
void
sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Failure(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This
    );

static
NTSTATUS
sxsisol_PathHasExtension(
    IN PCUNICODE_STRING Path,
    OUT bool &rfHasExtension
    );

static
NTSTATUS
sxsisol_PathAppendDefaultExtension(
    IN PCUNICODE_STRING Path,
    IN PCUNICODE_STRING DefaultExtension OPTIONAL,
    OUT PRTL_UNICODE_STRING_BUFFER PathWithExtension,
    OUT bool &rfAppended
    );

static
NTSTATUS
sxsisol_CanonicalizeFullPathFileName(
    IN OUT PUNICODE_STRING FileName,   // could be a fullpath or relative path, and only fullpath are dealt with
    IN PUNICODE_STRING FullPathPreallocatedString,
    IN OUT PUNICODE_STRING FullPathDynamicString
    );

static
NTSTATUS
sxsisol_RespectDotLocal(
    IN PCUNICODE_STRING FileName,
    OUT PRTL_UNICODE_STRING_BUFFER FullPathResult,
    IN OUT ULONG *OutFlags OPTIONAL
    );

static
NTSTATUS
sxsisol_SearchActCtxForDllName(
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN fExistenceTest,
    IN OUT SIZE_T &TotalLength,
    IN OUT ULONG  *OutFlags,
    OUT PRTL_UNICODE_STRING_BUFFER FullPathResult
    );

static
NTSTATUS
sxsisol_ExpandEnvironmentStrings_UEx(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PRTL_UNICODE_STRING_BUFFER Destination
    );

NTSTATUS
NTAPI
RtlDosApplyFileIsolationRedirection_Ustr(
    ULONG Flags,
    PCUNICODE_STRING FileNameIn,
    PCUNICODE_STRING DefaultExtension,
    PUNICODE_STRING PreAllocatedString,
    PUNICODE_STRING DynamicallyAllocatedString,
    PUNICODE_STRING *OutFullPath,
    ULONG  *OutFlags,
    SIZE_T *FilePartPrefixCch,
    SIZE_T *BytesRequired
    )

//  ++
//
//  Routine Description:
//
//      This function implements the basic capability of taking a path
//      and applying any appropriate isolation/redirection to it.
//
//      Notably it today includes redirection for Fusion manifest-based
//      isolation and .local isolation.
//
//  Arguments:
//
//      Flags - Flags affecting the behavior of this function.
//
//          RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL
//              Controls whether this function applies ".local" semantics
//              to the redirection.
//
//      FileNameIn - Path that is being checked for isolation/redirection.
//          This may be "any" sort of Win32/DOS path - absolute, relative,
//          leaf name only.
//
//          .local redirection applies equally to all kinds of paths.
//
//          Fusion manifest-based redirection normally applies to relative
//          paths, except when a component is listed in the "system default
//          manifest", in which case attempts to load the DLL by full path
//          (e.g. "c:\windows\system32\comctl32.dll") need to be redirected
//          into the side-by-side store.
//
//      DefaultExtension
//
//          Default extension to apply to FileNameIn if it does not have
//          an extension.
//
//      PreAllocatedString (optional)
//
//          UNICODE_STRING that this function can use to return results
//          where the caller is responsible for managing the storage
//          associated with the allocation.  The function may use this
//          string and will not attempt to dynamically resize it;
//          if the space required exceeds the maximum length of
//          the preallocated string, either dynamic storage is allocated
//          or the function will fail with the buffer-too-small
//          NTSTATUS code.
//
//          If NULL is passed for this parameter, the space for the
//          output and temporary strings will be dynamically allocated.
//
//      DynamicallyAllocatedString (optional)
//
//          UNICODE_STRING which if present should refer to an "empty"
//          UNICODE_STRING (sizes an buffer pointer 0 and NULL
//          respectively).  If PreAllocatedString was not passed or
//          is not big enough for the results, the information about
//          the dynamically allocated string is returned in this
//          parameter.  If no dynamic allocation was performed, this
//          string is left null.
//
//      OutFullPath (optional)
//
//          PUNICODE_STRING pointer that is filled in with the
//          UNICODE_STRING pointer passed in as PreAllocatedString or
//          DynamicallyAllocatedString as appropriate.  If only one
//          of the two (PreAllocatedString, DynamicallyAllocatedString)
//          is passed in, this parameter may be omitted.
//
//      FilePartPrefixCch
//
//          Returned number of characters in the resultant path up to
//          and including the last path separator.
//
//      BytesRequired
//
//          Returned byte count of the size of the string needed for
//          storing the resultant full path.
//
//  The expected calling sequence for RtlDosApplyFileIsolationRedirection_Ustr() is something
//  like this:
//
//  {
//      WCHAR Buffer[MAX_PATH];
//      UNICODE_STRING PreAllocatedString;
//      UNICODE_STRING DynamicallyAllocatedString = { 0, 0, NULL };
//      PUNICODE_STRING FullPath;
//
//      PreAllocatedString.Length = 0;
//      PreAllocatedString.MaximumLength = sizeof(Buffer);
//      PreAllocatedString.Buffer = Buffer;
//
//      Status = RtlDosApplyFileIsolationRedirection_Ustr(
//                  Flags,
//                  FileToCheck,
//                  DefaultExtensionToApply, // for example ".DLL"
//                  &PreAllocatedString,
//                  &DynamicallyAllocatedString,
//                  &FullPath);
//      if (!NT_SUCCESS(Status)) return Status;
//      // now code uses FullPath as the complete path name...
//
//      // In exit paths, always free the dynamic string:
//      RtlFreeUnicodeString(&DynamicallyAllocatedString);
//  }
//
//  Return Value:
//
//      NTSTATUS indicating the success/failure of the function.
//
//  --

{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    //
    // perf and frame size problems here..
    //
    WCHAR           FullPathPreallocatedBuffer[64]; // seldom used
    UNICODE_STRING  FullPathDynamicString = { 0, 0, NULL };
    UNICODE_STRING  FullPathPreallocatedString = { 0, sizeof(FullPathPreallocatedBuffer), FullPathPreallocatedBuffer };

    //
    // This is where we append .dll (or any other extension).
    // This is considered an unusual case -- when people say LoadLibrary(kernel32) instead of LoadLibrary(kernel32.dll).
    //
    UCHAR FileNameWithExtensionStaticBuffer[16 * sizeof(WCHAR)];
    RTL_UNICODE_STRING_BUFFER FileNameWithExtensionBuffer;

    UNICODE_STRING FileName;

    SXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS StringWrapper;
    const PRTL_UNICODE_STRING_BUFFER FullPathResult = &StringWrapper.PublicUnicodeStringBuffer;
    SIZE_T TotalLength = 0;
    USHORT FilePartPrefixCb = 0;
    ULONG OutFlagsTemp = 0; // local copy; we'll copy out on success

    // Initialize out parameters first
    if (OutFlags != NULL)
        *OutFlags = 0;

    if (FilePartPrefixCch != NULL)
        *FilePartPrefixCch = 0;

    if (BytesRequired != NULL)
        *BytesRequired = (DOS_MAX_PATH_LENGTH * sizeof(WCHAR)); // sleazy, but I doubt it was usually correct

    if (DynamicallyAllocatedString != NULL) {
        RtlInitEmptyUnicodeString(DynamicallyAllocatedString, NULL, 0);
    }

    //
    // step1 : initialization
    //
    RtlInitUnicodeStringBuffer(
        &FileNameWithExtensionBuffer,
        FileNameWithExtensionStaticBuffer,
        sizeof(FileNameWithExtensionStaticBuffer));

    sxsisol_InitUnicodeStringBufferAroundUnicodeStrings(
        &StringWrapper,
        PreAllocatedString,
        DynamicallyAllocatedString,
        OutFullPath);

    // Valid input conditions:
    //  1. You have to have a filename
    //  2. If you specify both the preallocated buffer and the dynamically
    //      allocated buffer, you need the OutFullPath parameter to detect
    //      which was actually populated.
    //  3. If you ask for the file part prefix cch, you need an output
    //      buffer; otherwise you can't know what the cch is relative to.

    PARAMETER_CHECK((Flags & ~(RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL)) == 0);
    PARAMETER_CHECK(FileNameIn != NULL);
    PARAMETER_CHECK(
        !(((PreAllocatedString == NULL) && (DynamicallyAllocatedString == NULL) && (FilePartPrefixCch != NULL)) ||
          ((PreAllocatedString != NULL) && (DynamicallyAllocatedString != NULL) && (OutFullPath == NULL))));

    FileName = *FileNameIn;

    //
    // step2: append extension (".dll" usually) if needed
    //
    bool fAppended;

    IFNOT_NTSUCCESS_EXIT(
        sxsisol_PathAppendDefaultExtension(
            &FileName,
            DefaultExtension,
            &FileNameWithExtensionBuffer,
            fAppended));

    if (fAppended)
        FileName = FileNameWithExtensionBuffer.String;

    //
    // step3: For fullpaths, canonicalize .. and . and such.
    // Comments:
    //      We do this so fullpaths like c:\windows\.\system32\comctl32.dll can be correctly
    //      redirected to "system default".
    //
    // It'd be nice to use the buffers our caller gave us here, but it is a bit tricky.
    //

    IFNOT_NTSUCCESS_EXIT(
        sxsisol_CanonicalizeFullPathFileName(
            &FileName,                          // FileName could be reset inside this func
            &FullPathPreallocatedString,
            &FullPathDynamicString));

    //
    // Step4: Deal with .local if existed
    //

    if ((Flags & RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL) &&
        (NtCurrentPeb()->ProcessParameters != NULL) &&
        (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL)) {
        IFNOT_NTSUCCESS_EXIT(
            sxsisol_RespectDotLocal(
                &FileName,
                FullPathResult,
                &OutFlagsTemp));
    }

    // If it was not redirected by .local, try activation contexts/manifests
    if (!(OutFlagsTemp & RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_DOT_LOCAL_REDIRECT)) {
        IFNOT_NTSUCCESS_EXIT(
            sxsisol_SearchActCtxForDllName(
                &FileName,
                ((PreAllocatedString == NULL) && (DynamicallyAllocatedString == NULL))? TRUE : FALSE,
                TotalLength,
                OutFlags,
                FullPathResult));

    }

    // we got the path but the input buffer is not big-enough
    if ((DynamicallyAllocatedString == NULL) && (PreAllocatedString != NULL) && (FullPathResult->String.Buffer != PreAllocatedString->Buffer))
    {
        Status = STATUS_BUFFER_TOO_SMALL; // no dynamic buffer, only a small static buffer
        goto Exit;
    }

    if (FilePartPrefixCch != NULL) {
        //
        //  We should have a full path at this point.  Compute the length of the
        //  string up through the last path separator.
        //

        IFNOT_NTSUCCESS_EXIT(
            RtlFindCharInUnicodeString(
                RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                &FullPathResult->String,
                &RtlDosPathSeperatorsString,
                &FilePartPrefixCb));
        //  The prefix length from RtlFindCharInUnicodeString does not include
        //  the pattern character matched.  Convert from byte count to character
        //  count and include space for the separator.
        *FilePartPrefixCch = (FilePartPrefixCb / sizeof(WCHAR)) + 1;
    }

    IFNOT_NTSUCCESS_EXIT(sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Success(&StringWrapper));

    if (OutFlags != NULL)
        *OutFlags = OutFlagsTemp;

    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status))
        sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Failure(&StringWrapper);

    RtlFreeUnicodeString(&FullPathDynamicString);
    RtlFreeUnicodeStringBuffer(&FileNameWithExtensionBuffer);

    // Map section not found back to key not found so that callers don't
    // have to worry about sections being present vs. the lookup key
    // being present.
    ASSERT(Status != STATUS_SXS_SECTION_NOT_FOUND);
    INTERNAL_ERROR_CHECK(Status != STATUS_SXS_SECTION_NOT_FOUND);

    return Status;
}

void
sxsisol_InitUnicodeStringBufferAroundUnicodeStrings(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This,
    PUNICODE_STRING PreallocatedString,
    PUNICODE_STRING DynamicallyAllocatedString,
    PUNICODE_STRING *UsedString
    )
//++
//
//  Routine Description:
//
//      Initialize a wrapper around the UNICODE_STRING pair
//      (preallocated vs. dynamically allocated) and the
//      actual PUNICODE_STRING which holds the value.
//
//  Arguments:
//
//      This
//          Pointer to the wrapper struct to initialize.
//
//      PreallocatedString (optional)
//          Pointer to a UNICODE_STRING that holds the preallocated
//          buffer.
//
//      DynamicallyAllocatedString (optional)
//          Pointer to a UNICODE_STRING which will store information
//          about any dynamic allocations done to support the
//          RTL_UNICODE_STRING_BUFFER manipulations.
//
//      UsedString
//          Pointer to the PUNICODE_STRING which will be updated
//          to indicate which of PreallocatedString or
//          DynamicallyAllocatedString were actually used.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success or failure of
//      the function.
//
//--

{
    ASSERT(This != NULL);

    if (PreallocatedString != NULL) {
        RtlInitUnicodeStringBuffer(
                &This->PublicUnicodeStringBuffer,
                (PUCHAR)PreallocatedString->Buffer,
                PreallocatedString->MaximumLength);
    } else
        RtlInitUnicodeStringBuffer(&This->PublicUnicodeStringBuffer, NULL, 0);

    This->PrivatePreallocatedString = PreallocatedString;
    This->PrivateDynamicallyAllocatedString = DynamicallyAllocatedString;
    This->PrivateUsedString = UsedString;
    This->Valid = TRUE;
}

NTSTATUS
sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Success(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This
    )
//++
//
//  Routine Description:
//
//      Cleans up use of a SXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS
//      structure, performing appropriate cleanup for success vs. failure
//      cases.
//
//  Arguments:
//
//      This
//          Pointer to the wrapper struct to clean up
//
//  Return Value:
//
//      NTSTATUS indicating the overall success or failure of
//      the function.
//
//--

{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    INTERNAL_ERROR_CHECK(This != NULL);

    if (This->Valid) {
        RTL_UNICODE_STRING_BUFFER &rUSB = This->PublicUnicodeStringBuffer;
        UNICODE_STRING &rUS = rUSB.String;

        INTERNAL_ERROR_CHECK(
            (This->PrivateDynamicallyAllocatedString == NULL) ||
            (This->PrivateDynamicallyAllocatedString->Buffer == NULL));

        if ((This->PrivatePreallocatedString != NULL) &&
            (This->PrivatePreallocatedString->Buffer == rUS.Buffer)) {

            INTERNAL_ERROR_CHECK(rUS.Length <= This->PrivatePreallocatedString->MaximumLength);
            This->PrivatePreallocatedString->Length = rUS.Length;

            INTERNAL_ERROR_CHECK(This->PrivateUsedString != NULL);
            *This->PrivateUsedString = This->PrivatePreallocatedString;
        } else if (This->PrivateDynamicallyAllocatedString != NULL) {
            *This->PrivateDynamicallyAllocatedString = rUS;

            INTERNAL_ERROR_CHECK(This->PrivateUsedString != NULL);
            *This->PrivateUsedString = This->PrivateDynamicallyAllocatedString;
        } else {
            RtlFreeUnicodeStringBuffer(&rUSB);
            //Status = STATUS_NAME_TOO_LONG;
            //goto Exit;
        }
    }

    Status = STATUS_SUCCESS;

Exit:
    if (This != NULL) {
        RtlZeroMemory(This, sizeof(*This));
        ASSERT(!This->Valid);
    }

    return Status;
}

void
sxsisol_FreeUnicodeStringBufferAroundUnicodeStrings_Failure(
    PSXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS This
    )
//++
//
//  Routine Description:
//
//      Cleans up use of a SXSISOL_UNICODE_STRING_BUFFER_AROUND_UNICODE_STRINGS
//      structure, performing appropriate cleanup for failure cases.
//
//  Arguments:
//
//      This
//          Pointer to the wrapper struct to initialize.
//
//
//  Return Value:
//
//      None
//
//--

{
    ASSERT(This != NULL);

    if (This->Valid) {
        if (This->PrivateDynamicallyAllocatedString != NULL) {
            ASSERT(This->PrivateDynamicallyAllocatedString->Buffer == NULL);
        }

        RtlFreeUnicodeStringBuffer(&This->PublicUnicodeStringBuffer);
    }

    RtlZeroMemory(This, sizeof(*This));
    ASSERT(!This->Valid);
}

NTSTATUS
sxsisol_PathHasExtension(
    IN PCUNICODE_STRING Path,
    OUT bool &rfHasExtension
    )

//++
//
//  Routine Description:
//
//      Locate the extension of a file in a path.
//
//  Arguments:
//
//      Path
//          Path in which to find extension.
//
//      rfHasExtension
//          On a successful outcome of the call, indicates that
//          the path passed in Path does have an extension.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the
//      call.
//
//--

{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    RTL_STRING_LENGTH_TYPE LocalPrefixLength;

    rfHasExtension = false;

    Status = RtlFindCharInUnicodeString(
        RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
        Path,
        &sxsisol_ExtensionDelimiters,
        &LocalPrefixLength);

    if (!NT_SUCCESS(Status)) {
        if (Status != STATUS_NOT_FOUND)
            goto Exit;
    } else {
        rfHasExtension = true;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
sxsisol_PathAppendDefaultExtension(
    IN PCUNICODE_STRING Path,
    IN PCUNICODE_STRING DefaultExtension OPTIONAL,
    IN OUT PRTL_UNICODE_STRING_BUFFER PathWithExtension,
    OUT bool &rfAppended
    )
//++
//
//  Routine Description:
//
//      If a path does not contain an extension, add one.
//
//  Arguments:
//
//      Path
//          Path in which to find extension.
//
//      DefaultExtension
//          Extension to append to the path.
//
//      PathWithExtension
//          Initialized RTL_UNICODE_STRING_BUFFER into which
//          the modified path (including extension) is written.
//
//          If the path already has an extension, nothing
//          is written to PathWithExtension.
//
//      rfAppended
//          Out bool set to true iff the path was modified with
//          an extension.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the
//      call.
//
//--
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    UNICODE_STRING Strings[2];
    ULONG NumberOfStrings = 1;

    rfAppended = false;

    PARAMETER_CHECK(Path != NULL);
    PARAMETER_CHECK(PathWithExtension != NULL);

    if ((DefaultExtension != NULL) && !RTL_STRING_IS_EMPTY(DefaultExtension)) {
        bool fHasExtension = false;
        IFNOT_NTSUCCESS_EXIT(sxsisol_PathHasExtension(Path, fHasExtension));
        if (!fHasExtension) {
            Strings[0] = *Path;
            Strings[1] = *DefaultExtension;
            NumberOfStrings = 2;
            PathWithExtension->String.Length = 0;
            IFNOT_NTSUCCESS_EXIT(RtlMultiAppendUnicodeStringBuffer(PathWithExtension, NumberOfStrings, Strings));
            rfAppended = true;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
sxsisol_CanonicalizeFullPathFileName(
    IN OUT PUNICODE_STRING FileName,   // could be a fullpath or relative path, and only fullpath are dealt with
    IN PUNICODE_STRING FullPathPreallocatedString,
    IN OUT PUNICODE_STRING FullPathDynamicString
    )
//++
//
//  Routine Description:
//
//      Canonicalize a path name for comparison against globally
//      redirected absolute file paths (e.g. the system default
//      activation context).
//
//      Given an absolute path, like c:\foo\bar.dll or c:\foo\..\bar.dll,
//      return a canonicalized fullpaty like c:\foo\bar.dll or c:\bar.dll
//
//      Given a relative path like bar.dll or ..\bar.dll, leave it unchanged.
//
//      \\?\ and \\.\ followed by drive letter colon slash are changed,
//      but followed by anything else is not.
//        \\?\c:\foo => c:\foo
//        \\.\c:\foo => c:\foo
//        \\?\pipe => \\?\pipe
//        \\.\pipe => \\.\pipe
//        \\?\unc\machine\share\foo => \\?\unc\machine\share\foo
//
//  Arguments:
//
//      FileName
//          Name of the file to be canonicalized.
//          If the file name is modified, this UNICODE_STRING
//          is overwritten with information about where the
//          canonicalized path is written; this will be one of
//          the two UNICODE_STRING parameters:
//          FullPathPreallocatedString or FullPathDynamicString.
//
//          Note that is may not be exactly either one of their
//          values but may instead reference a substring contained
//          in them.
//
//      FullPathPreallocatedString
//          Optional preallocated buffer used to hold the canonicalized
//          full path of FileName.
//
//      FullPathDynamicString
//          Optional UNICODE_STRING which is used if the file name
//          passed in FileName must be canonicalized and the
//          canonicalization does not fit in FullPathPreallocatedString.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the
//      call.
//
//--
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    RTL_PATH_TYPE PathType;
    PUNICODE_STRING FullPathUsed = NULL;
    bool fDynamicAllocatedBufferUsed = false;

    PARAMETER_CHECK(FileName != NULL);
    // The dynamic string is optional, but if it is present, the buffer must be NULL.
    PARAMETER_CHECK((FullPathDynamicString == NULL) || (FullPathDynamicString->Buffer == NULL));

    IFNOT_NTSUCCESS_EXIT(
        RtlGetFullPathName_UstrEx(
            FileName,
            FullPathPreallocatedString,
            FullPathDynamicString,
            &FullPathUsed,
            NULL,
            NULL,
            &PathType,
            NULL));

    if ((PathType == RtlPathTypeLocalDevice) || (PathType == RtlPathTypeDriveAbsolute) || (PathType == RtlPathTypeUncAbsolute)) {
        UNICODE_STRING RealFullPath;    
        RealFullPath = *FullPathUsed;

        if (PathType == RtlPathTypeLocalDevice) {

            ASSERT(RTL_STRING_GET_LENGTH_CHARS(FullPathUsed) > 4);
            ASSERT((FileName->Buffer[0] == L'\\') && (FileName->Buffer[1] == L'\\') &&
                    ((FileName->Buffer[2] == L'.') || (FileName->Buffer[2] == L'?' )) && (FileName->Buffer[3] == L'\\'));

            //
            // only deal with \\?\C:\ or \\.\C:\, ignore other cases such as \\?\UNC\ or \\.\UNC\
            //
            if ((FileName->Buffer[5] == L':') && ( FileName->Buffer[6] == L'\\')) {   
                //
                // Remove first four characters from string, "\\?\c:\" => "c:\"
                //
                FileName->Length -= (4 * sizeof(WCHAR));         
                FileName->Buffer += 4;
                FileName->MaximumLength -= (4 * sizeof(WCHAR));         

                RealFullPath.Length -= (4 * sizeof(WCHAR));
                RealFullPath.Buffer += 4;                
                RealFullPath.MaximumLength -= (4 * sizeof(WCHAR));         
            }
        }
        if (FileName->Length > RealFullPath.Length) { // FileName contains redundant path part, so FileName must be reset 
            if (FullPathUsed == FullPathDynamicString)
                fDynamicAllocatedBufferUsed = true;

            *FileName = RealFullPath;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    if (!fDynamicAllocatedBufferUsed)
        RtlFreeUnicodeString(FullPathDynamicString); // free here or at the end of the caller

    return Status;
}

NTSTATUS
sxsisol_RespectDotLocal(
    IN PCUNICODE_STRING FileName,
    OUT PRTL_UNICODE_STRING_BUFFER FullPathResult,
    OUT ULONG *OutFlags OPTIONAL
    )
//++
//
//  Routine Description:
//
//      Determine if the file pass in FileName has .local based
//      redirection in the app folder.
//
//  Arguments:
//
//      FileName
//          Leaf name of the file to look for.  (e.g. "foo.dll")
//
//      FullPathResult
//          Returned full path to the file found.
//
//      OutFlags
//          Option out parameter; the value
//          RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_DOT_LOCAL_REDIRECT
//          is ORed in if a .local based redirection is found.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the
//      call.
//
//--
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    UNICODE_STRING LocalDllNameInAppDir = { 0 };
    UNICODE_STRING LocalDllNameInDotLocalDir = { 0 };
    PUNICODE_STRING LocalDllNameFound = NULL;

    PARAMETER_CHECK(FullPathResult != NULL);

    IFNOT_NTSUCCESS_EXIT(
        RtlComputePrivatizedDllName_U(
            FileName,
            &LocalDllNameInAppDir,
            &LocalDllNameInDotLocalDir));

    if (RtlDoesFileExists_UStr(&LocalDllNameInDotLocalDir)) {
        LocalDllNameFound = &LocalDllNameInDotLocalDir;
    } else if (RtlDoesFileExists_UStr(&LocalDllNameInAppDir)) {
        LocalDllNameFound = &LocalDllNameInAppDir;
    }

    if (LocalDllNameFound != NULL) {
        IFNOT_NTSUCCESS_EXIT(RtlAssignUnicodeStringBuffer(FullPathResult, LocalDllNameFound));

        if (OutFlags != NULL)
            *OutFlags |= RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_DOT_LOCAL_REDIRECT;
    }

    Status = STATUS_SUCCESS;

Exit:
    RtlFreeUnicodeString(&LocalDllNameInAppDir);
    RtlFreeUnicodeString(&LocalDllNameInDotLocalDir);

    return Status;
}

NTSTATUS
sxsisol_SearchActCtxForDllName(
    IN PCUNICODE_STRING FileNameIn,
    IN BOOLEAN fExistenceTest,
    IN OUT SIZE_T &TotalLength,
    IN OUT ULONG *OutFlags,
    OUT PRTL_UNICODE_STRING_BUFFER FullPathResult
    )
//++
//
//  Routine Description:
//
//      Determine if the active activation context(s) contain a redirection
//      for a given file name and if so, compute the full absolute path
//      of the redirection.
//
//  Arguments:
//
//      FileNameIn
//          Name of the file to search for in the activation context.
//
//          This file name is searched for exactly in the activation
//          context dll redirection section (case insensitive).
//
//      fExistenceTest
//          Set to true to indicate that we're only interested in
//          whether the path in FileNameIn is redirected.
//
//      TotalLength
//          Total length of the path out.
//
//      OutFlags
//          Flags set to indicate the disposition of the call.
//
//              RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_ACTCTX_REDIRECT
//                  Activation context based redirection was found and applied.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the
//      call.
//
//--
{
    UNICODE_STRING FileNameTemp;
    PUNICODE_STRING FileName;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA askd = {sizeof(askd)};
    const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION *DllRedirData;
    const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT *PathSegmentArray;
    RTL_UNICODE_STRING_BUFFER EnvironmentExpandedDllPathBuffer; // seldom used
    SIZE_T PathSegmentCount = 0;
    PACTIVATION_CONTEXT ActivationContext = NULL;
    PCUNICODE_STRING AssemblyStorageRoot = NULL;
    ULONG i;

    FileNameTemp = *FileNameIn;
    FileName = &FileNameTemp;

    RtlInitUnicodeStringBuffer(&EnvironmentExpandedDllPathBuffer, NULL, 0);

    Status = RtlFindActivationContextSectionString(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT |
                        FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS,
                    NULL,
                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
                    FileName,
                    &askd);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SXS_SECTION_NOT_FOUND)
            Status = STATUS_SXS_KEY_NOT_FOUND;

        goto Exit;
    }

    if (fExistenceTest == TRUE) {
        Status = STATUS_SUCCESS;
        // This was just an existence test.  return the successful status.
        goto Exit;
    }

    ActivationContext = askd.ActivationContext;

    if ((askd.Length < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION)) ||
        (askd.DataFormatVersion != ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER)) {
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    DllRedirData = (const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION *) askd.Data;

    // validate DllRedirData
    // If the path segment list extends beyond the section, we're outta here
    if ((((ULONG) DllRedirData->PathSegmentOffset) > askd.SectionTotalLength) ||
        (DllRedirData->PathSegmentCount > (MAXULONG / sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT))) ||
        (DllRedirData->PathSegmentOffset > (MAXULONG - (DllRedirData->PathSegmentCount * sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT)))) ||
        (((ULONG) (DllRedirData->PathSegmentOffset + (DllRedirData->PathSegmentCount * sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT)))) > askd.SectionTotalLength)) {

#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s - Path segment array extends beyond section limits\n",
            __FUNCTION__);
#endif // DBG

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // If the entry requires path root resolution, do so!
    if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT) {
        NTSTATUS InnerStatus = STATUS_SUCCESS;
        ULONG GetAssemblyStorageRootFlags = 0;

        // There's no need to support both a dynamic root and environment variable
        // expansion.
        if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "[%x.%x] SXS: %s - Relative redirection plus env var expansion.\n",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                __FUNCTION__);

            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if (askd.Flags & ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT) {
            INTERNAL_ERROR_CHECK(!(askd.Flags & ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT));
            GetAssemblyStorageRootFlags |= RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT;
        }
        if (askd.Flags & ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT){
            GetAssemblyStorageRootFlags |= RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT;
        }

        Status = RtlGetAssemblyStorageRoot(
                        GetAssemblyStorageRootFlags,
                        ActivationContext,
                        askd.AssemblyRosterIndex,
                        &AssemblyStorageRoot,
                        &RtlpAssemblyStorageMapResolutionDefaultCallback,
                        (PVOID) &InnerStatus);
        if (!NT_SUCCESS(Status)) {
            if ((Status == STATUS_CANCELLED) && (!NT_SUCCESS(InnerStatus)))
                Status = InnerStatus;

            goto Exit;
        }
    }

    PathSegmentArray = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) askd.SectionBase) + DllRedirData->PathSegmentOffset);
    TotalLength = 0;
    PathSegmentCount = DllRedirData->PathSegmentCount;

    for (i=0; i != PathSegmentCount; i++) {
        const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT *PathSegment = &PathSegmentArray[i];

        // If the character array is outside the bounds of the section, something's hosed.
        if ((((ULONG) PathSegmentArray[i].Offset) > askd.SectionTotalLength) ||
            (PathSegmentArray[i].Offset > (MAXULONG - PathSegmentArray[i].Length)) ||
            (((ULONG) (PathSegmentArray[i].Offset + PathSegmentArray[i].Length)) > askd.SectionTotalLength)) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s - path segment %lu at %p (offset: %ld, length: %lu, bounds: %lu) buffer is outside section bounds\n",
                __FUNCTION__,
                i,
                PathSegment->Offset,
                PathSegment->Offset,
                PathSegment->Length,
                askd.SectionTotalLength);
#endif // DBG
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        TotalLength += (RTL_STRING_LENGTH_TYPE)PathSegment->Length;
        if (TotalLength >= MAXUSHORT) { // everytime TotalLength is changed, needs to check whether it is out of range.
            Status = STATUS_NAME_TOO_LONG;
        }
    }
    if (AssemblyStorageRoot != NULL) {
        TotalLength += AssemblyStorageRoot->Length;
        if (TotalLength >= MAXUSHORT)
            Status = STATUS_NAME_TOO_LONG;
    }

    //
    // TotalLength is an approximation, the better the approx, the better perf, but
    // it does not need to be exact.
    // Jaykrell May 2002
    //
    IFNOT_NTSUCCESS_EXIT(RtlEnsureUnicodeStringBufferSizeBytes(FullPathResult, (RTL_STRING_LENGTH_TYPE)TotalLength));
    if (AssemblyStorageRoot != NULL)
        IFNOT_NTSUCCESS_EXIT(RtlAssignUnicodeStringBuffer(FullPathResult, AssemblyStorageRoot));

    for (i=0; i != PathSegmentCount; i++) {
        UNICODE_STRING PathSegmentString;
        const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT *PathSegment = &PathSegmentArray[i];

        PathSegmentString.Length = (RTL_STRING_LENGTH_TYPE)PathSegment->Length;
        PathSegmentString.Buffer = (PWSTR)(((ULONG_PTR) askd.SectionBase) + PathSegment->Offset);
        IFNOT_NTSUCCESS_EXIT(RtlAppendUnicodeStringBuffer(FullPathResult, &PathSegmentString));
    }

    if (!(DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME))  {
        if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL) {
            // only in this case, FileName needs to be reseted
            RTL_STRING_LENGTH_TYPE PrefixLength;

            //
            // get the leaf filename
            //
            Status = RtlFindCharInUnicodeString(
                            RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                            FileName,
                            &RtlDosPathSeperatorsString,
                            &PrefixLength);
            if (!NT_SUCCESS(Status)) {
                INTERNAL_ERROR_CHECK(Status != STATUS_NOT_FOUND);
                goto Exit;
            }

            FileName->Length = FileName->Length - PrefixLength - sizeof(WCHAR);
            FileName->Buffer = FileName->Buffer + (PrefixLength / sizeof(WCHAR)) + 1;
        }

        TotalLength += FileName->Length;
        if (TotalLength >= MAXUSHORT) {
            Status = STATUS_NAME_TOO_LONG;
            goto Exit;
        }

        IFNOT_NTSUCCESS_EXIT(RtlAppendUnicodeStringBuffer(FullPathResult, FileName));
    }

    if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND) {
        //
        // Apply any environment strings as necessary (rare case),
        // in this case, ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT must not been set
        //

        IFNOT_NTSUCCESS_EXIT(sxsisol_ExpandEnvironmentStrings_UEx(NULL, &(FullPathResult->String), &EnvironmentExpandedDllPathBuffer));

        //
        // TotalLength does not account for this. Jaykrell May 2002
        //
        IFNOT_NTSUCCESS_EXIT(RtlAssignUnicodeStringBuffer(FullPathResult, &EnvironmentExpandedDllPathBuffer.String));
    }

    if (OutFlags != NULL)
        *OutFlags |= RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_ACTCTX_REDIRECT;

    Status = STATUS_SUCCESS;
Exit:
    ASSERT(Status != STATUS_INTERNAL_ERROR);

    RtlFreeUnicodeStringBuffer(&EnvironmentExpandedDllPathBuffer);
    if (ActivationContext != NULL)
        RtlReleaseActivationContext(ActivationContext);

    return Status;
}

NTSTATUS
sxsisol_ExpandEnvironmentStrings_UEx(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PRTL_UNICODE_STRING_BUFFER Destination
    )
//++
//
//  Routine Description:
//
//      Wrapper around RtlExpandEnvironmentStrings_U which handles
//      dynamic allocation/resizing of the output buffer.
//
//  Arguments:
//
//      Environment
//          Optional environment block to query.
//
//      Source
//          Source string with replacement strings to use.
//
//      Destination
//          RTL_UNICODE_STRING_BUFFER into which the translated
//          string is written.
//
//  Return Value:
//
//      NTSTATUS indicating the overall success/failure of the call.
//
//--

{
    ULONG RequiredLengthBytes;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    UNICODE_STRING EmptyBuffer;

    PARAMETER_CHECK(Source != NULL);
    PARAMETER_CHECK(Destination != NULL);
    PARAMETER_CHECK(Source != &Destination->String);

    if (Source->Length == 0) {
        Status = RtlAssignUnicodeStringBuffer(Destination, Source);
        goto Exit;
    }

    RtlInitEmptyUnicodeString(&EmptyBuffer, NULL, 0);

    RtlAcquirePebLock();
    __try {
        Status = RtlExpandEnvironmentStrings_U(Environment, Source, &EmptyBuffer, &RequiredLengthBytes);
        if ((!NT_SUCCESS(Status)) &&
            (Status != STATUS_BUFFER_TOO_SMALL)) {
            __leave;
        }
        if (RequiredLengthBytes > UNICODE_STRING_MAX_BYTES) {
            Status = STATUS_NAME_TOO_LONG;
            __leave;
        }
        ASSERT(Status == STATUS_BUFFER_TOO_SMALL);
        Status = RtlEnsureUnicodeStringBufferSizeBytes(Destination, RequiredLengthBytes + sizeof(UNICODE_NULL));
        if (!NT_SUCCESS(Status)) {
            __leave;
        }
        Status = RtlExpandEnvironmentStrings_U(NULL, Source, &Destination->String, NULL);
        ASSERT(NT_SUCCESS(Status)); // the environment variable changed with the peb lock held?
        if (!NT_SUCCESS(Status)) {
            __leave;
        }

        Status = STATUS_SUCCESS;
    } __finally {
        RtlReleasePebLock();
    }

Exit:
    ASSERT(Status != STATUS_INTERNAL_ERROR);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsstoragecpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsstoragecpp.cpp

Abstract:

    C++ wrapper source file for sxsstorage.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsstorage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsquery.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsquery.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of query functions over activation contexts

Author:

    Michael Grier (MGrier) 1/18/2001

Revision History:

    1/18/2001 - MGrier  - initial; split off from sxsactctx.c.
    3/15/2001 - xiaoyuw - add support query for Assembly of Actctx and files of Assembly info
    5/2001 - JayKrell - more query support (from hmodule, from address, noaddref)

--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"
#include "ldrp.h"

VOID
RtlpLocateActivationContextSectionForQuery(
    OUT PULONG                   Disposition,
    OUT NTSTATUS*                Status,
    PVOID                        Buffer,
    SIZE_T                       InLength,
    PSIZE_T                      OutLength OPTIONAL,
    SIZE_T                       MinimumLength,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN CONST GUID *              ExtensionGuid OPTIONAL,
    IN ULONG                     Id,
    OUT PCVOID *                 SectionData,
    OUT ULONG *                  SectionLength
    )
{
#define RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE (1)
#define RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN   (2)
    ASSERT(Status != NULL);
    ASSERT(Disposition != NULL);

    if (ActivationContextData != NULL) {
        *Status = RtlpLocateActivationContextSection(ActivationContextData, ExtensionGuid, Id, SectionData, SectionLength);
        if (*Status != STATUS_SXS_SECTION_NOT_FOUND) {
            if (NT_SUCCESS(*Status))
                *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE;
            else
                *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN;
            return;
        }
    }
    *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN;

    if (MinimumLength > InLength) {
        *Status = STATUS_BUFFER_TOO_SMALL;
        return;
    }
    RtlZeroMemory(Buffer, MinimumLength);
    if (OutLength != NULL)
        *OutLength = MinimumLength;
    *Status = STATUS_SUCCESS;
}

NTSTATUS
RtlpCrackActivationContextStringSectionHeader(
    IN PCVOID SectionBase,
    IN SIZE_T SectionLength,
    OUT ULONG *FormatVersion OPTIONAL,
    OUT ULONG *DataFormatVersion OPTIONAL,
    OUT ULONG *SectionFlags OPTIONAL,
    OUT ULONG *ElementCount OPTIONAL,
    OUT PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY *Elements OPTIONAL,
    OUT ULONG *HashAlgorithm OPTIONAL,
    OUT PCVOID *SearchStructure OPTIONAL,
    OUT ULONG *UserDataLength OPTIONAL,
    OUT PCVOID *UserData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR; // in case someone forgets to set it...
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) SectionBase;

    if (FormatVersion != NULL)
        *FormatVersion = 0;

    if (DataFormatVersion != NULL)
        *DataFormatVersion = 0;

    if (SectionFlags != NULL)
        *SectionFlags = 0;

    if (ElementCount != NULL)
        *ElementCount = 0;

    if (Elements != NULL)
        *Elements = NULL;

    if (HashAlgorithm != NULL)
        *HashAlgorithm = 0;

    if (SearchStructure != NULL)
        *SearchStructure = NULL;

    if (UserDataLength != NULL)
        *UserDataLength = 0;

    if (UserData != NULL)
        *UserData = NULL;

    if (SectionLength < (RTL_SIZEOF_THROUGH_FIELD(ACTIVATION_CONTEXT_STRING_SECTION_HEADER, HeaderSize))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p only %lu bytes long; that's not even enough for the 4-byte magic and 4-byte header length!\n",
            __FUNCTION__,
            SectionBase,
            SectionLength);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with wrong magic value\n"
            "   Expected %lu; got %lu\n",
            __FUNCTION__,
            ACTIVATION_CONTEXT_STRING_SECTION_MAGIC,
            Header->Magic);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Pedantic: check to see if the header size claimed includes the header size field so that we can safely use it.
    if (!RTL_CONTAINS_FIELD(Header, Header->HeaderSize, HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p claims %lu byte header size; that doesn't even include the HeaderSize member!\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Now we're just going to jump forward to the last known member that we expect to see; UserDataSize...
    if (!RTL_CONTAINS_FIELD(Header, Header->HeaderSize, UserDataSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p with too small of a header\n"
            "   HeaderSize: %lu\n"
            "   Required: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            RTL_SIZEOF_THROUGH_FIELD(ACTIVATION_CONTEXT_STRING_SECTION_HEADER, UserDataSize));

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->ElementListOffset != 0) &&
        (Header->ElementListOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with element list overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   ElementListOffset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->ElementListOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->SearchStructureOffset != 0) &&
        (Header->SearchStructureOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with search structure overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   SearchStructureOffset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->SearchStructureOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset != 0) &&
        (Header->UserDataOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   User Data Offset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->UserDataOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data too small\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu; needed: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize, sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset + Header->UserDataSize) > SectionLength) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data extending beyond section data\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu\n"
            "   UserDataOffset: %lu\n"
            "   Section size: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize,
            Header->UserDataOffset,
            SectionLength);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (FormatVersion != NULL)
        *FormatVersion = Header->FormatVersion;

    if (DataFormatVersion != NULL)
        *DataFormatVersion = Header->DataFormatVersion;

    if (SectionFlags != NULL)
        *SectionFlags = Header->Flags;

    if (ElementCount != NULL)
        *ElementCount = Header->ElementCount;

    if (Elements != NULL) {
        if (Header->ElementListOffset == 0)
            *Elements = NULL;
        else
            *Elements = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Header) + Header->ElementListOffset);
    }

    if (HashAlgorithm != NULL)
        *HashAlgorithm = Header->HashAlgorithm;

    if (SearchStructure != NULL) {
        if (Header->SearchStructureOffset == 0)
            *SearchStructure = NULL;
        else
            *SearchStructure = (PCVOID) (((ULONG_PTR) Header) + Header->SearchStructureOffset);
    }

    if (UserDataLength != NULL)
        *UserDataLength = Header->UserDataSize;

    if (UserData != NULL) {
        if (Header->UserDataOffset == 0)
            *UserData = NULL;
        else
            *UserData = (PCVOID) (((ULONG_PTR) Header) + Header->UserDataOffset);
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
RtlpGetActiveActivationContextApplicationDirectory(
    IN SIZE_T InLength,
    OUT PVOID OutBuffer,
    OUT SIZE_T *OutLength
    )
// This is never used.
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PCRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = NULL;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header = NULL;
    const PPEB Peb = NtCurrentPeb();
    const PTEB Teb = NtCurrentTeb();
    PCVOID pvTemp = NULL;
    ULONG ulTemp = 0;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION GlobalInfo = NULL;

    if (OutLength != NULL)
        *OutLength = 0;

    if (((InLength != 0) && (OutBuffer == NULL)) ||
        ((OutBuffer == NULL) && (OutLength == NULL))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s(): called with invalid parameters\n"
            "   InLength = %Iu\n"
            "   OutBuffer = %p\n"
            "   OutLength = %p\n",
            __FUNCTION__,
            InLength,
            OutBuffer,
            OutLength);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Frame = Teb->ActivationContextStack.ActiveFrame;

    if (Frame == NULL) {
        ActivationContextData = Peb->ActivationContextData;
    } else {
        ActivationContextData = Frame->ActivationContext->ActivationContextData;
    }

    // We need to find the assembly metadata section...
    Status = RtlpLocateActivationContextSection(ActivationContextData, NULL, ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, &pvTemp, &ulTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ulTemp < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information string section with header too small\n"
            "   Expected at least %lu; got %lu bytes\n",
            __FUNCTION__,
            sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER),
            ulTemp);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    Header = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) pvTemp;

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with wrong magic value\n"
            "   Expected %lu; got %lu\n",
            __FUNCTION__,
            ACTIVATION_CONTEXT_STRING_SECTION_MAGIC,
            Header->Magic);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataOffset < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data overlapping section header\n"
            "   Section header: %p\n"
            "   User Data Offset: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data too small\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu; needed: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize, sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset + Header->UserDataSize) > ulTemp) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data extending beyond section data\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu\n"
            "   UserDataOffset: %lu\n"
            "   Section size: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize,
            Header->UserDataOffset,
            ulTemp);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    GlobalInfo = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) (((ULONG_PTR) Header) + Header->UserDataOffset);

    if (GlobalInfo->Size < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section global data with size less than structure size\n"
            "   Section header: %p\n"
            "   Global Info: %p\n"
            "   Global Info Size: %lu\n"
            "   Structure size: %lu\n",
            __FUNCTION__,
            Header,
            GlobalInfo,
            GlobalInfo->Size,
            sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (GlobalInfo->ApplicationDirectoryOffset != 0) {
        if (GlobalInfo->ApplicationDirectoryOffset < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() found assembly information section global data with app dir offset within base structure\n"
                "   Section header: %p\n"
                "   GlobalInfo: %p\n"
                "   ApplicationDirectoryOffset: %lu\n",
                __FUNCTION__,
                Header,
                GlobalInfo,
                GlobalInfo->ApplicationDirectoryOffset);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if ((GlobalInfo->ApplicationDirectoryOffset + GlobalInfo->ApplicationDirectoryLength) > GlobalInfo->Size) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() found assembly information section global data with app dir extending beyond end of global data\n"
                "   Section header: %p\n"
                "   GlobalInfo: %p\n"
                "   ApplicationDirectoryOffset: %lu\n"
                "   ApplicationDirectoryLength: %lu\n"
                "   GlobalInfo size: %lu\n",
                __FUNCTION__,
                Header,
                GlobalInfo,
                GlobalInfo->ApplicationDirectoryOffset,
                GlobalInfo->ApplicationDirectoryLength,
                GlobalInfo->Size);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if (InLength < GlobalInfo->ApplicationDirectoryLength) {
            if (OutLength != NULL)
                *OutLength = GlobalInfo->ApplicationDirectoryLength;

            Status = STATUS_BUFFER_TOO_SMALL;
            goto Exit;
        }

        RtlCopyMemory(
            OutBuffer,
            (PVOID) (((ULONG_PTR) GlobalInfo) + GlobalInfo->ApplicationDirectoryOffset),
            GlobalInfo->ApplicationDirectoryLength);

        if (OutLength != NULL)
            *OutLength = GlobalInfo->ApplicationDirectoryLength;
    } else {
        // Hmm... there's just no application directory
        if (OutLength != NULL)
            *OutLength = 0; // I think we already did this but what the heck
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#define \
RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF (0x00000001)

NTSTATUS
RtlpQueryInformationActivationContextBasicInformation(
    IN ULONG                Flags,
    IN PCACTIVATION_CONTEXT ConstActivationContext,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN ULONG SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT ActivationContext = RTL_CONST_CAST(PACTIVATION_CONTEXT)(ConstActivationContext);
    PACTIVATION_CONTEXT_BASIC_INFORMATION Info = (PACTIVATION_CONTEXT_BASIC_INFORMATION) Buffer;

    if (OutLength != NULL)
        *OutLength = 0;

    if (SubInstanceIndex != 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid non-zero sub-instance index %lu\n",
            __FUNCTION__,
            SubInstanceIndex);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (InLength < sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION)) {
        if (OutLength != NULL) {
            *OutLength = sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION);
        }
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    if (ActivationContextData != NULL)
        Info->Flags = ActivationContextData->Flags;
    else
        Info->Flags = 0;

    if ((Flags & RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF) == 0) {
        RtlAddRefActivationContext(ActivationContext);
    }
    Info->ActivationContext = ActivationContext;

    if (OutLength != NULL)
        *OutLength = sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpQueryInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    ULONG SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT_DETAILED_INFORMATION Info = (PACTIVATION_CONTEXT_DETAILED_INFORMATION) Buffer;
    SIZE_T BytesNeeded = 0;
    PCVOID StringSectionHeader;
    ULONG StringSectionSize;
    ULONG DataFormatVersion;
    PCVOID UserData;
    ULONG UserDataSize;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION RootAssemblyInformation = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION AssemblyGlobalInformation = NULL;
    ULONG i;
    ULONG EntryCount;
    PWSTR Cursor = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;

    if (OutLength != NULL)
        *OutLength = 0;
    
    if (SubInstanceIndex != 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid non-zero sub-instance index %lu\n",
            __FUNCTION__,
            SubInstanceIndex);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(*Info),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
        &StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }
    Status = RtlpCrackActivationContextStringSectionHeader(
        StringSectionHeader,
        StringSectionSize,
        NULL,
        &DataFormatVersion,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &UserDataSize,
        &UserData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);

    EntryCount = AssemblyRosterHeader->EntryCount;

    // 1-based counting for Asseblies in the actctx
    for (i=1; i<EntryCount; i++) {
        if (AssemblyRosterEntryList[i].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT)
            break;
    }

    if (i == EntryCount) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found activation context data at %p with assembly roster that has no root\n",
            __FUNCTION__,
            ActivationContextData);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    RootAssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) ActivationContextData) + AssemblyRosterEntryList[i].AssemblyInformationOffset);
    AssemblyGlobalInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) UserData;

    // Ok, we have everything we could need.  Figure out the size of the buffer required.

    BytesNeeded = sizeof(ACTIVATION_CONTEXT_DETAILED_INFORMATION);

    if (RootAssemblyInformation->ManifestPathLength != 0)
        BytesNeeded += (RootAssemblyInformation->ManifestPathLength + sizeof(WCHAR));

    if (RootAssemblyInformation->PolicyPathLength != 0)
        BytesNeeded += (RootAssemblyInformation->PolicyPathLength + sizeof(WCHAR));

    if (AssemblyGlobalInformation->ApplicationDirectoryLength != 0)
        BytesNeeded += (AssemblyGlobalInformation->ApplicationDirectoryLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // Wow, it's all there and ready to go.  Let's fill in!

    Cursor = (PWSTR) (Info + 1);

    Info->dwFlags = ActivationContextData->Flags;
    Info->ulFormatVersion = ActivationContextData->FormatVersion;
    Info->ulAssemblyCount = AssemblyRosterHeader->EntryCount - 1;
    Info->ulRootManifestPathType = RootAssemblyInformation->ManifestPathType;
    Info->ulRootManifestPathChars = (RootAssemblyInformation->ManifestPathLength / sizeof(WCHAR));
    Info->lpRootManifestPath = NULL;
    Info->ulRootConfigurationPathType = RootAssemblyInformation->PolicyPathType;
    Info->ulRootConfigurationPathChars = (RootAssemblyInformation->PolicyPathLength / sizeof(WCHAR));
    Info->lpRootConfigurationPath = NULL;
    Info->ulAppDirPathType = AssemblyGlobalInformation->ApplicationDirectoryPathType;
    Info->ulAppDirPathChars = (AssemblyGlobalInformation->ApplicationDirectoryLength / sizeof(WCHAR));
    Info->lpAppDirPath = NULL;

    // And copy the strings...    
    if (RootAssemblyInformation->ManifestPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + RootAssemblyInformation->ManifestPathOffset),
            RootAssemblyInformation->ManifestPathLength);
        Info->lpRootManifestPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + RootAssemblyInformation->ManifestPathLength);
        *Cursor++ = L'\0';
    }
    
    if (RootAssemblyInformation->PolicyPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + RootAssemblyInformation->PolicyPathOffset),
            RootAssemblyInformation->PolicyPathLength);
        Info->lpRootConfigurationPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + RootAssemblyInformation->PolicyPathLength);
        *Cursor++ = L'\0';
    }
    
    if (AssemblyGlobalInformation->ApplicationDirectoryLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) AssemblyGlobalInformation) + AssemblyGlobalInformation->ApplicationDirectoryOffset),
            AssemblyGlobalInformation->ApplicationDirectoryLength);
        Info->lpAppDirPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemblyGlobalInformation->ApplicationDirectoryLength);
        *Cursor++ = L'\0';
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    if (OutLength != NULL)
        *OutLength = BytesNeeded;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS 
RtlpQueryAssemblyInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    ULONG SubInstanceIndex,     // 0-based index of assembly
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    SIZE_T BytesNeeded = 0;
    PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION Info= (PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)Buffer;
    PCVOID StringSectionHeader;
    ULONG StringSectionSize;
    PWSTR Cursor = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemlbyDataInfo = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;

    if (OutLength != NULL)
        *OutLength = 0;
    
    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);
    
    if (SubInstanceIndex > AssemblyRosterHeader->EntryCount) // AssemblyRosterHeader->EntryCount is 1-based, 
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid sub-instance index %lu out of %lu Assemblies in the Acitvation Context\n",
            __FUNCTION__,
            SubInstanceIndex, 
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    AssemlbyDataInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)((ULONG_PTR)ActivationContextData + AssemblyRosterEntryList[SubInstanceIndex].AssemblyInformationOffset);

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
        &StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }

    // Figure out the size of the buffer required.
    BytesNeeded = sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION);

    if (AssemlbyDataInfo->EncodedAssemblyIdentityLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->EncodedAssemblyIdentityLength + sizeof(WCHAR));

    if (AssemlbyDataInfo->ManifestPathLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->ManifestPathLength + sizeof(WCHAR));
    
    if (AssemlbyDataInfo->PolicyPathLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->PolicyPathLength + sizeof(WCHAR));

    if (AssemlbyDataInfo->AssemblyDirectoryNameLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->AssemblyDirectoryNameLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // fill in the struct

    Cursor = (PWSTR) (Info + 1);
    Info->ulFlags = AssemlbyDataInfo->Flags;
    Info->ulEncodedAssemblyIdentityLength   = AssemlbyDataInfo->EncodedAssemblyIdentityLength;
    Info->ulManifestPathType                = AssemlbyDataInfo->ManifestPathType;
    Info->ulManifestPathLength              = AssemlbyDataInfo->ManifestPathLength ;
    Info->liManifestLastWriteTime           = AssemlbyDataInfo->ManifestLastWriteTime;
    Info->ulPolicyPathType                  = AssemlbyDataInfo->PolicyPathType;
    Info->ulPolicyPathLength                = AssemlbyDataInfo->PolicyPathLength;
    Info->liPolicyLastWriteTime             = AssemlbyDataInfo->PolicyLastWriteTime;
    Info->ulMetadataSatelliteRosterIndex    = AssemlbyDataInfo->MetadataSatelliteRosterIndex;
    
    Info->ulManifestVersionMajor            = AssemlbyDataInfo->ManifestVersionMajor;
    Info->ulManifestVersionMinor            = AssemlbyDataInfo->ManifestVersionMinor;
    Info->ulPolicyVersionMajor              = AssemlbyDataInfo->PolicyVersionMajor;
    Info->ulPolicyVersionMinor              = AssemlbyDataInfo->PolicyVersionMinor;
    Info->ulAssemblyDirectoryNameLength     = AssemlbyDataInfo->AssemblyDirectoryNameLength;          // in bytes    

    Info->lpAssemblyEncodedAssemblyIdentity = NULL;
    Info->lpAssemblyManifestPath            = NULL;
    Info->lpAssemblyPolicyPath              = NULL;
    Info->lpAssemblyDirectoryName           = NULL;
    Info->ulFileCount                       = AssemlbyDataInfo->NumOfFilesInAssembly;

    if (AssemlbyDataInfo->EncodedAssemblyIdentityLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->EncodedAssemblyIdentityOffset),
            AssemlbyDataInfo->EncodedAssemblyIdentityLength);
        Info->lpAssemblyEncodedAssemblyIdentity = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->EncodedAssemblyIdentityLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->ManifestPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->ManifestPathOffset),
            AssemlbyDataInfo->ManifestPathLength);
        Info->lpAssemblyManifestPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->ManifestPathLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->PolicyPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->PolicyPathOffset),
            AssemlbyDataInfo->PolicyPathLength);
        Info->lpAssemblyPolicyPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->PolicyPathLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->AssemblyDirectoryNameLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->AssemblyDirectoryNameOffset),
            AssemlbyDataInfo->AssemblyDirectoryNameLength);
        Info->lpAssemblyDirectoryName = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->AssemblyDirectoryNameLength);
        *Cursor++ = L'\0';
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    if (OutLength != NULL)
        *OutLength = BytesNeeded;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpQueryFilesInAssemblyInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    PCACTIVATION_CONTEXT_QUERY_INDEX SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{    
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    SIZE_T BytesNeeded = 0;
    PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION Info= (PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION)Buffer;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER StringSectionHeader=NULL;
    ULONG StringSectionSize;
    PWSTR Cursor = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION EntryData = NULL;
    ULONG i, CounterForFilesFoundInSpecifiedAssembly;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;


    if (OutLength != NULL)
        *OutLength = 0;
    
    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);

    if (SubInstanceIndex->ulAssemblyIndex >= AssemblyRosterHeader->EntryCount - 1)// AssemblyRosterHeader->EntryCount is 1-based,                                                                               
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid sub-instance index %lu out of %lu Assemblies in the Acitvation Context\n",
            __FUNCTION__,
            SubInstanceIndex->ulAssemblyIndex, 
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }    

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
        (PCVOID*)&StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }

    if (SubInstanceIndex->ulFileIndexInAssembly >= StringSectionHeader->ElementCount) 
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid file index (%d) in Assembly (%d)\n",
            __FUNCTION__,
            SubInstanceIndex->ulFileIndexInAssembly, 
            SubInstanceIndex->ulAssemblyIndex, 
            StringSectionHeader->ElementCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StringSectionHeader->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)(((ULONG_PTR)StringSectionHeader) + StringSectionHeader->ElementListOffset);
    else
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Exit;
    } 
    
    CounterForFilesFoundInSpecifiedAssembly = 0 ;
    EntryData = NULL;
    for ( i = 0 ; i < StringSectionHeader->ElementCount; i++ ) 
    {
        // for a specified assembly
        if (ElementList[i].AssemblyRosterIndex == SubInstanceIndex->ulAssemblyIndex + 1)
        {       
            // for specified file in this assembly   
            if (CounterForFilesFoundInSpecifiedAssembly == SubInstanceIndex->ulFileIndexInAssembly) 
            {
                if (ElementList[i].Offset != 0) 
                {
                    // we found the right one                    
                    EntryData = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION)(((ULONG_PTR)StringSectionHeader) + ElementList[i].Offset);
                    break;
                }
            }
            CounterForFilesFoundInSpecifiedAssembly ++;            
        }
    }
    if (EntryData == NULL )
    {        
        Status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    // figure out buffer size needed

    BytesNeeded = sizeof(ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION);

    if (ElementList[i].KeyLength != 0)
        BytesNeeded += (ElementList[i].KeyLength + sizeof(WCHAR)); // for filename       

    if (EntryData->TotalPathLength != 0)
        BytesNeeded += (EntryData->TotalPathLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) 
    {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // let us fill in
    
    Cursor = (PWSTR) (Info + 1);
    Info->ulFlags = EntryData->Flags;
    Info->ulFilenameLength = ElementList[i].KeyLength;
    Info->ulPathLength = EntryData->TotalPathLength;

    Info->lpFileName = NULL;
    Info->lpFilePath = NULL;   

    // copy the strings...

    // copy the filename
    if (ElementList[i].KeyLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + ElementList[i].KeyOffset),
            ElementList[i].KeyLength);
        Info->lpFileName = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + ElementList[i].KeyLength);
        *Cursor++ = L'\0';
    }

    // concatenate the path
    if (EntryData->TotalPathLength != 0) {
        if (EntryData->PathSegmentOffset != 0)
            PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT)(StringSectionHeader + EntryData->PathSegmentOffset);

        if (PathSegments != NULL)
        {  
            Info->lpFilePath = Cursor;
            for (i=0; i < EntryData->PathSegmentCount; i++)
            {
                if (PathSegments[i].Offset != 0)
                {                                
                    RtlCopyMemory(
                        Cursor,
                        (PVOID) (((ULONG_PTR) StringSectionHeader) + PathSegments[i].Offset),
                        PathSegments[i].Length);
                    Cursor = (PWSTR) (((ULONG_PTR) Cursor) + PathSegments[i].Length);
                }
            }
            *Cursor++ = L'\0';
        }
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlQueryInformationActivationContext(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT ActivationContext,
    IN PVOID SubInstanceIndex,
    IN ACTIVATION_CONTEXT_INFO_CLASS InfoClass,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    BOOLEAN  LoaderLockLocked = FALSE;
    PVOID    LoaderLockCookie = NULL;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;

    __try {

        if (OutLength != NULL) {
            *OutLength = 0;
        }

        if ((Flags &
                ~(  RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF
                 )) != 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed invalid flags (0x%08lx)\n",
                __FUNCTION__,
                Flags);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;
        }

        //
        // REVIEW do we really care?
        // And check that no other infoclass really does include an optionally addrefed actctx.
        //
        if ((Flags & RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF) != 0
            && InfoClass != ActivationContextBasicInformation) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed meaningless flags/class combination (0x%08lx/0x%08lx)\n",
                __FUNCTION__,
                Flags,
                InfoClass);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;
        }

        if ((InfoClass != ActivationContextBasicInformation) &&
            (InfoClass != ActivationContextDetailedInformation) && 
            (InfoClass != AssemblyDetailedInformationInActivationContxt ) &&
            (InfoClass != FileInformationInAssemblyOfAssemblyInActivationContxt))
        {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller asked for unknown information class %lu\n",
                __FUNCTION__,
                InfoClass);
            Status = STATUS_INVALID_PARAMETER_3;
            goto Exit;
        }

        if ((InLength != 0) && (Buffer == NULL)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller passed nonzero buffer length but NULL buffer pointer\n",
                __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER_4;
            goto Exit;
        }

        if ((InLength == 0) && (OutLength == NULL)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller supplied no buffer to populate and no place to return required byte count\n",
                __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER_6;
            goto Exit;
        }

        switch (
            Flags & (
                  RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT
                | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE
                | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS
                )) {

        default:
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed invalid flags (0x%08lx)\n",
                __FUNCTION__,
                Flags);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;

        case 0:
            break;

        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT:
            {
                PCRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;

                if (ActivationContext != NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - caller asked to use active activation context but passed %p\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                Frame = NtCurrentTeb()->ActivationContextStack.ActiveFrame;

                if (Frame != NULL) {
                    ActivationContext = Frame->ActivationContext;
                }
            }
            break;

        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS:
            {
                PVOID DllHandle;

                if (ActivationContext == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller asked to use activation context from address in .dll but passed NULL\n",
                        __FUNCTION__
                        );
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                Status = LdrLockLoaderLock(0, NULL, &LoaderLockCookie);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                LoaderLockLocked = TRUE;
                DllHandle = RtlPcToFileHeader((PVOID)(PCVOID)ActivationContext, &DllHandle);
                if (DllHandle == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller passed invalid address, not in any .dll (%p)\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_DLL_NOT_FOUND; // REVIEW
                    goto Exit;
                }
                ActivationContext = (PCACTIVATION_CONTEXT)DllHandle;
            }
            // FALLTHROUGH
        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE:
            {
                PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;

                if (ActivationContext == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller asked to use activation context from hmodule but passed NULL\n",
                        __FUNCTION__
                        );
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                if (!LoaderLockLocked) {
                    Status = LdrLockLoaderLock(0, NULL, &LoaderLockCookie);
                    if (!NT_SUCCESS(Status))
                        goto Exit;
                    LoaderLockLocked = TRUE;
                }
                if (!LdrpCheckForLoadedDllHandle((PVOID)(PCVOID)ActivationContext, &LdrDataTableEntry)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller passed invalid hmodule (%p)\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_DLL_NOT_FOUND; // REVIEW
                    goto Exit;
                }
                ActivationContext = LdrDataTableEntry->EntryPointActivationContext;
            }
            break;
        }

        Status = RtlpGetActivationContextData(
            RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY,
            ActivationContext,
            NULL,
            &ActivationContextData);
        if (!NT_SUCCESS(Status))
            goto Exit;

        if (ActivationContextData == NULL) {
            switch (InfoClass) {
                case ActivationContextBasicInformation:
                default:
                    break;

                case ActivationContextDetailedInformation:
                case AssemblyDetailedInformationInActivationContxt:
                case FileInformationInAssemblyOfAssemblyInActivationContxt:
                    Status = STATUS_INVALID_PARAMETER_1;
                    goto Exit;
            }
        }

        switch (InfoClass) {
        case ActivationContextBasicInformation:
            {
                ULONG BasicInfoFlags = 0;
                if ((Flags & RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF) != 0) {
                    BasicInfoFlags |= RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF;
                }
                Status = RtlpQueryInformationActivationContextBasicInformation(
                    BasicInfoFlags,
                    ActivationContext,
                    ActivationContextData,
                    0, 
                    Buffer, 
                    InLength, 
                    OutLength
                    );
                if (!NT_SUCCESS(Status))
                    goto Exit;
            }
            break;

        case ActivationContextDetailedInformation:
            Status = RtlpQueryInformationActivationContextDetailedInformation(
                ActivationContextData,
                0,
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        case AssemblyDetailedInformationInActivationContxt:
            if (SubInstanceIndex == NULL) {
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
            Status = RtlpQueryAssemblyInformationActivationContextDetailedInformation(
                ActivationContextData,
                *((ULONG *)SubInstanceIndex),
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        case FileInformationInAssemblyOfAssemblyInActivationContxt:
            Status = RtlpQueryFilesInAssemblyInformationActivationContextDetailedInformation(
                ActivationContextData,
                ((ACTIVATION_CONTEXT_QUERY_INDEX *)SubInstanceIndex),
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        default:
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - internal coding error; missing switch statement branch for InfoClass == %lu\n",
                __FUNCTION__,
                InfoClass);
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        Status = STATUS_SUCCESS;
Exit:
        ;
    } __finally {
        if (LoaderLockLocked)
            LdrUnlockLoaderLock(0, LoaderLockCookie);
    }
    return Status;
}


NTSTATUS
NTAPI
RtlQueryInformationActiveActivationContext(
    IN ACTIVATION_CONTEXT_INFO_CLASS InfoClass,
    OUT PVOID OutBuffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    return RtlQueryInformationActivationContext(
        RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
        NULL,
        0,
        InfoClass,
        OutBuffer,
        InLength,
        OutLength);
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsp.h

Abstract:

    Include file for ntdll-private definitions of Side-By-Side data structures.

Author:

    Michael J. Grier (mgrier) October 26, 2000

Environment:


Revision History:

--*/

#if !defined(_NTDLL_SXSP_H_INCLUDED_)
#define _NTDLL_SXSP_H_INCLUDED_

#include <nturtl.h>
#include <sxstypes.h>

typedef const void *PCVOID;

//
//  Private definitions for activation context management stuff
//

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

//
//  Codes for the STATUS_SXS_CORRUPTION exception
//

#define SXS_CORRUPTION_CODE_FRAMELIST (1)
#define SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC (1)
#define SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT (2)

//  SXS_CORRUPTION_CODE_FRAMELIST:
//
//      ExceptionInformation[0] == SXS_CORRUPTION_CODE_FRAMELIST
//      ExceptionInformation[1] == one of: SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC, SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT
//      ExceptionInformation[2] == Framelist list head in TEB
//      ExceptionInformation[3] == Framelist found to be corrupt

#define SXS_CORRUPTION_ACTCTX_LIST (2)
#define SXS_CORRUPTION_ACTCTX_LIST_RELEASING_NOT_IN_LIVE_LIST (1)

//  SXS_CORRUPTION_ACTCTX_LIST
//
//      ExceptionInformation[0] = SXS_CORRUPTION_ACTCTX_LIST
//      ExceptionInformation[1] = One of SXS_CORRUPTION_ACTCTX_LIST_*
//      ExceptionInformation[2] = Pointer to the list of live activation contexts
//      ExceptionInformation[3] = Activation context not found in live list

#define SXS_CORRUPTION_ACTCTX_MAGIC (1)
#define SXS_CORRUPTION_ACTCTX_MAGIC_NOT_MATCHED (1)
#define SXS_CORRUPTION_ACTCTX_MAGIC_NOT_ALIGNED (2)

//  SXS_CORRUPTION_ACTCTX_MAGIC
//
//      ExceptionInformation[0] = SXS_CORRUPTION_ACTCTX_MAGIC
//      ExceptionInformation[1] = SXS_CORRUPTION_MAGIC_NOT_MATCHED or SXS_CORRUPTION_ACTCTX_MAGIC_NOT_ALIGNED
//      ExceptionInformation[2] = Pointer to the activation context that fails


typedef struct _RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME {
    RTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    ULONG_PTR Cookie;
    PVOID ActivationStackBackTrace[8];
} RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME;

NTSYSAPI
VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    IN ULONG CallbackReason,
    IN OUT ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA *CallbackData,
    IN PVOID CallbackContext
    );

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {
    ULONG Flags;
    UNICODE_STRING DosPath;         // stored with a trailing unicode null
    HANDLE Handle;                  // open file handle on the directory to lock it down
} ASSEMBLY_STORAGE_MAP_ENTRY, *PASSEMBLY_STORAGE_MAP_ENTRY;

#define ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED (0x00000001)

typedef struct _ASSEMBLY_STORAGE_MAP {
    ULONG Flags;
    ULONG AssemblyCount;
    PASSEMBLY_STORAGE_MAP_ENTRY *AssemblyArray;
} ASSEMBLY_STORAGE_MAP, *PASSEMBLY_STORAGE_MAP;

#define ACTCTX_RELEASE_STACK_DEPTH (4)
#define ACTCTX_RELEASE_STACK_SLOTS (4)

typedef struct _ACTIVATION_CONTEXT {
    LONG RefCount;
    ULONG Flags;
    LIST_ENTRY Links;
    PCACTIVATION_CONTEXT_DATA ActivationContextData;
    PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine;
    PVOID NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ASSEMBLY_STORAGE_MAP StorageMap;
    PASSEMBLY_STORAGE_MAP_ENTRY InlineStorageMapEntries[32];
    ULONG StackTraceIndex;
    PVOID StackTraces[ACTCTX_RELEASE_STACK_SLOTS][ACTCTX_RELEASE_STACK_DEPTH];
} ACTIVATION_CONTEXT;

#define ACTIVATION_CONTEXT_NOTIFICATION_DESTROY_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_DESTROY >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_DESTROY_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_DESTROY & 0x1f)))

#define ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY & 0x1f)))

#define ACTIVATION_CONTEXT_NOTIFICATION_USED_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_USED >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_USED_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_USED & 0x1f)))

#define HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_SENT(_pac, _nt) (((_pac)->SentNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] & ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK) != 0)
#define HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_DISABLED(_pac, _nt) (((_pac)->DisabledNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] & ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK) != 0)

#define ACTIVATION_CONTEXT_SHOULD_SEND_NOTIFICATION(_pac, _nt) \
 ((!IS_SPECIAL_ACTCTX(_pac)) && ((_pac)->NotificationRoutine != NULL) && ((!HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_SENT((_pac), _nt)) || (!HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_DISABLED((_pac), _nt))))

#define RECORD_ACTIVATION_CONTEXT_NOTIFICATION_SENT(_pac, _nt) { (_pac)->SentNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] |= ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK; }
#define RECORD_ACTIVATION_CONTEXT_NOTIFICATION_DISABLED(_pac, _nt) { (_pac)->DisabledNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] |= ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK; }

#define SEND_ACTIVATION_CONTEXT_NOTIFICATION(_pac, _nt, _data) \
{ \
    if (ACTIVATION_CONTEXT_SHOULD_SEND_NOTIFICATION((_pac), _nt)) { \
        BOOLEAN __DisableNotification = FALSE; \
        (*((_pac)->NotificationRoutine))( \
            ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt, \
            (_pac), \
            (_pac)->ActivationContextData, \
            (_pac)->NotificationContext, \
            (_data), \
            &__DisableNotification); \
        RECORD_ACTIVATION_CONTEXT_NOTIFICATION_SENT((_pac), _nt); \
        if (__DisableNotification) \
            RECORD_ACTIVATION_CONTEXT_NOTIFICATION_DISABLED((_pac), _nt); \
    } \
}

//
//  Flags for ACTIVATION_CONTEXT
//

#define ACTIVATION_CONTEXT_ZOMBIFIED          (0x00000001)
#define ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED (0x00000002)

//
//  Because activating an activation context may require a heap allocation
//  which may fail, sometimes (e.g. dispatching an APC) we must still
//  go forward with the operation.  If there is an opportunity to
//  report the failure to activate back to the user, that should be done.
//  However, as in activating the necessary context prior to dispatching
//  an APC back to the user mode code, if the allocation fails, there is
//  no caller to whom to report the error.
//
//  To alleviate this problem, failure paths should disable lookups on
//  the current stack frame via the RtlSetActivationContextSearchState()
//  API.  Calling RtlSetActivationContextSearchState(FALSE) marks
//  the active frame as having lookups disabled.  Attempts to query
//  the activation context stack will fail with the
//  STATUS_SXS_THREAD_QUERIES_DISABLED.
//
//  This means that attempts to load libraries from within APCs where this
//  is true will fail, but it's surely better than either silently not
//  calling the APC or calling the APC with the wrong activation context
//  active.
//

#define ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC 'tslF'

typedef struct _ACTIVATION_CONTEXT_STACK_FRAMELIST {
    ULONG Magic;    // Bit pattern to recognize a framelist
    ULONG FramesInUse;
    LIST_ENTRY Links;
    ULONG Flags;
    ULONG NotFramesInUse; // Inverted bits of FramesInUse.  Useful for debugging.
    RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frames[32];
} ACTIVATION_CONTEXT_STACK_FRAMELIST, *PACTIVATION_CONTEXT_STACK_FRAMELIST;

#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_SIZE        (0x00000001)
#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_OFFSETS     (0x00000002)
#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_READONLY    (0x00000004)

NTSTATUS
RtlpValidateActivationContextData(
    IN ULONG Flags OPTIONAL,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN SIZE_T BufferSize OPTIONAL
    );

NTSTATUS
RtlpFindUnicodeStringInSection(
    IN const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header,
    IN SIZE_T SectionSize,
    IN PCUNICODE_STRING StringToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut OPTIONAL,
    IN OUT PULONG HashAlgorithm,
    IN OUT PULONG PseudoKey,
    OUT PULONG UserDataSize OPTIONAL,
    OUT VOID CONST ** UserData OPTIONAL
    );

NTSTATUS
RtlpFindGuidInSection(
    IN const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED * Header,
    IN const GUID *GuidToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut OPTIONAL
    );

NTSTATUS
RtlpLocateActivationContextSection(
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN const GUID *ExtensionGuid,
    IN ULONG Id,
    OUT PCVOID *SectionData,
    OUT ULONG *SectionLength
    );

NTSTATUS
RtlpCrackActivationContextStringSectionHeader(
    IN CONST VOID *SectionBase,
    IN SIZE_T SectionLength,
    OUT ULONG *FormatVersion OPTIONAL,
    OUT ULONG *DataFormatVersion OPTIONAL,
    OUT ULONG *SectionFlags OPTIONAL,
    OUT ULONG *ElementCount OPTIONAL,
    OUT PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY *Elements OPTIONAL,
    OUT ULONG *HashAlgorithm OPTIONAL,
    OUT VOID CONST **SearchStructure OPTIONAL,
    OUT ULONG *UserDataSize OPTIONAL,
    OUT VOID CONST **UserData OPTIONAL
    );

NTSTATUS
RtlpGetActiveActivationContextApplicationDirectory(
    IN SIZE_T InLength,
    OUT PVOID OutBuffer,
    OUT SIZE_T *OutLength
    );

NTSTATUS
RtlpFindNextActivationContextSection(
    PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PCVOID *SectionData,
    ULONG *SectionLength,
    PACTIVATION_CONTEXT *ActivationContextOut
    );

NTSTATUS
RtlpAllocateActivationContextStackFrame(
    ULONG Flags,
    PTEB Teb,
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME *Frame
    );

VOID
RtlpFreeActivationContextStackFrame(
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    );

PSTR
RtlpFormatGuidANSI(
    const GUID *Guid,
    PSTR Buffer,
    SIZE_T BufferLength
    );

#define RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActCtx) \
    {  \
        ASSERT((ActCtx) != &RtlpTheEmptyActivationContext); \
        if ((ActCtx) == &RtlpTheEmptyActivationContext) {   \
            DbgPrintEx( \
                DPFLTR_SXS_ID, \
                DPFLTR_ERROR_LEVEL, \
                "SXS: %s() passed the empty activation context\n", __FUNCTION__); \
            Status = STATUS_INVALID_PARAMETER; \
            goto Exit; \
        } \
    }

#define RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT_DATA(ActCtxData) \
    {  \
        ASSERT((ActCtxData) != &RtlpTheEmptyActivationContextData); \
        if ((ActCtxData) == &RtlpTheEmptyActivationContextData) {   \
            DbgPrintEx( \
                DPFLTR_SXS_ID, \
                DPFLTR_ERROR_LEVEL, \
                "SXS: %s() passed the empty activation context data\n", __FUNCTION__); \
            Status = STATUS_INVALID_PARAMETER; \
            goto Exit; \
        } \
    }

PACTIVATION_CONTEXT
RtlpMapSpecialValuesToBuiltInActivationContexts(
    PACTIVATION_CONTEXT ActivationContext
    );

NTSTATUS
RtlpThreadPoolGetActiveActivationContext(
    PACTIVATION_CONTEXT* ActivationContext
    );

NTSTATUS
RtlpInitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG EntryCount,
    PASSEMBLY_STORAGE_MAP_ENTRY *EntryArray
    );

VOID
RtlpUninitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map
    );

NTSTATUS
RtlpResolveAssemblyStorageMapEntry(
    IN OUT PASSEMBLY_STORAGE_MAP Map,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN ULONG AssemblyRosterIndex,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    );

NTSTATUS
RtlpInsertAssemblyStorageMapEntry(
    IN PASSEMBLY_STORAGE_MAP Map,
    IN ULONG AssemblyRosterIndex,
    IN PCUNICODE_STRING StorageLocation,
    IN OUT HANDLE *OpenDirectoryHandle
    );

NTSTATUS
RtlpProbeAssemblyStorageRootForAssembly(
    IN ULONG Flags,
    IN PCUNICODE_STRING Root,
    IN PCUNICODE_STRING AssemblyDirectory,
    OUT PUNICODE_STRING PreAllocatedString,
    OUT PUNICODE_STRING DynamicString,
    OUT PUNICODE_STRING *StringUsed,
    IN OUT HANDLE *OpenDirectoryHandle
    );

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    IN HANDLE KeyHandle,
    IN PCUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Root
    );

#define RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT (0x00000001)
#define RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT  (0x00000002)

NTSTATUS
RtlpGetActivationContextDataRosterHeader(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    OUT PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *AssemblyRosterHeader
    );

NTSTATUS
RtlpGetActivationContextDataStorageMapAndRosterHeader(
    IN ULONG Flags,
    IN PPEB Peb,
    IN PACTIVATION_CONTEXT ActivationContext,
    OUT PCACTIVATION_CONTEXT_DATA *ActivationContextData,
    OUT PASSEMBLY_STORAGE_MAP *AssemblyStorageMap,
    OUT PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *AssemblyRosterHeader
    );

#define RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY (0x00000001)
NTSTATUS
RtlpGetActivationContextData(
    IN ULONG                                Flags,
    IN PCACTIVATION_CONTEXT                 ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION  FindContext, OPTIONAL /* This is used for its flags. */
    OUT PCACTIVATION_CONTEXT_DATA *         ActivationContextData
    );

NTSTATUS
RtlpFindActivationContextSection_FillOutReturnedData(
    IN ULONG                                    Flags,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA  ReturnedData,
    IN OUT PACTIVATION_CONTEXT                  ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION      FindContext,
    IN const VOID * UNALIGNED                   Header,
    IN ULONG                                    Header_UserDataOffset,
    IN ULONG                                    Header_UserDataSize,
    IN ULONG                                    SectionLength
    );

VOID
FASTCALL
RtlpFreeCachedActivationContexts(
    VOID
    );



#define ACTCTX_MAGIC_MARKER ((PVOID)(ULONG_PTR)('gMcA'))

typedef struct _ACTIVATION_CONTEXT_WRAPPED {
    PVOID MagicMarker;
    ACTIVATION_CONTEXT ActivationContext;
} ACTIVATION_CONTEXT_WRAPPED, *PACTIVATION_CONTEXT_WRAPPED;

typedef const ACTIVATION_CONTEXT_WRAPPED *PCACTIVATION_CONTEXT_WRAPPED;

extern const ACTIVATION_CONTEXT_DATA RtlpTheEmptyActivationContextData;
extern const ACTIVATION_CONTEXT_WRAPPED RtlpTheEmptyActivationContextWrapped;
#define RtlpTheEmptyActivationContext (RtlpTheEmptyActivationContextWrapped.ActivationContext)

EXTERN_C BOOLEAN g_SxsKeepActivationContextsAlive;

#endif // !defined(_NTDLL_SXSP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsstorage.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsstorage.c

Abstract:

    User-mode side by side storage map default resolution support.

    Private functions that support the default probing/finding
    where assemblies are stored.

Author:

    Michael J. Grier (mgrier) 6/30/2000

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4201)   // nameless struct/union
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"
#include "ctype.h"
#include "sxstypes.h"
#include "ntdllp.h"

VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    ULONG Reason,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA Data,
    PVOID Context
    )
{
    NTSTATUS Status;
    NTSTATUS *StatusOut = (NTSTATUS *) Context;

    switch (Reason) {
        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_BEGINNING: {
            static const WCHAR NameStringBuffer[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\AssemblyStorageRoots";
            static const UNICODE_STRING NameString = { sizeof(NameStringBuffer) - sizeof(WCHAR), sizeof(NameStringBuffer), (PWSTR) NameStringBuffer };

            OBJECT_ATTRIBUTES Obja;
            HANDLE KeyHandle = NULL;

            InitializeObjectAttributes(
                &Obja,
                (PUNICODE_STRING) &NameString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenKey(&KeyHandle, KEY_ENUMERATE_SUB_KEYS, &Obja);
            if (!NT_SUCCESS(Status)) {
                // If the key is not found, we handle the system assembly installation area and privatized
                // assemblies differently anyways, so let things continue.  We'll just stop when we
                // try to use the registry stuff.

                if ((Status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                    (Status != STATUS_TOO_LATE)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Unable to open registry key %wZ Status = 0x%08lx\n", &NameString, Status);

                    Data->ResolutionBeginning.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;

                    break;
                }

                RTL_SOFT_ASSERT(KeyHandle == NULL);
            }

            Data->ResolutionBeginning.ResolutionContext = (PVOID) KeyHandle;
            Data->ResolutionBeginning.RootCount = ((SIZE_T) -1);

            break;
        }

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_GET_ROOT: {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Getting assembly storage root #%Iu\n", Data->GetRoot.RootIndex);

            if (Data->GetRoot.RootIndex == 0) {
                // privatized assembly
                static const WCHAR DllRedirectionLocal[] = L".Local\\"; 
                USHORT cbFullImageNameLength; 
                LPWSTR pFullImageName = NULL;
                SIZE_T TotalLength; 
                PVOID  Cursor = NULL; 

                // get ImageName and Lenght from PEB
                cbFullImageNameLength = NtCurrentPeb()->ProcessParameters->ImagePathName.Length; // w/o trailing NULL
                TotalLength = cbFullImageNameLength + sizeof(DllRedirectionLocal); // containing a trailing NULL
                if (TotalLength > UNICODE_STRING_MAX_BYTES) {
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_NAME_TOO_LONG;
                    break;
                }

                if ( TotalLength > Data->GetRoot.Root.MaximumLength) { 
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_BUFFER_TOO_SMALL;
                    break; 
                }
                // point to ImageName
                pFullImageName = (PWSTR)NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer;
                if (!(NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) 
                    pFullImageName = (PWSTR)((PCHAR)pFullImageName + (ULONG_PTR)(NtCurrentPeb()->ProcessParameters));

                Cursor = Data->GetRoot.Root.Buffer; 
                RtlCopyMemory(Cursor, pFullImageName, cbFullImageNameLength);
                Cursor = (PVOID) (((ULONG_PTR) Cursor) + cbFullImageNameLength);
                RtlCopyMemory(Cursor, DllRedirectionLocal, sizeof(DllRedirectionLocal));//with a trailing "/" and NULL
                Data->GetRoot.Root.Length = (USHORT)TotalLength - sizeof(WCHAR); 

                if ( ! RtlDoesFileExists_U(Data->GetRoot.Root.Buffer))  // no bother to return a wrong path
                    Data->GetRoot.Root.Length = 0 ; 

            } else if (Data->GetRoot.RootIndex == 1) {

                static const UNICODE_STRING WinSxS = RTL_CONSTANT_STRING(L"\\WinSxS\\");
                UNICODE_STRING SystemRoot;

                RtlInitUnicodeString(&SystemRoot, USER_SHARED_DATA->NtSystemRoot);

                Data->GetRoot.Root.Length = 0;

                if ((SystemRoot.Length + WinSxS.Length) > Data->GetRoot.Root.MaximumLength) {
                    Data->GetRoot.CancelResolution = TRUE;

                    if (StatusOut != NULL)
                        *StatusOut = STATUS_BUFFER_TOO_SMALL;
                    break;
                }

                RtlCopyMemory(Data->GetRoot.Root.Buffer, SystemRoot.Buffer, SystemRoot.Length);
                RtlCopyMemory(((PUCHAR)Data->GetRoot.Root.Buffer) + SystemRoot.Length, WinSxS.Buffer, WinSxS.Length);
                Data->GetRoot.Root.Length = SystemRoot.Length + WinSxS.Length;

            } else if (Data->GetRoot.RootIndex <= MAXULONG) {
                // Return the appropriate root
                struct {
                    KEY_BASIC_INFORMATION kbi;
                    WCHAR KeyNameBuffer[DOS_MAX_PATH_LENGTH]; // arbitrary biggish size
                } KeyData;
                HANDLE KeyHandle = (HANDLE) Data->GetRoot.ResolutionContext;
                ULONG ResultLength = 0;
                ULONG SubKeyIndex = (ULONG) (Data->GetRoot.RootIndex - 2); // minus two because we use index 0 for privatized assembly probing and 1 for %SystemRoot%\winsxs
                UNICODE_STRING SubKeyName;

                // If the registry key could not be opened in the first place, we're done.
                if (KeyHandle == NULL) {
                    Data->GetRoot.NoMoreEntries = TRUE;
                    break;
                }

                Status = NtEnumerateKey(
                                KeyHandle,
                                SubKeyIndex,
                                KeyBasicInformation,
                                &KeyData,
                                sizeof(KeyData),
                                &ResultLength);
                if (!NT_SUCCESS(Status)) {
                    // If this is the end of the subkeys, tell our caller to stop the iterations.
                    if (Status == STATUS_NO_MORE_ENTRIES) {
                        Data->GetRoot.NoMoreEntries = TRUE;
                        break;
                    }

                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Unable to enumerate assembly storage subkey #%lu Status = 0x%08lx\n", SubKeyIndex, Status);

                    // Otherwise, cancel the searching and propogate the error status.
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;

                    break;
                }

                if (KeyData.kbi.NameLength > UNICODE_STRING_MAX_BYTES) {
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_NAME_TOO_LONG;
                    break;
                }

                SubKeyName.Length = (USHORT) KeyData.kbi.NameLength;
                SubKeyName.MaximumLength = SubKeyName.Length;
                SubKeyName.Buffer = KeyData.kbi.Name;

                Status = RtlpGetAssemblyStorageMapRootLocation(
                            KeyHandle,
                            &SubKeyName,
                            &Data->GetRoot.Root);
                if (!NT_SUCCESS(Status)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Attempt to get storage location from subkey %wZ failed; Status = 0x%08lx\n", &SubKeyName, Status);

                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;
                    
                    break;
                }
            } else {
                Data->GetRoot.NoMoreEntries = TRUE;
                break;
            }

            break;
        }

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_SUCCESSFUL:
            // nothing to do...
            break;

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_ENDING: {
            // close the registry key, if it was opened.
            if (Data->ResolutionEnding.ResolutionContext != NULL) {
                RTL_SOFT_VERIFY(NT_SUCCESS(NtClose((HANDLE) Data->ResolutionEnding.ResolutionContext)));
            }
            break;
        }

    }
}

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    HANDLE KeyHandle,
    PCUNICODE_STRING SubKeyName,
    PUNICODE_STRING Root
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SubKeyHandle = NULL;
    ULONG ResultLength = 0;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION kvpi;
        WCHAR Buffer[DOS_MAX_PATH_LENGTH];
    } ValueData;

    static const WCHAR ValueNameBuffer[] = L"Location";
    static const UNICODE_STRING ValueName = { sizeof(ValueNameBuffer) - sizeof(WCHAR), sizeof(ValueNameBuffer), (PWSTR) ValueNameBuffer };

    ASSERT(KeyHandle != NULL);
    ASSERT(SubKeyName != NULL);
    ASSERT(Root != NULL);

    if ((KeyHandle == NULL) ||
        (SubKeyName == NULL) ||
        (Root == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING) &SubKeyName,
        OBJ_CASE_INSENSITIVE,
        KeyHandle,
        NULL);

    Status = NtOpenKey(&SubKeyHandle, KEY_QUERY_VALUE, &Obja);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Unable to open storage root subkey %wZ; Status = 0x%08lx\n", &SubKeyName, Status);

        goto Exit;
    }

    Status = NtQueryValueKey(
        SubKeyHandle,
        (PUNICODE_STRING) &ValueName,
        KeyValuePartialInformation,
        &ValueData,
        sizeof(ValueData),
        &ResultLength);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Unabel to query location from storage root subkey %wZ; Status = 0x%08lx\n", &SubKeyName, Status);

        goto Exit;
    }

    if (ValueData.kvpi.Type != REG_SZ) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage root location value type is not REG_SZ\n");
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    if ((ValueData.kvpi.DataLength % 2) != 0) {
        // Hmmm... a unicode string with an odd size??
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage root location value has non-even size\n");
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    if (ValueData.kvpi.DataLength > Root->MaximumLength) {
        // The buffer isn't big enough.  Let's allocate one that is.
        if (ValueData.kvpi.DataLength > UNICODE_STRING_MAX_BYTES) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Assembly storage root location for %wZ does not fit in a UNICODE STRING\n", &SubKeyName);

            Status = STATUS_NAME_TOO_LONG;
            goto Exit;
        }

        Root->MaximumLength = (USHORT) ValueData.kvpi.DataLength;
        Root->Buffer = (PWSTR)(RtlAllocateStringRoutine)(Root->MaximumLength);
        if (Root->Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
    }

    RtlCopyMemory(
        Root->Buffer,
        ValueData.kvpi.Data,
        ValueData.kvpi.DataLength);

    // We checked the length earlier; either it was less than or equal to a value that's
    // already stored in a USHORT or we explicitly compared against UNICODE_STRING_MAX_BYTES.
    Root->Length = (USHORT) ValueData.kvpi.DataLength;

    Status = STATUS_SUCCESS;

Exit:
    if (SubKeyHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(SubKeyHandle)));
    }

    return Status;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsstoragemapcpp.cpp ===
/*++

Copyright (c) Corporation

Module Name:

    sxsstoragemapcpp.cpp

Abstract:

    C++ wrapper source file for sxsstoragemap.c

Author:

    Jay Krell

Revision History:

    March 2002 - Jay Krell

--*/

#include "pch.cxx"
#include "sxsstoragemap.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\sxsstoragemap.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsstorage.c

Abstract:

    Side-by-side activation support for Windows/NT

    Implementation of the assembly storage map.


Author:

    Michael Grier (MGrier) 6/13/2000

Revision History:
    Xiaoyu Wu(xiaoyuw) 7/01/2000     .local directory
    Xiaoyu Wu(xiaoyuw) 8/04/2000     private assembly
    Jay Krell (a-JayK) October 2000  the little bit of system default context that wasn't already done
--*/

#if defined(__cplusplus)
extern "C" {
#endif
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"

#define IS_PATH_SEPARATOR(_wch) (((_wch) == L'\\') || ((_wch) == L'/'))
#define LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX L".Local"

#if DBG
PCUNICODE_STRING RtlpGetImagePathName(VOID);
#define RtlpGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlpGetCurrentThreadId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))
#endif

#if DBG

PCUNICODE_STRING RtlpGetImagePathName(VOID)
{
    PPEB Peb = NtCurrentPeb();
    return (Peb->ProcessParameters != NULL) ? &Peb->ProcessParameters->ImagePathName : NULL;
}

static VOID
DbgPrintFunctionEntry(
    CONST CHAR* Function
    )
{
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: [pid:0x%x, tid:0x%x, %wZ] enter %s%d()\n",
        RtlpGetCurrentProcessId(),
        RtlpGetCurrentThreadId(),
        RtlpGetImagePathName(),
        Function,
        (int)sizeof(PVOID) * 8
        );
}

static VOID
DbgPrintFunctionExit(
    CONST CHAR* Function,
    NTSTATUS    Status
    )
{
    DbgPrintEx(
        DPFLTR_SXS_ID,
        NT_SUCCESS(Status) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL,
        "SXS: [0x%x.%x] %s%d() exiting with status 0x%lx\n",
        RtlpGetCurrentProcessId(),
        RtlpGetCurrentThreadId(),
        Function,
        (int)sizeof(PVOID) * 8,
        Status
        );
}
#else

#define DbgPrintFunctionEntry(function) /* nothing */
#define DbgPrintFunctionExit(function, status) /* nothing */

#endif // DBG

// Because we write to the peb, we must not be in 64bit code for a 32bit process,
// unless we know we are early enough in CreateProcess, which is not the case
// in this file. Also don't call the 32bit version of this in a 64bit process.
#if DBG
#define ASSERT_OK_TO_WRITE_PEB() \
{ \
    PVOID Peb32 = NULL; \
    NTSTATUS Status; \
 \
    Status = \
        NtQueryInformationProcess( \
            NtCurrentProcess(), \
            ProcessWow64Information, \
            &Peb32, \
            sizeof(Peb32), \
            NULL); \
    /* The other Peb must be The Peb or the other Peb must not exist. */ \
    ASSERT(Peb32 == NtCurrentPeb() || Peb32 == NULL); \
}
#else
#define ASSERT_OK_TO_WRITE_PEB() /* nothing */
#endif

NTSTATUS
RtlpInitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG EntryCount,
    PASSEMBLY_STORAGE_MAP_ENTRY *EntryArray
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    ULONG Flags = 0;

#if DBG
    DbgPrintFunctionEntry(__FUNCTION__);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "%s(Map:%p, EntryCount:0x%lx)\n",
        __FUNCTION__,
        Map,
        EntryCount
        );

    ASSERT_OK_TO_WRITE_PEB();
#endif // DBG

    if ((Map == NULL) ||
        (EntryCount == 0)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Map        : 0x%lx\n"
            "SXS:    EntryCount : 0x%lx\n"
            __FUNCTION__,
            Map,
            EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (EntryArray == NULL) {
        EntryArray = (PASSEMBLY_STORAGE_MAP_ENTRY *) RtlAllocateHeap(RtlProcessHeap(), 0, EntryCount * sizeof(PASSEMBLY_STORAGE_MAP_ENTRY));
        if (EntryArray == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        Flags |= ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED;
    }

    for (i=0; i<EntryCount; i++)
        EntryArray[i] = NULL;

    Map->Flags = Flags;
    Map->AssemblyCount = EntryCount;
    Map->AssemblyArray = EntryArray;

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintFunctionExit(__FUNCTION__, Status);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        NT_SUCCESS(Status) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL,
        "%s(Map:%p, EntryCount:0x%lx) : (Map:%p, Status:0x%lx)\n",
        __FUNCTION__,
        Map,        
        EntryCount,
        Map,
        Status
        );
#endif

    return Status;
}

VOID
RtlpUninitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map
    )
{
    DbgPrintFunctionEntry(__FUNCTION__);
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "%s(Map:%p)\n",
        __FUNCTION__,
        Map
        );
#endif

    if (Map != NULL) {
        ULONG i;

        for (i=0; i<Map->AssemblyCount; i++) {
            PASSEMBLY_STORAGE_MAP_ENTRY Entry = Map->AssemblyArray[i];

            if (Entry != NULL) {
                Entry->DosPath.Length = 0;
                Entry->DosPath.MaximumLength = 0;
                Entry->DosPath.Buffer = NULL;

                if (Entry->Handle != NULL) {
                    RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(Entry->Handle)));
                    Entry->Handle = NULL;
                }

                Map->AssemblyArray[i] = NULL;

                RtlFreeHeap(RtlProcessHeap(), 0, Entry);
            }
        }

        if (Map->Flags & ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED) {
            RtlFreeHeap(RtlProcessHeap(), 0, Map->AssemblyArray);
        }

        Map->AssemblyArray = NULL;
        Map->AssemblyCount = 0;
        Map->Flags = 0;
    }
}

NTSTATUS
RtlpInsertAssemblyStorageMapEntry(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG AssemblyRosterIndex,
    PCUNICODE_STRING StorageLocation,
    HANDLE* OpenDirectoryHandle
    )
{
    PASSEMBLY_STORAGE_MAP_ENTRY Entry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Map != NULL);
    ASSERT(AssemblyRosterIndex >= 1);
    ASSERT((Map != NULL) && (AssemblyRosterIndex < Map->AssemblyCount));
    ASSERT(StorageLocation != NULL);
    ASSERT((StorageLocation != NULL) && (StorageLocation->Length >= sizeof(WCHAR)));
    ASSERT((StorageLocation != NULL) && (StorageLocation->Buffer != NULL));

    DbgPrintFunctionEntry(__FUNCTION__);

    if ((Map == NULL) ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyRosterIndex > Map->AssemblyCount) ||
        (StorageLocation == NULL) ||
        (StorageLocation->Length < sizeof(WCHAR)) ||
        (StorageLocation->Buffer == NULL) ||
        (OpenDirectoryHandle == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:  Map                    : %p\n"
            "SXS:  AssemblyRosterIndex    : 0x%lx\n"
            "SXS:  Map->AssemblyCount     : 0x%lx\n"
            "SXS:  StorageLocation        : %p\n"
            "SXS:  StorageLocation->Length: 0x%x\n"
            "SXS:  StorageLocation->Buffer: %p\n"
            "SXS:  OpenDirectoryHandle    : %p\n",
            __FUNCTION__,
            Map,
            AssemblyRosterIndex,
            Map ? Map->AssemblyCount : 0,
            StorageLocation,
            (StorageLocation != NULL) ? StorageLocation->Length : 0,
            (StorageLocation != NULL) ? StorageLocation->Buffer : NULL,
            OpenDirectoryHandle
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((StorageLocation->Length + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    Entry = (PASSEMBLY_STORAGE_MAP_ENTRY) RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ASSEMBLY_STORAGE_MAP_ENTRY) + StorageLocation->Length + sizeof(WCHAR));
    if (Entry == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Entry->Flags = 0;
    Entry->DosPath.Length = StorageLocation->Length;
    Entry->DosPath.Buffer = (PWSTR) (Entry + 1);
    Entry->DosPath.MaximumLength = (USHORT) (StorageLocation->Length + sizeof(WCHAR));
    RtlCopyMemory(
        Entry->DosPath.Buffer,
        StorageLocation->Buffer,
        StorageLocation->Length);
    Entry->DosPath.Buffer[Entry->DosPath.Length / sizeof(WCHAR)] = L'\0';

    Entry->Handle = *OpenDirectoryHandle;

    // Ok, we're all set.  Let's try the big interlocked switcheroo
    if (InterlockedCompareExchangePointer(
            (PVOID *) &Map->AssemblyArray[AssemblyRosterIndex],
            (PVOID) Entry,
            (PVOID) NULL) == NULL) {
        // If we're the first ones in, avoid cleaning up in the exit path.
        Entry = NULL;
        *OpenDirectoryHandle = NULL;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    if (Entry != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, Entry);
    }

    return Status;
}

NTSTATUS
RtlpResolveAssemblyStorageMapEntry(
    PASSEMBLY_STORAGE_MAP Map,
    PCACTIVATION_CONTEXT_DATA Data,
    ULONG AssemblyRosterIndex,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA CallbackData;
    PVOID ResolutionContext;
    BOOLEAN ResolutionContextValid = FALSE;
    UNICODE_STRING AssemblyDirectory;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRoster;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntry;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation;
    PVOID AssemblyInformationSectionBase;
    UNICODE_STRING ResolvedPath;
    WCHAR ResolvedPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING ResolvedDynamicPath;
    PUNICODE_STRING ResolvedPathUsed;
    HANDLE OpenDirectoryHandle = NULL;
    WCHAR QueryPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES Obja; 
    IO_STATUS_BLOCK IoStatusBlock;
    SIZE_T RootCount, CurrentRootIndex;
    PWSTR FreeBuffer = NULL;

    DbgPrintFunctionEntry(__FUNCTION__);

    ResolvedPath.Length = 0;
    ResolvedPath.MaximumLength = sizeof(ResolvedPathBuffer);
    ResolvedPath.Buffer = ResolvedPathBuffer;

    ResolvedDynamicPath.Length = 0;
    ResolvedDynamicPath.MaximumLength = 0;
    ResolvedDynamicPath.Buffer = NULL;

    FileName.Length = 0;
    FileName.MaximumLength = 0;
    FileName.Buffer = NULL;

    ResolutionContext = NULL;

    // First, let's validate parameters...
    if ((Map == NULL) ||
        (Data == NULL) ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyRosterIndex > Map->AssemblyCount)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:   Map                : %p\n"
            "SXS:   Data               : %p\n"
            "SXS:   AssemblyRosterIndex: 0x%lx\n"
            "SXS:   Map->AssemblyCount : 0x%lx\n",
            __FUNCTION__,
            Map,
            Data,
            AssemblyRosterIndex,
            (Map != NULL) ? Map->AssemblyCount : 0
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Is it already resolved?
    if (Map->AssemblyArray[AssemblyRosterIndex] != NULL)
        goto Exit;

    AssemblyRoster = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset);
    AssemblyRosterEntry = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Data) + AssemblyRoster->FirstEntryOffset + (AssemblyRosterIndex * sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)));
    AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Data) + AssemblyRosterEntry->AssemblyInformationOffset);
    AssemblyInformationSectionBase = (PVOID) (((ULONG_PTR) Data) + AssemblyRoster->AssemblyInformationSectionOffset);

    if (AssemblyInformation->AssemblyDirectoryNameLength > UNICODE_STRING_MAX_BYTES) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly directory name stored in assembly information too long (%lu bytes) - ACTIVATION_CONTEXT_DATA at %p\n", AssemblyInformation->AssemblyDirectoryNameLength, Data);

        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    // The root assembly may just be in the raw filesystem, in which case we want to resolve the path to be the
    // directory containing the application.
    if (AssemblyInformation->Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY)
    {
        WCHAR * p = NULL;
        WCHAR * pManifestPath = NULL; 
        USHORT ManifestPathLength;
        
        //now, we have AssemblyInformation in hand, get the manifest path 
        ResolvedPathUsed = &ResolvedPath;

        pManifestPath = (PWSTR)((ULONG_PTR)AssemblyInformationSectionBase + AssemblyInformation->ManifestPathOffset);
        if ( !pManifestPath) { 
            Status = STATUS_INTERNAL_ERROR;
            goto Exit; 
    
        }

        p = wcsrchr(pManifestPath, L'\\'); 
        if (!p) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit; 
        }
        ManifestPathLength = (USHORT)((p - pManifestPath + 1) * sizeof(WCHAR)); // additional 1 WCHAR for "\"
        ManifestPathLength += sizeof(WCHAR); // for trailing NULL

        if (ManifestPathLength > sizeof(ResolvedPathBuffer)) {
            if (ManifestPathLength > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            ResolvedDynamicPath.MaximumLength = (USHORT) (ManifestPathLength);

            ResolvedDynamicPath.Buffer = (PWSTR)(RtlAllocateStringRoutine)(ResolvedDynamicPath.MaximumLength);
            if (ResolvedDynamicPath.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            ResolvedPathUsed = &ResolvedDynamicPath;
        }

        RtlCopyMemory(
            ResolvedPathUsed->Buffer,
            (PVOID)(pManifestPath),
            ManifestPathLength-sizeof(WCHAR));

        ResolvedPathUsed->Buffer[ManifestPathLength / sizeof(WCHAR) - 1] = L'\0';
        ResolvedPathUsed->Length = (USHORT)ManifestPathLength-sizeof(WCHAR);
    } else if ((AssemblyInformation->Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY) &&
        (AssemblyInformation->AssemblyDirectoryNameLength == 0)) {
        // Get the image directory for the process
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NtCurrentPeb()->ProcessParameters;
        // We don't need to image name, just the length up to the last slash.
        PWSTR pszCursor;
        USHORT cbOriginalLength;
        USHORT cbLeft;
        USHORT cbIncludingSlash;

        ASSERT(ProcessParameters != NULL);
        if (ProcessParameters == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        // We don't need to image name, just the length up to the last slash.
        pszCursor = ProcessParameters->ImagePathName.Buffer;
        cbOriginalLength = ProcessParameters->ImagePathName.Length;
        cbLeft = cbOriginalLength;
        cbIncludingSlash = 0;

        while (cbLeft != 0) {
            const WCHAR wch = *pszCursor++;
            cbLeft -= sizeof(WCHAR);

            if (IS_PATH_SEPARATOR(wch)) {
                cbIncludingSlash = cbOriginalLength - cbLeft;
            }
        }

        ResolvedPathUsed = &ResolvedPath;

        if ((cbIncludingSlash + sizeof(WCHAR)) > sizeof(ResolvedPathBuffer)) {
            if ((cbIncludingSlash + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            ResolvedDynamicPath.MaximumLength = (USHORT) (cbIncludingSlash + sizeof(WCHAR));

            ResolvedDynamicPath.Buffer = (PWSTR)(RtlAllocateStringRoutine)(ResolvedDynamicPath.MaximumLength);
            if (ResolvedDynamicPath.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            ResolvedPathUsed = &ResolvedDynamicPath;
        }

        RtlCopyMemory(
            ResolvedPathUsed->Buffer,
            ProcessParameters->ImagePathName.Buffer,
            cbIncludingSlash);

        ResolvedPathUsed->Buffer[cbIncludingSlash / sizeof(WCHAR)] = L'\0';
        ResolvedPathUsed->Length = cbIncludingSlash;
    } else {
        // If the resolution is not to the root assembly path, we need to make our callbacks.

        ResolvedPathUsed = NULL;
        AssemblyDirectory.Length = (USHORT) AssemblyInformation->AssemblyDirectoryNameLength;
        AssemblyDirectory.MaximumLength = AssemblyDirectory.Length;
        AssemblyDirectory.Buffer = (PWSTR) (((ULONG_PTR) AssemblyInformationSectionBase) + AssemblyInformation->AssemblyDirectoryNameOffset);

        // Get ready to fire the resolution beginning event...
        CallbackData.ResolutionBeginning.Data = Data;
        CallbackData.ResolutionBeginning.AssemblyRosterIndex = AssemblyRosterIndex;
        CallbackData.ResolutionBeginning.ResolutionContext = NULL;
        CallbackData.ResolutionBeginning.Root.Length = 0;
        CallbackData.ResolutionBeginning.Root.MaximumLength = sizeof(QueryPathBuffer);
        CallbackData.ResolutionBeginning.Root.Buffer = QueryPathBuffer;
        CallbackData.ResolutionBeginning.KnownRoot = FALSE;
        CallbackData.ResolutionBeginning.CancelResolution = FALSE;
        CallbackData.ResolutionBeginning.RootCount = 0;

        (*Callback)(
            ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_BEGINNING,
            &CallbackData,
            CallbackContext);
        if (CallbackData.ResolutionBeginning.CancelResolution) {
            Status = STATUS_CANCELLED;
            goto Exit;
        }

        // If that was enough, then register it and we're outta here...
        if (CallbackData.ResolutionBeginning.KnownRoot) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Storage resolution callback said that this is a well known storage root\n");

            // See if it's there...
            Status = RtlpProbeAssemblyStorageRootForAssembly(
                0,
                &CallbackData.ResolutionBeginning.Root,
                &AssemblyDirectory,
                &ResolvedPath,
                &ResolvedDynamicPath,
                &ResolvedPathUsed,
                &OpenDirectoryHandle);
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to probe known root of assembly storage (\"%wZ\") failed; Status = 0x%08lx\n", &CallbackData.ResolutionBeginning.Root, Status);
                goto Exit;
            }

            Status = RtlpInsertAssemblyStorageMapEntry(
                Map,
                AssemblyRosterIndex,
                &CallbackData.ResolutionBeginning.Root,
                &OpenDirectoryHandle);
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to insert well known storage root into assembly storage map assembly roster index %lu failed; Status = 0x%08lx\n", AssemblyRosterIndex, Status);

                goto Exit;
            }

            Status = STATUS_SUCCESS;
            goto Exit;
        }

        // Otherwise, begin the grind...
        ResolutionContext = CallbackData.ResolutionBeginning.ResolutionContext;
        RootCount = CallbackData.ResolutionBeginning.RootCount;

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: Assembly storage resolution trying %Id roots (-1 is ok)\n", (SSIZE_T/*from SIZE_T*/)RootCount);

        ResolutionContextValid = TRUE;

        for (CurrentRootIndex = 0; CurrentRootIndex < RootCount; CurrentRootIndex++) {
            CallbackData.GetRoot.ResolutionContext = ResolutionContext;
            CallbackData.GetRoot.RootIndex = CurrentRootIndex;
            CallbackData.GetRoot.Root.Length = 0;
            CallbackData.GetRoot.Root.MaximumLength = sizeof(QueryPathBuffer);
            CallbackData.GetRoot.Root.Buffer = QueryPathBuffer;
            CallbackData.GetRoot.CancelResolution = FALSE;
            CallbackData.GetRoot.NoMoreEntries = FALSE;

            (*Callback)(
                ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_GET_ROOT,
                &CallbackData,
                CallbackContext);

            if (CallbackData.GetRoot.CancelResolution) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Callback routine cancelled storage root resolution on root number %Iu\n", CurrentRootIndex);

                Status = STATUS_CANCELLED;
                goto Exit;
            }

            if (CallbackData.GetRoot.NoMoreEntries) {
                if (CallbackData.GetRoot.Root.Length == 0) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_TRACE_LEVEL,
                        "SXS: Storage resolution finished because callback indicated no more entries on root number %Iu\n", CurrentRootIndex);

                    // we're done... 
                    RootCount = CurrentRootIndex;
                    break;
                }

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Storage resolution callback has indicated that this is the last root to process: number %Iu\n", CurrentRootIndex);

                RootCount = CurrentRootIndex + 1;
            }

            // Allow the caller to skip this index.
            if (CallbackData.GetRoot.Root.Length == 0) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Storage resolution for root number %lu returned blank root; skipping probing logic and moving to next.\n", CurrentRootIndex);

                continue;
            }

            if (OpenDirectoryHandle != NULL) {
                RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(OpenDirectoryHandle)));
                OpenDirectoryHandle = NULL;
            }

            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Assembly storage map probing root %wZ for assembly directory %wZ\n", &CallbackData.GetRoot.Root, &AssemblyDirectory);

            // See if it's there...
            Status = RtlpProbeAssemblyStorageRootForAssembly(
                0,
                &CallbackData.GetRoot.Root,
                &AssemblyDirectory,
                &ResolvedPath,
                &ResolvedDynamicPath,
                &ResolvedPathUsed,
                &OpenDirectoryHandle);

            // If we got it, leave the loop.
            if (NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Found good storage root for %wZ at index %Iu\n", &AssemblyDirectory, CurrentRootIndex);
                break;
            }

            if (Status != STATUS_SXS_ASSEMBLY_NOT_FOUND) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to probe assembly storage root %wZ for assembly directory %wZ failed with status = 0x%08lx\n", &CallbackData.GetRoot.Root, &AssemblyDirectory, Status);

                goto Exit;
            }
        }

        if (CurrentRootIndex == RootCount) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to resolve storage root for assembly directory %wZ in %Iu tries\n", &AssemblyDirectory, CurrentRootIndex);

            Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
            goto Exit;
        }
    }

    //
    // sometimes at this point probing has simultaneously opened the directory,
    // sometimes it has not.
    //
    if (OpenDirectoryHandle == NULL) {

        //create Handle for this directory
        if (!RtlDosPathNameToRelativeNtPathName_U(
                    ResolvedPathUsed->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    )) 
        {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Attempt to translate DOS path name \"%S\" to NT format failed\n", ResolvedPathUsed->Buffer);

            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            goto Exit;
        }

        FreeBuffer = FileName.Buffer;

        if (RelativeName.RelativeName.Length != 0) 
        {
            FileName = RelativeName.RelativeName;
        } else 
        {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
            &Obja,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        // Open the directory to prevent deletion, just like set current working directory does...
        Status = NtOpenFile(
                    &OpenDirectoryHandle,
                    FILE_TRAVERSE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                    );
        RtlReleaseRelativeName(&RelativeName);
        if (!NT_SUCCESS(Status)) 
        {
            //
            // Don't map this to like SXS_blah_NOT_FOUND, because
            // probing says this is definitely where we expect to get stuff.
            //
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", ResolvedPathUsed->Buffer, Status);
            goto Exit; 
        } else 
        { 
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: It is resolved!!!, GOOD");
        }
    }

    // Hey, we made it.  Add us to the list!
    Status = RtlpInsertAssemblyStorageMapEntry(
        Map,
        AssemblyRosterIndex,
        ResolvedPathUsed,
        &OpenDirectoryHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Storage resolution failed to insert entry to storage map; Status = 0x%08lx\n", Status);

        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    // Let the caller run down their context...
    if (ResolutionContextValid) {
        CallbackData.ResolutionEnding.ResolutionContext = ResolutionContext;

        (*Callback)(
            ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_ENDING,
            &CallbackData,
            CallbackContext);
    }

    if (ResolvedDynamicPath.Buffer != NULL) {
        (RtlFreeStringRoutine)(ResolvedDynamicPath.Buffer);
    }

    //
    // RtlpInsertAssemblyStorageMapEntry gives ownership to the storage map, and
    // NULLs out our local, when successful.
    //
    if (OpenDirectoryHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(OpenDirectoryHandle)));
    }

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    return Status;
}

NTSTATUS
RtlpProbeAssemblyStorageRootForAssembly(
    ULONG Flags,
    PCUNICODE_STRING Root,
    PCUNICODE_STRING AssemblyDirectory,
    PUNICODE_STRING PreAllocatedString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    HANDLE *OpenDirectoryHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR Buffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING String = {0};
    SIZE_T TotalLength;
    BOOLEAN SeparatorNeededAfterRoot = FALSE;
    PWSTR Cursor;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileName = {0};
    RTL_RELATIVE_NAME_U RelativeName;
    PWSTR FreeBuffer = NULL;
    HANDLE TempDirectoryHandle = NULL;
    BOOLEAN fExistDir; 
    FILE_BASIC_INFORMATION BasicInfo;

    DbgPrintFunctionEntry(__FUNCTION__);

    if (StringUsed != NULL)
        *StringUsed = NULL;

    if (OpenDirectoryHandle != NULL)
        *OpenDirectoryHandle = NULL;

    if ((Flags != 0) ||
        (Root == NULL) ||
        (AssemblyDirectory == NULL) ||
        (PreAllocatedString == NULL) ||
        (DynamicString == NULL) ||
        (StringUsed == NULL) ||
        (OpenDirectoryHandle == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:  Flags:               0x%lx\n"
            // %p is good enough because the checks are only against NULL
            "SXS:  Root:                %p\n"
            "SXS:  AssemblyDirectory:   %p\n"
            "SXS:  PreAllocatedString:  %p\n"
            "SXS:  DynamicString:       %p\n"
            "SXS:  StringUsed:          %p\n"
            "SXS:  OpenDirectoryHandle: %p\n",
            __FUNCTION__,
            Flags,
            Root,
            AssemblyDirectory,
            PreAllocatedString,
            DynamicString,
            StringUsed,
            OpenDirectoryHandle
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    TotalLength = Root->Length;

    if (Root->Length != 0) {
        if (!IS_PATH_SEPARATOR(Root->Buffer[(Root->Length / sizeof(WCHAR)) - 1])) {
            SeparatorNeededAfterRoot = TRUE;
            TotalLength += sizeof(WCHAR);
        }
    }

    TotalLength += AssemblyDirectory->Length;

    // And space for the trailing slash
    TotalLength += sizeof(WCHAR);

    // And space for a trailing null character because the path functions want one
    TotalLength += sizeof(WCHAR);

    //
    //  We do not add in space for the trailing slash so as to not cause a dynamic
    //  allocation until necessary in the boundary condition.  If the name of the
    //  directory we're probing fits fine in the stack-allocated buffer, we'll do
    //  the heap allocation if the probe succeeds.  Otherwise we'll not bother.
    //
    //  Maybe the relative complexity of the extra "+ sizeof(WCHAR)"s that are
    //  around aren't worth it, but extra unnecessary heap allocations are my
    //  hot button.
    //

    // Check to see if the string, plus a trailing slash that we don't write until
    // the end of this function plus the trailing null accounted for above
    // fits into a UNICODE_STRING.  If not, bail out.
    if (TotalLength > UNICODE_STRING_MAX_BYTES) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage resolution failing probe because combined path length does not fit in an UNICODE_STRING.\n");

        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (TotalLength > sizeof(Buffer)) {
        String.MaximumLength = (USHORT) TotalLength;

        String.Buffer = (PWSTR)(RtlAllocateStringRoutine)(String.MaximumLength);
        if (String.Buffer == NULL) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Assembly storage resolution failing probe because attempt to allocate %u bytes failed.\n", String.MaximumLength);

            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
    } else {
        String.Buffer = Buffer;
        String.MaximumLength = sizeof(Buffer);
    }

    RtlCopyMemory(
        String.Buffer,
        Root->Buffer,
        Root->Length);

    Cursor = (PWSTR) (((ULONG_PTR) String.Buffer) + Root->Length);

    if (SeparatorNeededAfterRoot) {
        *Cursor++ = L'\\';
    }

    RtlCopyMemory(
        Cursor,
        AssemblyDirectory->Buffer,
        AssemblyDirectory->Length);

    Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemblyDirectory->Length);

    *Cursor = L'\0';

    String.Length =
        Root->Length +
        (SeparatorNeededAfterRoot ? sizeof(WCHAR) : 0) +
        AssemblyDirectory->Length;

    if (!RtlDosPathNameToRelativeNtPathName_U(
                                String.Buffer,
                                &FileName,
                                NULL,
                                &RelativeName
                                )) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Attempt to translate DOS path name \"%S\" to NT format failed\n", String.Buffer);

        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length != 0) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
    // check the existence of directories
    Status = NtQueryAttributesFile(
                &Obja,
                &BasicInfo
                );

    fExistDir = FALSE; 
    if ( !NT_SUCCESS(Status) ) {
        if ( (Status == STATUS_SHARING_VIOLATION) || (Status == STATUS_ACCESS_DENIED) ) 
            fExistDir = TRUE; 
        else 
            fExistDir = FALSE;
    }
    else 
        fExistDir = TRUE;
    
    if (! fExistDir) {
        RtlReleaseRelativeName(&RelativeName);
        if (( Status == STATUS_NO_SUCH_FILE) || Status == STATUS_OBJECT_NAME_NOT_FOUND || Status == STATUS_OBJECT_PATH_NOT_FOUND)
             Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
        else 
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", String.Buffer, Status);

        goto Exit; 
    }

    // Open the directory to prevent deletion, just like set current working directory does...
    Status = NtOpenFile(
                &TempDirectoryHandle,
                FILE_TRAVERSE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );
    RtlReleaseRelativeName(&RelativeName);
    if (!NT_SUCCESS(Status)) {
        // If we failed, remap no such file to STATUS_SXS_ASSEMBLY_NOT_FOUND.
        if (Status == STATUS_NO_SUCH_FILE) {
            Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
        } else {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", String.Buffer, Status);
        }

        goto Exit;
    }

    // Hey, we found it!
    // add a slash to the path on the way out and we're done!

    if (TotalLength <= PreAllocatedString->MaximumLength) {
        // The caller's static string is big enough; just use it.
        RtlCopyMemory(
            PreAllocatedString->Buffer,
            String.Buffer,
            String.Length);

        *StringUsed = PreAllocatedString;
    } else {
        // If we already have a dynamic string, just give them our pointer.
        if (String.Buffer != Buffer) {
            DynamicString->Buffer = String.Buffer;
            String.Buffer = NULL;
        } else {
            // Otherwise we do our first allocation on the way out...
            DynamicString->Buffer = (PWSTR)(RtlAllocateStringRoutine)(TotalLength);
            if (DynamicString->Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            RtlCopyMemory(
                DynamicString->Buffer,
                String.Buffer,
                String.Length);
        }

        DynamicString->MaximumLength = (USHORT) TotalLength;
        *StringUsed = DynamicString;
    }

    Cursor = (PWSTR) (((ULONG_PTR) (*StringUsed)->Buffer) + String.Length);
    *Cursor++ = L'\\';
    *Cursor++ = L'\0';
    (*StringUsed)->Length = (USHORT) (String.Length + sizeof(WCHAR)); // aka "TotalLength - sizeof(WCHAR)" but this seemed cleaner

    *OpenDirectoryHandle = TempDirectoryHandle;
    TempDirectoryHandle = NULL;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    if ((String.Buffer != NULL) && (String.Buffer != Buffer)) {
        (RtlFreeStringRoutine)(String.Buffer);
    }

    if (TempDirectoryHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(TempDirectoryHandle)));
    }

    return Status;
}

#if 0 /* dead code */

NTSTATUS
NTAPI
RtlResolveAssemblyStorageMapEntry(
    IN ULONG Flags,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN ULONG AssemblyRosterIndex,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PASSEMBLY_STORAGE_MAP Map = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PPEB Peb = NtCurrentPeb();

    DbgPrintFunctionEntry(__FUNCTION__);
    ASSERT_OK_TO_WRITE_PEB();
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    Status = RtlpGetActivationContextDataStorageMapAndRosterHeader(
                    0,
                    Peb,
                    ActivationContext,
                    &ActivationContextData,
                    &Map,
                    &AssemblyRosterHeader);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextData == NULL) {
        ASSERT(ActivationContext == NULL);

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: RtlResolveAssemblyStorageMapEntry() asked to resolve an assembly storage entry when no activation context data is available.\n");

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (AssemblyRosterIndex >= AssemblyRosterHeader->EntryCount) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters: AssemblyRosterIndex 0x%lx >= AssemblyRosterHeader->EntryCount 0x%lx\n",
            __FUNCTION__,
            AssemblyRosterIndex,
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpResolveAssemblyStorageMapEntry(Map, ActivationContextData, AssemblyRosterIndex, Callback, CallbackContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    return Status;
}

#endif /* dead code */

NTSTATUS
NTAPI
RtlGetAssemblyStorageRoot(
    IN ULONG Flags,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN ULONG AssemblyRosterIndex,
    OUT PCUNICODE_STRING *AssemblyStorageRoot,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PASSEMBLY_STORAGE_MAP AssemblyStorageMap = NULL;

    const PPEB Peb = NtCurrentPeb();

    DbgPrintFunctionEntry(__FUNCTION__);
    ASSERT_OK_TO_WRITE_PEB();
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    if (AssemblyStorageRoot != NULL) {
        *AssemblyStorageRoot = NULL;
    }

    if ((Flags & ~(RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT
            | RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT))
        ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyStorageRoot == NULL) ||
        (Callback == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Flags              : 0x%lx\n"
            "SXS:    AssemblyRosterIndex: 0x%lx\n"
            "SXS:    AssemblyStorageRoot: %p\n"
            "SXS:    Callback           : %p\n",
            __FUNCTION__,
            Flags,
            AssemblyRosterIndex,
            AssemblyStorageRoot,
            Callback
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Simple implementation: just resolve it and if it resolves OK, return the string in the
    // storage map.
    Status =
        RtlpGetActivationContextDataStorageMapAndRosterHeader(
            ((Flags & RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT)
                ? RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
                : 0)
            | ((Flags & RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT)
                ? RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT
                : 0),
            Peb,
            ActivationContext,
            &ActivationContextData,
            &AssemblyStorageMap,
            &AssemblyRosterHeader
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: RtlGetAssemblyStorageRoot() unable to get activation context data, storage map and assembly roster header.  Status = 0x%08lx\n", Status);

        goto Exit;
    }

    // It's possible that there wasn't anything...
    if (ActivationContextData != NULL) {
        ASSERT(AssemblyRosterHeader != NULL);
        ASSERT(AssemblyStorageMap != NULL);

        if ((AssemblyRosterHeader == NULL) || (AssemblyStorageMap == NULL)) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        if (AssemblyRosterIndex >= AssemblyRosterHeader->EntryCount) {

            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() bad parameters AssemblyRosterIndex 0x%lx "
                           ">= AssemblyRosterHeader->EntryCount: 0x%lx\n",
                __FUNCTION__,
                AssemblyRosterIndex,
                AssemblyRosterHeader->EntryCount
                );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        Status = RtlpResolveAssemblyStorageMapEntry(AssemblyStorageMap, ActivationContextData, AssemblyRosterIndex, Callback, CallbackContext);
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: RtlGetAssemblyStorageRoot() unable to resolve storage map entry.  Status = 0x%08lx\n", Status);

            goto Exit;
        }

        // I guess we're done!
        ASSERT(AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex] != NULL);
        if (AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex] == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        *AssemblyStorageRoot = &AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex]->DosPath;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    return Status;
}

NTSTATUS
RtlpGetActivationContextDataStorageMapAndRosterHeader(
    ULONG Flags,
    PPEB Peb,
    PACTIVATION_CONTEXT ActivationContext,
    PCACTIVATION_CONTEXT_DATA *ActivationContextData,
    PASSEMBLY_STORAGE_MAP *AssemblyStorageMap,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER  *AssemblyRosterHeader
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER TempAssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA* TempActivationContextData = NULL;
    PASSEMBLY_STORAGE_MAP* TempAssemblyStorageMap = NULL;
    WCHAR LocalAssemblyDirectoryBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING LocalAssemblyDirectory = {0};

    DbgPrintFunctionEntry(__FUNCTION__);
    LocalAssemblyDirectoryBuffer[0] = 0;
    LocalAssemblyDirectory.Length = 0;
    LocalAssemblyDirectory.MaximumLength = sizeof(WCHAR);
    LocalAssemblyDirectory.Buffer = LocalAssemblyDirectoryBuffer;

    ASSERT(Peb != NULL);
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    if (ActivationContextData != NULL) {
        *ActivationContextData = NULL;
    }

    if (AssemblyStorageMap != NULL) {
        *AssemblyStorageMap = NULL;
    }

    if (AssemblyRosterHeader != NULL) {
        *AssemblyRosterHeader = NULL;
    }

    if (
        (Flags & ~(RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
            | RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT))
        ||
        (Peb == NULL) ||
        (ActivationContextData == NULL) ||
        (AssemblyStorageMap == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Flags                : 0x%lx\n"
            "SXS:    Peb                  : %p\n"
            "SXS:    ActivationContextData: %p\n"
            "SXS:    AssemblyStorageMap   : %p\n"
            __FUNCTION__,
            Flags,
            Peb,
            ActivationContextData,
            AssemblyStorageMap
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ActivationContext == ACTCTX_PROCESS_DEFAULT
        || ActivationContext == ACTCTX_SYSTEM_DEFAULT
        || (Flags & (
        RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
        | RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT))) {

        //
        // NOTE the ambiguity here. Maybe we'll clean this up.
        //
        // The flags override.
        // ActivationContext == ACTCTX_PROCESS_DEFAULT could still be system default.
        //

        if (ActivationContext == ACTCTX_SYSTEM_DEFAULT
            || (Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT)
            ) {
            TempActivationContextData = &Peb->SystemDefaultActivationContextData;
            TempAssemblyStorageMap = &Peb->SystemAssemblyStorageMap;

            if (*TempActivationContextData != NULL) {
                TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
            }
        }
        else if (ActivationContext == ACTCTX_PROCESS_DEFAULT || (Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT)) {
            TempActivationContextData = &Peb->ActivationContextData;
            TempAssemblyStorageMap = &Peb->ProcessAssemblyStorageMap;

            if (*TempActivationContextData != NULL) {
                TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
                if (*TempAssemblyStorageMap == NULL) {
                    UNICODE_STRING ImagePathName;

                    // Capture the image path name so that we don't overrun allocated buffers because someone's
                    // randomly tweaking the RTL_USER_PROCESS_PARAMETERS.
                    ImagePathName = Peb->ProcessParameters->ImagePathName;

                    // The process default local assembly directory is the image name plus ".local".
                    // The process default private assembly directory is the image path.
                    if ((ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX)) > sizeof(LocalAssemblyDirectoryBuffer)) {
                        if ((ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX)) > UNICODE_STRING_MAX_BYTES) {
                            Status = STATUS_NAME_TOO_LONG;
                            goto Exit;
                        }

                        LocalAssemblyDirectory.MaximumLength = (USHORT) (ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX));

                        LocalAssemblyDirectory.Buffer = (PWSTR)(RtlAllocateStringRoutine)(LocalAssemblyDirectory.MaximumLength);
                        if (LocalAssemblyDirectory.Buffer == NULL) {
                            Status = STATUS_NO_MEMORY;
                            goto Exit;
                        }
                    } else {
                        LocalAssemblyDirectory.MaximumLength = sizeof(LocalAssemblyDirectoryBuffer);
                        LocalAssemblyDirectory.Buffer = LocalAssemblyDirectoryBuffer;
                    }

                    RtlCopyMemory(
                        LocalAssemblyDirectory.Buffer,
                        ImagePathName.Buffer,
                        ImagePathName.Length);

                    RtlCopyMemory(
                        &LocalAssemblyDirectory.Buffer[ImagePathName.Length / sizeof(WCHAR)],
                        LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX,
                        sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX));

                    LocalAssemblyDirectory.Length = ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX) - sizeof(WCHAR);

                    if (!NT_SUCCESS(Status))
                        goto Exit;
                }
            }
        }
        if (*TempActivationContextData != NULL) {
            if (*TempAssemblyStorageMap == NULL) {
                PASSEMBLY_STORAGE_MAP Map = (PASSEMBLY_STORAGE_MAP) RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ASSEMBLY_STORAGE_MAP) + (TempAssemblyRosterHeader->EntryCount * sizeof(PASSEMBLY_STORAGE_MAP_ENTRY)));
                if (Map == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }
                Status = RtlpInitializeAssemblyStorageMap(Map, TempAssemblyRosterHeader->EntryCount, (PASSEMBLY_STORAGE_MAP_ENTRY *) (Map + 1));
                if (!NT_SUCCESS(Status)) {
                    RtlFreeHeap(RtlProcessHeap(), 0, Map);
                    goto Exit;
                }

                if (InterlockedCompareExchangePointer((PVOID*)TempAssemblyStorageMap, Map, NULL) != NULL) {
                    // We were not the first ones in.  Free ours and use the one allocated.
                    RtlpUninitializeAssemblyStorageMap(Map);
                    RtlFreeHeap(RtlProcessHeap(), 0, Map);
                }
            }
        } else {
            ASSERT(*TempAssemblyStorageMap == NULL);
        }
        *AssemblyStorageMap = (PASSEMBLY_STORAGE_MAP) *TempAssemblyStorageMap;
    } else {
        TempActivationContextData = &ActivationContext->ActivationContextData;

        ASSERT(*TempActivationContextData != NULL);
        if (*TempActivationContextData == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
        *AssemblyStorageMap = &ActivationContext->StorageMap;
    }

    if (ActivationContextData != NULL)
        *ActivationContextData = *TempActivationContextData;

    if (AssemblyRosterHeader != NULL)
        *AssemblyRosterHeader = TempAssemblyRosterHeader;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    if ((LocalAssemblyDirectory.Buffer != NULL) &&
        (LocalAssemblyDirectory.Buffer != LocalAssemblyDirectoryBuffer)) {
        RtlFreeUnicodeString(&LocalAssemblyDirectory);
    }
    return Status;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\tpath.c ===
/*++

Copyright (b\\c) 2000 Microsoft Corporation

Module Name:

    tpath.b\\c

Abstract:

    Test program for path stuff in rtl.

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdio.h>

//__declspec(selectany) int _ldused = 0;
//__declspec(selectany) int _fltused = 0;

#if 1
void __stdcall RtlpInitDeferredCriticalSection(void);
void __stdcall RtlpDphInitializeDelayedFreeQueue(void);
extern RTL_CRITICAL_SECTION RtlpDphHeapListCriticalSection;

VOID __stdcall LdrpInitialize (IN PCONTEXT Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2);

void NtdllMain()
{
    PPEB PPeb = NtCurrentPeb();
    PTEB PTeb = NtCurrentTeb();
    PEB  Peb;
    TEB  Teb;
    HANDLE NtdllModuleHandle = GetModuleHandleW(L"ntdll.dll");
    HANDLE MyModuleHandle = GetModuleHandleW(NULL);
    PIMAGE_NT_HEADERS MyHeaders = RtlImageNtHeader(MyModuleHandle);
    /*const*/ static IMAGE_NT_HEADERS ZeroHeaders = { 0 };
    SIZE_T RegionSize = 0x10000;
    PVOID  Base = MyModuleHandle;
    ULONG  OldProtect = 0;
    NTSTATUS Status;

    Status = NtProtectVirtualMemory(
                NtCurrentProcess(),
                &Base,
                &RegionSize,
                PAGE_EXECUTE_READWRITE,
                &OldProtect
                );
/*
    WriteProcessMemory(
        NtCurrentProcess(),
        &MyHeaders->OptionalHeader.DataDirectory,
        &ZeroHeaders,
        sizeof(MyHeaders->OptionalHeader.DataDirectory),
        NULL
        );
*/
    RtlZeroMemory(&MyHeaders->OptionalHeader.DataDirectory, sizeof(MyHeaders->OptionalHeader.DataDirectory));
#if 0
    NLSTABLEINFO InitTableInfo = {0};

    RtlInitNlsTables(
        Peb->AnsiCodePageData,
        Peb->OemCodePageData,
        Peb->UnicodeCaseTableData,
        &InitTableInfo
        );

    RtlResetRtlTranslations(&InitTableInfo);

    RtlpInitDeferredCriticalSection();
    RtlInitializeCriticalSection( &RtlpDphHeapListCriticalSection );
    RtlpDphInitializeDelayedFreeQueue();
#elif 1
    Peb = *PPeb;
    Teb = *PTeb;
    RtlZeroMemory(NtCurrentPeb(), sizeof(*NtCurrentPeb()));
    PPeb->ProcessParameters = Peb.ProcessParameters;
    PPeb->BeingDebugged = Peb.BeingDebugged;
    PPeb->FastPebLock = Peb.FastPebLock;
    PPeb->FastPebLockRoutine = Peb.FastPebLockRoutine;
    PPeb->FastPebUnlockRoutine = Peb.FastPebUnlockRoutine;
    PPeb->ProcessHeap = Peb.ProcessHeap;
    PPeb->ImageBaseAddress = Peb.ImageBaseAddress;
    PPeb->AnsiCodePageData = Peb.AnsiCodePageData;
    PPeb->OemCodePageData = Peb.OemCodePageData;
    PPeb->UnicodeCaseTableData = Peb.UnicodeCaseTableData;
    PPeb->NtGlobalFlag = Peb.NtGlobalFlag
                    /*
                   | FLG_HEAP_ENABLE_TAIL_CHECK |
                     FLG_HEAP_ENABLE_FREE_CHECK |
                     FLG_HEAP_VALIDATE_PARAMETERS |
                     FLG_HEAP_VALIDATE_ALL |
                     FLG_HEAP_ENABLE_TAGGING
                     */
                     ;
    __try
    {
        //LdrpInitialize(0, NtdllModuleHandle, 0);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    PPeb->ProcessParameters = Peb.ProcessParameters;
    PPeb->BeingDebugged = Peb.BeingDebugged;
    PPeb->NtGlobalFlag = Peb.NtGlobalFlag
                    /*
                   | FLG_HEAP_ENABLE_TAIL_CHECK |
                     FLG_HEAP_ENABLE_FREE_CHECK |
                     FLG_HEAP_VALIDATE_PARAMETERS |
                     FLG_HEAP_VALIDATE_ALL |
                     FLG_HEAP_ENABLE_TAGGING
                     */
                     ;
    PPeb->FastPebLock = Peb.FastPebLock;
    PPeb->FastPebLockRoutine = Peb.FastPebLockRoutine;
    PPeb->ProcessHeap = Peb.ProcessHeap;
    PPeb->FastPebUnlockRoutine = Peb.FastPebUnlockRoutine;
    PPeb->ImageBaseAddress = Peb.ImageBaseAddress;
    PPeb->AnsiCodePageData = Peb.AnsiCodePageData;
    PPeb->OemCodePageData = Peb.OemCodePageData;
    PPeb->UnicodeCaseTableData = Peb.UnicodeCaseTableData;
    PPeb->Ldr = Peb.Ldr;
#else
#endif
}
#else
void NtdllMain() { }
#include "curdir.c"
#endif

// WriteProcessMemory(1 + (ULONG_PTR)RtlEnterCriticalSection, GetModuleHandleW(L"ntdll.dll"), "RtlEnterCriticalSection"

static BOOLEAN InMain;

int __cdecl main(int argc, char** argv)
{
    UCHAR Buffer[100];
    RTL_UNICODE_STRING_BUFFER StringBuffer = {0};
    UNICODE_STRING String = {0};
    ULONG i = 0;
    PCWSTR x = 0;
    PCWSTR y = 0;
    NTSTATUS Status = 0;

    const static WCHAR AppendPathElementTestData[] =
    {
// noslash
        L"a\0bar\0" // =  a\b
// one slash
        L"/a\0bar\0" // = /a/b
        L"a/\0bar\0" // = /a/b/
        L"a\0/b\0" // =  a/b
        L"a\0bar/\0" // =  a/b/
// two slashes
        L"/a/\0bar\0" // = /a/b/
        L"/a\0/b\0" // = /a/b
        L"/a\0bar/\0" // = /a/b/
        L"a/\0/b\0" // =  a/b/
        L"a/\0bar/\0" // =  a/b/
        L"a\0/b/\0" // =  a/b/
// three slashes
        L"/a/\0/b\0" // = /a/b/
        L"/a/\0bar/\0" // = /a/b/
        L"/a\0/b/\0" // = /a/b/
        L"a/\0/b/\0" // =  a/b
// four slashes
        L"/a/\0/b/\0" // = /a/b/
//
// 1 + 4 + 6 + 4 + 1 = 4^2 = 16 posibilities
        L"\0"
    };

    const static WCHAR RemoveLastPathElementTestData[] =
    {

    //
    // move/copy cases to the top to debug them
    //
        //L"c:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
        //L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
        //L"\0"

        L"\\\\a\\\\b\\\\c\\\\\0"

        L"x:\\\0"

        L"c:a\\\\b\\c\\\\\0"

        L"\\\\?\\a:\\\0"

        L"\\\\?\\unc\\a\\b\0"

        L"\\\0"
        L"\\\\\0"
        L"\\\\?\0"

        L"\\\\?\\unc\0"
        L"\\\\?\\unc\\a\0"
        L"\\\\?\\unc\\a\\b\0"
        L"\\\\?\\unc\\a\\b\\c\0"

        L"\\\\?\\a\0"
        L"\\\\?\\a\\b\0"
        L"\\\\?\\a\\b\\c\0"

        L"\\\\?\\a:\0"
        L"\\\\?\\a:\\\0"
        L"\\\\?\\a:\\b\0"
        L"\\\\?\\a:\\b\\c\0"

        L"\\\\a\\\\b\\c\\\\\0"
        L"\\\\a\\\\b\\c\\\0"
        L"\\\\a\\\\b\\c/\0"
        L"\\\\a\\\\b\\c//\0"
        L"\\\\a\\\\b\\c/\\\0"
        L"\\\\a\\\\b\\c\\/\0"
        L"\\\\a\\\\b\\c\0"

        L"\\\\a\\b\\c\\\\\0"
        L"\\\\a\\b\\c\\\0"
        L"\\\\a\\b\\c/\0"
        L"\\\\a\\b\\c//\0"
        L"\\\\a\\b\\c/\\\0"
        L"\\\\a\\b\\c\\/\0"
        L"\\\\a\\b\\c\0"

        L"\\\\a/b\\c\\\\\0"
        L"\\\\a/b\\c\\\0"
        L"\\\\a/b\\c/\0"
        L"\\\\a/b\\c//\0"
        L"\\\\a/b\\c/\\\0"
        L"\\\\a/b\\c\\/\0"
        L"\\\\a/b\\c\0"

        L"\\\\a//b\\c\\\\\0"
        L"\\\\a//b\\c\\\0"
        L"\\\\a//b\\c/\0"
        L"\\\\a//b\\c//\0"
        L"\\\\a//b\\c/\\\0"
        L"\\\\a//b\\c\\/\0"
        L"\\\\a//b\\c\0"

        L"\\\\a/\\b\\c\\\\\0"
        L"\\\\a/\\b\\c\\\0"
        L"\\\\a/\\b\\c/\0"
        L"\\\\a/\\b\\c//\0"
        L"\\\\a/\\b\\c/\\\0"
        L"\\\\a/\\b\\c\\/\0"
        L"\\\\a/\\b\\c\0"

        L"\\\\a\\/b\\c\\\\\0"
        L"\\\\a\\/b\\c\\\0"
        L"\\\\a\\/b\\c/\0"
        L"\\\\a\\/b\\c//\0"
        L"\\\\a\\/b\\c/\\\0"
        L"\\\\a\\/b\\c\\/\0"
        L"\\\\a\\/b\\c\0"

        L"\\\\\0"
        L"//\0"
        L"/\\\0"
        L"\\/\0"

        L"x:\\\\a\\\\b\\c\\\\\0"
        L"x:\\\\a\\\\b\\c\\\0"
        L"x:\\\\a\\\\b\\c/\0"
        L"x:\\\\a\\\\b\\c//\0"
        L"x:\\\\a\\\\b\\c/\\\0"
        L"x:\\\\a\\\\b\\c\\/\0"
        L"x:\\\\a\\\\b\\c\0"

        L"x:\\\\a\\b\\c\\\\\0"
        L"x:\\\\a\\b\\c\\\0"
        L"x:\\\\a\\b\\c/\0"
        L"x:\\\\a\\b\\c//\0"
        L"x:\\\\a\\b\\c/\\\0"
        L"x:\\\\a\\b\\c\\/\0"
        L"x:\\\\a\\b\\c\0"

        L"x:\\\\a/b\\c\\\\\0"
        L"x:\\\\a/b\\c\\\0"
        L"x:\\\\a/b\\c/\0"
        L"x:\\\\a/b\\c//\0"
        L"x:\\\\a/b\\c/\\\0"
        L"x:\\\\a/b\\c\\/\0"
        L"x:\\\\a/b\\c\0"

        L"x:\\\\a//b\\c\\\\\0"
        L"x:\\\\a//b\\c\\\0"
        L"x:\\\\a//b\\c/\0"
        L"x:\\\\a//b\\c//\0"
        L"x:\\\\a//b\\c/\\\0"
        L"x:\\\\a//b\\c\\/\0"
        L"x:\\\\a//b\\c\0"

        L"x:\\\\a/\\b\\c\\\\\0"
        L"x:\\\\a/\\b\\c\\\0"
        L"x:\\\\a/\\b\\c/\0"
        L"x:\\\\a/\\b\\c//\0"
        L"x:\\\\a/\\b\\c/\\\0"
        L"x:\\\\a/\\b\\c\\/\0"
        L"x:\\\\a/\\b\\c\0"

        L"x:\\\\a\\/b\\c\\\\\0"
        L"x:\\\\a\\/b\\c\\\0"
        L"x:\\\\a\\/b\\c/\0"
        L"x:\\\\a\\/b\\c//\0"
        L"x:\\\\a\\/b\\c/\\\0"
        L"x:\\\\a\\/b\\c\\/\0"
        L"x:\\\\a\\/b\\c\0"

        L"x:\\\\a\\\\\0"
        L"x:\\\\a\\\0"
        L"x:\\\\a/\0"
        L"x:\\\\a//\0"
        L"x:\\\\a/\\\0"
        L"x:\\\\a\\/\0"
        L"x:\\\\a\0"

        L"x:\\a\\\\\0"
        L"x:\\a\\\0"
        L"x:\\a/\0"
        L"x:\\a//\0"
        L"x:\\a/\\\0"
        L"x:\\a\\/\0"
        L"x:\\a\0"

        L"x:/a\\\\\0"
        L"x:/a\\\0"
        L"x:/a/\0"
        L"x:/a//\0"
        L"x:/a/\\\0"
        L"x:/a\\/\0"
        L"x:/a\0"

        L"x:\\\0"
        L"x:/\0"
        L"x:\0"
        L"c\0"

        //////////////////////////////////////////////////////////////////////////

        L"a\\\\b\\c\\\\\0"
        L"a\\\\b\\c\\\0"
        L"a\\\\b\\c/\0"
        L"a\\\\b\\c//\0"
        L"a\\\\b\\c/\\\0"
        L"a\\\\b\\c\\/\0"
        L"a\\\\b\\c\0"

        L"a\\b\\c\\\\\0"
        L"a\\b\\c\\\0"
        L"a\\b\\c/\0"
        L"a\\b\\c//\0"
        L"a\\b\\c/\\\0"
        L"a\\b\\c\\/\0"
        L"a\\b\\c\0"

        L"a/b\\c\\\\\0"
        L"a/b\\c\\\0"
        L"a/b\\c/\0"
        L"a/b\\c//\0"
        L"a/b\\c/\\\0"
        L"a/b\\c\\/\0"
        L"a/b\\c\0"

        L"a//b\\c\\\\\0"
        L"a//b\\c\\\0"
        L"a//b\\c/\0"
        L"a//b\\c//\0"
        L"a//b\\c/\\\0"
        L"a//b\\c\\/\0"
        L"a//b\\c\0"

        L"a/\\b\\c\\\\\0"
        L"a/\\b\\c\\\0"
        L"a/\\b\\c/\0"
        L"a/\\b\\c//\0"
        L"a/\\b\\c/\\\0"
        L"a/\\b\\c\\/\0"
        L"a/\\b\\c\0"

        L"a\\/b\\c\\\\\0"
        L"a\\/b\\c\\\0"
        L"a\\/b\\c/\0"
        L"a\\/b\\c//\0"
        L"a\\/b\\c/\\\0"
        L"a\\/b\\c\\/\0"
        L"a\\/b\\c\0"

        L"x:a\\\\b\\c\\\\\0"
        L"x:a\\\\b\\c\\\0"
        L"x:a\\\\b\\c/\0"
        L"x:a\\\\b\\c//\0"
        L"x:a\\\\b\\c/\\\0"
        L"x:a\\\\b\\c\\/\0"
        L"x:a\\\\b\\c\0"

        L"x:a\\b\\c\\\\\0"
        L"x:a\\b\\c\\\0"
        L"x:a\\b\\c/\0"
        L"x:a\\b\\c//\0"
        L"x:a\\b\\c/\\\0"
        L"x:a\\b\\c\\/\0"
        L"x:a\\b\\c\0"

        L"x:a/b\\c\\\\\0"
        L"x:a/b\\c\\\0"
        L"x:a/b\\c/\0"
        L"x:a/b\\c//\0"
        L"x:a/b\\c/\\\0"
        L"x:a/b\\c\\/\0"
        L"x:a/b\\c\0"

        L"x:a//b\\c\\\\\0"
        L"x:a//b\\c\\\0"
        L"x:a//b\\c/\0"
        L"x:a//b\\c//\0"
        L"x:a//b\\c/\\\0"
        L"x:a//b\\c\\/\0"
        L"x:a//b\\c\0"

        L"x:a/\\b\\c\\\\\0"
        L"x:a/\\b\\c\\\0"
        L"x:a/\\b\\c/\0"
        L"x:a/\\b\\c//\0"
        L"x:a/\\b\\c/\\\0"
        L"x:a/\\b\\c\\/\0"
        L"x:a/\\b\\c\0"

        L"x:a\\/b\\c\\\\\0"
        L"x:a\\/b\\c\\\0"
        L"x:a\\/b\\c/\0"
        L"x:a\\/b\\c//\0"
        L"x:a\\/b\\c/\\\0"
        L"x:a\\/b\\c\\/\0"
        L"x:a\\/b\\c\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"\\a\\b\\c\\\\\0"
        L"\\a\\b\\c\\\0"
        L"\\a\\b\\c/\0"
        L"\\a\\b\\c//\0"
        L"\\a\\b\\c/\\\0"
        L"\\a\\b\\c\\/\0"
        L"\\a\\b\\c\0"

        L"\\a\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\b\\c\0"

        L"\0\0"
    };

    if (InMain)
        return;
    InMain = TRUE;

    NtdllMain();

    Status = RtlInitUnicodeStringBuffer(&StringBuffer, Buffer, sizeof(Buffer));
    RTL_SOFT_ASSERT(NT_SUCCESS(Status));

#if 1
    for (   (x = AppendPathElementTestData, y = x + wcslen(x) + 1) ;
            *x && *y ;
            (x = y + wcslen(y) + 1, y = x + wcslen(x) + 1)
        )
    {
        RtlInitUnicodeString(&String, x);
        RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAssignUnicodeStringBuffer(&StringBuffer, &String)));
        RtlInitUnicodeString(&String, y);

        RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAppendPathElement(0, &StringBuffer, &String)));

        printf("%ls + %ls = %ls\n", x, y, StringBuffer.String.Buffer);
    }
#endif


#if 1
    printf("\n\nDosPath<->NtPath conversion\n\n");

    for (x = RemoveLastPathElementTestData ; *x || *(x + 1) ; x += + wcslen(x) + 1)
    {
        UNICODE_STRING DosToNt = {0};
        RTL_UNICODE_STRING_BUFFER NtToDos = {0};
        BOOLEAN  Success;

        RtlInitUnicodeStringBuffer(&NtToDos, 0, 0);
        //RtlInitUnicodeStringBuffer(&NtToDos, Buffer, sizeof(Buffer));

        RTL_SOFT_VERIFY(Success = RtlDosPathNameToNtPathName_U(x, &DosToNt, NULL, NULL));

        if (!Success)
            printf("%ls failed\n", x);
        else if (DosToNt.Length && DosToNt.Buffer)
        {
            printf("%ls -> %ls\n", x, DosToNt.Buffer);

            RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAssignUnicodeStringBuffer(&NtToDos, &DosToNt)));
            RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlNtPathNameToDosPathName(0, &NtToDos, NULL, NULL)));

            if (Status != STATUS_SUCCESS)
                printf("%ls Status = 0x%08lx\n", x, Status);
            else if (NtToDos.String.Length && NtToDos.String.Buffer)
                printf("%ls -> %ls\n\n", DosToNt.Buffer, NtToDos.String.Buffer);
        }

        RtlFreeStringRoutine(DosToNt.Buffer);
        RtlFreeUnicodeStringBuffer(&NtToDos);
    }
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\vectxcpt.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vectxcpt.c

Abstract:

    This module implements call out functionality needed to
    implement vectored exception handlers

Author:

    Mark Lucovsky (markl) 14-Feb-2000

Revision History:

--*/

#include <ldrp.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

typedef struct _VECTXCPT_CALLOUT_ENTRY {
    LIST_ENTRY Links;
    PVECTORED_EXCEPTION_HANDLER VectoredHandler;
} VECTXCPT_CALLOUT_ENTRY, *PVECTXCPT_CALLOUT_ENTRY;

BOOLEAN
RtlCallVectoredExceptionHandlers(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )
/*++

Routine Description:

    This function is called by the user-mode exception dispatcher trampoline
    logic prior to performing a frame based exception handler search.
    
    It's purpose is call any registered vectored exception handlers. If any one
    of the registered handlers tells this function to continue execution, exception
    handler searching is terminated and the passed in context is restored.
    
    If none of the vectored handlers returns this indication, frame based handling 
    resumes.

Arguments:

    ExceptionInfo - Supplies the address of an EXCEPTION_POINTERS structures
        that defines the current exception.
        
Return Value:

    EXCEPTION_CONTINUE_EXECUTION - A vectored handler would like execution to continue
        without searching for frame based exception handlers
        
    EXCEPTION_CONTINUE_SEARCH - None of the vectored handlers have "handled" the 
        exception, so frame based handlers should be searched

--*/
{
    
    PLIST_ENTRY Next;
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;
    LONG ReturnValue;
    EXCEPTION_POINTERS ExceptionInfo;

    if (IsListEmpty (&RtlpCalloutEntryList)) {
        return FALSE;
    }

    ExceptionInfo.ExceptionRecord = ExceptionRecord;
    ExceptionInfo.ContextRecord = ContextRecord;
    
    RtlEnterCriticalSection(&RtlpCalloutEntryLock);
    
    Next = RtlpCalloutEntryList.Flink;

    while ( Next != &RtlpCalloutEntryList) {

        //
        // Call all of the vectored handlers
        // The first one that returns EXCEPTION_CONTINUE_EXECUTION is assumed to
        // have "handled" the exception.
        //

        CalloutEntry = (PVECTXCPT_CALLOUT_ENTRY)(CONTAINING_RECORD(Next,VECTXCPT_CALLOUT_ENTRY,Links));
        ReturnValue = (CalloutEntry->VectoredHandler)(&ExceptionInfo);
        if (ReturnValue == EXCEPTION_CONTINUE_EXECUTION) {
            RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
            return TRUE;
        }
        Next = Next->Flink;
    }
    RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
    return FALSE;
}

PVOID
RtlAddVectoredExceptionHandler(
    IN ULONG FirstHandler,
    IN PVECTORED_EXCEPTION_HANDLER VectoredHandler
    )
/*++

Routine Description:

    This function is used to register a vectored exception handler. The caller
    can request that this be the first handler, or the last handler called by
    using the FirstHandler argument.
    
    If this API is used and that VectoredHandler points to a DLL, and that DLL unloads,
    the unload does not invalidate the registration of the handler. This is considered a
    programming error.
    
Arguments:

    FirstHandler - If non-zero, specifies that the VectoredHandler should be the
        first handler called. This of course changes when a subsequent call is
        made by other code in the process that also requests to be the FirstHandler. If zero,
        the vectored handler is added as the last handler to be called.

    VectoredHandler - Supplies the address of the handler to call.

Return Value:

    NULL - The operation failed. No further error status is available.
        
    Non-Null - The operation was successful. This value may be used in a subsequent call
        to RtlRemoveVectoredExceptionHandler.

--*/
{
    
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;

    CalloutEntry = RtlAllocateHeap(RtlProcessHeap(),0,sizeof(*CalloutEntry));

    if (CalloutEntry) {
        CalloutEntry->VectoredHandler = VectoredHandler;

        RtlEnterCriticalSection(&RtlpCalloutEntryLock);
        if (FirstHandler) {
            InsertHeadList(&RtlpCalloutEntryList,&CalloutEntry->Links);
        } else {
            InsertTailList(&RtlpCalloutEntryList,&CalloutEntry->Links);
        }
        RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
    }
    return CalloutEntry;
}


ULONG
RtlRemoveVectoredExceptionHandler(
    IN PVOID VectoredHandlerHandle
    )
/*++

Routine Description:

    This function is used to un-register a vectored exception handler.
    
Arguments:

    VectoredHandlerHandle - Specifies a vectored handler previsouly registerd using
        RtlAddVectoredExceptionHandler.

Return Value:

    Non-Zero - The operation was successful. The vectored handler associated with the
        specified VectoredHandlerHandle will not be called.
        
    Zero - The operation failed. The specified VecoteredHandlerHandle does not match
        a handler previously added with RtlAddVectoredExceptionHandler.

--*/
{
    
    PLIST_ENTRY Next;
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;

    RtlEnterCriticalSection(&RtlpCalloutEntryLock);
    Next = RtlpCalloutEntryList.Flink;

    while ( Next != &RtlpCalloutEntryList) {

        CalloutEntry = (PVECTXCPT_CALLOUT_ENTRY)(CONTAINING_RECORD(Next,VECTXCPT_CALLOUT_ENTRY,Links));
        
        if (CalloutEntry == VectoredHandlerHandle) {
            RemoveEntryList(&CalloutEntry->Links);
            RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
            RtlFreeHeap(RtlProcessHeap(),0,CalloutEntry);
            return TRUE;
        }
        Next = Next->Flink;
    }
    RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
        
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntdll\verifier.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    verifier.c

Abstract:

    This module implements the core support for application verifier.

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/


#include "ldrp.h"
#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>

#define AVRF_FLG_EXPORT_DLL_LOADED 0x0001

ULONG AVrfpDebug = 0x0000;

#define AVRF_DBG_SHOW_SNAPS             0x0001
#define AVRF_DBG_SHOW_VERIFIED_EXPORTS  0x0002
#define AVRF_DBG_SHOW_DLLS_WITH_EXPORTS 0x0004
#define AVRF_DBG_SHOW_PROVIDER_LOADS    0x0008
#define AVRF_DBG_SHOW_CHAIN_ACTIVITY    0x0010
#define AVRF_DBG_SHOW_CHAIN_DETAILS     0x0020
#define AVRF_DBG_SHOW_PAGE_HEAP_DETAILS 0x0040

BOOLEAN AVrfpEnabled;

//
// Default system-wide settings
//

#define RTL_VRF_FLG_SYSTEM_WIDE_SETTINGS              \
    (0                                                \
    | RTL_VRF_FLG_FAST_FILL_HEAP                      \
    | RTL_VRF_FLG_LOCK_CHECKS                         \
    | RTL_VRF_FLG_HANDLE_CHECKS                       \
    )

//
// Local vars
//

ULONG AVrfpVerifierFlags;
LOGICAL AVrfpEnabledSystemWide;
WCHAR AVrfpVerifierDllsString [512];
LIST_ENTRY AVrfpVerifierProvidersList;

RTL_CRITICAL_SECTION AVrfpVerifierLock;

#define VERIFIER_LOCK()  RtlEnterCriticalSection(&AVrfpVerifierLock)
#define VERIFIER_UNLOCK()  RtlLeaveCriticalSection(&AVrfpVerifierLock)

ULONG AVrfpVirtualProtectFailures; 

//
// Local types
//

typedef struct _AVRF_VERIFIER_DESCRIPTOR {

    LIST_ENTRY List;
    UNICODE_STRING VerifierName;
    PVOID VerifierHandle;
    PVOID VerifierEntryPoint;
    PRTL_VERIFIER_DLL_DESCRIPTOR VerifierDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK VerifierLoadHandler;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK VerifierUnloadHandler;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK VerifierNtdllHeapFreeHandler;

} AVRF_VERIFIER_DESCRIPTOR, *PAVRF_VERIFIER_DESCRIPTOR;

//
// Local functions
//

NTSTATUS
AVrfpSnapDllImports (
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

BOOLEAN
AVrfpDetectVerifiedExports (
    PRTL_VERIFIER_DLL_DESCRIPTOR Dll,
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks
    );

BOOLEAN
AVrfpParseVerifierDllsString (
    PWSTR Dlls
    );

VOID
AVrfpSnapAlreadyLoadedDlls (
    );

VOID
AVrfpMoveProviderToEndOfInitializationList (
    PWSTR ProviderName
    );

BOOLEAN
AVrfpLoadAndInitializeProvider (
    PAVRF_VERIFIER_DESCRIPTOR Provider
    );

BOOLEAN
AVrfpIsVerifierProviderDll (
    PVOID Handle
    );

VOID
AVrfpDumpProviderList (
    );

PVOID
AVrfpFindClosestThunkDuplicate (
    PAVRF_VERIFIER_DESCRIPTOR Verifier,
    PWCHAR DllName,
    PCHAR ThunkName
    );

VOID
AVrfpChainDuplicateVerificationLayers (
    );

NTSTATUS
AVrfpDllLoadNotificationInternal (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

PWSTR
AVrfpGetProcessName (
    );

BOOLEAN
AVrfpEnableVerifierOptions (
    );

LOGICAL
AVrfpIsDebuggerPresent (
    VOID
    );

NTSTATUS
AVrfpVerifierStopInitialize (
    VOID
    );

VOID
RtlpPageHeapStop (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    );

int __cdecl _snwprintf (wchar_t *, size_t, const wchar_t *, ...);
int __cdecl swprintf (wchar_t *, const wchar_t *, ...);
int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// ISSUE: SilviuC: should change this to return status and fail process init

VOID
AVrfInitializeVerifier (
    BOOLEAN EnabledSystemWide,
    PCUNICODE_STRING ImageName,
    ULONG Phase
    )
/*++

Routine description:

    This routine initializes the verifier package. Reads options 
    from registry, loads verifier dlls, etc.

Parameters:

    EnabledSystemWide - true if all processes are supposed to run with
        application verifier enabled. If this is the case we will scale
        down our memory-demanding checks so that we can boot.

    ImageName - unicode name of the current process
    
    Phase - initialization happens in several stages. 
        0 - we read registry settings under image file execution options.
            in this phase the other two parameters have a meaning.
        1 - we parse the verifier dlls and load them.    
    
Return value:

    None.
            
--*/
{
    BOOLEAN Result;
    PLIST_ENTRY Entry;
    PAVRF_VERIFIER_DESCRIPTOR Provider;
    BOOLEAN LoadSuccess;
    NTSTATUS Status;
    ULONG RegistryFlags = 0;

    switch (Phase) {
        
        case 0: // Phase 0

            AVrfpVerifierFlags = RTL_VRF_FLG_SYSTEM_WIDE_SETTINGS;
            AVrfpVerifierDllsString[0] = L'\0';

            //
            // Attempt to read verifier registry settings even if verifier
            // is enabled system wide. In the worst case no values are there 
            // and nothing will be read. If we have some options per process
            // this will override system wide settings.
            //

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierFlags",
                                               REG_DWORD,
                                               &RegistryFlags, 
                                               sizeof(AVrfpVerifierFlags),
                                               NULL);

            if (RegistryFlags == 0) {

                //
                // Store if verifier enabled system wide. We will need it during
                // phase 1 initialization but in that case the EnabledsystemWide
                // parameter will not have an accurate value. We do it only if
                // we do not find a setting or the setting is zero.
                //

                if (EnabledSystemWide) {
                    AVrfpEnabledSystemWide = TRUE;
                }
            }
            else {

                AVrfpVerifierFlags = RegistryFlags;
            }

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierDebug",
                                               REG_DWORD,
                                               &AVrfpDebug,
                                               sizeof(AVrfpDebug),
                                               NULL);

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierDlls",
                                               REG_SZ,
                                               AVrfpVerifierDllsString,
                                               512,
                                               NULL);

            AVrfpEnableVerifierOptions ();

            break;

        case 1: // Phase 1

            InitializeListHead (&AVrfpVerifierProvidersList);
            Status = RtlInitializeCriticalSection (&AVrfpVerifierLock);
            if (! NT_SUCCESS(Status)) {

                goto Done;
            }

            DbgPrint ("AVRF: %ws: pid 0x%X: flags 0x%X: application verifier enabled\n",
                      AVrfpGetProcessName(),
                      RtlGetCurrentProcessId(),
                      AVrfpVerifierFlags);

            Result = AVrfpParseVerifierDllsString (AVrfpVerifierDllsString);

            if (Result == FALSE) {
                
                DbgPrint ("AVRF: %ws: pid 0x%X: application verifier will be disabled due to an initialization error.\n",
                          AVrfpGetProcessName(),
                          RtlGetCurrentProcessId());

                NtCurrentPeb()->NtGlobalFlag &= ~FLG_APPLICATION_VERIFIER;
            }

            Entry = AVrfpVerifierProvidersList.Flink;

            while  (Entry != &AVrfpVerifierProvidersList) {

                Provider = CONTAINING_RECORD (Entry,
                                              AVRF_VERIFIER_DESCRIPTOR,
                                              List);

                //
                // Load provider, probe it to make sure it is really a
                // provider, call initialize routine with PROCESS_VERIFIER, etc.
                //

                LoadSuccess = AVrfpLoadAndInitializeProvider (Provider);

                //
                // Move to next provider
                //

                Entry = Provider->List.Flink;

                //
                // Get this provider out of the providers list if we
                // encountered an error while loading
                //

                if (! LoadSuccess) {

                    RemoveEntryList (&Provider->List);

                    RtlFreeHeap (RtlProcessHeap(), 0, Provider);
                }
            }

            //
            // Chain duplicate verification functions.
            //

            AVrfpChainDuplicateVerificationLayers ();

            //
            // Enable verifier. Resnap already loaded dlls.
            // Now we will start processing dll load
            // notifications coming from loader.
            //

            AVrfpEnabled = TRUE; 

            AVrfpSnapAlreadyLoadedDlls ();

            if ((AVrfpDebug & AVRF_DBG_SHOW_PROVIDER_LOADS)) {

                DbgPrint ("AVRF: -*- final list of providers -*- \n");
                AVrfpDumpProviderList ();
            }

            //
            // Enable verifier stops logic. This involves discovering the
            // entry point for VerifierStopMessage from verifier.dll ...
            //

            AVrfpVerifierStopInitialize ();
            
            break;

        default:

            break;
    }

Done:

    NOTHING;
}

extern const WCHAR VerifierDllWCharArray[] = L"verifier.dll";
extern const UNICODE_STRING VerifierDllString =
{
    sizeof(VerifierDllWCharArray) - sizeof(VerifierDllWCharArray[0]),
    sizeof(VerifierDllWCharArray),
    (PWSTR)VerifierDllWCharArray
};

BOOLEAN
AVrfpParseVerifierDllsString (
    PWSTR Dlls
    )
{
    PWSTR Current;
    PWSTR Start;
    WCHAR Save;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    HANDLE Heap;

    //
    // Create by default an entry for the standard provider "verifier.dll"
    //

    Entry = RtlAllocateHeap (Heap = RtlProcessHeap (), 0, sizeof *Entry);

    if (Entry == NULL) {
        return FALSE;
    }

    RtlZeroMemory (Entry, sizeof *Entry);

    Entry->VerifierName = VerifierDllString;

    InsertTailList (&AVrfpVerifierProvidersList, &Entry->List);

    //
    // Parse the string
    //

    Current = Dlls;

    while (*Current != L'\0') {
        
        while (*Current == L' ' || *Current == L'\t') {
            Current += 1;
        }

        Start = Current;

        while (*Current && *Current != L' ' && *Current != L'\t') {
            Current += 1;
        }

        if (Start == Current) {
            break;
        }

        Save = *Current;
        *Current = L'\0';

        //
        // Check if standard provider was specified explicitely.
        // In this case we ignore it because we already have it 
        // in the list.
        //

        if (_wcsicmp (Start, VerifierDllWCharArray) != 0) {
            
            Entry = RtlAllocateHeap (Heap, 0, sizeof *Entry);

            if (Entry == NULL) {
                return FALSE;
            }

            RtlZeroMemory (Entry, sizeof *Entry);

            RtlInitUnicodeString (&Entry->VerifierName, Start);

            InsertTailList (&AVrfpVerifierProvidersList, &Entry->List);
        }

        // *Current = Save;
        Current += 1;
    }   

    return TRUE;
}


VOID
AVrfpSnapAlreadyLoadedDlls (
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;

    Ldr = &PebLdr;
    Head = &Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next, 
                                   LDR_DATA_TABLE_ENTRY, 
                                   InLoadOrderLinks);
        Next = Next->Flink;

        if (! AVrfpIsVerifierProviderDll (Entry->DllBase)) {

            if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {

                DbgPrint ("AVRF: resnapping %ws ... \n", 
                            Entry->BaseDllName.Buffer);
            }

            AVrfpDllLoadNotificationInternal (Entry);
        }
        else {

            if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {

                DbgPrint ("AVRF: skipped resnapping provider %ws ... \n", 
                            Entry->BaseDllName.Buffer);
            }
        }
    }
}


VOID
AVrfpMoveProviderToEndOfInitializationList (
    PWSTR ProviderName
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;
    BOOLEAN Done = FALSE;

    Ldr = &PebLdr;
    Head = &Ldr->InInitializationOrderModuleList;
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next, 
                                   LDR_DATA_TABLE_ENTRY, 
                                   InInitializationOrderLinks);
        
        if (_wcsicmp (Entry->BaseDllName.Buffer, ProviderName) == 0) {

            RemoveEntryList (Next);
            InsertTailList (Head, Next);
            Done = TRUE;
            break;
        }

        Next = Next->Flink;
    }

    if (! Done) {
        
        DbgPrint ("AVRF: provider %ws was not found in the initialization list \n",
                    ProviderName);

        DbgBreakPoint ();
    }
}


//
// Disable warnings for conversions from function pointers to data pointers.
// We do this when we pass ntdll private entry points to verifier providers.
//

#pragma warning(disable:4054)

BOOLEAN
AVrfpLoadAndInitializeProvider (
    PAVRF_VERIFIER_DESCRIPTOR Provider
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    BOOLEAN LoadError = FALSE;
    NTSTATUS Status;
    PVOID Descriptor;
    PRTL_VERIFIER_PROVIDER_DESCRIPTOR Dscr;
    BOOLEAN InitStatus;
    static WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING SystemDllPath;

    if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {
        
        DbgPrint ("AVRF: verifier dll `%ws' \n", 
                    Provider->VerifierName.Buffer);
    }

    //
    // Prepare the system search path (%windir%\system32).
    // Verifier providers can be loaded only from this directory.
    //

    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof(SystemDllPathBuffer);

    RtlAppendUnicodeToString (&SystemDllPath, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeStringToString (&SystemDllPath, &SlashSystem32SlashString);

    //
    // Load provider dll
    //

    Status = LdrLoadDll (SystemDllPath.Buffer,
                         NULL,
                         &Provider->VerifierName,
                         &Provider->VerifierHandle);

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: %ws: failed to load provider `%ws' (status %08X) from %ws\n", 
                  AVrfpGetProcessName(),
                  Provider->VerifierName.Buffer,
                  Status,
                  SystemDllPath.Buffer);

        LoadError = TRUE;
        goto Error;
    }
    
    //
    // Make sure we have a dll.
    //

    try {
        
        NtHeaders = RtlImageNtHeader (Provider->VerifierHandle);

        if (! NtHeaders) {

            LoadError = TRUE;
            goto Error;
        }

        if ((NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {

            DbgPrint ("AVRF: provider %ws is not a DLL image \n",
                      Provider->VerifierName.Buffer);

            LoadError = TRUE;
            goto Error;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("AVRF: exception raised while probing provider %ws \n",
                    Provider->VerifierName.Buffer);

        LoadError = TRUE;
        goto Error;
    }

    //
    // We loaded the provider successfully. We will move it to the end
    // of the initialization list so that code from other system dlls
    // on which the provider relies gets initialized first. For normal
    // DLLs this is not an issue but a verifier provider gets loaded
    // before any normal DLL no matter what dependencies has.
    //

    AVrfpMoveProviderToEndOfInitializationList (Provider->VerifierName.Buffer);

    //
    // Now call the initialization routine with the special
    // PROCESS_VERIFIER reason.
    //

    Provider->VerifierEntryPoint = LdrpFetchAddressOfEntryPoint(Provider->VerifierHandle);

    if (Provider->VerifierEntryPoint == NULL) {

        DbgPrint ("AVRF: cannot find an entry point for provider %ws \n",
                    Provider->VerifierName.Buffer);
        
        LoadError = TRUE;
        goto Error;
    }
    
    try {

        //
        // We are passing a pointer to the verifier dll and expect it to
        // fill out its verifier descriptor address in it. 
        //

        Descriptor = NULL;

        InitStatus = LdrpCallInitRoutine ((PDLL_INIT_ROUTINE)(ULONG_PTR)(Provider->VerifierEntryPoint),
                                          Provider->VerifierHandle,
                                          DLL_PROCESS_VERIFIER,
                                          (PCONTEXT)(&Descriptor));

        if (InitStatus && Descriptor != NULL) {

            Dscr = (PRTL_VERIFIER_PROVIDER_DESCRIPTOR)Descriptor;

            //
            // Check if this is really a provider descriptor.
            //

            if (Dscr->Length != sizeof (*Dscr)) {

                LoadError = TRUE;

                DbgPrint ("AVRF: provider %ws passed an invalid descriptor @ %p \n",
                            Provider->VerifierName.Buffer,
                            Descriptor);
            }
            else {

                if ((AVrfpDebug & AVRF_DBG_SHOW_PROVIDER_LOADS)) {

                    DbgPrint ("AVRF: initialized provider %ws (descriptor @ %p) \n",
                                Provider->VerifierName.Buffer,
                                Descriptor);
                }

                Provider->VerifierDlls = Dscr->ProviderDlls;
                Provider->VerifierLoadHandler = Dscr->ProviderDllLoadCallback;
                Provider->VerifierUnloadHandler = Dscr->ProviderDllUnloadCallback;
                Provider->VerifierNtdllHeapFreeHandler = Dscr->ProviderNtdllHeapFreeCallback;

                //
                // Fill out the provider descriptor structure with goodies.
                //

                Dscr->VerifierImage = AVrfpGetProcessName();
                Dscr->VerifierFlags = AVrfpVerifierFlags;
                Dscr->VerifierDebug = AVrfpDebug;

                Dscr->RtlpGetStackTraceAddress = (PVOID)RtlpGetStackTraceAddress;
                Dscr->RtlpDebugPageHeapCreate = (PVOID)RtlpDebugPageHeapCreate;
                Dscr->RtlpDebugPageHeapDestroy = (PVOID)RtlpDebugPageHeapDestroy;

                //
                // If verifier is enabled system wide we need to flip the bit
                // in the VerifierFlags field so that the provider knows about this.
                //

                if (AVrfpEnabledSystemWide) {
                    Dscr->VerifierFlags |= RTL_VRF_FLG_ENABLED_SYSTEM_WIDE;
                }

                //
                // Now call again with PROCESS_ATTACH. verifier.dll knowns how to 
                // deal with multiple PROCESS_ATTACH calls so this is not an issue.
                // We need to do this because of a side-effect created by WinSafer.
                // WinSafer checks every dll load but in order to do this it loads
                // advapi32.dll before anything else. This links statically to a 
                // bunch of others like kerne32.dll, msvcrt.dll, etc. This creates 
                // a different load order and init code in kernel32 runs before 
                // verifier init code managed to run. So this double call here
                // fixes that. 
                //

                InitStatus = LdrpCallInitRoutine ((PDLL_INIT_ROUTINE)(ULONG_PTR)(Provider->VerifierEntryPoint),
                                                  Provider->VerifierHandle,
                                                  DLL_PROCESS_ATTACH,
                                                  (PCONTEXT)(&Descriptor));

                if (! InitStatus) {
                    
                    LoadError = TRUE;

                    DbgPrint ("AVRF: provider %ws did not initialize correctly \n",
                                Provider->VerifierName.Buffer);
                }
            }
        }
        else {

            LoadError = TRUE;

            DbgPrint ("AVRF: provider %ws did not initialize correctly \n",
                        Provider->VerifierName.Buffer);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("AVRF: exception raised in provider %ws initialization routine \n",
                    Provider->VerifierName.Buffer);
        
        LoadError = TRUE;
        goto Error;
    }

    Error:

    return !LoadError;
}


BOOLEAN
AVrfpIsVerifierProviderDll (
    PVOID Handle
    )
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierHandle == Handle) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AVrfpDumpProviderList (
    )
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        DbgPrint ("AVRF: provider %ws \n",
                    Entry->VerifierName.Buffer);
    }
}


PVOID
AVrfpFindClosestThunkDuplicate (
    PAVRF_VERIFIER_DESCRIPTOR Verifier,
    PWCHAR DllName,
    PCHAR ThunkName
    )
/*++

Routine description:

    This function searches the list of providers backwards (reverse load order)
    for a function that verifies original export ThunkName from DllName. This
    is necessary to implement chaining of verification layers.              

Parameters:

    Verifier -  verifier provider descriptor for which we want to find 
        duplicates.                                      
        
    DllName - name of a dll containing a verified export
    
    ThunkName - name of the verified export
    
Return value:

    Address of a verification function for the same thunk. Null if none
    was found.
            
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;
    ULONG Di;
    ULONG Ti;

    Current = Verifier->List.Blink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Blink;

        //
        // Search in this provider for the thunk.
        //

        if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
            
            DbgPrint ("AVRF: chain: searching in %ws\n", 
                        Entry->VerifierName.Buffer);
        }
        
        Dlls = Entry->VerifierDlls;

        for (Di = 0; Dlls[Di].DllName; Di += 1) {

            if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
                
                DbgPrint ("AVRF: chain: dll: %ws\n", 
                            Dlls[Di].DllName);
            }
            
            if (_wcsicmp(Dlls[Di].DllName, DllName) == 0) {

                Thunks = Dlls[Di].DllThunks;

                for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
                        
                        DbgPrint ("AVRF: chain: thunk: %s == %s ?\n", 
                                    Thunks[Ti].ThunkName,
                                    ThunkName);
                    }

                    if (_stricmp(Thunks[Ti].ThunkName, ThunkName) == 0) {
                        
                        if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {

                            DbgPrint ("AVRF: Found duplicate for (%ws: %s) in %ws\n",
                                        DllName,
                                        ThunkName,
                                        Dlls[Di].DllName);
                        }

                        return Thunks[Ti].ThunkNewAddress;
                    }
                }
            }
        }
    }

    return NULL;
}


VOID
AVrfpChainDuplicateVerificationLayers (
    )
/*++

Routine description:

    This routines is called in the final stage of verifier initialization,
    after all provider dlls have been loaded, and makes a final sweep to
    detect providers that attempt to verify the same interface. This will be
    chained together so that they will be called in reverse load order 
    (last declared will be first called).
    
Parameters:

    None.            
    
Return value:

    None.            
    
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;
    ULONG Di;
    ULONG Ti;
    PVOID Duplicate;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        //
        // Search in this provider for duplicate thunks.
        //

        Dlls = Entry->VerifierDlls;

        for (Di = 0; Dlls[Di].DllName; Di += 1) {

            Thunks = Dlls[Di].DllThunks;

            for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {

                    DbgPrint ("AVRF: Checking %ws for duplicate (%ws: %s) \n",
                                Entry->VerifierName.Buffer,
                                Dlls[Di].DllName,
                                Thunks[Ti].ThunkName);
                }

                Duplicate = AVrfpFindClosestThunkDuplicate (Entry,
                                                            Dlls[Di].DllName,
                                                            Thunks[Ti].ThunkName);

                if (Duplicate) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_ACTIVITY)) {

                        DbgPrint ("AVRF: Chaining (%ws: %s) to %ws\n",
                                    Dlls[Di].DllName,
                                    Thunks[Ti].ThunkName,
                                    Entry->VerifierName.Buffer);
                    }
                    
                    Thunks[Ti].ThunkOldAddress = Duplicate;
                }
            }
        }
    }
}


NTSTATUS
AVrfDllLoadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    )
/*++

Routine description:

    This routine is the DLL load hook of application verifier. It gets called
    whenever a dll got loaded in the process space and after its import
    descriptors have been walked.

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // Do nothing if application verifier is not enabled. The function
    // should not even get called if the flag is not set but we
    // double check just in case.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return STATUS_SUCCESS;
    }
    
    //
    // Get verifier global lock.
    //

    VERIFIER_LOCK ();

    //
    // We skip verifier providers. Otherwise we get into infinite loops.
    //

    if (AVrfpIsVerifierProviderDll (LoadedDllData->DllBase)) {
        goto Exit;
    }

    //
    // Call internal function.
    //

    Status = AVrfpDllLoadNotificationInternal (LoadedDllData);

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Iterate the verifier provider list and notify each one of the
    // load event.

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierLoadHandler) {

            Entry->VerifierLoadHandler (LoadedDllData->BaseDllName.Buffer,
                                        LoadedDllData->DllBase,
                                        LoadedDllData->SizeOfImage,
                                        LoadedDllData);
        }
    }
    
    Exit:

    VERIFIER_UNLOCK ();
    return Status;
}


NTSTATUS
AVrfpDllLoadNotificationInternal (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    )
/*++

Routine description:

    This routine is the DLL load hook of application verifier. It gets called
    whenever a dll got loaded in the process space and after its import
    descriptors have been walked. It is also called internally in early stages 
    of process initialization when we just loaded verifier providers and
    we need to resnap dlls already loaded (.exe, ntdll.dll (although on
    ntdll this will have zero effect because it does not import anything)). 

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // If verifier is disabled skip.
    //

    if (AVrfpEnabled == FALSE) {
        return Status;
    }
    
    //
    // Iterate the verifier provider list and for each one determine
    // if one of the dlls that has exports to be verified is loaded.
    // If this is the case we need to look at its export table in order
    // to find out real addresses for functions being redirected.
    //

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        Dlls = Entry->VerifierDlls;

        for (Index = 0; Dlls[Index].DllName; Index += 1) {

            if ((Dlls[Index].DllFlags & AVRF_FLG_EXPORT_DLL_LOADED) == 0) {

                int CompareResult;

                CompareResult = _wcsicmp (LoadedDllData->BaseDllName.Buffer,
                                          Dlls[Index].DllName);

                if (CompareResult == 0) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_DLLS_WITH_EXPORTS)) {
                        
                        DbgPrint ("AVRF: pid 0x%X: found dll descriptor for `%ws' with verified exports \n", 
                                    RtlGetCurrentProcessId(),
                                    LoadedDllData->BaseDllName.Buffer);
                    }

                    //
                    // ISSUE: SilviuC: should check failures in detecting
                    // exports. These can come from fusion land.
                    //

                    AVrfpDetectVerifiedExports (&(Dlls[Index]),
                                                Dlls[Index].DllThunks);
                }
            }
        }
    }

    //
    // Note. We do not have to snap other DLLs already loaded because they cannot
    // possibly have a dependence on a verifier export just discovered in
    // current DLL. If this had been the case, the DLL would have been loaded
    // earlier (before the current one).
    //

    Status = AVrfpSnapDllImports (LoadedDllData);

    return Status;
}


VOID
AVrfDllUnloadNotification (
    PLDR_DATA_TABLE_ENTRY DllData
    )
/*++

Routine description:

    This routine is the DLL unload hook of application verifier. 
    It gets called whenever a dll gets unloaded from the process space.
    The hook is called after the DllMain routine of the DLL got called
    with PROCESS_DETACH therefore this is the right moment to check for 
    leaks.
    
    The function will call DllUnload notification routines for all providers
    loaded into the process space.

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    //
    // Do nothing if application verifier is not enabled. The function
    // should not even get called if the flag is not set but we
    // double check just in case.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    //
    // If verifier is disabled skip.
    //

    if (AVrfpEnabled == FALSE) {
        return;
    }
    
    //
    // Get verifier global lock.
    //

    VERIFIER_LOCK ();

    //
    // We should never get this call for a verifier provider DLL because
    // these are never unloaded.
    //

    if (AVrfpIsVerifierProviderDll (DllData->DllBase)) {

        DbgPrint ("AVRF: AVrfDllUnloadNotification called for a provider (%p) \n", 
                    DllData);

        DbgBreakPoint ();
        VERIFIER_UNLOCK ();
        return;
    }

    //
    // Iterate the verifier provider list and notify each one of the
    // unload event.
    //

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierUnloadHandler) {

            Entry->VerifierUnloadHandler (DllData->BaseDllName.Buffer,
                                          DllData->DllBase,
                                          DllData->SizeOfImage,
                                          DllData);
        }
    }
    
    VERIFIER_UNLOCK ();
}


VOID
AVrfInternalHeapFreeNotification (
    PVOID AllocationBase,
    SIZE_T AllocationSize
    )
/*++

Routine description:

    This routine is the application verifier hook for internal ntdll 
    HeapFree operations. It gets called by the HeapDestroy page heap 
    code for each block in the heap being destroyied. 

Parameters:

    AllocationBase - Heap allocation base address.

    AllocationSize - Heap allocation size.
    
Return value:

    None.
            
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    //
    // Do nothing if application verifier is not enabled. The function
    // should not even get called if the flag is not set but we
    // double check just in case.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    //
    // If verifier is disabled skip.
    //

    if (AVrfpEnabled == FALSE) {
        return;
    }
    
    //
    // Get verifier global lock.
    //

    VERIFIER_LOCK ();

    //
    // Iterate the verifier provider list and notify each one of the
    // unload event.
    //

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierNtdllHeapFreeHandler) {

            Entry->VerifierNtdllHeapFreeHandler (AllocationBase,
                                                 AllocationSize);
        }
    }
    
    VERIFIER_UNLOCK ();
}

NTSTATUS
AVrfpSnapDllImports (
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
/*++

Routine description:

    This routine walks the already resolved import tables of a loaded
    dll and modifies the addresses of all functions that need to be
    verifier. The dll has just been loaded, imports resolved but dll
    main function has not been called.
    
Parameters:

    LdrDataTableEntry - loader descriptor for a loaded dll
    
Return value:

    True if we checked all imports of the dll and modified the ones
    that need to be verified. False if an error was encountered along
    the way.
            
--*/
{
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;
    NTSTATUS st;
    ULONG Pi; // procedure index
    ULONG Di; // dll index
    ULONG Ti; // thunk index
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;

    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to functions that should be
    // verified and replace those thunks.
    //

    IATBase = RtlImageDirectoryEntryToData (LdrDataTableEntry->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize);

    if (IATBase == NULL) {

        //
        // It is not an error if we do not find an import table in the image.
        // This can be a DLL that simply does not import anything (a resource
        // dll for instance).
        //

        return STATUS_SUCCESS;
    }
    
    BigIATSize = LittleIATSize;

    //
    // Make table read/write.
    //
    // ISSUE: SilviuC: we can strenghten this a bit if we add some retry scheme
    // to deal with out of mem conditions. This is the typical scenario in
    // which protect can fail.
    //

    st = NtProtectVirtualMemory (NtCurrentProcess(),
                                 &IATBase,
                                 &BigIATSize,
                                 PAGE_READWRITE,
                                 &OldProtect);

    if (!NT_SUCCESS (st)) {

        InterlockedIncrement ((PLONG)(&AVrfpVirtualProtectFailures));

        if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {
            
            DbgPrint ("AVRF: Unable to unprotect IAT to modify thunks (status %08X).\n", st);
        }
        
        return st;
    }

    ProcAddresses = (PVOID *)IATBase;
    NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));

    for (Pi = 0; Pi < NumberOfProcAddresses; Pi += 1) {
        
        //
        // If we find a null in the import table we skip over it.
        //

        if (*ProcAddresses == NULL) {
            ProcAddresses += 1;
            continue;
        }

        Current = AVrfpVerifierProvidersList.Flink;

        while (Current != &AVrfpVerifierProvidersList) {

            Entry = CONTAINING_RECORD (Current,
                                       AVRF_VERIFIER_DESCRIPTOR,
                                       List);

            Current = Current->Flink;

            Dlls = Entry->VerifierDlls;
            
            for (Di = 0; Dlls[Di].DllName; Di += 1) {

                Thunks = Dlls[Di].DllThunks;

                for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                    if (*ProcAddresses == Thunks[Ti].ThunkOldAddress) {

                        if (Thunks[Ti].ThunkNewAddress) {

                            *ProcAddresses = Thunks[Ti].ThunkNewAddress;
                        }
                        else {

                            DbgPrint ("AVRF: internal error: New thunk for %s is null. \n",
                                        Thunks[Ti].ThunkName);

                            DbgBreakPoint ();
                        }

                        if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {

                            DbgPrint ("AVRF: Snapped (%ws: %s) with (%ws: %p). \n",
                                        LdrDataTableEntry->BaseDllName.Buffer,
                                        Thunks[Ti].ThunkName,
                                        Entry->VerifierName.Buffer,
                                        Thunks[Ti].ThunkNewAddress);
                        }
                    }
                }
            }
        }

        ProcAddresses += 1;
    }

    //
    // Restore old protection for the table. We do not fail the entire
    // function if this protect fails because not managing to switch back
    // from RW to RO is something we can live with.
    //

    NtProtectVirtualMemory (NtCurrentProcess(),
                            &IATBase,
                            &BigIATSize,
                            OldProtect,
                            &OldProtect);

    return st;
}


BOOLEAN
AVrfpDetectVerifiedExports (
    PRTL_VERIFIER_DLL_DESCRIPTOR Dll,
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks
    )
/*++

Routine description:

    This routine checks if `DllString' is the name of a dll that has
    exports that need to be verifier. If it does then we detect the
    addresses of all those exports. We need the addresses to detect
    what imports need to be modified by application verifier.
    
Parameters:

    DlString - name of a dll exporting verified interfaces.
    
    Thunks - array of thunk descriptors for our dll    
    
Return value:

    True if verified exports have been detected. False if an error has been
    encountered.
        
--*/
{
    UNICODE_STRING DllName;
    PLDR_DATA_TABLE_ENTRY DllData;
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    WCHAR StaticRedirectionBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectionString;
    UNICODE_STRING DynamicRedirectionString;
    PUNICODE_STRING DllNameToUse;
    BOOLEAN Redirected = FALSE;
    ULONG Ti;

    DllData = NULL;

    //
    // "Fusion-ize" the dll name. 
    //

    RtlInitUnicodeString (&DllName,
                          Dll->DllName);

    DynamicRedirectionString.Buffer = NULL;
    DynamicRedirectionString.Length = 0;
    DynamicRedirectionString.MaximumLength = 0;

    StaticRedirectionString.Length = 0;
    StaticRedirectionString.MaximumLength = sizeof(StaticRedirectionBuffer);
    StaticRedirectionString.Buffer = StaticRedirectionBuffer;

    DllNameToUse = &DllName;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
            &DllName,
            &DefaultExtension,
            &StaticRedirectionString,
            &DynamicRedirectionString,
            &DllNameToUse,
            NULL,
            NULL,
            NULL);

    if (NT_SUCCESS(Status)) {
        Redirected = TRUE;
    } else if (Status == STATUS_SXS_KEY_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }

    //
    // Get the loader descriptor for this dll.
    //
    // ISSUE: SilviuC: This search and fusion code above are totally redundant
    // because this function is always called when the dll in which we look for
    // exports is loaded (just loaded actually) and the function above that 
    // calls this one has actually a pointer to the LDR entry therefore we do
    // not need to search here again.
    //

    if (NT_SUCCESS(Status)) {

        Result = LdrpCheckForLoadedDll (NULL,
                                        DllNameToUse,
                                        TRUE,
                                        Redirected,
                                        &DllData);

        if (DynamicRedirectionString.Buffer != NULL) {
            RtlFreeUnicodeString(&DynamicRedirectionString);
        }
    }

    if (Result == FALSE) {

        //
        // We exit of we failed to fusionize name or did not find
        // the dll among the loaded ones.
        //

        return FALSE;
    }

    //
    // Search for exports from this dll that need to be verified.
    // We need their original addresses.
    //

    for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {
        
        PVOID OriginalAddress;
        ANSI_STRING FunctionName;

        //
        // If old thunk already filled (can happen due to chaining)
        // then skip search for the original address.
        //

        if (Thunks[Ti].ThunkOldAddress) {
            continue;
        }

        RtlInitAnsiString (&FunctionName, Thunks[Ti].ThunkName);

        //
        // It is crucial that the last parameter is FALSE so that
        // LdrpGetProcedureAddress() does not call init routines.
        //

        Status = LdrpGetProcedureAddress (DllData->DllBase,
                                          &FunctionName,
                                          0,
                                          &OriginalAddress,
                                          FALSE);

        if (! NT_SUCCESS(Status)) {

            DbgPrint ("AVRF: warning: did not find `%s' export in %ws . \n",
                      Thunks[Ti].ThunkName,
                      DllData->BaseDllName.Buffer);


            continue;
        }

        Thunks[Ti].ThunkOldAddress = OriginalAddress;

        if ((AVrfpDebug & AVRF_DBG_SHOW_VERIFIED_EXPORTS)) {

            DbgPrint ("AVRF: (%ws) %s export found. \n",
                      DllData->BaseDllName.Buffer,
                      Thunks[Ti].ThunkName);
        }
    }   
        
    return TRUE;
}


PWSTR
AVrfpGetProcessName (
    VOID
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;

    Ldr = &PebLdr;
    Head = &Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    Entry = CONTAINING_RECORD (Next, 
                               LDR_DATA_TABLE_ENTRY, 
                               InLoadOrderLinks);

    return Entry->BaseDllName.Buffer;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////// Verifier options initialization
/////////////////////////////////////////////////////////////////////

BOOLEAN
AVrfpEnableHandleVerifier (

    VOID
    )
{
    PROCESS_HANDLE_TRACING_ENABLE HandleCheckEnable;
    NTSTATUS Status;

    RtlZeroMemory (&HandleCheckEnable, sizeof HandleCheckEnable);

    Status = NtSetInformationProcess (NtCurrentProcess(),
                                      ProcessHandleTracing,
                                      &HandleCheckEnable,
                                      sizeof HandleCheckEnable);

    if (!NT_SUCCESS (Status)) {

        DbgPrint ("AVRF: failed to enable handle checking (status %X) \n", 
                    Status);

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
AVrfpEnableStackVerifier (
    VOID
    )
{
    //
    // We enable potential stack overflow checking only if we have some debugger
    // attached and logging was not requested. Since stack overflows are very 
    // difficult to catch without a debugger attached we consider it is better
    // disabling it than confusing people.
    //

    if (AVrfpIsDebuggerPresent() &&
        (AVrfpVerifierFlags & RTL_VRF_FLG_ENABLE_LOGGING) == 0) {

        NtCurrentPeb()->NtGlobalFlag |= FLG_DISABLE_STACK_EXTENSION;
    }

    return TRUE;
}

BOOLEAN
AVrfpEnableLockVerifier (
    VOID
    )
{
    RtlpCriticalSectionVerifier = TRUE;
    return TRUE;
}

BOOLEAN
AVrfpEnableHeapVerifier (
    VOID
    )
{
    extern ULONG RtlpDphGlobalFlags;

    if (AVrfpVerifierFlags & RTL_VRF_FLG_FULL_PAGE_HEAP) {
    
        NtCurrentPeb()->NtGlobalFlag |= FLG_HEAP_PAGE_ALLOCS;

        RtlpDphGlobalFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
    }
    else if (AVrfpVerifierFlags & RTL_VRF_FLG_FAST_FILL_HEAP) {
    
        NtCurrentPeb()->NtGlobalFlag |= FLG_HEAP_PAGE_ALLOCS;
    }
    else {

        //
        // Nothing. 
        //
    }

    return TRUE;
}

BOOLEAN
AVrfpEnableVerifierOptions (
    VOID
    )
{
    BOOLEAN Result;
    BOOLEAN Failures = FALSE;

    //
    // Heap verifier in some form is enabled always.
    //

    Result = AVrfpEnableHeapVerifier ();

    if (Result == FALSE) {
        Failures = TRUE;
    }

    //
    // Handle checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_HANDLE_CHECKS) {

        Result = AVrfpEnableHandleVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    //
    // Stack overflow checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_STACK_CHECKS) {

        Result = AVrfpEnableStackVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    //
    // Lock checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) {

        Result = AVrfpEnableLockVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    return !Failures;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Application verifier stops
/////////////////////////////////////////////////////////////////////

//
// VerifierStopMessage entry point from verifier.dll.
//

#pragma warning(disable:4055)

typedef VOID
(* STOP_MESSAGE_FUNCTION_TYPE) (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    );

STOP_MESSAGE_FUNCTION_TYPE AVrfpVerifierStopMessageFunction;


LOGICAL
AVrfpIsDebuggerPresent (
    VOID
    )
/*++

Routine description:

    This routine checks out if we  have any kind of debuggers active.
    Note that we cannot do this check only once during process
    initialization because debuggers can be attached and detached
    from a process while the process is running.

Parameters:

    None.
    
Return value:

    TRUE if a user mode debugger is attached to the current process or
    kernel mode debugger is enabled.
    
--*/
{

    if (NtCurrentPeb()->BeingDebugged) {
        return TRUE;
    }

    if (USER_SHARED_DATA->KdDebuggerEnabled) {
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
AVrfpVerifierStopInitialize (
    VOID
    )
{
    NTSTATUS Status;
    PVOID VerifierDllAddress = NULL;
    ANSI_STRING FunctionName;
    PVOID FunctionAddress;
    PLIST_ENTRY Entry;
    PAVRF_VERIFIER_DESCRIPTOR Provider;

    //
    // Find load address for verifier.dll.
    //
    
    Entry = AVrfpVerifierProvidersList.Flink;

    while  (Entry != &AVrfpVerifierProvidersList) {

        Provider = CONTAINING_RECORD (Entry,
                                      AVRF_VERIFIER_DESCRIPTOR,
                                      List);

        if (_wcsicmp(Provider->VerifierName.Buffer, L"verifier.dll") == 0) {
            VerifierDllAddress = Provider->VerifierHandle;
            break;
        }

        Entry = Provider->List.Flink;
    }

    ASSERT (VerifierDllAddress != NULL);

    if (VerifierDllAddress == NULL) {
        DbgPrint ("AVRF: Failed to find verifier.dll among loaded providers! \n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // It is crucial that the last parameter is FALSE so that
    // LdrpGetProcedureAddress() does not call init routines.
    //

    RtlInitAnsiString (&FunctionName, "VerifierStopMessage");

    Status = LdrpGetProcedureAddress (VerifierDllAddress,
                                      &FunctionName,
                                      0,
                                      &FunctionAddress,
                                      FALSE);

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: Failed to find `VerifierStopMessage()' export in verifier.dll! \n");
        return Status;
    }

    AVrfpVerifierStopMessageFunction = (STOP_MESSAGE_FUNCTION_TYPE)FunctionAddress;

    return Status;
}


VOID
RtlApplicationVerifierStop (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    )
/*++

Routine description:

    This routine will call the real implementation from 
    verifier.dll VerifierStopMessage().
    
Parameters:

    Code: Verifier stop code. The two flags described above can be OR'd into the code
        to change the behavior of the API. The verifier stop codes are defined in
        \base\published\nturtl.w and described in \base\win32\verifier\verifier_stop.doc.
        
    Message: Ascii string describing the failure. It is considered bad style to use several
        different messages with the same `Code'. Every different issue should have its own
        unique (Code, Message) pair.    

    Param1, Description1: First arbitrary pointer to information and ascii description.
    
    Param2, Description2: Second arbitrary pointer to information and ascii description.
    
    Param3, Description3: Third arbitrary pointer to information and ascii description.
    
    Param4, Description4: Fourth arbitrary pointer to information and ascii description.
    
Return value:

    None.

--*/
{
    ULONG GlobalFlags;

    GlobalFlags = NtCurrentPeb()->NtGlobalFlag;

    if ((GlobalFlags & FLG_APPLICATION_VERIFIER) == 0 &&
        (GlobalFlags & FLG_HEAP_PAGE_ALLOCS) != 0) {

        //
        // If page heap is enabled separately then go to a simplified function. 
        //

        RtlpPageHeapStop (Code, Message,
                          Param1, Description1,
                          Param2, Description2,
                          Param3, Description3,
                          Param4, Description4);

        return;
    }
    else if (AVrfpVerifierStopMessageFunction) {

        //
        // If application verifier is enabled and we have discovered
        // the entry point for VerifierStopMessage() then call it.
        //

        AVrfpVerifierStopMessageFunction (Code, Message,
                                          Param1, Description1,
                                          Param2, Description2,
                                          Param3, Description3,
                                          Param4, Description4);
    }
    else {

        //
        // Nothing. We can get here if someone calls this interface w/o 
        // enabling application verifier.
        //
    }
}


ULONG_PTR AVrfpPageHeapPreviousStopData[5];
ULONG_PTR AVrfpPageHeapStopData[5];


VOID
RtlpPageHeapStop (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    )
{
    //
    // Make it easy for a debugger to pick up the failure info.
    //

    RtlCopyMemory (AVrfpPageHeapPreviousStopData, 
                   AVrfpPageHeapStopData, 
                   sizeof AVrfpPageHeapStopData);

    AVrfpPageHeapStopData[0] = Code;
    AVrfpPageHeapStopData[1] = Param1;
    AVrfpPageHeapStopData[2] = Param2;
    AVrfpPageHeapStopData[3] = Param3;
    AVrfpPageHeapStopData[4] = Param4;

    DbgPrint ("\n\n"                           
              "===========================================================\n"
              "VERIFIER STOP %p: pid 0x%X: %s \n"
              "\n\t%p : %s\n\t%p : %s\n\t%p : %s\n\t%p : %s\n"
              "===========================================================\n\n",
              Code, RtlGetCurrentProcessId(), Message,
              Param1, Description1, 
              Param2, Description2, 
              Param3, Description3, 
              Param4, Description4);

    DbgBreakPoint ();
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Page heap target dll logic
/////////////////////////////////////////////////////////////////////

//
// ISSUE: SilviuC: pageheap per dll code should move into verifier.dll
//

BOOLEAN AVrfpDphKernel32Snapped;
BOOLEAN AVrfpDphMsvcrtSnapped;

#define SNAP_ROUTINE_GLOBALALLOC     0
#define SNAP_ROUTINE_GLOBALREALLOC   1
#define SNAP_ROUTINE_GLOBALFREE      2
#define SNAP_ROUTINE_LOCALALLOC      3
#define SNAP_ROUTINE_LOCALREALLOC    4
#define SNAP_ROUTINE_LOCALFREE       5
#define SNAP_ROUTINE_HEAPALLOC       6
#define SNAP_ROUTINE_HEAPREALLOC     7
#define SNAP_ROUTINE_HEAPFREE        8
#define SNAP_ROUTINE_HEAPCREATE      9
#define SNAP_ROUTINE_MALLOC          10
#define SNAP_ROUTINE_CALLOC          11
#define SNAP_ROUTINE_REALLOC         12
#define SNAP_ROUTINE_FREE            13
#define SNAP_ROUTINE_NEW             14
#define SNAP_ROUTINE_DELETE          15
#define SNAP_ROUTINE_NEW_ARRAY       16
#define SNAP_ROUTINE_DELETE_ARRAY    17
#define SNAP_ROUTINE_MAX_INDEX       18

PVOID AVrfpDphSnapRoutines [SNAP_ROUTINE_MAX_INDEX];

typedef struct _DPH_SNAP_NAME {

    PSTR Name;
    ULONG Index;

} DPH_SNAP_NAME, * PDPH_SNAP_NAME;

DPH_SNAP_NAME
AVrfpDphSnapNamesForKernel32 [] = {

    { "GlobalAlloc",   0 },
    { "GlobalReAlloc", 1 },
    { "GlobalFree",    2 },
    { "LocalAlloc",    3 },
    { "LocalReAlloc",  4 },
    { "LocalFree",     5 },
    { "HeapAlloc",     6 },
    { "HeapReAlloc",   7 },
    { "HeapFree",      8 },
    { "HeapCreate",    9 },
    { NULL, 0 }
};

DPH_SNAP_NAME
AVrfpDphSnapNamesForMsvcrt [] = {

    { "malloc",        10},
    { "calloc",        11},
    { "realloc",       12},
    { "free",          13},
#if defined(_X86_) // compilers for various architectures decorate slightly different
    {"??2@YAPAXI@Z",   14},
    {"??3@YAXPAX@Z",   15},
    {"??_U@YAPAXI@Z",  16},
    {"??_V@YAXPAX@Z",  17},
#elif defined(_IA64_)
    {"??2@YAPEAX_K@Z", 14},
    {"??3@YAXPEAX@Z",  15},
    {"??_U@YAPEAX_K@Z",16},
    {"??_V@YAXPEAX@Z", 17},
#elif defined(_AMD64_)
    {"??2@YAPAX_K@Z",  14},
    {"??3@YAXPAX@Z",   15},
    {"??_U@YAPAX_K@Z", 16},
    {"??_V@YAXPAX@Z",  17},
#else
#error Unknown architecture
#endif
    { NULL, 0 }
};



//
// Declarations for replacement functions
//

PVOID
AVrfpDphDllHeapAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllHeapReAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

BOOLEAN
AVrfpDphDllHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
AVrfpDphDllLocalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllLocalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

PVOID
AVrfpDphDllLocalFree(
    IN PVOID Address
    );

PVOID
AVrfpDphDllGlobalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllGlobalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

PVOID
AVrfpDphDllGlobalFree(
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllmalloc (
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfpDphDllcalloc (
    IN SIZE_T Number,
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfpDphDllrealloc (
    IN PVOID Address,
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllfree (
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllNew (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllDelete (
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllNewArray (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllDeleteArray (
    IN PVOID Address
    );

//
// Replacement function for msvcrt HeapCreate used to intercept
// the CRT heap creation.
//

PVOID
AVrfpDphDllHeapCreate (
    ULONG Options,
    SIZE_T InitialSize,
    SIZE_T MaximumSize
    );

//
// Address of heap created by msvcrt. This is needed
// by the replacements of malloc/free etc.
//

PVOID AVrfpDphMsvcrtHeap;

//
// Snap implementation
//

BOOLEAN
AVrfpDphDetectSnapRoutines (
    PWSTR DllString,
    PDPH_SNAP_NAME SnapNames
    )
{
    PLDR_DATA_TABLE_ENTRY DllData;
    PIMAGE_EXPORT_DIRECTORY Directory;
    ULONG Size;
    PCHAR NameAddress;
    PCHAR FunctionAddress;
    PCHAR Base;
    PCHAR IndexAddress;
    ULONG Index;
    ULONG RealIndex;
    BOOLEAN Result = FALSE;
    UNICODE_STRING DllName;
    PDPH_SNAP_NAME CurrentSnapName;
    NTSTATUS Status;
   