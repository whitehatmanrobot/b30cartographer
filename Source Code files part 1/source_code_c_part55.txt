t.wBeginDay    = st.wDay;
            }
        }

        break;

    case INDEX_STARTUP:
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
        break;

    case INDEX_LOGON:
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
        break;

    case INDEX_IDLE:
    {
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_ON_IDLE;
        ULONG ulSpinPos = Spin_GetPos(Hwnd(), sch_spin_idle_min);

        WORD wDummy;
        WORD wIdleDeadline;

        m_pIJob->GetIdleWait(&wDummy, &wIdleDeadline);

        if (HIWORD(ulSpinPos))
        {
            m_pIJob->SetIdleWait(SCH_DEFAULT_IDLE_TIME, wIdleDeadline);
        }
        else
        {
            m_pIJob->SetIdleWait(LOWORD(ulSpinPos), wIdleDeadline);
        }
        break;
    }

    default:
        Win4Assert(0 && "Unexpected");
    }
}


LRESULT
CSchedulePage::_OnTimer(
    UINT idTimer)
{
    TRACE(CSchedulePage, _OnTimer);

    //
    // If this isn't the right timer, ignore it.
    //
    // If one of the comboboxes holding data needed to build the trigger is
    // in the dropped-down state (and therefore may not have a valid
    // selection), don't try to update the trigger.  leave the timer
    // running so we get another chance to update.
    //
    // Otherwise, save current trigger settings, update the string displayed
    // at the top of the page, and get rid of the timer.
    //

    if (idTimer == IDT_UPDATE_TRIGGER_STRING && s_iCbx == -1)
    {
        _SaveTriggerSettings();
        _UpdateTriggerString();

        _DeleteTimerToUpdateTriggerStr();
    }
    else
    {
        DEBUG_OUT((DEB_IWARN,
                   "Ignoring timer message (%s)\n",
                    idTimer != IDT_UPDATE_TRIGGER_STRING ?
                        "foreign timer" :
                        "combobox down"));
    }

    return 0;
}



LRESULT
CSchedulePage::_OnPSNSetActive(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnPSNSetActive);

    m_fInInit = TRUE;

    Win4Assert(s_iCbx == -1); // can't have a combo open yet

    //
    //  Show application icon
    //

    SendDlgItemMessage(Hwnd(), idc_icon, STM_SETICON,
            (WPARAM)m_pIconHelper->hiconJob, 0L);

    //
    //  single or multiple scheds
    //

    if (m_fShowingMultiSchedsOnKillActive != m_fShowMultiScheds)
    {
        _ShowTriggerStringDispCtrls();

        if (m_fShowMultiScheds == FALSE)
        {
            m_indexCbxTriggers = 0; // reset to zero

            //
            // Show the first trigger
            //
            HWND hwnd;
            if (hwnd = _hCtrl(cbx_triggers))
            {
                m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(hwnd, 0);
            }

            _RefreshPage();
        }
        else
        {
            _UpdateTriggerString();
        }
    }
    else
    {
        _UpdateTriggerString();
    }

    //
    // Make sure IdleWait is syncronized with Settings page changes.
    //

    _UpdateIdleControls();

    //
    //  Create timer to update trigger
    //

    _CreateTimerToUpdateTriggerStr();

    m_fInInit = FALSE;

    return CPropPage::_OnPSNSetActive(lParam);
}


LRESULT
CSchedulePage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnPSNKillActive);

    if (_PerformSanityChkOnCurrTrigger() == FALSE)
    {
        // Returns TRUE to prevent the page from losing the activation
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }

    m_fShowingMultiSchedsOnKillActive = m_fShowMultiScheds;

    //
    //  Save the current trigger
    //

    _SaveTriggerSettings();

    //
    // Make sure Settings page is syncronized with IdleWait changes.
    //

    WORD wDummy;
    WORD wIdleDeadline;

    HRESULT hr = m_pIJob->GetIdleWait(&wDummy, &wIdleDeadline);
    CHECK_HRESULT(hr);

    ULONG ulSpinPos = Spin_GetPos(Hwnd(), sch_spin_idle_min);

    if (HIWORD(ulSpinPos))
    {
        m_pIJob->SetIdleWait(SCH_DEFAULT_IDLE_TIME, wIdleDeadline);
    }
    else
    {
        m_pIJob->SetIdleWait(LOWORD(ulSpinPos), wIdleDeadline);
    }

    //
    // kill timer here
    //

    _DeleteTimerToUpdateTriggerStr();

    return CPropPage::_OnPSNKillActive(lParam);
}


LRESULT
CSchedulePage::_OnDateTimeChange(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnDateTimeChange);

    m_pcjtCurr->DirtyTrigger();

    _EnableApplyButton();

    _CreateTimerToUpdateTriggerStr();

    return CPropPage::_OnDateTimeChange(lParam);
}


LRESULT
CSchedulePage::_OnSpinDeltaPos(
    NM_UPDOWN * pnmud)
{
    m_pcjtCurr->DirtyTrigger();

    _CreateTimerToUpdateTriggerStr();

    return CPropPage::_OnSpinDeltaPos(pnmud);
}



LRESULT
CSchedulePage::_OnWinIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CSchedulePage, _OnWinIniChange);

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));
    HWND hwnd;
    if (hwnd = _hCtrl(dp_start_time)) DateTime_SetFormat(hwnd, m_tszTimeFormat);
    if (hwnd = _hCtrl(once_dp_date))  DateTime_SetFormat(hwnd, NULL);
    return 0;
}



void
CSchedulePage::_UpdateTriggerString(void)
{
    TRACE(CSchedulePage, _UpdateTriggerString);

    if (m_pcjtCurr == 0)
    {
        // No triggers
        return;
    }

    TCHAR   tcBuff[SCH_XBIGBUF_LEN];

    m_pcjtCurr->TriggerString(m_fShowMultiScheds, tcBuff, SCH_XBIGBUF_LEN);

    if (m_fShowMultiScheds == TRUE)
    {
        HWND hCombo = _hCtrl(cbx_triggers);
        if (!hCombo)
        {
            return;
        }

        ComboBox_DeleteString(hCombo, m_indexCbxTriggers);

        int iNew = ComboBox_InsertString(hCombo, m_indexCbxTriggers, tcBuff);

        Win4Assert((UINT)iNew == m_indexCbxTriggers);

        ComboBox_SetItemData(hCombo, iNew, m_pcjtCurr);

        ComboBox_SetCurSel(hCombo, m_indexCbxTriggers);
    }
    else
    {
        // single trigger

        SetDlgItemText(Hwnd(), txt_trigger, tcBuff);
    }
}


LRESULT
CSchedulePage::_OnApply(void)
{
    TRACE(CSchedulePage, _OnApply);

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    if (_PerformSanityChkOnCurrTrigger() == FALSE)
    {
        SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    HRESULT     hr = S_OK;

    do
    {
        /////////////////////////////////////////////////////////////////////
        //
        // During the first pass do not delete triggers, since deleting
        // triggers changes the trigger ids in the in memory job. So in
        // the first pass:
        //   - save changes to existing triggers (if any)
        //   - set pcjtLastOriginal to the trigger with the largest ID of
        //     those originally loaded
        //   - add new triggers (if any)
        //

        WORD    wTriggerID = 0;

        ITaskTrigger * pIJobTrigger = NULL;
        CJobTrigger  * pcjtLastOriginal = NULL;

        for (CJobTrigger *pcjt = m_cjtList.First();
             pcjt != NULL;
             pcjt = pcjt->Next())
        {
            wTriggerID = pcjt->GetTriggerID();

            if (wTriggerID < m_cTriggersPrev)
            {
                pcjtLastOriginal = pcjt;

                if (pcjt->IsTriggerDirty() == TRUE)
                {
                    hr = m_pIJob->GetTrigger(wTriggerID, &pIJobTrigger);

                    CHECK_HRESULT(hr);
                    BREAK_ON_FAIL(hr);
                }
                else
                {
                    pIJobTrigger = NULL;
                }
            }
            else
            {
                WORD wTemp;
                hr = m_pIJob->CreateTrigger(&wTemp, &pIJobTrigger);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }

            if (pIJobTrigger != NULL)
            {
                hr = pIJobTrigger->SetTrigger(&pcjt->m_jt);

                pIJobTrigger->Release();

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }

        BREAK_ON_FAIL(hr);

        //
        // Delete triggers in the decreasing order of Trigger ids, since
        // the trigger ids in memory change.
        //

        if (m_cTriggersPrev && pcjtLastOriginal)
        {
            WORD wSequential = m_cTriggersPrev - 1;
            pcjt = pcjtLastOriginal;

            //
            // There were some triggers originally && not all have been
            // deleted.
            //
            // Go backwards sequentially through the original trigger IDs.
            // Wherever we find a remaining trigger that is out of sync with
            // wSequential, then the original trigger with ID wSequential must
            // have been deleted in the UI, so we delete it on the job.
            //

            while (pcjt)
            {
                if (pcjt->GetTriggerID() < wSequential)
                {
                    hr = m_pIJob->DeleteTrigger(wSequential);
                    CHECK_HRESULT(hr);
                    BREAK_ON_FAIL(hr);
                }
                else
                {
                    pcjt = pcjt->Prev();
                }
                wSequential--;
            }

            //
            // Special case deletions from the start of the list
            //

            wSequential = m_cjtList.First()->GetTriggerID();

            while (wSequential > 0)
            {
                hr = m_pIJob->DeleteTrigger(--wSequential);
                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }
        else if (m_cTriggersPrev)
        {
            WORD wSequential;

            //
            // All the original triggers were deleted in the ui.
            //

            for (wSequential = m_cTriggersPrev; wSequential; )
            {
                hr = m_pIJob->DeleteTrigger(--wSequential);
                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }
        BREAK_ON_FAIL(hr);

        //
        //  Re-number the trigger IDs, since this would have changed for
        //  the job.
        //
        //      NOTE: This is was what we would have if we did a reload of
        //            the job.
        //

        m_wNextTriggerId = 0;

        for (pcjt = m_cjtList.First();
             pcjt != NULL;
             pcjt = pcjt->Next())
        {
             pcjt->SetTriggerID(m_wNextTriggerId++);
        }

        m_cTriggersPrev = m_wNextTriggerId;

        //
        //  Reload the trigger strings.
        //
        HWND hwnd;
        if (hwnd = _hCtrl(cbx_triggers))
        {
            ComboBox_ResetContent(hwnd);

            _LoadTriggerStrings();
    
            if (m_fShowMultiScheds == TRUE)
            {
                ComboBox_SetCurSel(hwnd, m_indexCbxTriggers);
                m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(hwnd, m_indexCbxTriggers);
            }
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE) &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // First, fetch general page task, application dirty status flags.
            // Default to not dirty if the general page isn't present.
            //

            BOOL fTaskApplicationChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_APPLICATION_DIRTY_STATUS,
                                    (LPARAM)&fTaskApplicationChange);
            BOOL fTaskAccountChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS,
                                    (LPARAM)&fTaskAccountChange);
            BOOL fSuppressAccountInfoRequest = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG,
                                    (LPARAM)&fSuppressAccountInfoRequest);

            hr = JFSaveJob(Hwnd(),
                           m_pIJob,
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           fTaskAccountChange,
                           fTaskApplicationChange,
                           fSuppressAccountInfoRequest);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_APPLICATION_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG, 0);

            //
            // Instruct the general page to refresh account information.
            //

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        TASK_ACCOUNT_CHANGE_NOTIFY, 0);
        }

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return TRUE;
}


LRESULT
CSchedulePage::_OnDestroy(void)
{
    _DeleteTimerToUpdateTriggerStr();

    return 0;
}


LRESULT
CSchedulePage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    INT_PTR iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;

    case GET_ICON_HELPER:
        iRet = (INT_PTR)m_pIconHelper;
        break;
    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);
    return iRet;
}


BOOL
CSchedulePage::_PerformSanityChkOnCurrTrigger(void)
{
    if (m_pcjtCurr == 0)
    {
        // No triggers
        return TRUE;
    }

    HWND hwnd = _hCtrl(cbx_trigger_type);
    if (!hwnd)
    {
        return FALSE;
    }
    int iCur = ComboBox_GetCurSel(hwnd);

    Win4Assert(iCur >= 0);

    ULONG   ul;
    UINT    i;
    UINT    idsErrStr = 0;

    switch (iCur)
    {
    case INDEX_DAILY:

        ul = GetDlgItemInt(Hwnd(), daily_txt_every, NULL, FALSE);

        if (ul <= 0)
        {
            Spin_SetPos(Hwnd(), daily_spin_every, 1);
            idsErrStr = IERR_INVALID_DAYILY_EVERY;
        }
        break;

    case INDEX_WEEKLY:

        ul = GetDlgItemInt(Hwnd(), weekly_txt_every, NULL, FALSE);

        if (ul <= 0)
        {
            Spin_SetPos(Hwnd(), weekly_spin_every, 1);
            idsErrStr = IERR_INVALID_WEEKLY_EVERY;
        }
        else
        {
            idsErrStr = IERR_INVALID_WEEKLY_TASK;

            for (i=0; i < ARRAYLEN(g_aDayData); i++)
            {
                if (IsDlgButtonChecked(Hwnd(), g_aDayData[i].idCtrl)
                    == BST_CHECKED)
                {
                    idsErrStr = 0;
                    break;
                }
            }
        }

        break;

    case INDEX_MONTHLY:

        if (IsDlgButtonChecked(Hwnd(), md_rb) == BST_CHECKED)
        {
            //
            // It's a monthly date trigger.  Get the spin control position.
            // Complain if it's not a valid day number for any month, i.e.,
            // if it's < 1 or > 31.
            //

            ul = GetDlgItemInt(Hwnd(), md_txt, NULL, FALSE);

            if (ul <= 0)
            {
                Spin_SetPos(Hwnd(), md_spin, 1);
                idsErrStr = IERR_MONTHLY_DATE_LT0;
                break;
            }

            if (ul > 31)
            {
                Spin_SetPos(Hwnd(), md_spin, 31);
                idsErrStr = IERR_MONTHLY_DATE_GT31;
                break;
            }

            //
            // Complain if the date specified does not fall within any of the
            // months selected (e.g., Feb 31 is an error, Jan+Feb 31 is
            // acceptable).
            //

            TASK_TRIGGER jt = m_pcjtCurr->m_jt;

            jt.Type.MonthlyDate.rgfDays = (1 << (ul - 1));

            if (!IsValidMonthlyDateTrigger(&jt))
            {
                idsErrStr = IERR_MONTHLY_DATE_INVALID;
                break;
            }
        }
        break;

    default:
        break;
    }

    if (idsErrStr != 0)
    {
        _ErrorDialog(idsErrStr);

        return FALSE;
    }

    return TRUE;
}



//+--------------------------------------------------------------------------
//
//  Function:   SkipResourceTemplateArray
//
//  Synopsis:   Return a pointer to the first byte after the resource
//              template array at [pbCur].
//
//  Arguments:  [pbCur] - points to resource template array to skip.
//
//  Returns:    [pbCur] + size of resource template array
//
//  History:    08-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCBYTE
SkipResourceTemplateArray(
    LPCBYTE pbCur)
{
    //
    // Menu/class array is either 0x0000, 0xFFFF 0x????, or a null terminated
    // Unicode string.
    //

    if (!*(USHORT *)pbCur)
    {
        pbCur += sizeof USHORT; // no menu
    }
    else if (*(USHORT *)pbCur == 0xFFFF)
    {
        pbCur += 2 * sizeof(USHORT);
    }
    else
    {
        pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
    }

    return pbCur;
}


#define SCHEDULE_PAGE_WIDTH     253

HRESULT
GetSchedulePage(
    ITask           * pIJob,
    LPTSTR            ptszTaskPath,
    BOOL              fPersistChanges,
    HPROPSHEETPAGE  * phpage)
{
    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    //
    // If there are no triggers show multiple trigger UI, so that
    // the user can use 'New' push button to create a trigger.
    //

    HRESULT hr = S_OK;
    LPTSTR  ptszPathCopy;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // Create a copy.
            //

            ptszPathCopy = NewDupString(ptszTaskPath);

            if (ptszPathCopy == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPathCopy);
        }

        BREAK_ON_FAIL(hr);

        WORD cTriggers = 0;

        hr = pIJob->GetTriggerCount(&cTriggers);

        if (FAILED(hr))
        {
            delete ptszPathCopy;
            CHECK_HRESULT(hr);
            break;
        }

        // Show single trigger only if count of triggers == 1.

        BOOL fShowMultipleTriggers = (cTriggers == 1) ? FALSE : TRUE;

        CSchedulePage * pPage = new CSchedulePage(
                                            pIJob,
                                            ptszPathCopy,
                                            fShowMultipleTriggers,
                                            fPersistChanges);

        if (pPage == NULL)
        {
            delete ptszPathCopy;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        //
        // To make localization feasible, the trigger controls are specified
        // in the dialog template as non overlapping.  That is, each set of
        // trigger controls has its own area on the dialog.
        //
        // Each set of controls is spaced out to the right.
        //
        // The following code loads the template, determines its size, makes
        // a copy, then resizes the copy to normal propsheet page width and
        // moves each set of trigger controls so that they all overlap.
        //

        // TODO - determine whether all this is still necessary.  
        // I removed the resizing code, and simply set the size in the dialog
        // template.
        // Now the contols are still spaced to the right, but are 'outside'
        // the ostensible window.

        HRSRC hrsDlg = FindResource(g_hInstance,
                                    MAKEINTRESOURCE(schedule_page),
                                    RT_DIALOG);

        if (!hrsDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Per SDK: Both Windows 95 and Windows NT automatically free
        // resources.  You do not need to call the FreeResource function to
        // free a resource loaded by using the LoadResource function.
        //

        HGLOBAL hglblDlg = LoadResource(g_hInstance, hrsDlg);

        if (!hglblDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Per SDK: It is not necessary for Win32-based applications to
        // unlock resources that were locked by the LockResource function.
        //

        LPVOID ptplDlg = (LPVOID) LockResource(hglblDlg);


        if (!ptplDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        BOOL bDialogEx;
        UINT uiStyle;
        USHORT iditCount;
        //
        // Handle DIALOGEX style template
        //
        if(((LPDLGTEMPLATE2) ptplDlg)->wSignature == 0xffff)
        {
            bDialogEx = TRUE;
            uiStyle = ((LPDLGTEMPLATE2) ptplDlg)->style;
            iditCount = ((LPDLGTEMPLATE2) ptplDlg)->cDlgItems;
        }
        else
        {
            bDialogEx = FALSE;
            uiStyle = ((LPDLGTEMPLATE) ptplDlg)->style;
            iditCount = ((LPDLGTEMPLATE) ptplDlg)->cdit;
        }

        //
        // ptplDlg is in read-only memory.  Make a writeable copy.
        //
        // Sure wish we could do this:
        //
        //      ULONG cbTemplate = GlobalSize(hglblDlg);
        //
        // but hglblDlg isn't on the global heap.
        //
        // So we're forced to grovel through the template and determine its
        // size.
        //

        LPCBYTE pbCur = (LPCBYTE) ptplDlg;
        USHORT i;

        //
        // Advance to dialog template menu array, then skip it and the class
        // array.
        //

        pbCur += bDialogEx ? sizeof DLGTEMPLATE2 : sizeof DLGTEMPLATE;
        pbCur = SkipResourceTemplateArray(pbCur);
        pbCur = SkipResourceTemplateArray(pbCur);

        //
        // Skip title array, which is a null-terminated Unicode string.
        //

        pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));

        //
        // Skip font info, if it is specified.
        //

        if (uiStyle & DS_SETFONT)
        {
            pbCur += sizeof USHORT;
            if (bDialogEx)
            {
                pbCur += sizeof USHORT;
                pbCur += sizeof BYTE;
                pbCur += sizeof BYTE;
            }
            pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
        }

        //
        // Now skip the DLGITEMTEMPLATE structures.
        //

        for (i = 0; i < iditCount; i++)
        {
            //
            // The DLGITEMTEMPLATE structures must be DWORD aligned, but pbCur
            // may be only WORD aligned.  Advance it if necessary to skip a pad
            // WORD.
            //

            if ((ULONG_PTR) pbCur & 3)
            {
                pbCur += 4 - ((ULONG_PTR) pbCur & 3);
            }

            // DEBUG_OUT((DEB_ITRACE, "control id %u\n", ((DLGITEMTEMPLATE*)pbCur)->id));

            // Skip to the start of the variable length data

            pbCur += bDialogEx ? sizeof DLGITEMTEMPLATE2 : sizeof DLGITEMTEMPLATE;

            // Skip the class array

            if (*(USHORT *)pbCur == 0xFFFF)
            {
                pbCur += 2 * sizeof(USHORT);
            }
            else
            {
                pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
            }

            // Skip the title array

            if (*(USHORT *)pbCur == 0xFFFF)
            {
                pbCur += 2 * sizeof(USHORT);
            }
            else
            {
                pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
            }

            //
            // Creation data.  Contrary to SDK docs, it does not start on
            // DWORD boundary.
            //

            if (*(USHORT *)pbCur)
            {
                pbCur += sizeof(USHORT) * (*(USHORT *)pbCur);
            }
            else
            {
                pbCur += sizeof(USHORT);
            }
        }

        //
        // pbCur now points just past the end of the entire dialog template.
        // Now that its size is known, copy it.
        //

        ULONG cbTemplate = (ULONG)(pbCur - (LPCBYTE) ptplDlg);

        LPVOID ptplDlgCopy = (LPVOID) new BYTE[cbTemplate];

        if (!ptplDlgCopy)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        CopyMemory(ptplDlgCopy, ptplDlg, cbTemplate);

        //
        // Modify the PROPSHEETPAGE struct member to indicate that the page
        // is created from an in-memory template.  The base class dtor will
        // see the PSP_DLGINDIRECT flag and do a delete on the pResource.
        //

        pPage->m_psp.dwFlags |= PSP_DLGINDIRECT;
        pPage->m_psp.pResource = (LPDLGTEMPLATE) ptplDlgCopy;

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;
            delete [] ptplDlgCopy;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    return hr;
}



HRESULT
AddSchedulePage(
    PROPSHEETHEADER &psh,
    ITask          * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSchedulePage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddSchedulePage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSchedulePage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\strings.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop

#include "strings.hxx"

const TCHAR tszBlank[] = TEXT(" ");
const TCHAR tszEmpty[] = TEXT("");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\shared.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       shared.cxx
//
//  Contents:   This file contains a set of routines for the management of
//              shared memory.
//
//  Functions:  SCHEDAllocShared: Allocates a handle (in a given process)
//                  to a copy of a memory block in this process.
//
//              SCHEDFreeShared: Releases the handle (and the copy of the
//                  memory block)
//
//              SCHEDLockShared: Maps a handle (from a given process) into
//                  a memory block in this process.  Has the option of
//                  transfering the handle to this process, thereby deleting
//                  it from the given process
//
//              SCHEDUnlockShared: Opposite of SCHEDLockShared, unmaps the
//                  memory block
//
//  History:    4/1/1996   RaviR   Created (stole from shell\dll\shared.c)
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <Sddl.h>
#include <StrSafe.h>

HANDLE
MapHandle(
    HANDLE  hData,
    DWORD   dwSource,
    DWORD   dwDest,
    DWORD   dwDesiredAccess,
    DWORD   dwFlags)
{
    HANDLE hSource = NULL;
    HANDLE hDest = NULL;
    HANDLE hNew = NULL;
    BOOL fOk;

    if (dwSource == GetCurrentProcessId())
        hSource = GetCurrentProcess();
    else
        hSource = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwSource);

    if (!hSource)
        goto DoExit;

    if (dwDest == GetCurrentProcessId())
        hDest = GetCurrentProcess();
    else
        hDest = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwDest);

    if (!hDest)
        goto DoExit;

    fOk = DuplicateHandle( hSource, hData,
                           hDest, &hNew,
                           dwDesiredAccess,
                           FALSE, dwFlags | DUPLICATE_SAME_ACCESS);
    if (!fOk)
        hNew = (HANDLE)NULL;

DoExit:
    if (hSource && dwSource != GetCurrentProcessId())
        CloseHandle(hSource);

    if (hDest && dwDest != GetCurrentProcessId())
        CloseHandle(hDest);

    return hNew;
}



HANDLE
SCHEDAllocShared(
    LPCVOID lpvData,
    DWORD   dwSize,
    DWORD   dwDestinationProcessId)
{
    HANDLE  hData;
    SHMAPHEADER* lpmh;
    HANDLE hUsableData;

    // djinn up an appropriate security descriptor
    BYTE buf[512];
    PSECURITY_DESCRIPTOR pSD = NULL;
    // allow full control to admins, system and owner
    WCHAR sddl[] = L"D:(A;;FA;;;CO)(A;;FA;;;BA)(A;;FA;;;SY)";

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION_1, &pSD, NULL))
        return NULL;

    // * CURRENT USER *
    HANDLE hToken;    
	OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);

    BYTE sidBuf[512];
    SID_AND_ATTRIBUTES* pSidAndAttr = (SID_AND_ATTRIBUTES*) sidBuf;

    DWORD size = 512;
    GetTokenInformation(hToken, TokenUser, (LPVOID)pSidAndAttr, size, &size);

    if (!SetSecurityDescriptorOwner(pSD, pSidAndAttr->Sid, false))
    {
        LocalFree(pSD);
        return NULL;
    }  

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = false;
    sa.lpSecurityDescriptor = pSD;

    //
    // Make a filemapping handle with this data in it.
    //
    hData = CreateFileMapping( INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,0,
                               dwSize+sizeof(SHMAPHEADER),NULL);

    LocalFree(pSD);

    if (hData == NULL)
    {
        // DebugMsg...
        return NULL;
    }

    lpmh = (SHMAPHEADER *)MapViewOfFile(hData, FILE_MAP_READ | FILE_MAP_WRITE,
                                                                    0, 0, 0);

    if (!lpmh)
    {
        // DebugMsg...
        CloseHandle(hData);
        return NULL;
    }
    lpmh->dwSize = dwSize;

    if (lpvData)
        memcpy((LPVOID)(lpmh+1),lpvData,dwSize);

    UnmapViewOfFile(lpmh);

    hUsableData = MapHandle(hData,
                            GetCurrentProcessId(),
                            dwDestinationProcessId,
                            FILE_MAP_ALL_ACCESS,
                            DUPLICATE_CLOSE_SOURCE);
    return hUsableData;
}



LPVOID
SCHEDLockShared(
    HANDLE  hData,
    DWORD   dwSourceProcessId)
{
    SHMAPHEADER*   lpmh;
    HANDLE          hUsableData;

    hUsableData = MapHandle(hData,dwSourceProcessId,GetCurrentProcessId(),FILE_MAP_ALL_ACCESS,0);

    //
    // Now map that new process specific handle and close it
    //
    lpmh = (SHMAPHEADER*)MapViewOfFile(hUsableData,
                    FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

    CloseHandle(hUsableData);

    if (!lpmh)
        return NULL;

    return (LPVOID)(lpmh+1);
}



BOOL
SCHEDUnlockShared(
    LPVOID  lpvData)
{
    SHMAPHEADER* lpmh = (SHMAPHEADER*)lpvData;

    //
    // Now just unmap the view of the file
    //
    return UnmapViewOfFile(lpmh-1);
}



BOOL
SCHEDFreeShared(
    HANDLE hData,
    DWORD dwSourceProcessId)
{
    HANDLE hUsableData;

    //
    // The below call closes the original handle in whatever process it
    // came from.
    //
    hUsableData = MapHandle(hData,dwSourceProcessId,
                            GetCurrentProcessId(),
                            FILE_MAP_ALL_ACCESS,DUPLICATE_CLOSE_SOURCE);

    //
    // Now free up the local handle
    //
    return CloseHandle(hUsableData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\shellex.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       ShellEx.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"

#include "dll.hxx"
#include "..\folderui\jobicons.hxx"
#include "..\folderui\util.hxx"
#include "schedui.hxx"


extern "C" const GUID IID_IShellExtInit;
extern "C" const GUID IID_IShellPropSheetExt;


TCHAR const c_szTask[] = TEXT("task!");


class CSchedObjExt : public IShellExtInit,
                   //public IContextMenu,
                     public IShellPropSheetExt
{
public:
    CSchedObjExt();
    ~CSchedObjExt();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IShellExtInit methods
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj,
                                                            HKEY hkeyProgID);

    // IShellPropSheetExt methods
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID,
                        LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

private:
    CDllRef         m_DllRef;
    LPDATAOBJECT    m_pdtobj;            // data object
    HKEY            m_hkeyProgID;        // reg. database key to ProgID

}; // CSchedObjExt


inline
CSchedObjExt::CSchedObjExt()
    :
    m_ulRefs(1),
    m_pdtobj(NULL),
    m_hkeyProgID(NULL)
{
    TRACE(CSchedObjExt, CSchedObjExt);
}


CSchedObjExt::~CSchedObjExt()
{
    TRACE(CSchedObjExt, ~CSchedObjExt);

    if (m_pdtobj)
    {
        m_pdtobj->Release();
    }

    if (m_hkeyProgID)
    {
        RegCloseKey(m_hkeyProgID);
    }
}

//
// IUnknown implementation
//
IMPLEMENT_STANDARD_IUNKNOWN(CSchedObjExt);


STDMETHODIMP
CSchedObjExt::QueryInterface(REFIID riid, void **ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    HRESULT hr = S_OK;

    if (ppvObject == NULL)
    {
        return(E_INVALIDARG);
    }

    *ppvObject = NULL;                      // in case of error.

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellExtInit, riid))
    {
        pUnkTemp = (IUnknown *)(IShellExtInit *)this;
    }
    else  if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        pUnkTemp = (IUnknown *)(IShellPropSheetExt *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if ((pUnkTemp != NULL) && (SUCCEEDED(hr)))
    {
        *ppvObject = (void*)pUnkTemp;
        pUnkTemp->AddRef();
    }

    return(hr);
}


//____________________________________________________________________________
//
//  Member:     CSchedObjExt::Initialize
//
//  Synopsis:   S
//
//  Arguments:  [pidlFolder] -- IN
//              [pdtobj] -- IN
//              [hkeyProgID] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CSchedObjExt::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pdtobj,
    HKEY            hkeyProgID)
{
    TRACE(CSchedObjExt, Initialize);

    // Initialize can be called more than once.
    if (m_pdtobj)
    {
        m_pdtobj->Release();
    }

    if (m_hkeyProgID)
    {
        RegCloseKey(m_hkeyProgID);
        m_hkeyProgID = NULL;
    }

    // Duplicate the pdtobj pointer
    m_pdtobj = pdtobj;

    if (pdtobj)
    {
        pdtobj->AddRef();
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        RegOpenKeyEx(hkeyProgID, NULL, 0, KEY_ALL_ACCESS, &m_hkeyProgID);
    }

    return S_OK;
}





//+-------------------------------------------------------------------------
//
//  Member:     CSchedObjExt::IShellPropSheetExt::AddPages
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  Returns:
//
//  History:    12-Oct-94 RaviR
//
//--------------------------------------------------------------------------

STDMETHODIMP
CSchedObjExt::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam)
{
    TRACE(CSchedObjExt, AddPages);

    //
    // Call IDataObject::GetData asking for a CF_HDROP (i.e., HDROP).
    //

    HRESULT   hr = S_OK;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, (DVTARGETDEVICE *)NULL, DVASPECT_CONTENT,
                                                        -1, TYMED_HGLOBAL };

    hr = m_pdtobj->GetData(&fmte, &medium);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    do
    {
        //
        //  Ensure it is only a single selection.
        //

        UINT cObjects = DragQueryFile((HDROP)medium.hGlobal,
                                                (UINT)-1, NULL, 0);
        if (cObjects != 1)
        {
            hr = S_FALSE;
            break;
        }

        //
        // Create shared info for all pages
        //

        TCHAR szFile[MAX_PATH + 1];
        UINT cchRet = DragQueryFile((HDROP)medium.hGlobal, 0, szFile,
                                                         ARRAYLEN(szFile));

        //
        // Bind to the ITask interface.
        //

        ITask * pIJob = NULL;

        hr = JFCreateAndLoadTask(NULL, szFile, &pIJob);

        BREAK_ON_FAIL(hr);

        // Add the tasks page
        hr = AddGeneralPage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        // Add the schedule page
        hr = AddSchedulePage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        // Add the settings page
        hr = AddSettingsPage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        pIJob->Release();

    } while (0);

    ReleaseStgMedium(&medium);

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CSchedObjExt::IShellPropSheetExt::ReplacePages
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  Returns:
//
//  History:    12-Oct-94 RaviR
//
//--------------------------------------------------------------------------

STDMETHODIMP
CSchedObjExt::ReplacePage(
    UINT            uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM          lParam)
{
    TRACE(CSchedObjExt, ReplacePage);

    Win4Assert(!"CSchedObjExt::ReplacePage called, not implemented");
    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   JFGetSchedObjExt
//
//  Synopsis:   Create an instance of CSchedObjExt and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetSchedObjExt(
    REFIID riid,
    LPVOID* ppvObj)
{
    CSchedObjExt * pSchedObjExt = new CSchedObjExt();

    HRESULT hr = S_OK;

    if (pSchedObjExt != NULL)
    {
        hr = pSchedObjExt->QueryInterface(riid, ppvObj);

        CHECK_HRESULT(hr);

        pSchedObjExt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CTaskIconExt : public IExtractIcon,
                     public IPersistFile
{
public:
    CTaskIconExt(void);
    ~CTaskIconExt(void);

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPTSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);

    // IPersistFile methods
    STDMETHOD(GetClassID)(LPCLSID lpClsID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(LPCOLESTR pszFile, DWORD grfMode);
    STDMETHOD(Save)(LPCOLESTR pszFile, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFile);
    STDMETHOD(GetCurFile)(LPOLESTR FAR *ppszFile);

private:
    TCHAR       m_szTask[MAX_PATH + 1];

}; // CTaskIconExt


inline
CTaskIconExt::CTaskIconExt(void)
    :
    m_ulRefs(1)
{
    TRACE(CTaskIconExt, CTaskIconExt);

    m_szTask[0] = TEXT('\0');
}

inline
CTaskIconExt::~CTaskIconExt(void)
{
    TRACE(CTaskIconExt, ~CTaskIconExt);
}

//
// IUnknown implementation
//
IMPLEMENT_STANDARD_IUNKNOWN(CTaskIconExt);

STDMETHODIMP
CTaskIconExt::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IPersistFile, riid))
    {
        *ppvObj = (IUnknown*)(IPersistFile*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIcon*) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        this->AddRef();
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CTaskIconExt::IExtractIcon::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::GetIconLocation(
    UINT    uFlags,
    LPTSTR  szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CTaskIconExt, GetIconLocation);

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    HRESULT hr = S_OK;
    UINT    len = lstrlen(c_szTask);

    StringCchCopy(szIconFile, cchMax, c_szTask);

    hr = JFGetAppNameForTask(m_szTask, &szIconFile[len], cchMax - len);

    *piIndex = FALSE;

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CTaskIconExt::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::Extract(
    LPCTSTR pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TRACE(CTaskIconExt, Extract);

    LPTSTR pszApp = (LPTSTR)(pszFile + lstrlen(c_szTask));

    CJobIcon ji;

    ji.GetIcons(pszApp, FALSE, phiconLarge, phiconSmall, nIconSize);

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CTaskIconExt::Load
//
//  Synopsis:   S
//
//  Arguments:  [pszFile] -- IN
//              [grfMode] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::Load(
    LPCOLESTR pszFile,
    DWORD grfMode)
{
    TRACE(CTaskIconExt, Load);
    StringCchCopy(m_szTask, MAX_PATH + 1, pszFile);
    return S_OK;
}


// The following functions, which are part of the OLE IPersistFile interface,
// are not required for shell extensions. In the unlikely event that they are
// called, they return the error code E_FAIL.
//

STDMETHODIMP CTaskIconExt::GetClassID(LPCLSID lpClsID)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::IsDirty()
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::Save(LPCOLESTR pszFile, BOOL fRemember)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::SaveCompleted(LPCOLESTR pszFile)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::GetCurFile(LPOLESTR FAR *ppszFile)
{
    return E_FAIL;
}


//____________________________________________________________________________
//
//  Function:   JFGetTaskIconExt
//
//  Synopsis:   Create an instance of CTaskIconExt and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetTaskIconExt(
    REFIID riid,
    LPVOID* ppvObj)
{
    TRACE_FUNCTION(JFGetTaskIconExt);

    CTaskIconExt * pTaskIconExt = new CTaskIconExt();

    HRESULT hr = S_OK;

    if (pTaskIconExt != NULL)
    {
        hr = pTaskIconExt->QueryInterface(riid, ppvObj);

        CHECK_HRESULT(hr);

        pTaskIconExt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\settings.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       settings.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\inc\common.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\util.hxx"
#include "..\inc\network.hxx"
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include "defines.h"
#include "uiutil.hxx"
#include "helpids.h"
#include "schedui.hxx"
#include "misc.hxx"



//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aSettingsPageHelpIds[] =
{
    chk_start_on_idle,              Hchk_start_on_idle,
    chk_stop_if_not_idle,           Hchk_stop_if_not_idle,
    chk_dont_start_if_on_batteries, Hchk_dont_start_if_on_batteries,
    chk_kill_if_going_on_batteries, Hchk_kill_if_going_on_batteries,
    chk_delete_when_done,           Hchk_delete_when_done,
    chk_stop_after,                 Hchk_stop_after,
    txt_stop_after_hr,              Htxt_stop_after_hr,
    spin_stop_after_hr,             Hspin_stop_after_hr,
    txt_stop_after_min,             Htxt_stop_after_min,
    spin_stop_after_min,            Hspin_stop_after_min,
    txt_idle_min,                   Htxt_idle_min,
    spin_idle_min,                  Hspin_idle_min,
    lbl_idle_deadline1,             Hlbl_idle_deadline,
    lbl_idle_deadline2,             Hlbl_idle_deadline,
    txt_idle_deadline,              Htxt_idle_deadline,
    spin_idle_deadline,             Hspin_idle_deadline,
    lbl_min,                        Hlbl_settings_min,
    lbl_hours,                      Hlbl_settings_hours,
    grp_idle_time,                  Hgrp_idle_time,
    txt_idle_minutes,               Htxt_idle_minutes,
    grp_task_completed,             Hgrp_task_completed,
    grp_power_management,           Hgrp_power_management,
    btn_new,                        Hbtn_new,
    btn_delete,                     Hbtn_delete,
    chk_system_required,            Hchk_system_required,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//
//  extern
//

extern HINSTANCE g_hInstance;


//
// All task flags included in this define will be modified when the page
// values are persisted in the _OnApply method.
//
// If we're running on NT and targeting NT, the controls for some of these
// flags will be initialized to the job's values and hidden.
//

#define TASK_FLAGS_IN_SETTINGS_PAGE (TASK_FLAG_START_ONLY_IF_IDLE         | \
                                     TASK_FLAG_KILL_ON_IDLE_END           | \
                                     TASK_FLAG_DONT_START_IF_ON_BATTERIES | \
                                     TASK_FLAG_KILL_IF_GOING_ON_BATTERIES | \
                                     TASK_FLAG_SYSTEM_REQUIRED            | \
                                     TASK_FLAG_DELETE_WHEN_DONE)


//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CSettingsPage ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CSettingsPage : public CPropPage
{
public:

    CSettingsPage(ITask * pIJob,
                  LPTSTR  ptszTaskPath,
                  BOOL    fPersistChanges);

    ~CSettingsPage();

private:

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply();
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNSetActive(LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ReadIdleSettings();

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    void    _DisableUI(void);

    BOOL    _PerformSanityChk();

    ITask         * m_pIJob;

    DWORD           m_dwFlags;
    DWORD           m_dwMaxRunTime;
    WORD            m_wIdleWait;
    WORD            m_wIdleDeadline;

    //
    //  Should we save on Apply or OK.
    //

    BOOL            m_fPersistChanges;

}; // class CSettingsPage


inline
CSettingsPage::CSettingsPage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_fPersistChanges(fPersistChanges),
        m_dwFlags(0),
        m_dwMaxRunTime(0),
        m_wIdleWait(0),
        m_wIdleDeadline(0),
        CPropPage(MAKEINTRESOURCE(settings_page), ptszTaskPath)
{
    TRACE(CSettingsPage, CSettingsPage);

    Win4Assert(m_pIJob != NULL);

    pIJob->AddRef();
}


inline
CSettingsPage::~CSettingsPage()
{
    TRACE(CSettingsPage, ~CSettingsPage);

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }
}



LRESULT
CSettingsPage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aSettingsPageHelpIds);
    return TRUE;
}




LRESULT
CSettingsPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CSettingsPage, _OnInitDialog);

    HRESULT     hr = S_OK;
    ITask     * pIJob = m_pIJob;


    Spin_SetRange(m_hPage, spin_idle_min, 1, MAX_IDLE_MINUTES);
    Edit_LimitText(_hCtrl(txt_idle_min), MAX_IDLE_DIGITS);

    Spin_SetRange(m_hPage, spin_idle_deadline, 0, MAX_IDLE_MINUTES);
    Edit_LimitText(_hCtrl(txt_idle_deadline), MAX_IDLE_DIGITS);

    Spin_SetRange(m_hPage, spin_stop_after_hr, 0, MAX_MAXRUNTIME_HOURS);
    Edit_LimitText(_hCtrl(txt_stop_after_hr), MAX_MAXRUNTIME_DIGITS);

    Spin_SetRange(m_hPage, spin_stop_after_min, 0, 59);
    Edit_LimitText(_hCtrl(txt_stop_after_min), 2);

    do
    {
        //
        // Set job flags
        //

        hr = pIJob->GetFlags(&m_dwFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        CheckDlgButton(m_hPage, chk_start_on_idle,
                        (m_dwFlags & TASK_FLAG_START_ONLY_IF_IDLE));

        CheckDlgButton(m_hPage, chk_stop_if_not_idle,
                        (m_dwFlags & TASK_FLAG_KILL_ON_IDLE_END));

        CheckDlgButton(m_hPage, chk_dont_start_if_on_batteries,
                        (m_dwFlags & TASK_FLAG_DONT_START_IF_ON_BATTERIES));

        CheckDlgButton(m_hPage, chk_kill_if_going_on_batteries,
                        (m_dwFlags & TASK_FLAG_KILL_IF_GOING_ON_BATTERIES));

        CheckDlgButton(m_hPage, chk_system_required,
                        (m_dwFlags & TASK_FLAG_SYSTEM_REQUIRED));

        CheckDlgButton(m_hPage, chk_delete_when_done,
                        (m_dwFlags & TASK_FLAG_DELETE_WHEN_DONE));

        //
        // Not all machines have resume timers, which are used to support the
        // TASK_FLAG_SYSTEM_REQUIRED flag.  If the target machine doesn't
        // have resume timers, hide the control.
        //

        if (!SupportsSystemRequired())
        {
            RECT rcSysReq;
            RECT rcGroup;
            LONG cy;

            //
            // Get the distance in pixels from the top of the system required
            // checkbox to the bottom of the group window.
            //
            // Reduce the height of the groupbox by this amount.
            //

            GetWindowRect(_hCtrl(chk_system_required), &rcSysReq);
            GetWindowRect(_hCtrl(grp_power_management), &rcGroup);

            cy = rcGroup.bottom - rcSysReq.top + 1;

            //
            // Hide the checkbox and resize the group window
            //

            ShowWindow(_hCtrl(chk_system_required), SW_HIDE);

            SetWindowPos(_hCtrl(grp_power_management),
                         NULL,
                         0,0,
                         rcGroup.right - rcGroup.left + 1,
                         rcGroup.bottom - rcGroup.top - cy + 1,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        //
        // Init idle controls
        //

        hr = m_pIJob->GetIdleWait(&m_wIdleWait, &m_wIdleDeadline);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (m_wIdleWait > MAX_IDLE_MINUTES)
        {
            m_wIdleWait = MAX_IDLE_MINUTES;
        }

        if (m_wIdleDeadline > MAX_IDLE_MINUTES)
        {
            m_wIdleDeadline = MAX_IDLE_MINUTES;
        }

        if (m_dwFlags & TASK_FLAG_START_ONLY_IF_IDLE)
        {
            Spin_Enable(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_Enable(m_hPage, spin_idle_deadline, m_wIdleDeadline);

            Spin_SetPos(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_SetPos(m_hPage, spin_idle_deadline, m_wIdleDeadline);
        }
        else
        {
            m_wIdleWait = SCH_DEFAULT_IDLE_TIME;
            m_wIdleDeadline = SCH_DEFAULT_IDLE_DEADLINE;
            Spin_Disable(m_hPage, spin_idle_min);
            Spin_Disable(m_hPage, spin_idle_deadline);
        }

        //
        // Set max run time
        //

        hr = pIJob->GetMaxRunTime(&m_dwMaxRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (m_dwMaxRunTime != (DWORD)-1)
        {
            CheckDlgButton(m_hPage, chk_stop_after, BST_CHECKED);

            //
            // Convert to minutes from milliseconds.  If the value is larger
            // than the UI supports, reduce it.
            //

            m_dwMaxRunTime /= 60000;

            if (m_dwMaxRunTime > (MAX_MAXRUNTIME_HOURS * 60 + 59))
            {
                m_dwMaxRunTime = MAX_MAXRUNTIME_HOURS * 60 + 59;
            }

            WORD wHours = (WORD) (m_dwMaxRunTime / 60);
            WORD wMins  = (WORD) (m_dwMaxRunTime % 60);
            Spin_SetPos(m_hPage, spin_stop_after_hr, wHours);
            Spin_SetPos(m_hPage, spin_stop_after_min, wMins);
        }
        else
        {
            CheckDlgButton(m_hPage, chk_stop_after, BST_UNCHECKED);

            Spin_Disable(m_hPage, spin_stop_after_hr);
            Spin_Disable(m_hPage, spin_stop_after_min);
        }

    } while (0);

    if (m_dwFlags & JOB_I_FLAG_NET_SCHEDULE)
    	_DisableUI();

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_SETTINGS_PAGE_INIT, hr);
        }

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    m_fDirty = FALSE;

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//	Member:		CSettingsPage::_DisableUI
//
//	Synopsis:	Disable UI so the user can only view the settings
//
//	History:	2001-11-13  ShBrown	Created
//
//---------------------------------------------------------------------------

void
CSettingsPage::_DisableUI(void)
{
	HWND hwnd;
    
    if (hwnd = _hCtrl(chk_delete_when_done)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_stop_after)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_stop_after_hr)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(spin_stop_after_hr)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_stop_after_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(spin_stop_after_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_start_on_idle)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_idle_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(spin_idle_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_idle_deadline)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(spin_idle_deadline)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_stop_if_not_idle)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_dont_start_if_on_batteries)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_kill_if_going_on_batteries)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_system_required)) EnableWindow(hwnd, FALSE);
}


LRESULT
CSettingsPage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CSettingsPage, _OnCommand);

    switch (id)
    {
    case chk_stop_after:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
        {
            Spin_Enable(m_hPage,
                        spin_stop_after_hr,
                        DEFAULT_MAXRUNTIME_HOURS);

            Spin_Enable(m_hPage,
                        spin_stop_after_min,
                        DEFAULT_MAXRUNTIME_MINUTES);
        }
        else
        {
            Spin_Disable(m_hPage, spin_stop_after_hr);
            Spin_Disable(m_hPage, spin_stop_after_min);
        }

        break;

    case chk_start_on_idle:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
        {
            Spin_Enable(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_Enable(m_hPage, spin_idle_deadline, m_wIdleDeadline);
        }
        else
        {
            Spin_Disable(m_hPage, spin_idle_min);
            Spin_Disable(m_hPage, spin_idle_deadline);
        }
        break;

    case txt_idle_min:
    case txt_idle_deadline:
    case txt_stop_after_hr:
    case txt_stop_after_min:
        if (codeNotify != EN_CHANGE)
        {
            return TRUE;
        }
        break;

//  case spin_stop_after_hr:
//  case spin_stop_after_min:
//      break;

    case chk_stop_if_not_idle:
    case chk_dont_start_if_on_batteries:
    case chk_kill_if_going_on_batteries:
    case chk_delete_when_done:
    case chk_system_required:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        break;

    default:
        return FALSE;
    }

    _EnableApplyButton();

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CSettingsPage::_ReadIdleSettings
//
//  Synopsis:   Move the idle settings from the edit controls to the member
//              variables, setting them on the job if they have been
//              updated.
//
//  History:    07-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CSettingsPage::_ReadIdleSettings()
{
    ULONG ulSpinPos;
    WORD wIdleWait;
    WORD wIdleDeadline;

    //
    // If idle wait isn't turned on, the controls don't have meaningful
    // values.
    //

    if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) != BST_CHECKED)
    {
        return;
    }

    ulSpinPos = Spin_GetPos(m_hPage, spin_idle_min);

    if (HIWORD(ulSpinPos))
    {
        wIdleWait = SCH_DEFAULT_IDLE_TIME;
    }
    else
    {
        wIdleWait = LOWORD(ulSpinPos);
    }

    ulSpinPos = Spin_GetPos(m_hPage, spin_idle_deadline);

    if (HIWORD(ulSpinPos))
    {
        wIdleDeadline = SCH_DEFAULT_IDLE_DEADLINE;
    }
    else
    {
        wIdleDeadline = LOWORD(ulSpinPos);
    }

    if (m_wIdleWait != wIdleWait || m_wIdleDeadline != wIdleDeadline)
    {
        HRESULT hr;

        hr = m_pIJob->SetIdleWait(wIdleWait, wIdleDeadline);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            m_wIdleWait = wIdleWait;
            m_wIdleDeadline = wIdleDeadline;
        }
    }
}




BOOL
CSettingsPage::_PerformSanityChk(void)
{
    ULONG ul;

    if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
    {
        ul = GetDlgItemInt(Hwnd(), txt_stop_after_hr, NULL, FALSE);

        if (!ul)
        {
            ul = GetDlgItemInt(Hwnd(), txt_stop_after_min, NULL, FALSE);

            if (!ul)
            {
                Spin_SetPos(Hwnd(), spin_stop_after_min, 1);
                _ErrorDialog(IERR_MAXRUNTIME);
                return FALSE;
            }
        }
    }

    return TRUE;
}

LRESULT
CSettingsPage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CSettingsPage, _OnPSNKillActive);

    if (_PerformSanityChk() == FALSE)
    {
        // Returns TRUE to prevent the page from losing the activation
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }

    //
    // Make sure Schedule page is synchronized with IdleWait changes.
    //

    _ReadIdleSettings();
    return CPropPage::_OnPSNKillActive(lParam);
}

LRESULT
CSettingsPage::_OnPSNSetActive(LPARAM lParam)
{
    m_fInInit = TRUE;

    //
    // Make sure IdleWait is synchronized with Schedule page changes.
    //

    WORD wDummy;

    HRESULT hr = m_pIJob->GetIdleWait(&m_wIdleWait, &wDummy);

    if (SUCCEEDED(hr) &&
        IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
    {
        Spin_SetPos(m_hPage, spin_idle_min, m_wIdleWait);
    }
    m_fInInit = FALSE;

    return CPropPage::_OnPSNSetActive(lParam);
}

LRESULT
CSettingsPage::_OnApply(void)
{
    TRACE(CSettingsPage, _OnApply);
    //DbxDisplay("CSettingsPage::_OnApply");

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    if (_PerformSanityChk() == FALSE)
    {
        SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    HRESULT     hr = S_OK;
    ITask     * pIJob = m_pIJob;
    DWORD       dwFlags = 0;

    do
    {
        if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_START_ONLY_IF_IDLE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_stop_if_not_idle) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_KILL_ON_IDLE_END;
        }

        if (IsDlgButtonChecked(m_hPage, chk_dont_start_if_on_batteries)
            == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_DONT_START_IF_ON_BATTERIES;
        }

        if (IsDlgButtonChecked(m_hPage, chk_kill_if_going_on_batteries) ==
            BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
        }

        if (IsDlgButtonChecked(m_hPage, chk_system_required) ==
            BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        }

        if (IsDlgButtonChecked(m_hPage, chk_delete_when_done) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_DELETE_WHEN_DONE;
        }

        if ((m_dwFlags & TASK_FLAGS_IN_SETTINGS_PAGE) != dwFlags)
        {
            hr = pIJob->GetFlags(&m_dwFlags);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            dwFlags |= (m_dwFlags & ~TASK_FLAGS_IN_SETTINGS_PAGE);

            hr = pIJob->SetFlags(dwFlags);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_dwFlags = dwFlags;
        }

        _ReadIdleSettings();

        DWORD dwMins = (DWORD)-1;

        if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
        {
            ULONG ulSpinPos = Spin_GetPos(m_hPage, spin_stop_after_hr);

            if (HIWORD(ulSpinPos))
            {
                dwMins = DEFAULT_MAXRUNTIME_HOURS * 60;
            }
            else
            {
                dwMins = LOWORD(ulSpinPos) * 60;
            }

            ulSpinPos = Spin_GetPos(m_hPage, spin_stop_after_min);

            if (HIWORD(ulSpinPos))
            {
                dwMins += DEFAULT_MAXRUNTIME_MINUTES;
            }
            else
            {
                dwMins += LOWORD(ulSpinPos);
            }
        }

        Win4Assert(dwMins != 0);

        if (m_dwMaxRunTime != dwMins)
        {
            // Max run time is in milliseconds
            hr = pIJob->SetMaxRunTime(
                    ((dwMins == (DWORD)-1) ? (DWORD)-1 : (dwMins * 60000)));

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_dwMaxRunTime = dwMins;
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE) &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // First, fetch general page task, application dirty status flags.
            // Default to not dirty if the general page isn't present.
            //

            BOOL fTaskApplicationChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_APPLICATION_DIRTY_STATUS,
                                    (LPARAM)&fTaskApplicationChange);
            BOOL fTaskAccountChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS,
                                    (LPARAM)&fTaskAccountChange);
            BOOL fSuppressAccountInfoRequest = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG,
                                    (LPARAM)&fSuppressAccountInfoRequest);

            hr = JFSaveJob(Hwnd(),
                           pIJob,
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           fTaskAccountChange,
                           fTaskApplicationChange,
                           fSuppressAccountInfoRequest);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_APPLICATION_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG, 0);

            //
            // Instruct the general page to refresh account information.
            //

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        TASK_ACCOUNT_CHANGE_NOTIFY, 0);
        }

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return TRUE;
}



LRESULT
CSettingsPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    int iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;
    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);

    return iRet;
}



HRESULT
GetSettingsPage(
    ITask          * pIJob,
    LPTSTR           ptszTaskPath,
    BOOL             fPersistChanges,
    HPROPSHEETPAGE * phpage)
{
    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    LPTSTR  ptszPath = NULL;
    HRESULT hr        = S_OK;
    WORD    cTriggers = 0;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // Use passed-in path
            //

            ptszPath = ptszTaskPath;
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPath);
            BREAK_ON_FAIL(hr);
        }

        hr = pIJob->GetTriggerCount(&cTriggers);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            break;
        }

        CSettingsPage * pPage = new CSettingsPage(
                                            pIJob,
                                            ptszPath,
                                            fPersistChanges);

        if (pPage == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;

            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    //
    // If we made a copy of pIJob's path string, free it.
    //

    if (ptszPath != ptszTaskPath)
    {
        delete [] ptszPath;
    }

    return hr;
}



HRESULT
AddSettingsPage(
    PROPSHEETHEADER &psh,
    ITask         *  pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSettingsPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddSettingsPage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSettingsPage(pIJob, NULL, TRUE, &hpage);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\selmonth.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selmonth.cxx
//
//  Contents:   Implementation of class to manage simple month-selection
//              dialog box.
//
//  Classes:    CSelectMonth
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <mstask.h>
#include "dll.hxx"
#include "dlg.hxx"
#include "selmonth.hxx"
#include "rc.h"
#include "uiutil.hxx"
#include "defines.hxx"
#include "helpids.h"


// Helpids for Select Months dialog
const ULONG s_aSelectMonthDlgHelpIds[] =
{
    select_month_dlg,           Hselect_month_dlg,
    chk_jan,                    Hchk_jan,
    chk_feb,                    Hchk_feb,
    chk_mar,                    Hchk_mar,
    chk_apr,                    Hchk_apr,
    chk_may,                    Hchk_may,
    chk_jun,                    Hchk_jun,
    chk_jul,                    Hchk_jul,
    chk_aug,                    Hchk_aug,
    chk_sep,                    Hchk_sep,
    chk_oct,                    Hchk_oct,
    chk_nov,                    Hchk_nov,
    chk_dec,                    Hchk_dec,
    lbl_sel_months,             Hlbl_sel_months,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::InitSelectionFromTrigger
//
//  Synopsis:   Set selected bits from monthly trigger
//
//  Arguments:  [pjt] - pointer to trigger to modify, must be of type
//                       TASK_TIME_TRIGGER_MONTHLYDATE or
//                       TASK_TIME_TRIGGER_MONTHLYDOW.
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::InitSelectionFromTrigger(
   const TASK_TRIGGER *pjt)
{
    if (pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        _rgfMonths = pjt->Type.MonthlyDate.rgfMonths;
    }
    else
    {
        Win4Assert(pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);
        _rgfMonths = pjt->Type.MonthlyDOW.rgfMonths;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::UpdateTrigger
//
//  Synopsis:   Copy the dialog settings into the appropriate rgfMonths
//              field in [pjt].
//
//  Arguments:  [pjt] - pointer to trigger to modify.
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::UpdateTrigger(
    TASK_TRIGGER *pjt)
{
    if (!_rgfMonths)
    {
        _rgfMonths = ALL_MONTHS;
    }

    if (pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        pjt->Type.MonthlyDate.rgfMonths = _rgfMonths;
    }
    else
    {
        Win4Assert(pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);
        pjt->Type.MonthlyDOW.rgfMonths = _rgfMonths;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::RealDlgProc
//
//  Synopsis:   Dispatch to methods for specific messages.
//
//  Arguments:  standard windows dlg
//
//  Returns:    standard windows dlg
//
//  Derivation: CDlg override
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CSelectMonth::RealDlgProc(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInit();
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            if (!_OnOK())
            {
                // tell user at least 1 month must be selected
                SchedUIErrorDialog(Hwnd(), IERR_INVALID_MONTHLY_TASK, 0);
                break;
            }
            // else FALL THROUGH

        case IDCANCEL:
            EndDialog(Hwnd(), GET_WM_COMMAND_ID(wParam, lParam) != IDCANCEL);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                szMstaskHelp,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR)s_aSelectMonthDlgHelpIds);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                szMstaskHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR)s_aSelectMonthDlgHelpIds);
        return TRUE;

    default:
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::_OnInit
//
//  Synopsis:   Check boxes so they match flags in _flMonths
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::_OnInit()
{
    ULONG id;

    for (id = chk_jan; id <= chk_dec; id++)
    {
        if (_rgfMonths & (1 << (id - chk_jan)))
        {
            CheckDlgButton(Hwnd(), id, BST_CHECKED);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::_OnOK
//
//  Synopsis:   Map checked boxes to TASK_<month> bits in *_prgfMonths
//
//  Returns:    TRUE if at least one month is selected
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CSelectMonth::_OnOK()
{
    ULONG id;

    _rgfMonths = 0;

    for (id = chk_jan; id <= chk_dec; id++)
    {
        if (IsDlgButtonChecked(Hwnd(), id))
        {
            _rgfMonths |= (1 << (id - chk_jan));
        }
    }

    return _rgfMonths != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedule\job_enum.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job_enum.cxx
//
//  Contents:   job object enumerator implementation
//
//  Classes:    CEnumJobs
//
//  Interfaces: IEnumWorkItems
//
//  History:    13-Sep-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

void FreeStrings(LPWSTR * rgpwszNames, int n);

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Next, public
//
//  Synopsis:   Returns the indicated number of job object monikers
//
//  Arguments:  [cJobs]         - the number of jobs to return
//              [rgpwszNames]   - the array of returned job names
//              [pcJobsFetched] - the actual number of jobs returned; can be
//                                less than or equal to cJobs. Can be NULL if
//                                cJobs is equal to one.
//
//  Returns:    S_OK - returned requested number of job names
//              S_FALSE - returned less than requested number of names because
//                        the end of the enumeration sequence was reached.
//              E_INVALIDARG or E_OUTOFMEMORY - s.b. obvious
//
//  Notes:      Each LPWSTR in the array must be caller freed using
//              CoTaskMemFree and then the array itself must be freed
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Next(ULONG cJobs, LPWSTR ** rgpwszNames, ULONG * pcJobsFetched)
{
    HRESULT hr = S_OK;
    if (cJobs == 0)
    {
        return E_INVALIDARG;
    }
    if (cJobs > 1 && pcJobsFetched == NULL)
    {
        // as required by IEnumX spec.
        //
        return E_INVALIDARG;
    }
    if (!rgpwszNames)
    {
        return E_INVALIDARG;
    }

    *rgpwszNames = NULL;

    if (m_fFindOverrun)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        return S_FALSE;
    }

    TCHAR * ptszName;
    WCHAR * pwszName;

    //
    // find the first requested
    //
    hr = GetNext(&ptszName);
    if (hr != S_OK)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        *rgpwszNames = NULL;
        return hr;
    }

    //
    // allocate the first job object name string and the pointer to it
    //
    *rgpwszNames = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR *));
    if (*rgpwszNames == NULL)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        return E_OUTOFMEMORY;
    }

    pwszName = ptszName;
    size_t cch = wcslen(pwszName) + 1;
    **rgpwszNames = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));
    if (**rgpwszNames == NULL)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        CoTaskMemFree(*rgpwszNames);
        *rgpwszNames = NULL;
        return E_OUTOFMEMORY;
    }

    StringCchCopy(**rgpwszNames, cch, pwszName);

    delete ptszName;

    if (cJobs == 1)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 1;
        }
        return S_OK;
    }

    //
    // Note a check at entry guarantees that at this point pcJobsFetched !=
    // NULL.
    //

    ULONG i = 1;

    //
    // find the rest requested
    //
    while (++i <= cJobs)
    {
        hr = GetNext(&ptszName);
        if (hr != S_OK)
        {
            //
            // Either hr == S_FALSE and we've completed successfully because
            // there are no more jobs to enumerate, or else hr is a
            // failure code and we must bail.
            //

            break;
        }
        LPWSTR * rgpwszTmp = *rgpwszNames;

        *rgpwszNames = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR *) * i);

        if (*rgpwszNames == NULL)
        {
            *rgpwszNames = rgpwszTmp; // so cleanup will free strings
            hr = E_OUTOFMEMORY;
            break;
        }

        memcpy(*rgpwszNames, rgpwszTmp, sizeof(LPWSTR *) * (i - 1));

        CoTaskMemFree(rgpwszTmp);

        pwszName = ptszName;
        cch = wcslen(pwszName) + 1;
        (*rgpwszNames)[i - 1] = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));
        if ((*rgpwszNames)[i - 1] == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        StringCchCopy((*rgpwszNames)[i - 1], cch, pwszName);

        delete ptszName;
        ptszName = NULL;
    }

    if (FAILED(hr))
    {
        FreeStrings(*rgpwszNames, i - 1);
        delete ptszName;
        *pcJobsFetched = 0;
        *rgpwszNames = NULL;
    }
    else
    {
        *pcJobsFetched = --i;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::GetNext, private
//
//  Synopsis:   enumeration helper
//
//  Arguments:  [pptszName] - the job/queue name, relative to the jobs folder
//
//  Returns:    S_OK - found next file
//              S_FALSE - the end of the enumeration sequence was reached.
//              other code - file system or memory error
//
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::GetNext(LPTSTR * pptszName)
{
    HRESULT hr = S_OK;

    DWORD dwRet = NO_ERROR;
    WIN32_FIND_DATA FindData;
    //
    // loop until either a matching file is found or the search is done
    //
    do
    {
        //
        // if the find handle is invalid, then we need to start a find in the
        // next directory (which may in fact be the first directory)
        //
        if (m_hFind == INVALID_HANDLE_VALUE)
        {
            //
            // Note that, unless ENUM_SUBDIRS is defined, PopDir returns the
            // string "." the first time it is called and returns S_FALSE the
            // second time to stop the enumeration.
            //
            hr = PopDir(m_tszCurDir, MAX_PATH + 1);
            if (hr == S_FALSE)
            {
                // we're done
                //
                m_fFindOverrun = TRUE;
                return S_FALSE;
            }

            TCHAR tszFullDirPath[MAX_PATH + 1];

            StringCchCopy(tszFullDirPath, MAX_PATH + 1, m_ptszFolderPath);
            StringCchCat(tszFullDirPath, MAX_PATH + 1, TEXT("\\*"));

            m_hFind = FindFirstFile(tszFullDirPath, &FindData);
            if (m_hFind == INVALID_HANDLE_VALUE)
            {
                dwRet = GetLastError();
                if (dwRet == ERROR_FILE_NOT_FOUND)
                {   // no files in the current dir, check the next dir.
                    continue;
                }
                else
                {
                    return HRESULT_FROM_WIN32(dwRet);
                }
            }

            hr = CheckFound(&FindData);
            if (hr == S_OK)
            {   // match found
                break;
            }
            if (hr != S_FALSE)
            {   // an error condition
                return hr;
            }
        }

        //
        // Continue looking at files in the current dir until a job/queue has
        // been found or the dir has been scanned. If the former, break out of
        // both loops. If the latter, break out of the inner loop and then
        // restart the search on the next dir.
        //
        do
        {
            if (!FindNextFile(m_hFind, &FindData))
            {
                dwRet = GetLastError();
                if (dwRet == ERROR_NO_MORE_FILES)
                {
                    FindClose(m_hFind);
                    m_hFind = INVALID_HANDLE_VALUE;
                    hr = S_FALSE;
                    break;
                }
                else
                {
                    return HRESULT_FROM_WIN32(dwRet);
                }
            }

            hr = CheckFound(&FindData);
            if (hr == S_OK)
            {   // match found
                break;
            }
            if (hr != S_FALSE)
            {   // an error condition
                return hr;
            }
        } while (hr != S_OK);
    } while (hr != S_OK);

    if (pptszName != NULL && dwRet == NO_ERROR)
    {
        int cch = lstrlen(FindData.cFileName);

        *pptszName = new TCHAR[cch + 1];
        if (*pptszName == NULL)
        {
            return E_OUTOFMEMORY;
        }

        StringCchCopy(*pptszName, cch + 1, FindData.cFileName);
    }
    m_cFound++;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::CheckFound, private
//
//  Synopsis:   Checks if the found file is a job or queue. If it is a
//              directory, push it onto the dir stack.
//
//  Returns:    S_OK if a job or queue, S_FALSE if not.
//
//  Notes:      The file find functions match on both long and short versions
//              of file names, so all names of the form *.job* will match
//              (a file like foo.jobber will have a short name of foo~1.job).
//              Thus, the returned file names must be checked for an exact
//              extension match.
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::CheckFound(LPWIN32_FIND_DATA pFindData)
{
    HRESULT hr;

    TCHAR * ptszExt = _tcsrchr(pFindData->cFileName, TEXT('.'));

    if (ptszExt)
    {
        if (lstrcmpi(ptszExt, m_tszJobExt) == 0)
            // || lstrcmpi(ptszExt, m_tszQueExt) == 0
        {
            return S_OK;
        }
    }
    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Skip, public
//
//  Synopsis:   Skips the indicated number of jobs in the enumeration
//
//  Arguments:  [cJobs] - the number of jobs to skip
//
//  Returns:    S_OK - skipped requested number of job names
//              S_FALSE - skipped less than requested number of names because
//                        the end of the enumeration sequence was reached.
//              E_INVALIDARG - if cJobs == 0
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Skip(ULONG cJobs)
{
    if (cJobs == 0)
    {
        return E_INVALIDARG;
    }

    if (m_fFindOverrun)
    {
        return S_FALSE;
    }
    HRESULT hr = S_OK;

    //
    // skip the requested number
    //
    for (ULONG i = 1; i <= cJobs; i++)
    {
        hr = GetNext(NULL);
        if (hr != S_OK)
        {
            return hr;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Reset, public
//
//  Synopsis:   Sets the enumerator back to its original state
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Reset(void)
{
    if (m_hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
        m_hFind = INVALID_HANDLE_VALUE;
    }
    m_fFindOverrun = FALSE;
    m_cFound = 0;
    ClearDirStack();
    m_pdsHead = new DIRSTACK;
    if (m_pdsHead == NULL)
    {
        return E_OUTOFMEMORY;
    }
    StringCchCopy(m_pdsHead->tszDir, MAX_PATH + 1, TEXT("."));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Clone, public
//
//  Synopsis:   Creates a copy of the enumerator object with the same state
//
//  Arguments:  [ppEnumJobs] - a place to return a pointer to the enum object
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Clone(IEnumWorkItems ** ppEnumJobs)
{
    TRACE(CEnumJobs, Clone);

    if (!ppEnumJobs)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    CEnumJobs * pEnumJobs = new CEnumJobs;
    if (pEnumJobs == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ErrCleanup;
    }

    hr = pEnumJobs->Init(m_ptszFolderPath);
    if (FAILED(hr))
    {
        goto ErrCleanup;
    }

    if (m_cFound > 0)
    {
        hr = pEnumJobs->Skip(m_cFound);
        if (FAILED(hr))
        {
            goto ErrCleanup;
        }
    }

    *ppEnumJobs = pEnumJobs;

    return S_OK;

ErrCleanup:

    delete pEnumJobs;
    *ppEnumJobs = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::Init, protected
//
//  Synopsis:   Initializes the enumeration
//
//  Returns:    hresults
//
//  Notes:      Initialization is not done during construction since the only
//              way to return ctor errors is to throw an exception.
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::Init(TCHAR * ptszFolderPath)
{
    TRACE(CEnumJobs, Init);
    if (ptszFolderPath == NULL)
    {
        return E_FAIL;
    }

    size_t cch = lstrlen(ptszFolderPath) + 1;
    m_ptszFolderPath = new TCHAR[cch];
    if (!m_ptszFolderPath)
    {
        return E_OUTOFMEMORY;
    }
    StringCchCopy(m_ptszFolderPath, cch, ptszFolderPath);

    m_pdsHead = new DIRSTACK;
    if (m_pdsHead == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(m_pdsHead->tszDir, MAX_PATH + 1, TEXT("."));
    StringCchCopy(m_tszJobExt, SCH_SMBUF_LEN, TEXT(".") TSZ_JOB);

    m_fInitialized = TRUE;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::CEnumJobs
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CEnumJobs::CEnumJobs(void) :
    m_hFind(INVALID_HANDLE_VALUE),
    m_pdsHead(NULL),
    m_ptszFolderPath(NULL),
    m_cFound(0),
    m_fInitialized(FALSE),
    m_fFindOverrun(FALSE),
    m_uRefs(1)
{
    m_tszCurDir[0] = TEXT('\0');
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::~CEnumJobs
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CEnumJobs::~CEnumJobs(void)
{
    if (m_hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }

    ClearDirStack();

    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::PopDir, private
//
//  Synopsis:   Pops the head element off of the dir stack.
//
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::PopDir(LPTSTR ptszDir, size_t cchBuff)
{
    if (m_pdsHead == NULL)
    {
        return S_FALSE;
    }
    StringCchCopy(ptszDir, cchBuff, m_pdsHead->tszDir);
    PDIRSTACK pdsNode = m_pdsHead->pdsNext;
    delete m_pdsHead;
    m_pdsHead = pdsNode;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::ClearDirStack, private
//
//  Synopsis:   free the stack element memory
//
//-----------------------------------------------------------------------------
void
CEnumJobs::ClearDirStack(void)
{
    if (m_pdsHead != NULL)
    {
        PDIRSTACK pdsNode, pdsNextNode;
        pdsNode = m_pdsHead;
        do
        {
            pdsNextNode = pdsNode->pdsNext;
            delete pdsNode;
            pdsNode = pdsNextNode;
        } while (pdsNode);
        m_pdsHead = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeStrings
//
//  Synopsis:   Frees the strings contained in the array and then the array
//              itself.
//
//  Arguments:  [rgpwszNames] - the array of strings.
//              [n]           - the array size.
//
//-----------------------------------------------------------------------------
void
FreeStrings(LPWSTR * rgpwszNames, int n)
{
    for (int i = 0; i < n; i++)
    {
        CoTaskMemFree(rgpwszNames[i]);
    }
    CoTaskMemFree(rgpwszNames);
}

//+----------------------------------------------------------------------------
//
//      CEnumJobs IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (!ppvObject)
    {
        return E_INVALIDARG;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(IEnumWorkItems *)this;
    }
    else if (IID_IEnumWorkItems == riid)
    {
        *ppvObject = (IUnknown *)(IEnumWorkItems *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CEnumJobs::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CEnumJobs::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

// BUGBUG: need a class factory if the interface is going to be exposed to OA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedule\sch_at.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_at.cxx
//
//  Contents:   scheduler class object methods to support the NetSchedule
//              (AT) APIs.
//
//  Classes:    CSchedule
//
//  History:    30-Jan-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

//
// Forward references
//

VOID
SetDomTrigger2Days(
    DWORD dwDaysOfMonth,
    WORD wFirstDayToCheck,
    WORD wLastDayToCheck,
    SYSTEMTIME *pstStart2,
    SYSTEMTIME *pstEnd2);


HRESULT
CSchedule::AddAtJobCommon(
    const AT_INFO &At,
    DWORD         *pID,
    CJob          **ppJob,
    WCHAR         wszName[],
    size_t        cchBuff,
    WCHAR         wszID[]
    )
{
    HRESULT  hr = S_OK;

    //
    // If the next at id is > 1 but there aren't any at jobs, the id can be
    // reset to 1.
    //

    if (m_dwNextID > 1 && S_FALSE == _AtTaskExists())
    {
        ResetAtID();
    }

    //
    // Compose a name for the new AT job.
    //
    StringCchCopy(wszName, cchBuff, m_ptszFolderPath);
    StringCchCat(wszName, cchBuff, L"\\" TSZ_AT_JOB_PREFIX);
    _itow(m_dwNextID, wszID, 10);
    StringCchCat(wszName, cchBuff, wszID);
    StringCchCat(wszName, cchBuff, L"." TSZ_JOB);
    //
    // Create a new job
    //
    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        ERR_OUT("CSchedule::AddAtJob: CJob::Create", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Convert the AT command line.
    //
    WCHAR * pwszApp, * pwszParams, wszCommand[MAX_PATH];

    //
    // net\svcdlls\atcmd\atcmd.c defines MAX_COMMAND_LEN to be 128. This
    // should at some point be changed to MAX_PATH.
    //
    StringCchCopy(wszCommand, MAX_PATH, At.Command);

    pwszApp = wszCommand;

    //
    // The app name and any command line params are all passed in one string,
    // At.Command, so separate the app name from the params. Any path to the
    // app plus the app name may be quoted. Otherwise, the parameters are
    // separated from the app name by white space.
    //
    if (*pwszApp == L'"')
    {
        //
        // Initial quote found, scan for end quote. The app name passed to
        // SetApplicationName should not be quoted.
        //
        pwszApp++;
        pwszParams = pwszApp + 1;
        while (TRUE)
        {
            if (*pwszParams == L'\0')
            {
                //
                // End of string found, no params.
                //
                pwszParams = NULL;
                break;
            }
            if (*pwszParams == L'"')
            {
                //
                // End quote found.
                //
                break;
            }
            pwszParams++;
        }
    }
    else
    {
        //
        // App path/name not quoted, scan for first white space for parameters.
        //
        pwszParams = wcspbrk(pwszApp, L" \t");
    }

    if (pwszParams != NULL)
    {
        // Null terminate app name string.
        //
        *pwszParams = L'\0';
        //
        // Move to first char of the parameters.
        //
        pwszParams++;
        //
        // Skip any leading white space.
        //
        while (*pwszParams != L'\0')
        {
            if (*pwszParams != L' ' && *pwszParams != L'\t')
            {
                break;
            }
            pwszParams++;
        }

        if (*pwszParams == L'\0')
        {
            //
            // No params.
            //
            pwszParams = NULL;
        }
    }

    hr = pJob->SetApplicationName(pwszApp);
    if (FAILED(hr))
    {
        ERR_OUT("AddAtJob: SetApplicationName", hr);
        pJob->Release();
        return hr;
    }
    if (pwszParams != NULL)
    {
        hr = pJob->SetParameters(pwszParams);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: SetParameters", hr);
            pJob->Release();
            return hr;
        }
    }

    pJob->m_rgFlags |= JOB_I_FLAG_NET_SCHEDULE | TASK_FLAG_DELETE_WHEN_DONE;

    if (!(At.Flags & JOB_NONINTERACTIVE))
    {
        pJob->m_rgFlags |= TASK_FLAG_INTERACTIVE;
    }

    pJob->m_hrStatus = SCHED_S_TASK_READY;

    WCHAR szComment[SCH_BUF_LEN + 1];
    if (LoadString(g_hInstance,
                   IDS_NETSCHED_COMMENT,
                   szComment,
                   SCH_BUF_LEN) > 0)
    {
        pJob->SetComment(szComment);
    }

    //
    // Convert from NetSchedule representation to Job Scheduler representation
    // of the run dates and times.
    //

    SYSTEMTIME stNow, stStart;
    SYSTEMTIME stDomStart1, stDomEnd1, stDomStart2, stDomEnd2;
    SYSTEMTIME stDowStart, stDowEnd;

    stDomStart2.wDay = 0;  // this serves as a flag
    GetLocalTime(&stNow);
    stStart = stNow;

    //
    // JobTime is expressed as milliseconds after midnight, so convert to
    // minutes.
    //
    DWORD dwMins = (DWORD)(At.JobTime / JOB_MILLISECONDS_PER_MINUTE);

    stStart.wHour = (WORD)(dwMins / JOB_MINS_PER_HOUR);
    stStart.wMinute = (WORD)(dwMins % JOB_MINS_PER_HOUR);
    stStart.wSecond = stStart.wMilliseconds = 0;

    DWORD DaysOfMonth = At.DaysOfMonth;

    WORD wFirstDowRunOffset = 0, wFirstDomRunOffset = 0;

    TASK_TRIGGER Trigger;

    if (At.Flags & JOB_ADD_CURRENT_DATE)
    {
        //
        // The flag is set, so add today as the first run date.
        //
        DaysOfMonth |= 1 << (stStart.wDay - 1);
    }
    else
    {
        if (DaysOfMonth == 0 && At.DaysOfWeek == 0)
        {
            //
            // Neither bitmask is set, so run at the next opportunity.
            //

            Trigger.TriggerType = TASK_TIME_TRIGGER_ONCE;

            if (! IsFirstTimeEarlier(&stNow, &stStart))
            {
                // Job runs tomorrow
                IncrementDay(&stStart);
            }
        }
    }

    //
    // Set the trigger values and save the new trigger(s).
    //
    // Initialize the start and end dates in case this is a periodic trigger.
    // If it is not periodic, then new start and end dates will overwrite
    // these initialization values.
    //

    Trigger.cbTriggerSize = sizeof(TASK_TRIGGER);
    Trigger.Reserved1 = pJob->m_Triggers.GetCount();
    Trigger.wBeginYear = stStart.wYear;
    Trigger.wBeginMonth = stStart.wMonth;
    Trigger.wBeginDay = stStart.wDay;
    Trigger.wEndYear = 0;
    Trigger.wEndMonth = 0;
    Trigger.wEndDay = 0;
    Trigger.wStartHour = stStart.wHour;
    Trigger.wStartMinute = stStart.wMinute;
    Trigger.Reserved2 = 0;
    Trigger.wRandomMinutesInterval = 0;

    Trigger.rgFlags = (At.Flags & JOB_RUN_PERIODICALLY)
                      ? 0 : TASK_TRIGGER_FLAG_HAS_END_DATE;

    Trigger.MinutesInterval = Trigger.MinutesDuration = 0;

    if (DaysOfMonth == 0 && At.DaysOfWeek == 0)
    {
       // First, zero out the end date flag
       Trigger.rgFlags &= ~JOB_RUN_PERIODICALLY;

       // This is a TASK_TIME_TRIGGER_ONCE job, and we are ready to commit
       hr = pJob->m_Triggers.Add(Trigger);
       if (FAILED(hr))
       {
           ERR_OUT("AddAtJob: m_Triggers.Add Once", hr);
           pJob->Release();
           return hr;
       }
    }

    if (DaysOfMonth > 0)
    {
        Trigger.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
        Trigger.Type.MonthlyDate.rgfDays = DaysOfMonth;
        Trigger.Type.MonthlyDate.rgfMonths = JOB_RGFMONTHS_MAX;

        if (!(At.Flags & JOB_RUN_PERIODICALLY))
        {
            CalcDomTriggerDates(DaysOfMonth,
                                stNow,
                                stStart,
                                &stDomStart1,
                                &stDomEnd1,
                                &stDomStart2,
                                &stDomEnd2);

            Trigger.wBeginYear = stDomStart1.wYear;
            Trigger.wBeginMonth = stDomStart1.wMonth;
            Trigger.wBeginDay = stDomStart1.wDay;
            Trigger.wEndYear = stDomEnd1.wYear;
            Trigger.wEndMonth = stDomEnd1.wMonth;
            Trigger.wEndDay = stDomEnd1.wDay;
        }

        hr = pJob->m_Triggers.Add(Trigger);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: m_Triggers.Add Dom1", hr);
            pJob->Release();
            return hr;
        }

        if (stDomStart2.wDay != 0)
        {
            Trigger.wBeginYear = stDomStart2.wYear;
            Trigger.wBeginMonth = stDomStart2.wMonth;
            Trigger.wBeginDay = stDomStart2.wDay;
            Trigger.wEndYear = stDomEnd2.wYear;
            Trigger.wEndMonth = stDomEnd2.wMonth;
            Trigger.wEndDay = stDomEnd2.wDay;

            Trigger.Reserved1 = pJob->m_Triggers.GetCount();
            hr = pJob->m_Triggers.Add(Trigger);
            if (FAILED(hr))
            {
                ERR_OUT("AddAtJob: m_Triggers.Add Dom2", hr);
                pJob->Release();
                return hr;
            }
        }
    }

    if (At.DaysOfWeek > 0)
    {
        Trigger.Reserved1 = pJob->m_Triggers.GetCount();
        Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        Trigger.Type.Weekly.WeeksInterval = 1;
        //
        // Convert AT_INFO DOW to Scheduler DOW:
        // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
        // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
        //
        Trigger.Type.Weekly.rgfDaysOfTheWeek = At.DaysOfWeek << 1;
        if (Trigger.Type.Weekly.rgfDaysOfTheWeek & 0x0080)
        {
            Trigger.Type.Weekly.rgfDaysOfTheWeek &= ~0x0080;
            Trigger.Type.Weekly.rgfDaysOfTheWeek |= 1;
        }

        if (!(At.Flags & JOB_RUN_PERIODICALLY))
        {
            CalcDowTriggerDate(stNow,
                               stStart,
                               &stDowStart,
                               &stDowEnd);

            Trigger.wBeginYear = stDowStart.wYear;
            Trigger.wBeginMonth = stDowStart.wMonth;
            Trigger.wBeginDay = stDowStart.wDay;
            Trigger.wEndYear = stDowEnd.wYear;
            Trigger.wEndMonth = stDowEnd.wMonth;
            Trigger.wEndDay = stDowEnd.wDay;
        }

        hr = pJob->m_Triggers.Add(Trigger);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: m_Triggers.Add", hr);
            pJob->Release();
            return hr;
        }
    }

	// get the AT task maximum run time from the registry
	// if the call fails, the default of 72 will be used
	DWORD dwMaxRunTime = 0;
	if (SUCCEEDED(GetAtTaskMaxHours(&dwMaxRunTime)))
		pJob->SetMaxRunTime(dwMaxRunTime);

    //
    // Set the same flags as in CJob::CreateTrigger.  (We should really call
    // CreateTrigger in this function instead of creating the trigger ourselves.)
    //
    pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    pJob->SetTriggersDirty();

    //
    // Save the new job.  Obviously this is one place we definitely don't want
    // the AT job flag cleared on save!
    //
    hr = pJob->SaveWithRetry(wszName,
                             TRUE,
                             SAVEP_VARIABLE_LENGTH_DATA |
                             SAVEP_PRESERVE_NET_SCHEDULE);

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            //
            // Name collision; someone has renamed a task to match the next
            // AT job. Recalc the max AT job ID.
            //
            GetNextAtID(&m_dwNextID);
            StringCchCopy(wszName, cchBuff, m_ptszFolderPath);
            StringCchCat(wszName, cchBuff, L"\\" TSZ_AT_JOB_PREFIX);
            _itow(m_dwNextID, wszID, 10);
            StringCchCat(wszName, cchBuff, wszID);
            StringCchCat(wszName, cchBuff, TSZ_DOTJOB);

            //
            // Now, retry the save.
            //
            hr = pJob->SaveWithRetry(wszName,
                                     TRUE,
                                     SAVEP_VARIABLE_LENGTH_DATA |
                                     SAVEP_PRESERVE_NET_SCHEDULE);
            if (FAILED(hr))
            {
                ERR_OUT("CSchedule::AddAtJob: Save", hr);
                pJob->Release();
                return hr;
            }
        }
        else
        {
            ERR_OUT("CSchedule::AddAtJob: Save", hr);
            pJob->Release();
            return hr;
        }
    }

    *ppJob = pJob;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::GetAtTaskMaxHours
//
//  Synopsis:   Check a registry setting to see what max run time value a user 
//				has specified for AT tasks.  If the key is not present or can't
//				be opened then interpret as the normal task default of 72.
//
//  Arguments:  none
//
//  Returns:    bool
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
HRESULT CSchedule::GetAtTaskMaxHours(DWORD* pdwMaxHours)
{
    //
    // Open the schedule service key
    //
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0, KEY_READ | KEY_WRITE, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        return(HRESULT_FROM_WIN32(lErr));
    }

    //
    // Get the AtTaskMaxHours setting
    //
	bool bNeedToUpdate = false;
	DWORD dwMaxHours = 0;
    DWORD cb = sizeof(DWORD);
    lErr = RegQueryValueEx(hSchedKey, SCH_ATTASKMAXHOURS_VALUE, NULL, NULL, (LPBYTE)&dwMaxHours, &cb);
    if (lErr != ERROR_SUCCESS)
    {
        if (lErr != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("Read of AtTaskMaxHours registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }

        //
        // Need to create the missing registry entry
        //
		dwMaxHours = DEFAULT_MAXRUNTIME_HOURS;
		bNeedToUpdate = true;
    }

	//
	// Correct out-of-bounds stored registry values
	//
	if (dwMaxHours > 999)
	{
		dwMaxHours = 999;
		bNeedToUpdate = true;
	}

	if (bNeedToUpdate)
	{
        lErr = RegSetValueEx(hSchedKey, SCH_ATTASKMAXHOURS_VALUE, 0, REG_DWORD,(CONST BYTE *)&dwMaxHours, sizeof(DWORD));
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Update of AtTaskMaxHours registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }
	}

	//
	// Convert the stored value to a value that has meaning to the scheduler
	//
	if (!dwMaxHours)
		dwMaxHours = INFINITE;	// If value is zero, return infinite (-1) for max run time
	else
		dwMaxHours *= 3600000;	// The stored value is in hours, but the value passed back
								// needs to be in milliseconds, so convert

    RegCloseKey(hSchedKey);

	// Set the value to be passed back
	*pdwMaxHours = dwMaxHours;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::AddAtJob
//
//  Synopsis:   create a downlevel job
//
//  Arguments:  [At]  - reference to an AT_INFO struct
//              [pID] - returns the new ID (optional, can be NULL)
//
//  Returns:    HRESULTS
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddAtJob(const AT_INFO &At, DWORD * pID)
{
    TRACE(CSchedule, AddAtJob);
    HRESULT hr = S_OK;
    CJob *pJob;
    WCHAR wszName[MAX_PATH + 1];
    WCHAR wszID[SCH_SMBUF_LEN];

    hr = AddAtJobCommon(At, pID, &pJob, wszName, MAX_PATH + 1, wszID);

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJob: AddAtJobCommon", hr);
        return hr;
    }

    //
    // Free the job object.
    //
    pJob->Release();

    //
    // Return the new job's ID and increment the ID counter
    //
    if (pID != NULL)
    {
        *pID = m_dwNextID;
    }

    hr = IncrementAndSaveID();

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   IsMonthBitSet
//
//  Synopsis:   Returns nonzero if 1-based bit [wDay] in [dwDaysOfMonth] is
//              set.
//
//  History:    09-26-96   DavidMun   Created
//
//----------------------------------------------------------------------------

inline BOOL
IsMonthBitSet(DWORD dwDaysOfMonth, WORD wDay)
{
    return dwDaysOfMonth & (1 << (wDay - 1));
}




//+---------------------------------------------------------------------------
//
//  Function:   CalcDomTriggerDates
//
//  Synopsis:   Calculate the dates for the start and end of the Day Of Month
//              trigger(s).
//
//  Arguments:  [dwDaysOfMonth] - bit array, bit 0=day 1, etc.  At least one
//                                  bit must be set!
//              [stNow]         - current time
//              [stStart]       - same as [stNow] but has hour & minute
//                                  values of actual job run time
//              [pstStart1]     - filled with start date of first trigger
//              [pstEnd1]       - filled with end date of first trigger
//              [pstStart2]     - filled with start date of second trigger;
//                                  wDay is 0 if second trigger not needed
//              [pstEnd2]       - filled with end date of second trigger,
//                                  wDay is 0 if second trigger not needed
//
//  Modifies:   All output arguments.
//
//  History:    09-26-96   DavidMun   Created
//
//  Notes:      Only the month, day, and year values in the output structs
//              are used.
//
//----------------------------------------------------------------------------

VOID
CalcDomTriggerDates(
          DWORD       dwDaysOfMonth,
    const SYSTEMTIME &stNow,
    const SYSTEMTIME &stStart,
          SYSTEMTIME *pstStart1,
          SYSTEMTIME *pstEnd1,
          SYSTEMTIME *pstStart2,
          SYSTEMTIME *pstEnd2)
{
    BOOL fDone = FALSE;
    WORD wStart1MonthDays;

    // assert not all bits below 32 are zero
    Win4Assert(dwDaysOfMonth & JOB_RGFDAYS_MAX);

    //
    // Find the start date for the first DOM trigger.
    //

    *pstStart1 = stNow;

    if (IsFirstTimeEarlier(&stStart, &stNow))
    {
        // already past run time today

        IncrementDay(pstStart1);
    }

    HRESULT hr = MonthDays(pstStart1->wMonth, pstStart1->wYear, &wStart1MonthDays);
    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
        return;
    }

    do
    {
        while (!IsMonthBitSet(dwDaysOfMonth, pstStart1->wDay) &&
                pstStart1->wDay <= wStart1MonthDays)
        {
           pstStart1->wDay++;
        }

        //
        // now either:
        // start1.wDay > wStart1MonthDays or
        // bit at start1.wDay is 1
        //

        if (pstStart1->wDay > wStart1MonthDays)
        {
            // have to go on to next month to get the first start date

            pstStart1->wDay = 1;
            IncrementMonth(pstStart1);
            MonthDays(pstStart1->wMonth, pstStart1->wYear, &wStart1MonthDays);
        }
        else
        {
            fDone = TRUE;
        }
    } while (!fDone);


    //
    // Now bit at pstStart1->wDay is on, and pstStart1->wDay is a valid day in
    // pstStart1->wMonth, and wStart1MonthDays is the number of days in the
    // month pstStart1->wMonth.  Next we need to find end1.
    //
    // end1 is initialized to start1.
    //
    // If there are any days set before the start day, then end1.wMonth will
    // be start1.wMonth + 1, and end1.wDay will be the last of the days that
    // is set before start1.wDay, with the restriction that end1.wDay is not
    // greater than the number of days in end1.wMonth.
    //

    *pstEnd1 = *pstStart1;
    WORD wDay;

    if (pstStart1->wDay > 1)
    {
        WORD wEnd1Month;
        WORD wEnd1MonthDays;

        wEnd1Month = pstEnd1->wMonth + 1;

        if (wEnd1Month > 12)
        {
            wEnd1Month = 1;
        }

        MonthDays(wEnd1Month, pstEnd1->wYear, &wEnd1MonthDays);
        WORD wMaxDay = min(pstStart1->wDay - 1, wEnd1MonthDays);

        for (wDay = 1; wDay <= wMaxDay; wDay++)
        {
            if (IsMonthBitSet(dwDaysOfMonth, wDay))
            {
                pstEnd1->wDay = wDay;
            }
        }
    }

    //
    // If any day bits were set before start1.wDay then end1.wDay will no
    // longer == start1.wDay, and end1 will be referring to the next month.
    //
    // Otherwise, End1 will remain in the same month as Start1, but will
    // need to be set to the last day bit set in the Start1 month.
    //

    if (pstEnd1->wDay < pstStart1->wDay)
    {
        IncrementMonth(pstEnd1);
    }
    else
    {
        for (wDay = pstStart1->wDay + 1; wDay <= wStart1MonthDays; wDay++)
        {
            if (IsMonthBitSet(dwDaysOfMonth, wDay))
            {
                pstEnd1->wDay = wDay;
            }
        }
    }

    //
    // Now start1 and end1 are set.  next, check if there's a need for the
    // second trigger.  There are two cases where a second trigger is
    // required.
    //
    // Case a: second trigger must fill time between end of first trigger
    // and start of first trigger.  for example, job is to run on next
    // 1, 30, 31 and start1 is 1/31.  then end1 will be 2/1, and a second
    // trigger must go from 3/30 to 3/30.   Note this case can only occur
    // if End1.wMonth == February.
    //
    // Case b: second trigger must fill time somewhere in the 29-31 day range.
    // For example, job is to run on next 1-31, and current day is 4/1.  so
    // start1 is 4/1, end1 is 4/30, then start2 must be 5/31 to 5/31.
    //
    // As another example, job is to run on next 27, 28, 30, current day is
    // 2/28.  then start1 is 2/28, end1 is 3/27, start2 is 3/30, end2 is 3/30.
    //
    // Case b only occurs when there are bits set for days beyond the last day
    // of pstStart1->wmonth.
    //
    //

    //
    // test if we need case a.
    //

    if (pstEnd1->wMonth == 2 &&
        pstStart1->wDay > 29 &&
        pstEnd1->wDay < pstStart1->wDay - 1)
    {
        //
        // There's a gap between end1 and start1.  we need the second trigger
        // if there are any day bits set in that gap.
        //

        Win4Assert(pstStart1->wMonth == 1);
        Win4Assert(pstEnd1->wDay + 1 <= 30);

        *pstStart2 = *pstEnd1;
        pstStart2->wMonth = 3;
        *pstEnd2 = *pstStart2;

        SetDomTrigger2Days(dwDaysOfMonth,
                           pstEnd1->wDay + 1,
                           pstStart1->wDay - 1,
                           pstStart2,
                           pstEnd2);
    }
    else if (wStart1MonthDays < 31)
    {
        //
        // we have case b if any bits after the last day in pstStart1->wMonth
        // are set.
        //

        *pstStart2 = *pstEnd1;
        if (pstEnd1->wMonth == pstStart1->wMonth)
        {
            pstStart2->wMonth++;
        }
        *pstEnd2 = *pstStart2;

        SetDomTrigger2Days(dwDaysOfMonth,
                           wStart1MonthDays + 1,
                           31,
                           pstStart2,
                           pstEnd2);
    }
    else
    {
        // no second trigger

        pstStart2->wDay = 0;
        pstEnd2->wDay = 0;
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   SetDomTrigger2Days
//
//  Synopsis:   Set the start and end dates for the second DOM trigger.
//
//  Arguments:  [dwDaysOfMonth]    - bit array, bit 0=day 1, etc.  At least
//                                     one bit must be set!
//              [wFirstDayToCheck] - 1 based
//              [wLastDayToCheck]  - 1 based, must be >= [wFirstDayToCheck]
//              [pstStart2]        - filled with start date of second
//                                    trigger; wDay is 0 if no second
//                                    trigger is required.
//              [pstEnd2]          - filled with end date of second trigger;
//                                    wDay is 0 if no second trigger is
//                                    required.
//
//  Modifies:   All out args.
//
//  History:    09-26-96   DavidMun   Created
//
//  Notes:      This is a helper function called only by
//              CalcDomTriggerDates.
//
//----------------------------------------------------------------------------

VOID
SetDomTrigger2Days(
    DWORD dwDaysOfMonth,
    WORD wFirstDayToCheck,
    WORD wLastDayToCheck,
    SYSTEMTIME *pstStart2,
    SYSTEMTIME *pstEnd2)
{
    WORD wDay;

    pstStart2->wDay = 0;
    pstEnd2->wDay = 0;

    for (wDay = wFirstDayToCheck; wDay <= wLastDayToCheck; wDay++)
    {
        if (IsMonthBitSet(dwDaysOfMonth, wDay))
        {
            //
            // if the start of the second trigger hasn't been assigned
            // yet, assign it.  otherwise update the end of the second
            // trigger to the current day.
            //

            if (!pstStart2->wDay)
            {
                pstStart2->wDay = wDay;
            }
            else
            {
                pstEnd2->wDay = wDay;
            }
        }
    }

    //
    // there may have been only one day on in the gap, so the start and
    // end of trigger 2 are the same day.
    //

    if (pstStart2->wDay && !pstEnd2->wDay)
    {
        pstEnd2->wDay = pstStart2->wDay;
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   CalcDowTriggerDate
//
//  Synopsis:   Set the start and end dates for the Day of Week trigger.
//
//  Arguments:  [stNow]    - Current time
//              [stStart]  - same as [stNow] but with hour and minute of
//                            actual run time
//              [pstStart] - filled with start date
//              [pstEnd]   - filled with end date
//
//  Modifies:   *[pstStart], *[pstEnd]
//
//  History:    09-26-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
CalcDowTriggerDate(
    const SYSTEMTIME &stNow,
    const SYSTEMTIME &stStart,
          SYSTEMTIME *pstStart,
          SYSTEMTIME *pstEnd)
{
    *pstStart = stNow;

    //
    // If it's too late for the job to run today, make the start date
    // tomorrow.
    //

    if (IsFirstTimeEarlier(&stStart, &stNow))
    {
        IncrementDay(pstStart);
    }

    //
    // Make the end date 6 days later than the start date, that way we cover a
    // full week and all runs will happen.
    //

    *pstEnd = *pstStart;
    pstEnd->wDay += 6;

    WORD wLastDay;
    HRESULT hr = MonthDays(pstEnd->wMonth, pstEnd->wYear, &wLastDay);

    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
    }
    else
    {
        if (pstEnd->wDay > wLastDay)
        {
            //
            // Wrap to the next month.
            //
            pstEnd->wDay -= wLastDay;
            IncrementMonth(pstEnd);
        }
    }
}




//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::GetAtJob, private
//
//  Synopsis:   retrieves a downlevel job's AT info
//
//  Arguments:  [pwszFileName] - job object's file name
//              [pAt]          - pointer to an AT_INFO struct
//              [pwszCommand]  - buffer for the command string
//              [pcchCommand]  - on input, size of supplied buffer, on output,
//                               size needed if supplied buffer is too small.
//
//  Returns:    HRESULTS - ERROR_INSUFFICIENT_BUFFER if too small
//                       - SCHED_E_NOT_AN_AT_JOB if not an AT job
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::GetAtJob(LPCTSTR pwszFileName, AT_INFO * pAt, LPWSTR pwszCommand,
                    DWORD * pcchCommand)
{
    TRACE(CSchedule, GetAtJob);

    CJob * pJob = CJob::Create();

    if (pJob == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pJob->LoadP(pwszFileName, 0, TRUE, TRUE);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtJob: LoadP", hr);
        pJob->Release();
        return hr;
    }

    hr = pJob->GetAtInfo(pAt, pwszCommand, pcchCommand);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtJob: GetAtInfo", hr);
        pJob->Release();
        return hr;
    }

    pJob->Release();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IncrementAndSaveID
//
//  Synopsis:   Increment the NextJobID value and save it to the registry.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::IncrementAndSaveID(void)
{
    EnterCriticalSection(&m_CriticalSection);
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0, KEY_SET_VALUE,
                        &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        LeaveCriticalSection(&m_CriticalSection);
        return(HRESULT_FROM_WIN32(lErr));
    }

    m_dwNextID++;

    //
    // update the registry entry
    //
    lErr = RegSetValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, 0, REG_DWORD,
                         (CONST BYTE *)&m_dwNextID, sizeof(DWORD));
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("Create of NextAtJobId registry value", lErr);
        m_dwNextID--;
        RegCloseKey(hSchedKey);
        LeaveCriticalSection(&m_CriticalSection);
        return(HRESULT_FROM_WIN32(lErr));
    }
    RegCloseKey(hSchedKey);
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ResetAtID
//
//  Synopsis:   Set the next at id value in the registry to 1
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::ResetAtID(void)
{
    HRESULT hr = S_OK;
    HKEY    hSchedKey = NULL;

    EnterCriticalSection(&m_CriticalSection);

    m_dwNextID = 1;

    do
    {
        LONG lErr;

        //
        // Open the schedule service key
        //

        lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SCH_SVC_KEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hSchedKey);

        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
            hr = HRESULT_FROM_WIN32(lErr);
            break;
        }

        //
        // Set the next At Job ID value to 1.  If the value is not present,
        // it will be created.
        //

        lErr = RegSetValueEx(hSchedKey,
                             SCH_NEXTATJOBID_VALUE,
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &m_dwNextID,
                             sizeof(m_dwNextID));

        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Create of NextAtJobId registry value", lErr);
            hr = HRESULT_FROM_WIN32(lErr);
        }
    } while (0);

    if (hSchedKey)
    {
        RegCloseKey(hSchedKey);
    }
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}




//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::_AtTaskExists, private
//
//  Synopsis:   Check for existing AT tasks
//
//  Returns:    S_OK    - an AT task was found
//              S_FALSE - no AT tasks were found
//              E_*
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::_AtTaskExists(void)
{
    WIN32_FIND_DATA fd;
    HANDLE          hFileFindContext;

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        return S_FALSE;
    }

    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_FALSE;
    DWORD   rgFlags;

    do
    {
        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        HRESULT hrLoad = LoadAtJob(pJob, fd.cFileName);

        if (FAILED(hrLoad))
        {
            hr = hrLoad;
            break;
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            hr = S_OK;
            break;
        }
    } while (FindNextFile(hFileFindContext, &fd));

    FindClose(hFileFindContext);
    pJob->Release();

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::InitAtID
//
//  Synopsis:   Obtains the current AT task ID from the registry.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::InitAtID(void)
{
    //
    // Open the schedule service key
    //
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0,
                        KEY_READ | KEY_WRITE, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        return(HRESULT_FROM_WIN32(lErr));
    }

    //
    // Get the next At Job ID
    //
    DWORD cb = sizeof(DWORD);
    lErr = RegQueryValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, NULL, NULL,
                           (LPBYTE)&m_dwNextID, &cb);
    if (lErr != ERROR_SUCCESS)
    {
        if (lErr != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("Read of NextAtJobId registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }

        //
        // Scan AT jobs for value if registry entry absent
        //
        GetNextAtID(&m_dwNextID);

        //
        // Create registry entry
        //
        lErr = RegSetValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, 0, REG_DWORD,
                             (CONST BYTE *)&m_dwNextID, sizeof(DWORD));
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Create of NextAtJobId registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }
    }

    RegCloseKey(hSchedKey);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedule\sch_itf.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_itf.cxx
//
//  Contents:   job scheduler service interface impementation
//
//  Classes:    CSchedule
//
//  Interfaces: ITaskScheduler
//
//  History:    08-Sep-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"
#include <FolderSecurity.h>

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::GetTargetComputer, public
//
//  Synopsis:   Returns the name of the machine towards which the interface is
//              currently targetted.
//
//  Arguments:  [ppwszComputer] - the returned buffer with the machine name
//
//  Returns:    hresults
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::GetTargetComputer(LPWSTR * ppwszComputer)
{
    TRACE(CSchedule, GetTargetComputer);

    if (!ppwszComputer)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    DWORD   cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR   tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 3] = TEXT("\\\\");
    TCHAR * ptszTargetMachine;
    WCHAR * pwszTargetMachine;

    if (m_ptszTargetMachine)
    {
        ptszTargetMachine = m_ptszTargetMachine;
        cch = lstrlen(ptszTargetMachine) + 1;
    }
    else    // A NULL m_ptszTargetMachine means that we are targetted locally
    {
        if (!GetComputerName(tszLocalName + 2, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetTargetComputer: GetComputerName", hr);
            return hr;
        }

        ptszTargetMachine = tszLocalName;
        cch += 3;   // 2 for the leading slashes + 1 for the NULL
    }

    pwszTargetMachine = ptszTargetMachine;

    *ppwszComputer = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));

    if (*ppwszComputer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr = StringCchCopy(*ppwszComputer, cch, pwszTargetMachine)))
    {
        return hr;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::SetTargetComputer, public
//
//  Synopsis:   Sets the machine towards which subsequent ITaskScheduler
//              calls will be directed
//
//  Arguments:  [pwszComputer] - the machine name string
//
//  Returns:    hresults
//
//  Notes:      The string is Caller allocated and freed. The machine name
//              must include two leading backslashes.
//              The caller may indicate using the local machine in one of two
//              ways: by setting pwszComputer to NULL or to the UNC name of the
//              local machine.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::SetTargetComputer(LPCWSTR pwszComputer)
{
    TRACE(CSchedule, SetTargetComputer);
    HRESULT hr;
    DWORD cch;
    BOOL fLocal = FALSE;
    //
    // Parameter validation. A null param means to target the local computer.
    //
    if (!pwszComputer)
    {
        fLocal = TRUE;
    }

    LPCTSTR tszPassedInName = pwszComputer;
    if (!fLocal)
    {
        //
        // Get the local machine name to compare with that passed in.
        //
        TCHAR tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 1];
        cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerName(tszLocalName, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("SetTargetComputer: GetComputerName", hr);
            return hr;
        }

        TCHAR tszFQDN[SA_MAX_COMPUTERNAME_LENGTH + 1];
        cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, tszFQDN, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("SetTargetComputer: GetComputerNameEx", hr);
            return hr;
        }

        //
        // skip over first two characters ("\\") of tszPassedInName when comparing
        //
        fLocal = (lstrcmpi(tszPassedInName + 2, tszLocalName) == 0) ||
                 (lstrcmpi(tszPassedInName + 2, tszFQDN) == 0);
    }

    //
    // If targeted remotely, get the folder path out of that machine's
    // registry.
    //
    TCHAR tszFolderPath[MAX_PATH + 1];
    if (!fLocal)
    {
        //
        // Open the remote registry.
        //
        long lErr;
        HKEY hRemoteKey, hSchedKey;

        lErr = RegConnectRegistry(tszPassedInName, HKEY_LOCAL_MACHINE,
                                  &hRemoteKey);
        if (lErr != ERROR_SUCCESS)
        {
            schDebugOut((DEB_ERROR, "SetTargetComputer: RegConnectRegistry "
                         "failed with error %ld\n",
                         lErr));
            return(HRESULT_FROM_WIN32(lErr));
        }

        lErr = RegOpenKeyEx(hRemoteKey, SCH_AGENT_KEY, 0, KEY_READ,
                            &hSchedKey);
        if (lErr != ERROR_SUCCESS)
        {
            RegCloseKey(hRemoteKey);

            if (lErr == ERROR_BADKEY || lErr == ERROR_FILE_NOT_FOUND)
            {
                return SCHED_E_SERVICE_NOT_INSTALLED;
            }

            schDebugOut((DEB_ERROR, "SetTargetComputer: RegOpenKeyEx "
                         "of Scheduler key failed with error %ld\n",
                         lErr));
            return HRESULT_FROM_WIN32(lErr);
        }
        //
        // Get the jobs folder location from the remote registry.
        //
        DWORD cb = (MAX_PATH + 1) * sizeof(TCHAR);
        TCHAR tszRegFolderValue[MAX_PATH + 1];
        lErr = RegQueryValueEx(hSchedKey, SCH_FOLDER_VALUE, NULL, NULL,
                               (LPBYTE)tszRegFolderValue, &cb);
        if (lErr != ERROR_SUCCESS)
        {
            // use default if value absent
            StringCchCopy(tszRegFolderValue, MAX_PATH + 1, TEXT("%SystemRoot%\\Tasks"));
        }
        RegCloseKey(hSchedKey);

        //
        // BUGBUG: temporary code to expand %SystemRoot% or %WinDir%
        // The installer will have to write a full path to the registry 'cause
        // expanding arbitrary environment strings remotely is too much work.
        //
        cch = ARRAY_LEN("%SystemRoot%") - 1;
        if (_tcsncicmp(tszRegFolderValue, TEXT("%SystemRoot%"), cch) != 0)
        {
            cch = ARRAY_LEN("%WinDir%") - 1;
            if (_tcsncicmp(tszRegFolderValue, TEXT("%WinDir%"), cch) != 0)
            {
                cch = 0;
            }
        }

        if (cch != 0)
        {
            HKEY hCurVerKey;
            lErr = RegOpenKeyEx(hRemoteKey,
                        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                                0, KEY_ALL_ACCESS,
                                &hCurVerKey);
            if (lErr != ERROR_SUCCESS)
            {
                RegCloseKey(hRemoteKey);
                schDebugOut((DEB_ERROR, "SetTargetComputer: RegOpenKeyEx "
                             "of CurrentVersion key failed with error %ld\n",
                             lErr));
                return HRESULT_FROM_WIN32(lErr);
            }
            TCHAR tszSystemRoot[MAX_PATH + 1];
            cb = (MAX_PATH + 1) * sizeof(TCHAR);
            lErr = RegQueryValueEx(hCurVerKey, TEXT("SystemRoot"), NULL, NULL,
                                   (LPBYTE)tszSystemRoot, &cb);
            if (lErr != ERROR_SUCCESS)
            {
                RegCloseKey(hCurVerKey);
                RegCloseKey(hRemoteKey);
                schDebugOut((DEB_ERROR, "SetTargetComputer: RegQueryValueEx "
                             "of CurrentVersion key failed with error %ld\n",
                             lErr));
                return HRESULT_FROM_WIN32(lErr);
            }
            RegCloseKey(hCurVerKey);
            StringCchCopy(tszFolderPath, MAX_PATH + 1, tszSystemRoot);
            StringCchCat(tszFolderPath, MAX_PATH + 1, tszRegFolderValue + cch);
        }
        else
        {
            StringCchCopy(tszFolderPath, MAX_PATH + 1, tszRegFolderValue);
        }
        //
        // end of temporary code to expand %SystemRoot%
        //

        RegCloseKey(hRemoteKey);

        //
        // Check the folder path for being a fully qualified path name where
        // the first char is the drive designator and the second char is a
        // colon.
        //
        if (!s_isDriveLetter(tszFolderPath[0]) || tszFolderPath[1] != TEXT(':'))
        {
            ERR_OUT("SetTargetComputer: registry path", ERROR_BAD_PATHNAME);
            return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }
        //
        // The UNC path to the job folder will be the result of concatonating
        // the machine name and the expanded folder path. The drive designator
        // in the folder path will be turned in an administrative share name
        // by replacing the colon with a dollar sign and will look like:
        //   \\machine\c$\windir\jobs
        // so that the count below includes the slash trailing the machine name
        // plus the terminating null.
        //
        cch = lstrlen(tszPassedInName) + 1 + lstrlen(tszFolderPath) + 1;
    }
    else // Targetted locally.
    {
        //
        // Use the local path. Include one for the null terminator.
        //
        cch = lstrlen(g_TasksFolderInfo.ptszPath) + 1;
    }

    //
    // Allocate the ITaskScheduler folder path string buffer.
    //
    size_t cchPathBuf = cch;
    TCHAR * ptszPathBuf = new TCHAR[cchPathBuf];
    if (!ptszPathBuf)
    {
        ERR_OUT("SetTargetComputer: Job folder path buffer allocation",
                E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Allocate the ITaskScheduler machine name string buffer.
    //
    size_t cchTargetMachine = 0;
    TCHAR * ptszTargetMachine;
    if (!fLocal)
    {
        cchTargetMachine = lstrlen(tszPassedInName) + 1;
        ptszTargetMachine = new TCHAR[cchTargetMachine];
        if (!ptszTargetMachine)
        {
            ERR_OUT("CSchedule::SetTargetComputer", E_OUTOFMEMORY);
            delete ptszPathBuf;
            return E_OUTOFMEMORY;
        }
    }

    //
    // Now that all failable operation have completed sucessfully, we can
    // update the machine name and folder path members.
    //

    if (m_ptszTargetMachine)
    {
        delete m_ptszTargetMachine;
    }

    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }

    //
    // Save the new machine name.
    //

    if (fLocal)
    {
        //
        // If we are targetted locally, the machine name member is set to
        // NULL.
        //
        m_ptszTargetMachine = NULL;
    }
    else
    {
        m_ptszTargetMachine = ptszTargetMachine;
        StringCchCopy(m_ptszTargetMachine, cchTargetMachine, tszPassedInName);
    }

    //
    // Save the folder path name.
    //

    m_ptszFolderPath = ptszPathBuf;

    if (fLocal)
    {
        StringCchCopy(m_ptszFolderPath, cchPathBuf, g_TasksFolderInfo.ptszPath);
    }
    else
    {
        //
        // Convert the folder location to an UNC path.
        //
        // Turn the drive designator into the admin share by replacing the
        // colon with the dollar sign.
        //
        tszFolderPath[1] = TEXT('$');
        //
        // Compose the UNC path.
        //
        StringCchCopy(m_ptszFolderPath, cchPathBuf, tszPassedInName);
        StringCchCat(m_ptszFolderPath, cchPathBuf, TEXT("\\"));
        StringCchCat(m_ptszFolderPath, cchPathBuf, tszFolderPath);
    }

    // Now that we have the folder name, check for access
    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if (fLocal && FAILED(hr = CoFolderAccessCheck(m_ptszFolderPath, FILE_READ_DATA)))
    {        
        // set back to local machine.
        delete[] m_ptszTargetMachine;
        m_ptszTargetMachine = NULL;

        // set back to something resembling a default state
        Init();

        return hr;
    }

    schDebugOut((DEB_ITRACE,
                 "SetTargetComputer: path to sched folder: \"" FMT_TSTR "\"\n",
                 m_ptszFolderPath));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::EnumInternal, public
//              (public member in class for internal use, not public via API)
//
//  Synopsis:   Returns a job/queue object enumerator.
//              only difference between this and the COM version is that
//              this function checks access against the thread/process token
//              rather than the COM call context
//
//  Arguments:  [ppEnumJobs] - a place to return a pointer to the enumerator
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::EnumInternal(IEnumWorkItems ** ppEnumJobs)
{
    TRACE(CSchedule, Enum);
    HRESULT hr;

    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if ((NULL == m_ptszTargetMachine) && FAILED(hr = FolderAccessCheckOnThreadToken(m_ptszFolderPath, FILE_READ_DATA)))
        return hr;

    CEnumJobs * pEnumJobs = new CEnumJobs;
    if (pEnumJobs == NULL)
    {
        *ppEnumJobs = NULL;
        return E_OUTOFMEMORY;
    }

    hr = pEnumJobs->Init(m_ptszFolderPath);
    if (FAILED(hr))
    {
        delete pEnumJobs;
        *ppEnumJobs = NULL;
    }

    *ppEnumJobs = pEnumJobs;

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Enum, public
//
//  Synopsis:   Returns a job/queue object enumerator.
//
//  Arguments:  [ppEnumJobs] - a place to return a pointer to the enumerator
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Enum(IEnumWorkItems ** ppEnumJobs)
{
    TRACE(CSchedule, Enum);
    HRESULT hr;

    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if ((NULL == m_ptszTargetMachine) && FAILED(hr = CoFolderAccessCheck(m_ptszFolderPath, FILE_READ_DATA)))
        return hr;

    if (!ppEnumJobs)
    {
        return E_INVALIDARG;
    }
    

    CEnumJobs * pEnumJobs = new CEnumJobs;
    if (pEnumJobs == NULL)
    {
        *ppEnumJobs = NULL;
        return E_OUTOFMEMORY;
    }

    hr = pEnumJobs->Init(m_ptszFolderPath);
    if (FAILED(hr))
    {
        delete pEnumJobs;
        *ppEnumJobs = NULL;
    }

    *ppEnumJobs = pEnumJobs;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::NewWorkItem, public
//
//  Synopsis:   Create a new job object.
//
//  Arguments:  [pwszJobName] - the name of the new job *REQUIRED*
//              [riid] - the interface desired
//              [ppunk] - a place to return a pointer to the new job object
//
//  Returns:    hresults
//
//  Notes:      ppwszJobName is caller allocated and freed. The CJob::Save
//              method will copy it before returning. The job name must conform
//              to NT file naming conventions but must not include
//              [back]slashes because nesting within the job object folder is
//              not allowed.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::NewWorkItem(LPCWSTR pwszJobName, REFCLSID rclsid,
                       REFIID riid, IUnknown ** ppunk)
{
    TRACE(CSchedule, NewWorkItem);
    HRESULT hr;

    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if ((NULL == m_ptszTargetMachine) && FAILED(hr = CoFolderAccessCheck(m_ptszFolderPath, FILE_WRITE_DATA)))
        return hr;

    if (!pwszJobName)
    {
        return E_INVALIDARG;
    }
    if (!ppunk)
    {
        return E_INVALIDARG;
    }

    *ppunk = NULL;

    if (!IsEqualCLSID(rclsid, CLSID_CTask))
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    TCHAR * ptszFullName;
    HANDLE hFile;

    hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::NewWorkItem: CheckJobName", hr);
        return hr;
    }

    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        delete [] ptszFullName;
        return E_OUTOFMEMORY;
    }

    //
    // Do the QI before the CreateFile so that if the caller asks for a non-
    // supported interface, the failure will not result in disk operations.
    //
    hr = pJob->QueryInterface(riid, (void **)ppunk);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::NewWorkItem: QueryInterface(riid)", hr);
        goto CleanExit;
    }
    // the above QI increased the refcount to 2, so set it back to 1
    pJob->Release();

    //
    // Per the spec for this method, the file must not already exist.
    //
    hFile = CreateFile(ptszFullName,
                       0,               // desired access: none
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        // share mode: all
                       NULL,            // security attributes
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            //
            // This is good.  Save the new filename.
            //
            pJob->m_ptszFileName = ptszFullName;
            return S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            ERR_OUT("CSchedule::NewWorkItem: CreateFile", hr);
        }
    }
    else
    {
        //
        // Opened successfully - the file exists
        //
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        ERR_OUT("CSchedule::NewWorkItem", hr);
    }

CleanExit:

    delete [] ptszFullName;
    delete pJob;    // on error, completely destroy the job object
    *ppunk = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::AddWorkItem, public
//
//  Synopsis:   Saves the job to the job scheduler folder.
//
//  Arguments:  [pwszJobName] - the name of the job *REQUIRED*
//              [pJob]        - pointer to the job object
//
//  Returns:    hresults
//
//  Notes:      Same job name conditions as above.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddWorkItem(LPCWSTR pwszJobName,
                       IScheduledWorkItem * pWorkItem)
{
    TRACE(CSchedule, AddWorkItem);
    HRESULT hr;

    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if ((NULL == m_ptszTargetMachine) && FAILED(hr = CoFolderAccessCheck(m_ptszFolderPath, FILE_WRITE_DATA)))
        return hr;
    
    if (!pwszJobName)
    {
        return E_INVALIDARG;
    }
    if (!pWorkItem)
    {
        return E_INVALIDARG;
    }
    
    TCHAR * ptszFullName;

    hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::AddWorkItem: CheckJobName", hr);
        return hr;
    }
    IPersistFile * pFile;

    hr = pWorkItem->QueryInterface(IID_IPersistFile, (void **)&pFile);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::AddWorkItem: QI(IPersistFile)", hr);
        delete [] ptszFullName;
        return hr;
    }

    WCHAR * pwszName;

    pwszName = ptszFullName;

    hr = pFile->Save(pwszName, TRUE);
    pFile->Release();
    delete [] ptszFullName;
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Delete, public
//
//  Synopsis:   Deletes the job/queue.
//
//  Arguments:  [pwszJobName] - indicates the job/queue to delete
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Delete(LPCWSTR pwszJobName)
{
    TRACE(CSchedule, Delete);

    HRESULT hr;

//    Let's not be redundant, here - 
//    if (FAILED(hr = CoFolderAccessCheck(m_ptszFolderPath, FILE_DELETE_CHILD)))
//        return hr;

    if (!pwszJobName)
    {
        return E_INVALIDARG;
    }

    TCHAR * ptszFullName;

    hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Delete: CheckJobName", hr);
        return hr;
    }

    if (!DeleteFile(ptszFullName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedule::Delete: DeleteFile", hr);
        delete ptszFullName;
        return hr;
    }
    delete ptszFullName;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Activate, public
//
//  Synopsis:   Given a valid name, returns a pointer to the activated job
//              object
//
//  Arguments:  [pwszName] - the name of the job to activate
//              [riid]     - the interface to return
//              [ppunk]    - a pointer to the job object interface
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Activate(LPCWSTR pwszName, REFIID riid, IUnknown ** ppunk)
{
    TRACE(CSchedule, Activate);

    if (!pwszName)
    {
        return E_INVALIDARG;
    }
    if (!ppunk)
    {
        return E_INVALIDARG;
    }
    
    TCHAR * ptszFullName;
    HRESULT hr = CheckJobName(pwszName, &ptszFullName);
    if (FAILED(hr))
    {
        *ppunk = NULL;
        return hr;
    }

    // only check in the remote case - access checks remotely don't always work
    // due to problems resolving groups local to remote machine
    // this is not a problem, access control will be enforced by the file system on the remote machine.
    if ((NULL == m_ptszTargetMachine) && FAILED(hr = CoFolderAccessCheck(ptszFullName, FILE_READ_DATA)))
    {        
        delete[] ptszFullName;
        return hr;
    }

    CJob * pJob;

    //
    // CJob is a single-use, in-proc handler, so no need to get OLE in the
    // loop here. Use new (called by CJob::Create) instead of CoCreateInstance.
    //
    pJob = CJob::Create();
    if (pJob == NULL)
    {
        *ppunk = NULL;
        delete [] ptszFullName;
        return E_OUTOFMEMORY;
    }

    hr = pJob->LoadP(ptszFullName, 0, TRUE, TRUE);

    delete [] ptszFullName;

    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Activate, Load", hr);
        *ppunk = NULL;
        pJob->Release();    // on error, completely release the job object
        return hr;
    }

    hr = pJob->QueryInterface(riid, (void **)ppunk);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Activate: QueryInterface(riid)", hr);
        *ppunk = NULL;
        pJob->Release();    // on error, completely release the job object
        return hr;
    }

    //
    // The above QI increased the refcount to 2, so set it back to 1.
    //
    pJob->Release();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::IsOfType, public
//
//  Synopsis:   Does this object support the desired interface?
//
//  Arguments:  [pwszName] - indicates the object name
//              [riid] - indicates the interface of interest, typically
//                  IID_ITask or IID_IScheduledQueue
//
//  Returns:    S_OK if it is, S_FALSE otherwise.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::IsOfType(LPCWSTR pwszName, REFIID riid)
{
    TRACE(CSchedule, IsOfType);

    // CODEWORK: A heavyweight implementation for now.  It could possibly
    // be optimized by doing the QueryInterface before the LoadP, and
    // doing a lightweight LoadP.

    if (!pwszName)
    {
        return E_INVALIDARG;
    }

    IUnknown * punk;
    HRESULT hr = Activate(pwszName, riid, &punk);
    if (SUCCEEDED(hr))
    {
        punk->Release();
        hr = S_OK;
    }
    else
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA) ||
            hr == SCHED_E_UNKNOWN_OBJECT_VERSION ||
            hr == E_NOINTERFACE)
        {
            //
            // These errors mean that the object is definitely not of a
            // type that we support.  We translate them to S_FALSE.
            // Other errors could include file-not-found, access-denied,
            // invalid-arg, etc.  We return those errors unmodified.
            //
            hr = S_FALSE;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\sch_main.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_main.cxx
//
//  Contents:   job scheduler NT service entry point and thread launcher
//
//  History:    08-Sep-95 EricB created
//              03-Mar-01 JBenton - BUG 207402 RESUMESUSPEND and RESUMEAUTOMATIC
//                  events arrive out of the expected sequence on some hardware.
//                  This caused the internal POWER_RESUME event to be sent twice
//                  which sometimes (20%) prevented the scheduled job that 
//                  triggered the wake-up from running.
//
//-----------------------------------------------------------------------------

#include "..\..\pch\headers.hxx"
#pragma hdrstop
#include <globals.hxx>
#include <svc_core.hxx>
#include "..\..\inc\sadat.hxx"
#include "..\..\inc\resource.h"
#include "..\..\idletask\inc\idlesrv.h"

DECLARE_INFOLEVEL(Sched);

// globals
SERVICE_STATUS_HANDLE g_hStatus = NULL;
SERVICE_STATUS g_SvcStatus;         // BUGBUG guard with critsec, put in class
ATOM   g_aClass = 0;
HANDLE g_hWindowThread = NULL;
HWND   g_hwndSchedSvc = NULL;
LONG   g_fUserIsLoggedOn = FALSE;   // Whether a user is currently logged on
HANDLE g_WndEvent = NULL;
UINT   g_uTaskbarMessage = 0;
BOOL   g_fShuttingDown;

// local prototypes
void SchedStart(DWORD, LPWSTR *);
BOOL RunningAsLocalSystem(VOID);
HRESULT WindowMsgFcn(LPVOID pVoid);
LRESULT CALLBACK SchedWndProc(HWND, UINT, WPARAM, LPARAM);

// routine to run on the prefetcher service thread.

extern "C" DWORD WINAPI PfSvcMainThread(VOID *Param);

#define IDM_EXIT    100

extern "C"  void CALLBACK CloseProcEx(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

//+---------------------------------------------------------------------------
//
//  Function:   CloseProc
//
//  Synopsis:   Entry point used with RunDll32
//              closes down window via WM_CLOSE
//
//  Arguments:  [hwnd]        -- ignored
//              [hinst]       -- uninteresting
//              [nCmdShow]    -- boring
//              [lpszCmdLine] -- command line from invocation 
//
//  Notes:      command line should be proc id.
//              This is a straight passthrough to the implementation in procssr.cxx
//
//----------------------------------------------------------------------------
extern "C" void CALLBACK CloseProc(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    CloseProcEx(hwnd, hinst, lpszCmdLine, nCmdShow);
}

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
    {
        DisableThreadLibraryCalls (hInstance) ;
        if (CStaticCritSec::anyFailure())
            return FALSE;
    }
    
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   SchedServiceMain
//
//  Synopsis:   Entry point when running in an SvcHost.exe instance.
//
//  Arguments:  [CArgs]     - count of arg strings
//              [ppwszArgs] - array of arg strings
//
//-----------------------------------------------------------------------------
VOID
WINAPI
SchedServiceMain(DWORD cArgs, LPWSTR * ppwszArgs)
{
    //
    // We need to initialize g_hInstance here for OpenLogFile
    // to work.
    //
    g_hInstance = GetModuleHandle(SCH_SERVICE_DLL_NAME);

    //
    // Open the schedule service log file.
    //
    if (FAILED(OpenLogFile()))
    {
        return;
    }
   
    LogServiceEvent(IDS_LOG_SERVICE_STARTED);

    SchedStart(cArgs, ppwszArgs);

    LogServiceEvent(IDS_LOG_SERVICE_EXITED);

    //
    // Close the schedule service log.
    //
    CloseLogFile();
}

//+----------------------------------------------------------------------------
//
//  Function:   SchedStart
//
//  Synopsis:   Primary thread of the NT service
//
//  Arguments:  [CArgs]     - count of arg strings
//              [ppwszArgs] - array of arg strings
//
//-----------------------------------------------------------------------------
void
SchedStart(DWORD cArgs, LPWSTR * ppwszArgs)
{
    HANDLE  hPfSvcThread;
    HANDLE  hPfSvcStopEvent;
    DWORD   ErrorCode;
    BOOLEAN StartedIdleDetectionServer;

    HRESULT hr;

    //
    // initialize locals so we know what to cleanup.
    //

    hPfSvcStopEvent            = NULL;
    hPfSvcThread               = NULL;
    StartedIdleDetectionServer = FALSE;

    //
    // Initialize some globals.
    //

    if (!g_hInstance) {
        g_hInstance = GetModuleHandle(NULL);
    }

    g_fShuttingDown   = FALSE;
    g_hStatus         = NULL;
    g_hWindowThread   = NULL;
    g_hwndSchedSvc    = NULL;
    g_fUserIsLoggedOn = FALSE;
    g_WndEvent        = NULL;
    
    g_SvcStatus.dwServiceType      = SERVICE_WIN32_OWN_PROCESS;
    g_SvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                     SERVICE_ACCEPT_PAUSE_CONTINUE |
                                     SERVICE_ACCEPT_SHUTDOWN |
                                     SERVICE_ACCEPT_POWEREVENT;

    g_SvcStatus.dwWaitHint                = SCH_WAIT_HINT;
    g_SvcStatus.dwCheckPoint              = 1;
    g_SvcStatus.dwWin32ExitCode           = NO_ERROR;
    g_SvcStatus.dwServiceSpecificExitCode = 0;
    g_SvcStatus.dwCurrentState            = SERVICE_START_PENDING;

    //
    // Register the control handler.
    //
    g_hStatus = RegisterServiceCtrlHandlerEx(g_tszSrvcName,
                                             SchSvcHandler,
                                             NULL);

    if (g_hStatus == NULL)
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, GetLastError(), 0);
        ERR_OUT("RegisterServiceCtrlHandler", GetLastError());
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    UpdateStatus();

    //
    // Make sure the service is running as LocalSystem
    //
    if (!RunningAsLocalSystem())
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE,
                        HRESULT_FROM_WIN32(SCHED_E_SERVICE_NOT_LOCALSYSTEM),
                        0);

        SchStop(HRESULT_FROM_WIN32(SCHED_E_SERVICE_NOT_LOCALSYSTEM), FALSE);
        return;
    }

    //
    // Initialize the service.
    //
    hr = SchInit();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr, FALSE);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Get the ID of the logged on user, if there is one.
    //
    GetLoggedOnUser();

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Initialize NetSchedule API support code.
    //
    hr = InitializeNetScheduleApi();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Start the RPC server.
    //
    hr = StartRpcServer();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Create the window thread event.
    //
    g_WndEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (g_WndEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Create the window thread.
    //
    DWORD dwThreadID;
    g_hWindowThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)WindowMsgFcn,
                                   NULL,
                                   0,
                                   &dwThreadID);
    if (!g_hWindowThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("Creation of Window Thread", hr);
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);

        CloseHandle( g_WndEvent );
        g_WndEvent = NULL;

        return;
    }

    //
    // Initialize idle detection server. This must be done after we
    // start the other RPC servers that register a dynamic ncalrpc
    // endpoint.
    //

    ErrorCode = ItSrvInitialize();

    hr = HRESULT_FROM_WIN32(ErrorCode);

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    StartedIdleDetectionServer = TRUE;


    //
    // Initialize the event it is going to wait on and kick off the
    // prefetcher maintenance thread.
    //
    
    hPfSvcStopEvent = CreateEvent(NULL,    // no security attributes
                                  TRUE,    // manual reset event
                                  FALSE,   // not-signalled
                                  NULL);   // no name
    
    if (hPfSvcStopEvent) { 
        hPfSvcThread = CreateThread(0,0,PfSvcMainThread,&hPfSvcStopEvent,0,0); 
    }

    //
    // We're off and running.
    //
    g_SvcStatus.dwCurrentState = SERVICE_RUNNING;
    g_SvcStatus.dwCheckPoint   = 0;
    UpdateStatus();

    hr = g_pSched->InitialDirScan();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        goto Exit;
    }

    //
    // Update the service flag in SA.DAT to running.
    // Also redetermine whether the machine supports wakeup timers.  We do
    // this every time the service starts in order to work around problems
    // with IBM Thinkpads and VPOWERD on Windows 98.  (BUGBUG  Do we need
    // to do this on NT as well?)
    //
    // Note, this function should not fail. If it does, something is
    // seriously wrong with the system.
    //

    hr = SADatCreate(g_TasksFolderInfo.ptszPath);

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        goto Exit;
    }

    //
    // Call the main function.
    //

    hr = SchedMain(NULL);

    //
    // Exit.
    //

Exit:

    //
    // If one exists, signal prefetcher thread's stop event and wait
    // for it to terminate.
    //
    
    if (hPfSvcStopEvent && hPfSvcThread) {
        SetEvent(hPfSvcStopEvent);
        WaitForSingleObject(hPfSvcThread, INFINITE);
    }

    if (hPfSvcStopEvent) {
        CloseHandle(hPfSvcStopEvent);
    }

    if (hPfSvcThread) {
        CloseHandle(hPfSvcThread);
    }

    HANDLE  rghWaitArray[2] = { g_WndEvent, g_hWindowThread };

    DBG_OUT("Service exit -- waiting for window thread to finish starting.");

    if (WaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE) == WAIT_OBJECT_0)
    {
        //
        // g_WndEvent was signalled -- we can now send a message
        // to the window thread to tell it to shut down
        //
        g_fShuttingDown = TRUE;
        SendMessage(g_hwndSchedSvc, WM_COMMAND, IDM_EXIT, 0);

        //
        // Wait for window thread to exit before exitting the main thread.
        // This is to ensure that the task bar icon is removed. The wait is
        // probably not needed since the SendMessage exit processing looks
        // like it is completely syncronous.
        //

        DBG_OUT("Waiting for window thread to exit.");
        WaitForSingleObject(g_hWindowThread, INFINITE);
        DBG_OUT("Window thread exited.");
    }
    else
    {
        DBG_OUT("Window thread exited prematurely -- shutting down.");
    }

    //
    // Stop idle detection server.
    //
    
    if (StartedIdleDetectionServer) {
        ItSrvUninitialize();
    }

    //
    // Cleanup some globals.
    //

    if (g_fUserIsLoggedOn) {
        LogonSessionDataCleanup();
        g_fUserIsLoggedOn = FALSE;
    }

    if (g_hWindowThread) {
        CloseHandle(g_hWindowThread);
        g_hWindowThread = NULL;
    }

    if (g_WndEvent) {
        CloseHandle(g_WndEvent);
        g_WndEvent = NULL;
    }

    SchStop(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   RunningAsLocalSystem
//
//  Synopsis:   Detects whether the service was started in the System account.
//
//  Arguments:  None
//
//  Returns:    TRUE  if the service is running as LocalSystem
//              FALSE if it is not or if any errors were encountered
//
//-----------------------------------------------------------------------------
BOOL
RunningAsLocalSystem(VOID)
{
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

    BOOL   fCheckSucceeded;
    BOOL   fIsLocalSystem = FALSE;

    fCheckSucceeded = CheckTokenMembership(NULL,
                                           &LocalSystemSid,
                                           &fIsLocalSystem);

    if (!fCheckSucceeded)
    {
        ERR_OUT("CheckTokenMembership", GetLastError());
    }

    return (fCheckSucceeded && fIsLocalSystem);
}


//+----------------------------------------------------------------------------
//
//  Function:   WindowMsgFcn
//
//  Synopsis:   Window message loop thread of the service.
//
//  Arguments:  [pVoid] - currently not used
//
//  Returns:    HRESULTS - the service is not currently detecting if this
//              thread exits prematurely. Thus, the exit code is ignored.
//              Monitoring the thread handle in SchedMain would give more
//              thorough error detection.
//-----------------------------------------------------------------------------
HRESULT
WindowMsgFcn(LPVOID pVoid)
{
    HRESULT hr = S_OK;

    //
    // Find out the ID of the message that the tray will send us when it
    // starts.
    //
    g_uTaskbarMessage = RegisterWindowMessage(TEXT("TaskbarCreated"));

    //
    // Register the window class
    //
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = SchedWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = SCHED_CLASS;

    g_aClass = RegisterClass(&wc);
    if (!g_aClass)
    {
        ULONG ulLastError = GetLastError();

        LogServiceError(IDS_NON_FATAL_ERROR, ulLastError, 0);
        ERR_OUT("RegisterClass", ulLastError);
        return HRESULT_FROM_WIN32(ulLastError);
    }

    //
    // Now create the hidden window on the interactive desktop.
    //
    g_hwndSchedSvc = CreateWindow(SCHED_CLASS, SCHED_TITLE, WS_OVERLAPPEDWINDOW,
                                  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                  CW_USEDEFAULT, (HWND)NULL, (HMENU)NULL,
                                  g_hInstance, (LPVOID)NULL);
    if (!g_hwndSchedSvc)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        ERR_OUT("CreateWindow", hr);
        return hr;
    }

    ShowWindow(g_hwndSchedSvc, SW_HIDE);
    UpdateWindow(g_hwndSchedSvc);

    //
    // Initialize this thread's keep-awake count.
    //

    InitThreadWakeCount();

    //
    // Initialize idle detection.  This must be done by the window thread
    // (not the state machine thread).
    //
    InitIdleDetection();

    //
    // Notify the main thread that the window creation is complete.
    //
    if (!SetEvent(g_WndEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        ERR_OUT("SetEvent(g_WndEvent)", hr);
        return hr;
    }

    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (g_aClass != 0)
    {
        DeleteAtom(g_aClass);
        g_aClass = 0;

        UnregisterClass(SCHED_CLASS, g_hInstance);
    }
    
    DBG_OUT("Window exited.");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchedWndProc
//
//  Synopsis:   handle messages
//
//  Returns:    occasionally
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
SchedWndProc(HWND hwndSched, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    switch (uMsg)
    {
    case WM_CREATE:
    case WM_SETTEXT:
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_EXIT:

            //
            // Only exit if this message was sent by the
            // Task Scheduler's shutdown code (vs. a user)
            //
            if (g_fShuttingDown)
            {
                DestroyWindow(hwndSched);
            }
            break;
        }

        break;

    case WM_TIMECHANGE:
        DBG_OUT("WM_TIMECHANGE received");
        if (g_pSched)
        {
            g_pSched->SubmitControl(SERVICE_CONTROL_TIME_CHANGED);
        }
        break;

    case WM_SCHED_SetNextIdleNotification:
        return SetNextIdleNotificationFn((WORD)wParam);

    case WM_SCHED_SetIdleLossNotification:
        return SetIdleLossNotificationFn();

    case WM_DESTROY:
        DBG_OUT("Got WM_DESTROY.");

        //
        // Only exit if this message was sent by the
        // Task Scheduler's shutdown code (vs. a user)
        //
        if (g_fShuttingDown)
        {
            EndIdleDetection();
            PostQuitMessage(0);
        }
        break;

    case WM_CLOSE:
    case WM_QUIT:

        //
        // If the Task Scheduler isn't shutting down, these
        // are malicious messages, so ignore them.  If the
        // Task Scheduler is shutting down, fall through and
        // let DefWindowProc handle these
        //
        if (!g_fShuttingDown)
        {
            break;
        }

        // Fall through

    default:
        if (uMsg == g_uTaskbarMessage)
        {
            schDebugOut((DEB_ITRACE,
                         "Got Taskbar message, calling SchSvcHandler.\n"));
            SchSvcHandler(SERVICE_CONTROL_USER_LOGON, 0, NULL, NULL);
            // CODEWORK: Is a non-zero return code expected from the wndproc?
        }
        else
        {
            return DefWindowProc(hwndSched, uMsg, wParam, lParam);
        }
    }
    return lResult;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchSvcHandler
//
//  Synopsis:   handles service controller callback notifications
//
//  Arguments:  [dwControl] - the control code
//
//-----------------------------------------------------------------------------
DWORD WINAPI
SchSvcHandler(
    DWORD   dwControl,
    DWORD   dwEventType,
    LPVOID  lpEventData,
    LPVOID  lpContext
    )
{
    static BOOL fResumeHandled;   // initially FALSE

    switch (dwControl)
    {
    case SERVICE_CONTROL_PAUSE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_PAUSE");
        if (g_SvcStatus.dwCurrentState == SERVICE_RUNNING ||
            g_SvcStatus.dwCurrentState == SERVICE_CONTINUE_PENDING)
        {
            g_SvcStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;

            g_pSched->SubmitControl(0);
            LogServiceEvent(IDS_LOG_SERVICE_PAUSED);
        }
        else
        {
            ERR_OUT("Trying to pause when service not running!", 0);
        }
        break;

    case SERVICE_CONTROL_CONTINUE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_CONTINUE");
        if (g_SvcStatus.dwCurrentState == SERVICE_PAUSED ||
            g_SvcStatus.dwCurrentState == SERVICE_PAUSE_PENDING)
        {
            g_SvcStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;

            g_pSched->SubmitControl(0);
            LogServiceEvent(IDS_LOG_SERVICE_CONTINUED);
        }
        else
        {
            ERR_OUT("Trying to continue when service not paused!", 0);
        }
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_SHUTDOWN");
    case SERVICE_CONTROL_STOP:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_STOP");
        g_SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_SvcStatus.dwWaitHint = SCH_WAIT_HINT;
        g_SvcStatus.dwCheckPoint = 1;

        UpdateStatus();

        g_pSched->SubmitControl(0);
        break;

    case SERVICE_CONTROL_USER_LOGON:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_USER_LOGON");
        //
        // (This could be called by the window-handling thread.)
        // The tray (or mstinit /logon) has notified us that it's started.
        // This usually happens because a user has logged on, but it also
        // happens when the tray crashes and restarts.  We must ignore the
        // notification in the latter case.
        //
        if (InterlockedExchange(&g_fUserIsLoggedOn, TRUE))
        {
            //
            // It wasn't really a user logon.  Ignore the control.
            //
            DBG_OUT("SchSvcHandler: User is already logged on");
            break;
        }

        //
        // Signal the main thread loop to run logon jobs.
        //
        g_pSched->SubmitControl(SERVICE_CONTROL_USER_LOGON);
        break;

    case SERVICE_CONTROL_USER_LOGOFF:

        schDebugOut((DEB_ITRACE, "User logging off *******************\n"));

        //
        // Dealloc & set to NULL the global data associated with the
        // user's logon session.
        //

        LogonSessionDataCleanup();

        g_fUserIsLoggedOn = FALSE;

        break;

    case SERVICE_CONTROL_INTERROGATE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_INTERROGATE");
        //
        // The interrogate is satisfied by the UpdateStatus call below.
        //
        break;

    case SERVICE_CONTROL_POWEREVENT:
        switch (dwEventType)
        {
        case PBT_APMPOWERSTATUSCHANGE:
            SYSTEM_POWER_STATUS PwrStatus;
            if (!GetSystemPowerStatus(&PwrStatus))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError(), 0);
                ERR_OUT("GetSystemPowerStatus", GetLastError());
                break;
            }
            if (PwrStatus.ACLineStatus == 0)
            {
                //
                // On battery.
                //
                OnPowerChange(TRUE);
            }
            else
            {
                if (PwrStatus.ACLineStatus == 1)
                {
                    //
                    // On AC power.
                    //
                    OnPowerChange(FALSE);
                }
            }
            break;

        case PBT_APMQUERYSUSPEND:
            //
            // The computer is preparing for suspended mode.
            // Signal the other thread to stop running jobs.
            //
            DBG_OUT("PBT_APMQUERYSUSPEND received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_SUSPEND);
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            //
            // Aborted going into suspended mode.
            // Signal the other thread to run the elapsed jobs.
            //
            DBG_OUT("PBT_APMQUERYSUSPENDFAILED received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_SUSPEND_FAILED);
            break;

        case PBT_APMSUSPEND:
            //
            // The computer is going into the suspended mode.
            // We already prepared for it when we got QUERYSUSPEND.
            // BUGBUG  We should wait here for the other thread to finish.
            //
            DBG_OUT("PBT_APMSUSPEND received, ignoring (already handled)");
            fResumeHandled = FALSE;
            break;


        //
        // PBT_APMRESUMExxx messages:
        // The computer is coming back from suspended mode.
        // Signal the other thread to run the appropriate jobs.
        //

        case PBT_APMRESUMESUSPEND:
            DBG_OUT("PBT_APMRESUMESUSPEND received");
            if (fResumeHandled)
            {
                DBG_OUT("IGNORING resumesuspend (sent after resumeautomatic)");
            }
            else
            {
                g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
                //
                // On some systems we see the RESUMESUSPEND message before
                // the RESUMEAUTOMATIC message. We don't want to signal the
				// main loop twice.  So set a flag telling us to ignore
				// RESUMEAUTOMATIC messages until a SUSPEND message is sent.
                //
                fResumeHandled = TRUE;
            }
            break;

        case PBT_APMRESUMECRITICAL:
            DBG_OUT("PBT_APMRESUMECRITICAL received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
            break;

        case PBT_APMRESUMEAUTOMATIC:
            DBG_OUT("PBT_APMRESUMEAUTOMATIC received");

            if (fResumeHandled)
            {
                DBG_OUT("IGNORING resumeautomatic (sent after resumeresume)");
			}
			else
			{
                g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
                //
                // After this RESUMEAUTOMATIC message, the system may also
                // send a RESUMESUSPEND message (if it detects user activity).
                // We don't want to signal the main loop twice.  So set a flag
                // telling us to ignore RESUMESUSPEND messages until a SUSPEND
                // message is sent.
                //
                fResumeHandled = TRUE;
			}

            break;
        }
        break;

    default:
        ERR_OUT("Unrecognized service control code", dwControl);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    UpdateStatus();

    return NO_ERROR;
}


//+----------------------------------------------------------------------------
//
//  Function:   CSchedWorker::HandleControl
//
//  Synopsis:   Handle NT service controller state changes.
//
//  Returns:    the control or the current/new state
//
//-----------------------------------------------------------------------------
DWORD
CSchedWorker::HandleControl()
{
    TRACE(CSchedWorker,HandleControl);

    DWORD dwControl = m_ControlQueue.GetEntry();

    switch (dwControl)
    {
    case SERVICE_CONTROL_USER_LOGON:
        schDebugOut((DEB_ITRACE, "  Event is USER_LOGON\n"));
        break;

    case SERVICE_CONTROL_POWER_SUSPEND:
        schDebugOut((DEB_ITRACE, "  Event is POWER_SUSPEND\n"));
        break;

    case SERVICE_CONTROL_POWER_SUSPEND_FAILED:
        schDebugOut((DEB_ITRACE, "  Event is POWER_SUSPEND_FAILED\n"));
        break;

    case SERVICE_CONTROL_POWER_RESUME:
        schDebugOut((DEB_ITRACE, "  Event is POWER_RESUME\n"));
        break;

    case SERVICE_CONTROL_TIME_CHANGED:
        schDebugOut((DEB_ITRACE, "  Event is TIME_CHANGED\n"));
        break;

    case 0:
        schDebugOut((DEB_ITRACE, "  Service Control is state %#lx\n",
                     g_SvcStatus.dwCurrentState));

        switch (g_SvcStatus.dwCurrentState)
        {
        case SERVICE_STOP_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for exit\n"));
            break;

        case SERVICE_PAUSE_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for pausing\n"));
            g_SvcStatus.dwCurrentState = SERVICE_PAUSED;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;
            UpdateStatus();
            break;

        case SERVICE_CONTINUE_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for continuing\n"));
            g_SvcStatus.dwCurrentState = SERVICE_RUNNING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;
            UpdateStatus();
            break;
        }
        return g_SvcStatus.dwCurrentState;

    default:
        schDebugOut((DEB_ITRACE, "  ??? UNKNOWN CONTROL %#lx\n", dwControl));
        break;
    }

    return dwControl;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetCurrentServiceState
//
//  Returns:    The schedule service's current state.
//
//-----------------------------------------------------------------------------
DWORD
GetCurrentServiceState(void)
{
    return g_SvcStatus.dwCurrentState;
}

//+----------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Tell the service controller what the current status is.
//
//  Returns:    Win32 error values
//
//-----------------------------------------------------------------------------
DWORD
UpdateStatus(void)
{
    TRACE_FUNCTION(UpdateStatus);

    DWORD dwRet = NO_ERROR;

    if (g_hStatus == NULL)
    {
        ERR_OUT("UpdateStatus called with a null status handle!", 0);
        return ERROR_INVALID_HANDLE;
    }

    if (!SetServiceStatus(g_hStatus, &g_SvcStatus))
    {
        dwRet = GetLastError();
        LogServiceError(IDS_NON_FATAL_ERROR, dwRet, 0);
        ERR_OUT("SetServiceStatus", dwRet);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchStop
//
//  Synopsis:   Shuts down the schedule service
//
//  Arguments:  [hr] - an error code if terminating abnormally
//
//-----------------------------------------------------------------------------
void
SchStop(HRESULT hr, BOOL fCoreCleanup)
{
    //
    // Update the service flag in SA.DAT to not running.
    // Check the folder path for NULL in case initialization failed.
    //

    if (g_TasksFolderInfo.ptszPath != NULL)
    {
        UpdateSADatServiceFlags(g_TasksFolderInfo.ptszPath,
                                SA_DAT_SVCFLAG_SVC_RUNNING,
                                TRUE);
    }

    g_SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    g_SvcStatus.dwCheckPoint++;

    UpdateStatus();

    //
    // do core cleanup
    //

    if (fCoreCleanup)
    {
        SchCleanup();
    }

    //
    // tell service controller that we are done cleaning up
    //

    if (FAILED(hr))
    {
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            g_SvcStatus.dwWin32ExitCode = HRESULT_CODE(hr);
        }
        else
        {
            g_SvcStatus.dwWin32ExitCode = hr;
        }
    }
    else
    {
        g_SvcStatus.dwWin32ExitCode = NO_ERROR;
    }

    g_SvcStatus.dwServiceSpecificExitCode = 0;
    g_SvcStatus.dwCurrentState = SERVICE_STOPPED;
    g_SvcStatus.dwControlsAccepted = 0;
    g_SvcStatus.dwWaitHint = 0;
    g_SvcStatus.dwCheckPoint = 0;

    UpdateStatus();
}

//+----------------------------------------------------------------------------
//
//  Function:   StartupProgressing
//
//  Synopsis:   Notifies the service controller that startup is still
//              progressing normally.
//
//-----------------------------------------------------------------------------
void
StartupProgressing(void)
{
    g_SvcStatus.dwCheckPoint++;
    UpdateStatus();
}




//*****************************************************************************
//*****************************************************************************
//
// Functions below are used for the sysprep extensions
//
//*****************************************************************************
//*****************************************************************************

HRESULT PrepSysPrepTask(ITask** ppITaskToRun, WCHAR* pwszTaskName);
HRESULT WINAPI SaveSysprepInfo(void);
HRESULT WINAPI ConvertSysprepInfo(void);

//+----------------------------------------------------------------------------
//
//  Function:   SysPrepBackup
//
//  Synopsis:   Entry point called prior to sysprep to store information needed for use after sysprep
//
//-----------------------------------------------------------------------------
void WINAPI SysPrepBackup(void)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); 
    if (SUCCEEDED(hr))
    {
        ITask* pITaskToRun = NULL;
        WCHAR wszTaskName[20];
    
        HRESULT hr = PrepSysPrepTask(&pITaskToRun, wszTaskName);
        if (SUCCEEDED(hr))
        {
            hr = pITaskToRun->Run();

            //
            // wait until task completes execution and deletes itself, or until we've waited too long
            // the simplest way to do this is to check for the job file to go away
            // checking job status would require us to repeatedly load the job file via Activate() anyway
            //
            WCHAR* pwszTasksFolder = NULL;
            hr = GetTasksFolder(&pwszTasksFolder);
            if (SUCCEEDED(hr))
            {
                WCHAR wszJobPath[MAX_PATH + 1];
                StringCchCopy(wszJobPath, MAX_PATH + 1, pwszTasksFolder);
                StringCchCat(wszJobPath, MAX_PATH + 1, L"\\");
                StringCchCat(wszJobPath, MAX_PATH + 1, wszTaskName);
                StringCchCat(wszJobPath, MAX_PATH + 1, TSZ_DOTJOB);
            
                DWORD dwNumWaits = 0;
                while (0xFFFFFFFF != GetFileAttributes(wszJobPath) && dwNumWaits < 60)
                {
                    Sleep(1000);
                    dwNumWaits++;
                }

                delete [] pwszTasksFolder;
            }
        }

        if (pITaskToRun)
        {
            pITaskToRun->Release();
        }

        CoUninitialize();
    }

    if (FAILED(hr))
    {
        // useful for debugging, but ignore errors in normal case as there's nothing we can do
        ERR_OUT("SysPrepBackup", hr);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SysPrepCallback
//
//  Synopsis:   Entry point used with RunDll32
//              runs sysprep first stage
//
//  Arguments:  [hwnd]        -- ignored
//              [hinst]       -- uninteresting
//              [nCmdShow]    -- boring
//              [lpszCmdLine] -- command line from invocation 
//
//  Notes:      This is a straight passthrough to the implementation in ...?
//
//----------------------------------------------------------------------------
extern "C" void SysPrepCallback(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    //
    // Store pre-sysprep credential key in a safe, secure place for use after sysprep
    //
    HRESULT hr = SaveSysprepInfo();
    if (FAILED(hr))
    {
        // useful for debugging, but ignore errors in normal case as there's nothing we can do
        ERR_OUT("SysPrepCallback", hr);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   SysPrepRestore
//
//  Synopsis:   Entry point called after sysprep to process information stored prior to sysprep
//
//-----------------------------------------------------------------------------
void WINAPI SysPrepRestore(void)
{
    //
    // Retrieve pre-sysprep credential key from safe, secure place and use it to decrypt all
    // existing stored task scheduler credentials, then encrypt them using the post-sysprep key
    //
    HRESULT hr = ConvertSysprepInfo();
    if (FAILED(hr))
    {
        // useful for debugging, but ignore errors in normal case
        ERR_OUT("SysPrepRestore", hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedule\sch_util.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_util.cxx
//
//  Contents:   scheduler object IUnknown methods, class factory,
//              plus misc private class methods
//
//  Classes:    CSchedule, CScheduleCF
//
//  Interfaces: IUnknown, IClassFactory
//
//  History:    09-Sep-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ActivateJob, private
//
//  Synopsis:   Given a valid name, returns a pointer to the activated job
//              object
//
//  Arguments:  [pwszName] - the folder-relative name of the job to activate
//              [ppJob]    - a pointer to the job class object; on entry,
//                           must either be NULL or point to a CJob object.
//              [fAllData] - load all job data from disk.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::ActivateJob(LPCTSTR ptszName, CJob ** ppJob, BOOL fAllData)
{
    TCHAR tszFullName[MAX_PATH + MAX_PATH];
    HRESULT hr = StringCchCopy(tszFullName, MAX_PATH + MAX_PATH, g_TasksFolderInfo.ptszPath);
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "CSchedule::ActivateJob: StringCchCopy failed with error 0x%x\n", hr));
        return hr;
    }
    hr = StringCchCat(tszFullName, MAX_PATH + MAX_PATH, TEXT("\\"));
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "CSchedule::ActivateJob: StringCchCat failed with error 0x%x\n", hr));
        return hr;
    }
    hr = StringCchCat(tszFullName, MAX_PATH + MAX_PATH, ptszName);
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "CSchedule::ActivateJob: StringCchCat failed with error 0x%x\n", hr));
        return hr;
    }
    //
    // If *ppJob is NULL, allocate a new job object.
    //
    if (*ppJob == NULL)
    {
        //
        // CJob is a single-use, in-proc handler, so no need to get OLE in the
        // loop here. Use new (called by CJob::Create) instead of CoCreateInstance.
        //
        *ppJob = CJob::Create();
        if (*ppJob == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    hr = (*ppJob)->LoadP(tszFullName, 0, TRUE, fAllData);
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "CSchedule::ActivateJob: pJob->Load failed with error 0x%x\n", hr));
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::CheckJobName
//
//  Synopsis:   Checks for a valid job object file name and returns the full
//              path name. Takes an UNICODE input name and returns a TCHAR.
//
//  Arguments:  [pwszJobName]       - the job name as specified by the client
//              [pptszFullPathName] - the name including the job folder path
//
//  Returns:    HRESULTS
//
//  Notes:      The job name can be an absolute or UNC path. If not,it is
//              assumed to be relative to the job schedule folder.
//              If there is an extension on the last element (the actual file
//              name), then it must be .job. If there is no extension, then
//              the the correct one will be added.
//-----------------------------------------------------------------------------
HRESULT
CSchedule::CheckJobName(LPCWSTR pwszJobName, LPTSTR * pptszFullPathName)
{
    //
    // Make sure that the string doesn't end in a slash character.
    //

    ULONG cchJobName = wcslen(pwszJobName);
    ULONG cchNameParam = cchJobName;

    if (!cchNameParam)
    {
        schDebugOut((DEB_ERROR,
         "CSchedule::CheckJobName: pwszJobName is a 0 length string\n"));
        return E_INVALIDARG;
    }

    if (cchNameParam > 1 &&
            (pwszJobName[cchNameParam - 1] == L'\\' ||
             pwszJobName[cchNameParam - 1] == L'/'))
    {
        schDebugOut((DEB_ERROR,
         "CSchedule::CheckJobName: pwszJobName ends in illegal char %c\n",
         pwszJobName[cchNameParam - 1]));
         return E_INVALIDARG;
    }

    BOOL fNeedsPath = TRUE;
    //
    // Is it a full or relative path?
    //
    if ((cchNameParam > 2 &&
        (pwszJobName[1] == TEXT(':')  ||
         (pwszJobName[0] == TEXT('\\') && pwszJobName[1] == TEXT('\\')) ||
         (pwszJobName[0] == TEXT('/') && pwszJobName[1] == TEXT('/')))))
    {
        fNeedsPath = FALSE;
    }
    //
    // Check extension
    //

    WCHAR * pwszJobExt = TSZ_JOB;
    ULONG cJobExt = ARRAY_LEN(TSZ_JOB);  // add one for the period
    BOOL fNeedExt = FALSE;
    const WCHAR * pwszLastDot = wcsrchr(pwszJobName, L'.');

    if (pwszLastDot != NULL)
    {
        // check if the period is within cJobExt chars of the end
        //
        if ((size_t)(cchNameParam - (pwszLastDot - pwszJobName)) <= (size_t)cJobExt)
        {
            if (_wcsicmp(pwszLastDot + 1, pwszJobExt) != 0)
            {
                // Its extension does not match TSZ_JOB, so it is invalid.
                //
                schDebugOut((DEB_ERROR,
                        "CSchedule::CheckJobName: expected '%S', got '%S'",
                        pwszJobExt,
                        pwszLastDot + 1));
                return E_INVALIDARG;
            }
        }
        else    // append the extension.
        {
            fNeedExt = TRUE;
            cchNameParam += cJobExt;  // add the length of the extension
        }
    }
    else    // append the extension.
    {
        fNeedExt = TRUE;
        cchNameParam += cJobExt;  // add the length of the extension
    }

    //
    // Allocate the string to return the result.
    //
    if (fNeedsPath)
    {
        // add one for the '\'
        cchNameParam += lstrlen(m_ptszFolderPath) + 1;
    }

    // add 1 to the array length for the null
    TCHAR * ptszPath = new TCHAR[cchNameParam + 1];
    if (ptszPath == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (fNeedsPath)
    {
        StringCchCopy(ptszPath, cchNameParam + 1, m_ptszFolderPath);
        StringCchCat(ptszPath, cchNameParam + 1, TEXT("\\"));
        StringCchCat(ptszPath, cchNameParam + 1, pwszJobName);
    }
    else
    {
        StringCchCopy(ptszPath, cchNameParam + 1, pwszJobName);
    }

    if (fNeedExt)
    {
        StringCchCat(ptszPath, cchNameParam + 1, TEXT(".") TSZ_JOB);
    }

    *pptszFullPathName = ptszPath;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::CSchedule
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CSchedule::CSchedule(void) :
    m_ptszTargetMachine(NULL),
    m_ptszFolderPath(NULL),
    m_dwNextID(1),
    m_uRefs(1)
{
    InitializeCriticalSection(&m_CriticalSection);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::~CSchedule
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CSchedule::~CSchedule(void)
{
    DeleteCriticalSection(&m_CriticalSection);
    if (m_ptszTargetMachine)
    {
        delete m_ptszTargetMachine;
    }
    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::Init
//
//  Synopsis:   Two phase construction - can't do operations that could fail
//              in the ctor since there is no way to return errors without
//              throwing exceptions.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::Init(void)
{
    if (g_TasksFolderInfo.ptszPath == NULL)
    {
        ERR_OUT("CSchedule::Init, folder path not set", E_FAIL);
        return E_FAIL;
    }
    HRESULT hr;

    //
    // Get the jobs folder location. These values will be replaced when a
    // call is made to SetTargetMachine
    //
    size_t cch = lstrlen(g_TasksFolderInfo.ptszPath) + 1;
    m_ptszFolderPath = new TCHAR[cch];
    if (!m_ptszFolderPath)
    {
        ERR_OUT("CSchedule::Init", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    StringCchCopy(m_ptszFolderPath, cch, g_TasksFolderInfo.ptszPath);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNextAtID
//
//  Synopsis:   Examine the AT jobs to find the highest ID.
//
//-----------------------------------------------------------------------------
void
GetNextAtID(LPDWORD pdwAtID)
{
    WCHAR wszAtJobSearchPath[MAX_PATH];

    StringCchCopy(wszAtJobSearchPath, MAX_PATH, g_TasksFolderInfo.ptszPath);
    StringCchCat(wszAtJobSearchPath, MAX_PATH, L"\\" TSZ_AT_JOB_PREFIX L"*." TSZ_JOB);

    DWORD cchNamePrefixLen = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1;

    WIN32_FIND_DATA fd;
    HANDLE hFileFind = FindFirstFile(wszAtJobSearchPath, &fd);

    if (hFileFind == INVALID_HANDLE_VALUE)
    {
        //
        // If no at jobs, set the initial job ID to be 1, since zero is
        // reserved for an error flag.
        //
        *pdwAtID = 1;
        return;
    }

    DWORD dwMaxID = 1;

    do
    {
        WCHAR * pDot = wcschr(fd.cFileName, L'.');
        if (pDot == NULL)
        {
            continue;
        }

        *pDot = L'\0';

        DWORD dwCurID = (DWORD)wcstoul(fd.cFileName + cchNamePrefixLen, NULL, 10);

        schDebugOut((DEB_ITRACE, "GetNextAtID: found %S, with ID %d\n",
                     fd.cFileName, dwCurID));

        if (dwCurID > dwMaxID)
        {
            dwMaxID = dwCurID;
        }

    } while (FindNextFile(hFileFind, &fd));

    FindClose(hFileFind);

    if (ULONG_MAX != dwMaxID)
    {
        //
        // The next available AT ID will be one greater than the current max.
        //
        *pdwAtID = dwMaxID + 1;
    }
    else
    {
        //
        // find first hole instead
        //
        StringCchCopy(wszAtJobSearchPath, MAX_PATH, g_TasksFolderInfo.ptszPath);
        StringCchCat(wszAtJobSearchPath, MAX_PATH, L"\\" TSZ_AT_JOB_PREFIX);
        DWORD cchOffset = wcslen(wszAtJobSearchPath);

        dwMaxID = 1;
        StringCchPrintf(wszAtJobSearchPath + cchOffset, MAX_PATH - cchOffset, L"%d%s", dwMaxID, TSZ_DOTJOB);
        while (0xffffffff != GetFileAttributes(wszAtJobSearchPath) && dwMaxID < ULONG_MAX)
        {
            dwMaxID++;
            StringCchPrintf(wszAtJobSearchPath + cchOffset, MAX_PATH - cchOffset, L"%d%s", dwMaxID, TSZ_DOTJOB);
        }

        // it is safe to assume dwMaxID now equals the first ID that wasn't found
        // as it is unfeasible that all IDs from 1 to 0xffffffff (4,294,967,295) would be in use

        *pdwAtID = dwMaxID;
    }
    return;
}

//+----------------------------------------------------------------------------
//
//      CSchedule IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::QueryInterface"));

    if (!ppvObject)
    {
        return E_INVALIDARG;
    }
    
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IID_ITaskScheduler == riid)
    {
        *ppvObject = (IUnknown *)(ITaskScheduler *)this;
    }
    //else if (IID_IDispatch == riid)
    //{
    //  *ppvObject = (IUnknown *)(IDispatch *)this;
    //}
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSchedule::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSchedule::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CScheduleCF - class factory for the Schedule Service object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CScheduleCF::Create(void)
{
    return new CScheduleCF;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::CScheduleCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CScheduleCF::CScheduleCF(void)
{
    m_uRefs = 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::~CScheduleCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CScheduleCF::~CScheduleCF(void)
{
    ;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CScheduleCF::QueryInterface"));

    if (!ppvObject)
    {
        return E_INVALIDARG;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CScheduleCF::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::Release
//
//  Synopsis:   noop, since this is a static object
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CScheduleCF::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the job class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CScheduleCF::CreateInstance\n"));

    if (!ppvObject)
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CSchedule * pSched = new CSchedule;
    if (pSched == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pSched->Init();
    if (FAILED(hr))
    {
        ERR_OUT("CScheduleCF::CreateInstance, pSched->Init", hr);
        pSched->Release();
        return hr;
    }

    hr = pSched->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        ERR_OUT("CScheduleCF::CreateInstance, pSched->QueryInterface", hr);
        pSched->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pSched->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//  Notes:      This is a no-op since the handler runs in-proc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::LockServer(BOOL fLock)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\pfsvc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfsvc.h

Abstract:

    This module contains private declarations for the prefetcher
    service responsible for maintaining prefetch scenario files.

Author:

    Stuart Sechrest (stuartse)
    Cenk Ergan (cenke)
    Chuck Leinzmeier (chuckl)

Environment:

    User Mode

--*/

#ifndef _PFSVC_H_
#define _PFSVC_H_

//
// This is the version of the prefetcher maintenance service. It does
// not have to be in sync with the the prefetcher PF_CURRENT_VERSION.
//

#define PFSVC_SERVICE_VERSION           15

//
// This is the maximum number of traces that will be acquired from the
// kernel and put on the list in the service waiting to be processed.
//

#define PFSVC_MAX_NUM_QUEUED_TRACES     100

//
// If the number of faults in a trace period falls below this, that
// marks the end of the trace for some scenario types.
//

#define PFSVC_MIN_FAULT_THRESHOLD       10

//
// What the rate of usage for the pages we prefetched should be
// greater than for us not to increase scenario sensitivity.
//

#define PFSVC_MIN_HIT_PERCENTAGE        90

//
// What the rate of usage for the pages we knew about but ignored
// should be less than for us not to decrease scenario sensitivity.
//

#define PFSVC_MAX_IGNORED_PERCENTAGE    30

//
// This is the number of launches after which we will set the
// MinReTraceTime and MinRePrefetchTime's on the scenario's header to
// limit prefetch activity if a scenario gets launched very
// frequently. This allows short training scenarios to be run before
// benchmarking after deleting the prefetch files.
//

#define PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK     10

//
// This is the default time in 100ns that has to pass from the last
// launch of a scenario before we prefetch it again.
//

#define PFSVC_DEFAULT_MIN_REPREFETCH_TIME            (1i64 * 120 * 1000 * 1000 * 10)

//
// This is the default time in 100ns that has to pass from the last
// launch of a scenario before we re-trace it again.
//

#define PFSVC_DEFAULT_MIN_RETRACE_TIME               (1i64 * 120 * 1000 * 1000 * 10) 

//
// This is the maximum number of prefetch scenario files we'll have in 
// the prefetch directory. Once we reach this amount we won't create 
// new scenario files until we clean up the old ones.
//

#if DBG
#define PFSVC_MAX_PREFETCH_FILES                     12
#else // DBG
#define PFSVC_MAX_PREFETCH_FILES                     128
#endif // DBG

//
// Path to the registry key and name of the value that specifies the
// file the defragger uses to determine optimal layout of files on the
// disk.
//

#define PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH       \
    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OptimalLayout"
#define PFSVC_OPTIMAL_LAYOUT_REG_VALUE_NAME     \
    L"LayoutFilePath"
#define PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME  \
    L"Layout.ini"
#define PFSVC_OPTIMAL_LAYOUT_ENABLE_VALUE_NAME  \
    L"EnableAutoLayout"

//
// Path to the registry key under which we store various service data,
// e.g. version, last time the defragger was run successfully to
// update layout etc.
//

#define PFSVC_SERVICE_DATA_KEY                  \
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Prefetcher"

//
// These are the value names under PFSVC_SERVICE_DATA_KEY in which we
// store various prefetcher service data.
//

#define PFSVC_VERSION_VALUE_NAME                \
    L"Version"

#define PFSVC_START_TIME_VALUE_NAME             \
    L"StartTime"

#define PFSVC_EXIT_TIME_VALUE_NAME              \
    L"ExitTime"

#define PFSVC_EXIT_CODE_VALUE_NAME              \
    L"ExitCode"

#define PFSVC_LAST_DISK_LAYOUT_TIME_STRING_VALUE_NAME  \
    L"LastDiskLayoutTimeString"

#define PFSVC_TRACES_PROCESSED_VALUE_NAME       \
    L"TracesProcessed"

#define PFSVC_TRACES_SUCCESSFUL_VALUE_NAME      \
    L"TracesSuccessful"

#define PFSVC_LAST_TRACE_FAILURE_VALUE_NAME     \
    L"LastTraceFailure"

#define PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME   \
    L"BootFilesOptimized"

#define PFSVC_MIN_RELAYOUT_HOURS_VALUE_NAME     \
    L"MinRelayoutHours"

//
// This is the value name under PFSVC_SERVICE_DATA_KEY in which we
// store the last time the defragger was run successfully to update
// layout.
//

#define PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME  \
    L"LastDiskLayoutTime"

//
// This is the registry path to the NLS configuration key.
//

#define PFSVC_NLS_REG_KEY_PATH                  \
    L"SYSTEM\\CurrentControlSet\\Control\\Nls"

//
// This is the name of the named manual-reset event that can be set to
// override waiting for system to be idle before processing traces.
//

#define PFSVC_OVERRIDE_IDLE_EVENT_NAME       L"PrefetchOverrideIdle"

//
// This is the name of the named manual-reset event that will be set
// when there are no traces left to process.
//

#define PFSVC_PROCESSING_COMPLETE_EVENT_NAME L"PrefetchProcessingComplete"

//
// When we have run the defragger for all drives after a setup / upgrade,
// we set the build status registry value to this string:
//

#define PFSVC_DEFRAG_DRIVES_DONE             L"DefragDone"

//
// Number of 100ns in an hour.
//

#define PFSVC_NUM_100NS_IN_AN_HOUR           (1i64 * 60 * 60 * 1000 * 1000 * 10)

//
// This is how many 100ns have to pass since last disk layout for us to do
// another one, if we are not being explicitly run.
//

#define PFSVC_MIN_TIME_BEFORE_DISK_RELAYOUT  (1i64 * 3 * 24 * PFSVC_NUM_100NS_IN_AN_HOUR)

//
// Allocation granularity for trace buffers.
//

#define ROUND_TRACE_BUFFER_SIZE(_required) (((_required) + 16384 - 1) & ~(16384 - 1))

//
// Define useful macros. As with all macros, must be careful of parameter
// reevalation. Don't use expressions as macro parameters.
//

#define PFSVC_ALLOC(NumBytes)          (HeapAlloc(GetProcessHeap(),0,(NumBytes)))
#define PFSVC_FREE(Buffer)             (HeapFree(GetProcessHeap(),0,(Buffer)))

//
// This magic is used to mark free'd memory in chunk allocator.
//

#define PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC  0xFEEDCEED

//
// This magic is used to mark free'd memory in string allocator.
//

#define PFSVC_STRING_ALLOCATOR_FREED_MAGIC 0xFEED

//
// This is the max size for the strings allocated from the string
// allocator that will be allocated from the preallocated buffer, so we 
// can save the size of the allocation with the header in a USHORT.
// 

#define PFSVC_STRING_ALLOCATOR_MAX_BUFFER_ALLOCATION_SIZE 60000

//
// These macros are used to acquire/release a mutex.
//

#define PFSVC_ACQUIRE_LOCK(Lock)                                                        \
    DBGPR((PFID,PFLOCK,"PFSVC: AcquireLock-Begin(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));\
    WaitForSingleObject((Lock), INFINITE);                                              \
    DBGPR((PFID,PFLOCK,"PFSVC: AcquireLock-End(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));  \

#define PFSVC_RELEASE_LOCK(Lock)                                                        \
    ReleaseMutex((Lock));                                                               \
    DBGPR((PFID,PFLOCK,"PFSVC: ReleaseLock(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));      \

//
// Internal type and constant definitions: Entries in the trace and in
// the existing scenario file are put into these structures for easier
// manipulation and policy implementation.
//

typedef struct _PFSVC_SECTION_NODE {
   
    // ISSUE-2002/03/29-ScottMa -- Anonymous unions are no longer supported by
    //   the compiler.  They are a non-standard extension (see MSDN -- C4201).
    //   There are three such unions/structs below.

    union {

        //
        // Link in the scenarios list of section nodes.
        //

        LIST_ENTRY SectionLink;

        //
        // These fields are used to sort section nodes by first
        // access.
        //

        struct {
            struct _PFSVC_SECTION_NODE *LeftChild;
            struct _PFSVC_SECTION_NODE *RightChild;
        };
    };

    //
    // Filesystem index number for this section is saved here if it is
    // retrieved. If the section node is for the MFT for the volume we
    // save the number of pages to prefetch from it here.
    //

    union {
        LARGE_INTEGER FileIndexNumber;
        ULONG MFTNumPagesToPrefetch;  
    };

    //
    // This is the section record that we will setup and save in the
    // scenario file.
    //

    PF_SECTION_RECORD SectionRecord;

    //
    // File path for this section.
    //

    WCHAR *FilePath;
    
    //
    // List of page nodes belonging to this section.
    //

    LIST_ENTRY PageList;

    //
    // This is the index of the section in the new trace file when
    // ordered by first access [i.e. page fault].
    //
    
    ULONG NewSectionIndex;

    //
    // This is the index of the section in the original scenario file.
    //

    ULONG OrgSectionIndex;

    //
    // Link in the volume's list of section nodes.
    //

    LIST_ENTRY SectionVolumeLink;

} PFSVC_SECTION_NODE, *PPFSVC_SECTION_NODE;

//
// This structure contains a path and is used with the path list below.
//

typedef struct _PFSVC_PATH {

    //
    // Link in the path list sorted by insertion order.
    //

    LIST_ENTRY InOrderLink;

    //
    // Link in the path list sorted lexically.
    //

    LIST_ENTRY SortedLink;

    //
    // Number of characters in the path excluding terminating NUL.
    //

    ULONG Length;

    //
    // NUL terminated path.
    //

    WCHAR Path[1];

} PFSVC_PATH, *PPFSVC_PATH;

//
// This structure holds a list paths. You should manipulate the
// list or walk through paths in it only using the PathList APIs
// (e.g. GetNextPathInOrder).
//

//
// Wrapper around path lists.
//

typedef struct _PFSVC_PATH_LIST {

    //
    // The list of paths sorted by insertion order.
    //

    LIST_ENTRY InOrderList;
    
    //
    // The list of paths sorted lexically.
    //

    LIST_ENTRY SortedList;

    //
    // If non NULL, we will make allocations for new entries from it
    // instead of hitting the heap.
    //

    struct _PFSVC_STRING_ALLOCATOR *Allocator;

    //
    // Number of paths in the list.
    //

    ULONG NumPaths;
    
    //
    // Total length of the paths in the list excluding NULs.
    //

    ULONG TotalLength;

    //
    // Whether list will be case sensitive or not.
    //

    BOOLEAN CaseSensitive;

} PFSVC_PATH_LIST, *PPFSVC_PATH_LIST;

//
// This structure is used to divide sections in a scenario to
// different disk volumes (i.e. c:, d:) they are on.
//

typedef struct _PFSVC_VOLUME_NODE {

    //
    // Link in the scenario's list of volume nodes.
    //

    LIST_ENTRY VolumeLink;

    //
    // Volume path and length in number of characters excluding NUL.
    //

    WCHAR *VolumePath;
    ULONG VolumePathLength;
    
    //
    // List of sections that are on this volume that will be prefetched.
    //

    LIST_ENTRY SectionList;
    ULONG NumSections;

    //
    // This is the total number of sections on this volume, including
    // those that won't be prefetched.
    //

    ULONG NumAllSections;

    //
    // List of directories accessed on this volume.
    //
    
    PFSVC_PATH_LIST DirectoryList;

    //
    // Serial Number/Creation time for this volume. This is retrieved
    // either from a new trace or from the existing scenario file
    // (both should match or the scenario file gets discarded.)
    //

    LARGE_INTEGER CreationTime;
    ULONG SerialNumber;

    //
    // Pointer to section node for the MFT for this volume (if there is one).
    //

    PPFSVC_SECTION_NODE MFTSectionNode;

} PFSVC_VOLUME_NODE, *PPFSVC_VOLUME_NODE;

//
// Wrapper around page records.
//

typedef struct _PFSVC_PAGE_NODE {

    //
    // Link in the section node's list of pages.
    //

    LIST_ENTRY PageLink;

    //
    // Page record from previous scenario instructions or a new one
    // initialized for a trace log entry.
    //

    PF_PAGE_RECORD PageRecord;

} PFSVC_PAGE_NODE, *PPFSVC_PAGE_NODE;

//
// This structure is used to make a single big allocation and give it away
// in small chunks to be used as strings. It is very simple and will not reclaim 
// freed memory for future allocs. The whole allocation will be freed in cleanup. 
// There is no synchronization.
//

typedef struct _PFSVC_STRING_ALLOCATOR {

    //
    // Actual allocation to be divided up and given away in small chunks.
    //

    PCHAR Buffer;

    //
    // End of buffer. If FreePointer is equal to beyond this we can't give
    // away more from this buffer.
    //

    PCHAR BufferEnd;

    //
    // Pointer to start of free memory in Buffer.
    //

    PCHAR FreePointer;

    //
    // Number of times we had to hit the heap because we ran out of space
    // and the current outstanding such allocations.
    //

    ULONG MaxHeapAllocs;
    ULONG NumHeapAllocs;

    //
    // Size of the last allocation that was made from the buffer.
    //

    USHORT LastAllocationSize;

    //
    // Whether user has passed in Buffer (so we don't free it when
    // cleaning up.
    //

    ULONG UserSpecifiedBuffer:1;

} PFSVC_STRING_ALLOCATOR, *PPFSVC_STRING_ALLOCATOR;

//
// This structure comes before allocations from the string allocator buffer.
//

typedef struct _PFSVC_STRING_ALLOCATION_HEADER {

    // ISSUE-2002/03/29-ScottMa -- Anonymous unions are no longer supported by
    //   the compiler.  They are a non-standard extension (see MSDN -- C4201).
    //   There are two such unions/structs below.

    union {

        //
        // This structure contains the actual fields.
        //

        struct {

            //
            // Size of the preceding allocation.
            //

            USHORT PrecedingAllocationSize;

            //
            // Size of this allocation.
            //

            USHORT AllocationSize;

        };

        //
        // Require pointer alignment for this structure, so allocations
        // from the string allocator end up pointer aligned.
        //

        PVOID FieldToRequirePointerAlignment;
    };

} PFSVC_STRING_ALLOCATION_HEADER, *PPFSVC_STRING_ALLOCATION_HEADER;

//
// This structure is used to make a single big allocation and give it away
// to be used as page nodes, sections nodes etc in small chunks. It is very 
// simple and will not reclaim freed small chunks for future allocs. The whole
// allocation will be freed in cleanup. The chunk size and max allocs to satisfy
// is fixed at initialization. There is no synchronization.
//

typedef struct _PFSVC_CHUNK_ALLOCATOR {

    //
    // Actual allocation to be divided up and given away in small chunks.
    //

    PCHAR Buffer;

    //
    // End of buffer. If FreePointer is equal to beyond this we can't give
    // away more from this buffer.
    //

    PCHAR BufferEnd;

    //
    // Pointer to start of free memory in Buffer.
    //

    PCHAR FreePointer;

    //
    // How big each chunk will be in bytes.
    //

    ULONG ChunkSize;

    //
    // Number of times we had to hit the heap because we ran out of space
    // and the current outstanding such allocations.
    //

    ULONG MaxHeapAllocs;
    ULONG NumHeapAllocs;

    //
    // Whether user has passed in Buffer (so we don't free it when
    // cleaning up.
    //

    ULONG UserSpecifiedBuffer:1;

} PFSVC_CHUNK_ALLOCATOR, *PPFSVC_CHUNK_ALLOCATOR;

//
// Wrapper around a scenario structure.
//

typedef struct _PFSVC_SCENARIO_INFO {

    //
    // Header information for the scenario instructions in preparation.
    //

    PF_SCENARIO_HEADER ScenHeader;

    //
    // Allocators used to make allocations for scenario processing efficient.
    //

    PVOID OneBigAllocation;
    PFSVC_CHUNK_ALLOCATOR SectionNodeAllocator;
    PFSVC_CHUNK_ALLOCATOR PageNodeAllocator;
    PFSVC_CHUNK_ALLOCATOR VolumeNodeAllocator;
    PFSVC_STRING_ALLOCATOR PathAllocator;

    //
    // Container for the sections in this scenario.
    //

    LIST_ENTRY SectionList;

    //
    // List of disk volumes that the scenario's sections are on. This
    // list is sorted lexically.
    //

    LIST_ENTRY VolumeList;

    //
    // Various statistics acquired from the trace information and used
    // in applying prefetch policy.
    //

    ULONG NewPages;
    ULONG HitPages;
    ULONG MissedOpportunityPages;
    ULONG IgnoredPages;
    ULONG PrefetchedPages;

} PFSVC_SCENARIO_INFO, *PPFSVC_SCENARIO_INFO;

//
// This is a priority queue used for sorting section nodes by first
// access.
//

typedef struct _PFSV_SECTNODE_PRIORITY_QUEUE {

    //
    // Think of this priority queue as a Head node and a binary sorted
    // tree at the right child of the Head node. The left child of the
    // Head node always stays NULL. If we need to add a new node
    // smaller than Head, the new node becames the new Head. This way
    // we always have binary sorted tree rooted at Head as well.
    //

    PPFSVC_SECTION_NODE Head;

} PFSV_SECTNODE_PRIORITY_QUEUE, *PPFSV_SECTNODE_PRIORITY_QUEUE;

//
// A list of these may be used to convert the prefix of a path from NT
// to DOS style. [e.g. \Device\HarddiskVolume1 to C:]
//

typedef struct _NTPATH_TRANSLATION_ENTRY {
    
    //
    // Link in a list of translation entries.
    //

    LIST_ENTRY Link;

    //
    // NT path prefix to convert and its length in number of
    // characters excluding NUL.
    //
    
    WCHAR *NtPrefix;
    ULONG NtPrefixLength;
    
    //
    // A DOS path prefix that the NT Path translates to. Note that
    // this not the only possible DOS name translation as a volume may
    // be mounted anywhere.
    //

    WCHAR *DosPrefix;
    ULONG DosPrefixLength;

    //
    // This is the volume string returned by FindNextVolume.
    //

    WCHAR *VolumeName;
    ULONG VolumeNameLength;

} NTPATH_TRANSLATION_ENTRY, *PNTPATH_TRANSLATION_ENTRY;

typedef LIST_ENTRY NTPATH_TRANSLATION_LIST;
typedef NTPATH_TRANSLATION_LIST *PNTPATH_TRANSLATION_LIST;

//
// Define structure that wraps traces from the kernel.
//

typedef struct _PFSVC_TRACE_BUFFER {
    
    //
    // Traces are saved on the list via this link.
    //

    LIST_ENTRY TracesLink;
    
    //
    // The real trace from kernel starts here and extends for traces
    // size.
    //

    PF_TRACE_HEADER Trace;

} PFSVC_TRACE_BUFFER, *PPFSVC_TRACE_BUFFER;

//
// Define the globals structure.
//

typedef struct _PFSVC_GLOBALS {

    //
    // Prefetch parameters. These won't be initialized when globals are 
    // initialized and have to be explicitly acquired from the kernel.
    // Use PrefetchRoot below instead of RootDirPath in this structure.  
    //

    PF_SYSTEM_PREFETCH_PARAMETERS Parameters;

    //
    // OS Version information.
    //

    OSVERSIONINFOEXW OsVersion;

    //
    // An array of path suffices to recognize files we don't want to prefetch 
    // for boot. It is UPCASE and sorted lexically going from last character 
    // to first.
    //

    WCHAR **FilesToIgnoreForBoot;
    ULONG NumFilesToIgnoreForBoot;
    ULONG *FileSuffixLengths;
    
    //
    // This manual reset event gets set when the prefetcher service is
    // asked to go away.
    //
    
    HANDLE TerminateServiceEvent;

    //
    // This is the list of traces acquired from the kernel that have
    // to be processed, number of them and the lock to protect the
    // list.
    //

    LIST_ENTRY Traces;
    ULONG NumTraces;
    HANDLE TracesLock;
    
    //
    // This auto-clearing event is set when new traces are put on the
    // list.
    //

    HANDLE NewTracesToProcessEvent;
    
    //
    // This auto-clearing event is set when we had max number of
    // queued traces and we process one. It signifies that we should
    // check for any traces we could not pick up because the queue was
    // maxed.
    //
    
    HANDLE CheckForMissedTracesEvent;

    //
    // This named manual-reset event is set to force the prefetcher
    // service to process the traces without waiting for an idle
    // system.
    //

    HANDLE OverrideIdleProcessingEvent;

    //
    // This named manual-reset event is set when processing of the
    // currently available traces are done.
    //

    HANDLE ProcessingCompleteEvent;

    //
    // This is the path to the directory where prefetch files are
    // kept and the lock to protect it.
    //
    
    WCHAR PrefetchRoot[MAX_PATH + 1];
    HANDLE PrefetchRootLock;

    //
    // Number of prefetch files in the prefetch directory. This is an estimate
    // (i.e. may not be exact) used to make sure the prefetch directory does
    // not grow too big.
    //

    ULONG NumPrefetchFiles;

    //
    // This is a registry handle to the data key under which some
    // prefetch service data is stored.
    //

    HKEY ServiceDataKey;

    //
    // This is the number of total traces we attempted to process. 
    //

    ULONG NumTracesProcessed;

    //
    // This is the number of traces processed successfully.
    //

    ULONG NumTracesSuccessful;

    //
    // This is the last error code with which we failed processing a
    // trace.
    //

    DWORD LastTraceFailure;

    //
    // Did the defragger crash last time we ran it?
    //

    DWORD DefraggerErrorCode;

    //
    // Whether we are asked not to run the defragger in the registry.
    //

    DWORD DontRunDefragger;

    //
    // Pointer to path where CSC (client side caching) files are stored.
    //

    WCHAR *CSCRootPath;

} PFSVC_GLOBALS, *PPFSVC_GLOBALS;

//
// This describes a worker function called when it is time for an idle
// task to run.
//

typedef 
DWORD 
(*PFSVC_IDLE_TASK_WORKER_FUNCTION) (
    struct _PFSVC_IDLE_TASK *Task
    );

//
// This structure is used to keep context for a registered idle task.
//

typedef struct _PFSVC_IDLE_TASK {

    //
    // Parameters filled in by RegisterIdleTask call.
    //

    HANDLE ItHandle;
    HANDLE StartEvent;
    HANDLE StopEvent;

    //
    // Handle for the registered wait.
    //

    HANDLE WaitHandle;

    //
    // The registered callback function that will be called when the start
    // event is signaled.
    //

    WAITORTIMERCALLBACK Callback;

    //
    // If the common callback function is specified, it calls this function
    // to do the actual work.
    //

    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction;

    //
    // This is a manual reset event that will be set when the wait/callback
    // on the start event is fully unregistered.
    //

    HANDLE WaitUnregisteredEvent;

    //
    // This manual reset event gets reset when a callback starts running and
    // gets signaled when the callback stops running. Signaling of this event
    // is not protected so you can't purely rely on it. It is useful as a
    // shortcut.
    //

    HANDLE CallbackStoppedEvent;

    //
    // This manual reset event gets signaled when somebody starts unregistering.
    //

    HANDLE StartedUnregisteringEvent;

    //
    // This manual reset event gets signaled when somebody completes unregistering.
    //

    HANDLE CompletedUnregisteringEvent;
    
    //
    // The first one to interlocked set this from 0 to an integer is responsible 
    // for unregistering the wait & task and cleaning up.
    //

    LONG Unregistering;

    //
    // This is interlocked set from 0 to an integer when a callback is running, 
    // or when the main thread is unregistering.
    //

    LONG CallbackRunning;

    //
    // Whether this task is registered (i.e. and has to be unregistered.)
    //

    BOOLEAN Registered;

    //
    // Whether this task has been initialized, used as a sanity check.
    //

    BOOLEAN Initialized;

} PFSVC_IDLE_TASK, *PPFSVC_IDLE_TASK;

//
// Values for the Unregistering field of PFSVC_IDLE_TASK.
//

typedef enum _PFSVC_TASK_UNREGISTERING_VALUES {
    PfSvcNotUnregisteringTask = 0,
    PfSvcUnregisteringTaskFromCallback,
    PfSvcUnregisteringTaskFromMainThread,
    PfSvcUnregisteringTaskMaxValue
} PFSVC_TASK_UNREGISTERING_VALUES, *PPFSVC_TASK_UNREGISTERING_VALUES;

//
// Values for the CallbackRunning field of PFSVC_IDLE_TASK.
//

typedef enum _PFSVC_TASK_CALLBACKRUNNING_VALUES {
    PfSvcTaskCallbackNotRunning = 0,
    PfSvcTaskCallbackRunning,
    PfSvcTaskCallbackDisabled,
    PfSvcTaskCallbackMaxValue
} PFSVC_TASK_CALLBACKRUNNING_VALUES, *PPFSVC_TASK_CALLBACKRUNNING_VALUES;


//
// Information on a scenario file's age, number of launches etc. used in 
// discarding old scenario files in the prefetch directory.
//

typedef struct _PFSVC_SCENARIO_AGE_INFO {

    //
    // Weight calculated based on the launch information. Larger weight is 
    // better. We'd rather discard scenario with smaller weight.
    //

    ULONG Weight;

    //
    // Scenario file path.
    //

    WCHAR *FilePath;   

} PFSVC_SCENARIO_AGE_INFO, *PPFSVC_SCENARIO_AGE_INFO;

//
// This structure is used to enumerate through the scenario files
// in the prefetch directory. None of the fields of this function
// should be modified outside the file cursor routines.
//

typedef struct _PFSVC_SCENARIO_FILE_CURSOR {

    //
    // Data returned from FindFile calls for the current prefetch file.
    //

    WIN32_FIND_DATA FileData;

    //
    // The current prefetch file's full path.
    //

    WCHAR *FilePath;

    //
    // File name & path length in number of characters excluding NUL.
    //

    ULONG FileNameLength;
    ULONG FilePathLength;

    //
    // Index of the current file.
    //

    ULONG CurrentFileIdx;

    //
    // The fields below are used privately by the scenario file cursor
    // functions.
    //

    //
    // FindFile handle.
    //

    HANDLE FindFileHandle;

    //
    // Where we are looking for prefetch files.
    //

    WCHAR *PrefetchRoot;
    ULONG PrefetchRootLength;

    //
    // This is the maximum length string the allocated FilePath can store.
    //

    ULONG FilePathMaxLength;

    //
    // This is where the file name starts in the file path. The base of
    // the file path does not change (i.e. PrefetchRoot) and we copy
    // the new enumerated file name starting at FilePath+FileNameStart.
    //

    ULONG FileNameStart;
    
} PFSVC_SCENARIO_FILE_CURSOR, *PPFSVC_SCENARIO_FILE_CURSOR;

//
// Return values from CompareSuffix.
//

typedef enum _PFSV_SUFFIX_COMPARISON_RESULT {
    PfSvSuffixIdentical,
    PfSvSuffixLongerThan,
    PfSvSuffixLessThan,
    PfSvSuffixGreaterThan
} PFSV_SUFFIX_COMPARISON_RESULT, *PPFSV_SUFFIX_COMPARISON_RESULT;

//
// Return values from ComparePrefix.
//

typedef enum _PFSV_PREFIX_COMPARISON_RESULT {
    PfSvPrefixIdentical,
    PfSvPrefixLongerThan,
    PfSvPrefixLessThan,
    PfSvPrefixGreaterThan
} PFSV_PREFIX_COMPARISON_RESULT, *PPFSV_PREFIX_COMPARISON_RESULT;

//
// Return values from SectionNodeComparisonRoutine.
//

typedef enum _PFSV_SECTION_NODE_COMPARISON_RESULT {
    PfSvSectNode1LessThanSectNode2 = -1,
    PfSvSectNode1EqualToSectNode2 = 0,
    PfSvSectNode1GreaterThanSectNode2 = 1,
} PFSV_SECTION_NODE_COMPARISON_RESULT, *PPFSV_SECTION_NODE_COMPARISON_RESULT;

//
// Local function prototypes:
//

//
// Exposed routines:
//

DWORD 
WINAPI
PfSvcMainThread(
    VOID *Param
    );


//
// Internal service routines:
//

//
// Thread routines:
//

DWORD 
WINAPI
PfSvProcessTraceThread(
    VOID *Param
    );

DWORD 
WINAPI
PfSvPollShellReadyWorker(
    VOID *Param
    );

//
// Routines called by the main prefetcher thread.
//

DWORD 
PfSvGetRawTraces(
    VOID
    );

DWORD
PfSvInitializeGlobals(
    VOID
    );

VOID
PfSvCleanupGlobals(
    VOID
    );

DWORD
PfSvGetCSCRootPath (
    WCHAR *CSCRootPath,
    ULONG CSCRootPathMaxChars
    );
    
DWORD
PfSvGetDontRunDefragger(
    DWORD *DontRunDefragger
    );

DWORD
PfSvSetPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    );

DWORD
PfSvQueryPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    );

DWORD
PfSvInitializePrefetchDirectory(
    WCHAR *PathFromSystemRoot
    );

DWORD
PfSvCountFilesInDirectory(
    WCHAR *DirectoryPath,
    WCHAR *MatchExpression,
    PULONG NumFiles
    );

//
// Routines to process acquired traces:
//

DWORD
PfSvProcessTrace(
    PPF_TRACE_HEADER Trace
    );

VOID
PfSvInitializeScenarioInfo (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_ID ScenarioId,
    PF_SCENARIO_TYPE ScenarioType
    );

VOID 
PfSvCleanupScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    );

DWORD
PfSvScenarioOpen (
    IN PWCHAR FilePath,
    IN PPF_SCENARIO_ID ScenarioId,
    IN PF_SCENARIO_TYPE ScenarioType,
    OUT PPF_SCENARIO_HEADER *Scenario
    );

DWORD
PfSvScenarioGetFilePath(
    OUT PWCHAR FilePath,
    IN ULONG FilePathMaxChars,
    IN PPF_SCENARIO_ID ScenarioId
    );

DWORD
PfSvScenarioInfoPreallocate(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OPTIONAL IN PPF_SCENARIO_HEADER Scenario,
    IN PPF_TRACE_HEADER Trace
    );

DWORD
PfSvAddExistingScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_HEADER Scenario
    );

DWORD
PfSvVerifyVolumeMagics(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    );

DWORD
PfSvAddTraceInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    );

PPFSVC_SECTION_NODE 
PfSvGetSectionRecord(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

DWORD 
PfSvAddFaultInfoToSection(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_LOG_ENTRY LogEntry,
    PPFSVC_SECTION_NODE SectionNode
    );

DWORD
PfSvApplyPrefetchPolicy(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    );

ULONG 
PfSvGetNumTimesUsed(
    ULONG UsageHistory,
    ULONG UsageHistorySize
    );

ULONG 
PfSvGetTraceEndIdx(
    PPF_TRACE_HEADER Trace
    );

//
// Routines to write updated scenario instructions to the scenario
// file.
//

DWORD
PfSvWriteScenario(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PWCHAR ScenarioFilePath
    );

DWORD
PfSvPrepareScenarioDump(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OUT PPF_SCENARIO_HEADER *ScenarioPtr
    );

//
// Routines to maintain the optimal disk layout file and update disk
// layout.
//

DWORD
PfSvUpdateOptimalLayout(
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvUpdateLayout (
    PPFSVC_PATH_LIST CurrentLayout,
    PPFSVC_PATH_LIST OptimalLayout,
    PBOOLEAN LayoutChanged
    );

DWORD
PfSvDetermineOptimalLayout (
    PPFSVC_IDLE_TASK Task,
    PPFSVC_PATH_LIST OptimalLayout,
    BOOL *BootScenarioProcessed
    );

DWORD
PfSvUpdateLayoutForScenario (
    PPFSVC_PATH_LIST OptimalLayout,
    WCHAR *ScenarioFilePath,
    PNTPATH_TRANSLATION_LIST TranslationList,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    );

DWORD
PfSvReadLayout(
    IN WCHAR *FilePath,
    OUT PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    );

DWORD
PfSvSaveLayout(
    IN WCHAR *FilePath,
    IN PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    );

DWORD
PfSvGetLayoutFilePath(
    PWCHAR *FilePathBuffer,
    PULONG FilePathBufferSize
    );

//
// Routines to defrag the disks once after setup when the system is idle.
//

DWORD
PfSvDefragDisks(
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvLaunchDefragger(
    PPFSVC_IDLE_TASK Task,
    BOOLEAN ForLayoutOptimization,
    PWCHAR TargetDrive
    );

DWORD
PfSvGetBuildDefragStatusValueName (
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *ValueName
    );

DWORD
PfSvSetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR BuildDefragStatus,
    ULONG Size
    );

DWORD
PfSvGetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *BuildDefragStatus,
    PULONG ReturnSize
    );

//
// Routines to cleanup old scenario files in the prefetch directory.
//

DWORD
PfSvCleanupPrefetchDirectory(
    PPFSVC_IDLE_TASK Task
    );

int
__cdecl 
PfSvCompareScenarioAgeInfo(
    const void *Param1,
    const void *Param2
    );

//
// Routines to enumerate scenario files.
//

VOID
PfSvInitializeScenarioFileCursor (
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

VOID
PfSvCleanupScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

DWORD
PfSvStartScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor,
    WCHAR *PrefetchRoot
    );

DWORD
PfSvGetNextScenarioFileInfo(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

//
// File I/O utility routines.
//

DWORD
PfSvGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    );

DWORD
PfSvWriteBuffer(
    PWCHAR FilePath,
    PVOID Buffer,
    ULONG Length
    );

DWORD
PfSvGetLastWriteTime (
    WCHAR *FilePath,
    PFILETIME LastWriteTime
    );

DWORD
PfSvReadLine (
    FILE *File,
    WCHAR **LineBuffer,
    ULONG *LineBufferMaxChars,
    ULONG *LineLength
    );

DWORD
PfSvGetFileBasicInformation (
    WCHAR *FilePath,
    PFILE_BASIC_INFORMATION FileInformation
    );

DWORD
PfSvGetFileIndexNumber(
    WCHAR *FilePath,
    PLARGE_INTEGER FileIndexNumber
    );

//
// String utility routines.
//

PFSV_SUFFIX_COMPARISON_RESULT
PfSvCompareSuffix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Suffix,
    ULONG SuffixLength,
    BOOLEAN CaseSensitive
    );

PFSV_PREFIX_COMPARISON_RESULT
PfSvComparePrefix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Prefix,
    ULONG PrefixLength,
    BOOLEAN CaseSensitive
    );

VOID
FASTCALL
PfSvRemoveEndOfLineChars (
    WCHAR *Line,
    ULONG *LineLength
    );

PWCHAR
PfSvcAnsiToUnicode(
    PCHAR str
    );

PCHAR
PfSvcUnicodeToAnsi(
    PWCHAR wstr
    );

VOID 
PfSvcFreeString(
    PVOID String
    );

//
// Routines that deal with information in the registry.
//

DWORD
PfSvSaveStartInfo (
    HKEY ServiceDataKey
    );

DWORD
PfSvSaveExitInfo (
    HKEY ServiceDataKey,
    DWORD ExitCode
    );

DWORD
PfSvSaveTraceProcessingStatistics (
    HKEY ServiceDataKey
    );

DWORD
PfSvGetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    );

DWORD
PfSvSetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    );

BOOLEAN
PfSvAllowedToRunDefragger(
    BOOLEAN CheckRegistry
    );

//
// Routines that deal with security.
//

BOOL 
PfSvSetPrivilege(
    HANDLE hToken,
    LPCTSTR lpszPrivilege,
    ULONG ulPrivilege,
    BOOL bEnablePrivilege
    );

DWORD
PfSvSetAdminOnlyPermissions(
    WCHAR *ObjectPath,
    HANDLE ObjectHandle,
    SE_OBJECT_TYPE ObjectType
    );

DWORD
PfSvGetPrefetchServiceThreadPrivileges (
    VOID
    );

//
// Routines that deal with volume node structures.
//

DWORD
PfSvCreateVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *VolumePath,
    ULONG VolumePathLength,
    PLARGE_INTEGER CreationTime,
    ULONG SerialNumber
    );

PPFSVC_VOLUME_NODE
PfSvGetVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

VOID
PfSvCleanupVolumeNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_VOLUME_NODE VolumeNode
    );
    
DWORD
PfSvAddParentDirectoriesToList(
    PPFSVC_PATH_LIST DirectoryList,
    ULONG VolumePathLength,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

//
// Routines used to allocate / free section & page nodes etc. efficiently.
//

VOID
PfSvChunkAllocatorInitialize (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

DWORD
PfSvChunkAllocatorStart (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Buffer,
    ULONG ChunkSize,
    ULONG MaxChunks
    );

PVOID
PfSvChunkAllocatorAllocate (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

VOID
PfSvChunkAllocatorFree (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Allocation
    );

VOID
PfSvChunkAllocatorCleanup (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

//
// Routines used to allocate / free file / directory / volume paths fast.
//

VOID
PfSvStringAllocatorInitialize (
    PPFSVC_STRING_ALLOCATOR Allocator
    );

DWORD
PfSvStringAllocatorStart (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Buffer,
    ULONG MaxSize
    );

PVOID
PfSvStringAllocatorAllocate (
    PPFSVC_STRING_ALLOCATOR Allocator,
    ULONG NumBytes
    );

VOID
PfSvStringAllocatorFree (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Allocation
    );

VOID
PfSvStringAllocatorCleanup (
    PPFSVC_STRING_ALLOCATOR Allocator
    );

//
// Routines that deal with section node structures.
//

VOID
PfSvCleanupSectionNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_SECTION_NODE SectionNode
    );

//
// Routines used to sort scenario's section nodes.
//

DWORD
PfSvSortSectionNodesByFirstAccess(
    PLIST_ENTRY SectionNodeList
    );

PFSV_SECTION_NODE_COMPARISON_RESULT 
FASTCALL
PfSvSectionNodeComparisonRoutine(
    PPFSVC_SECTION_NODE Element1, 
    PPFSVC_SECTION_NODE Element2 
    );

//
// Routines that implement a priority queue used to sort section nodes
// for a scenario.
//

VOID
PfSvInitializeSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    );

VOID
PfSvInsertSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue,
    PPFSVC_SECTION_NODE NewElement
    );

PPFSVC_SECTION_NODE
PfSvRemoveMinSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    );

//
// Implementation of the Nt path to Dos path translation API.
//

DWORD
PfSvBuildNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST *NtPathTranslationList
    );

VOID
PfSvFreeNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST TranslationList
    );

DWORD 
PfSvTranslateNtPath(
    PNTPATH_TRANSLATION_LIST TranslationList,
    WCHAR *NtPath,
    ULONG NtPathLength,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    );
    
//
// Path list API.
//

VOID
PfSvInitializePathList(
    PPFSVC_PATH_LIST PathList,
    PPFSVC_STRING_ALLOCATOR PathAllocator,
    BOOLEAN CaseSensitive
    );

VOID
PfSvCleanupPathList(
    PPFSVC_PATH_LIST PathList
    );

BOOLEAN
PfSvIsInPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    );

DWORD
PfSvAddToPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    );

PPFSVC_PATH
PfSvGetNextPathSorted (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    );

PPFSVC_PATH
PfSvGetNextPathInOrder (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    );

//
// Routines to build the list of files accessed by the boot loader.
//

DWORD
PfSvBuildBootLoaderFilesList (
    PPFSVC_PATH_LIST PathList
    );

ULONG
PfVerifyImageImportTable (
    IN PVOID BaseAddress,
    IN ULONG MappingSize,
    IN BOOLEAN MappedAsImage
    );

DWORD 
PfSvAddBootImageAndImportsToList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

DWORD
PfSvLocateBootServiceFile(
    IN WCHAR *FileName,
    IN ULONG FileNameLength,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength   
    );

DWORD
PfSvGetBootServiceFullPath(
    IN WCHAR *ServiceName,
    IN WCHAR *BinaryPathName,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength
    );

DWORD 
PfSvGetBootLoaderNlsFileNames (
    PPFSVC_PATH_LIST PathList
    );

DWORD 
PfSvLocateNlsFile(
    WCHAR *FileName,
    WCHAR *FilePathBuffer,
    ULONG FilePathBufferLength,
    ULONG *RequiredLength
    );

DWORD
PfSvQueryNlsFileName (
    HKEY Key,
    WCHAR *ValueName,
    WCHAR *FileNameBuffer,
    ULONG FileNameBufferSize,
    ULONG *RequiredSize
    );

//
// Routines to manage / run idle tasks.
//

VOID
PfSvInitializeTask (
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvRegisterTask (
    PPFSVC_IDLE_TASK Task,
    IT_IDLE_TASK_ID TaskId,
    WAITORTIMERCALLBACK Callback,
    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction
    );

DWORD
PfSvUnregisterTask (
    PPFSVC_IDLE_TASK Task,
    BOOLEAN CalledFromCallback
    );

VOID
PfSvCleanupTask (
    PPFSVC_IDLE_TASK Task
    );

BOOL
PfSvStartTaskCallback(
    PPFSVC_IDLE_TASK Task
    );

VOID
PfSvStopTaskCallback(
    PPFSVC_IDLE_TASK Task
    );

VOID 
CALLBACK 
PfSvCommonTaskCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired
    );

DWORD
PfSvContinueRunningTask(
    PPFSVC_IDLE_TASK Task
    );

//
// ProcessIdleTasks notify routine and its dependencies.
//

VOID
PfSvProcessIdleTasksCallback(
    VOID
    );

DWORD
PfSvForceWMIProcessIdleTasks(
    VOID
    );

BOOL 
PfSvWaitForServiceToStart (
    LPTSTR ServiceName, 
    DWORD MaxWait
    );

//
// Wrappers around verify routines.
//

BOOLEAN
PfSvVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    );

//
// Debug definitions.
//

#if DBG
#ifndef PFSVC_DBG
#define PFSVC_DBG
#endif // !PFSVC_DBG
#endif // DBG

#ifdef PFSVC_DBG

//
// Define the component ID we use.
//

#define PFID       DPFLTR_PREFETCHER_ID

//
// Define DbgPrintEx levels.
//

#define PFERR      DPFLTR_ERROR_LEVEL
#define PFWARN     DPFLTR_WARNING_LEVEL
#define PFTRC      DPFLTR_TRACE_LEVEL
#define PFINFO     DPFLTR_INFO_LEVEL

//
// DbgPrintEx levels 4 - 19 are reserved for the kernel mode component.
//

#define PFSTRC     20
#define PFWAIT     21
#define PFLOCK     22
#define PFPATH     23
#define PFNTRC     24
#define PFTASK     25

//
//  This may help you determine what to set the DbgPrintEx mask.
//
//  3 3 2 2  2 2 2 2  2 2 2 2  1 1 1 1   1 1 1 1  1 1 0 0  0 0 0 0  0 0 0 0
//  1 0 9 8  7 6 5 4  3 2 1 0  9 8 7 6   5 4 3 2  1 0 9 8  7 6 5 4  3 2 1 0
//  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _   _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define DBGPR(x) DbgPrintEx x
#define PFSVC_ASSERT(x) if (!(x)) RtlAssert(#x, __FILE__, __LINE__, NULL )

//
// Variables used when saving traces acquired from the kernel. The
// traces are saved in the prefetch directory by appending the trace
// number % max number of saved traces to the base trace name.
//

WCHAR *PfSvcDbgTraceBaseName = L"PrefetchTrace";
LONG PfSvcDbgTraceNumber = 0;
LONG PfSvcDbgMaxNumSavedTraces = 20;

#else // PFSVC_DBG

#define DBGPR(x)
#define PFSVC_ASSERT(x)

#endif // PFSVC_DBG

#endif // _PFSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\pfsvc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfsvc.c

Abstract:

    This module contains the main rountines for the prefetcher service
    responsible for maintaining prefetch scenario files.

Author:

    Stuart Sechrest (stuartse)
    Cenk Ergan (cenke)
    Chuck Leinzmeier (chuckl)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <aclapi.h>
#include <dbghelp.h>
#include <idletask.h>
#include <prefetch.h>
#include <shdcom.h>
#include <tchar.h>
#include "pfsvc.h"

//
// Routine called to register for notifications when processing of all idle 
// tasks is requested from the idle task server.
//

typedef VOID (*PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE)(VOID);

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    );

//
// Globals.
//

PFSVC_GLOBALS PfSvcGlobals = {0};

//
// Exposed routines:
//

DWORD 
WINAPI
PfSvcMainThread(
    VOID *Param
    )

/*++

Routine Description:

    This is the main routine for the prefetcher service. It sets up
    file notification on the input files directory and waits for work
    or the signaling of the termination event.

Arguments:

    Param - Pointer to handle to the event that will signal our
      termination.

Return Value:

    Win32 error code.

--*/

{
    HANDLE hStopEvent;
    HANDLE hTracesReadyEvent;
    HANDLE hParametersChangedEvent;
    HANDLE hEvents[4];
    ULONG NumEvents;
    DWORD ErrorCode;
    BOOLEAN bExitMainLoop;
    DWORD dwWait;
    NTSTATUS Status;
    PF_SCENARIO_TYPE ScenarioType;
    BOOLEAN UpdatedParameters;
    BOOLEAN PrefetchingEnabled;
    HANDLE PrefetcherThreads[1];
    ULONG NumPrefetcherThreads;
    ULONG ThreadIdx;
        
    //
    // Initialize locals.
    //

    // FUTURE-2002/03/29-ScottMa -- NumEvents should be set where the events
    //   array is initialized, and asserted against the maximum value.

    NumEvents = sizeof(hEvents) / sizeof(HANDLE);
    hStopEvent = *((HANDLE *) Param);
    hTracesReadyEvent = NULL;
    hParametersChangedEvent = NULL;
    NumPrefetcherThreads = 0;

    DBGPR((PFID,PFTRC,"PFSVC: MainThread()\n"));

    //
    // Initialize globals.
    //
    
    ErrorCode = PfSvInitializeGlobals();
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedInitGlobals\n"));
        goto cleanup;
    }

    //
    // Save service start time, prefetcher version etc.
    //

    PfSvSaveStartInfo(PfSvcGlobals.ServiceDataKey);

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedGetPrivileges\n"));
        goto cleanup;
    }

    //
    // Set permissions on the event that can be set to override
    // waiting for system to be idle before processing traces, so it
    // can be set by administrators.
    //

    ErrorCode = PfSvSetAdminOnlyPermissions(PFSVC_OVERRIDE_IDLE_EVENT_NAME,
                                            PfSvcGlobals.OverrideIdleProcessingEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions1\n"));
        goto cleanup;
    }

    ErrorCode = PfSvSetAdminOnlyPermissions(PFSVC_PROCESSING_COMPLETE_EVENT_NAME,
                                            PfSvcGlobals.ProcessingCompleteEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions2\n"));
        goto cleanup;
    }

    //
    // Get system prefetch parameters.
    //

    ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);

    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedQueryParameters\n"));
        goto cleanup;
    }

    //
    // Depending on system type, if various types of prefetching is
    // not specified in the registry (i.e. not specifically disabled),
    // enable it.
    //

    UpdatedParameters = FALSE;

    if (PfSvcGlobals.OsVersion.wProductType == VER_NT_WORKSTATION) {

        //
        // Enable all prefetching types if they are not disabled.
        //

        for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
            if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvNotSpecified) {
                PfSvcGlobals.Parameters.EnableStatus[ScenarioType] = PfSvEnabled;
                UpdatedParameters = TRUE;
            }
        }

    } else if (PfSvcGlobals.OsVersion.wProductType == VER_NT_SERVER ||
               PfSvcGlobals.OsVersion.wProductType == VER_NT_DOMAIN_CONTROLLER) {
        
        //
        // Enable only boot prefetching.
        //

        if (PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] == PfSvNotSpecified) {
            PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] = PfSvEnabled;
            UpdatedParameters = TRUE;
        }
    }

    //
    // If we enabled prefetching for a scenario type, call the kernel
    // to update the parameters.
    //
    
    if (UpdatedParameters) {

        ErrorCode = PfSvSetPrefetchParameters(&PfSvcGlobals.Parameters);

        if (ErrorCode != ERROR_SUCCESS) {
            DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetParameters\n"));
            goto cleanup;
        }
    }

    //
    // Continue only if prefetching for a scenario type is enabled.
    //

    PrefetchingEnabled = FALSE;

    for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
        if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvEnabled) {
            PrefetchingEnabled = TRUE;
            break;
        }
    }

    if (PrefetchingEnabled == FALSE) {
        ErrorCode = ERROR_NOT_SUPPORTED;
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-PrefetchingNotEnabled\n"));
        goto cleanup;
    }

    //
    // Initialize the directory that contains prefetch instructions.
    //

    ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);

    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedInitPrefetchDir\n"));
        goto cleanup;
    }
    
    //
    // Create the event that the kernel will set when raw traces are
    // available. Then set the event so that the first time into the loop we
    // will immediately process whatever raw traces are already waiting.
    //
    // The event is an autoclearing event, so it resets to the not-signaled
    // state when our wait is satisfied. This allows proper synchronization
    // with the kernel prefetcher.
    //

    hTracesReadyEvent = CreateEvent(NULL,
                                    FALSE,
                                    FALSE,
                                    PF_COMPLETED_TRACES_EVENT_WIN32_NAME);

    if (hTracesReadyEvent == NULL) {
        ErrorCode = GetLastError();
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedTracesReadyEvent\n"));
        goto cleanup;
    }

    SetEvent(hTracesReadyEvent);

    //
    // Create the event that the kernel will set when system prefetch
    // parameters change.
    //
    
    hParametersChangedEvent = CreateEvent(NULL,
                                          FALSE,
                                          FALSE,
                                          PF_PARAMETERS_CHANGED_EVENT_WIN32_NAME);

    if (hParametersChangedEvent == NULL) {
        ErrorCode = GetLastError();
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedParamsChangedEvent\n"));
        goto cleanup;
    }

    //
    // Set permissions on the events kernel uses to communicate with us.
    //

    ErrorCode = PfSvSetAdminOnlyPermissions(PF_COMPLETED_TRACES_EVENT_WIN32_NAME,
                                            hTracesReadyEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions3\n"));
        goto cleanup;
    }

    ErrorCode = PfSvSetAdminOnlyPermissions(PF_PARAMETERS_CHANGED_EVENT_WIN32_NAME,
                                            hParametersChangedEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions3\n"));
        goto cleanup;
    }

    //
    // Queue a work item to wait for the shell ready event and notify
    // the kernel.
    //

    QueueUserWorkItem(PfSvPollShellReadyWorker, NULL, WT_EXECUTELONGFUNCTION);

    //
    // Create a thread to process traces retrieved from the kernel.
    //

    PrefetcherThreads[NumPrefetcherThreads] = CreateThread(NULL,
                                                           0,
                                                           PfSvProcessTraceThread,
                                                           NULL,
                                                           0,
                                                           NULL);
    
    if (PrefetcherThreads[NumPrefetcherThreads]) {
        NumPrefetcherThreads++;
    }

    //
    // Register a notification routine with the idle task server.
    //

    ItSpSetProcessIdleTasksNotifyRoutine(PfSvProcessIdleTasksCallback);

    //
    // Set up handles we are going to wait on.
    //

    hEvents[0] = hStopEvent;
    hEvents[1] = hTracesReadyEvent;
    hEvents[2] = hParametersChangedEvent;
    hEvents[3] = PfSvcGlobals.CheckForMissedTracesEvent;

    //
    // This is the main loop. Wait on the events for work or for exit
    // signal.
    //

    bExitMainLoop = FALSE;
    
    do {

        DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-WaitForWork\n"));
        dwWait = WaitForMultipleObjects(NumEvents, hEvents, FALSE, INFINITE);
        DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-EndWaitForWork=%x\n",dwWait));
        
        switch(dwWait) {

        case WAIT_OBJECT_0:
            
            //
            // Service exit event:
            //

            //
            // Break out, cleanup and exit.
            //

            ErrorCode = ERROR_SUCCESS;
            bExitMainLoop = TRUE;

            break;

        case WAIT_OBJECT_0 + 3:

            //
            // The event that is set when we had max number of queued
            // traces and we processed one. We should check for traces
            // we could not pick up because the queue had maxed.
            //

            //
            // Fall through to retrieve traces from the kernel.
            //
            
        case WAIT_OBJECT_0 + 1:
            
            //
            // New traces are available event set by the kernel:
            //

            PfSvGetRawTraces();
            
            break;

        case WAIT_OBJECT_0 + 2:
            
            //
            // Prefetch parameters changed event:
            //

            //
            // Get new system prefetch parameters.
            //

            ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);
    
            //
            // If we were not successful, we should not continue.
            //
            
            if (ErrorCode != ERROR_SUCCESS) {
                bExitMainLoop = TRUE;
                DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedQueryParameters2\n"));
                break;
            }

            //
            // Update the path to the prefetch instructions directory.
            //
            
            ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);

            if (ErrorCode != ERROR_SUCCESS) {
                bExitMainLoop = TRUE;
                DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedReinitPrefetchDir\n"));
                break;
            }

            break;

        default:
            
            //
            // Something gone wrong. Break out, cleanup and exit.
            //

            DBGPR((PFID,PFERR,"PFSVC: MainThread()-WaitForWorkFailed\n"));
            ErrorCode = ERROR_INVALID_HANDLE;
            bExitMainLoop = TRUE;
            
            break;
        }

    } while (!bExitMainLoop);

 cleanup:

    //
    // If we could create this event, make sure it is signaled when the
    // service is exiting, so no one gets stuck on it.
    //

    if (PfSvcGlobals.ProcessingCompleteEvent) {
        SetEvent(PfSvcGlobals.ProcessingCompleteEvent);
    }

    //
    // Save exit information.
    //
    
    if (PfSvcGlobals.ServiceDataKey) {
        PfSvSaveExitInfo(PfSvcGlobals.ServiceDataKey, ErrorCode);
    }

    //
    // Make sure the terminate event is set and wait for all our
    // threads to exit.
    //

    if (NumPrefetcherThreads) {

        //
        // We could not have created worker threads without having
        // initialized the globals successfully.
        //

        PFSVC_ASSERT(PfSvcGlobals.TerminateServiceEvent);
        SetEvent(PfSvcGlobals.TerminateServiceEvent);

        for (ThreadIdx = 0; ThreadIdx < NumPrefetcherThreads; ThreadIdx++) {
            PFSVC_ASSERT(PrefetcherThreads[ThreadIdx]);

            DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-WaitForThreadIdx(%d)\n", ThreadIdx));

            WaitForSingleObject(PrefetcherThreads[ThreadIdx], INFINITE);

            DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-EndWaitForThreadIdx(%d)\n", ThreadIdx));

            CloseHandle(PrefetcherThreads[ThreadIdx]);
        }
    }

    if (hTracesReadyEvent != NULL) {
        CloseHandle(hTracesReadyEvent);
    }

    if (hParametersChangedEvent != NULL) {
        CloseHandle(hParametersChangedEvent);
    }

    //
    // Cleanup all globals.
    //

    PfSvCleanupGlobals();

    DBGPR((PFID,PFTRC,"PFSVC: MainThread()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Internal service routines:
//

//
// Thread routines:
//

DWORD 
WINAPI
PfSvProcessTraceThread(
    VOID *Param
    )

/*++

Routine Description:

    This is the routine for the thread that processes traces and
    updates scenarios.

Arguments:

    Param - Ignored.

Return Value:

    Win32 error code.

--*/

{
    PFSVC_IDLE_TASK LayoutTask;   
    PFSVC_IDLE_TASK DirectoryCleanupTask;
    PPFSVC_TRACE_BUFFER TraceBuffer;
    PLIST_ENTRY HeadEntry;
    HANDLE CheckForQueuedTracesEvents[3];
    HANDLE BootTraceEvents[2];
    DWORD ErrorCode;
    ULONG NumCheckForQueuedTracesEvents;
    ULONG OrgNumQueuedTraces;
    ULONG WaitResult;
    ULONG NumEvents;
    ULONG NumFailedTraces;
    BOOLEAN AcquiredTracesLock;

    //
    // Intialize locals.
    //

    TraceBuffer = NULL;
    AcquiredTracesLock = FALSE;
    PfSvInitializeTask(&LayoutTask);
    PfSvInitializeTask(&DirectoryCleanupTask);
    NumFailedTraces = 0;
    
    //
    // These are the events we wait on before picking up traces to
    // process. 
    //

    CheckForQueuedTracesEvents[0] = PfSvcGlobals.TerminateServiceEvent;
    CheckForQueuedTracesEvents[1] = PfSvcGlobals.NewTracesToProcessEvent;
    CheckForQueuedTracesEvents[2] = PfSvcGlobals.OverrideIdleProcessingEvent;
    NumCheckForQueuedTracesEvents = sizeof(CheckForQueuedTracesEvents) / sizeof(HANDLE);

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTraceThread()\n"));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If we are allowed to run the defragger...     
    // We'll update the layout file even if the registry setting prevents us
    // from launching the defragger.
    //
    if (PfSvAllowedToRunDefragger(FALSE)) {

        //
        // Queue an idle task to check & update the optimal disk layout if 
        // necessary. Ignore failure to do so.
        //

        ErrorCode = PfSvRegisterTask(&LayoutTask,
                                     ItOptimalDiskLayoutTaskId,
                                     PfSvCommonTaskCallback,
                                     PfSvUpdateOptimalLayout);

    }
  
    //
    // Loop forever waiting for traces to process and processing them.
    //

    while(TRUE) {
        
        //
        // Grab queued traces lock to check for queued traces.
        //

        PFSVC_ASSERT(!AcquiredTracesLock);
        PFSVC_ACQUIRE_LOCK(PfSvcGlobals.TracesLock);
        AcquiredTracesLock = TRUE;

        if (!IsListEmpty(&PfSvcGlobals.Traces)) {

            //
            // Dequeue and process the first entry in the list.
            //

            HeadEntry = RemoveHeadList(&PfSvcGlobals.Traces);

            TraceBuffer = CONTAINING_RECORD(HeadEntry,
                                            PFSVC_TRACE_BUFFER,
                                            TracesLink);
            
            
            PFSVC_ASSERT(PfSvcGlobals.NumTraces);
            OrgNumQueuedTraces = PfSvcGlobals.NumTraces;
            PfSvcGlobals.NumTraces--;
            
            //
            // Release the lock.
            //

            PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
            AcquiredTracesLock = FALSE;

            //
            // If we had maxed the queue, note to check for traces
            // that we may have failed to pick up because the queue
            // was full.
            //
            
            if (OrgNumQueuedTraces == PFSVC_MAX_NUM_QUEUED_TRACES) {
                SetEvent(PfSvcGlobals.CheckForMissedTracesEvent);

                //
                // Let the thread that queries the kernel for traces
                // wake up and run.
                //

                Sleep(0);
            }
            
            //
            // Clear the event that says we don't have traces to
            // process.
            //

            ResetEvent(PfSvcGlobals.ProcessingCompleteEvent);

            //
            // If this is a boot trace, wait for a little while for
            // boot to be really over before processing it.
            //

            if (TraceBuffer->Trace.ScenarioType == PfSystemBootScenarioType) {
                
                BootTraceEvents[0] = PfSvcGlobals.TerminateServiceEvent;
                BootTraceEvents[1] = PfSvcGlobals.OverrideIdleProcessingEvent;
                NumEvents = 2;
                
                PFSVC_ASSERT(NumEvents <= (sizeof(BootTraceEvents) / sizeof(HANDLE)));

                WaitResult = WaitForMultipleObjects(NumEvents,
                                                    BootTraceEvents,
                                                    FALSE,
                                                    45000); // 45 seconds.
                
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
            }

            ErrorCode = PfSvProcessTrace(&TraceBuffer->Trace);

            //
            // Update statistics.
            //

            PfSvcGlobals.NumTracesProcessed++;
            
            if (ErrorCode != ERROR_SUCCESS) {
                PfSvcGlobals.LastTraceFailure = ErrorCode;
            } else {
                PfSvcGlobals.NumTracesSuccessful++;
            }

            //
            // Free the trace buffer.
            //
        
            VirtualFree(TraceBuffer, 0, MEM_RELEASE);
            TraceBuffer = NULL;

            //
            // Did we just create too many scenario files in the prefetch directory?
            // Queue an idle task to clean up.
            //

            if (PfSvcGlobals.NumPrefetchFiles >= PFSVC_MAX_PREFETCH_FILES) {

                if (!DirectoryCleanupTask.Registered) {

                    //
                    // Make sure we've cleaned up after a possible previous run.
                    //

                    PfSvCleanupTask(&DirectoryCleanupTask);
                    PfSvInitializeTask(&DirectoryCleanupTask);

                    ErrorCode = PfSvRegisterTask(&DirectoryCleanupTask,
                                                 ItPrefetchDirectoryCleanupTaskId,
                                                 PfSvCommonTaskCallback,
                                                 PfSvCleanupPrefetchDirectory);
                }
            }

            //
            // Every so many scenario launches it is good to see if we should update
            // disk layout.
            //

            if (((PfSvcGlobals.NumTracesSuccessful + 1) % 32) == 0) {

                //
                // Even if we can't launch the defragger because of the 
                // registry setting, we'll update layout.ini, so if the user
                // manually launches the defragger it will optimize layout
                // as well.
                //

                if (PfSvAllowedToRunDefragger(FALSE)) {

                    if (!LayoutTask.Registered) {

                        //
                        // Make sure we've cleaned up after a possible previous run.
                        //

                        PfSvCleanupTask(&LayoutTask);
                        PfSvInitializeTask(&LayoutTask);

                        ErrorCode = PfSvRegisterTask(&LayoutTask,
                                                     ItOptimalDiskLayoutTaskId,
                                                     PfSvCommonTaskCallback,
                                                     PfSvUpdateOptimalLayout);
                    }
                }
            }

        } else {
            
            //
            // The list is empty. Signal that we are done with all the
            // queued traces if we don't have idle tasks to complete.
            //
            
            if (!LayoutTask.Registered && 
                !DirectoryCleanupTask.Registered) {

                SetEvent(PfSvcGlobals.ProcessingCompleteEvent);
            }

            //
            // Release the lock.
            //

            PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
            AcquiredTracesLock = FALSE;

            //
            // Update the statistics if there were new failed traces.
            //

            // FUTURE-2002/03/29-ScottMa -- The statistics are not updated
            //   unless there were new failed traces, therefore the logged
            //   values for number of traces processed is stale.

            if (NumFailedTraces != (PfSvcGlobals.NumTracesProcessed - 
                                    PfSvcGlobals.NumTracesSuccessful)) {

                NumFailedTraces = PfSvcGlobals.NumTracesProcessed - 
                                  PfSvcGlobals.NumTracesSuccessful;
                                  
                PfSvSaveTraceProcessingStatistics(PfSvcGlobals.ServiceDataKey);
            }

            //
            // Wait until new traces are queued.
            //
           
            DBGPR((PFID,PFWAIT,"PFSVC: ProcessTraceThread()-WaitForTrace\n"));

            NumEvents = NumCheckForQueuedTracesEvents;

            WaitResult = WaitForMultipleObjects(NumEvents,
                                                CheckForQueuedTracesEvents,
                                                FALSE,
                                                INFINITE);

            DBGPR((PFID,PFWAIT,"PFSVC: ProcessTraceThread()-EndWaitForTrace=%x\n", WaitResult));

            switch(WaitResult) {

            case WAIT_OBJECT_0:
                
                //
                // Service exit event:
                //

                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

                break;

            case WAIT_OBJECT_0 + 1:
                
                //
                // New traces queued for processing event:
                //

                break;

            case WAIT_OBJECT_0 + 2:
                
                //
                // Idle detection was overriden. If we had registered tasks
                // to be run, we will unregister them and run them manually.
                //

                PfSvSaveTraceProcessingStatistics(PfSvcGlobals.ServiceDataKey);

                if (LayoutTask.Registered) {
                    PfSvUnregisterTask(&LayoutTask, FALSE);
                    PfSvCleanupTask(&LayoutTask);
                    PfSvInitializeTask(&LayoutTask);

                    PfSvUpdateOptimalLayout(NULL);
                }

                if (DirectoryCleanupTask.Registered) {
                    PfSvUnregisterTask(&DirectoryCleanupTask, FALSE);
                    PfSvCleanupTask(&DirectoryCleanupTask);
                    PfSvInitializeTask(&DirectoryCleanupTask);

                    PfSvCleanupPrefetchDirectory(NULL);
                }

                //
                // We will drop out of this block, check & process queued traces
                // and then set the processing complete event.
                //

                break;

            default:

                //
                // Something went wrong...
                //
                
                ErrorCode = ERROR_INVALID_HANDLE;
                goto cleanup;
            }
        }

        //
        // Loop to check if there are new traces.
        //
    }

    //
    // We should not break out of the loop.
    //

    PFSVC_ASSERT(FALSE);

    ErrorCode = ERROR_INVALID_FUNCTION;
    
 cleanup:

    if (AcquiredTracesLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
    }

    if (TraceBuffer) {
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }

    PfSvUnregisterTask(&LayoutTask, FALSE);
    PfSvCleanupTask(&LayoutTask);

    PfSvUnregisterTask(&DirectoryCleanupTask, FALSE);
    PfSvCleanupTask(&DirectoryCleanupTask);

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTraceThread()=%x\n", ErrorCode));

    return ErrorCode;
}

DWORD 
WINAPI
PfSvPollShellReadyWorker(
    VOID *Param
    )

/*++

Routine Description:

    This is the routine for the thread that is spawned to poll the
    ShellReadyEvent.

Arguments:

    Param - Ignored.

Return Value:

    Win32 error code.

--*/

{
    HANDLE ShellReadyEvent;
    HANDLE Events[2];
    ULONG NumEvents;
    ULONG PollPeriod;
    ULONG TotalPollPeriod;
    DWORD WaitResult;
    DWORD ErrorCode;
    NTSTATUS Status;
    PREFETCHER_INFORMATION PrefetcherInformation;
    PF_BOOT_PHASE_ID PhaseId;
    
    //
    // Initialize locals.
    //
    
    ShellReadyEvent = NULL;
    Events[0] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 1;

    DBGPR((PFID,PFTRC,"PFSVC: PollShellReadyThread()\n"));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Until we can open the shell ready event, wait on the service
    // termination event and retry every PollPeriod milliseconds.
    //

    PollPeriod = 1000;
    TotalPollPeriod = 0;

    do {
        
        //
        // Try to open the shell ready event.
        //

        // FUTURE-2002/03/29-ScottMa -- The EVENT_ALL_ACCESS flag only needs
        //   to be SYNCHRONIZE, following the principle of least privelege.

        ShellReadyEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"ShellReadyEvent");
        
        if (ShellReadyEvent) {
            break;
        }
        
        //
        // Wait for a while.
        //

        DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-WaitForOpen\n"));

        WaitResult = WaitForMultipleObjects(NumEvents,
                                            Events,
                                            FALSE,
                                            PollPeriod);

        DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-EndWaitForOpen=%d\n", WaitResult));

        switch(WaitResult) {

        case WAIT_OBJECT_0:
            
            //
            // Service exit event:
            //

            ErrorCode = ERROR_PROCESS_ABORTED;
            goto cleanup;

            break;
            
        case WAIT_TIMEOUT:
            
            //
            // Fall through and try opening the shell ready event again.
            //
            
            break;

        default:
            
            //
            // Something gone wrong. Break out, cleanup and exit.
            //

            ErrorCode = ERROR_INVALID_HANDLE;
            goto cleanup;
        }

        TotalPollPeriod += PollPeriod;

    } while (TotalPollPeriod < 180000);

    //
    // If we could not get the ShellReadyEvent, we timed out.
    //

    if (ShellReadyEvent == NULL) {
        ErrorCode = ERROR_TIMEOUT;
        goto cleanup;
    }

    //
    // Wait on the ShellReadyEvent to be signaled.
    //

    Events[NumEvents] = ShellReadyEvent;
    NumEvents++;

    DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-WaitForShell\n"));

    WaitResult = WaitForMultipleObjects(NumEvents,
                                        Events,
                                        FALSE,
                                        60000);

    DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-EndWaitForShell=%d\n",WaitResult));

    switch (WaitResult) {

    case WAIT_OBJECT_0:
            
        //
        // Service exit event:
        //
        
        ErrorCode = ERROR_PROCESS_ABORTED;
        goto cleanup;
        
        break;
        
    case WAIT_OBJECT_0 + 1:
        
        //
        // Shell ready event got signaled. Let the kernel mode
        // prefetcher know.
        //

        PhaseId = PfUserShellReadyPhase;

        PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
        PrefetcherInformation.Version = PF_CURRENT_VERSION;
        PrefetcherInformation.PrefetcherInformationClass = PrefetcherBootPhase;
        PrefetcherInformation.PrefetcherInformation = &PhaseId;
        PrefetcherInformation.PrefetcherInformationLength = sizeof(PhaseId);
            
        Status = NtSetSystemInformation(SystemPrefetcherInformation,
                                        &PrefetcherInformation,
                                        sizeof(PrefetcherInformation));
                    
        //
        // Fall through with the status.
        //
        
        ErrorCode = RtlNtStatusToDosError(Status);

        break;

    case WAIT_TIMEOUT:

        //
        // Shell ready event was created but not signaled...
        //

        ErrorCode = ERROR_TIMEOUT;

        break;
        
    default:
        
        //
        // Something gone wrong.
        //
        
        ErrorCode = GetLastError();

        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = ERROR_INVALID_FUNCTION;
        }
    }

    //
    // Fall through with status from the switch statement.
    //

 cleanup:
    
    if (ShellReadyEvent) {
        CloseHandle(ShellReadyEvent);
    }

    DBGPR((PFID,PFTRC,"PFSVC: PollShellReadyThread()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Routines called by the main prefetcher thread.
//

DWORD 
PfSvGetRawTraces(
    VOID
    )

/*++

Routine Description:

    This routine checks for new traces prepared by the kernel. The new
    traces are downloaded and queued so they can be processed.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;
    PPFSVC_TRACE_BUFFER TraceBuffer;
    ULONG TraceBufferMaximumLength;
    ULONG TraceBufferLength;
    PREFETCHER_INFORMATION PrefetcherInformation;
    ULONG NumTracesRetrieved;
    ULONG FailedCheck;

    //
    // Initialize locals.
    //

    TraceBuffer = NULL;
    TraceBufferMaximumLength = 0;
    NumTracesRetrieved = 0;

    DBGPR((PFID,PFTRC,"PFSVC: GetRawTraces()\n"));

    //
    // Clear the event that asks us to check for more traces.
    //
    
    ResetEvent(PfSvcGlobals.CheckForMissedTracesEvent);

    //
    // While we do not already have too many traces to process, get
    // traces from the kernel.
    //    

    while (PfSvcGlobals.NumTraces < PFSVC_MAX_NUM_QUEUED_TRACES) { 

        //
        // Retrieve a trace from the kernel.
        //

        PrefetcherInformation.Version = PF_CURRENT_VERSION;
        PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
        PrefetcherInformation.PrefetcherInformationClass = PrefetcherRetrieveTrace;
        PrefetcherInformation.PrefetcherInformation = &TraceBuffer->Trace;

        if (TraceBufferMaximumLength <= FIELD_OFFSET(PFSVC_TRACE_BUFFER, Trace)) {
            PrefetcherInformation.PrefetcherInformationLength = 0;
        } else {
            PrefetcherInformation.PrefetcherInformationLength = 
                TraceBufferMaximumLength - FIELD_OFFSET(PFSVC_TRACE_BUFFER, Trace);
        }

        Status = NtQuerySystemInformation(SystemPrefetcherInformation,
                                          &PrefetcherInformation,
                                          sizeof(PrefetcherInformation),
                                          &TraceBufferLength);

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_BUFFER_TOO_SMALL) {

                if (TraceBuffer != NULL) {
                    VirtualFree(TraceBuffer, 0, MEM_RELEASE);
                }
                
                //
                // Add room for the header we wrap over it.
                //              

                TraceBufferLength += sizeof(PFSVC_TRACE_BUFFER) - sizeof(PF_TRACE_HEADER);

                TraceBufferMaximumLength = ROUND_TRACE_BUFFER_SIZE(TraceBufferLength);  

                TraceBuffer = VirtualAlloc(NULL,
                                           TraceBufferMaximumLength,
                                           MEM_COMMIT,
                                           PAGE_READWRITE);
                if (TraceBuffer == NULL) {
                    ErrorCode = GetLastError();
                    goto cleanup;
                }

                continue;

            } else if (Status == STATUS_NO_MORE_ENTRIES) {

                break;
            }

            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }

#ifdef PFSVC_DBG

        //
        // Write out the trace to a file:
        //

        if (PfSvcDbgMaxNumSavedTraces) {

            WCHAR TraceFilePath[MAX_PATH + 1];
            LONG NumChars;

            //
            // Build up a file name.
            //

            InterlockedIncrement(&PfSvcDbgTraceNumber);

            PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);

            NumChars = _snwprintf(TraceFilePath,
                                  MAX_PATH,
                                  L"%ws\\%ws%d.trc",
                                  PfSvcGlobals.PrefetchRoot,
                                  PfSvcDbgTraceBaseName,
                                  PfSvcDbgTraceNumber % PfSvcDbgMaxNumSavedTraces);

            PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
            
            if (NumChars > 0 && NumChars < MAX_PATH) {
                
                //
                // Make sure the path is terminated.
                //

                TraceFilePath[MAX_PATH - 1] = 0;
                
                //
                // Write out the trace.
                //
                
                PfSvWriteBuffer(TraceFilePath, 
                                &TraceBuffer->Trace, 
                                TraceBuffer->Trace.Size);
            }
        }

#endif // PFSVC_DBG

        //
        // Verify integrity of the trace.
        //

        if (!PfVerifyTraceBuffer(&TraceBuffer->Trace, 
                                 TraceBuffer->Trace.Size, 
                                 &FailedCheck)) {
            DBGPR((PFID,PFWARN,"PFSVC: IGNORING TRACE\n"));
            continue;
        }

        //
        // Put it on the list of traces to process.
        //
        
        PFSVC_ACQUIRE_LOCK(PfSvcGlobals.TracesLock);

        InsertTailList(&PfSvcGlobals.Traces, &TraceBuffer->TracesLink);
        PfSvcGlobals.NumTraces++;

        PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);

        //
        // Notify that there are new traces to process.
        //

        SetEvent(PfSvcGlobals.NewTracesToProcessEvent);

        //
        // Clean out the loop variables.
        //
        
        TraceBuffer = NULL;
        TraceBufferMaximumLength = 0;
        TraceBufferLength = 0;

        NumTracesRetrieved++;
    }
    
    //
    // We should never go above the limit of queued traces.
    //
    
    PFSVC_ASSERT(PfSvcGlobals.NumTraces <= PFSVC_MAX_NUM_QUEUED_TRACES);
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (TraceBuffer != NULL) {
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetRawTraces()=%x,%d\n", ErrorCode, NumTracesRetrieved));

    return ErrorCode;
}

DWORD
PfSvInitializeGlobals(
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables / tables etc.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG FileIdx;
    WCHAR *CSCRootPath;
    ULONG CSCRootPathMaxChars;

    //
    // These are the path suffices to recognize files we don't want to 
    // prefetch for boot. Keep these sorted lexically going from
    // LAST CHARACTER TO FIRST and UPCASE.
    //

    static WCHAR *FilesToIgnoreForBoot[] = {
           L"SYSTEM32\\CONFIG\\SOFTWARE",
                     L"\\WMI\\TRACE.LOG",
       L"SYSTEM32\\CONFIG\\SOFTWARE.LOG",
            L"SYSTEM32\\CONFIG\\SAM.LOG",
         L"SYSTEM32\\CONFIG\\SYSTEM.LOG",
        L"SYSTEM32\\CONFIG\\DEFAULT.LOG",
       L"SYSTEM32\\CONFIG\\SECURITY.LOG",
                           L"\\PERF.ETL",
                L"SYSTEM32\\CONFIG\\SAM",
             L"SYSTEM32\\CONFIG\\SYSTEM",
         L"SYSTEM32\\CONFIG\\SYSTEM.ALT",
            L"SYSTEM32\\CONFIG\\DEFAULT",
           L"SYSTEM32\\CONFIG\\SECURITY",
    };

    DBGPR((PFID,PFTRC,"PFSVC: InitializeGlobals()\n"));

    //
    // Initialize locals.
    //

    CSCRootPath = NULL;
    
    //
    // Zero out the globals structure so we know what to cleanup if
    // the initialization fails in the middle.
    //

    RtlZeroMemory(&PfSvcGlobals, sizeof(PfSvcGlobals));

    //
    // Initialize the list of traces to be processed.
    //
    
    InitializeListHead(&PfSvcGlobals.Traces);
    PfSvcGlobals.NumTraces = 0;

    //
    // We have not launched the defragger for anything yet.
    //

    PfSvcGlobals.DefraggerErrorCode = ERROR_SUCCESS;

    //
    // Initialize table for registry files that we don't want to
    // prefetch for boot.
    //

    PfSvcGlobals.FilesToIgnoreForBoot = FilesToIgnoreForBoot;
    PfSvcGlobals.NumFilesToIgnoreForBoot = 
        sizeof(FilesToIgnoreForBoot) / sizeof(WCHAR *);

    //
    // Get OS version information.
    //

    RtlZeroMemory(&PfSvcGlobals.OsVersion, sizeof(PfSvcGlobals.OsVersion));
    PfSvcGlobals.OsVersion.dwOSVersionInfoSize = sizeof(PfSvcGlobals.OsVersion);
    Status = RtlGetVersion((PRTL_OSVERSIONINFOW)&PfSvcGlobals.OsVersion);

    if (!NT_SUCCESS(Status)) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedGetOSVersion\n"));
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

   
    //
    // Initialize the table of ignored files' suffix lengths.
    //
  
    PfSvcGlobals.FileSuffixLengths = 
        PFSVC_ALLOC(PfSvcGlobals.NumFilesToIgnoreForBoot * sizeof(ULONG));

    if (!PfSvcGlobals.FileSuffixLengths) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    for (FileIdx = 0; 
         FileIdx < PfSvcGlobals.NumFilesToIgnoreForBoot; 
         FileIdx++) {
        
        PfSvcGlobals.FileSuffixLengths[FileIdx] = 
            wcslen(PfSvcGlobals.FilesToIgnoreForBoot[FileIdx]);
    }   

    //
    // Create an event that will get signaled when the service is
    // exiting.
    //

    PfSvcGlobals.TerminateServiceEvent = CreateEvent(NULL,
                                                     TRUE,
                                                     FALSE,
                                                     NULL);
    
    if (PfSvcGlobals.TerminateServiceEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the lock for the list of traces to be processed.
    //
    
    PfSvcGlobals.TracesLock = CreateMutex(NULL, FALSE, NULL);
    if (PfSvcGlobals.TracesLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the events that are used to communicate between the
    // acquirer and processor of the traces.
    //
    
    PfSvcGlobals.NewTracesToProcessEvent = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);
    if (PfSvcGlobals.NewTracesToProcessEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    PfSvcGlobals.CheckForMissedTracesEvent = CreateEvent(NULL,
                                                         FALSE,
                                                         FALSE,
                                                         NULL);
    if (PfSvcGlobals.CheckForMissedTracesEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // This named manual-reset event can be set to force all traces to
    // be processed as soon as they become available rather than
    // waiting for the system to become idle first.
    //

    // NOTICE-2002/03/29-ScottMa -- Have we considered the impact of squatting
    //   on all the named events used in the code?

    PfSvcGlobals.OverrideIdleProcessingEvent = CreateEvent(NULL,
                                                           TRUE,
                                                           FALSE,
                                                           PFSVC_OVERRIDE_IDLE_EVENT_NAME);
    if (PfSvcGlobals.OverrideIdleProcessingEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // This named manual-reset event is created signaled. When this
    // event is signaled, it means there are no traces we have to
    // process now.
    //

    PfSvcGlobals.ProcessingCompleteEvent = CreateEvent(NULL,
                                                       TRUE,
                                                       TRUE,
                                                       PFSVC_PROCESSING_COMPLETE_EVENT_NAME);

    if (PfSvcGlobals.ProcessingCompleteEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    //
    // Initialize prefetch root path and the lock to protect it. The
    // real root path will be initialized after parameters are queried
    // from the kernel.
    //

    PfSvcGlobals.PrefetchRoot[0] = 0;
    PfSvcGlobals.PrefetchRootLock = CreateMutex(NULL, FALSE, NULL);
    if (PfSvcGlobals.PrefetchRootLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    PfSvcGlobals.NumPrefetchFiles = 0;

    //
    // Open the service data registry key, creating it if necessary.
    //

    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_SERVICE_DATA_KEY,
                             &PfSvcGlobals.ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Check the registry to see if the user does not want us to run 
    // the defragger.
    //

    ErrorCode = PfSvGetDontRunDefragger(&PfSvcGlobals.DontRunDefragger);

    if (ErrorCode != ERROR_SUCCESS) {

        //
        // By default we will run the defragger.
        //
    
        PfSvcGlobals.DontRunDefragger = FALSE;
    }

    //
    // Determine CSC root path. It won't be used if we can't allocate or 
    // determine it, so don't worry about the error code.
    //

    CSCRootPathMaxChars = MAX_PATH + 1;
    CSCRootPath = PFSVC_ALLOC(CSCRootPathMaxChars * sizeof(CSCRootPath[0]));

    if (CSCRootPath) {

        ErrorCode = PfSvGetCSCRootPath(CSCRootPath, CSCRootPathMaxChars);

        if (ErrorCode == ERROR_SUCCESS) {
            PfSvcGlobals.CSCRootPath = CSCRootPath;
            CSCRootPath = NULL;
        }
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: InitializeGlobals()=%x\n", ErrorCode));

    if (CSCRootPath) {
        PFSVC_FREE(CSCRootPath);
    }

    return ErrorCode;
}

VOID
PfSvCleanupGlobals(
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the global variables / tables etc.

Arguments:

    None.

Return Value:

    VOID

--*/

{
    PPFSVC_TRACE_BUFFER TraceBuffer;
    PLIST_ENTRY ListHead;

    DBGPR((PFID,PFTRC,"PFSVC: CleanupGlobals()\n"));

    //
    // Free allocated table.
    //

    if (PfSvcGlobals.FileSuffixLengths) {
        PFSVC_FREE(PfSvcGlobals.FileSuffixLengths);
    }
    
    //
    // Free queued traces.
    //
    
    while (!IsListEmpty(&PfSvcGlobals.Traces)) {

        ListHead = RemoveHeadList(&PfSvcGlobals.Traces);
        
        PFSVC_ASSERT(PfSvcGlobals.NumTraces);
        PfSvcGlobals.NumTraces--;

        TraceBuffer = CONTAINING_RECORD(ListHead,
                                        PFSVC_TRACE_BUFFER,
                                        TracesLink);
        
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }
    
    //
    // Close handles to opened events/mutexes.
    //
    
    if (PfSvcGlobals.TerminateServiceEvent) {
        CloseHandle(PfSvcGlobals.TerminateServiceEvent);
    }
    
    if (PfSvcGlobals.TracesLock) {
        CloseHandle(PfSvcGlobals.TracesLock);
    }

    if (PfSvcGlobals.NewTracesToProcessEvent) {
        CloseHandle(PfSvcGlobals.NewTracesToProcessEvent);
    }
    
    if (PfSvcGlobals.CheckForMissedTracesEvent) {
        CloseHandle(PfSvcGlobals.CheckForMissedTracesEvent);
    }

    if (PfSvcGlobals.OverrideIdleProcessingEvent) {
        CloseHandle(PfSvcGlobals.OverrideIdleProcessingEvent);
    }

    if (PfSvcGlobals.ProcessingCompleteEvent) {
        CloseHandle(PfSvcGlobals.ProcessingCompleteEvent);
    }
    
    if (PfSvcGlobals.PrefetchRootLock) {
        CloseHandle(PfSvcGlobals.PrefetchRootLock);
    }

    //
    // Close service data key handle.
    //
    
    if (PfSvcGlobals.ServiceDataKey) {
        RegCloseKey(PfSvcGlobals.ServiceDataKey);
    }

    //
    // Free CSC root path.
    //

    if (PfSvcGlobals.CSCRootPath) {
        PFSVC_FREE(PfSvcGlobals.CSCRootPath);
    }
}

DWORD
PfSvGetCSCRootPath (
    WCHAR *CSCRootPath,
    ULONG CSCRootPathMaxChars
    )

/*++

Routine Description:

    This routine determines the root path for CSC (client side caching) files.

Arguments:

    CSCRootPath - If successful, a NUL terminated string is copied into this buffer.

    CSCRootPathMaxChars - Maximum characters we can copy into CSCRootPath 
      buffer including the terminating NUL.
    
Return Value:

    Win32 error code.

--*/

{
    WCHAR CSCDirName[] = L"CSC";
    HKEY CSCKeyHandle;
    ULONG WindowsDirectoryLength;
    ULONG CSCRootPathLength;
    ULONG RequiredNumChars;
    DWORD ErrorCode;
    DWORD BufferSize;
    DWORD ValueType;

    //
    // Initialize locals.
    //

    CSCKeyHandle = NULL;

    //
    // Open CSC parameters key.
    //

    ErrorCode = RegOpenKey(HKEY_LOCAL_MACHINE,
                           TEXT(REG_STRING_NETCACHE_KEY_A),
                           &CSCKeyHandle);

    if (ErrorCode == ERROR_SUCCESS) {

        //
        // Query system setting for the CSC root path.
        //

        BufferSize = CSCRootPathMaxChars * sizeof(CSCRootPath[0]);

        ErrorCode = RegQueryValueEx(CSCKeyHandle,
                                    TEXT(REG_STRING_DATABASE_LOCATION_A),
                                    NULL,
                                    &ValueType,
                                    (PVOID)CSCRootPath,
                                    &BufferSize);

        if (ErrorCode == ERROR_SUCCESS) {

            //
            // Sanity check the length.
            //

            if ((BufferSize / sizeof(CSCRootPath[0])) < MAX_PATH) {

                //
                // Make sure the buffer is NUL terminated.
                //

                CSCRootPath[CSCRootPathMaxChars-1] = 0;
                
                //
                // We got what we wanted. Make sure it has room for and is terminated 
                // by a slash.
                //

                CSCRootPathLength = wcslen(CSCRootPath);

                if (CSCRootPathLength < CSCRootPathMaxChars - 1) {

                    if (CSCRootPath[CSCRootPathLength - 1] != L'\\') {
                        CSCRootPath[CSCRootPathLength] = L'\\';
                        CSCRootPathLength++;
                        CSCRootPath[CSCRootPathLength] = L'\0';
                    }
                    
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
            }
        }
    }
                               
    //
    // If we come here, we have to use the default CSC path i.e. %windir%\CSC
    //

    WindowsDirectoryLength = GetWindowsDirectory(CSCRootPath,
                                                 CSCRootPathMaxChars - 1);

    if (WindowsDirectoryLength == 0) {

        //
        // There was an error.
        //

        ErrorCode = GetLastError();
        PFSVC_ASSERT(ErrorCode != ERROR_SUCCESS);
        goto cleanup;
    }

    //
    // See if we have room to add \CSC\ and a terminating NUL.
    //

    RequiredNumChars = WindowsDirectoryLength;
    RequiredNumChars ++;                                // leading backslash.
    RequiredNumChars += wcslen(CSCDirName);             // CSC.
    RequiredNumChars ++;                                // ending backslash.
    RequiredNumChars ++;                                // terminating NUL.

    if (CSCRootPathMaxChars < RequiredNumChars) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Build up the path:
    //

    CSCRootPathLength = WindowsDirectoryLength;

    if (CSCRootPath[CSCRootPathLength - 1] != L'\\') {
        CSCRootPath[CSCRootPathLength] = L'\\';
        CSCRootPathLength++;
    }

    wcscpy(CSCRootPath + CSCRootPathLength, CSCDirName);
    CSCRootPathLength += wcslen(CSCDirName);

    CSCRootPath[CSCRootPathLength] = L'\\';
    CSCRootPathLength++;

    //
    // Terminate the string.
    //

    CSCRootPath[CSCRootPathLength] = L'\0';
    
    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    if (CSCKeyHandle) {
        RegCloseKey(CSCKeyHandle);
    }

    if (ErrorCode == ERROR_SUCCESS) {

        //
        // We have the path in CSCRootPath. It should be in the X:\path\
        // format. It should also be somewhat long, otherwise we will mismatch
        // to too many files that we will not prefetch. It should also be
        // terminated by a \ and NUL.
        //

        PFSVC_ASSERT(CSCRootPathLength < CSCRootPathMaxChars);

        if ((CSCRootPathLength > 6) &&
            (CSCRootPath[1] == L':') &&
            (CSCRootPath[2] == L'\\') &&
            (CSCRootPath[CSCRootPathLength - 1] == L'\\') &&
            (CSCRootPath[CSCRootPathLength] == L'\0')) {

            //
            // Remove the X: from the beginning of the path so we can match
            // it to NT paths like \Device\HarddiskVolume1. Note that we have 
            // to move the terminating NUL too.
            //

            MoveMemory(CSCRootPath, 
                       CSCRootPath + 2, 
                       (CSCRootPathLength - 1) * sizeof(CSCRootPath[0]));

            CSCRootPathLength -= 2;

            //
            // Upcase the path so we don't have to do expensive case insensitive
            // comparisons.
            //

            _wcsupr(CSCRootPath);

        } else {

            ErrorCode = ERROR_BAD_FORMAT;
        }
    }

    return ErrorCode;
}

DWORD
PfSvSetPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine updates the system prefetch parameters in the kernel.

Arguments:

    Parameters - Pointer to parameters structure.
    
Return Value:

    Win32 error code.

--*/

{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    DWORD ErrorCode;

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherSystemParameters;
    PrefetcherInformation.PrefetcherInformation = Parameters;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(*Parameters);
    
    Status = NtSetSystemInformation(SystemPrefetcherInformation,
                                    &PrefetcherInformation,
                                    sizeof(PrefetcherInformation));
    
    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

DWORD
PfSvQueryPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine queries the system prefetch parameters from the kernel.
    The calling thread must have called PfSvGetPrefetchServiceThreadPrivileges.

Arguments:

    Parameters - Pointer to structure to update.
    
Return Value:

    Win32 error code.

--*/

{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG Length;

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherSystemParameters;
    PrefetcherInformation.PrefetcherInformation = Parameters;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(*Parameters);
    
    Status = NtQuerySystemInformation(SystemPrefetcherInformation,
                                      &PrefetcherInformation,
                                      sizeof(PrefetcherInformation),
                                      &Length);


    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

DWORD
PfSvInitializePrefetchDirectory(
    WCHAR *PathFromSystemRoot
    )

/*++

Routine Description:

    This routine builds up full path for the prefetch instructions
    directory given PathFromSystemRoot, makes sure this directory
    exists, and sets the security information on it. Finally, the
    global PrefetchRoot path is updated with path to the new
    directory.

    Global NumPrefetchFiles is also updated.

    The calling thread must have the SE_TAKE_OWNERSHIP_NAME privilege.

Arguments:

    PathFromSystemRoot - Path to the prefetch directory from SystemRoot.

Return Value:

    Win32 error code.

--*/

{
    ULONG PathLength;
    ULONG NumFiles;
    HANDLE DirHandle;
    DWORD ErrorCode;
    DWORD FileAttributes;
    WCHAR FullDirPathBuffer[MAX_PATH + 1];
   
    //
    // Initialize locals.
    //

    DirHandle = INVALID_HANDLE_VALUE;

    DBGPR((PFID,PFTRC,"PFSVC: InitPrefetchDir(%ws)\n",PathFromSystemRoot));
    
    //
    // Build path name to the prefetch files directory.
    // ExpandEnvironmentStrings return length includes space for
    // the terminating NUL character.
    //

    PathLength = ExpandEnvironmentStrings(L"%SystemRoot%\\",
                                          FullDirPathBuffer,
                                          MAX_PATH);


    PathLength += wcslen(PathFromSystemRoot);
    
    if (PathLength > MAX_PATH) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Copy the path from system root.
    //

    wcscat(FullDirPathBuffer, PathFromSystemRoot);

    //
    // Create the directory if it does not already exist.
    //
    
    if (!CreateDirectory(FullDirPathBuffer, NULL)) {
        
        ErrorCode = GetLastError();
        
        if (ErrorCode == ERROR_ALREADY_EXISTS) {
            
            //
            // The directory, or a file with that name may already
            // exist. Make sure it is the former.
            //
            
            FileAttributes = GetFileAttributes(FullDirPathBuffer);
            
            if (FileAttributes == INVALID_FILE_ATTRIBUTES) {
                ErrorCode = GetLastError();
                goto cleanup;
            }
            
            if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                ErrorCode = ERROR_CANNOT_MAKE;
                goto cleanup;
            }

        } else {
            goto cleanup;
        }
    }

    //
    // Disable indexing of the prefetch directory.
    //

    FileAttributes = GetFileAttributes(FullDirPathBuffer);
    
    if (FileAttributes == INVALID_FILE_ATTRIBUTES) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!SetFileAttributes(FullDirPathBuffer,
                           FileAttributes | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set permissions.
    //

    ErrorCode = PfSvSetAdminOnlyPermissions(FullDirPathBuffer, NULL, SE_FILE_OBJECT);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Count the scenario files in the directory.
    //

    ErrorCode = PfSvCountFilesInDirectory(FullDirPathBuffer,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Update the global prefetch root directory path.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    
    wcscpy(PfSvcGlobals.PrefetchRoot, FullDirPathBuffer);
    PfSvcGlobals.NumPrefetchFiles = NumFiles;

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: InitPrefetchDir(%ws)=%x\n",PathFromSystemRoot,ErrorCode));

    return ErrorCode;           
}

DWORD
PfSvCountFilesInDirectory(
    WCHAR *DirectoryPath,
    WCHAR *MatchExpression,
    PULONG NumFiles
    )

/*++

Routine Description:

    This is routine returns the number of files in the specified 
    directory whose names match the specified expression.

Arguments:

    DirectoryPath - NULL terminated path to the directory.

    MatchExpression - Something like "*.pf" Don't go nuts with DOS
      type expressions, this function won't try to transmogrify them.

    NumFiles - Number of files are returned here. Bogus if returned error.

Return Value:

    Win32 error code.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DirectoryPathU;
    UNICODE_STRING MatchExpressionU;
    HANDLE DirectoryHandle;
    PVOID QueryBuffer;
    PFILE_NAMES_INFORMATION FileInfo;
    ULONG QueryBufferSize;
    ULONG FileCount;
    NTSTATUS Status;
    DWORD ErrorCode;
    BOOLEAN Success;
    BOOLEAN AllocatedDirectoryPathU;
    BOOLEAN OpenedDirectory;
    BOOLEAN RestartScan;

    //
    // Initialize locals.
    //

    AllocatedDirectoryPathU = FALSE;
    OpenedDirectory = FALSE;
    QueryBuffer = NULL;
    QueryBufferSize = 0;
    RtlInitUnicodeString(&MatchExpressionU, MatchExpression);

    DBGPR((PFID,PFTRC,"PFSVC: CountFilesInDirectory(%ws,%ws)\n", DirectoryPath, MatchExpression));

    //
    // Convert the path to NT path.
    //

    Success = RtlDosPathNameToNtPathName_U(DirectoryPath,
                                           &DirectoryPathU,
                                           NULL,
                                           NULL);

    if (!Success) {
        ErrorCode = ERROR_PATH_NOT_FOUND;
        goto cleanup;
    }

    AllocatedDirectoryPathU = TRUE;

    //
    // Open the directory.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               &DirectoryPathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&DirectoryHandle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | 
                          FILE_SYNCHRONOUS_IO_NONALERT | 
                          FILE_OPEN_FOR_BACKUP_INTENT);

    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    OpenedDirectory = TRUE;

    //
    // Allocate a decent sized query buffer.
    //

    QueryBufferSize = sizeof(FILE_NAMES_INFORMATION) + MAX_PATH * sizeof(WCHAR);
    QueryBufferSize *= 16;
    QueryBuffer = PFSVC_ALLOC(QueryBufferSize);

    if (!QueryBuffer) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Loop querying file data. We query FileNamesInformation so
    // we don't have to access file metadata.
    //

    RestartScan = TRUE;
    FileCount = 0;

    while (TRUE) {

        Status = NtQueryDirectoryFile(DirectoryHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      QueryBuffer,
                                      QueryBufferSize,
                                      FileNamesInformation,
                                      FALSE,
                                      &MatchExpressionU,
                                      RestartScan);

        RestartScan = FALSE;

        //
        // If there are no files that match the format, then we'll get 
        // STATUS_NO_SUCH_FILE.
        //

        if (Status == STATUS_NO_SUCH_FILE && (FileCount == 0)) {

            //
            // We'll return the fact that there are no such files in the
            // directory.
            //

            break;
        }

        if (Status == STATUS_NO_MORE_FILES) {

            //
            // We are done.
            //

            break;
        }

        if (NT_ERROR(Status)) {

            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }

        //
        // Go through the files returned in the buffer.
        //

        for (FileInfo = QueryBuffer;
             ((PUCHAR) FileInfo < ((PUCHAR) QueryBuffer + QueryBufferSize));
             FileInfo = (PVOID) (((PUCHAR) FileInfo) + FileInfo->NextEntryOffset)) {

            FileCount++;

            if (!FileInfo->NextEntryOffset) {
                break;
            }
        }
    }

    *NumFiles = FileCount;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: CountFilesInDirectory(%ws)=%d,%x\n", DirectoryPath, *NumFiles, ErrorCode));

    if (AllocatedDirectoryPathU) {
        RtlFreeHeap(RtlProcessHeap(), 0, DirectoryPathU.Buffer);
    }

    if (OpenedDirectory) {
        NtClose(DirectoryHandle);
    }

    if (QueryBuffer) {
        PFSVC_FREE(QueryBuffer);
    }

    return ErrorCode;
}

//
// Routines to process acquired traces:
//

DWORD
PfSvProcessTrace(
    PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    This routine is called to process a trace and update the the
    scenario file.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;    
    PFSVC_SCENARIO_INFO ScenarioInfo;
    WCHAR ScenarioFilePath[MAX_PATH];
    ULONG ScenarioFilePathMaxChars;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PfSvInitializeScenarioInfo(&ScenarioInfo,
                               &Trace->ScenarioId,
                               Trace->ScenarioType);

    ScenarioFilePathMaxChars = sizeof(ScenarioFilePath) / 
                               sizeof(ScenarioFilePath[0]);

    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTrace(%p)\n", Trace));

    //
    // Build file path to existing information for this scenario.
    //

    ErrorCode = PfSvScenarioGetFilePath(ScenarioFilePath,
                                        ScenarioFilePathMaxChars,
                                        &Trace->ScenarioId);

    if (ErrorCode != ERROR_SUCCESS) {

        //
        // The buffer we specified should have been big enough. This call
        // should not fail.
        //

        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);

        goto cleanup;
    }

    //
    // Map and verify scenario file if it exists. If we cannot open it,
    // NULL Scenario should be returned.
    //

    ErrorCode = PfSvScenarioOpen(ScenarioFilePath, 
                                 &Trace->ScenarioId,
                                 Trace->ScenarioType,
                                 &Scenario);
                                 
    PFSVC_ASSERT(Scenario || ErrorCode);

    //
    // Allocate memory upfront for trace & scenario processing.
    //

    ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                            Scenario,
                                            Trace);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Incorporate information from any existing scenario file.
    //

    if (Scenario) {

        ErrorCode = PfSvAddExistingScenarioInfo(&ScenarioInfo, Scenario);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Unmap the scenario so we can write over it when done.
        //

        UnmapViewOfFile(Scenario);
        Scenario = NULL;
    }

    //
    // If this is the first launch of this scenario, it is likely that we
    // will create a new scenario file for it. 
    //

    if (ScenarioInfo.ScenHeader.NumLaunches == 1) {

        //
        // Do we already have too many scenario files in the prefetch directory?
        //

        if (PfSvcGlobals.NumPrefetchFiles > PFSVC_MAX_PREFETCH_FILES) {

            //
            // If this is not the boot scenario, we'll ignore it. We don't
            // create new scenario files until we clean up the old ones.
            //

            if (ScenarioInfo.ScenHeader.ScenarioType != PfSystemBootScenarioType) {

                #ifndef PFSVC_DBG

                ErrorCode = ERROR_TOO_MANY_OPEN_FILES;
                goto cleanup;

                #endif // !PFSVC_DBG
            }
        }

        PfSvcGlobals.NumPrefetchFiles++;
    }

    //
    // Verify that volume magics from existing scenario match those in
    // the new trace. If volumes change beneath us we'd need to fix
    // file paths in the existing scenario. But that is too much work,
    // so for now we just start new.
    //

    if (!PfSvVerifyVolumeMagics(&ScenarioInfo, Trace)) {

        PfSvCleanupScenarioInfo(&ScenarioInfo);

        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &Trace->ScenarioId,
                                   Trace->ScenarioType);

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                NULL,
                                                Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Also delete the existing scenario instruction in case we
        // fail to update them since they are invalid now.
        //
        
        PfSvcGlobals.NumPrefetchFiles--;
        DeleteFile(ScenarioFilePath);
    }

    //
    // Merge information from new trace.
    //
        
    ErrorCode = PfSvAddTraceInfo(&ScenarioInfo, Trace);
        
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Decide which pages to actually prefetch next time, and
    // eliminate uninteresting sections and pages.
    //
    
    ErrorCode = PfSvApplyPrefetchPolicy(&ScenarioInfo);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If no pages/sections are left in the scenario after applying
    // the policy, we'll delete the scenario file.
    //

    if (ScenarioInfo.ScenHeader.NumSections == 0 || 
        ScenarioInfo.ScenHeader.NumPages == 0) {

        //
        // We cannot have sections without pages or vice versa.
        //

        PFSVC_ASSERT(ScenarioInfo.ScenHeader.NumSections == 0);
        PFSVC_ASSERT(ScenarioInfo.ScenHeader.NumPages == 0);

        //
        // Remove the scenario file.
        //
        
        DeleteFile(ScenarioFilePath);
        
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Sort remaining sections by first access.
    //
    
    ErrorCode = PfSvSortSectionNodesByFirstAccess(&ScenarioInfo.SectionList);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
 
    //
    // Write out new scenario file.
    //
            
    ErrorCode = PfSvWriteScenario(&ScenarioInfo, ScenarioFilePath);

    //
    // Fall through with status.
    //
        
 cleanup:

    PfSvCleanupScenarioInfo(&ScenarioInfo);

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTrace(%p)=%x\n", Trace, ErrorCode));
        
    return ErrorCode;
}

VOID
PfSvInitializeScenarioInfo (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_ID ScenarioId,
    PF_SCENARIO_TYPE ScenarioType
    )

/*++

Routine Description:

    This routine initializes the specified new scenario structure. It
    sets the fields of the embedded scenario header as if no previous
    scenario information is available.

Arguments:

    ScenarioInfo - Pointer to structure to initialize.

    ScenarioId & ScenarioType - Identifiers for the scenario.

Return Value:

    None.

--*/

{

    //
    // Initialize ScenarioInfo so we know what to cleanup. Zeroing the structure
    // takes care of the following fields:
    //   OneBigAllocation
    //   NewPages
    //   HitPages
    //   MissedOpportunityPages
    //   IgnoredPages
    //   PrefetchedPages
    //

    RtlZeroMemory(ScenarioInfo, sizeof(PFSVC_SCENARIO_INFO));
    InitializeListHead(&ScenarioInfo->SectionList);
    InitializeListHead(&ScenarioInfo->VolumeList);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->SectionNodeAllocator);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->PageNodeAllocator);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->VolumeNodeAllocator);
    PfSvStringAllocatorInitialize(&ScenarioInfo->PathAllocator);
    
    //
    // Initialize the embedded scenario header.
    //
    
    ScenarioInfo->ScenHeader.Version = PF_CURRENT_VERSION;
    ScenarioInfo->ScenHeader.MagicNumber = PF_SCENARIO_MAGIC_NUMBER;
    ScenarioInfo->ScenHeader.ServiceVersion = PFSVC_SERVICE_VERSION;
    ScenarioInfo->ScenHeader.Size = 0;
    ScenarioInfo->ScenHeader.ScenarioId = *ScenarioId;
    ScenarioInfo->ScenHeader.ScenarioType = ScenarioType;
    ScenarioInfo->ScenHeader.NumSections = 0;
    ScenarioInfo->ScenHeader.NumPages = 0;
    ScenarioInfo->ScenHeader.FileNameInfoSize = 0;
    ScenarioInfo->ScenHeader.NumLaunches = 1;
    ScenarioInfo->ScenHeader.Sensitivity = PF_MIN_SENSITIVITY;

    //
    // These fields help us not prefetch if a scenario is getting
    // launched too frequently. RePrefetchTime and ReTraceTime's get
    // set to default values after the scenario is launched a number
    // of times. This allows training scenarios run after clearing the
    // prefetch cache to be traced correctly.
    //

    ScenarioInfo->ScenHeader.LastLaunchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = 0;

    return;
}

VOID 
PfSvCleanupScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    )

/*++

Routine Description:

    This function cleans up a scenario info structure. It does not
    free the structure itself. The structure should have been
    initialized by PfSvInitializeScenarioInfo.

Arguments:

    ScenarioInfo - Pointer to structure.

Return Value:

    None.

--*/

{
    PPFSVC_SECTION_NODE SectionNode;
    PLIST_ENTRY SectListEntry;
    PPFSVC_VOLUME_NODE VolumeNode;
    PLIST_ENTRY VolumeListEntry;

    //
    // Walk through the volume nodes and free them. Do this before
    // freeing section nodes, so when we are trying to cleanup a
    // section node, it is not on a volume node's list.
    //

    while (!IsListEmpty(&ScenarioInfo->VolumeList)) {
        
        VolumeListEntry = RemoveHeadList(&ScenarioInfo->VolumeList);
        
        VolumeNode = CONTAINING_RECORD(VolumeListEntry, 
                                       PFSVC_VOLUME_NODE, 
                                       VolumeLink);

        //
        // Cleanup the volume node.
        //

        PfSvCleanupVolumeNode(ScenarioInfo, VolumeNode);

        //
        // Free the volume node.
        //

        PfSvChunkAllocatorFree(&ScenarioInfo->VolumeNodeAllocator, VolumeNode);
    }

    //
    // Walk through the section nodes and free them.
    //

    while (!IsListEmpty(&ScenarioInfo->SectionList)) {
        
        SectListEntry = RemoveHeadList(&ScenarioInfo->SectionList);
        
        SectionNode = CONTAINING_RECORD(SectListEntry, 
                                        PFSVC_SECTION_NODE, 
                                        SectionLink);

        //
        // Cleanup the section node.
        //

        PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

        //
        // Free the section node.
        //

        PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
    }

    //
    // Cleanup allocators.
    //

    PfSvChunkAllocatorCleanup(&ScenarioInfo->SectionNodeAllocator);
    PfSvChunkAllocatorCleanup(&ScenarioInfo->PageNodeAllocator);
    PfSvChunkAllocatorCleanup(&ScenarioInfo->VolumeNodeAllocator);
    PfSvStringAllocatorCleanup(&ScenarioInfo->PathAllocator);

    //
    // Free the one big allocation we made.
    //

    if (ScenarioInfo->OneBigAllocation) {
        PFSVC_FREE(ScenarioInfo->OneBigAllocation);
    }

    return;
}

DWORD
PfSvScenarioGetFilePath(
    OUT PWCHAR FilePath,
    IN ULONG FilePathMaxChars,
    IN PPF_SCENARIO_ID ScenarioId
    )

/*++

Routine Description:

    This routine builds the file path for the specified scenario.

Arguments:

    FilePath - Output buffer.

    FilePathMaxChars - Size of FilePath buffer in characters including NUL.

    ScenarioId - Scenario identifier.

Return Value:

    Win32 error code.

--*/

{
    ULONG NumChars;
    DWORD ErrorCode;
    WCHAR ScenarioFileName[PF_MAX_SCENARIO_FILE_NAME];
    BOOLEAN AcquiredPrefetchRootLock;

    //
    // Get the lock so the path to prefetch folder does not change
    // beneath our feet.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = TRUE;

    //
    // Calculate how big an input buffer we will need.
    //

    NumChars = wcslen(PfSvcGlobals.PrefetchRoot);
    NumChars += wcslen(L"\\");
    NumChars += PF_MAX_SCENARIO_FILE_NAME;
        
    if (NumChars >= FilePathMaxChars) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Build the scenario file name from scenario identifier.
    //

    swprintf(ScenarioFileName, 
             PF_SCEN_FILE_NAME_FORMAT,
             ScenarioId->ScenName,
             ScenarioId->HashId,
             PF_PREFETCH_FILE_EXTENSION);

    //
    // Build file path from prefetch directory path and file name.
    //

    swprintf(FilePath, 
             L"%ws\\%ws",
             PfSvcGlobals.PrefetchRoot,
             ScenarioFileName);

    PFSVC_ASSERT(wcslen(FilePath) < FilePathMaxChars);

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = FALSE;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (AcquiredPrefetchRootLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    return ErrorCode;
}

DWORD
PfSvScenarioOpen (
    IN PWCHAR FilePath,
    IN PPF_SCENARIO_ID ScenarioId,
    IN PF_SCENARIO_TYPE ScenarioType,
    OUT PPF_SCENARIO_HEADER *Scenario
    )

/*++

Routine Description:

    This routine maps & verifies the scenario instructions at FilePath.

    If a Scenario is returned, caller has to call UnmapViewOfFile to cleanup.

Arguments:

    FilePath - Path to scenario instructions.

    Scenario - Pointer to base of mapping of scenario instructions or NULL
      if the function returns an error.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER OpenedScenario;
    DWORD FailedCheck;
    DWORD ErrorCode;  
    DWORD FileSize;

    //
    // Initialize locals.
    //

    OpenedScenario = NULL;

    //
    // Initialize output parameters.
    //

    *Scenario = NULL;

    //
    // Try to map the scenario file.
    //

    ErrorCode = PfSvGetViewOfFile(FilePath, 
                                  &OpenedScenario,
                                  &FileSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Verify the scenario file.
    //

    FailedCheck = 0;
   
    if (!PfSvVerifyScenarioBuffer(OpenedScenario, FileSize, &FailedCheck) ||
        (OpenedScenario->ScenarioType != ScenarioType) ||
        OpenedScenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
        
        //
        // This is a bogus / wrong / outdated scenario file. Remove
        // it.
        //

        UnmapViewOfFile(OpenedScenario);
        OpenedScenario = NULL;
        
        DeleteFile(FilePath);

        ErrorCode = ERROR_BAD_FORMAT; 
        goto cleanup;
    }

    *Scenario = OpenedScenario;
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {

        if (OpenedScenario) {
            UnmapViewOfFile(OpenedScenario);
        }

        *Scenario = NULL;

    } else {

        //
        // If we are returning success we should be returning a valid Scenario.
        //

        PFSVC_ASSERT(*Scenario);
    }

    return ErrorCode;
}

DWORD
PfSvScenarioInfoPreallocate(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OPTIONAL IN PPF_SCENARIO_HEADER Scenario,
    OPTIONAL IN PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    This routine preallocates a heap to be divided up and used by the 
    various allocators when processing a prefetch trace. The default allocation
    size is determined from the Trace and Scenario size.

Arguments:

    ScenarioInfo - Pointer to scenario containing allocators to initialize.

    Scenario - Pointer to scenario instructions.

    Trace - Pointer to prefetch trace.

Return Value:

    Win32 error code.

--*/

{
    PUCHAR Allocation;
    PUCHAR ChunkStart;
    DWORD ErrorCode;
    ULONG AllocationSize;
    ULONG NumSections;
    ULONG NumPages;
    ULONG NumVolumes;
    ULONG PathSize;

    //
    // Initialize locals.
    //

    Allocation = NULL;
    NumSections = 0;
    NumPages = 0;
    NumVolumes = 0;
    PathSize = 0;

    //
    // Estimate how much to preallocate. Over-estimate rather than under-
    // estimate because we will have to go to the heap for individual allocations
    // if we underestimate. If we overestimate, as long as we don't touch the extra 
    // pages allocated we don't get a hit.
    //

    if (Trace) {
        NumSections += Trace->NumSections;
    }

    if (Scenario) {
        NumSections += Scenario->NumSections;
    }   

    if (Trace) {
        NumPages += Trace->NumEntries;
    }
    
    if (Scenario) {
        NumPages += Scenario->NumPages;
    }

    if (Trace) {
        NumVolumes += Trace->NumVolumes;
    }
    
    if (Scenario) {

        NumVolumes += Scenario->NumMetadataRecords;

        //
        // It is very likely that we will at least share the volume containing the
        // main executables between the trace and existing scenario instructions.
        // So if we have both Trace and Scenario take one volume node off the estimate.
        //

        if (Trace) {
            PFSVC_ASSERT(NumVolumes);
            NumVolumes--;
        }
    }

    //
    // It is hard to estimate how much we will allocate for various paths
    // e.g. file paths & each level of parent directory paths etc. It should be less
    // than the size of the total trace, although it probably makes up most of it.
    //

    if (Trace) {
        PathSize += Trace->Size;
    }
    
    if (Scenario) {
        PathSize += Scenario->FileNameInfoSize;
        PathSize += Scenario->MetadataInfoSize;
    }

    //
    // Add it all up.
    //

    AllocationSize = 0;
    AllocationSize += _alignof(PFSVC_VOLUME_NODE);
    AllocationSize += NumVolumes * sizeof(PFSVC_VOLUME_NODE);
    AllocationSize += _alignof(PFSVC_SECTION_NODE);
    AllocationSize += NumSections * sizeof(PFSVC_SECTION_NODE);
    AllocationSize += _alignof(PFSVC_PAGE_NODE);
    AllocationSize += NumPages * sizeof(PFSVC_PAGE_NODE);
    AllocationSize += PathSize;

    //
    // Make one big allocation.
    //

    Allocation = PFSVC_ALLOC(AllocationSize);

    if (!Allocation) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Divide up the big allocation. Since we are providing the buffers,
    // allocators should not fail.
    //

    ChunkStart = Allocation;

    //
    // Volume nodes.
    //

    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->VolumeNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_VOLUME_NODE),
                                        NumVolumes);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumVolumes * sizeof(PFSVC_VOLUME_NODE);

    //
    // Section nodes.
    //

    ChunkStart = PF_ALIGN_UP(ChunkStart, _alignof(PFSVC_SECTION_NODE));
    
    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->SectionNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_SECTION_NODE),
                                        NumSections);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumSections * sizeof(PFSVC_SECTION_NODE);

    //
    // Page nodes.
    //
    
    ChunkStart = PF_ALIGN_UP(ChunkStart, _alignof(PFSVC_PAGE_NODE));

    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->PageNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_PAGE_NODE),
                                        NumPages);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumPages * sizeof(PFSVC_PAGE_NODE);

    //
    // Path names.
    //

    ErrorCode = PfSvStringAllocatorStart(&ScenarioInfo->PathAllocator,
                                        ChunkStart,
                                        PathSize);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) PathSize;

    //
    // We should not have passed beyond what we allocated.
    //

    PFSVC_ASSERT(ChunkStart > (PUCHAR) Allocation);
    PFSVC_ASSERT(ChunkStart < (PUCHAR) Allocation + (ULONG_PTR) AllocationSize);

    ScenarioInfo->OneBigAllocation = Allocation;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (Allocation) {
            PFSVC_FREE(Allocation);       
        }
    }

    return ErrorCode;
}

DWORD
PfSvAddExistingScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_HEADER Scenario
    )

/*++

Routine Description:

    This function gets existing scenario information for the specified
    scenario and updates ScenarioInfo.

Arguments:

    ScenarioInfo - Initialized scenario info structure.

    Scenario - Pointer to mapped scenario instructions.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD SectionRecord;
    PPF_PAGE_RECORD Pages;
    PCHAR FileNameInfo;
    WCHAR *FileName;
    LONG PageIdx;
    ULONG SectionIdx;
    ULONG NumPages;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    PWCHAR VolumePath;   

    //
    // Copy over the existing scenario header.
    //

    ScenarioInfo->ScenHeader = *Scenario;

    //
    // Update number of launches.
    //

    ScenarioInfo->ScenHeader.NumLaunches++;

    //
    // Convert the scenario data into intermediate data structures
    // we can manipulate easier:
    //

    //
    // Create volume nodes from metadata records.
    //

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        VolumePath = (PWCHAR)(MetadataInfoBase + MetadataRecord->VolumeNameOffset);  

        ErrorCode = PfSvCreateVolumeNode(ScenarioInfo,
                                         VolumePath,
                                         MetadataRecord->VolumeNameLength,
                                         &MetadataRecord->CreationTime,
                                         MetadataRecord->SerialNumber);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    //
    // Convert page and section nodes.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);
    Pages = (PPF_PAGE_RECORD) ((PCHAR)Scenario + Scenario->PageInfoOffset);
    FileNameInfo = (PCHAR)Scenario + Scenario->FileNameInfoOffset;
            
    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {

        //
        // Build a section node from this section record in the
        // scenario file. PfSvGetSectionRecord will insert it into
        // the new scenario by the section record's name.
        //

        SectionRecord = &Sections[SectionIdx];
        FileName = (PWSTR) (FileNameInfo + SectionRecord->FileNameOffset);

        SectionNode = PfSvGetSectionRecord (ScenarioInfo,
                                            FileName,
                                            SectionRecord->FileNameLength);

        if (!SectionNode) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // There should not be duplicate sections in the
        // scenario. The section node we got should have an empty
        // section record.
        //

        PFSVC_ASSERT(SectionNode->SectionRecord.FirstPageIdx == 0);
        PFSVC_ASSERT(SectionNode->SectionRecord.NumPages == 0);
        PFSVC_ASSERT(SectionNode->OrgSectionIndex == ULONG_MAX);
    
        //
        // Update the index of this section in the scenario file.
        //

        SectionNode->OrgSectionIndex = SectionIdx;

        //
        // Update the section record in the section node.
        //

        SectionNode->SectionRecord = *SectionRecord;

        //
        // Put page records for the section into the list.
        //
            
        PageIdx = SectionRecord->FirstPageIdx;
        NumPages = 0;

        while (PageIdx != PF_INVALID_PAGE_IDX) {

            if (NumPages >= SectionRecord->NumPages) {
                    
                //
                // There should not be more pages on the list than
                // what the section record says there is.
                //

                PFSVC_ASSERT(FALSE);
                break;
            }

            PageNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->PageNodeAllocator);
                
            if (!PageNode) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
                
            //
            // Copy over the page record.
            //

            PageNode->PageRecord = Pages[PageIdx];

            //
            // Insert it into the section's page list. Note that
            // the page records in the section should be sorted by
            // offset. By inserting to the tail, we maintain that.
            //

            InsertTailList(&SectionNode->PageList, &PageNode->PageLink);

            //
            // Shift the usage history for this page record making
            // room for whether this page was used in this launch.
            //
                
            PageNode->PageRecord.UsageHistory <<= 1;

            //
            // Shift the prefetch history for this page record and
            // note whether we had asked this page to be
            // prefetched in this launch.
            //
                
            PageNode->PageRecord.PrefetchHistory <<= 1;
                
            if (!PageNode->PageRecord.IsIgnore) {
                PageNode->PageRecord.PrefetchHistory |= 0x1;
            }

            //
            // Keep the count of pages we had asked to be
            // prefetched, so we can calculate hit rate and adjust
            // the sensitivity.
            //

            if(!PageNode->PageRecord.IsIgnore) {
                if (PageNode->PageRecord.IsImage) {
                    ScenarioInfo->PrefetchedPages++;
                }
                if (PageNode->PageRecord.IsData) {
                    ScenarioInfo->PrefetchedPages++;
                }
            } else {
                ScenarioInfo->IgnoredPages++;
            }

            //
            // Update next page idx.
            //

            PageIdx = Pages[PageIdx].NextPageIdx;

            //
            // Update number of pages we've copied.
            //

            NumPages++;
        }

        //
        // We should have copied as many pages as the section said
        // there were.
        //

        PFSVC_ASSERT(NumPages == SectionRecord->NumPages);
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvVerifyVolumeMagics(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Walk through the volumes in the trace and make sure their magics
    match the ones in ScenarioInfo.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPFSVC_VOLUME_NODE VolumeNode;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    BOOLEAN VolumeMagicsMatch;
    
    //
    // Walk the volumes in the trace.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {
        
        //
        // Get the scenario info's volume node for this volume.
        //
        
        VolumeNode = PfSvGetVolumeNode(ScenarioInfo,
                                       VolumeInfo->VolumePath,
                                       VolumeInfo->VolumePathLength);
        
        if (VolumeNode) {

            //
            // Make sure the magics match.
            //

            if (VolumeNode->SerialNumber != VolumeInfo->SerialNumber ||
                VolumeNode->CreationTime.QuadPart != VolumeInfo->CreationTime.QuadPart) {

                VolumeMagicsMatch = FALSE;
                goto cleanup;
            }
        }

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }
 
    //
    // Volume magics for volumes that appear both in the trace and the
    // scenario info matched.
    //

    VolumeMagicsMatch = TRUE;

 cleanup:

    return VolumeMagicsMatch;
}

DWORD
PfSvAddTraceInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Add information in a raw trace to the specified scenario info
    structure.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SECTION_INFO Section;
    PPF_LOG_ENTRY LogEntries;
    PCHAR pFileName;
    PPFSVC_SECTION_NODE *SectionTable;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_VOLUME_NODE VolumeNode;   
    ULONG TraceEndIdx;
    ULONG SectionIdx;
    ULONG EntryIdx;
    DWORD ErrorCode;
    ULONG SectionLength;
    ULONG NextSectionIndex;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    ULONG SectionTableSize;

    //
    // Initialize locals so we know what to clean up.
    //

    SectionTable = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()\n"));
    
    //
    // Update last launch time.
    //
   
    ScenarioInfo->ScenHeader.LastLaunchTime = Trace->LaunchTime;

    //
    // If this scenario has been launched a number of times, we update
    // the min reprefetch and retrace times. See comment for
    // PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK.
    //

    if (ScenarioInfo->ScenHeader.NumLaunches >= PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK) {
        ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = PFSVC_DEFAULT_MIN_REPREFETCH_TIME;
        ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = PFSVC_DEFAULT_MIN_RETRACE_TIME;
    }

#ifdef PFSVC_DBG

    //
    // On checked build, always set these to 0, so we do prefetch every 
    // scenario launch.
    //

    ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = 0;

#endif // PFSVC_DBG

    //
    // Walk through the volumes in the trace and create volume nodes
    // for them.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {

        //
        // Upcase the path so we don't have to do expensive case
        // insensitive comparisons.
        //

        _wcsupr(VolumeInfo->VolumePath);

        ErrorCode = PfSvCreateVolumeNode(ScenarioInfo,
                                         VolumeInfo->VolumePath,
                                         VolumeInfo->VolumePathLength,
                                         &VolumeInfo->CreationTime,
                                         VolumeInfo->SerialNumber);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // Allocate section node table so we know where to put the logged
    // page faults.
    //

    SectionTableSize = sizeof(PPFSVC_SECTION_NODE) * Trace->NumSections;

    SectionTable = PFSVC_ALLOC(SectionTableSize);
    
    if (!SectionTable) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(SectionTable, SectionTableSize);

    //
    // Walk through the sections in the trace, and either find
    // existing section records in the new scenario or create new
    // ones.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Upcase the path so we don't have to do expensive case
        // insensitive comparisons.
        //
        
        _wcsupr(Section->FileName);

        //
        // If the section is for metafile, simply add it as a directory
        // to be prefetched. We don't keep track of individual faults,
        // since we can't prefetch only parts of directories.
        //

        if (Section->Metafile) {

            VolumeNode = PfSvGetVolumeNode(ScenarioInfo, 
                                           Section->FileName,
                                           Section->FileNameLength);

            PFSVC_ASSERT(VolumeNode);

            if (VolumeNode) {
                PfSvAddParentDirectoriesToList(&VolumeNode->DirectoryList,
                                               VolumeNode->VolumePathLength,
                                               Section->FileName,
                                               Section->FileNameLength);
            }

            goto NextSection;
        }

        //
        // Find or create a section record for this section.
        //

        SectionTable[SectionIdx] = PfSvGetSectionRecord(ScenarioInfo,
                                                        Section->FileName,
                                                        Section->FileNameLength);
        
        //
        // If we could not get a record, it is because we had to
        // create one and we did not have enough memory.
        //
        
        if (!SectionTable[SectionIdx]) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

      NextSection:

        //
        // Get the next section record in the trace.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Determine after which log entry the trace ends.
    //

    TraceEndIdx = PfSvGetTraceEndIdx(Trace);

    //
    // If the determined trace end is zero (as is the case for most
    // applications running under stress that don't get any pagefaults
    // traced for the first few seconds), bail out.
    //

    if (TraceEndIdx == 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Add logged pagefault information up to the determined trace end
    // to the new scenario info.
    //

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);
    
    //
    // Keep track of NextSectionIdx so we can order the sections by
    // the first access [i.e. first page fault in the trace]
    //

    NextSectionIndex = 0;

    for (EntryIdx = 0; EntryIdx < TraceEndIdx; EntryIdx++) {

        SectionNode = SectionTable[LogEntries[EntryIdx].SectionId];

        //
        // For metafile sections we don't create section nodes.
        //

        if (!SectionNode) {
            continue;
        }

        //
        // NewSectionIndex fields of all section nodes are initialized
        // to ULONG_MAX. If we have not already seen this section in
        // the trace note its order and update NextSectionIdx.
        //

        if (SectionNode->NewSectionIndex == ULONG_MAX) {
            SectionNode->NewSectionIndex = NextSectionIndex;
            NextSectionIndex++;
        }

        //
        // Add fault information to our section record.
        //

        ErrorCode = PfSvAddFaultInfoToSection(ScenarioInfo,
                                              &LogEntries[EntryIdx], 
                                              SectionNode);

       if (ErrorCode != ERROR_SUCCESS) {
           goto cleanup;
       }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (SectionTable) {
        PFSVC_FREE(SectionTable);
    }

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()=%x\n", ErrorCode));

    return ErrorCode;
}

// FUTURE-2002/03/29-ScottMa -- The function below should not be named
//   PfSvGetSectionRecord, since a PF_SECTION_RECORD is not returned.
//   Consider renaming it to PfSvGetSectionNode.

PPFSVC_SECTION_NODE 
PfSvGetSectionRecord(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    Find or create a section node in the scenario info for the
    specified file path.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    FilePath - NUL terminated NT path to file.

    FilePathLength - Length of FilePath in chars excluding NUL.

Return Value:

    Pointer to created or found section node or NULL if there was a
    problem.

--*/

{
    PPFSVC_SECTION_NODE SectionNode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    LONG ComparisonResult;
    ULONG FilePathSize;
    PPFSVC_SECTION_NODE ReturnNode;

    //
    // Initialize locals.
    //

    ReturnNode = NULL;

    //
    // Walk through the existing sections records looking for a file
    // name match. Section records are on a lexically sorted list.
    //

    HeadEntry = &ScenarioInfo->SectionList;
    NextEntry = HeadEntry->Flink;
    
    while (HeadEntry != NextEntry) {

        SectionNode = CONTAINING_RECORD(NextEntry,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);

        ComparisonResult = wcscmp(SectionNode->FilePath, FilePath);
        
        if (ComparisonResult == 0) {

            //
            // We found a match. Return this section record.
            //

            ReturnNode = SectionNode;
            goto cleanup;

        } else if (ComparisonResult > 0) { 
            
            //
            // We won't find the name in our list. We have to create a
            // new section record.
            //

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // We have to create a new section record. NextEntry points to
    // where we have to insert it in the list.
    //

    SectionNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->SectionNodeAllocator);

    if (!SectionNode) {
        ReturnNode = NULL;
        goto cleanup;
    }

    //
    // Initialize the section node.
    //

    SectionNode->FilePath = NULL;
    InitializeListHead(&SectionNode->PageList);
    InitializeListHead(&SectionNode->SectionVolumeLink);
    SectionNode->NewSectionIndex = ULONG_MAX;
    SectionNode->OrgSectionIndex = ULONG_MAX;
    SectionNode->FileIndexNumber.QuadPart = -1i64;
    
    //
    // Initialize the section record. 
    //

    RtlZeroMemory(&SectionNode->SectionRecord, sizeof(PF_SECTION_RECORD));

    //
    // Allocate and copy over the file name.
    //

    FilePathSize = (FilePathLength + 1) * sizeof(WCHAR);

    SectionNode->FilePath = PfSvStringAllocatorAllocate(&ScenarioInfo->PathAllocator,
                                                        FilePathSize);

    if (!SectionNode->FilePath) {

        PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

        PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);

        ReturnNode = NULL;
        goto cleanup;
    }

    RtlCopyMemory(SectionNode->FilePath, FilePath, FilePathSize);

    //
    // Update the file name length on the section record.
    //

    SectionNode->SectionRecord.FileNameLength = FilePathLength;

    //
    // Insert the section into the right spot on the scenario's list.
    //

    InsertTailList(NextEntry, &SectionNode->SectionLink);

    //
    // Return the newly setup section record.
    //

    ReturnNode = SectionNode;

 cleanup:

    return ReturnNode;
}

DWORD 
PfSvAddFaultInfoToSection(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_LOG_ENTRY LogEntry,
    PPFSVC_SECTION_NODE SectionNode
    )

/*++

Routine Description:

    Add fault information from a trace log entry to proper section
    record in the new scenario.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    LogEntry - Pointer to trace log entry.

    SectionNode - Pointer to the section node the log entry belongs to.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Walk through the page records for this section.
    //

    HeadEntry = &SectionNode->PageList;
    NextEntry = HeadEntry->Flink;
                                 
    while (HeadEntry != NextEntry) {
        
        PageNode = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PAGE_NODE,
                                     PageLink);

        if (PageNode->PageRecord.FileOffset > LogEntry->FileOffset) {
            
            //
            // We won't find this fault in this sorted list.
            //
            
            break;

        } else if (PageNode->PageRecord.FileOffset == LogEntry->FileOffset) {

            //
            // We found the page, update the page record and section
            // record with the info in log entry.
            //

            if (LogEntry->IsImage) {
                PageNode->PageRecord.IsImage = 1;
            } else {
                PageNode->PageRecord.IsData = 1;
            }
            
            //
            // Note the this page was used in this launch.
            //

            PageNode->PageRecord.UsageHistory |= 0x1;

            //
            // See if this page was prefetched for this launch and
            // update appropriate stats.
            //

            if(PageNode->PageRecord.IsIgnore) {
                ScenarioInfo->MissedOpportunityPages++;
            } else {
                ScenarioInfo->HitPages++;
            }

            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
        
        NextEntry = NextEntry->Flink;
    }

    //
    // We have to add a new page record before NextEntry in the list.
    //
    
    PageNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->PageNodeAllocator);

    if (!PageNode) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    //
    // Set up new page record. First initialize fields.
    //

    PageNode->PageRecord.IsImage = 0;
    PageNode->PageRecord.IsData = 0;
    PageNode->PageRecord.IsIgnore = 0;
    
    PageNode->PageRecord.FileOffset = LogEntry->FileOffset;
        
    if (LogEntry->IsImage) {
        PageNode->PageRecord.IsImage = 1;
    } else {
        PageNode->PageRecord.IsData = 1;
    }

    //
    // Initialize usage history for this new page record noting that
    // it was used in this launch.
    //

    PageNode->PageRecord.UsageHistory = 0x1;

    //
    // Initialize prefetch history for this new page record.
    //

    PageNode->PageRecord.PrefetchHistory = 0;

    //
    // Insert it into the sections pages list.
    //

    InsertTailList(NextEntry, &PageNode->PageLink);

    //
    // Update stats on the new scenario.
    //

    ScenarioInfo->NewPages++;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvApplyPrefetchPolicy(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    )

/*++

Routine Description:

    Go through all the information in ScenarioInfo and determine which
    pages/sections to prefetch for the next launch of the scenario.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

Return Value:

    Win32 error code.

--*/

{
    ULONG Sensitivity;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    ULONG SectNumPagesToPrefetch;
    ULONG HitPages;
    ULONG MissedOpportunityPages;
    ULONG PrefetchedPages;
    ULONG IgnoredPages;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;  
    ULONG NumUsed;
    PPF_SCENARIO_HEADER Scenario;
    ULONG FileNameSize;
    ULONG IgnoredFileIdx;
    BOOLEAN bSkipSection;
    PFSV_SUFFIX_COMPARISON_RESULT ComparisonResult;
    DWORD ErrorCode;
    PPFSVC_VOLUME_NODE VolumeNode;
    PWCHAR MFTSuffix;
    PWCHAR PathSuffix;
    FILE_BASIC_INFORMATION FileInformation;
    ULONG MFTSuffixLength;
    
    //
    // Initialize locals.
    //

    Scenario = &ScenarioInfo->ScenHeader;
    MFTSuffix = L"\\$MFT";
    MFTSuffixLength = wcslen(MFTSuffix);

    DBGPR((PFID,PFTRC,"PFSVC: ApplyPrefetchPolicy()\n"));

    //
    // Initialize fields of the scenario header we will set up.
    //
    
    Scenario->NumSections = 0;
    Scenario->NumPages = 0;
    Scenario->FileNameInfoSize = 0;
    
    //
    // Determine sensitivity based on usage of the pages we prefetched
    // and we ignored.
    //

    HitPages = ScenarioInfo->HitPages;
    MissedOpportunityPages = ScenarioInfo->MissedOpportunityPages;
    PrefetchedPages = ScenarioInfo->PrefetchedPages;
    IgnoredPages = ScenarioInfo->IgnoredPages;

    //
    // Check what percent of the pages we brought were used.
    //

    if (PrefetchedPages &&
        (((HitPages * 100) / PrefetchedPages) < PFSVC_MIN_HIT_PERCENTAGE)) {
            
        //
        // Our hit rate is low. Increase sensitivity of the
        // scenario, so for us to prefetch a page, it has to be
        // used in more of the last launches.
        //
            
        if (ScenarioInfo->ScenHeader.Sensitivity < PF_MAX_SENSITIVITY) {
            ScenarioInfo->ScenHeader.Sensitivity ++;
        }

    } else if (IgnoredPages && 
               (((MissedOpportunityPages * 100) / IgnoredPages) > PFSVC_MAX_IGNORED_PERCENTAGE)) {

        //
        // If we are using most of what we prefetched (or we are not
        // prefetching anything!), but we ignored some pages we could
        // have prefetched, and they were used too, time to decrease
        // sensitivity so we ignore less pages.
        //
            
        if (ScenarioInfo->ScenHeader.Sensitivity > PF_MIN_SENSITIVITY) {
            ScenarioInfo->ScenHeader.Sensitivity --;
        }
    }

    //
    // Don't let the boot scenario's sensitivity to fall below 2. 
    // This makes sure we don't pick up all the application setup &
    // configuration updates that happen during boot once.
    //

    if (ScenarioInfo->ScenHeader.ScenarioType == PfSystemBootScenarioType) {
        PFSVC_ASSERT(PF_MIN_SENSITIVITY <= 2);
        if (ScenarioInfo->ScenHeader.Sensitivity < 2) {
            ScenarioInfo->ScenHeader.Sensitivity = 2;
        }
    }

    Sensitivity = ScenarioInfo->ScenHeader.Sensitivity;

    //
    // If number of times this scenario was launched is less
    // than sensitivity, adjust sensitivity. Otherwise we
    // won't end up prefetching anything.
    //
    
    if (Sensitivity > ScenarioInfo->ScenHeader.NumLaunches) {
        Sensitivity = ScenarioInfo->ScenHeader.NumLaunches;
    }   

    //
    // Walk through pages for every section and determine if they
    // should be prefetched or not based on scenario sensitivity and
    // their usage history in the last launches. 
    //

    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;

    while (SectHead != SectNext) {

        SectionNode = CONTAINING_RECORD(SectNext,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        SectNext = SectNext->Flink;

        //
        // Initialize section records fields.
        //
        
        SectionNode->SectionRecord.IsImage = 0;
        SectionNode->SectionRecord.IsData = 0;
        SectionNode->SectionRecord.NumPages = 0;

        //
        // If we are nearing the limits for number of sections and
        // pages, ignore the rest of the sections.
        //

        if (Scenario->NumSections >= PF_MAXIMUM_SECTIONS ||
            Scenario->NumPages + PF_MAXIMUM_SECTION_PAGES >= PF_MAXIMUM_PAGES) {
            
            //
            // Remove this section node from our list.
            //
            
            PfSvCleanupSectionNode(ScenarioInfo, SectionNode);
            
            RemoveEntryList(&SectionNode->SectionLink);
            
            PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
            
            continue;
        }

        //
        // If this is the boot scenario, check to see if this is one
        // of the sections we ignore.
        //
        
        if (Scenario->ScenarioType == PfSystemBootScenarioType) {

            bSkipSection = FALSE;

            for (IgnoredFileIdx = 0;
                 IgnoredFileIdx < PfSvcGlobals.NumFilesToIgnoreForBoot;
                 IgnoredFileIdx++) {

                ComparisonResult = PfSvCompareSuffix(SectionNode->FilePath,
                                                     SectionNode->SectionRecord.FileNameLength,
                                                     PfSvcGlobals.FilesToIgnoreForBoot[IgnoredFileIdx],
                                                     PfSvcGlobals.FileSuffixLengths[IgnoredFileIdx],
                                                     TRUE);

                if (ComparisonResult == PfSvSuffixIdentical) {
                    
                    //
                    // The suffix matched.
                    //

                    bSkipSection = TRUE;
                    break;

                } else if (ComparisonResult == PfSvSuffixGreaterThan) {

                    //
                    // Since the ignore-suffices are lexically sorted,
                    // this file name's suffix won't match others
                    // either.
                    //

                    bSkipSection = FALSE;
                    break;
                }
            }
            
            if (bSkipSection) {
                
                //
                // Remove this section node from our list.
                //
                
                PfSvCleanupSectionNode(ScenarioInfo, SectionNode);
                
                RemoveEntryList(&SectionNode->SectionLink);
                
                PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
                
                continue;
            }
        }
        
        //
        // Keep track of num pages to prefetch for this section.
        //
        
        SectNumPagesToPrefetch = 0;
        
        PageHead = &SectionNode->PageList;
        PageNext = PageHead->Flink;
        
        while (PageHead != PageNext) {
            
            PageNode = CONTAINING_RECORD(PageNext,
                                         PFSVC_PAGE_NODE,
                                         PageLink);
            PageNext = PageNext->Flink;
            
            //
            // Get number of times this page was used in the launches
            // in usage history.
            //
            
            NumUsed = PfSvGetNumTimesUsed(PageNode->PageRecord.UsageHistory,
                                          PF_PAGE_HISTORY_SIZE);
            
            
            //
            // If it was not used at all in the history we've kept
            // track of, remove it.
            //
            
            if (NumUsed == 0) {
                
                RemoveEntryList(&PageNode->PageLink);
                
                PfSvChunkAllocatorFree(&ScenarioInfo->PageNodeAllocator, PageNode);

                continue;
            }
            
            //
            // Update the number of pages for this section.
            //
            
            SectionNode->SectionRecord.NumPages++;

            //
            // Check if this page qualifies to be prefetched next time.
            //

            if (NumUsed >= Sensitivity) {
                PageNode->PageRecord.IsIgnore = 0;

                //
                // Update the number of pages we are prefetching for
                // this section.
                //

                SectNumPagesToPrefetch++;
            
                //
                // Update whether we are going to prefetch this
                // section as image, data [or both].
                //
                
                SectionNode->SectionRecord.IsImage |= PageNode->PageRecord.IsImage;
                SectionNode->SectionRecord.IsData |= PageNode->PageRecord.IsData;
                
            } else {
                
                PageNode->PageRecord.IsIgnore = 1;
            }
        }

        //
        // Check if we want to keep this section in the scenario:
        //

        bSkipSection = FALSE;       

        if (SectionNode->SectionRecord.NumPages == 0) {

            //
            // If we don't have any pages left for this section, remove
            // it.
            //

            bSkipSection = TRUE;            

        } else if (SectionNode->SectionRecord.NumPages >= PF_MAXIMUM_SECTION_PAGES) {

            //
            // If we ended up with too many pages for this section, remove
            // it.
            //

            bSkipSection = TRUE;

        } else if (PfSvcGlobals.CSCRootPath &&
                   wcsstr(SectionNode->FilePath, PfSvcGlobals.CSCRootPath)) {

            //
            // Skip client side cache (CSC) files. These files may get encrypted as 
            // LocalSystem, and when the AppData folder is redirected, we may take
            // minutes trying to open them when prefetching for shell launch.
            //

            bSkipSection = TRUE;

        } else {

            //
            // Encrypted files may result in several network accesses during open, 
            // even if they are local. This is especially so if the AppData folder is
            // redirected to a server. We cannot afford these network delays when
            // blocking the scenario for prefetching.
            //

            ErrorCode = PfSvGetFileBasicInformation(SectionNode->FilePath, 
                                                    &FileInformation);

            if ((ErrorCode == ERROR_SUCCESS) &&
                (FileInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                bSkipSection = TRUE;

            }
        }

        if (bSkipSection) {

            PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

            RemoveEntryList(&SectionNode->SectionLink);
            
            PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);

            continue;
        }

        //
        // Get the volume node for the volume this section is
        // on. The volume node should have been added when the
        // existing scenario information or the new trace
        // information was added to the scenario info.
        //
        
        VolumeNode = PfSvGetVolumeNode(ScenarioInfo,
                                       SectionNode->FilePath,
                                       SectionNode->SectionRecord.FileNameLength);
        
        PFSVC_ASSERT(VolumeNode);

        if (VolumeNode) {
            VolumeNode->NumAllSections++;
        }

        //
        // If we are not prefetching any pages from this section for
        // the next launch, mark it ignore.
        //

        if (SectNumPagesToPrefetch == 0) {

            SectionNode->SectionRecord.IsIgnore = 1;

        } else {

            SectionNode->SectionRecord.IsIgnore = 0;

            //
            // If this is MFT section for this volume, save it on the volume
            // node. We will add the pages referenced from MFT to the list of
            // files to prefetch metadata for. 
            //

            if ((VolumeNode && VolumeNode->MFTSectionNode == NULL) &&
                 (VolumeNode->VolumePathLength == (SectionNode->SectionRecord.FileNameLength - MFTSuffixLength))) {

                PathSuffix = SectionNode->FilePath + SectionNode->SectionRecord.FileNameLength;
                PathSuffix -= MFTSuffixLength;

                if (wcscmp(PathSuffix, MFTSuffix) == 0) {

                    //
                    // This is the MFT section node for this volume.
                    //

                    VolumeNode->MFTSectionNode = SectionNode;

                    //
                    // Mark the MFT section node as "ignore" so kernel does
                    // not attempt to prefetch it directly.
                    //

                    VolumeNode->MFTSectionNode->SectionRecord.IsIgnore = 1;

                    //
                    // Save how many pages we'll prefetch from MFT on the section
                    // node. We save this instead of FileIndexNumber field, since
                    // there won't be one for MFT. We won't try to get one either
                    // since we are marking this section node ignore.
                    //

                    VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch = SectNumPagesToPrefetch;
                }
            }
        }

        //
        // If we are not ignoring this section, update its file system
        // index number so its metadata can be prefetched.
        //
        
        if (SectionNode->SectionRecord.IsIgnore == 0) {
            
            ErrorCode = PfSvGetFileIndexNumber(SectionNode->FilePath,
                                               &SectionNode->FileIndexNumber);
            
            if (ErrorCode == ERROR_SUCCESS) {

                if (VolumeNode) {
                
                    //
                    // Insert this section node into the section list of
                    // the volume it is on.
                    //
                    
                    InsertTailList(&VolumeNode->SectionList, 
                                   &SectionNode->SectionVolumeLink);
                    
                    VolumeNode->NumSections++;

                    //
                    // Update volume node's directory list with parent
                    // directories of this file.
                    //
                    
                    PfSvAddParentDirectoriesToList(&VolumeNode->DirectoryList,
                                                   VolumeNode->VolumePathLength,
                                                   SectionNode->FilePath,
                                                   SectionNode->SectionRecord.FileNameLength);
                }
            }
        }

        //
        // Update number of sections, number of pages and file name
        // info length on the scenario.
        //
        
        Scenario->NumSections++;
        Scenario->NumPages += SectionNode->SectionRecord.NumPages;
        
        FileNameSize = sizeof(WCHAR) * 
            (SectionNode->SectionRecord.FileNameLength + 1);
        Scenario->FileNameInfoSize += FileNameSize;
    }

    //
    // We are done. 
    //

    ErrorCode = ERROR_SUCCESS;

    DBGPR((PFID,PFTRC,"PFSVC: ApplyPrefetchPolicy()=%x\n", ErrorCode));

    return ErrorCode;
}

ULONG 
PfSvGetNumTimesUsed(
    ULONG UsageHistory,
    ULONG UsageHistorySize
    )

/*++

Routine Description:

    Calculate how many times a page seems to be used according to
    UsageHistory.

Arguments:

    UsageHistory - Bitmap. 1's correspond to "was used", 0 = "not used".
    
    UsageHistorySize - Size of UsageHistory in bits from the least
      significant bit.

Return Value:

    How many times the page seems to be used.

--*/

{
    ULONG NumUsed;
    ULONG BitIdx;

    //
    // Initialize locals.
    //

    NumUsed = 0;

    //
    // Walk through the bits in usage history starting from the least
    // significant and count how many bits are on. We can probably do
    // this more efficiently.
    //
    // FUTURE-2002/03/29-ScottMa -- You're right... We CAN do this more
    //   efficiently!

    for (BitIdx = 0; BitIdx < UsageHistorySize; BitIdx++) {
        if (UsageHistory & (1 << BitIdx)) {
            NumUsed++;
        }
    }

    return NumUsed;
}

ULONG 
PfSvGetTraceEndIdx(
    PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    Determines the index of the last page logged in the trace.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Index of the last page logged.

--*/

{
    ULONG TotalFaults;
    ULONG PeriodIdx;
    ULONG *Id;

    DBGPR((PFID,PFSTRC,"PFSVC: GetTraceEndIdx(%p)\n", Trace));

    TotalFaults = Trace->FaultsPerPeriod[0];

    for (PeriodIdx = 1; PeriodIdx < PF_MAX_NUM_TRACE_PERIODS; PeriodIdx++) {
        
        if(Trace->FaultsPerPeriod[PeriodIdx] < PFSVC_MIN_FAULT_THRESHOLD) {

            //
            // If this is not the boot scenario, determine that
            // scenario has ended when logged pagefaults for a time
            // slice falls below minimum.
            //

            if (Trace->ScenarioType != PfSystemBootScenarioType) {
                break;
            }
        }
        
        TotalFaults += Trace->FaultsPerPeriod[PeriodIdx];
    }

    //
    // Sum of entries per period should not be greater than all
    // entries logged.
    //

    PFSVC_ASSERT(TotalFaults <= Trace->NumEntries);

    DBGPR((PFID,PFSTRC,"PFSVC: GetTraceEndIdx(%p)=%d\n", Trace, TotalFaults));

    return TotalFaults;
}

//
// Routines to write updated scenario instructions to the scenario
// file.
//

DWORD
PfSvWriteScenario(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PWCHAR ScenarioFilePath
    )

/*++

Routine Description:

    Prepare scenario instructions structure from the scenarion info
    and write it to the specified file.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    ScenarioFilePath - Path to scenarion file to update.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPF_SCENARIO_HEADER Scenario;
    ULONG FailedCheck;
      
    //
    // Initialize locals.
    //
    
    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: WriteScenario(%ws)\n", ScenarioFilePath));

    //
    // Build scenario dump from information we gathered.
    //

    ErrorCode = PfSvPrepareScenarioDump(ScenarioInfo, &Scenario);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Make sure the scenario we built passes the checks.
    //
    
    if (!PfSvVerifyScenarioBuffer(Scenario, Scenario->Size, &FailedCheck) ||
        Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
        PFSVC_ASSERT(FALSE);
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Write out the buffer.
    //

    ErrorCode = PfSvWriteBuffer(ScenarioFilePath, Scenario, Scenario->Size);

    //
    // Fall through with ErrorCode.
    //

 cleanup:

    if (Scenario) {
        PFSVC_FREE(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: WriteScenario(%ws)=%x\n", ScenarioFilePath, ErrorCode));
       
    return ErrorCode;
}

DWORD
PfSvPrepareScenarioDump(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OUT PPF_SCENARIO_HEADER *ScenarioPtr
    ) 

/*++

Routine Description:

    Allocate a contiguous scenario buffer and fill it in with
    information in ScenarioInfo. ScenarioInfo is not modified.

Arguments:

    ScenarioInfo - Pointer to scenario information built from an
      existing scenario file and a scenario trace.

    ScenarioPtr - If successful, pointer to allocated and built
      scenario is put here. The caller should free this buffer when
      done with it.
    
Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;
    ULONG Size;
    DWORD ErrorCode;
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD Section;
    PPFSVC_SECTION_NODE SectionNode;
    ULONG CurSectionIdx;
    PPF_PAGE_RECORD Pages;
    PPF_PAGE_RECORD Page;
    PPF_PAGE_RECORD PreviousPage;
    PPFSVC_PAGE_NODE PageNode;
    ULONG CurPageIdx;
    PCHAR FileNames;
    ULONG CurFileInfoOffset;
    PCHAR DestPtr;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;
    ULONG FileNameSize;
    PPFSVC_VOLUME_NODE VolumeNode;
    PLIST_ENTRY HeadVolume;
    PLIST_ENTRY NextVolume;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataInfoSize;
    ULONG NumMetadataRecords;
    ULONG CurMetadataRecordIdx;
    ULONG CopySize;
    ULONG CurFilePrefetchIdx;
    ULONG FilePrefetchInfoSize;
    ULONG FilePrefetchCount;
    PFILE_PREFETCH FilePrefetchInfo;
    WCHAR *DirectoryPath;
    ULONG DirectoryPathLength;
    PPFSVC_PATH PathEntry;
    LARGE_INTEGER IndexNumber;
    ULONG DirectoryPathInfoSize;
    ULONG DirectoryPathSize;
    PPF_COUNTED_STRING DirectoryPathCS;

    //
    // Initialize locals.
    //

    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: PrepareScenarioDump()\n"));

    //
    // Calculate how big the scenario is going to be.
    //
    
    Size = sizeof(PF_SCENARIO_HEADER);
    Size += ScenarioInfo->ScenHeader.NumSections * sizeof(PF_SECTION_RECORD);
    Size += ScenarioInfo->ScenHeader.NumPages * sizeof(PF_PAGE_RECORD);
    Size += ScenarioInfo->ScenHeader.FileNameInfoSize;

    //
    // Add space for the metadata prefetch information.
    //

    //
    // Make some space for aligning the metadata records table.
    //

    MetadataInfoSize = _alignof(PF_METADATA_RECORD);

    HeadVolume = &ScenarioInfo->VolumeList;
    NextVolume = HeadVolume->Flink;

    NumMetadataRecords = 0;
    
    while (NextVolume != HeadVolume) {

        VolumeNode = CONTAINING_RECORD(NextVolume,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextVolume = NextVolume->Flink;

        //
        // If there are no sections at all on this volume, skip it.
        //

        if (VolumeNode->NumAllSections == 0) {
            continue;
        }

        NumMetadataRecords++;

        //
        // Metadata record:
        //

        MetadataInfoSize += sizeof(PF_METADATA_RECORD);
        
        //
        // Volume Path:
        //

        MetadataInfoSize += (VolumeNode->VolumePathLength + 1) * sizeof(WCHAR);
        
        //
        // FilePrefetchInfo buffer: This has to be ULONGLONG
        // aligned. Add extra space for that in case.
        //

        MetadataInfoSize += _alignof(FILE_PREFETCH);
        MetadataInfoSize += sizeof(FILE_PREFETCH);
        
        if (VolumeNode->NumSections) {
            MetadataInfoSize += (VolumeNode->NumSections - 1) * sizeof(ULONGLONG);
        }

        MetadataInfoSize += VolumeNode->DirectoryList.NumPaths * sizeof(ULONGLONG);

        if (VolumeNode->MFTSectionNode) {
            MetadataInfoSize += VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch * sizeof(ULONGLONG);
        }

        //
        // Add space for the directory paths on this volume.
        //
        
        MetadataInfoSize += VolumeNode->DirectoryList.NumPaths * sizeof(PF_COUNTED_STRING);
        MetadataInfoSize += VolumeNode->DirectoryList.TotalLength * sizeof(WCHAR);
        
        //
        // Note that PF_COUNTED_STRING contains space for one
        // character. DirectoryList's total length excludes NUL's at
        // the end of each path.
        //
    }   

    Size += MetadataInfoSize;

    //
    // Allocate scenario buffer.
    //

    Scenario = PFSVC_ALLOC(Size);
    
    if (!Scenario) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Copy the header and set the size.
    //

    *Scenario = ScenarioInfo->ScenHeader;
    Scenario->Size = Size;

    DestPtr = (PCHAR) Scenario + sizeof(*Scenario);
    
    //
    // Initialize where our data is going.
    //
        
    Sections = (PPF_SECTION_RECORD) DestPtr;
    Scenario->SectionInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurSectionIdx = 0;
    
    DestPtr += Scenario->NumSections * sizeof(PF_SECTION_RECORD);
    
    Pages = (PPF_PAGE_RECORD) DestPtr;
    Scenario->PageInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurPageIdx = 0;

    DestPtr += Scenario->NumPages * sizeof(PF_PAGE_RECORD);

    FileNames = DestPtr;
    Scenario->FileNameInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurFileInfoOffset = 0;

    DestPtr += Scenario->FileNameInfoSize;

    //
    // Extra space for this alignment was allocated upfront.
    //

    PFSVC_ASSERT(PF_IS_POWER_OF_TWO(_alignof(PF_METADATA_RECORD)));
    MetadataInfoBase = PF_ALIGN_UP(DestPtr, _alignof(PF_METADATA_RECORD));
    DestPtr += MetadataInfoSize;

    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;
    Scenario->MetadataInfoOffset = (ULONG) (MetadataInfoBase - (PCHAR) Scenario);
    Scenario->MetadataInfoSize = (ULONG) (DestPtr - MetadataInfoBase);
    Scenario->NumMetadataRecords = NumMetadataRecords;

    //
    // Destination pointer should be at the end of the allocated
    // buffer now.
    //
    
    if (DestPtr != (PCHAR) Scenario + Scenario->Size) {

        PFSVC_ASSERT(FALSE);

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Walk through the sections on the new scenario info and copy
    // them.
    //

    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;

    while (SectHead != SectNext) {
        
        SectionNode = CONTAINING_RECORD(SectNext,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        
        //
        // The target section record.
        //

        Section = &Sections[CurSectionIdx];

        //
        // Copy section record info.
        //
                                   
        *Section = SectionNode->SectionRecord;

        //
        // Copy pages for the section.
        //

        Section->FirstPageIdx = PF_INVALID_PAGE_IDX;
        PreviousPage = NULL;
        
        PageHead = &SectionNode->PageList;
        PageNext = PageHead->Flink;
        
        while (PageNext != PageHead) {

            PageNode = CONTAINING_RECORD(PageNext,
                                         PFSVC_PAGE_NODE,
                                         PageLink);

            Page = &Pages[CurPageIdx];

            //
            // If this is the first page in the section, update first
            // page index on the section record.
            //

            if (Section->FirstPageIdx == PF_INVALID_PAGE_IDX) {
                Section->FirstPageIdx = CurPageIdx;
            }

            //
            // Copy page record.
            //

            *Page = PageNode->PageRecord;

            //
            // Update NextPageIdx on the previous page if there is
            // one.
            //

            if (PreviousPage) {
                PreviousPage->NextPageIdx = CurPageIdx;
            }

            //
            // Update previous page.
            //
            
            PreviousPage = Page;

            //
            // Set next link to list termination now. If there is a
            // next page it is going to update this.
            //

            Page->NextPageIdx = PF_INVALID_PAGE_IDX;

            //
            // Update position in the page record table.
            //

            CurPageIdx++;

            PFSVC_ASSERT(CurPageIdx <= Scenario->NumPages);

            PageNext = PageNext->Flink;
        }

        //
        // Copy over file name.
        //

        FileNameSize = (Section->FileNameLength + 1) * sizeof(WCHAR);
        
        RtlCopyMemory(FileNames + CurFileInfoOffset, 
                      SectionNode->FilePath, 
                      FileNameSize);

        //
        // Update section record's file name offset.
        //

        Section->FileNameOffset = CurFileInfoOffset;

        //
        // Update current index into file name info.
        //

        CurFileInfoOffset += FileNameSize;

        PFSVC_ASSERT(CurFileInfoOffset <= Scenario->FileNameInfoSize);
        
        //
        // Update our position in the section table.
        //
        
        CurSectionIdx++;

        PFSVC_ASSERT(CurSectionIdx <= Scenario->NumSections);

        SectNext = SectNext->Flink;
    }    

    //
    // Make sure we filled up the tables.
    //

    if (CurSectionIdx != Scenario->NumSections ||
        CurPageIdx != Scenario->NumPages ||
        CurFileInfoOffset != Scenario->FileNameInfoSize) {
        
        PFSVC_ASSERT(FALSE);

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Build and copy the metadata prefetch information.
    //

    //
    // Set our target to right after the metadata records table.
    //

    DestPtr = MetadataInfoBase + sizeof(PF_METADATA_RECORD) * NumMetadataRecords;
    CurMetadataRecordIdx = 0;
    
    HeadVolume = &ScenarioInfo->VolumeList;
    NextVolume = HeadVolume->Flink;
    
    while (NextVolume != HeadVolume) {

        VolumeNode = CONTAINING_RECORD(NextVolume,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextVolume = NextVolume->Flink;

        //
        // If there are no sections at all on this volume, skip it.
        //

        if (VolumeNode->NumAllSections == 0) {
            continue;
        }

        //
        // Make sure we are within bounds.
        //

        if (CurMetadataRecordIdx >= NumMetadataRecords) {
            PFSVC_ASSERT(CurMetadataRecordIdx < NumMetadataRecords);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        MetadataRecord = &MetadataRecordTable[CurMetadataRecordIdx];
        CurMetadataRecordIdx++;

        //
        // Copy volume identifiers. 
        //

        MetadataRecord->SerialNumber = VolumeNode->SerialNumber;
        MetadataRecord->CreationTime = VolumeNode->CreationTime;

        //
        // Copy volume name.
        //

        MetadataRecord->VolumeNameOffset = (ULONG) (DestPtr - MetadataInfoBase);
        MetadataRecord->VolumeNameLength = VolumeNode->VolumePathLength;
        CopySize = (VolumeNode->VolumePathLength + 1) * sizeof(WCHAR);
        
        if (DestPtr + CopySize > (PCHAR) Scenario + Scenario->Size) {
            PFSVC_ASSERT(FALSE);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        RtlCopyMemory(DestPtr, VolumeNode->VolumePath, CopySize);
        DestPtr += CopySize;

        //
        // Align and update DestPtr for the FILE_PREFETCH structure.
        //

        PFSVC_ASSERT(PF_IS_POWER_OF_TWO(_alignof(FILE_PREFETCH)));
        DestPtr = PF_ALIGN_UP(DestPtr, _alignof(FILE_PREFETCH));
        FilePrefetchInfo = (PFILE_PREFETCH) DestPtr;
        MetadataRecord->FilePrefetchInfoOffset = (ULONG) (DestPtr - MetadataInfoBase);
       
        //
        // Calculate size of the file prefetch information structure.
        //

        FilePrefetchCount = VolumeNode->NumSections;
        if (VolumeNode->MFTSectionNode) {
            FilePrefetchCount += VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch;
        }

        FilePrefetchCount += VolumeNode->DirectoryList.NumPaths;

        FilePrefetchInfoSize = sizeof(FILE_PREFETCH);
        if (FilePrefetchCount) {

            //
            // Note that there is room for one entry in the FILE_PREFETCH
            // structure.
            //
            
            FilePrefetchInfoSize += (FilePrefetchCount - 1) * sizeof(ULONGLONG);
        }

        MetadataRecord->FilePrefetchInfoSize = FilePrefetchInfoSize;

        if (DestPtr + FilePrefetchInfoSize > (PCHAR) Scenario + Scenario->Size) {
            PFSVC_ASSERT(FALSE);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        //
        // Update destination pointer.
        //

        DestPtr += FilePrefetchInfoSize;      

        //
        // Initialize file prefetch information structure.
        //

        FilePrefetchInfo->Type = FILE_PREFETCH_TYPE_FOR_CREATE;
        FilePrefetchInfo->Count = FilePrefetchCount;

        //
        // Build list of file indexes to prefetch:
        //

        CurFilePrefetchIdx = 0;

        //
        // Add file system index numbers for sections.
        //

        SectHead = &VolumeNode->SectionList;
        SectNext = SectHead->Flink;
        
        while(SectNext != SectHead) {
            
            SectionNode = CONTAINING_RECORD(SectNext,
                                            PFSVC_SECTION_NODE,
                                            SectionVolumeLink);
            
            SectNext = SectNext->Flink;
            
            if (CurFilePrefetchIdx >= VolumeNode->NumSections) {
                PFSVC_ASSERT(FALSE);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }

            //
            // Add the filesystem index number for this section to the list.
            //
            
            FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 
                SectionNode->FileIndexNumber.QuadPart;
            CurFilePrefetchIdx++;
        }

        //
        // Add file system index numbers for directories.
        //
        
        PathEntry = NULL;
        
        while (PathEntry = PfSvGetNextPathSorted(&VolumeNode->DirectoryList, 
                                                 PathEntry)) {

            DirectoryPath = PathEntry->Path;

            //
            // Get the file index number for this directory and add it
            // to the list we'll ask the filesystem to prefetch.
            //

            ErrorCode = PfSvGetFileIndexNumber(DirectoryPath, &IndexNumber);
            
            if (ErrorCode == ERROR_SUCCESS) {
                FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = IndexNumber.QuadPart;
            } else {
                FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 0;
            }
            
            CurFilePrefetchIdx++;
        }

        //
        // Add file system index numbers that we drive from direct MFT access.
        //

        if (VolumeNode->MFTSectionNode) {

            SectionNode = VolumeNode->MFTSectionNode;
    
            for (PageNext = SectionNode->PageList.Flink;
                 PageNext != &SectionNode->PageList;
                 PageNext = PageNext->Flink) {

                PageNode = CONTAINING_RECORD(PageNext,
                                             PFSVC_PAGE_NODE,
                                             PageLink);

                if (!PageNode->PageRecord.IsIgnore) {

                    //
                    // We know the file offset in MFT. Every file record is
                    // 1KB == 2^10 bytes. To convert fileoffset in MFT to a
                    // file record number we just shift it by 10.
                    //

                    FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 
                        PageNode->PageRecord.FileOffset >> 10;

                    CurFilePrefetchIdx++;
                }
            }
        }

        //
        // We should have specified all the file index numbers.
        //
        
        PFSVC_ASSERT(CurFilePrefetchIdx == FilePrefetchInfo->Count);

        //
        // Add paths for directories accessed on this volume.
        //

        MetadataRecord->NumDirectories = VolumeNode->DirectoryList.NumPaths;
        MetadataRecord->DirectoryPathsOffset = (ULONG)(DestPtr - MetadataInfoBase);             

        PathEntry = NULL;
        while (PathEntry = PfSvGetNextPathSorted(&VolumeNode->DirectoryList, 
                                                 PathEntry)) {
            
            DirectoryPath = PathEntry->Path;
            DirectoryPathLength = PathEntry->Length;

            //
            // Calculate how big the entry for this path is going to
            // be and make sure it will be within bounds.
            //

            DirectoryPathSize = sizeof(PF_COUNTED_STRING);
            DirectoryPathSize += DirectoryPathLength * sizeof(WCHAR);

            if (DestPtr + DirectoryPathSize > (PCHAR) Scenario + Scenario->Size) {
                PFSVC_ASSERT(FALSE);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }
            
            //
            // Copy over the directory path.
            //

            DirectoryPathCS = (PPF_COUNTED_STRING) DestPtr;
            DirectoryPathCS->Length = (USHORT) DirectoryPathLength;
            RtlCopyMemory(DirectoryPathCS->String, 
                          DirectoryPath, 
                          (DirectoryPathLength + 1) * sizeof(WCHAR));

            DestPtr += DirectoryPathSize;
        }
    }    

    //
    // Make sure we are not past the end of the buffer.
    //

    if (DestPtr > (PCHAR) Scenario + Scenario->Size) {
        PFSVC_ASSERT(FALSE);
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Set up return pointer.
    //

    *ScenarioPtr = Scenario;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (Scenario != NULL) {
            PFSVC_FREE(Scenario);
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: PrepareScenarioDump()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Routines to maintain the optimal disk layout file and update disk
// layout.
//

DWORD
PfSvUpdateOptimalLayout(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    This routine will determine if the optimal disk layout has to be 
    updated and if so it will write out a new layout file and launch
    the defragger.
        
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    ULARGE_INTEGER CurrentTimeLI;
    ULARGE_INTEGER LastDiskLayoutTimeLI;
    ULARGE_INTEGER MinTimeBeforeRelayoutLI;
    PFSVC_PATH_LIST OptimalLayout;
    PFSVC_PATH_LIST CurrentLayout;
    FILETIME LastDiskLayoutTime;
    FILETIME LayoutFileTime;
    FILETIME CurrentTime;
    PPFSVC_PATH_LIST NewLayout;
    PWCHAR LayoutFilePath;
    ULONG LayoutFilePathBufferSize;
    DWORD ErrorCode;
    DWORD BootScenarioProcessed;
    DWORD BootFilesWereOptimized;
    DWORD MinHoursBeforeRelayout;
    DWORD Size;
    DWORD RegValueType;
    BOOLEAN LayoutChanged;
    BOOLEAN MissingOriginalLayoutFile;
    BOOLEAN CheckForLayoutFrequencyLimit;

    //
    // Initialize locals.
    //

    LayoutFilePath = NULL;
    LayoutFilePathBufferSize = 0;
    PfSvInitializePathList(&OptimalLayout, NULL, FALSE);
    PfSvInitializePathList(&CurrentLayout, NULL, FALSE);

    DBGPR((PFID,PFTRC,"PFSVC: UpdateOptimalLayout(%p)\n", Task));

    //
    // Determine when we updated the disk layout from the layout file.
    //

    ErrorCode = PfSvGetLastDiskLayoutTime(&LastDiskLayoutTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Query whether boot files have been optimized.
    //

    Size = sizeof(BootFilesWereOptimized);

    ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME,
                                NULL,
                                &RegValueType,
                                (PVOID) &BootFilesWereOptimized,
                                &Size);

    if (ErrorCode != ERROR_SUCCESS) {
        BootFilesWereOptimized = FALSE;
    }

    //
    // Get optimal layout file path.
    //

    ErrorCode =  PfSvGetLayoutFilePath(&LayoutFilePath,
                                       &LayoutFilePathBufferSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Determine when the file was last modified.
    //

    ErrorCode = PfSvGetLastWriteTime(LayoutFilePath, &LayoutFileTime);

    if (ErrorCode == ERROR_SUCCESS) {

        MissingOriginalLayoutFile = FALSE;

        //
        // If the file was modified after we laid out the files on the disk
        // its contents are not interesting. Otherwise, if the new optimal
        // layout is similar to layout specified in the file, we may not
        // have to re-layout the files.
        //

        if (CompareFileTime(&LayoutFileTime, &LastDiskLayoutTime) <= 0) {

            //
            // Read the current layout.
            //

            ErrorCode = PfSvReadLayout(LayoutFilePath,
                                       &CurrentLayout,
                                       &LayoutFileTime);
            
            if (ErrorCode != ERROR_SUCCESS) {
                
                //
                // The layout file seems to be bad / inaccesible.
                // Cleanup the path list, so a brand new one gets
                // built.
                //

                PfSvCleanupPathList(&CurrentLayout);
                PfSvInitializePathList(&CurrentLayout, NULL, FALSE);
            }
        }

    } else {

        //
        // We could not get the timestamp on the original layout file.
        // It might have been deleted.
        //
        
        MissingOriginalLayoutFile = TRUE;
    }

    //
    // Determine what the current optimal layout should be from 
    // scenario files.
    //

    ErrorCode = PfSvDetermineOptimalLayout(Task, 
                                           &OptimalLayout, 
                                           &BootScenarioProcessed);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Update current layout based on what optimal layout should be.
    // If the two are similar we don't need to launch the defragger.
    //

    ErrorCode = PfSvUpdateLayout(&CurrentLayout, 
                                 &OptimalLayout,
                                 &LayoutChanged);

    if (ErrorCode == ERROR_SUCCESS) {

        if (!LayoutChanged) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // We'll use the updated layout.
        //

        NewLayout = &CurrentLayout;

    } else {

        //
        // We'll run with the optimal layout.
        //

        NewLayout = &OptimalLayout;
    }

    //
    // Optimal way to layout files has changed. Write out the new layout.
    //

    ErrorCode = PfSvSaveLayout(LayoutFilePath,
                               NewLayout,
                               &LayoutFileTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If enough time has not passed since last disk layout don't run the
    // defragger again unless...
    //

    CheckForLayoutFrequencyLimit = TRUE;

    //
    //   - We've been explicitly asked to update the layout (i.e. no idle
    //     task context.)
    //

    if (!Task) {
        CheckForLayoutFrequencyLimit = FALSE;        
    }

    //
    //   - Someone seems to have deleted the layout file and we recreated it.
    //

    if (MissingOriginalLayoutFile) {
        CheckForLayoutFrequencyLimit = FALSE;
    }

    //
    //   - Boot prefetching is enabled but boot files have not been optimized
    //     yet and we processed the list of files from the boot this time.
    //

    if (PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] == PfSvEnabled) {
        if (!BootFilesWereOptimized && BootScenarioProcessed) {
            CheckForLayoutFrequencyLimit = FALSE;
        }
    }

    if (CheckForLayoutFrequencyLimit) {

        //
        // We will check to see if enough time has passed by getting current 
        // time and comparing it to last disk layout time.
        //

        LastDiskLayoutTimeLI.LowPart = LastDiskLayoutTime.dwLowDateTime;
        LastDiskLayoutTimeLI.HighPart = LastDiskLayoutTime.dwHighDateTime;

        //
        // Get current time as file time.
        //

        GetSystemTimeAsFileTime(&CurrentTime);

        CurrentTimeLI.LowPart = CurrentTime.dwLowDateTime;
        CurrentTimeLI.HighPart = CurrentTime.dwHighDateTime;

        //
        // Check to make sure that current time is after last disk layout time
        // (in case the user has played with time.) 
        //

        if (CurrentTimeLI.QuadPart > LastDiskLayoutTimeLI.QuadPart) {

            //
            // Query how long has to pass before we re-layout the files on
            // disk.
            //
            
            Size = sizeof(MinHoursBeforeRelayout);

            ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                        PFSVC_MIN_RELAYOUT_HOURS_VALUE_NAME,
                                        NULL,
                                        &RegValueType,
                                        (PVOID) &MinHoursBeforeRelayout,
                                        &Size);

            if (ErrorCode == ERROR_SUCCESS) {
                MinTimeBeforeRelayoutLI.QuadPart = PFSVC_NUM_100NS_IN_AN_HOUR * MinHoursBeforeRelayout;
            } else {
                MinTimeBeforeRelayoutLI.QuadPart = PFSVC_MIN_TIME_BEFORE_DISK_RELAYOUT;
            }

            if (CurrentTimeLI.QuadPart < LastDiskLayoutTimeLI.QuadPart + 
                                         MinTimeBeforeRelayoutLI.QuadPart) {

                //
                // Not enough time has passed before last disk layout.
                //

                ErrorCode = ERROR_INVALID_TIME;
                goto cleanup;               
            }
        }       
    }

    //
    // Launch the defragger for layout optimization.
    //

    ErrorCode = PfSvLaunchDefragger(Task, TRUE, NULL);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save whether boot files were optimized.
    //

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &BootScenarioProcessed,
                              sizeof(BootScenarioProcessed));

    //
    // Save the last time we updated disk layout to the registry.
    //

    ErrorCode = PfSvSetLastDiskLayoutTime(&LayoutFileTime);

    //
    // Fall through with error code.
    //

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: UpdateOptimalLayout(%p)=%x\n", Task, ErrorCode));

    PfSvCleanupPathList(&OptimalLayout);
    PfSvCleanupPathList(&CurrentLayout);

    if (LayoutFilePath) {
        PFSVC_FREE(LayoutFilePath);
    }

    return ErrorCode;
}

DWORD
PfSvUpdateLayout (
    PPFSVC_PATH_LIST CurrentLayout,
    PPFSVC_PATH_LIST OptimalLayout,
    PBOOLEAN LayoutChanged
    )

/*++

Routine Description:

    This routine updates the specified layout based on the new optimal
    layout. If the two layouts are similar, CurrentLayout is not updated.

    An error may be returned while CurrentLayout is being updated. It is the 
    caller's responsibility to revert CurrentLayout to its original in that case.

Arguments:

    CurrentLayout - Current file layout.

    OptimalLayout - Newly determined optimal file layout.

    LayoutChanged - Whether Layout was changed.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPFSVC_PATH PathEntry;
    ULONG NumOptimalLayoutFiles;
    ULONG NumMissingFiles;
    ULONG NumCommonFiles;
    ULONG NumCurrentLayoutOnlyFiles;

    //
    // Initialize locals.
    //

    NumOptimalLayoutFiles = 0;
    NumMissingFiles = 0;

    //
    // Go through the paths in the new layout counting the differences with
    // the current layout.
    //

    PathEntry = NULL;

    while (PathEntry = PfSvGetNextPathInOrder(OptimalLayout, PathEntry)) {

        NumOptimalLayoutFiles++;

        if (!PfSvIsInPathList(CurrentLayout, PathEntry->Path, PathEntry->Length)) {
            NumMissingFiles++;
        }
    }

    //
    // Make some sanity checks about the statistics gathered.
    //

    PFSVC_ASSERT(NumOptimalLayoutFiles == OptimalLayout->NumPaths);
    PFSVC_ASSERT(NumOptimalLayoutFiles >= NumMissingFiles);

    NumCommonFiles = NumOptimalLayoutFiles - NumMissingFiles;
    PFSVC_ASSERT(CurrentLayout->NumPaths >= NumCommonFiles);

    NumCurrentLayoutOnlyFiles = CurrentLayout->NumPaths - NumCommonFiles;

    //
    // If there are not that many new files: no need to update the layout. 
    //

    if (NumMissingFiles <= 20) {
                
        *LayoutChanged = FALSE;
        ErrorCode = ERROR_SUCCESS;

        goto cleanup;
    } 

    //
    // We will be updating the current layout.
    //

    *LayoutChanged = TRUE;

    //
    // If there are too many files in the current layout that don't need to be
    // there anymore, rebuild the list.
    //

    if (NumCurrentLayoutOnlyFiles >= CurrentLayout->NumPaths / 4) {
        PfSvCleanupPathList(CurrentLayout);
        PfSvInitializePathList(CurrentLayout, NULL, FALSE);
    }
    
    //
    // Add files from the optimal layout to the end of current layout.
    //

    while (PathEntry = PfSvGetNextPathInOrder(OptimalLayout, PathEntry)) {

        ErrorCode = PfSvAddToPathList(CurrentLayout, PathEntry->Path, PathEntry->Length);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: UpdateLayout(%p,%p)=%d,%x\n",CurrentLayout,OptimalLayout,*LayoutChanged,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvDetermineOptimalLayout (
    PPFSVC_IDLE_TASK Task,
    PPFSVC_PATH_LIST OptimalLayout,
    BOOL *BootScenarioProcessed
    )

/*++

Routine Description:

    This routine will determine if the optimal disk layout has to be 
    updated by looking at the existing scenario files.
        
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

    OptimalLayout - Initialized empty path list that will be built.

    BootScenarioProcessed - Whether we got the list of boot files from
      the boot scenario.

Return Value:

    Win32 error code.

--*/

{
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    FILETIME LayoutFileTime;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PWCHAR DosPathBuffer;
    ULONG DosPathBufferSize;
    DWORD ErrorCode;
    BOOLEAN AcquiredLock;
    WCHAR BootScenarioFileName[PF_MAX_SCENARIO_FILE_NAME];
    WCHAR BootScenarioFilePath[MAX_PATH + 1];
    
    //
    // Initialize locals.
    //

    PfSvInitializeScenarioFileCursor(&FileCursor);
    TranslationList = NULL;
    AcquiredLock = FALSE;
    DosPathBuffer = NULL;
    DosPathBufferSize = 0;

    DBGPR((PFID,PFTRC,"PFSVC: DetermineOptimalLayout(%p,%p)\n",Task,OptimalLayout));

    //
    // Initialize output variables.
    //

    *BootScenarioProcessed = FALSE;

    //
    // Acquire the prefetch root directory lock and initialize some locals.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = TRUE;

    //
    // Start the file cursor.
    //

    ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, PfSvcGlobals.PrefetchRoot);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Build the boot scenario file path.
    //

    swprintf(BootScenarioFileName, 
             PF_SCEN_FILE_NAME_FORMAT,
             PF_BOOT_SCENARIO_NAME,
             PF_BOOT_SCENARIO_HASHID,
             PF_PREFETCH_FILE_EXTENSION);

    _snwprintf(BootScenarioFilePath,
               MAX_PATH,
               L"%ws\\%ws",
               PfSvcGlobals.PrefetchRoot,
               BootScenarioFileName);   

    BootScenarioFilePath[MAX_PATH - 1] = 0;

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = FALSE;   

    //
    // Get translation list so we can convert NT paths in the trace to
    // Dos paths that the defragger understands.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&TranslationList);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Should we continue to run?
    //

    ErrorCode = PfSvContinueRunningTask(Task);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }       

    //
    // Add boot loader files to optimal layout.
    //

    ErrorCode = PfSvBuildBootLoaderFilesList(OptimalLayout);
        
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Add files from the boot scenario.
    //

    ErrorCode = PfSvUpdateLayoutForScenario(OptimalLayout, 
                                            BootScenarioFilePath,
                                            TranslationList,
                                            &DosPathBuffer,
                                            &DosPathBufferSize);

    if (ErrorCode == ERROR_SUCCESS) {
        *BootScenarioProcessed = TRUE;
    }

    //
    // Go through all the other scenario files.
    //

    while (TRUE) {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }       

        //
        // Get file info for the next scenario file.
        //

        ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor);

        if (ErrorCode == ERROR_NO_MORE_FILES) {
            break;
        }

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        PfSvUpdateLayoutForScenario(OptimalLayout, 
                                    FileCursor.FilePath,
                                    TranslationList,
                                    &DosPathBuffer,
                                    &DosPathBufferSize);
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: DetermineOptimalLayout(%p,%p)=%x\n",Task,OptimalLayout,ErrorCode));

    if (AcquiredLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (TranslationList) {
        PfSvFreeNtPathTranslationList(TranslationList);
    }

    if (DosPathBuffer) {
        PFSVC_ASSERT(DosPathBufferSize);
        PFSVC_FREE(DosPathBuffer);
    }

    return ErrorCode;
}

DWORD
PfSvUpdateLayoutForScenario (
    PPFSVC_PATH_LIST OptimalLayout,
    WCHAR *ScenarioFilePath,
    PNTPATH_TRANSLATION_LIST TranslationList,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    )

/*++

Routine Description:

    This routine will add the directories and files referenced in a 
    scenario in the order they appear to the specified optimal layout 
    path list .
        
Arguments:

    OptimalLayout - Pointer to path list.

    ScenarioFilePath - Scenario file.

    TranslationList, DosPathBuffer, DosPathBufferSize - These are used
      to translate NT path names in the scenario file to Dos path names
      that should be in the layout file.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    PPF_COUNTED_STRING DirectoryPath;
    PPF_SECTION_RECORD Sections;
    PCHAR FilePathInfo;
    PWCHAR FilePath;
    ULONG FilePathLength;
    ULONG SectionIdx;
    ULONG MetadataRecordIdx;
    ULONG DirectoryIdx;
    DWORD ErrorCode;
    DWORD FileSize;
    DWORD FailedCheck;

    //
    // Initialize locals.
    //

    Scenario = NULL;

    //
    // Map the scenario file.
    //

    ErrorCode = PfSvGetViewOfFile(ScenarioFilePath, 
                                  &Scenario,
                                  &FileSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Verify scenario file.
    //

    if (!PfSvVerifyScenarioBuffer(Scenario, FileSize, &FailedCheck) ||
        Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // First add the directories that need to be accessed.
    //
    
    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];

        DirectoryPath = (PPF_COUNTED_STRING)
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx++,
               DirectoryPath = (PPF_COUNTED_STRING) (&DirectoryPath->String[DirectoryPath->Length + 1])) {

            ErrorCode = PfSvTranslateNtPath(TranslationList,
                                            DirectoryPath->String,
                                            DirectoryPath->Length,
                                            DosPathBuffer,
                                            DosPathBufferSize);

            //
            // We may not be able to translate all NT paths to Dos paths.
            //

            if (ErrorCode == ERROR_SUCCESS) {

                ErrorCode = PfSvAddToPathList(OptimalLayout,
                                              *DosPathBuffer,
                                              wcslen(*DosPathBuffer));

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }
            }
        }       
    }

    //
    // Now add the file paths.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);
    FilePathInfo = (PCHAR)Scenario + Scenario->FileNameInfoOffset;

    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {

        FilePath = (PWSTR) (FilePathInfo + Sections[SectionIdx].FileNameOffset);
        FilePathLength = Sections[SectionIdx].FileNameLength;
        
        ErrorCode = PfSvTranslateNtPath(TranslationList,
                                        FilePath,
                                        FilePathLength,
                                        DosPathBuffer,
                                        DosPathBufferSize);

        //
        // We may not be able to translate all NT paths to Dos paths.
        //

        if (ErrorCode == ERROR_SUCCESS) {

            ErrorCode = PfSvAddToPathList(OptimalLayout,
                                          *DosPathBuffer,
                                          wcslen(*DosPathBuffer));

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: UpdateLayoutForScenario(%p,%ws)=%x\n",OptimalLayout,ScenarioFilePath,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvReadLayout(
    IN WCHAR *FilePath,
    OUT PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    )

/*++

Routine Description:

    This function adds contents of the optimal layout file to the
    specified path list. Note that failure may be returned after
    adding several files to the list.

Arguments:

    FilePath - NUL terminated path to optimal layout file.

    Layout - Pointer to initialized path list.     

    LastWriteTime - Last write time of the read file.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    FILE *LayoutFile;
    WCHAR *LineBuffer;
    ULONG LineBufferMaxChars;
    ULONG LineLength;

    //
    // Initialize locals.
    //
    
    LayoutFile = NULL;
    LineBuffer = NULL;
    LineBufferMaxChars = 0;

    //
    // Open the layout file.
    //
    
    LayoutFile = _wfopen(FilePath, L"rb");
    
    if (!LayoutFile) {
        ErrorCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // Read and verify header.
    //

    ErrorCode = PfSvReadLine(LayoutFile,
                             &LineBuffer,
                             &LineBufferMaxChars,
                             &LineLength);
    
    if (ErrorCode != ERROR_SUCCESS || !LineLength) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);
    
    if (wcscmp(LineBuffer, L"[OptimalLayoutFile]")) {

        //
        // Notepad puts a weird first character in the UNICODE text files.
        // Skip the first character and compare again.
        //

        // FUTURE-2002/03/29-ScottMa -- Strictly speaking, that first character
        //   is the UNICODE marker character, which must be 0xFFFE if the file
        //   was written on the same -endian machine as it is being read, while
        //   0xFEFF would indicate that the file needs to be converted.
        
        if ((LineLength < 1) || 
            wcscmp(&LineBuffer[1], L"[OptimalLayoutFile]")) {

            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }
    }

    //
    // Read and verify version.
    //

    ErrorCode = PfSvReadLine(LayoutFile,
                             &LineBuffer,
                             &LineBufferMaxChars,
                             &LineLength);
    
    if (ErrorCode != ERROR_SUCCESS || !LineLength) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);

    if (wcscmp(LineBuffer, L"Version=1")) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    //
    // Read in file names.
    //

    do {

        ErrorCode = PfSvReadLine(LayoutFile,
                                 &LineBuffer,
                                 &LineBufferMaxChars,
                                 &LineLength);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        if (!LineLength) {
            
            //
            // We hit end of file.
            //

            break;
        }
    
        PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);
        
        //
        // Add it to the list.
        //
        
        ErrorCode = PfSvAddToPathList(Layout,
                                      LineBuffer,
                                      LineLength);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } while (TRUE);

    //
    // Get the last write time on the file.
    //

    ErrorCode = PfSvGetLastWriteTime(FilePath, LastWriteTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (LayoutFile) {
        fclose(LayoutFile);
    }
    
    if (LineBuffer) {
        PFSVC_ASSERT(LineBufferMaxChars);
        PFSVC_FREE(LineBuffer);
    }
    
    return ErrorCode;
} 

DWORD
PfSvSaveLayout(
    IN WCHAR *FilePath,
    IN PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    )

/*++

Routine Description:

    This routine saves the specified file layout list in order to the
    specified file in the right format.

Arguments:
      
    FilePath - Path to output layout file.

    Layout - Pointer to layout.

    LastWriteTime - Last write time on the file after we are done
      saving the layout.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    HANDLE LayoutFile;
    WCHAR *FileHeader;
    ULONG BufferSize;
    ULONG NumBytesWritten;
    PPFSVC_PATH PathEntry;
    WCHAR *NewLine;
    ULONG SizeOfNewLine;

    //
    // Initialize locals.
    //
    
    LayoutFile = INVALID_HANDLE_VALUE;
    NewLine = L"\r\n";
    SizeOfNewLine = wcslen(NewLine) * sizeof(WCHAR);

    //
    // Open & truncate the layout file. We are also opening with read
    // permissions so we can query the last write time when we are
    // done.
    //
    
    LayoutFile = CreateFile(FilePath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            0,
                            CREATE_ALWAYS,
                            0,
                            NULL);
    
    if (LayoutFile == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Write out the header.
    //

    FileHeader = L"[OptimalLayoutFile]\r\nVersion=1\r\n";
    BufferSize = wcslen(FileHeader) * sizeof(WCHAR);

    if (!WriteFile(LayoutFile,
                   FileHeader,
                   BufferSize,
                   &NumBytesWritten,
                   NULL)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    PathEntry = NULL;
    while (PathEntry = PfSvGetNextPathInOrder(Layout, PathEntry)) {
        
        //
        // Write the path.
        //

        BufferSize = PathEntry->Length * sizeof(WCHAR);

        if (!WriteFile(LayoutFile,
                       PathEntry->Path,
                       BufferSize,
                       &NumBytesWritten,
                       NULL)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // Write the newline.
        //

        if (!WriteFile(LayoutFile,
                       NewLine,
                       SizeOfNewLine,
                       &NumBytesWritten,
                       NULL)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }
    
    //
    // Make sure everything is written to the file so our
    // LastWriteTime will be accurate.
    //

    if (!FlushFileBuffers(LayoutFile)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get the last write time.
    //

    if (!GetFileTime(LayoutFile, NULL, NULL, LastWriteTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (LayoutFile != INVALID_HANDLE_VALUE) {
        CloseHandle(LayoutFile);
    }

    return ErrorCode;
}

DWORD
PfSvGetLayoutFilePath(
    PWCHAR *FilePathBuffer,
    PULONG FilePathBufferSize
    )

/*++

Routine Description:

    This function tries to query the layout file path into the
    specified buffer. If the buffer is too small, or NULL, it is
    reallocated. If not NULL, the buffer should have been allocated by
    PFSVC_ALLOC. It is the callers responsibility to free the returned
    buffer using PFSVC_FREE.

    In order to avoid having somebody cause us to overwrite any file
    in the system always the default layout file path is saved in the
    registry and returned.

Arguments:

    FilePathBuffer - Layout file path will be put into this buffer
      after it is reallocated if it is NULL or not big enough.

    FilePathBufferSize - Maximum size of *FilePathBuffer in bytes.

Return Value:

    Win32 error code.

--*/

{
    ULONG DefaultPathSize;
    ULONG DefaultPathLength;
    HKEY DefragParametersKey;
    DWORD ErrorCode;
    BOOLEAN AcquiredPrefetchRootLock;
    BOOLEAN OpenedParametersKey;

    //
    // Initialize locals.
    //

    AcquiredPrefetchRootLock = FALSE;
    OpenedParametersKey = FALSE;

    //
    // Verify parameters.
    //

    if (*FilePathBufferSize) {
        PFSVC_ASSERT(*FilePathBuffer);
    }

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = TRUE;

    DefaultPathLength = wcslen(PfSvcGlobals.PrefetchRoot);
    DefaultPathLength += 1;  // for '\\'
    DefaultPathLength += wcslen(PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME);

    DefaultPathSize = (DefaultPathLength + 1) * sizeof(WCHAR);

    //
    // Check if we have to allocate/reallocate the buffer.
    //

    if ((*FilePathBufferSize) < DefaultPathSize) {
        
        if (*FilePathBuffer) {
            PFSVC_ASSERT(*FilePathBufferSize);
            PFSVC_FREE(*FilePathBuffer);
        }
        
        (*FilePathBufferSize) = 0;

        (*FilePathBuffer) = PFSVC_ALLOC(DefaultPathSize);
        
        if (!(*FilePathBuffer)) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        (*FilePathBufferSize) = DefaultPathSize;
    }

    //
    // Build the path in the FilePathBuffer
    //
            
    wcscpy((*FilePathBuffer), PfSvcGlobals.PrefetchRoot);
    wcscat((*FilePathBuffer), L"\\");
    wcscat((*FilePathBuffer), PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME);

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = FALSE;

    //
    // Save the default path in the registry so it is used by the
    // defragger:
    //

    //
    // Open the parameters key, creating it if necessary.
    //
    
    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH,
                             &DefragParametersKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    OpenedParametersKey = TRUE;
                        
    ErrorCode = RegSetValueEx(DefragParametersKey,
                              PFSVC_OPTIMAL_LAYOUT_REG_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) (*FilePathBuffer),
                              (*FilePathBufferSize));
            
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

 cleanup:
    
    if (AcquiredPrefetchRootLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    if (OpenedParametersKey) {
        CloseHandle(DefragParametersKey);
    }   

    return ErrorCode;
}

//
// Routines to defrag the disks once after setup when the system is idle.
//

DWORD
PfSvLaunchDefragger(
    PPFSVC_IDLE_TASK Task,
    BOOLEAN ForLayoutOptimization,
    PWCHAR TargetDrive
    )

/*++

Routine Description:

    This routine will launch the defragger. It will create an event that
    will be passed to the defragger so the defragger can be stopped if
    the service is stopping or the Task (if one is specified) is being 
    unregistered, etc.
            
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

    ForLayoutOptimization - Whether we are launching the defragger
      only for layout optimization.

    TargetDrive - If we are not launching for layout optimization, the 
      drive that we want to defrag.

Return Value:

    Win32 error code.

--*/

{
    PROCESS_INFORMATION ProcessInfo; 
    STARTUPINFO StartupInfo; 
    WCHAR *CommandLine;
    WCHAR *DefragCommand;
    WCHAR *DoLayoutParameter;
    WCHAR *DriveToDefrag;
    HANDLE StopDefraggerEvent;
    HANDLE ProcessHandle;
    HANDLE Events[4];
    ULONG NumEvents;
    ULONG MaxEvents;
    DWORD ErrorCode;
    DWORD ExitCode;
    DWORD WaitResult;
    DWORD ProcessId;
    ULONG SystemDirLength;
    ULONG CommandLineLength;
    ULONG RetryCount;
    BOOL DefraggerExitOnItsOwn;
    WCHAR SystemDrive[3];
    WCHAR ProcessIdString[35];
    WCHAR StopEventString[35];
    WCHAR SystemDir[MAX_PATH + 1];

    //
    // Initialize locals.
    //
   
    StopDefraggerEvent = NULL;
    DefragCommand = L"\\defrag.exe\" ";
    DoLayoutParameter = L"-b ";
    CommandLine = NULL;
    RtlZeroMemory(&ProcessInfo, sizeof(PROCESS_INFORMATION));
    RtlZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO); 
    ProcessHandle = NULL;
    MaxEvents = sizeof(Events) / sizeof(HANDLE);

    DBGPR((PFID,PFTRC,"PFSVC: LaunchDefragger(%p,%d,%ws)\n",Task,(DWORD)ForLayoutOptimization,TargetDrive));

    //
    // If we are not allowed to run the defragger, don't.
    //

    if (!PfSvAllowedToRunDefragger(TRUE)) {
        ErrorCode = ERROR_ACCESS_DENIED;
        goto cleanup;
    }
    
    //
    // Get current process ID as string.
    //

    ProcessId = GetCurrentProcessId();
    swprintf(ProcessIdString, L"-p %x ", ProcessId);

    //
    // Create a stop event and convert handle value to string.
    //

    StopDefraggerEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!StopDefraggerEvent) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    swprintf(StopEventString, L"-s %p ", StopDefraggerEvent);

    //
    // Get path to system32 directory.
    //

    SystemDirLength = GetSystemDirectory(SystemDir, MAX_PATH);
    
    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SystemDirLength >= MAX_PATH) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    SystemDir[MAX_PATH - 1] = 0;

    //
    // Determine which drive we will be defragmenting.
    //

    if (ForLayoutOptimization) {

        //
        // Get system drive from system directory path.
        //
        
        SystemDrive[0] = SystemDir[0];
        SystemDrive[1] = SystemDir[1];
        SystemDrive[2] = 0;

        DriveToDefrag = SystemDrive;

    } else {

        DriveToDefrag = TargetDrive;
    }

    //
    // Build the command line to launch the process. All strings we put 
    // together include a trailing space.
    //

    CommandLineLength = 0;
    CommandLineLength += wcslen(L"\"");  // protect against spaces in SystemDir.
    CommandLineLength += wcslen(SystemDir);
    CommandLineLength += wcslen(DefragCommand); 
    CommandLineLength += wcslen(ProcessIdString);
    CommandLineLength += wcslen(StopEventString);

    if (ForLayoutOptimization) {
        CommandLineLength += wcslen(DoLayoutParameter);
    } 

    CommandLineLength += wcslen(DriveToDefrag);

    CommandLine = PFSVC_ALLOC((CommandLineLength + 1) * sizeof(WCHAR));

    if (!CommandLine) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(CommandLine, L"\"");
    wcscat(CommandLine, SystemDir);
    wcscat(CommandLine, DefragCommand);
    wcscat(CommandLine, ProcessIdString);
    wcscat(CommandLine, StopEventString);

    if (ForLayoutOptimization) {
        wcscat(CommandLine, DoLayoutParameter);
    }
    
    wcscat(CommandLine, DriveToDefrag);

    //
    // We may have to launch the defragger multiple times for it to make
    // or determine the space in which to layout files etc.
    //

    for (RetryCount = 0; RetryCount < 20; RetryCount++) {

        PFSVC_ASSERT(!ProcessHandle);

        //
        // Create the process.
        //
        
        // FUTURE-2002/03/29-ScottMa -- CreateProcess is safer if you supply
        //   the first parameter.  Since the full command-line was built up
        //   by this function, the first parameter is readily available.

        if (!CreateProcess (NULL,
                            CommandLine,
                            NULL,
                            NULL,
                            FALSE,
                            CREATE_NO_WINDOW,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo)) {

            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // Close handle to the thread, save the process handle.
        //

        CloseHandle(ProcessInfo.hThread);
        ProcessHandle = ProcessInfo.hProcess;

        //
        // Setup the events we will wait on.
        //

        NumEvents = 0;
        Events[NumEvents] = ProcessHandle;
        NumEvents++;
        Events[NumEvents] = PfSvcGlobals.TerminateServiceEvent;
        NumEvents ++;

        if (Task) {
            Events[NumEvents] = Task->StartedUnregisteringEvent;
            NumEvents++;
            Events[NumEvents] = Task->StopEvent;
            NumEvents++;      
        }
        
        PFSVC_ASSERT(NumEvents <= MaxEvents);

        DefraggerExitOnItsOwn = FALSE;

        WaitResult = WaitForMultipleObjects(NumEvents,
                                            Events,
                                            FALSE,
                                            INFINITE);

        switch(WaitResult) {

        case WAIT_OBJECT_0:

            //
            // The defragger process exit.
            //

            DefraggerExitOnItsOwn = TRUE;

            break;

        case WAIT_OBJECT_0 + 1:

            //
            // The service is exiting, Signal the defragger to exit, but don't
            // wait for it.
            //

            SetEvent(StopDefraggerEvent);

            ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
            goto cleanup;

            break;
            
        case WAIT_OBJECT_0 + 2:
        case WAIT_OBJECT_0 + 3:

            //
            // We would have specified these wait events only if a Task was
            // specified.
            //

            PFSVC_ASSERT(Task);

            //
            // Signal the defragger process to exit and wait for it to exit.
            //

            SetEvent(StopDefraggerEvent);

            NumEvents = 0;
            Events[NumEvents] = ProcessHandle;
            NumEvents++;
            Events[NumEvents] = PfSvcGlobals.TerminateServiceEvent;
            NumEvents++;

            WaitResult = WaitForMultipleObjects(NumEvents,
                                                Events,
                                                FALSE,
                                                INFINITE);

            if (WaitResult == WAIT_OBJECT_0) {

                //
                // Defragger exit, 
                //

                break;

            } else if (WaitResult == WAIT_OBJECT_0 + 1) {

                //
                // Service exiting, cannot wait for the defragger anymore.
                //

                ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
                goto cleanup;

            } else {

                ErrorCode = GetLastError();
                goto cleanup;
            }

            break;

        default:

            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // If we came here, the defragger exit. Determine its exit code and 
        // propagate it. If the defragger exit because we told it to, this should
        // be ENGERR_RETRY.
        //

        if (!GetExitCodeProcess(ProcessHandle, &ExitCode)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // If the defragger needs us to launch it again do so.
        //

        if (DefraggerExitOnItsOwn && (ExitCode == 9)) { // ENGERR_RETRY

            //
            // Reset the event that tells the defragger to stop.
            //

            ResetEvent(StopDefraggerEvent);

            //
            // Close to handle to the old defragger process.
            //

            CloseHandle(ProcessHandle);
            ProcessHandle = NULL;

            //
            // Setup the error code to return. If we've already retried 
            // too many times, this is the error that we'll return when
            // we end the retry loop.
            //

            ErrorCode = ERROR_REQUEST_ABORTED;
            
            continue;
        }

        //
        // If the defragger is crashing, note it so we don't attempt to run
        // it again. When the defragger crashes, its exit code is an NT status
        // code that will be error, e.g. 0xC0000005 for AV etc.
        //

        if (NT_ERROR(ExitCode)) {
            PfSvcGlobals.DefraggerErrorCode = ExitCode;
        }

        //
        // Translate the return value of the defragger to a Win32 error code.
        // These codes are defined in base\fs\utils\dfrg\inc\dfrgcmn.h.
        // I wish they were in a file I could include.
        //

        switch(ExitCode) {

        case 0: ErrorCode = ERROR_SUCCESS; break;               // ENG_NOERR
        case 1: ErrorCode = ERROR_RETRY; break;                 // ENG_USER_CANCELLED
        case 2: ErrorCode = ERROR_INVALID_PARAMETER; break;     // ENGERR_BAD_PARAM

        //
        // If the defragger's children processes AV / die, it will return 
        // ENGERR_UNKNOWN == 3.
        //

        case 3: 

            ErrorCode = ERROR_INVALID_FUNCTION;
            PfSvcGlobals.DefraggerErrorCode = STATUS_UNSUCCESSFUL;
            break;

        case 4: ErrorCode = ERROR_NOT_ENOUGH_MEMORY; break;     // ENGERR_NOMEM
        case 7: ErrorCode = ERROR_DISK_FULL; break;             // ENGERR_LOW_FREESPACE

        //
        // There is no good translation for the other exit codes or we just
        // don't understand them.
        //
        
        default: ErrorCode = ERROR_INVALID_FUNCTION;
        }

        //
        // The defragger returned success or an error other than retry. 
        //

        break;
    }

    //
    // Fall through with error code.
    //
    
 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: LaunchDefragger(%p)=%x\n",Task,ErrorCode));

    if (CommandLine) {
        PFSVC_FREE(CommandLine);
    }

    if (StopDefraggerEvent) {
        CloseHandle(StopDefraggerEvent);
    }

    if (ProcessHandle) {
        CloseHandle(ProcessHandle);
    }

    return ErrorCode; 
}

DWORD
PfSvGetBuildDefragStatusValueName (
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *ValueName
    )

/*++

Routine Description:

    This routine translates OsVersion to a string allocated with 
    PFSVC_ALLOC. The returned string should be freed by caller.
            
Arguments:

    OsVersion - Version info to translate to string.

    ValueName - Pointer to output string is returned here.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR BuildName;
    PWCHAR BuildNameFormat;
    ULONG BuildNameMaxLength;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    BuildName = NULL;
    BuildNameFormat = L"%x.%x.%x.%hx.%hx.%hx.%hx_DefragStatus";
    BuildNameMaxLength = 80;

    //
    // Allocate the string.
    //

    BuildName = PFSVC_ALLOC((BuildNameMaxLength + 1) * sizeof(WCHAR));

    if (!BuildName) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    _snwprintf(BuildName, 
               BuildNameMaxLength, 
               BuildNameFormat,
               OsVersion->dwBuildNumber,
               OsVersion->dwMajorVersion,
               OsVersion->dwMinorVersion,
               (WORD) OsVersion->wSuiteMask,
               (WORD) OsVersion->wProductType,
               (WORD) OsVersion->wServicePackMajor,
               (WORD) OsVersion->wServicePackMinor);

    //
    // Make sure the string is terminated.
    //

    BuildName[BuildNameMaxLength] = 0;

    *ValueName = BuildName;
    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (BuildName) {
            PFSVC_FREE(BuildName);
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetBuildName(%.80ws)=%x\n",BuildName,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvSetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR BuildDefragStatus,
    ULONG Size
    )

/*++

Routine Description:

    This routine will set the information on which drives have been 
    defragmented and such for the specified build (OsVersion).

    Defrag status is in REG_MULTI_SZ format. Each element is a drive
    path that has been defragged for this build. If all drives were
    defragged, than the first element is PFSVC_DEFRAG_DRIVES_DONE.
            
Arguments:

    OsVersion - Build & SP we are setting defrag status for.

    BuildDefragStatus - A string that describes the status in 
      REG_MULTI_SZ format.

    Size - Size in bytes of the data that has to be saved to the registry.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR ValueName;
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //

    ValueName = NULL;

    //
    // Build the value name from OS version info.
    //

    ErrorCode = PfSvGetBuildDefragStatusValueName(OsVersion, &ValueName);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              ValueName,
                              0,
                              REG_MULTI_SZ,
                              (PVOID) BuildDefragStatus,
                              Size);

    //
    // Fall through with error code.
    //
    
cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: SetBuildDefragStatus(%ws)=%x\n",BuildDefragStatus,ErrorCode));

    if (ValueName) {
        PFSVC_FREE(ValueName);
    }

    return ErrorCode;    
}

DWORD
PfSvGetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *BuildDefragStatus,
    PULONG ReturnSize
    )

/*++

Routine Description:

    This routine will get the information on which drives have been 
    defragmented and such for the specified build (OsVersion).

    Defrag status is in REG_MULTI_SZ format. Each element is a drive
    path that has been defragged for this build. If all drives were
    defragged, than the first element is PFSVC_DEFRAG_DRIVES_DONE.
            
Arguments:

    OsVersion - Build & SP we are querying defrag status for.

    BuildDefragStatus - Output for defrag status. If the function returns 
      success this should be freed with a call to PFSVC_FREE().

    ReturnSize - Size of the returned value in bytes.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR ValueBuffer;
    PWCHAR ValueName;
    DWORD ErrorCode;
    DWORD RegValueType;
    ULONG ValueBufferSize;
    ULONG Size;
    ULONG NumTries;
    ULONG DefaultValueSize;
    BOOLEAN InvalidValue;

    //
    // Initialize locals.
    //

    ValueName = NULL;
    ValueBuffer = NULL;
    ValueBufferSize = 0;
    InvalidValue = FALSE;

    //
    // Build the value name from OS version info.
    //

    ErrorCode = PfSvGetBuildDefragStatusValueName(OsVersion, &ValueName);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Try to allocate a right size buffer to read this value into.
    //

    NumTries = 0;
    
    do {

        Size = ValueBufferSize;

        ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                    ValueName,
                                    NULL,
                                    &RegValueType,
                                    (PVOID) ValueBuffer,
                                    &Size);

        //
        // API returns SUCCESS with required size in Size if ValueBuffer
        // is NULL. We have to special case that out.
        //

        if (ValueBuffer && ErrorCode == ERROR_SUCCESS) {

            //
            // We got it. Check the type. 
            //

            if (RegValueType != REG_MULTI_SZ) {

                //
                // Return default value.
                //

                InvalidValue = TRUE;

            } else {

                InvalidValue = FALSE;

                *ReturnSize = Size;
            }

            break;
        }

        if (ErrorCode ==  ERROR_FILE_NOT_FOUND) {

            //
            // The value does not exist. Return default value.
            //

            InvalidValue = TRUE;
            
            break;
        }

        if (ErrorCode != ERROR_MORE_DATA &&
            !(ErrorCode == ERROR_SUCCESS && !ValueBuffer)) {

            //
            // This is a real error.
            //

            goto cleanup;
        }

        //
        // Allocate a bigger buffer and try again.
        //

        PFSVC_ASSERT(ValueBufferSize < Size);

        if (ValueBuffer) {
            PFSVC_ASSERT(ValueBufferSize);
            PFSVC_FREE(ValueBuffer);
            ValueBufferSize = 0;           
        }

        ValueBuffer = PFSVC_ALLOC(Size);

        if (!ValueBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;            
        }

        ValueBufferSize = Size;

        NumTries++;

    } while (NumTries < 10);

    //
    // If we did not get a valid value from the registry, make up a default
    // one: empty string.
    //

    if (InvalidValue) {

        DefaultValueSize = sizeof(WCHAR);

        if (ValueBufferSize < DefaultValueSize) {

            if (ValueBuffer) {
                PFSVC_ASSERT(ValueBufferSize);
                PFSVC_FREE(ValueBuffer);
                ValueBufferSize = 0;            
            }

            ValueBuffer = PFSVC_ALLOC(DefaultValueSize);

            if (!ValueBuffer) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ValueBufferSize = DefaultValueSize;
        }

        ValueBuffer[0] = 0;

        *ReturnSize = DefaultValueSize;
    }

    //
    // We should get here only if we got a value in value buffer.
    //

    PFSVC_ASSERT(ValueBuffer && ValueBufferSize);

    *BuildDefragStatus = ValueBuffer;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: GetBuildDefragStatus(%.80ws)=%x\n",*BuildDefragStatus,ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {

        if (ValueBuffer) {
            PFSVC_ASSERT(ValueBufferSize);
            PFSVC_FREE(ValueBuffer);
        }
    }

    if (ValueName) {
        PFSVC_FREE(ValueName);
    }

    return ErrorCode;
}

DWORD
PfSvDefragDisks(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    If we have not defragged all disks after a setup/upgrade, do so.
    
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    PNTPATH_TRANSLATION_LIST VolumeList;
    PNTPATH_TRANSLATION_ENTRY VolumeEntry;
    PWCHAR DefraggedVolumeName;
    PWCHAR BuildDefragStatus;
    PWCHAR NewBuildDefragStatus;
    PLIST_ENTRY NextEntry;
    ULONG NewBuildDefragStatusLength;
    ULONG BuildDefragStatusSize;
    ULONG NewBuildDefragStatusSize;
    DWORD ErrorCode;
    BOOLEAN AlreadyDefragged;

    //
    // Initialize locals.
    //

    NewBuildDefragStatus = NULL;
    NewBuildDefragStatusSize = 0;
    BuildDefragStatus = NULL;
    BuildDefragStatusSize = 0;
    VolumeList = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: DefragDisks(%p)\n",Task));

    //
    // Determine defrag status for the current build.
    //

    ErrorCode = PfSvGetBuildDefragStatus(&PfSvcGlobals.OsVersion, 
                                         &BuildDefragStatus, 
                                         &BuildDefragStatusSize);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Check if we are already done for this build.
    //
    
    if (!_wcsicmp(BuildDefragStatus, PFSVC_DEFRAG_DRIVES_DONE)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Build a list of volumes that are mounted.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&VolumeList);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Walk through the volumes defragging the ones we have not yet
    // defragged after setup.
    //

    for (NextEntry = VolumeList->Flink;
         NextEntry != VolumeList;
         NextEntry = NextEntry->Flink) {

        VolumeEntry = CONTAINING_RECORD(NextEntry,
                                        NTPATH_TRANSLATION_ENTRY,
                                        Link);

        //
        // Skip volumes that are not fixed disks.
        //

        if (DRIVE_FIXED != GetDriveType(VolumeEntry->VolumeName)) {
            continue;
        }

        //
        // Have we already defragged this volume?
        //

        AlreadyDefragged = FALSE;

        for (DefraggedVolumeName = BuildDefragStatus;
             DefraggedVolumeName[0] != 0;
             DefraggedVolumeName += wcslen(DefraggedVolumeName) + 1) {

            PFSVC_ASSERT((PCHAR) DefraggedVolumeName < (PCHAR) BuildDefragStatus + BuildDefragStatusSize);

            if (!_wcsicmp(DefraggedVolumeName, VolumeEntry->DosPrefix)) {
                AlreadyDefragged = TRUE;
                break;
            }
        }

        if (AlreadyDefragged) {
            continue;
        }

        //
        // Launch the defragger to defrag this volume.
        //

        ErrorCode = PfSvLaunchDefragger(Task, FALSE, VolumeEntry->DosPrefix);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Note that we have defragged this volume.
        //

        NewBuildDefragStatusSize = BuildDefragStatusSize;
        NewBuildDefragStatusSize += (VolumeEntry->DosPrefixLength + 1) * sizeof(WCHAR);

        NewBuildDefragStatus = PFSVC_ALLOC(NewBuildDefragStatusSize);

        if (!NewBuildDefragStatus) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // Start with new defragged drive path.
        //

        wcscpy(NewBuildDefragStatus, VolumeEntry->DosPrefix);

        //
        // Append original status.
        //

        RtlCopyMemory(NewBuildDefragStatus + VolumeEntry->DosPrefixLength + 1, 
                      BuildDefragStatus, 
                      BuildDefragStatusSize);

        //
        // The last character and the one before that should be NUL.
        //

        PFSVC_ASSERT(NewBuildDefragStatus[NewBuildDefragStatusSize/sizeof(WCHAR)-1] == 0);
        PFSVC_ASSERT(NewBuildDefragStatus[NewBuildDefragStatusSize/sizeof(WCHAR)-2] == 0);

        //
        // Save the new status.
        //

        ErrorCode = PfSvSetBuildDefragStatus(&PfSvcGlobals.OsVersion,
                                             NewBuildDefragStatus,
                                             NewBuildDefragStatusSize);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Update the old variable.
        //

        PFSVC_ASSERT(BuildDefragStatus && BuildDefragStatusSize);
        PFSVC_FREE(BuildDefragStatus);

        BuildDefragStatus = NewBuildDefragStatus;
        NewBuildDefragStatus = NULL;
        BuildDefragStatusSize = NewBuildDefragStatusSize;
        NewBuildDefragStatusSize = 0;

        //
        // Continue to check & defrag other volumes.
        //
    }

    //
    // If we came here, then we have successfully defragged all the drives 
    // we had to. Set the status in the registry. Note that defrag status
    // value has to end with an additional NUL because it is REG_MULTI_SZ.
    //

    NewBuildDefragStatusSize = (wcslen(PFSVC_DEFRAG_DRIVES_DONE) + 1) * sizeof(WCHAR);
    NewBuildDefragStatusSize += sizeof(WCHAR);

    NewBuildDefragStatus = PFSVC_ALLOC(NewBuildDefragStatusSize);

    if (!NewBuildDefragStatus) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(NewBuildDefragStatus, PFSVC_DEFRAG_DRIVES_DONE);
    NewBuildDefragStatus[(NewBuildDefragStatusSize / sizeof(WCHAR)) - 1] = 0;

    ErrorCode = PfSvSetBuildDefragStatus(&PfSvcGlobals.OsVersion,
                                         NewBuildDefragStatus,
                                         NewBuildDefragStatusSize);

    //
    // Fall through with error code.
    //

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: DefragDisks(%p)=%x\n",Task,ErrorCode));

    if (BuildDefragStatus) {

        //
        // We should have NULL'ed NewBuildDefragStatus, otherwise we will
        // try to free the same memory twice.
        //
        
        PFSVC_ASSERT(BuildDefragStatus != NewBuildDefragStatus);

        PFSVC_ASSERT(BuildDefragStatusSize);
        PFSVC_FREE(BuildDefragStatus);
    }

    if (NewBuildDefragStatus) {
        PFSVC_ASSERT(NewBuildDefragStatusSize);
        PFSVC_FREE(NewBuildDefragStatus);
    }

    if (VolumeList) {
        PfSvFreeNtPathTranslationList(VolumeList);
    }

    return ErrorCode;
}

//
// Routines to cleanup old scenario files in the prefetch directory.
//

DWORD
PfSvCleanupPrefetchDirectory(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    If we have too many scenario files in the prefetch directory, discard the 
    ones that are not as useful to make room for new files.
    
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    PPFSVC_SCENARIO_AGE_INFO Scenarios;
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    PPF_SCENARIO_HEADER Scenario;
    ULONG NumPrefetchFiles;
    ULONG AllocationSize;
    ULONG NumScenarios;
    ULONG ScenarioIdx;
    ULONG PrefetchFileIdx;
    ULONG FileSize;
    ULONG FailedCheck;
    ULONG MaxRemainingScenarioFiles;
    ULONG NumLaunches;
    ULONG HoursSinceLastLaunch;
    FILETIME CurrentTime;
    ULARGE_INTEGER CurrentTimeLI;
    ULARGE_INTEGER LastLaunchTimeLI;
    DWORD ErrorCode;
    BOOLEAN AcquiredLock;

    //
    // Initialize locals.
    //

    AcquiredLock = FALSE;
    NumScenarios = 0;
    Scenarios = NULL;
    Scenario = NULL;
    GetSystemTimeAsFileTime(&CurrentTime);
    PfSvInitializeScenarioFileCursor(&FileCursor);
    CurrentTimeLI.LowPart = CurrentTime.dwLowDateTime;
    CurrentTimeLI.HighPart = CurrentTime.dwHighDateTime;

    DBGPR((PFID,PFTRC,"PFSVC: CleanupPrefetchDirectory(%p)\n",Task));

    //
    // Once we are done cleaning up, we should not have more than this many
    // prefetch files remaining.
    //

    MaxRemainingScenarioFiles = PFSVC_MAX_PREFETCH_FILES / 4;

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = TRUE;

    //
    // Start the file cursor.
    //

    ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, PfSvcGlobals.PrefetchRoot);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Count the number of files in the directory.
    //

    ErrorCode = PfSvCountFilesInDirectory(PfSvcGlobals.PrefetchRoot,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumPrefetchFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = FALSE;   

    //
    // Allocate an array that we will fill in with information from
    // scenario files to determine which ones need to be discarded.
    //

    AllocationSize = NumPrefetchFiles * sizeof(PFSVC_SCENARIO_AGE_INFO);

    Scenarios = PFSVC_ALLOC(AllocationSize);

    if (!Scenarios) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the scenarios array so we know what to clean up.
    //

    RtlZeroMemory(Scenarios, AllocationSize);
    NumScenarios = 0;

    //
    // Enumerate the scenario files:
    //

    ScenarioIdx = 0;
    PrefetchFileIdx = 0;

    do {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Get the file info for the next scenario file.
        //

        ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor);

        if (ErrorCode == ERROR_NO_MORE_FILES) {
            break;
        }

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Is the file name longer than what a valid prefetch file can be max?
        //

        if (FileCursor.FileNameLength > PF_MAX_SCENARIO_FILE_NAME) {

            //
            // Bogus file. Remove it.
            //

            DeleteFile(FileCursor.FilePath);
            goto NextPrefetchFile;
        }

        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileCursor.FilePath, 
                                      &Scenario,
                                      &FileSize);

        if (ErrorCode != ERROR_SUCCESS) {
            goto NextPrefetchFile;
        }

        //
        // Verify the scenario file.
        //

        if (!PfSvVerifyScenarioBuffer(Scenario, FileSize, &FailedCheck) ||
            Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
            DeleteFile(FileCursor.FilePath);
            goto NextPrefetchFile;
        }

        //
        // Skip boot scenario, we won't discard it.
        //

        if (Scenario->ScenarioType == PfSystemBootScenarioType) {
            goto NextPrefetchFile;
        }

        //
        // Determine the last time scenario was updated. I assume this 
        // corresponds to the last time scenario was launched...
        //

        LastLaunchTimeLI.LowPart = FileCursor.FileData.ftLastWriteTime.dwLowDateTime;
        LastLaunchTimeLI.HighPart = FileCursor.FileData.ftLastWriteTime.dwHighDateTime;

        if (CurrentTimeLI.QuadPart > LastLaunchTimeLI.QuadPart) {
            HoursSinceLastLaunch = (ULONG) ((CurrentTimeLI.QuadPart - LastLaunchTimeLI.QuadPart) / 
                                            PFSVC_NUM_100NS_IN_AN_HOUR);       
        } else {

            HoursSinceLastLaunch = 0;
        }

        //
        // Calculate weight: bigger weight means scenario file won't get
        // discarded. We calculate the weight by dividing the total number
        // times a scenario was launched by how long has it been since the last
        // launch of the scenario.
        //       

        NumLaunches = Scenario->NumLaunches;

        //
        // For the calculations below limit how large NumLaunches can be, so
        // values does not overflow.
        //

        if (NumLaunches > 1 * 1024 * 1024) {
            NumLaunches = 1 * 1024 * 1024;
        }

        //
        // Since we are going divide by number of hours (e.g. 7*24 for a program
        // launched a week ago) multiplying the number of launches with a number 
        // allows us to give a weight other than 0 to scenarios launched long ago.
        //
        
        Scenarios[ScenarioIdx].Weight = NumLaunches * 256;

        if (HoursSinceLastLaunch) {

             Scenarios[ScenarioIdx].Weight /= HoursSinceLastLaunch;
        }

        //
        // Copy over the file path.
        //

        AllocationSize = (FileCursor.FilePathLength + 1) * sizeof(WCHAR);

        Scenarios[ScenarioIdx].FilePath = PFSVC_ALLOC(AllocationSize);

        if (!Scenarios[ScenarioIdx].FilePath) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        wcscpy(Scenarios[ScenarioIdx].FilePath, FileCursor.FilePath);                    

        ScenarioIdx++;

    NextPrefetchFile:

        PrefetchFileIdx++;

        if (Scenario) {
            UnmapViewOfFile(Scenario);
            Scenario = NULL;
        }

    } while (PrefetchFileIdx < NumPrefetchFiles);

    //
    // If we do not have too many scenario files, we don't have to do anything.
    //

    NumScenarios = ScenarioIdx;

    if (NumScenarios <= MaxRemainingScenarioFiles) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Sort the age information.
    //

    qsort(Scenarios, 
          NumScenarios, 
          sizeof(PFSVC_SCENARIO_AGE_INFO),
          PfSvCompareScenarioAgeInfo);

    //
    // Delete the files with the smallest weight until we reach our goal.
    //

    for (ScenarioIdx = 0; 
         (ScenarioIdx < NumScenarios) && 
            ((NumScenarios - ScenarioIdx) > MaxRemainingScenarioFiles);
         ScenarioIdx++) {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }       

        DeleteFile(Scenarios[ScenarioIdx].FilePath);
    }

    //
    // Count the files in the directory now and update the global.
    //

    ErrorCode = PfSvCountFilesInDirectory(PfSvcGlobals.PrefetchRoot,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumPrefetchFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Note that global NumPrefetchFiles is not protected, so the new value
    // we are setting it to may be overwritten with an older value. It should
    // not be a big problem though, maybe resulting in this task being requeued.
    //

    PfSvcGlobals.NumPrefetchFiles = NumPrefetchFiles;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: CleanupPrefetchDirectory(%p)=%x\n",Task,ErrorCode));

    if (AcquiredLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (Scenarios) {

        for (ScenarioIdx = 0; ScenarioIdx < NumScenarios; ScenarioIdx++) {
            if (Scenarios[ScenarioIdx].FilePath) {
                PFSVC_FREE(Scenarios[ScenarioIdx].FilePath);
            }
        }

        PFSVC_FREE(Scenarios);
    }

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    return ErrorCode;
}

int
__cdecl 
PfSvCompareScenarioAgeInfo(
    const void *Param1,
    const void *Param2
    )

/*++

Routine Description:

    Qsort comparison function for PFSVC_SCENARIO_AGE_INFO structure.
    
Arguments:

    Param1, Param2 - pointer to PFSVC_SCENARIO_AGE_INFO structures

Return Value:

    Qsort comparison function return value.

--*/


{
    PFSVC_SCENARIO_AGE_INFO *Elem1;
    PFSVC_SCENARIO_AGE_INFO *Elem2;

    Elem1 = (PVOID) Param1;
    Elem2 = (PVOID) Param2;

    //
    // Compare precalculated weights.
    //

    if (Elem1->Weight > Elem2->Weight) {

        return 1;

    } else if (Elem1->Weight < Elem2->Weight) {

        return -1;

    } else {

        return 0;
    }
}

//
// Routines to enumerate scenario files.
//

VOID
PfSvInitializeScenarioFileCursor (
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Initializes the cursor structure so it can be safely cleaned up.
    
Arguments:

    FileCursor - Pointer to structure.

Return Value:

    None.

--*/

{
    FileCursor->FilePath = NULL;
    FileCursor->FileNameLength = 0;
    FileCursor->FilePathLength = 0;  
    FileCursor->CurrentFileIdx = 0;

    FileCursor->PrefetchRoot = NULL;
    FileCursor->FindFileHandle = INVALID_HANDLE_VALUE;

    return;
}

VOID
PfSvCleanupScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Cleans up an initialized and possibly started cursor structure.
    
Arguments:

    FileCursor - Pointer to structure.

Return Value:

    None.

--*/

{
    if (FileCursor->FilePath) {
        PFSVC_FREE(FileCursor->FilePath);
    }

    if (FileCursor->PrefetchRoot) {
        PFSVC_FREE(FileCursor->PrefetchRoot);
    }

    if (FileCursor->FindFileHandle != INVALID_HANDLE_VALUE) {
        FindClose(FileCursor->FindFileHandle);
    }

    return;
}

DWORD
PfSvStartScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor,
    WCHAR *PrefetchRoot
    )

/*++

Routine Description:

    After making this call on an initialized FileCursor, you can start
    enumerating the scenario files in that directory by calling the get
    next file function.

    You have to call the get next file function after starting the cursor
    to get the information on the first file.

    If this function fails, you should call cleanup on the FileCursor 
    structure and reinitialize it before trying to start the cursor again.
    
Arguments:

    FileCursor - Pointer to initialized cursor structure.

    PrefetchRoot - Directory path in which we'll look for prefetch
      files.

Return Value:

    Win32 error code.

--*/

{
    WCHAR *PrefetchFileSearchPattern;
    WCHAR *PrefetchFileSearchPath;
    ULONG PrefetchRootLength;
    ULONG PrefetchFileSearchPathLength;
    ULONG FileNameMaxLength;
    ULONG FilePathMaxLength;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PrefetchRootLength = wcslen(PrefetchRoot);
    PrefetchFileSearchPattern = L"\\*." PF_PREFETCH_FILE_EXTENSION;
    PrefetchFileSearchPath = NULL;

    //
    // The file cursor should have been initialized.
    //

    PFSVC_ASSERT(!FileCursor->CurrentFileIdx);
    PFSVC_ASSERT(!FileCursor->PrefetchRoot);
    PFSVC_ASSERT(FileCursor->FindFileHandle == INVALID_HANDLE_VALUE);

    //
    // Copy the prefetch root directory path.
    //

    FileCursor->PrefetchRoot = PFSVC_ALLOC((PrefetchRootLength + 1) * sizeof(WCHAR));

    if (!FileCursor->PrefetchRoot) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(FileCursor->PrefetchRoot, PrefetchRoot);
    FileCursor->PrefetchRootLength = PrefetchRootLength;

    //
    // Build the path we will pass in to enumerate the prefetch files.
    //

    PrefetchFileSearchPathLength = PrefetchRootLength;
    PrefetchFileSearchPathLength += wcslen(PrefetchFileSearchPattern);

    PrefetchFileSearchPath = PFSVC_ALLOC((PrefetchFileSearchPathLength + 1) * sizeof(WCHAR));

    if (!PrefetchFileSearchPath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(PrefetchFileSearchPath, PrefetchRoot);
    wcscat(PrefetchFileSearchPath, PrefetchFileSearchPattern);

    //
    // Allocate the string we will use to build the full path of the 
    // prefetch files. We can use it for prefetch files with names of 
    // max MAX_PATH. This works because that is the max file name that
    // can fit into WIN32_FIND_DATA structure.
    //

    FileNameMaxLength = MAX_PATH;

    FilePathMaxLength = PrefetchRootLength;
    FilePathMaxLength += wcslen(L"\\");
    FilePathMaxLength += FileNameMaxLength;

    FileCursor->FilePath = PFSVC_ALLOC((FilePathMaxLength + 1) * sizeof(WCHAR));

    if (!FileCursor->FilePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the first part of the file path and note where we will
    // start copying file names from.
    //

    wcscpy(FileCursor->FilePath, PrefetchRoot);
    wcscat(FileCursor->FilePath, L"\\");
    FileCursor->FileNameStart = PrefetchRootLength + 1;

    //
    // Start enumerating the files. Note that this puts the data for the
    // first file into FileData member.
    //

    FileCursor->FindFileHandle = FindFirstFile(PrefetchFileSearchPath, 
                                               &FileCursor->FileData);

    if (FileCursor->FindFileHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: StartFileCursor(%p,%ws)=%x\n",FileCursor,PrefetchRoot,ErrorCode));

    if (PrefetchFileSearchPath) {
        PFSVC_FREE(PrefetchFileSearchPath);
    }

    return ErrorCode;    
}

DWORD
PfSvGetNextScenarioFileInfo(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Fills in public fields of the FileCursor with information on the next
    scenario file.

    You have to call the get next file function after starting the cursor
    to get the information on the first file.

    Files with *names* longer than MAX_PATH will be skipped because it
    is not feasible to handle these with Win32 API.
    
Arguments:

    FileCursor - Pointer to started cursor structure.

Return Value:

    ERROR_NO_MORE_FILES - No more files to enumerate.

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // File cursor should have been started.
    //

    PFSVC_ASSERT(FileCursor->PrefetchRoot);
    PFSVC_ASSERT(FileCursor->FindFileHandle != INVALID_HANDLE_VALUE);

    //
    // If this it the first file, the FileData for it was already set when
    // we started the cursor. Otherwise call FindNextFile.
    //

    if (FileCursor->CurrentFileIdx != 0) {
        if (!FindNextFile(FileCursor->FindFileHandle, &FileCursor->FileData)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    FileCursor->FileNameLength = wcslen(FileCursor->FileData.cFileName);

    //
    // We allocated a file path to hold MAX_PATH file name in addition to the
    // directory path. FileData.cFileName is MAX_PATH sized.
    //

    PFSVC_ASSERT(FileCursor->FileNameLength < MAX_PATH);

    if (FileCursor->FileNameLength >= MAX_PATH) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Copy the file name.
    //

    wcscpy(FileCursor->FilePath + FileCursor->FileNameStart, 
           FileCursor->FileData.cFileName);

    FileCursor->FilePathLength = FileCursor->FileNameStart + FileCursor->FileNameLength;

    FileCursor->CurrentFileIdx++;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: GetNextScenarioFile(%p)=%ws,%x\n",FileCursor,FileCursor->FileData.cFileName,ErrorCode));

    return ErrorCode;
}

//
// File I/O utility routines.
//

DWORD
PfSvGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    )

/*++

Routine Description:

    Map the all of the specified file to memory.

Arguments:

    FilePath - NUL terminated path to file to map.
    
    BasePointer - Start address of mapping will be returned here.

    FileSize - Size of the mapping/file will be returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE InputHandle;
    HANDLE InputMappingHandle;
    DWORD ErrorCode;
    DWORD SizeL;
    DWORD SizeH;
    BOOLEAN OpenedFile;
    BOOLEAN CreatedFileMapping;

    //
    // Initialize locals.
    //

    OpenedFile = FALSE;
    CreatedFileMapping = FALSE;

    DBGPR((PFID,PFTRC,"PFSVC: GetViewOfFile(%ws)\n", FilePath));

    //
    // Note that we are opening the file exclusively. This guarantees
    // that for trace files as long as the kernel is not done writing
    // it we can't open the file, which guarantees we won't have an
    // incomplete file to worry about.
    //

    InputHandle = CreateFile(FilePath, 
                             GENERIC_READ, 
                             0,
                             NULL, 
                             OPEN_EXISTING, 
                             0, 
                             NULL);

    if (INVALID_HANDLE_VALUE == InputHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedFile = TRUE;

    SizeL = GetFileSize(InputHandle, &SizeH);

    if (SizeL == INVALID_FILE_SIZE && (GetLastError() != NO_ERROR )) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SizeH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    if (FileSize) {
        *FileSize = SizeL;
    }

    InputMappingHandle = CreateFileMapping(InputHandle, 
                                           0, 
                                           PAGE_READONLY, 
                                           0,
                                           0, 
                                           NULL);

    if (NULL == InputMappingHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedFileMapping = TRUE;
    
    *BasePointer = MapViewOfFile(InputMappingHandle, 
                                 FILE_MAP_READ, 
                                 0, 
                                 0, 
                                 0);

    if (NULL == *BasePointer) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedFile) {
        CloseHandle(InputHandle);
    }

    if (CreatedFileMapping) {
        CloseHandle(InputMappingHandle);
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetViewOfFile(%ws)=%x\n", FilePath, ErrorCode));

    return ErrorCode;
}

DWORD
PfSvWriteBuffer(
    PWCHAR FilePath,
    PVOID Buffer,
    ULONG Length
    )

/*++

Routine Description:

    This routine creats/overwrites the file at the specified path and
    writes the contents of the buffer to it.

Arguments:

    FilePath - Full path to the file.

    Buffer - Buffer to write out.

    Length - Number of bytes to write out from the buffer.

Return Value:

    Win32 error code.

--*/

{
    DWORD BytesWritten;
    HANDLE OutputHandle;
    DWORD ErrorCode;
    BOOL Result;

    //
    // Initialize locals.
    //

    OutputHandle = INVALID_HANDLE_VALUE;

    DBGPR((PFID,PFSTRC,"PFSVC: WriteBuffer(%p,%ws)\n", Buffer, FilePath));

    //
    // Open file overwriting any existing one. Don't share it so
    // nobody tries to read a half-written file.
    //

    OutputHandle = CreateFile(FilePath, 
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL, 
                              CREATE_ALWAYS, 
                              0, 
                              NULL);
    
    if (INVALID_HANDLE_VALUE == OutputHandle)
    {
        ErrorCode = GetLastError();      
        goto cleanup;
    }

    //
    // Write out the scenario.
    //

    Result = WriteFile(OutputHandle, 
                       Buffer, 
                       Length, 
                       &BytesWritten, 
                       NULL);

    if (!Result || (BytesWritten != Length)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (OutputHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(OutputHandle);
    }

    DBGPR((PFID,PFSTRC,"PFSVC: WriteBuffer(%p,%ws)=%x\n", Buffer, FilePath, ErrorCode));

    return ErrorCode;
}

DWORD
PfSvGetLastWriteTime (
    WCHAR *FilePath,
    PFILETIME LastWriteTime
    )

/*++

Routine Description:

    This function attempts to get the last write time for the
    specified file.

Arguments:

    FilePath - Pointer to NUL terminated path.

    LastWriteTime - Pointer to return buffer.

Return Value:

    Win32 error code.

--*/

{
    HANDLE FileHandle;
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //

    FileHandle = INVALID_HANDLE_VALUE;

    //
    // Open the file.
    //
    
    FileHandle = CreateFile(FilePath,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Query last write time.
    //

    if (!GetFileTime(FileHandle, NULL, NULL, LastWriteTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }

    return ErrorCode;
}

DWORD
PfSvReadLine (
    FILE *File,
    WCHAR **LineBuffer,
    ULONG *LineBufferMaxChars,
    ULONG *LineLength
    )

/*++

Routine Description:

    This function reads a line from the specified file into
    LineBuffer. If LineBuffer is NULL or not big enough, it is
    allocated or reallocated using PFSVC_ALLOC/FREE macros. It is the
    caller's reponsibility to free the returned buffer.

    Carriage return/Line feed characters are included in the returned
    LineBuffer & LineLength. Thus, a LineLength of 0 means end of file
    is hit. Returned LineBuffer is NUL terminated.

Arguments:

    File - File to read from.
    
    LineBuffer - Pointer to a buffer to read the line into.

    LineBufferMaxChars - Pointer to size of LineBuffer in characters,
      including room for NUL etc.
    
    LineLength - Pointer to length of the read line in characters
      including the carriage return/linefeed, excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR *NewBuffer;
    ULONG NewBufferMaxChars;
    WCHAR *CurrentReadPosition;
    ULONG MaxCharsToRead;

    //
    // Verify parameters.
    //

    PFSVC_ASSERT(LineBuffer && LineBufferMaxChars && LineLength);

    if (*LineBufferMaxChars) {
        PFSVC_ASSERT(*LineBuffer);
    } 

    //
    // If a zero length but non NULL buffer was passed in, free it so
    // we can allocate a larger initial one.
    //

    if (((*LineBufferMaxChars) == 0) && (*LineBuffer)) {
        PFSVC_FREE(*LineBuffer);
        (*LineBuffer) = NULL;
    }

    //
    // If no buffer was passed in, allocate one. We do not want to
    // enter the read line loop with a zero length or NULL buffer.
    //

    if (!(*LineBuffer)) {

        PFSVC_ASSERT((*LineBufferMaxChars) == 0);

        (*LineBuffer) = PFSVC_ALLOC(MAX_PATH * sizeof(WCHAR));
        
        if (!(*LineBuffer)) {
            ErrorCode = ERROR_INSUFFICIENT_BUFFER;
            goto cleanup;
        }
        
        (*LineBufferMaxChars) = MAX_PATH;
    }
    
    //
    // Initialize output length and NUL terminate the output line.
    //

    (*LineLength) = 0;   
    (*(*LineBuffer)) = 0;

    do {

        //
        // Try to read a line from the file.
        //
        
        CurrentReadPosition = (*LineBuffer) + (*LineLength);
        MaxCharsToRead = (*LineBufferMaxChars) - (*LineLength);

        if (!fgetws(CurrentReadPosition, 
                    MaxCharsToRead, 
                    File)) {
            
            //
            // If we have not hit an EOF, we have hit an error.
            //
            
            if (!feof(File)) {

                ErrorCode = ERROR_READ_FAULT;
                goto cleanup;

            } else {
                
                //
                // We hit end of file. Return what we have.
                //
                
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

        //
        // Update line length.
        //

        (*LineLength) += wcslen(CurrentReadPosition);
        
        //
        // If we have read a carriage return, we are done. Check to
        // see if we had room to read anything first!
        //

        if ((*LineLength) && (*LineBuffer)[(*LineLength) - 1] == L'\n') {
            break;
        }
        
        //
        // If we read up to the end of the buffer, resize it.
        //
        
        if ((*LineLength) == (*LineBufferMaxChars) - 1) {
        
            //
            // We should not enter this loop with a zero lengthed or NULL
            // line buffer.
            //

            PFSVC_ASSERT((*LineBufferMaxChars) && (*LineBuffer));

            NewBufferMaxChars = (*LineBufferMaxChars) * 2;
            NewBuffer = PFSVC_ALLOC(NewBufferMaxChars * sizeof(WCHAR));
        
            if (!NewBuffer) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            //
            // Copy contents of the original buffer and free it.
            //

            RtlCopyMemory(NewBuffer,
                          (*LineBuffer),
                          ((*LineLength) + 1) * sizeof(WCHAR));
                
            PFSVC_FREE(*LineBuffer);

            //
            // Update line buffer.
            //

            (*LineBuffer) = NewBuffer;
            (*LineBufferMaxChars) = NewBufferMaxChars;
        }
        
        //
        // Continue reading this line and appending it to output
        // buffer.
        //

    } while (TRUE);
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (ErrorCode == ERROR_SUCCESS && (*LineBufferMaxChars)) {
        
        //
        // Returned length must fit into buffer.
        //

        PFSVC_ASSERT((*LineLength) < (*LineBufferMaxChars));

        //
        // Returned buffer should be NUL terminated.
        //

        PFSVC_ASSERT((*LineBuffer)[(*LineLength)] == 0);
    }

    return ErrorCode;
}

DWORD
PfSvGetFileBasicInformation (
    WCHAR *FilePath,
    PFILE_BASIC_INFORMATION FileInformation
    )

/*++

Routine Description:

    This routine queries the basic attributes for the specified file.

Arguments:

    FilePath - Pointer to full NT file path, e.g. 
        \Device\HarddiskVolume1\boot.ini, NOT Win32 path, e.g. c:\boot.ini

    FileInformation - If successful the basic file info is returned here.

Return Value:

    Win32 error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FilePathU;
    NTSTATUS Status;
    DWORD ErrorCode;

    //
    // Query the file information.
    //

    RtlInitUnicodeString(&FilePathU, FilePath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &FilePathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtQueryAttributesFile(&ObjectAttributes,
                                   FileInformation);

    if (NT_SUCCESS(Status)) {

        //
        // In the typical success case, don't call possibly an expensive
        // routine to convert the error code.
        //

        ErrorCode = ERROR_SUCCESS;

    } else {

        ErrorCode = RtlNtStatusToDosError(Status);
    }

    return ErrorCode;
}

DWORD
PfSvGetFileIndexNumber(
    WCHAR *FilePath,
    PLARGE_INTEGER FileIndexNumber
    )

/*++

Routine Description:

    This routine queries the file system's IndexNumber for the specified
    file.

Arguments:

    FilePath - Pointer to full NT file path, e.g. 
        \Device\HarddiskVolume1\boot.ini, NOT Win32 path, e.g. c:\boot.ini

    FileIndexNumber - If successful the index number is returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE FileHandle;
    BOOLEAN OpenedFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FilePathU;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_INTERNAL_INFORMATION InternalInformation;

    //
    // Initialize locals.
    //
    
    OpenedFile = FALSE;

    //
    // Open the file.
    //

    RtlInitUnicodeString(&FilePathU, FilePath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &FilePathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateFile(&FileHandle,
                          STANDARD_RIGHTS_READ |
                            FILE_READ_ATTRIBUTES | 
                            FILE_READ_EA,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          0,
                          FILE_SHARE_READ | 
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);
    
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
    
    OpenedFile = TRUE;
      
    //
    // Query internal information.
    //
    
    Status = NtQueryInformationFile(FileHandle,
                                    &IoStatusBlock,
                                    &InternalInformation,
                                    sizeof(InternalInformation),
                                    FileInternalInformation);
    
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
        
    *FileIndexNumber = InternalInformation.IndexNumber;
    
    Status = STATUS_SUCCESS;

 cleanup:

    if (OpenedFile) {
        NtClose(FileHandle);
    }

    return RtlNtStatusToDosError(Status);
}

//
// String utility routines.
//

PFSV_SUFFIX_COMPARISON_RESULT
PfSvCompareSuffix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Suffix,
    ULONG SuffixLength,
    BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This compares the last characters of String to Suffix. The strings
    don't have to be NUL terminated. 

    NOTE: The lexical ordering is done starting from the LAST
    characters.

Arguments:

    String - String to check suffix of. 
    
    StringLength - Number of characters in String.

    Suffix - What the suffix of String should match.

    SuffixLength - Number of characters in Suffix.

    CaseSensitive - Whether the comparison should be case sensitive.

Return Value:

    PFSV_SUFFIX_COMPARISON_RESULT

--*/

{
    LONG StringCharIdx;
    WCHAR StringChar;
    LONG SuffixCharIdx;
    WCHAR SuffixChar;

    //
    // If suffix is longer than the string itself, it cannot match.
    //

    if (SuffixLength > StringLength) {
        return PfSvSuffixLongerThan;
    }

    //
    // If the suffix is 0 length it matches anything.
    //

    if (SuffixLength == 0) {
        return PfSvSuffixIdentical;
    }

    //
    // If the suffix is not 0 length and it is greater than
    // StringLength, StringLength cannot be 0.
    //

    PFSVC_ASSERT(StringLength);

    //
    // Start from the last character of the string and try to match
    // the suffix.
    //

    StringCharIdx = StringLength - 1;
    SuffixCharIdx = SuffixLength - 1;

    while (SuffixCharIdx >= 0) {

        SuffixChar = Suffix[SuffixCharIdx];
        StringChar = String[StringCharIdx];

        if (!CaseSensitive) {
            SuffixChar = towupper(SuffixChar);
            StringChar = towupper(StringChar);
        }

        //
        // Is comparing the values of chars same comparing them
        // lexically?
        //

        if (StringChar < SuffixChar) {
            return PfSvSuffixGreaterThan;
        } else if (StringChar > SuffixChar) {
            return PfSvSuffixLessThan;
        }
        
        //
        // Otherwise this character matches. Compare next one.
        //

        StringCharIdx--;
        SuffixCharIdx--;
    }

    //
    // All suffix characters matched.
    //

    return PfSvSuffixIdentical;
}

PFSV_PREFIX_COMPARISON_RESULT
PfSvComparePrefix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Prefix,
    ULONG PrefixLength,
    BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This compares the first characters of String to Prefix. The
    strings don't have to be NUL terminated.

Arguments:

    String - String to check prefix of. 
    
    StringLength - Number of characters in String.

    Suffix - What the prefix of String should match.

    SuffixLength - Number of characters in Prefix.

    CaseSensitive - Whether the comparison should be case sensitive.

Return Value:

    PFSV_PREFIX_COMPARISON_RESULT

--*/

{
    LONG StrCmpResult;
    
    //
    // If prefix is longer than the string itself, it cannot match.
    //

    if (PrefixLength > StringLength) {
        return PfSvPrefixLongerThan;
    }

    //
    // If the prefix is 0 length it matches anything.
    //

    if (PrefixLength == 0) {
        return PfSvPrefixIdentical;
    }

    //
    // If the prefix is not 0 length and it is greater than
    // StringLength, StringLength cannot be 0.
    //

    ASSERT(StringLength);

    //
    // Compare the prefix to the beginning of the string.
    //

    if (CaseSensitive) {
        StrCmpResult = wcsncmp(Prefix, String, PrefixLength);
    } else {
        StrCmpResult = _wcsnicmp(Prefix, String, PrefixLength);
    }

    if (StrCmpResult == 0) {
        return PfSvPrefixIdentical;
    } else if (StrCmpResult > 0) {
        return PfSvPrefixGreaterThan;
    } else {
        return PfSvPrefixLessThan;
    }
}

VOID
FASTCALL
PfSvRemoveEndOfLineChars (
    WCHAR *Line,
    ULONG *LineLength
    )

/*++

Routine Description:

    If the Line ends with \n/\r\n, these characters are removed and
    LineLength is adjusted accordingly.

Arguments:

    Line - Pointer to line string.
    
    LineLength - Pointer to length of line string in characters
      excluding any terminating NULs. This is updated if carriage
      return/linefeed characters are removed.

Return Value:

    None.

--*/

{
    if ((*LineLength) && (Line[(*LineLength) - 1] == L'\n')) {
        
        Line[(*LineLength) - 1] = 0;
        (*LineLength)--;

        if ((*LineLength) && (Line[(*LineLength) - 1] == L'\r')) {
            
            Line[(*LineLength) - 1] = 0;
            (*LineLength)--;
        }
    }
}

PWCHAR
PfSvcAnsiToUnicode(
    PCHAR str
    )

/*++

Routine Description:

    This routine converts an ANSI string into an allocated wide
    character string. The returned string should be freed by
    PfSvcFreeString.

Arguments:

    str - Pointer to string to convert.

Return Value:

    Allocated wide character string or NULL if there is a failure.

--*/

{
    ULONG len;
    wchar_t *retstr = NULL;

    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    retstr = (wchar_t *)PFSVC_ALLOC(len * sizeof(wchar_t));
    if (!retstr) 
    {
        return NULL;
    }
    MultiByteToWideChar(CP_ACP, 0, str, -1, retstr, len);
    return retstr;
}

PCHAR
PfSvcUnicodeToAnsi(
    PWCHAR wstr
    )

/*++

Routine Description:

    This routine converts a unicode string into an allocated ansi
    string. The returned string should be freed by PfSvcFreeString.

Arguments:

    wstr - Pointer to string to convert.

Return Value:

    Allocated ANSI string or NULL if there is a failure.

--*/

{
    ULONG len;
    char *retstr = NULL;
  
    len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, 0, 0);
    retstr = (char *) PFSVC_ALLOC(len * sizeof(char));
    if (!retstr)
    {
        return NULL;
    }
    WideCharToMultiByte(CP_ACP, 0, wstr, -1, retstr, len, 0, 0);
    return retstr;
}

VOID 
PfSvcFreeString(
    PVOID String
    )

/*++

Routine Description:

    This routine frees a string allocated and returned by
    PfSvcUnicodeToAnsi or PfSvcAnsiToUnicode.

Arguments:

    String - Pointer to string to free.

Return Value:

    None.

--*/

{
    PFSVC_FREE(String);
}

//
// Routines that deal with information in the registry.
//

DWORD
PfSvSaveStartInfo (
    HKEY ServiceDataKey
    )

/*++

Routine Description:

    This routine saves start time, prefetcher version etc. into the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    DWORD PrefetchVersion;
    SYSTEMTIME LocalTime;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;

    //
    // Initialize locals.
    //

    PrefetchVersion = PF_CURRENT_VERSION;
    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save version.
    //

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_VERSION_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PrefetchVersion,
                              sizeof(PrefetchVersion));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Get system time and convert it to a string.
    //
    
    GetLocalTime(&LocalTime);
    
    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalTime.wYear,
               (ULONG)LocalTime.wMonth,
               (ULONG)LocalTime.wDay,
               (ULONG)LocalTime.wHour,
               (ULONG)LocalTime.wMinute,
               (ULONG)LocalTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;
    
    //
    // Save it to the registry.
    //

    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_START_TIME_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save the initial statistics (which should be mostly zeros).
    //

    ErrorCode = PfSvSaveTraceProcessingStatistics(ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvSaveExitInfo (
    HKEY ServiceDataKey,
    DWORD ExitCode
    )

/*++

Routine Description:

    This routine saves the prefetcher service exit information to the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.
    
    ExitCode - Win32 error code the service is exiting with.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    SYSTEMTIME LocalTime;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;

    //
    // Initialize locals.
    //

    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save exit code.
    //   
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_EXIT_CODE_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &ExitCode,
                              sizeof(ExitCode));
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Get system time and convert it to a string.
    //
    
    GetLocalTime(&LocalTime);
    
    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalTime.wYear,
               (ULONG)LocalTime.wMonth,
               (ULONG)LocalTime.wDay,
               (ULONG)LocalTime.wHour,
               (ULONG)LocalTime.wMinute,
               (ULONG)LocalTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;
    
    //
    // Save it to the registry.
    //

    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_EXIT_TIME_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save the final statistics.
    //

    ErrorCode = PfSvSaveTraceProcessingStatistics(ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvSaveTraceProcessingStatistics (
    HKEY ServiceDataKey
    )

/*++

Routine Description:

    This routine saves global trace processing statistics to the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;

    //
    // Save the various global statistics.
    //

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_TRACES_PROCESSED_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.NumTracesProcessed,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_TRACES_SUCCESSFUL_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.NumTracesSuccessful,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_LAST_TRACE_FAILURE_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.LastTraceFailure,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvGetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    )

/*++

Routine Description:

    This routine queries the last time disk layout was updated from
    the registry under the service data key.

Arguments:

    LastDiskLayoutTime - Pointer to output data.

Return Value:

    Win32 error code.

--*/

{
    ULONG Size;
    DWORD ErrorCode;
    DWORD RegValueType;
    FILETIME CurrentFileTime;
    SYSTEMTIME SystemTime;
                                
    //
    // Query last disk layout time from the registry and adjust it if
    // necessary.
    //

    Size = sizeof(FILETIME);

    ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME,
                                NULL,
                                &RegValueType,
                                (PVOID) LastDiskLayoutTime,
                                &Size);

    if (ErrorCode != ERROR_SUCCESS) {

       if (ErrorCode ==  ERROR_FILE_NOT_FOUND) {
           
           //
           // No successful runs of the defragger to update layout has
           // been recorded in the registry. 
           //

           RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));

       } else {
       
           //
           // This is a real error.
           //
           
           goto cleanup;
       }

    } else {
       
       //
       // The query was successful, but if the value type is not
       // REG_BINARY, we most likely read in trash.
       //

       if (RegValueType != REG_BINARY || (Size != sizeof(FILETIME))) {
           
           RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));

       } else {

           //
           // If the time we recorded looks greater than the current
           // time (e.g. because the user played with the system time
           // and such), adjust it.
           //

           GetSystemTime(&SystemTime);

           if (!SystemTimeToFileTime(&SystemTime, &CurrentFileTime)) {
               ErrorCode = GetLastError();
               goto cleanup;
           }

           if (CompareFileTime(LastDiskLayoutTime, &CurrentFileTime) > 0) {
       
               //
               // The time in the registry looks bogus. We'll set it
               // to 0, to drive our caller to run the defragger to
               // update the layout again.
               //

               RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));
           }
       }
    }

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    return ErrorCode;
}

DWORD
PfSvSetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    )

/*++

Routine Description:

    This routine saves the last time the disk layout was updated to
    the registry under the service data key.

Arguments:

    LastDiskLayoutTime - Pointer to new disk layout time.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;
    FILETIME LocalFileTime;
    SYSTEMTIME LocalSystemTime;

    //
    // Initialize locals.
    //
   
    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save the specified time.
    //

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME,
                              0,
                              REG_BINARY,
                              (PVOID) LastDiskLayoutTime,
                              sizeof(FILETIME));
   

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Also save it in human readable format.
    //

    if (!FileTimeToLocalFileTime(LastDiskLayoutTime, &LocalFileTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!FileTimeToSystemTime(&LocalFileTime, &LocalSystemTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalSystemTime.wYear,
               (ULONG)LocalSystemTime.wMonth,
               (ULONG)LocalSystemTime.wDay,
               (ULONG)LocalSystemTime.wHour,
               (ULONG)LocalSystemTime.wMinute,
               (ULONG)LocalSystemTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;

    //
    // Save it to the registry.
    //
    
    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_LAST_DISK_LAYOUT_TIME_STRING_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvGetDontRunDefragger(
    DWORD *DontRunDefragger
    )

/*++

Routine Description:

    This routine queries the registry setting that disables launching
    the defragger when the system is idle.

Arguments:

    DontRunDefragger - Pointer to output data.

Return Value:

    Win32 error code.

--*/

{
    HKEY ParametersKey;  
    ULONG Size;
    DWORD Value;
    DWORD ErrorCode;
    DWORD RegValueType;
    BOOLEAN OpenedParametersKey;

    //
    // Initialize locals.
    //

    OpenedParametersKey = FALSE;

    //
    // Open the parameters key, creating it if necessary.
    //
    
    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH,
                             &ParametersKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    OpenedParametersKey = TRUE;

    //
    // Query whether auto layout is enabled.
    //

    Size = sizeof(Value);

    ErrorCode = RegQueryValueEx(ParametersKey,
                               PFSVC_OPTIMAL_LAYOUT_ENABLE_VALUE_NAME,
                               NULL,
                               &RegValueType,
                               (PVOID) &Value,
                               &Size);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // The query was successful. Make sure value is a DWORD.
    //

    if (RegValueType != REG_DWORD) {          
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Set the value.
    //

    *DontRunDefragger = !(Value);

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (OpenedParametersKey) {
        CloseHandle(ParametersKey);
    }

    return ErrorCode;
}

BOOLEAN
PfSvAllowedToRunDefragger(
    BOOLEAN CheckRegistry
    )
    
/*++

Routine Description:

    This routine checks the global state/parameters to see if we
    are allowed to try to run the defragger.

Arguments:

    CheckRegistry - Whether to ignore auto-layout enable key in the registry.

Return Value:

    TRUE - Go ahead and run the defragger.
    FALSE - Don't run the defragger.

--*/

{
    PF_SCENARIO_TYPE ScenarioType;
    BOOLEAN AllowedToRunDefragger;
    BOOLEAN PrefetchingEnabled;
    
    //
    // Initialize locals.
    //

    AllowedToRunDefragger = FALSE;

    //
    // On checked builds allow auto-layout on other sku's too.
    //

#ifndef PFSVC_DBG

    //
    // Is this a server machine?
    //

    if (PfSvcGlobals.OsVersion.wProductType != VER_NT_WORKSTATION) {
        goto cleanup;
    }

#endif

    //
    // Is prefetching enabled for any scenario type?
    //

    PrefetchingEnabled = FALSE;
    
    for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
        if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvEnabled) {
            PrefetchingEnabled = TRUE;
            break;
        }
    }    

    if (!PrefetchingEnabled) {
        goto cleanup;
    }

    //
    // Did we try to run the defragger and it crashed before?
    //

    if (PfSvcGlobals.DefraggerErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If in the registry we were not allowed to run the defragger, don't 
    // do so.
    //

    if (CheckRegistry) {
        if (PfSvcGlobals.DontRunDefragger) {
            goto cleanup;
        }
    }

    //
    // If we passed all checks, we are allowed to run the defragger.
    //

    AllowedToRunDefragger = TRUE;
    
cleanup:

    return AllowedToRunDefragger;
}

//
// Routines that deal with security.
//

BOOL 
PfSvSetPrivilege(
    HANDLE hToken,
    LPCTSTR lpszPrivilege,
    ULONG ulPrivilege,
    BOOL bEnablePrivilege
    ) 

/*++

Routine Description:

    Enables or disables a privilege in an access token.

Arguments:

    hToken - Access token handle.

    lpszPrivilege - Name of privilege to enable/disable.

    ulPrivilege - If a name is not specified, then a ULONG privilege 
      should be specified.

    bEnablePrivilege - Whether to enable or disable privilege

Return Value:

    TRUE - Success.
    FALSE - Failure.

--*/

{
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (lpszPrivilege) {
        if ( !LookupPrivilegeValue(NULL,
                                   lpszPrivilege,
                                   &luid)) {
            return FALSE; 
        }
    } else {
        luid = RtlConvertUlongToLuid(ulPrivilege);
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    //
    // Enable the privilege or disable all privileges.
    //

    AdjustTokenPrivileges(
        hToken, 
        FALSE, 
        &tp, 
        0, 
        (PTOKEN_PRIVILEGES) NULL, 
        (PDWORD) NULL); 
 
    //
    // Call GetLastError to determine whether the function succeeded.
    //

    if (GetLastError() != ERROR_SUCCESS) { 
        return FALSE; 
    } 

    return TRUE;
}

DWORD
PfSvSetAdminOnlyPermissions(
    WCHAR *ObjectPath,
    HANDLE ObjectHandle,
    SE_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine makes the built-in administrators group the owner and
    only allowed in the DACL of the specified directory or event
    object.

    The calling thread must have the SE_TAKE_OWNERSHIP_NAME privilege.

Arguments:

    ObjectPath - File/directory path or event name.
    
    ObjectHandle - If this is a SE_KERNEL_OBJECT, handle to it,
      otherwise NULL.

    ObjectType - Security object type. Only SE_KERNEL_OBJECT and
      SE_FILE_OBJECT are supported.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    SID_IDENTIFIER_AUTHORITY SIDAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsSID;
    PSECURITY_DESCRIPTOR SecurityDescriptor; 
    PACL DiscretionaryACL; 
    DWORD ACLRevision;
    ULONG ACESize;
    ULONG ACLSize;
    PACCESS_ALLOWED_ACE AccessAllowedAce;
    BOOL Result;

    //
    // Initialize locals.
    //

    AdministratorsSID = NULL;
    SecurityDescriptor = NULL;
    DiscretionaryACL = NULL;
    ACLRevision = ACL_REVISION;

    //
    // Check parameters.
    //
    
    if (ObjectType == SE_KERNEL_OBJECT) {
        if (ObjectHandle == NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    } else if (ObjectType == SE_FILE_OBJECT) {
        if (ObjectHandle != NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    } else {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Create a SID for the BUILTIN\Administrators group.
    //

    if(!AllocateAndInitializeSid(&SIDAuthority, 
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &AdministratorsSID)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Make Administrators the owner.
    //

    ErrorCode = SetNamedSecurityInfo (ObjectPath,
                                      ObjectType,
                                      OWNER_SECURITY_INFORMATION,
                                      AdministratorsSID,
                                      NULL, 
                                      NULL, 
                                      NULL); 
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Setup a discretionary access control list:
    //

    //
    // Determine size of an ACCESS_ALLOWED access control entry for
    // the administrators group. (Subtract size of SidStart which is
    // both part of ACE and SID.
    //

    ACESize = sizeof(ACCESS_ALLOWED_ACE);
    ACESize -= sizeof (AccessAllowedAce->SidStart);
    ACESize += GetLengthSid(AdministratorsSID);

    //
    // Determine size of the access control list.
    //

    ACLSize = sizeof(ACL);
    ACLSize += ACESize;

    //
    // Allocate and initialize the access control list.
    //

    DiscretionaryACL = PFSVC_ALLOC(ACLSize);

    if (!DiscretionaryACL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (!InitializeAcl(DiscretionaryACL, ACLSize, ACLRevision)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Add an ACE to allow access for the Administrators group.
    //

    if (!AddAccessAllowedAce(DiscretionaryACL,
                             ACLRevision,
                             GENERIC_ALL,
                             AdministratorsSID)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize a security descriptor.
    //

    SecurityDescriptor = PFSVC_ALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);
    
    if (!SecurityDescriptor) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    if (!InitializeSecurityDescriptor(SecurityDescriptor, 
                                      SECURITY_DESCRIPTOR_REVISION)) {
        ErrorCode = GetLastError();
        goto cleanup; 
    } 
    
    //
    // Set the discretionary access control list on the security descriptor.
    //
    
    if (!SetSecurityDescriptorDacl(SecurityDescriptor, 
                                   TRUE,
                                   DiscretionaryACL, 
                                   FALSE)) {
        ErrorCode = GetLastError();
        goto cleanup; 
    } 
    
    //
    // Set the built security descriptor on the prefetch directory.
    //
    
    if (ObjectType == SE_FILE_OBJECT) {
        Result = SetFileSecurity(ObjectPath, 
                                 DACL_SECURITY_INFORMATION, 
                                 SecurityDescriptor);
 
    } else {

        PFSVC_ASSERT(ObjectType == SE_KERNEL_OBJECT);
        PFSVC_ASSERT(ObjectHandle);

        Result = SetKernelObjectSecurity(ObjectHandle, 
                                         DACL_SECURITY_INFORMATION, 
                                         SecurityDescriptor);

    }

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (AdministratorsSID) {
        FreeSid(AdministratorsSID);
    }
    
    if (SecurityDescriptor) {
        PFSVC_FREE(SecurityDescriptor);
    }
    
    if (DiscretionaryACL) {
        PFSVC_FREE(DiscretionaryACL);
    }
    
    return ErrorCode;
}

DWORD
PfSvGetPrefetchServiceThreadPrivileges (
    VOID
    )

/*++

Routine Description:

    This routine ensures there is a security token for the current
    thread and sets the right privileges on it so the thread can
    communicate with the kernel mode prefetcher. It should be called
    right after a thread is created.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    BOOLEAN ImpersonatedSelf;
    BOOLEAN OpenedThreadToken;
    HANDLE ThreadToken;

    //
    // Initialize locals.
    //

    ImpersonatedSelf = FALSE;
    OpenedThreadToken = FALSE;

    DBGPR((PFID,PFTRC,"PFSVC: GetThreadPriviliges()\n"));
      
    //
    // Obtain a security context for this thread so we can set
    // privileges etc. without effecting the whole process.
    //

    if (!ImpersonateSelf(SecurityImpersonation)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedImpersonateSelf\n"));
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ImpersonatedSelf = TRUE;

    //
    // Set the privileges we will need talk to the kernel mode
    // prefetcher:
    //
    
    //
    // Open thread's access token.
    //
    
    if (!OpenThreadToken(GetCurrentThread(), 
                         TOKEN_ADJUST_PRIVILEGES,
                         FALSE,
                         &ThreadToken)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedOpenToken\n"));
        ErrorCode = GetLastError();
        goto cleanup;
    } 
    
    OpenedThreadToken = TRUE;

    //
    // Enable the SE_PROF_SINGLE_PROCESS_PRIVILEGE privilege so the
    // kernel mode prefetcher accepts our queries & set requests.
    // 
    //
 
    if (!PfSvSetPrivilege(ThreadToken, 0, SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedEnableProf\n"));
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    //
    // Enable the SE_TAKE_OWNERSHIP_NAME privilege so we can get
    // ownership of the prefetch directory.
    //
 
    if (!PfSvSetPrivilege(ThreadToken, SE_TAKE_OWNERSHIP_NAME, 0, TRUE)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedEnableOwn\n"));
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedThreadToken) {
        CloseHandle(ThreadToken);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (ImpersonatedSelf) {
            RevertToSelf();
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetThreadPriviliges()=%x\n",ErrorCode));

    return ErrorCode;
}

//
// Routines that deal with volume node structures.
//

DWORD
PfSvCreateVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *VolumePath,
    ULONG VolumePathLength,
    PLARGE_INTEGER CreationTime,
    ULONG SerialNumber
    )

/*++

Routine Description:

    This routine creates a volume node with the specifed info if it
    does not already exist. If a node already exists, it verifies
    CreationTime and SerialNumber.

Arguments:

    ScenarioInfo - Pointer to new scenario information.
    
    VolumePath - UPCASE NT full path of the volume, NUL terminated.
    
    VolumePathLength - Number of characters in VolumePath excluding NUL.

    CreationTime & SerialNumber - For the volume.

Return Value:

    ERROR_REVISION_MISMATCH - There already exists a volume node with
      that path but with a different signature/creation time.

    Win32 error code.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY FoundPosition;
    PPFSVC_VOLUME_NODE VolumeNode;
    DWORD ErrorCode;
    LONG ComparisonResult;
    PPFSVC_VOLUME_NODE NewVolumeNode;
    PWCHAR NewVolumePath;

    //
    // Initialize locals.
    //

    NewVolumeNode = NULL;
    NewVolumePath = NULL;

    DBGPR((PFID,PFSTRC,"PFSVC: CreateVolumeNode(%ws)\n", VolumePath));

    //
    // Walk through the existing volume nodes list and try to find
    // matching one.
    //
    
    HeadEntry = &ScenarioInfo->VolumeList;
    NextEntry = HeadEntry->Flink;
    FoundPosition = NULL;

    while (NextEntry != HeadEntry) {
        
        VolumeNode = CONTAINING_RECORD(NextEntry,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextEntry = NextEntry->Flink;
        
        ComparisonResult = wcsncmp(VolumePath, 
                                   VolumeNode->VolumePath, 
                                   VolumePathLength);
        
        if (ComparisonResult == 0) {

            //
            // Make sure VolumePathLengths are equal.
            //
            
            if (VolumeNode->VolumePathLength != VolumePathLength) {
                
                //
                // Continue searching.
                //
                
                continue;
            }
            
            //
            // We found our volume. Verify magics.
            //
            
            if (VolumeNode->SerialNumber != SerialNumber ||
                VolumeNode->CreationTime.QuadPart != CreationTime->QuadPart) {

                ErrorCode = ERROR_REVISION_MISMATCH;
                goto cleanup;

            } else {

                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }

        } else if (ComparisonResult < 0) {
            
            //
            // The volume paths are sorted lexically. The file path
            // would be less than other volumes too. The new node
            // would go right before this node.
            //

            FoundPosition = &VolumeNode->VolumeLink;

            break;
        }

        //
        // Continue looking...
        //

    }

    //
    // If we could not find an entry to put the new entry before, it
    // goes before the list head.
    //
    
    if (!FoundPosition) {
        FoundPosition = HeadEntry;
    }

    //
    // If we break out of the while loop, we could not find a
    // volume. We should create a new node.
    //

    NewVolumeNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->VolumeNodeAllocator);
    
    if (!NewVolumeNode) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    NewVolumePath = PfSvStringAllocatorAllocate(&ScenarioInfo->PathAllocator,
                                                (VolumePathLength + 1) * sizeof(WCHAR));

    if (!NewVolumePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    //
    // Copy file's volume path.
    //

    wcsncpy(NewVolumePath, VolumePath, VolumePathLength);
    NewVolumePath[VolumePathLength] = 0;
    
    //
    // Initialize volume node.
    //

    NewVolumeNode->VolumePath = NewVolumePath;
    NewVolumeNode->VolumePathLength = VolumePathLength;
    NewVolumeNode->SerialNumber = SerialNumber;
    NewVolumeNode->CreationTime = (*CreationTime);
    InitializeListHead(&NewVolumeNode->SectionList);
    PfSvInitializePathList(&NewVolumeNode->DirectoryList, &ScenarioInfo->PathAllocator, TRUE);
    NewVolumeNode->NumSections = 0;
    NewVolumeNode->NumAllSections = 0;
    NewVolumeNode->MFTSectionNode = NULL;

    //
    // Add it to the scenario's volume list before the found position.
    //

    InsertTailList(FoundPosition, &NewVolumeNode->VolumeLink);

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        
        if (NewVolumePath) {
            PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, NewVolumePath);
        }
        
        if (NewVolumeNode) {
            PfSvChunkAllocatorFree(&ScenarioInfo->VolumeNodeAllocator, NewVolumeNode);
        }               
    }

    DBGPR((PFID,PFSTRC,"PFSVC: CreateVolumeNode()=%x\n", ErrorCode));

    return ErrorCode;
}

PPFSVC_VOLUME_NODE
PfSvGetVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This routine looks for a volume node for the specified file path.

Arguments:

    ScenarioInfo - Pointer to new scenario information.
    
    FilePath - NT full path of the file, NUL terminated.
    
    FilePathLength - Number of characters in FilePath excluding NUL.

Return Value:

    Pointer to found VolumeNode, or NULL.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_VOLUME_NODE VolumeNode;
    DWORD ErrorCode;
    PFSV_PREFIX_COMPARISON_RESULT ComparisonResult;

    DBGPR((PFID,PFSTRC,"PFSVC: GetVolumeNode(%ws)\n", FilePath));

    //
    // Walk through the existing volume nodes list and try to find
    // matching one.
    //
    
    HeadEntry = &ScenarioInfo->VolumeList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        VolumeNode = CONTAINING_RECORD(NextEntry,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextEntry = NextEntry->Flink;
        
        ComparisonResult = PfSvComparePrefix(FilePath, 
                                             FilePathLength,
                                             VolumeNode->VolumePath, 
                                             VolumeNode->VolumePathLength,
                                             TRUE);
        
        if (ComparisonResult == PfSvPrefixIdentical) {

            //
            // Make sure that there is a slash in the file
            // path after the volume path.
            //
            
            if (FilePath[VolumeNode->VolumePathLength] != L'\\') {
                
                //
                // Continue searching.
                //
                
                continue;
            }
            
            //
            // We found our volume.
            //
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

        } else if (ComparisonResult == PfSvPrefixGreaterThan) {
            
            //
            // The volume paths are sorted lexically. The volume path
            // would be less than other volumes too.
            //

            break;
        }

        //
        // Continue looking...
        //

    }

    //
    // If we break out of the while loop, we could not find a
    // volume. 
    //

    VolumeNode = NULL;
    ErrorCode = ERROR_NOT_FOUND;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        VolumeNode = NULL;
    }

    DBGPR((PFID,PFSTRC,"PFSVC: GetVolumeNode()=%p\n", VolumeNode));

    return VolumeNode;
}

VOID
PfSvCleanupVolumeNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_VOLUME_NODE VolumeNode
    )

/*++

Routine Description:

    This function cleans up a volume node structure. It does not free
    the structure itself.

Arguments:

    ScenarioInfo - Pointer to scenario info context this volume node 
      belongs to.

    VolumeNode - Pointer to structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY SectListEntry;
    PPFSVC_SECTION_NODE SectionNode;

    //
    // Cleanup directory list.
    //

    PfSvCleanupPathList(&VolumeNode->DirectoryList);

    //
    // If there is a volume path, free it.
    //
    
    if (VolumeNode->VolumePath) {
        PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, VolumeNode->VolumePath);
        VolumeNode->VolumePath = NULL;
    }
    
    //
    // Remove the section nodes from our list and re-initialize their
    // links so they know they have been removed.
    //

    while (!IsListEmpty(&VolumeNode->SectionList)) {
        
        SectListEntry = RemoveHeadList(&VolumeNode->SectionList);
        
        SectionNode = CONTAINING_RECORD(SectListEntry, 
                                        PFSVC_SECTION_NODE, 
                                        SectionVolumeLink);

        InitializeListHead(&SectionNode->SectionVolumeLink);
    }

    return;
}

DWORD
PfSvAddParentDirectoriesToList(
    PPFSVC_PATH_LIST DirectoryList,
    ULONG VolumePathLength,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This function will parse a fully qualified NT file path and add
    all parent directories to the specified directory list. The part
    of the path that is the volume path is skipped.

Arguments:

    DirectoryList - Pointer to list to update.

    VolumePathLength - Position in the file path at which the volume
      path ends and the root directory starts.

    FilePath - Pointer to NT file path, NUL terminated.
      
    FullPathLength - Length of FilePath in characters excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR DirectoryPath[MAX_PATH];
    ULONG DirectoryPathLength;
    WCHAR *CurrentChar;
    WCHAR *FilePathEnd;

    //
    // Initialize locals.
    //
    
    FilePathEnd = FilePath + FilePathLength;
    PFSVC_ASSERT(*FilePathEnd == 0);

    //
    // Skip the volume path and start from the root directory.
    //

    CurrentChar = FilePath + VolumePathLength;

    while (CurrentChar < FilePathEnd) {

        if (*CurrentChar == L'\\') {

            //
            // We got a directory.
            //

            DirectoryPathLength = (ULONG) (CurrentChar - FilePath + 1);

            if (DirectoryPathLength >= MAX_PATH) {
                ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                goto cleanup;
            }

            //
            // Copy directory path to buffer and NUL terminate it.
            //

            wcsncpy(DirectoryPath, FilePath, DirectoryPathLength);
            DirectoryPath[DirectoryPathLength] = 0;
            PFSVC_ASSERT(DirectoryPath[DirectoryPathLength - 1] == L'\\');
            
            //
            // Add it to the list.
            //
            
            ErrorCode = PfSvAddToPathList(DirectoryList,
                                       DirectoryPath,
                                       DirectoryPathLength);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
         
            //
            // Continue looking for more directories in the path.
            //
        }

        CurrentChar++;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

//
// Routines used to allocate / free section & page nodes etc. efficiently.
//

// FUTURE-2002/03/29-ScottMa -- The "optional" Buffer parameter is always
//   supplied in both the chunk and string allocators.  You could remove the
//   code that handles a NULL Buffer throughout these functions.

VOID
PfSvChunkAllocatorInitialize (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Initializes the allocator structure. Must be called before other allocator
    routines.

Arguments:

    Allocator - Pointer to structure.
    
Return Value:

    None.

--*/

{
    //
    // Zero the structure. This effectively initializes the following fields:
    //   Buffer
    //   BufferEnd
    //   FreePointer
    //   ChunkSize
    //   MaxHeapAllocs
    //   NumHeapAllocs
    //   UserSpecifiedBuffer
    //

    RtlZeroMemory(Allocator, sizeof(PFSVC_CHUNK_ALLOCATOR));

    return;
}

DWORD
PfSvChunkAllocatorStart (
    IN PPFSVC_CHUNK_ALLOCATOR Allocator,
    OPTIONAL IN PVOID Buffer,
    IN ULONG ChunkSize,
    IN ULONG MaxChunks
    )

/*++

Routine Description:

    Must be called before calling alloc/free on an allocator that has
    been initialized.

Arguments:

    Allocator - Pointer to initialized structure.

    Buffer - If specified, it is the buffer that will be divided up into
      MaxChunks of ChunkSize and given away. Otherwise a buffer will be
      allocated. If specified, the user has to free the buffer after the
      chunk allocator has been cleaned up. It should be aligned right.

    ChunkSize - In bytes how big each allocated chunk will be. 
                e.g. sizeof(PFSVC_PAGE_NODE) It should be greater than
                sizeof(DWORD).

    MaxChunks - Max number of allocs that will be made from the allocator.
    
Return Value:

    Win32 error code.

--*/

{
    ULONG AllocationSize;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    AllocationSize = ChunkSize * MaxChunks;

    //
    // We should be initialized and we should not get started twice.
    //

    PFSVC_ASSERT(Allocator->Buffer == NULL);

    //
    // Chunk size should not be too small.
    //

    if (ChunkSize < sizeof(DWORD) || !MaxChunks) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Did the user specify the buffer to use?
    //

    if (Buffer) {

        Allocator->Buffer = Buffer;
        Allocator->UserSpecifiedBuffer = TRUE;

    } else {

        Allocator->Buffer = PFSVC_ALLOC(AllocationSize);

        if (!Allocator->Buffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        Allocator->UserSpecifiedBuffer = FALSE;
    }

    Allocator->BufferEnd = (PCHAR) Buffer + (ULONG_PTR) AllocationSize;
    Allocator->FreePointer = Buffer;
    Allocator->ChunkSize = ChunkSize;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

PVOID
PfSvChunkAllocatorAllocate (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Returns a ChunkSize chunk allocated from Allocator. ChunkSize was specified 
    when Allocator was started. If a chunk is return the caller should free it
    to this Allocator before uninitializing the Allocator.

Arguments:

    Allocator - Pointer to started allocator.
    
Return Value:

    NULL or chunk allocated from Allocator.

--*/

{
    PVOID ReturnChunk;

    //
    // We should not be trying to make allocations before we start the 
    // allocator.
    //

    PFSVC_ASSERT(Allocator->Buffer && Allocator->ChunkSize);

    //
    // If we can allocate from our preallocated buffer do so. Otherwise we 
    // have to hit the heap.
    //

    if (Allocator->FreePointer >= Allocator->BufferEnd) {

        Allocator->MaxHeapAllocs++;

        ReturnChunk = PFSVC_ALLOC(Allocator->ChunkSize);

        if (ReturnChunk) {
            Allocator->NumHeapAllocs++;
        }

    } else {

        ReturnChunk = Allocator->FreePointer;

        Allocator->FreePointer += (ULONG_PTR) Allocator->ChunkSize;
    }

    return ReturnChunk;
}

VOID
PfSvChunkAllocatorFree (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Allocation
    )

/*++

Routine Description:

    Frees a chunk allocated from the allocator. This may not make it available
    for use by further allocations from the allocator.

Arguments:

    Allocator - Pointer to started allocator.

    Allocation - Allocation to free.
    
Return Value:

    None.

--*/

{

    //
    // Is this within the preallocated block?
    //

    if ((PUCHAR) Allocation >= Allocator->Buffer &&
        (PUCHAR) Allocation < Allocator->BufferEnd) {

        //
        // Mark this chunk freed.
        //

        *(PULONG)Allocation = PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC;

    } else {

        //
        // This chunk was allocated from heap.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs && Allocator->MaxHeapAllocs);

        Allocator->NumHeapAllocs--;

        PFSVC_FREE(Allocation);
    }

    return;
}

VOID
PfSvChunkAllocatorCleanup (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Cleans up resources associated with the allocator. There should not be 
    any outstanding allocations from the allocator when this function is 
    called.

Arguments:

    Allocator - Pointer to initialized allocator.
    
Return Value:

    None.

--*/

{
    PCHAR CurrentChunk;
    ULONG Magic;

    if (Allocator->Buffer) {

        #ifdef PFSVC_DBG

        //
        // Make sure all real heap allocations have been freed.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs == 0);

        //
        // Make sure all allocated chunks have been freed. Check
        // ChunkSize first, if it's corrupted we'd loop forever.
        //

        PFSVC_ASSERT(Allocator->ChunkSize);

        for (CurrentChunk = Allocator->Buffer; 
             CurrentChunk < Allocator->FreePointer;
             CurrentChunk += (ULONG_PTR) Allocator->ChunkSize) {

            Magic = *(PULONG)CurrentChunk;

            PFSVC_ASSERT(Magic == PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC);
        }

        #endif // PFSVC_DBG

        //
        // If the buffer was allocated by us (and not specified by
        // the user), free it.
        //

        if (!Allocator->UserSpecifiedBuffer) {
            PFSVC_FREE(Allocator->Buffer);
        }

        #ifdef PFSVC_DBG

        //
        // Setup the fields so if we try to make allocations after cleaning up
        // an allocator we'll hit an assert.
        //

        Allocator->FreePointer = Allocator->Buffer;
        Allocator->Buffer = NULL;

        #endif // PFSVC_DBG

    }

    return;
}

//
// Routines used to allocate / free path strings efficiently.
//

VOID
PfSvStringAllocatorInitialize (
    PPFSVC_STRING_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Initializes the allocator structure. Must be called before other allocator
    routines.

Arguments:

    Allocator - Pointer to structure.
    
Return Value:

    None.

--*/

{
    //
    // Zero the structure. This effectively initializes the following fields:
    //   Buffer
    //   BufferEnd
    //   FreePointer
    //   MaxHeapAllocs
    //   NumHeapAllocs
    //   LastAllocationSize
    //   UserSpecifiedBuffer
    //

    RtlZeroMemory(Allocator, sizeof(PFSVC_STRING_ALLOCATOR));

    return;
}

DWORD
PfSvStringAllocatorStart (
    IN PPFSVC_STRING_ALLOCATOR Allocator,
    OPTIONAL IN PVOID Buffer,
    IN ULONG MaxSize
    )

/*++

Routine Description:

    Must be called before calling alloc/free on an allocator that has
    been initialized.

Arguments:

    Allocator - Pointer to initialized structure.

    Buffer - If specified, it is the buffer that we will allocate strings
      from. Otherwise a buffer will be allocated. If specified, the user 
      has to free the buffer after the string allocator has been cleaned up. 
      It should be aligned right.

    MaxSize - Max valid size of buffer in bytes.
    
Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // We should be initialized and we should not get started twice.
    //

    PFSVC_ASSERT(Allocator->Buffer == NULL);

    //
    // Did the user specify the buffer to use?
    //

    if (Buffer) {

        Allocator->Buffer = Buffer;
        Allocator->UserSpecifiedBuffer = TRUE;

    } else {

        Allocator->Buffer = PFSVC_ALLOC(MaxSize);

        if (!Allocator->Buffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        Allocator->UserSpecifiedBuffer = FALSE;
    }

    Allocator->BufferEnd = (PCHAR) Buffer + (ULONG_PTR) MaxSize;
    Allocator->FreePointer = Buffer;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

PVOID
PfSvStringAllocatorAllocate (
    PPFSVC_STRING_ALLOCATOR Allocator,
    ULONG NumBytes
    )

/*++

Routine Description:

    Returns a NumBytes size buffer allocated from Allocator. 
    This buffer should be freed back to the Allocator before the it is
    uninitialized.

Arguments:

    Allocator - Pointer to started allocator.

    NumBytes - Number of bytes to allocate.
    
Return Value:

    NULL or buffer allocated from Allocator.

--*/

{
    PVOID ReturnChunk;
    PPFSVC_STRING_ALLOCATION_HEADER AllocationHeader;
    ULONG_PTR RealAllocationSize;

    //
    // We should not be trying to make allocations before we start the 
    // allocator.
    //

    PFSVC_ASSERT(Allocator->Buffer);

    //
    // Calculate how much we have to reserve from the buffer to make this
    // allocation. 
    //

    RealAllocationSize = 0;
    RealAllocationSize += sizeof(PFSVC_STRING_ALLOCATION_HEADER);
    RealAllocationSize += NumBytes;
    RealAllocationSize = (ULONG_PTR) PF_ALIGN_UP(RealAllocationSize, _alignof(PFSVC_STRING_ALLOCATION_HEADER));
    
    //
    // We can't allocate from our buffer and have to go to the heap if
    // - We've run out of space.
    // - Allocation size is too big to fit in a USHORT.
    // - It is a 0 sized allocation.
    //

    if (Allocator->FreePointer + RealAllocationSize > Allocator->BufferEnd ||
        NumBytes > PFSVC_STRING_ALLOCATOR_MAX_BUFFER_ALLOCATION_SIZE ||
        NumBytes == 0) {

        //
        // Hit the heap.
        //

        Allocator->MaxHeapAllocs++;

        ReturnChunk = PFSVC_ALLOC(NumBytes);

        if (ReturnChunk) {
            Allocator->NumHeapAllocs++;
        }

    } else {

        AllocationHeader = (PVOID) Allocator->FreePointer;
        AllocationHeader->PrecedingAllocationSize = Allocator->LastAllocationSize;

        PFSVC_ASSERT(RealAllocationSize < USHRT_MAX);
        AllocationHeader->AllocationSize = (USHORT) RealAllocationSize;

        Allocator->FreePointer += RealAllocationSize;
        Allocator->LastAllocationSize = (USHORT) RealAllocationSize;

        //
        // The user's allocation comes right after the allocation header. 
        // (Using pointer arithmetic...)
        //

        ReturnChunk = AllocationHeader + 1;
    }

    return ReturnChunk;
}

VOID
PfSvStringAllocatorFree (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Allocation
    )

/*++

Routine Description:

    Frees a string allocated from the allocator. This may not make it available
    for use by further allocations from the allocator.

Arguments:

    Allocator - Pointer to started allocator.

    Allocation - Allocation to free.
    
Return Value:

    None.

--*/

{

    //
    // Is this within the preallocated block?
    //

    if ((PUCHAR) Allocation >= Allocator->Buffer &&
        (PUCHAR) Allocation < Allocator->BufferEnd) {

        //
        // Mark this chunk freed.
        //

        *((PWCHAR)Allocation) = PFSVC_STRING_ALLOCATOR_FREED_MAGIC;

    } else {

        //
        // This chunk was allocated from heap.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs && Allocator->MaxHeapAllocs);

        Allocator->NumHeapAllocs--;

        PFSVC_FREE(Allocation);
    }

    return;
}

VOID
PfSvStringAllocatorCleanup (
    PPFSVC_STRING_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Cleans up resources associated with the allocator. There should not be 
    any outstanding allocations from the allocator when this function is 
    called.

Arguments:

    Allocator - Pointer to initialized allocator.
    
Return Value:

    None.

--*/

{
    PPFSVC_STRING_ALLOCATION_HEADER AllocationHeader;
    PCHAR NextAllocationHeader;
    WCHAR Magic;

    if (Allocator->Buffer) {

        #ifdef PFSVC_DBG

        //
        // Make sure all real heap allocations have been freed.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs == 0);

        //
        // Make sure all allocated strings have been freed.
        //

        for (AllocationHeader = (PVOID) Allocator->Buffer; 
             (PCHAR) AllocationHeader < (PCHAR) Allocator->FreePointer;
             AllocationHeader = (PVOID) NextAllocationHeader) {

            Magic = *((PWCHAR)(AllocationHeader + 1));

            PFSVC_ASSERT(Magic == PFSVC_STRING_ALLOCATOR_FREED_MAGIC);

            //
            // Calculate where the NextAllocationHeader will be.
            //
        
            NextAllocationHeader = (PCHAR) AllocationHeader + 
                                   (ULONG_PTR) AllocationHeader->AllocationSize;
        }

        #endif // PFSVC_DBG

        //
        // If the buffer was allocated by us (and not specified by
        // the user), free it.
        //

        if (!Allocator->UserSpecifiedBuffer) {
            PFSVC_FREE(Allocator->Buffer);
        }

        #ifdef PFSVC_DBG

        //
        // Setup the fields so if we try to make allocations after cleaning up
        // an allocator we'll hit an assert.
        //

        Allocator->FreePointer = Allocator->Buffer;
        Allocator->Buffer = NULL;

        #endif // PFSVC_DBG

    }

    return;
}

//
// Routines that deal with section node structures.
//

VOID
PfSvCleanupSectionNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_SECTION_NODE SectionNode
    )

/*++

Routine Description:

    This function cleans up a section node structure. It does not free
    the structure itself.

Arguments:

    ScenarioInfo - Pointer to scenario info.

    SectionNode - Pointer to structure.

Return Value:

    None.

--*/

{
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY ListHead;

    //
    // If there is an allocated file name, free it.
    //

    if (SectionNode->FilePath) {
        PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, SectionNode->FilePath);
        SectionNode->FilePath = NULL;
    }

    //
    // Free all the page nodes for this section.
    //
    
    while (!IsListEmpty(&SectionNode->PageList)) {
        
        ListHead = RemoveHeadList(&SectionNode->PageList);
        PageNode = CONTAINING_RECORD(ListHead, PFSVC_PAGE_NODE, PageLink);

        PfSvChunkAllocatorFree(&ScenarioInfo->PageNodeAllocator, PageNode);
    }

    //
    // We should not be on a volume node's list if we are being
    // cleaned up.
    //

    PFSVC_ASSERT(IsListEmpty(&SectionNode->SectionVolumeLink));
}

//
// Routines used to sort scenario's section nodes.
//

DWORD
PfSvSortSectionNodesByFirstAccess(
    PLIST_ENTRY SectionNodeList
    )

/*++

Routine Description:

    This routine will sort the specified section node list by first
    access using NewSectionIndex and OrgSectionIndex of the section
    nodes.

Arguments:

    SectionNodeList - Pointer to list of section nodes to be sorted.

Return Value:

    Win32 error code.

--*/

{
    PFSV_SECTNODE_PRIORITY_QUEUE SortQueue;
    PLIST_ENTRY SectHead;
    PPFSVC_SECTION_NODE SectionNode;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PfSvInitializeSectNodePriorityQueue(&SortQueue);

    DBGPR((PFID,PFSTRC,"PFSVC: SortByFirstAccess(%p)\n", SectionNodeList));

    //
    // We have to sort the section nodes by first access. Remove
    // section nodes from the scenario list and put them on a priority
    // queue. [Bummer, it may have been a little faster if we had
    // built a binary tree and traversed that in the rest of the code]
    //
    
    while (!IsListEmpty(SectionNodeList)) {

        //
        // The section list is sorted by name. It is more likely that
        // we also accessed files by name. So to make the priority
        // queue act better in such cases, remove from the tail of the
        // list to insert into the priority queue.
        //

        SectHead = RemoveTailList(SectionNodeList);
        
        SectionNode = CONTAINING_RECORD(SectHead,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        
        PfSvInsertSectNodePriorityQueue(&SortQueue, SectionNode);
    }

    //
    // Remove the section nodes from the priority queue sorted by
    // first access and put them to the tail of the section node list.
    //

    while (SectionNode = PfSvRemoveMinSectNodePriorityQueue(&SortQueue)) {
        InsertTailList(SectionNodeList, &SectionNode->SectionLink);
    }

    ErrorCode = ERROR_SUCCESS;

    DBGPR((PFID,PFSTRC,"PFSVC: SortByFirstAccess(%p)=%x\n", SectionNodeList, ErrorCode));
    
    return ErrorCode;
}

PFSV_SECTION_NODE_COMPARISON_RESULT 
FASTCALL
PfSvSectionNodeComparisonRoutine(
    PPFSVC_SECTION_NODE Element1, 
    PPFSVC_SECTION_NODE Element2 
    )

/*++

Routine Description:

    This routine is called to compare to elements when sorting the
    section nodes array by first access.

Arguments:

    Element1, Element2 - The two elements to compare.

Return Value:

    PFSVC_SECTION_NODE_COMPARISON_RESULT

--*/

{
    //
    // First compare first-access index in the new trace.
    //
    
    if (Element1->NewSectionIndex < Element2->NewSectionIndex) {
        
        return PfSvSectNode1LessThanSectNode2;

    } else if (Element1->NewSectionIndex > Element2->NewSectionIndex) {

        return PfSvSectNode1GreaterThanSectNode2;

    } else {

        //
        // Next compare first-access index in the current scenario
        // file.
        //

        if (Element1->OrgSectionIndex < Element2->OrgSectionIndex) {
            
            return PfSvSectNode1LessThanSectNode2;
           
        } else if (Element1->OrgSectionIndex > Element2->OrgSectionIndex) {
            
            return PfSvSectNode1GreaterThanSectNode2;

        } else {
            
            return PfSvSectNode1EqualToSectNode2;

        }
    }
}

//
// Routines that implement a priority queue used to sort section nodes
// for a scenario.
//

VOID
PfSvInitializeSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    )

/*++

Routine Description:

    Initialize a section node priority queue.    

Arguments:

    PriorityQueue - Pointer to the queue.

Return Value:

    None.

--*/

{
    PriorityQueue->Head = NULL;
}

VOID
PfSvInsertSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue,
    PPFSVC_SECTION_NODE NewElement
    )

/*++

Routine Description:

    Insert a section node in the a section node priority queue.

Arguments:

    PriorityQueue - Pointer to the queue.

    NewElement - Pointer to new element.

Return Value:

    None.

--*/

{
    PPFSVC_SECTION_NODE *CurrentPosition;
    
    //
    // Initialize the link fields of NewElement.
    //

    NewElement->LeftChild = NULL;
    NewElement->RightChild = NULL;

    //
    // If the queue is empty, insert this at the head.
    //
    
    if (PriorityQueue->Head == NULL) {
        PriorityQueue->Head = NewElement;
        return;
    }
    
    //
    // If we are less than the current min element, put us at the
    // head.
    //

    if (PfSvSectionNodeComparisonRoutine(NewElement, PriorityQueue->Head) <= 0) {
        
        NewElement->RightChild = PriorityQueue->Head;
        PriorityQueue->Head = NewElement;
        return;
    }

    //
    // Insert this node into the tree rooted at the right child of the
    // head node.
    //

    CurrentPosition = &PriorityQueue->Head->RightChild;

    while (*CurrentPosition) {
        if (PfSvSectionNodeComparisonRoutine(NewElement, *CurrentPosition) <= 0) {
            CurrentPosition = &(*CurrentPosition)->LeftChild;
        } else {
            CurrentPosition = &(*CurrentPosition)->RightChild;    
        }
    }
    
    //
    // We found the place.
    //

    *CurrentPosition = NewElement;
}

PPFSVC_SECTION_NODE
PfSvRemoveMinSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    )

/*++

Routine Description:

    Remove the head element of the queue.

Arguments:

    PriorityQueue - Pointer to the queue.

Return Value:

    Pointer to head element of the queue. 
    NULL if queue is empty.

--*/

{
    PPFSVC_SECTION_NODE *CurrentPosition;
    PPFSVC_SECTION_NODE OrgHeadNode;
    PPFSVC_SECTION_NODE NewHeadNode;
    PPFSVC_SECTION_NODE TreeRoot;

    //
    // If the queue is empty return NULL.
    //

    if (PriorityQueue->Head == NULL) {
        return NULL;
    }

    //
    // Save pointer to original head node.
    //

    OrgHeadNode = PriorityQueue->Head;

    //
    // Find the minimum element of the tree rooted at the right child
    // of the head node. CurrentPosition points to the link of the
    // parent to the smaller child.
    //

    TreeRoot = OrgHeadNode->RightChild;

    CurrentPosition = &TreeRoot;

    while (*CurrentPosition && (*CurrentPosition)->LeftChild) {
        CurrentPosition = &(*CurrentPosition)->LeftChild;
    }

    NewHeadNode = *CurrentPosition;

    //
    // Check if there is really a new head node that we have to remove
    // from its current position.
    //
    
    if (NewHeadNode) {
  
        //
        // We are removing this node to put it at the head. In its
        // place, we'll put its right child. Since we know that this
        // node does not have a left child, that's all we have to do.
        //
        
        *CurrentPosition = NewHeadNode->RightChild;

        //
        // Set the tree rooted at the head's right child.
        //
        
        NewHeadNode->RightChild = TreeRoot;
    }

    //
    // Set the new head.
    //

    PriorityQueue->Head = NewHeadNode;

    //
    // Return the original head node.
    //

    return OrgHeadNode;
}

//
// Implementation of the Nt path to Dos path translation API.
//

DWORD
PfSvBuildNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST *NtPathTranslationList
    )

/*++

Routine Description:

    This routine is called to build a list that can be used to
    translate Nt paths to Dos paths. If successful, the returned list
    should be freed by calling PfSvFreeNtPathTranslationList.

Arguments:

    TranslationList - Pointer to where a pointer to the built
      translation list is going to be put.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG VolumeNameLength;
    ULONG VolumeNameMaxLength;
    PWCHAR VolumeName;
    ULONG NTDevicePathMaxLength;
    ULONG NTDevicePathLength;
    PWCHAR NTDevicePath;
    HANDLE FindVolumeHandle;
    ULONG RequiredLength;
    ULONG VolumePathNamesLength;
    WCHAR *VolumePathNames;
    ULONG MountPathNameLength;
    WCHAR *MountPathName;
    ULONG ShortestMountPathLength;
    WCHAR *ShortestMountPathName;
    ULONG NumMountPoints;
    ULONG NumResizes;
    BOOL Result;
    ULONG NumChars;
    ULONG Length;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PNTPATH_TRANSLATION_ENTRY TranslationEntry;
    PNTPATH_TRANSLATION_ENTRY NextTranslationEntry;
    ULONG AllocationSize;
    PUCHAR DestinationPointer;
    ULONG CopySize;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;  
    PLIST_ENTRY InsertPosition;
    BOOLEAN TrimmedTerminatingSlash;

    //
    // Initialize locals.
    //

    FindVolumeHandle = INVALID_HANDLE_VALUE;
    VolumePathNames = NULL;
    VolumePathNamesLength = 0;
    VolumeName = NULL;
    VolumeNameMaxLength = 0;
    NTDevicePath = NULL;
    NTDevicePathMaxLength = 0;   
    TranslationList = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: BuildTransList()\n"));

    //
    // Allocate intermediate buffers.
    //

    Length = MAX_PATH + 1;

    VolumeName = PFSVC_ALLOC(Length * sizeof(WCHAR));
    NTDevicePath = PFSVC_ALLOC(Length * sizeof(WCHAR));

    if (!VolumeName || !NTDevicePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    VolumeNameMaxLength = Length;  
    NTDevicePathMaxLength = Length;


    //
    // Allocate and initialize a translation list.
    //

    TranslationList = PFSVC_ALLOC(sizeof(NTPATH_TRANSLATION_LIST));
    
    if (!TranslationList) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    InitializeListHead(TranslationList);

    //
    // Start enumerating the volumes.
    //

    FindVolumeHandle = FindFirstVolume(VolumeName, VolumeNameMaxLength);
    
    if (FindVolumeHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    do {

        //
        // Update volume length after the FindFirst/NextVolume call.
        //

        VolumeNameLength = wcslen(VolumeName);

        //
        // Get list of where this volume is mounted.
        //

        NumResizes = 0;

        do {
            
            Result = GetVolumePathNamesForVolumeName(VolumeName, 
                                                     VolumePathNames, 
                                                     VolumePathNamesLength, 
                                                     &RequiredLength);
            
            if (Result) {
                
                //
                // We got the mount points.
                //
                
                break;
            }
            
            //
            // Check why we failed.
            //

            ErrorCode = GetLastError();
            
            if (ErrorCode != ERROR_MORE_DATA) {
                
                //
                // A real error...
                //
                
                goto cleanup;
            } 

            //
            // We need to increase the size of our buffer. If there is
            // an existing buffer, first free it.
            //

            if (VolumePathNames) {
                PFSVC_FREE(VolumePathNames);
                VolumePathNames = NULL;
                VolumePathNamesLength = 0;
            }
            
            //
            // Try to allocate a new buffer.
            //
            
            VolumePathNames = PFSVC_ALLOC(RequiredLength * sizeof(WCHAR));
            
            if (!VolumePathNames) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            VolumePathNamesLength = RequiredLength;

            //
            // Retry with the resized buffer but make sure we don't
            // loop forever!
            //

            NumResizes++;
            if (NumResizes > 1000) {
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

        } while (TRUE);

        //
        // Loop through the mount points to find the shortest one. It
        // is possible that the depth of it is more.
        //

        MountPathName = VolumePathNames;
        NumMountPoints = 0;

        ShortestMountPathName = NULL;
        ShortestMountPathLength = ULONG_MAX;

        while (*MountPathName) {

            MountPathNameLength = wcslen(MountPathName);

            if (MountPathNameLength < ShortestMountPathLength) {
                ShortestMountPathName = MountPathName;
                ShortestMountPathLength = MountPathNameLength;
            }

            NumMountPoints++;

            //
            // Update the pointer to next mount point path.
            //

            MountPathName += MountPathNameLength + 1;
        }

        //
        // Check if we got a mount point path.
        //

        if (ShortestMountPathName == NULL) {

            //
            // Skip this volume.
            //

            continue;
        }

        //
        // Remove the terminating slash if there is one.
        //
        
        if (ShortestMountPathName[ShortestMountPathLength - 1] == L'\\') {
            ShortestMountPathName[ShortestMountPathLength - 1] = 0;
            ShortestMountPathLength--;
        }

        //
        // Get NT device that is the target of the volume link in
        // Win32 object namespace. We get the dos device name by
        // trimming the first 4 characters [i.e. \\?\] of the
        // VolumeName. Also trim the \ at the very end of the volume
        // name.
        //

        if (VolumeNameLength <= 4) {
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        if (VolumeName[VolumeNameLength - 1] == L'\\') {
            VolumeName[VolumeNameLength - 1] = 0;
            TrimmedTerminatingSlash = TRUE;
        } else {
            TrimmedTerminatingSlash = FALSE;
        }

        NumChars = QueryDosDevice(&VolumeName[4], 
                                  NTDevicePath, 
                                  NTDevicePathMaxLength);
        
        if (TrimmedTerminatingSlash) {
            VolumeName[VolumeNameLength - 1] = L'\\';
        }

        if (NumChars == 0) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // We are interested only in the current mapping.
        //       

        NTDevicePath[NTDevicePathMaxLength - 1] = 0;
        NTDevicePathLength = wcslen(NTDevicePath);
        
        if (NTDevicePathLength == 0) {
            
            //
            // Skip this volume.
            //
            
            continue;
        }

        //
        // Remove terminating slash if there is one.
        //
        
        if (NTDevicePath[NTDevicePathLength - 1] == L'\\') {
            NTDevicePath[NTDevicePathLength - 1] = 0;
            NTDevicePathLength--;
        }
        
        //
        // Allocate a translation entry big enough to contain both
        // path names and the volume string.
        //

        AllocationSize = sizeof(NTPATH_TRANSLATION_ENTRY);
        AllocationSize += (ShortestMountPathLength + 1) * sizeof(WCHAR);
        AllocationSize += (NTDevicePathLength + 1) * sizeof(WCHAR);
        AllocationSize += (VolumeNameLength + 1) * sizeof(WCHAR);

        TranslationEntry = PFSVC_ALLOC(AllocationSize);
        
        if (!TranslationEntry) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        DestinationPointer = (PUCHAR) TranslationEntry;
        DestinationPointer += sizeof(NTPATH_TRANSLATION_ENTRY);

        //
        // Copy the NT path name and the terminating NUL.
        //

        TranslationEntry->NtPrefix = (PVOID) DestinationPointer;
        TranslationEntry->NtPrefixLength = NTDevicePathLength;

        CopySize = (NTDevicePathLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, NTDevicePath, CopySize);
        DestinationPointer += CopySize;

        //
        // Copy the DOS mount point name and the terminating NUL.
        //

        TranslationEntry->DosPrefix = (PVOID) DestinationPointer;
        TranslationEntry->DosPrefixLength = ShortestMountPathLength;

        CopySize = (ShortestMountPathLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, ShortestMountPathName, CopySize);
        DestinationPointer += CopySize;

        //
        // Copy the volume name and the terminating NUL.
        //

        TranslationEntry->VolumeName = (PVOID) DestinationPointer;
        TranslationEntry->VolumeNameLength = VolumeNameLength;

        CopySize = (VolumeNameLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, VolumeName, CopySize);
        DestinationPointer += CopySize;
        
        //
        // Find the position for this entry in the sorted translation
        // list.
        //

        HeadEntry = TranslationList;
        NextEntry = HeadEntry->Flink;
        InsertPosition = HeadEntry;

        while (NextEntry != HeadEntry) {
            
            NextTranslationEntry = CONTAINING_RECORD(NextEntry,
                                                     NTPATH_TRANSLATION_ENTRY,
                                                     Link);
            
            if (_wcsicmp(TranslationEntry->NtPrefix, 
                         NextTranslationEntry->NtPrefix) <= 0) {
                break;
            }
            
            InsertPosition = NextEntry;
            NextEntry = NextEntry->Flink;
        }

        //
        // Insert it after the found position.
        //

        InsertHeadList(InsertPosition, &TranslationEntry->Link);

    } while (FindNextVolume(FindVolumeHandle, VolumeName, VolumeNameMaxLength));
    
    //
    // We will break out of the loop when FindNextVolume does not
    // return success. Check if it failed for a reason other than that
    // we have enumerated all volumes.
    //

    ErrorCode = GetLastError();   

    if (ErrorCode != ERROR_NO_MORE_FILES) {
        goto cleanup;
    }

    //
    // Set return value.
    //

    *NtPathTranslationList = TranslationList;

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (FindVolumeHandle != INVALID_HANDLE_VALUE) {
        FindVolumeClose(FindVolumeHandle);
    }

    if (VolumePathNames) {
        PFSVC_FREE(VolumePathNames);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (TranslationList) {
            PfSvFreeNtPathTranslationList(TranslationList); 
        }
    }

    if (VolumeName) {
        PFSVC_FREE(VolumeName);
    }

    if (NTDevicePath) {
        PFSVC_FREE(NTDevicePath);
    }

    DBGPR((PFID,PFTRC,"PFSVC: BuildTransList()=%x,%p\n", ErrorCode, TranslationList));

    return ErrorCode;
}

VOID
PfSvFreeNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST TranslationList
    )

/*++

Routine Description:

    This routine is called to free a translation list returned by
    PfSvBuildNtPathTranslationList.

Arguments:

    TranslationList - Pointer to list to free.

Return Value:

    None.

--*/

{
    PLIST_ENTRY HeadEntry;
    PNTPATH_TRANSLATION_ENTRY TranslationEntry;

    DBGPR((PFID,PFTRC,"PFSVC: FreeTransList(%p)\n", TranslationList));

    //
    // Free all entries in the list.
    //

    while (!IsListEmpty(TranslationList)) {

        HeadEntry = RemoveHeadList(TranslationList);
        
        TranslationEntry = CONTAINING_RECORD(HeadEntry,
                                             NTPATH_TRANSLATION_ENTRY,
                                             Link);

        PFSVC_FREE(TranslationEntry);
    }

    //
    // Free the list itself.
    //

    PFSVC_FREE(TranslationList);
}

DWORD 
PfSvTranslateNtPath(
    PNTPATH_TRANSLATION_LIST TranslationList,
    WCHAR *NtPath,
    ULONG NtPathLength,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    )

/*++

Routine Description:

    This routine is called to free a translation list returned by
    PfSvBuildNtPathTranslationList. Note that it may not be possible to
    translate all Nt path's to a Dos path.

Arguments:

    TranslationList - Pointer to list built by PfSvBuildNtPathTranslationList.

    NtPath - Path to translate.

    NtPathLength - Length of NtPath in characters excluding terminating NUL.

    DosPathBuffer - Buffer to put the translation into. If it is NULL
      or not big enough it will get reallocated. If a buffer is passed
      in, it should be allocated by PFSVC_ALLOC. It is the callers
      responsibility to free the buffer with PFSVC_FREE when done.

    DosPathBufferSize - Size of DosPathBuffer in bytes. Updated if the
      buffer is reallocated.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PNTPATH_TRANSLATION_ENTRY CurrentTranslationEntry;
    PNTPATH_TRANSLATION_ENTRY FoundTranslationEntry;
    PFSV_PREFIX_COMPARISON_RESULT ComparisonResult;
    ULONG RequiredSize;

    //
    // Initialize locals.
    //

    FoundTranslationEntry = NULL;

    DBGPR((PFID,PFPATH,"PFSVC: TranslateNtPath(%ws)\n", NtPath));

    //
    // Walk through the sorted translation list to find an entry that
    // applies.
    //

    HeadEntry = TranslationList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {
        
        CurrentTranslationEntry = CONTAINING_RECORD(NextEntry,
                                                    NTPATH_TRANSLATION_ENTRY,
                                                    Link);
        
        //
        // Do a case insensitive comparison.
        //

        ComparisonResult = PfSvComparePrefix(NtPath,
                                             NtPathLength,
                                             CurrentTranslationEntry->NtPrefix,
                                             CurrentTranslationEntry->NtPrefixLength,
                                             FALSE);

        if (ComparisonResult == PfSvPrefixIdentical) {
            
            //
            // Check to see if the character in NtPath after the
            // prefix is a path seperator [i.e. '\']. Otherwise we may
            // match \Device\CdRom10\DirName\FileName to \Device\Cdrom1.
            //
            
            if (NtPathLength == CurrentTranslationEntry->NtPrefixLength ||
                NtPath[CurrentTranslationEntry->NtPrefixLength] == L'\\') {

                //
                // We found a translation entry that applies to us.
                //
                
                FoundTranslationEntry = CurrentTranslationEntry;
                break;
            }

        } else if (ComparisonResult == PfSvPrefixGreaterThan) {

            //
            // Since the translation list is sorted in increasing
            // order, following entries will also be greater than
            // NtPath.
            //

            FoundTranslationEntry = NULL;
            break;
        }
        
        //
        // Continue looking for a matching prefix.
        //
                                         
        NextEntry = NextEntry->Flink;
    }

    //
    // If we could not find an entry that applies we cannot translate
    // the path.
    //

    if (FoundTranslationEntry == NULL) {
        ErrorCode = ERROR_PATH_NOT_FOUND;
        goto cleanup;
    }

    //
    // Calculate required size: We will replace the NtPrefix with
    // DosPrefix. Don't forget the terminating NUL character.
    //

    RequiredSize = (NtPathLength + 1) * sizeof(WCHAR);
    RequiredSize += (FoundTranslationEntry->DosPrefixLength * sizeof(WCHAR));
    RequiredSize -= (FoundTranslationEntry->NtPrefixLength * sizeof(WCHAR));

    if (RequiredSize > (*DosPathBufferSize)) {

        //
        // Reallocate the buffer. First free it if there is one.
        //

        if (*DosPathBufferSize) {
            PFSVC_ASSERT(*DosPathBuffer);
            PFSVC_FREE(*DosPathBuffer);
            (*DosPathBuffer) = NULL;
            (*DosPathBufferSize) = 0;
        }

        PFSVC_ASSERT((*DosPathBuffer) == NULL);

        (*DosPathBuffer) = PFSVC_ALLOC(RequiredSize);
        
        if (!(*DosPathBuffer)) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        (*DosPathBufferSize) = RequiredSize;
    }

    //
    // We should have enough room now.
    //

    PFSVC_ASSERT(RequiredSize <= (*DosPathBufferSize));

    //
    // Copy the DosPrefix.
    //

    wcscpy((*DosPathBuffer), FoundTranslationEntry->DosPrefix);
    
    //
    // Concatenate the remaining path.
    //

    wcscat((*DosPathBuffer), NtPath + CurrentTranslationEntry->NtPrefixLength);

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFPATH,"PFSVC: TranslateNtPath(%ws)=%x,%ws\n",
           NtPath,ErrorCode,(ErrorCode==ERROR_SUCCESS)?(*DosPathBuffer):L"Failed"));

    return ErrorCode;
}

//
// Implementation of the path list API.
//

VOID
PfSvInitializePathList(
    PPFSVC_PATH_LIST PathList,
    OPTIONAL IN PPFSVC_STRING_ALLOCATOR PathAllocator,
    IN BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This function initializes a path list structure.

Arguments:

    PathList - Pointer to structure.

    PathAllocator - If specified path allocations will be made from it.

    CaseSenstive - Whether list will be case senstive.

Return Value:

    None.

--*/

{
    InitializeListHead(&PathList->InOrderList);
    InitializeListHead(&PathList->SortedList);
    PathList->NumPaths = 0;
    PathList->TotalLength = 0;
    PathList->Allocator = PathAllocator;
    PathList->CaseSensitive = CaseSensitive;
}

VOID
PfSvCleanupPathList(
    PPFSVC_PATH_LIST PathList
    )

/*++

Routine Description:

    This function cleans up a path list structure. It does not free
    the structure itself. The structure should have been initialized
    by PfSvInitializePathList.

Arguments:

    PathList - Pointer to structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PPFSVC_PATH Path;

    while (!IsListEmpty(&PathList->InOrderList)) {

        PFSVC_ASSERT(PathList->NumPaths);
        PathList->NumPaths--;

        ListEntry = RemoveHeadList(&PathList->InOrderList);
        Path = CONTAINING_RECORD(ListEntry,
                                 PFSVC_PATH,
                                 InOrderLink);

        if (PathList->Allocator) {
            PfSvStringAllocatorFree(PathList->Allocator, Path);
        } else {
            PFSVC_FREE(Path);
        }
    }
}

BOOLEAN
PfSvIsInPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    )

/*++

Routine Description:

    This function checks if the specified path is already in the path
    list. 

Arguments:

    PathList - Pointer to list.

    Path - Path to look for. Does not have to be NUL terminated.
      
    PathLength - Length of Path in characters excluding NUL if there
      is one.

Return Value:

    Win32 error code.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH PathEntry;
    INT ComparisonResult;
    BOOLEAN PathIsInPathList;

    //
    // Walk through the list.
    //

    HeadEntry = &PathList->SortedList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {

        PathEntry = CONTAINING_RECORD(NextEntry,
                                      PFSVC_PATH,
                                      SortedLink);
        
        if (PathList->CaseSensitive) {
            ComparisonResult = wcsncmp(Path,
                                       PathEntry->Path,
                                       PathLength);
        } else {
            ComparisonResult = _wcsnicmp(Path,
                                         PathEntry->Path,
                                         PathLength);
        }

        //
        // Adjust comparison result so we don't match "abcde" to
        // "abcdefg". If string comparison says the first PathLength
        // characters match, check to see if PathEntry's length is
        // longer, which would make it "greater" than the new path.
        //

        if (ComparisonResult == 0 && PathEntry->Length != PathLength) {
            
            //
            // The string comparison would not say The path entry's
            // path is equal to path if its length was smaller.
            //
            
            PFSVC_ASSERT(PathEntry->Length > PathLength);
            
            //
            // Path is actually less than this path entry.
            //

            ComparisonResult = -1; 
        }

        //
        // Based on comparison result determine what to do:
        //

        if (ComparisonResult == 0) {

            //
            // We found it.
            //
            
            PathIsInPathList = TRUE;
            goto cleanup;

        } else if (ComparisonResult < 0) {
            
            //
            // We will be less than the rest of the strings in the
            // list after this too.
            //
            
            PathIsInPathList = FALSE;
            goto cleanup;
        }

        //
        // Continue looking for the path or an available position.
        //

        NextEntry = NextEntry->Flink;
    }

    //
    // If we came here, we could not find the path in the list.
    //

    PathIsInPathList = FALSE;

 cleanup:
    
    return PathIsInPathList;
}

DWORD
PfSvAddToPathList(
    PPFSVC_PATH_LIST PathList,  
    WCHAR *Path,
    ULONG PathLength
    )

/*++

Routine Description:

    This function adds a path to a path list. If the path already
    exists in the list, it is not added again.

Arguments:

    PathList - Pointer to list.

    Path - Path to add. Does not need to be NUL terminated.
      
    PathLength - Length of Path in characters excluding NUL if there
      is one.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH PathEntry;
    PPFSVC_PATH NewPathEntry;
    INT ComparisonResult;
    ULONG AllocationSize;

    //
    // Initialize locals.
    //

    NewPathEntry = NULL;
    
    //
    // Walk through the list to check if path is already in the list,
    // or to find where it should be so we can insert it there.
    //

    HeadEntry = &PathList->SortedList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {

        PathEntry = CONTAINING_RECORD(NextEntry,
                                      PFSVC_PATH,
                                      SortedLink);
        
        if (PathList->CaseSensitive) {
            ComparisonResult = wcsncmp(Path,
                                       PathEntry->Path,
                                       PathLength);
        } else {
            ComparisonResult = _wcsnicmp(Path,
                                         PathEntry->Path,
                                         PathLength);
        }

        //
        // Adjust comparison result so we don't match "abcde" to
        // "abcdefg". If string comparison says the first PathLength
        // characters match, check to see if PathEntry's length is
        // longer, which would make it "greater" than the new path.
        //

        if (ComparisonResult == 0 && PathEntry->Length != PathLength) {
            
            //
            // The string comparison would not say The path entry's
            // path is equal to path if its length was smaller.
            //
            
            PFSVC_ASSERT(PathEntry->Length > PathLength);
            
            //
            // Path is actually less than this path entry.
            //

            ComparisonResult = -1; 
        }

        //
        // Based on comparison result determine what to do:
        //

        if (ComparisonResult == 0) {

            //
            // The path already exists in the list.
            //
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

        } else if (ComparisonResult < 0) {
            
            //
            // We will be less than the rest of the strings in the
            // list after this too. We should be inserted before this
            // one.
            //
            
            break;
        }

        //
        // Continue looking for the path or an available position.
        //

        NextEntry = NextEntry->Flink;
    }

    //
    // We will insert the path before NextEntry. First create an entry
    // we can insert.
    //
    
    AllocationSize = sizeof(PFSVC_PATH);
    AllocationSize += PathLength * sizeof(WCHAR);
    
    //
    // Note that PFSVC_PATH already contains space for the terminating
    // NUL character.
    //

    if (PathList->Allocator) {
        NewPathEntry = PfSvStringAllocatorAllocate(PathList->Allocator, AllocationSize);
    } else {
        NewPathEntry = PFSVC_ALLOC(AllocationSize);
    }
    
    if (!NewPathEntry) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Copy path and terminate it.
    //

    NewPathEntry->Length = PathLength;
    RtlCopyMemory(NewPathEntry->Path,
                  Path,
                  PathLength * sizeof(WCHAR));
    
    NewPathEntry->Path[PathLength] = 0;
    
    //
    // Insert it into the sorted list before the current entry.
    //
    
    InsertTailList(NextEntry, &NewPathEntry->SortedLink);
    
    //
    // Insert it at the end of in-order list.
    //
    
    InsertTailList(&PathList->InOrderList, &NewPathEntry->InOrderLink);
    
    PathList->NumPaths++;
    PathList->TotalLength += NewPathEntry->Length;

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (ErrorCode != ERROR_SUCCESS) {
        if (NewPathEntry) {
            if (PathList->Allocator) {
                PfSvStringAllocatorFree(PathList->Allocator, NewPathEntry);
            } else {
                PFSVC_FREE(NewPathEntry);
            }
        }
    }

    return ErrorCode;
}

PPFSVC_PATH
PfSvGetNextPathSorted (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    )

/*++

Routine Description:

    This function is used to walk through paths in a path list in
    lexically sorted order.

Arguments:

    PathList - Pointer to list.

    CurrentPath - The current path entry. The function will return the 
      next entry in the list. If this is NULL, the first entry in the
      list is returned.

Return Value:

    NULL - There are no more entries in the list.
    
    or Pointer to next path in the list.

--*/

{
    PLIST_ENTRY EndOfList;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH NextPath;
    
    //
    // Initialize locals.
    //
   
    EndOfList = &PathList->SortedList;

    //
    // Determine NextEntry based on whether CurrentPath is specified.
    //

    if (CurrentPath) {
        NextEntry = CurrentPath->SortedLink.Flink;
    } else {
        NextEntry = PathList->SortedList.Flink;
    }

    //
    // Check if the NextEntry points to the end of list.
    //

    if (NextEntry == EndOfList) {
        NextPath = NULL;
    } else {
        NextPath = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PATH,
                                     SortedLink);
    }
    
    return NextPath;
}

PPFSVC_PATH
PfSvGetNextPathInOrder (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    )

/*++

Routine Description:

    This function is used to walk through paths in a path list in
    the order they were inserted into the list.

Arguments:

    PathList - Pointer to list.

    CurrentPath - The current path entry. The function will return the 
      next entry in the list. If this is NULL, the first entry in the
      list is returned.

Return Value:

    NULL - There are no more entries in the list.
    
    or Pointer to next path in the list.

--*/

{
    PLIST_ENTRY EndOfList;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH NextPath;
    
    //
    // Initialize locals.
    //
   
    EndOfList = &PathList->InOrderList;

    //
    // Determine NextEntry based on whether CurrentPath is specified.
    //

    if (CurrentPath) {
        NextEntry = CurrentPath->InOrderLink.Flink;
    } else {
        NextEntry = PathList->InOrderList.Flink;
    }

    //
    // Check if the NextEntry points to the end of list.
    //

    if (NextEntry == EndOfList) {
        NextPath = NULL;
    } else {
        NextPath = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PATH,
                                     InOrderLink);
    }
    
    return NextPath;
}

//
// Routines to build the list of files accessed by the boot loader.
//

DWORD
PfSvBuildBootLoaderFilesList (
    PPFSVC_PATH_LIST PathList
    )

/*++

Routine Description:

    This function attempts to add the list of files loaded in the boot
    loader to the specified file list.

Arguments:

    PathList - Pointer to initialized list.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    SC_HANDLE ScHandle;
    SC_HANDLE ServiceHandle;
    LPENUM_SERVICE_STATUS_PROCESS EnumBuffer;
    LPENUM_SERVICE_STATUS_PROCESS ServiceInfo;
    ULONG EnumBufferMaxSize;
    ULONG NumResizes;
    BOOL Result;
    ULONG RequiredAdditionalSize;
    ULONG RequiredSize;
    ULONG NumServicesEnumerated;
    ULONG ResumeHandle;
    ULONG ServiceIdx;
    LPQUERY_SERVICE_CONFIG ServiceConfigBuffer;
    ULONG ServiceConfigBufferMaxSize;
    WCHAR FilePath[MAX_PATH + 1];
    ULONG FilePathLength;
    ULONG SystemDirLength;
    ULONG RequiredLength;
    WCHAR *KernelName;
    WCHAR *HalName;
    WCHAR *SystemHive;
    WCHAR *SoftwareHive;
    
    //
    // Initialize locals.
    //
    
    ScHandle = NULL;
    ServiceHandle = NULL;
    EnumBuffer = NULL;
    EnumBufferMaxSize = 0;
    NumServicesEnumerated = 0;
    ServiceConfigBuffer = NULL;
    ServiceConfigBufferMaxSize = 0;
    KernelName = L"ntoskrnl.exe";
    HalName = L"hal.dll";
    SystemHive = L"config\\system";
    SoftwareHive = L"config\\software";

    //
    // Add kernel & hal to known files list:
    //

    //
    // Get path to system directory.
    // 

    SystemDirLength = GetSystemDirectory(FilePath, MAX_PATH);

    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    //
    // Append a trailing \.
    //

    if (SystemDirLength + 1 < MAX_PATH) {
        FilePath[SystemDirLength] = '\\';
        SystemDirLength++;
        FilePath[SystemDirLength] = 0;
    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Append kernel name and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(KernelName);
    
    if (FilePathLength < MAX_PATH) {
        wcscat(FilePath, KernelName);
        ErrorCode = PfSvAddBootImageAndImportsToList(PathList, 
                                                     FilePath,
                                                     FilePathLength);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Roll FilePath back to system directory. Append hal name and add
    // it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(HalName);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, HalName);
        ErrorCode = PfSvAddBootImageAndImportsToList(PathList, 
                                                  FilePath,
                                                  FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Roll FilePath back to system directory. Append system hive path
    // and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(SystemHive);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, SystemHive);
        
        ErrorCode = PfSvAddToPathList(PathList,
                                   FilePath,
                                   FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Roll FilePath back to system directory. Append software hive path
    // and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(SoftwareHive);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, SoftwareHive);
        
        ErrorCode = PfSvAddToPathList(PathList,
                                   FilePath,
                                   FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Note that we will use FilePath & FilePathLength to add the
    // software hive after we add all the other boot loader files. The
    // software hive is not accessed in the boot loader, but during
    // boot. It is not put into the boot scenario file, however. We
    // don't want to mix it in with the boot loader files, so we don't
    // hurt the boot loader performance.
    //

    //
    // Add file paths for NLS data & fonts loaded by the boot loader.
    //

    PfSvGetBootLoaderNlsFileNames(PathList);

    //
    // Open service controller.
    //

    // FUTURE-2002/03/29-ScottMa -- The dwDesiredAccess parameter may be able
    //   to be set to a lesser set of priveleges.

    ScHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    if (ScHandle == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get the list of boot services we are interested in.
    //
    
    NumResizes = 0;
    
    do {

        //
        // We want to get all of services at one call.
        //

        ResumeHandle = 0;

        Result = EnumServicesStatusEx (ScHandle,
                                       SC_ENUM_PROCESS_INFO,
                                       SERVICE_DRIVER,
                                       SERVICE_ACTIVE,
                                       (PVOID)EnumBuffer,
                                       EnumBufferMaxSize,
                                       &RequiredAdditionalSize,
                                       &NumServicesEnumerated,
                                       &ResumeHandle,
                                       NULL);
        
        if (Result) {

            //
            // We got it.
            //
            
            break;
        }

        //
        // Check why our call failed.
        //

        ErrorCode = GetLastError();

        //
        // If we failed for some other reason than that our buffer was
        // too small, we cannot go on.
        //

        if (ErrorCode != ERROR_MORE_DATA) {
            goto cleanup;
        }

        //
        // Free the old buffer if it exists, and allocate a bigger one.
        //

        RequiredSize = EnumBufferMaxSize + RequiredAdditionalSize;

        if (EnumBuffer) {
            PFSVC_FREE(EnumBuffer);
            EnumBuffer = NULL;
            EnumBufferMaxSize = 0;
        }
        
        EnumBuffer = PFSVC_ALLOC(RequiredSize);
        
        if (EnumBuffer == NULL) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        EnumBufferMaxSize = RequiredSize;

        //
        // Make sure we don't loop for ever.
        //

        NumResizes++;
        if (NumResizes > 100) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // Identify the enumerated services that may be loaded by the boot
    // loader.
    //

    for (ServiceIdx = 0; ServiceIdx < NumServicesEnumerated; ServiceIdx++) {
        
        ServiceInfo = &EnumBuffer[ServiceIdx];

        //
        // Open the service to get its configuration info.
        //

        ServiceHandle = OpenService(ScHandle, 
                                    ServiceInfo->lpServiceName,
                                    SERVICE_QUERY_CONFIG);

        if (ServiceHandle == NULL) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // Query service configuration.
        //

        NumResizes = 0;
        
        do {

            Result = QueryServiceConfig(ServiceHandle,
                                        ServiceConfigBuffer,
                                        ServiceConfigBufferMaxSize,
                                        &RequiredSize);

            if (Result) {
                
                //
                // We got it.
                //
                
                break;
            }
        
            ErrorCode = GetLastError();
            
            if (ErrorCode != ERROR_INSUFFICIENT_BUFFER) {
                
                //
                // This is a real error.
                //
                
                goto cleanup;
            }

            //
            // Resize the buffer and try again.
            //

            if (ServiceConfigBuffer) {
                PFSVC_FREE(ServiceConfigBuffer);
                ServiceConfigBuffer = NULL;
                ServiceConfigBufferMaxSize = 0;
            }

            ServiceConfigBuffer = PFSVC_ALLOC(RequiredSize);
            
            if (ServiceConfigBuffer == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ServiceConfigBufferMaxSize = RequiredSize;

            //
            // Make sure we don't loop forever.
            //

            NumResizes++;
            if (NumResizes > 100) {
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

        } while (TRUE);
        
        //
        // We are interested in this service only if it starts as a
        // boot driver or if it is a file system.
        //

        if (ServiceConfigBuffer->dwStartType == SERVICE_BOOT_START ||
            ServiceConfigBuffer->dwServiceType == SERVICE_FILE_SYSTEM_DRIVER) {

            //
            // Try to locate the real service binary path.
            //

            ErrorCode = PfSvGetBootServiceFullPath(ServiceInfo->lpServiceName,
                                            ServiceConfigBuffer->lpBinaryPathName,
                                            FilePath,
                                            MAX_PATH,
                                            &RequiredLength);
            
            if (ErrorCode == ERROR_SUCCESS) {
                PfSvAddBootImageAndImportsToList(PathList, 
                                                 FilePath,
                                                 wcslen(FilePath));
            }
        }
        
        //
        // Close the handle and continue.
        //
        
        CloseServiceHandle(ServiceHandle);
        ServiceHandle = NULL;
    }   

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }

    if (ScHandle) {
        CloseServiceHandle(ScHandle);
    }
    
    if (EnumBuffer) {
        PFSVC_FREE(EnumBuffer);
    }

    if (ServiceConfigBuffer) {
        PFSVC_FREE(ServiceConfigBuffer);
    }

    return ErrorCode;
}

DWORD 
PfSvAddBootImageAndImportsToList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This function attempts to add the image file whose fully qualified
    path is in FilePath as well as the modules it imports from to the
    file list, if those modules can be located.

    NOTE: Ntoskrnl.exe and Hal.dll are special cased out and not added
    to the file list, since most drivers will import from them. They
    can be added to the list seperately. Also note that the file list
    is not checked for duplicates when adding new entries.

Arguments:

    PathList - Pointer to list.

    FilePath - Fully qualified path of an image file.

    FilePathLength - Length of the file path in characters excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG MaxNumImports;
    ULONG NumImports;
    WCHAR **ImportNames;
    ULONG ImportIdx;
    ULONG BufferSize;
    WCHAR *FileName;
    WCHAR ParentDir[MAX_PATH + 1];
    ULONG ParentDirLength;
    WCHAR *ImportName;
    ULONG ImportNameLength;
    WCHAR ImportPath[MAX_PATH + 1];
    PUCHAR ImportBase;
    ULONG RequiredLength;
    ULONG FileSize;
    PIMAGE_IMPORT_DESCRIPTOR NewImportDescriptor;
    CHAR *NewImportNameAnsi;
    WCHAR *NewImportName;
    ULONG NewImportNameRva;
    BOOLEAN AddedToTable;
    ULONG ImportTableSize;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG NextImport;
    ULONG FailedCheck;

    //
    // Initialize locals.
    //

    MaxNumImports = 256;
    ImportNames = NULL;
    NumImports = 0;
    NextImport = 0;

    //
    // Find the file name from the path.
    //

    if (FilePathLength == 0 || FilePath[FilePathLength - 1] == L'\\') {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    FileName = &FilePath[FilePathLength - 1];   
    while (FileName > FilePath) {

        //
        // It is OK to decrement FileName the first time in the loop because
        // we checked for the terminating slash above.
        //

        FileName--;

        if (*FileName == L'\\') {
            FileName++;
            break;
        }
    }

    //
    // Extract the parent directory.
    //

    ParentDirLength = (ULONG) (FileName - FilePath);

    if (ParentDirLength >= MAX_PATH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }
    
    wcsncpy(ParentDir, FilePath, ParentDirLength);
    ParentDir[ParentDirLength] = 0;
    
    //
    // Allocate a table for keeping track of imported modules.
    //

    BufferSize = MaxNumImports * sizeof(WCHAR *);
    ImportNames = PFSVC_ALLOC(BufferSize);
    
    if (ImportNames == NULL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(ImportNames, BufferSize);

    //
    // Insert the file into the table and kick off import enumeration
    // on the table. Each enumerated import gets appended to the table
    // if it is not already present. Enumeration continues until all
    // appended entries are processed. 
    //

    ImportNames[NumImports] = FileName;
    NumImports++;

    while (NextImport < NumImports) {

        //
        // Initialize loop locals.
        //
        
        ImportBase = NULL;
        ImportName = ImportNames[NextImport];
        ImportNameLength = wcslen(ImportName);

        //
        // Locate the file. First look in ParentDir.
        //
        
        if (ImportNameLength + ParentDirLength >= MAX_PATH) {
          goto NextImport;
        }
        
        wcscpy(ImportPath, ParentDir);
        wcscat(ImportPath, ImportName);
        
        if (GetFileAttributes(ImportPath) == INVALID_FILE_ATTRIBUTES) {

            //
            // Look for this file in other known directories.
            //
            
            ErrorCode = PfSvLocateBootServiceFile(ImportName,
                                               ImportNameLength,
                                               ImportPath,
                                               MAX_PATH,
                                               &RequiredLength);
            
            if (ErrorCode != ERROR_SUCCESS) {
              goto NextImport;
            }
        }

        //
        // Add the file to the file list.
        //

        PfSvAddToPathList(PathList,
                          ImportPath,
                          wcslen(ImportPath));
        
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(ImportPath, &ImportBase, &FileSize); 
        
        if (ErrorCode != ERROR_SUCCESS) {
          goto NextImport;
        }

        //
        // Make sure this is an image file.
        //

        __try {

            //
            // This is the first access to the mapped file. Under stress we might not be
            // able to page this in and an exception might be raised. This protects us from
            // the most common failure case.
            //

            //
            // Verify the image and its import table. If the image is corrupt it might 
            // result in an AV when we try to walk its imports.
            //

            FailedCheck = PfVerifyImageImportTable(ImportBase, FileSize, FALSE);

            if (FailedCheck) {
                ErrorCode = ERROR_BAD_FORMAT;
                goto NextImport;
            }

            NtHeaders = ImageNtHeader(ImportBase);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            NtHeaders = NULL;
        }
        
        if (NtHeaders == NULL) {
          goto NextImport;
        }

        //
        // Walk through the imports for this binary.
        //

        NewImportDescriptor = ImageDirectoryEntryToData(ImportBase,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                        &ImportTableSize);

        while (NewImportDescriptor &&
               (NewImportDescriptor->Name != 0) &&
               (NewImportDescriptor->FirstThunk != 0)) {

            //
            // Initialize loop locals.
            //
            
            AddedToTable = FALSE;
            NewImportName = NULL;

            //
            // Get the name for this import.
            //

            NewImportNameRva = NewImportDescriptor->Name;
            NewImportNameAnsi = ImageRvaToVa(NtHeaders, 
                                             ImportBase,
                                             NewImportNameRva,
                                             NULL);
            
            ErrorCode = GetLastError();

            if (NewImportNameAnsi) {
                NewImportName = PfSvcAnsiToUnicode(NewImportNameAnsi);
            }

            if (NewImportName == NULL) {
                goto NextImportDescriptor;
            }
            
            //
            // Skip the kernel and hal imports. See comment in
            // function description.
            //

            if (!_wcsicmp(NewImportName, L"ntoskrnl.exe") ||
                !_wcsicmp(NewImportName, L"hal.dll")) {
                goto NextImportDescriptor;
            }

            //
            // Check to see if this import is already in our table.
            //

            for (ImportIdx = 0; ImportIdx < NumImports; ImportIdx++) {
                if (!_wcsicmp(NewImportName, ImportNames[ImportIdx])) {
                    goto NextImportDescriptor;
                }
            }
            
            //
            // Append this import to the table.
            //
            
            if (NumImports < MaxNumImports) {
                ImportNames[NumImports] = NewImportName;
                NumImports++;
                AddedToTable = TRUE;
            }

        NextImportDescriptor:

            if (!AddedToTable && NewImportName) {
                PFSVC_FREE(NewImportName);
            }
            
            if (NumImports >= MaxNumImports) {
                break;
            }
            
            NewImportDescriptor++;
        }
        
    NextImport:        

        if (ImportBase) {
            UnmapViewOfFile(ImportBase);
        }
        
        NextImport++;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ImportNames) {
        
        //
        // The first entry in the table is the filename from FilePath,
        // which is not allocated and which should not be freed.
        //
        
        for (ImportIdx = 1; ImportIdx < NumImports; ImportIdx++) {
            PfSvcFreeString(ImportNames[ImportIdx]);
        }

        PFSVC_FREE(ImportNames);
    }

    return ErrorCode;
}

DWORD
PfSvLocateBootServiceFile(
    IN WCHAR *FileName,
    IN ULONG FileNameLength,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength   
    )

/*++

Routine Description:

    This function looks at known directories in an *attempt* locate
    the file whose name is specified. The logic may have to be
    improved.

Arguments:

    FileName - File name to look for.

    FileNameLength - Length of file name in characters excluding NUL.
      
    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    ERROR_INSUFFICIENT_BUFFER - The FullPathBuffer is not big enough.

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR *DriversDirName;
    ULONG SystemDirLength;
    
    //
    // Initialize locals.
    //

    DriversDirName = L"drivers\\";

    //
    // Copy system root path and a trailing \.
    //

    SystemDirLength = GetSystemDirectory(FullPathBuffer, FullPathBufferLength);

    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    SystemDirLength++;

    //
    // Calculate maximum size of required length.
    //

    (*RequiredLength) = SystemDirLength;
    (*RequiredLength) += wcslen(DriversDirName);
    (*RequiredLength) += FileNameLength;
    (*RequiredLength) += 1; // terminating NUL.

    if ((*RequiredLength) > FullPathBufferLength) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Append slash.
    //
    
    wcscat(FullPathBuffer, L"\\");

    //
    // Append drivers path.
    //

    wcscat(FullPathBuffer, DriversDirName);
    
    //
    // Append file name.
    //

    wcscat(FullPathBuffer, FileName);

    if (GetFileAttributes(FullPathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Roll back and look for the file in the system
    // directory. SystemDirLength includes the slash after system
    // directory path.
    //
    
    FullPathBuffer[SystemDirLength] = 0;
    
    wcscat(FullPathBuffer, FileName);

    if (GetFileAttributes(FullPathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:    
    
    return ErrorCode;
}

DWORD
PfSvGetBootServiceFullPath(
    IN WCHAR *ServiceName,
    IN WCHAR *BinaryPathName,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function *attempts* to locate specified boot service. The
    logic may have to be improved.

Arguments:

    ServiceName - Name of the service.

    BinaryPathName - From service configuration info. This is supposed
      to be the full path, but it is not.
      
    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR FileName[MAX_PATH];
    ULONG BinaryPathLength;
    BOOLEAN GotFileNameFromBinaryPath;
    LONG CharIdx;
    ULONG CopyLength;
    WCHAR *SysExtension;
    WCHAR *DllExtension;
    WCHAR *FileNamePart;

    //
    // Initialize locals.
    //
    
    GotFileNameFromBinaryPath = FALSE;
    SysExtension = L".sys";
    DllExtension = L".dll";

    //
    // Check if a binary path was specified.
    //

    if (BinaryPathName && BinaryPathName[0]) {

        //
        // See if the file is really there.
        //

        if (GetFileAttributes(BinaryPathName) != INVALID_FILE_ATTRIBUTES) {
            
            //
            // BinaryPathName may not be a fully qualified path. Make
            // sure it is.
            //
            
            (*RequiredLength) = GetFullPathName(BinaryPathName,
                                              FullPathBufferLength,
                                              FullPathBuffer,
                                              &FileNamePart);
            
            if ((*RequiredLength) == 0) {
                ErrorCode = GetLastError();
                goto cleanup;
            }

            if ((*RequiredLength) > FullPathBufferLength) {
                ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                goto cleanup;
            }
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Try to extract a file name from the binary path.
        //

        BinaryPathLength = wcslen(BinaryPathName);
        
        for (CharIdx = BinaryPathLength - 1;
             CharIdx >= 0;
             CharIdx --) {
            
            if (BinaryPathName[CharIdx] == L'\\') {

                //
                // Check length and copy it.
                //
                
                CopyLength = BinaryPathLength - CharIdx;

                if (CopyLength < MAX_PATH &&
                    CopyLength > 1) {

                    //
                    // Copy name starting after the \ character.
                    //

                    wcscpy(FileName, &BinaryPathName[CharIdx + 1]);

                    GotFileNameFromBinaryPath = TRUE;
                }

                break;
            }
        }
        
        //
        // There was not a slash. Maybe the BinaryPathLength is just
        // the file name.
        //
        
        if (GotFileNameFromBinaryPath == FALSE && 
            BinaryPathLength && 
            BinaryPathLength < MAX_PATH) {

            wcscpy(FileName, BinaryPathName);
            GotFileNameFromBinaryPath = TRUE;
        }
    }

    //
    // After this point we will base our search on file name hints.
    //

    //
    // If we got a file name from the binary path try that first.
    //

    if (GotFileNameFromBinaryPath) {
        
        ErrorCode = PfSvLocateBootServiceFile(FileName,
                                           wcslen(FileName),
                                           FullPathBuffer,
                                           FullPathBufferLength,
                                           RequiredLength);
        
        if (ErrorCode != ERROR_FILE_NOT_FOUND) {

            //
            // If we found a path or if the buffer length was not
            // enough we will bubble up that to our caller.
            //

            goto cleanup;
        }      
    }

    //
    // Build a file name from service name by appending a .sys.
    //

    CopyLength = wcslen(ServiceName);
    CopyLength += wcslen(SysExtension);
    
    if (CopyLength >= MAX_PATH) {

        //
        // The service name is too long!
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    wcscpy(FileName, ServiceName);
    wcscat(FileName, SysExtension);

    ErrorCode = PfSvLocateBootServiceFile(FileName,
                                       wcslen(FileName),
                                       FullPathBuffer,
                                       FullPathBufferLength,
                                       RequiredLength);
    
    if (ErrorCode != ERROR_FILE_NOT_FOUND) {

        //
        // If we found a path or if the buffer length was not
        // enough we will bubble up that to our caller.
        //

        goto cleanup;
    }      

    //
    // Build a file name from service name by appending a .dll.
    //

    CopyLength = wcslen(ServiceName);
    CopyLength += wcslen(DllExtension);
    
    if (CopyLength >= MAX_PATH) {

        //
        // The service name is too long!
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    wcscpy(FileName, ServiceName);
    wcscat(FileName, DllExtension);

    ErrorCode = PfSvLocateBootServiceFile(FileName,
                                       wcslen(FileName),
                                       FullPathBuffer,
                                       FullPathBufferLength,
                                       RequiredLength);
    
    if (ErrorCode != ERROR_FILE_NOT_FOUND) {

        //
        // If we found a path or if the buffer length was not
        // enough we will bubble up that to our caller.
        //

        goto cleanup;
    }      
        
    //
    // We could not find the file...
    //

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:

    return ErrorCode;
}

DWORD 
PfSvGetBootLoaderNlsFileNames (
    PPFSVC_PATH_LIST PathList
    ) 

/*++

Routine Description:

    This function attempts to add the list of NLS files loaded in the
    boot loader to the specified file list.

Arguments:

    PathList - Pointer to list.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    HKEY NlsKeyHandle;
    WCHAR *CodePageKeyName;
    HKEY CodePageKeyHandle;
    WCHAR *LanguageKeyName;
    HKEY LanguageKeyHandle;
    ULONG BufferSize;
    ULONG RequiredSize;
    ULONG RequiredLength;
    WCHAR FileName[MAX_PATH + 1];
    WCHAR FilePath[MAX_PATH + 1];
    WCHAR *AnsiCodePageName;
    WCHAR *OemCodePageName;
    WCHAR *OemHalName;
    WCHAR *DefaultLangName;
    ULONG RegValueType;

    //
    // Initialize locals.
    //
    
    NlsKeyHandle = NULL;
    CodePageKeyHandle = NULL;
    LanguageKeyHandle = NULL;
    CodePageKeyName = L"CodePage";
    LanguageKeyName = L"Language";
    AnsiCodePageName = L"ACP";
    OemCodePageName = L"OEMCP";
    DefaultLangName = L"Default";
    OemHalName = L"OEMHAL";  

    //
    // Open NLS key.
    //

    ErrorCode = RegOpenKey(HKEY_LOCAL_MACHINE,
                           PFSVC_NLS_REG_KEY_PATH,
                           &NlsKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Open CodePage key.
    //

    ErrorCode = RegOpenKey(NlsKeyHandle,
                        CodePageKeyName,
                        &CodePageKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Open Language key.
    //

    ErrorCode = RegOpenKey(NlsKeyHandle,
                        LanguageKeyName,
                        &LanguageKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // AnsiCodePage:
    //

    ErrorCode = PfSvQueryNlsFileName(CodePageKeyHandle,
                                  AnsiCodePageName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // OemCodePage:
    //

    ErrorCode = PfSvQueryNlsFileName(CodePageKeyHandle,
                                  OemCodePageName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // Default language case conversion.
    //

    ErrorCode = PfSvQueryNlsFileName(LanguageKeyHandle,
                                  DefaultLangName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // OemHal:
    //
   
    BufferSize = MAX_PATH * sizeof(WCHAR);
    ErrorCode = RegQueryValueEx(CodePageKeyHandle,
                             OemHalName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileName,
                             &BufferSize);
    

    FileName[MAX_PATH - 1] = 0;

    if (ErrorCode == ERROR_SUCCESS && RegValueType == REG_SZ) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (NlsKeyHandle) {
        RegCloseKey(NlsKeyHandle);
    }

    if (CodePageKeyHandle) {
        RegCloseKey(CodePageKeyHandle);
    }

    if (LanguageKeyHandle) {
        RegCloseKey(LanguageKeyHandle);
    }

    return ErrorCode;
}

DWORD 
PfSvLocateNlsFile(
    WCHAR *FileName,
    WCHAR *FilePathBuffer,
    ULONG FilePathBufferLength,
    ULONG *RequiredLength
    )

/*++

Routine Description:

    This function attempts to locate a nls/font related file in known
    directories.

Arguments:

    FileName - File name to look for.

    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    ERROR_INSUFFICIENT_BUFFER - The FullPathBuffer is not big enough.

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    ULONG SystemRootLength;
    WCHAR *System32DirName;
    WCHAR *FontsDirName;
    WCHAR *SystemDirName;
    WCHAR *LongestDirName;

    //
    // Initialize locals. NOTE: The length of the longest directory
    // name to concatenate to SystemRoot is used in RequiredLength
    // calculation.
    //
    
    System32DirName = L"System32\\";
    SystemDirName = L"System\\";
    FontsDirName = L"Fonts\\";
    LongestDirName = System32DirName;

    //
    // Get system root path.
    //

    SystemRootLength = ExpandEnvironmentStrings(L"%SystemRoot%\\",
                                                FilePathBuffer,
                                                FilePathBufferLength);

    if (SystemRootLength == 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // SystemRootLength includes the terminating NUL. Adjust it.
    //

    SystemRootLength--;

    //
    // Calculate required length with space for terminating NUL.
    //

    (*RequiredLength) = SystemRootLength;
    (*RequiredLength) += wcslen(LongestDirName);
    (*RequiredLength) += wcslen(FileName);
    (*RequiredLength) ++;

    if ((*RequiredLength) > FilePathBufferLength) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Look for it under system32 dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, System32DirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Look for it under fonts dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, FontsDirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }
    
    //
    // Look for it under system dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, SystemDirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Look for it at SystemRoot.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != INVALID_FILE_ATTRIBUTES) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }                                                

    //
    // Could not find the file.
    //

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvQueryNlsFileName (
    HKEY Key,
    WCHAR *ValueName,
    WCHAR *FileNameBuffer,
    ULONG FileNameBufferSize,
    ULONG *RequiredSize
    )

/*++

Routine Description:

    This function attempts to get a file name from an NLS
    CodePage/Language registry key.

Arguments:

    Key - CodePage or Language key handle.

    ValueName - What we are trying to get the file name for.

    FileNameBuffer - Where the file name will be put.
    
    FileNameBufferSize - Size in bytes of the file name buffer.

    RequiredSize - If FileNameBuffer is too small, this is what its
      size should be.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR FileValueName[MAX_PATH + 1];
    ULONG BufferSize;
    ULONG RegValueType;

    //
    // First we first get the valuename under which the file name is
    // stored, then we get the file name:
    //

    BufferSize = MAX_PATH * sizeof(WCHAR);
    ErrorCode = RegQueryValueEx(Key,
                             ValueName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileValueName,
                             &BufferSize);

    if (ErrorCode == ERROR_MORE_DATA) {
        ErrorCode = ERROR_INVALID_FUNCTION;
        goto cleanup;
    }

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (RegValueType != REG_SZ) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    FileValueName[MAX_PATH - 1] = 0;
    
    *RequiredSize = FileNameBufferSize;
    ErrorCode = RegQueryValueEx(Key,
                             FileValueName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileNameBuffer,
                             RequiredSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (RegValueType != REG_SZ) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    if (FileNameBufferSize >= sizeof(WCHAR)) {
        FileNameBuffer[(FileNameBufferSize/sizeof(WCHAR)) - 1] = 0;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

//
// Routines to manage / run idle tasks.
//

VOID
PfSvInitializeTask (
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Initialize the task structure. Should be called before any other
    task functions are called. You should call the cleanup routine
    on the initialized task.

Arguments:

    Task - Pointer to structure.

Return Value:

    None.
    
--*/
  
{

    //
    // Zero out the structure initializing the following to
    // the right values:
    //
    //   Registered
    //   WaitUnregisteredEvent
    //   CallbackStoppedEvent
    //   StartedUnregisteringEvent
    //   CompletedUnregisteringEvent
    //   Unregistering
    //   CallbackRunning
    //
    
    RtlZeroMemory(Task, sizeof(PFSVC_IDLE_TASK));

    Task->Initialized = TRUE;
}

DWORD
PfSvRegisterTask (
    PPFSVC_IDLE_TASK Task,
    IT_IDLE_TASK_ID TaskId,
    WAITORTIMERCALLBACK Callback,
    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction
    )

/*++

Routine Description:

    Registers the Callback to be called when it is the turn of this
    idle task to run. IFF this function returns success, you should
    call unregister function before calling the cleanup function.

Arguments:

    Task - Pointer to initialized task structure.

    TaskId - Idle task ID to register.

    Callback - We'll register a wait on the start event returned by
      idle task registration with this callback. The callback should 
      call start/stop task callback functions appropriately.

    DoWorkFunction - If the caller wants the common callback function
      to be used, then this function will be called to do the actual
      work in the common callback.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD ErrorCode;
    BOOL Success;
    BOOLEAN CreatedWaitUnregisteredEvent;
    BOOLEAN CreatedStartedUnregisteringEvent;
    BOOLEAN CreatedCompletedUnregisteringEvent;
    BOOLEAN CreatedCallbackStoppedEvent;
    BOOLEAN RegisteredIdleTask;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    CreatedWaitUnregisteredEvent = FALSE;
    CreatedStartedUnregisteringEvent = FALSE;
    CreatedCompletedUnregisteringEvent = FALSE;
    CreatedCallbackStoppedEvent = FALSE;

    DBGPR((PFID,PFTASK,"PFSVC: RegisterTask(%p,%d,%p,%p)\n",Task,TaskId,Callback,DoWorkFunction));

    //
    // The task should be initialized and not registered.
    //

    PFSVC_ASSERT(Task->Initialized);
    PFSVC_ASSERT(!Task->Registered);
    PFSVC_ASSERT(!Task->Unregistering);
    PFSVC_ASSERT(!Task->CallbackRunning);

    //
    // Create the event that cleanup waits on to make sure
    // the registered wait is fully unregistered.
    //

    Task->WaitUnregisteredEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->WaitUnregisteredEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedWaitUnregisteredEvent = TRUE;

    //
    // Create the event that will get signaled when we start
    // unregistering the task.
    //

    Task->StartedUnregisteringEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->StartedUnregisteringEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedStartedUnregisteringEvent = TRUE;

    //
    // Create the event that will get signaled when we complete
    // unregistering the task.
    //

    Task->CompletedUnregisteringEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->CompletedUnregisteringEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedCompletedUnregisteringEvent = TRUE;

    //
    // Create the event we may wait on for the current running
    // callback to go away.
    //

    Task->CallbackStoppedEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (Task->CallbackStoppedEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedCallbackStoppedEvent = TRUE;

    //
    // Register the idle task.
    //

    ErrorCode = RegisterIdleTask(TaskId,
                                 &Task->ItHandle,
                                 &Task->StartEvent,
                                 &Task->StopEvent);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    RegisteredIdleTask = TRUE;

    //
    // Register the callback: Note that once this call succeeds the task has to
    // be unregistered via PfSvUnregisterTask.
    //

    //
    // The callback might fire right away so note that we registered it and set
    // up its fields upfront.
    //

    // FUTURE-2002/03/29-ScottMa -- For consistency, the Task->Registered
    //   variable should be set to TRUE & FALSE instead of 0 & 1.

    Task->Registered = 1;
    Task->Callback = Callback;
    Task->DoWorkFunction = DoWorkFunction;

    //
    // If the common task callback was specified, a worker function should also
    // be specified.
    //

    if (Callback == PfSvCommonTaskCallback) {
        PFSVC_ASSERT(DoWorkFunction);
    }

    Success = RegisterWaitForSingleObject(&Task->WaitHandle,
                                          Task->StartEvent,
                                          Task->Callback,
                                          Task,
                                          INFINITE,
                                          WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION);

    if (!Success) {

        //
        // We failed to really register the task.
        //

        Task->Registered = 0;

        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;       

cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: RegisterTask(%p)=%x\n",Task,ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {

        if (CreatedWaitUnregisteredEvent) {
            CloseHandle(Task->WaitUnregisteredEvent);
            Task->WaitUnregisteredEvent = NULL;
        }

        if (CreatedStartedUnregisteringEvent) {
            CloseHandle(Task->StartedUnregisteringEvent);
            Task->StartedUnregisteringEvent = NULL;
        }

        if (CreatedCompletedUnregisteringEvent) {
            CloseHandle(Task->CompletedUnregisteringEvent);
            Task->CompletedUnregisteringEvent = NULL;
        }

        if (CreatedCallbackStoppedEvent) {
            CloseHandle(Task->CallbackStoppedEvent);
            Task->CallbackStoppedEvent = NULL;
        }
    
        if (RegisteredIdleTask) {
            UnregisterIdleTask(Task->ItHandle,
                               Task->StartEvent,
                               Task->StopEvent);

            Task->StartEvent = NULL;
            Task->StopEvent  = NULL;
        }
    }

    return ErrorCode;
}

DWORD
PfSvUnregisterTask (
    PPFSVC_IDLE_TASK Task,
    BOOLEAN CalledFromCallback
    )

/*++

Routine Description:

    Unregisters the idle task and the registered wait / callback. You should 
    call this function before calling the cleanup routine IFF the register
    function returned success.

Arguments:

    Task - Pointer to registered task.

    CalledFromCallback - Whether this function is being called from inside
      the queued callback of the task.
      
Return Value:

    Win32 error code.
    
--*/


{
    LONG OldValue;
    LONG NewValue;
    DWORD ErrorCode;

    DBGPR((PFID,PFTASK,"PFSVC: UnregisterTask(%p,%d)\n",Task,(DWORD)CalledFromCallback));

    //
    // The task should be initialized. It may already be unregistered.
    //

    PFSVC_ASSERT(Task->Initialized);

    if (Task->Registered == 0) {
        ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    //
    // Distinguish whether we are unregistering the task from a callback.
    //

    if (CalledFromCallback) {
        NewValue = PfSvcUnregisteringTaskFromCallback;
    } else {
        NewValue = PfSvcUnregisteringTaskFromMainThread;
    }

    //
    // Is this task already being unregistered?
    //

    OldValue = InterlockedCompareExchange(&Task->Unregistering,
                                          NewValue,
                                          PfSvcNotUnregisteringTask);

    if (OldValue != PfSvcNotUnregisteringTask) {

        ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    //
    // *We* will be unregistering the task. There is no turning back.
    //

    SetEvent(Task->StartedUnregisteringEvent);

    //
    // If we are not inside a callback, wait for no callbacks to be running
    // and cause new ones that start to bail out. We do this so we can safely
    // unregister the wait.
    //

    if (!CalledFromCallback) {

        do {
            OldValue = InterlockedCompareExchange(&Task->CallbackRunning,
                                                  PfSvcTaskCallbackDisabled,
                                                  PfSvcTaskCallbackNotRunning);

            if (OldValue == PfSvcTaskCallbackNotRunning) {

                //
                // We did it. No callbacks are running and new ones that try to
                // start will bail out.
                //

                PFSVC_ASSERT(Task->CallbackRunning == PfSvcTaskCallbackDisabled);

                break;
            }

            //
            // A callback might be active right now. It will see that we are unregistering and
            // go away. Sleep for a while and try again.
            //

            PFSVC_ASSERT(OldValue == PfSvcTaskCallbackRunning);

            //
            // We wait on this event with a timeout, because signaling of it is not
            // 100% reliable because it is not under a lock etc.
            //

            WaitForSingleObject(Task->CallbackStoppedEvent, 1000);

        } while (TRUE);

    } else {

        //
        // We already have control of this variable as the running callback: just
        // update it.
        //

        Task->CallbackRunning = PfSvcTaskCallbackDisabled;
    }

    //
    // Unregister the wait. Note that in cleanup we have to wait to for 
    // WaitUnregisteredEvent to be signaled.
    //

    UnregisterWaitEx(Task->WaitHandle, Task->WaitUnregisteredEvent);

    //
    // Unregister the idle task.
    //

    UnregisterIdleTask(Task->ItHandle,
                       Task->StartEvent,
                       Task->StopEvent);

    Task->StartEvent = NULL;
    Task->StopEvent  = NULL;
    //
    // Note that the task is no longer registered.
    //

    Task->Registered = FALSE;

    SetEvent(Task->CompletedUnregisteringEvent);

    ErrorCode = ERROR_SUCCESS;
    
cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: UnregisterTask(%p)=%x\n",Task,ErrorCode));

    return ErrorCode;
}

VOID
PfSvCleanupTask (
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Cleans up all fields of an unregistered task or a task that was never
    registered.

Arguments:

    Task - Pointer to task.

Return Value:

    None.
    
--*/
    
{
    //
    // The task should have been initialized.
    //

    PFSVC_ASSERT(Task->Initialized);
    
    //
    // If there is a WaitUnregisteredEvent, we have to wait on it
    // to make sure the unregister operation is fully complete.
    //

    if (Task->WaitUnregisteredEvent) {
        WaitForSingleObject(Task->WaitUnregisteredEvent, INFINITE);
        CloseHandle(Task->WaitUnregisteredEvent);
        Task->WaitUnregisteredEvent = NULL;
    }   

    //
    // If there is CompletedUnregisteringEvent, wait for it to
    // be signalled to make sure both that the wait is unregistered,
    // and the idle task is unregistered.
    //

    if (Task->CompletedUnregisteringEvent) {
        WaitForSingleObject(Task->CompletedUnregisteringEvent, INFINITE);
    }   

    //
    // The task should be unregistered before it is cleaned up.
    //

    PFSVC_ASSERT(Task->Registered == FALSE);

    //
    // Cleanup task unregistering events.
    //

    if (Task->StartedUnregisteringEvent) {
        CloseHandle(Task->StartedUnregisteringEvent);
        Task->StartedUnregisteringEvent = NULL;
    }

    if (Task->CompletedUnregisteringEvent) {
        CloseHandle(Task->CompletedUnregisteringEvent);
        Task->CompletedUnregisteringEvent = NULL;
    }

    //
    // Clean up callback stopped event.
    //

    if (Task->CallbackStoppedEvent) {
        CloseHandle(Task->CallbackStoppedEvent);
        Task->CallbackStoppedEvent = NULL;
    }

    Task->Initialized = FALSE;

    return;
}

BOOL
PfSvStartTaskCallback(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Callbacks registered via register task function should call this as the
    first thing. If this function returns FALSE, the callback should go away
    immediately without calling the stop-callback function.

Arguments:

    Task - Pointer to task.

Return Value:

    TRUE - Everything is cool.
    FALSE - The task is being unregistered. Exit the callback asap.
    
--*/

{
    BOOL ReturnValue;
    LONG OldValue;

    DBGPR((PFID,PFTASK,"PFSVC: StartTaskCallback(%p)\n",Task));

    //
    // We should not be called if the task is not initialized.
    //

    PFSVC_ASSERT(Task->Initialized);

    do {

        //
        // First check if we are trying to unregister.
        //

        if (Task->Unregistering) {
            ReturnValue = FALSE;
            goto cleanup;
        }

        //
        // Try to mark the callback running.
        //

        OldValue = InterlockedCompareExchange(&Task->CallbackRunning,
                                              PfSvcTaskCallbackRunning,
                                              PfSvcTaskCallbackNotRunning);

        if (OldValue == PfSvcTaskCallbackNotRunning) {

            //
            // We are the running callback now. Reset the event that says
            // the current callback stopped running.
            //

            ResetEvent(Task->CallbackStoppedEvent);

            ReturnValue = TRUE;
            goto cleanup;
        }

        //
        // Either another callback is running or we are unregistering.
        //

        //
        // Are we unregistering?
        //

        if (Task->Unregistering) {

            ReturnValue = FALSE;
            goto cleanup;

        } else {

            PFSVC_ASSERT(OldValue == PfSvcTaskCallbackRunning);
        }

        //
        // Sleep for a while and try again. There should not be much conflict in this 
        // code, so we should hardly ever need to sleep.
        //

        Sleep(15);
        
    } while (TRUE);

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);

cleanup:

    //
    // If we are starting a callback, the task should not be in unregistered state.
    //

    PFSVC_ASSERT(!ReturnValue || Task->Registered);

    DBGPR((PFID,PFTASK,"PFSVC: StartTaskCallback(%p)=%d\n",Task,ReturnValue));

    return ReturnValue;
}

VOID
PfSvStopTaskCallback(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Callbacks registered via register task function should call this as the
    last thing, only if they successfully called the start callback function and
    they did not unregister the task.

Arguments:

    Task - Pointer to task.

Return Value:

    None.
    
--*/

{
    DBGPR((PFID,PFTASK,"PFSVC: StopTaskCallback(%p)\n",Task));

    //
    // The task should be registered.
    //

    PFSVC_ASSERT(Task->Registered);

    //
    // There should be a running callback.
    //

    PFSVC_ASSERT(Task->CallbackRunning == PfSvcTaskCallbackRunning);

    Task->CallbackRunning = PfSvcTaskCallbackNotRunning;

    //
    // Signal the event the main thread may be waiting on to unregister
    // this task.
    //

    SetEvent(Task->CallbackStoppedEvent);

    return;
}

VOID 
CALLBACK 
PfSvCommonTaskCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    This is the callback for the idle tasks. It is called when the system is idle,
    and it is this tasks turn to run.

    Note that you cannot call PfSvCleanupTask from this thread, as it would cause
    a deadlock when that function waits for registered wait callbacks to exit.

Arguments:

    lpParameter - Pointer to task.

    TimerOrWaitFired - Whether the callback was initiated by a timeout or the start
      event getting signaled by the idle task service.

Return Value:

    None.
    
--*/

{
    HANDLE NewWaitHandle;
    PPFSVC_IDLE_TASK Task;
    BOOL StartedCallback;
    BOOL Success;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    Task = lpParameter;
    StartedCallback = FALSE;

    DBGPR((PFID,PFTASK,"PFSVC: CommonTaskCallback(%p)\n",Task));

    //
    // Enter task callback.
    //

    StartedCallback = PfSvStartTaskCallback(Task);

    if (!StartedCallback) {
        goto cleanup;
    }
    
    //
    // Do the task.
    //

    ErrorCode = Task->DoWorkFunction(Task);

    if (ErrorCode == ERROR_RETRY) {

        //
        // The stop event was signaled. We will queue another callback.
        //

        Success = RegisterWaitForSingleObject(&NewWaitHandle,
                                              Task->StartEvent,
                                              Task->Callback,
                                              Task,
                                              INFINITE,
                                              WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION);


        if (Success) {

            //
            // Unregister the current wait handle and update it.
            //

            UnregisterWaitEx(Task->WaitHandle, NULL);
            Task->WaitHandle = NewWaitHandle;

            goto cleanup;

        } else {

            //
            // We could not queue another callback. We will unregister, 
            // since we would not be able to respond to start signals
            // from the idle task service. Unregister may fail only if
            // the main thread is already trying to unregister.
            //

            ErrorCode = PfSvUnregisterTask(Task, TRUE);

            if (ErrorCode == ERROR_SUCCESS) {

                //
                // Since *we* unregistered, we should not call stop callback.
                //

                StartedCallback = FALSE;

            }

            goto cleanup;
        }

    } else {

        //
        // The task completed. Let's unregister.
        //

        ErrorCode = PfSvUnregisterTask(Task, TRUE);

        if (ErrorCode == ERROR_SUCCESS) {

            //
            // Since *we* unregistered, we should not call stop callback.
            //

            StartedCallback = FALSE;

        }

        goto cleanup;
    }

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);

cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: CommonTaskCallback(%p)=%x\n",Task,ErrorCode));

    if (StartedCallback) {
        PfSvStopTaskCallback(Task);
    }
}

DWORD
PfSvContinueRunningTask(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    This is called from a running task to determine if we should continue
    running this task. The task should continue running if ERROR_SUCCESS is
    returned. ERROR_RETRY may be returned if the task is unregistering or
    was asked to stop.

Arguments:

    Task - Pointer to task. If NULL, this parameter is ignored.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD WaitResult;
    DWORD ErrorCode;

    if (Task) {

        //
        // Is the task being unregistered?
        //

        if (Task->Unregistering) {
            ErrorCode = ERROR_RETRY;
            goto cleanup;
        }

        //
        // Is the stop event signaled? We don't really wait here since
        // the timeout is 0.
        //

        WaitResult = WaitForSingleObject(Task->StopEvent, 0);

        if (WaitResult == WAIT_OBJECT_0) {

            ErrorCode = ERROR_RETRY;
            goto cleanup;

        } else if (WaitResult != WAIT_TIMEOUT) {

            //
            // There was an error.
            //

            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // Check if the service is exiting...
    //

    if (PfSvcGlobals.TerminateServiceEvent) {

        WaitResult = WaitForSingleObject(PfSvcGlobals.TerminateServiceEvent, 0);

        if (WaitResult == WAIT_OBJECT_0) {

            ErrorCode = ERROR_RETRY;
            goto cleanup;

        } else if (WaitResult != WAIT_TIMEOUT) {

            //
            // There was an error.
            //

            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // The task should continue to run.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

//
// ProcessIdleTasks notify routine and its dependencies.
//

VOID
PfSvProcessIdleTasksCallback(
    VOID
    )

/*++

Routine Description:

    This is routine is registered with the idle task server as a notify
    routine that is called when processing of all idle tasks is requested.
    ProcessIdleTasks is usually called to prepare the system for a benchmark 
    run by performing the optimization tasks that would have been performed 
    when the system is idle.

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE Events[2];
    DWORD NumEvents;
    DWORD WaitResult;
    BOOLEAN ResetOverrideIdleEvent;

    //
    // First flush the idle tasks the prefetcher may have queued:
    //

    //
    // Determine the current status of the override-idle event.
    //

    WaitResult = WaitForSingleObject(PfSvcGlobals.OverrideIdleProcessingEvent,
                                     0);
    
    if (WaitResult != WAIT_OBJECT_0) {

        //
        // Override idle event is not already set. Set it and note to reset
        // it once tasks are completed. 
        //

        SetEvent(PfSvcGlobals.OverrideIdleProcessingEvent);
        ResetOverrideIdleEvent = TRUE;

    } else {

        ResetOverrideIdleEvent = FALSE;
    }

    //
    // Wait for processing complete event to get signaled.
    //

    Events[0] = PfSvcGlobals.ProcessingCompleteEvent;
    Events[1] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 2;

    WaitForMultipleObjects(NumEvents, Events, FALSE, 30 * 60 * 1000);

    //
    // If we set the override idle event, reset it.
    //

    if (ResetOverrideIdleEvent) {
        ResetEvent(PfSvcGlobals.OverrideIdleProcessingEvent);
    }
    
    //
    // Force an update of the disk layout in case it did not happen.
    // If we notice no changes we will not launch the defragger again.
    //

    PfSvUpdateOptimalLayout(NULL);

    //
    // Signal WMI to complete its idle tasks if it has pending tasks.
    //

    PfSvForceWMIProcessIdleTasks();

    return;
}

DWORD
PfSvForceWMIProcessIdleTasks(
    VOID
    )

/*++

Routine Description:

    This is routine is called to force WMI to process all of its idle tasks.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    HANDLE StartEvent;
    HANDLE DoneEvent;
    HANDLE Events[2];
    DWORD NumEvents;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOL Success;

    //
    // Initialize locals.
    //

    StartEvent = NULL;
    DoneEvent = NULL;

    //
    // Wait until WMI service is started.
    //

    Success = PfSvWaitForServiceToStart(L"WINMGMT", 5 * 60 * 1000);

    if (!Success) {
        ErrorCode = ERROR_SERVICE_NEVER_STARTED;
        goto cleanup;
    }

    //
    // Open the start and done events.
    //

    StartEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, L"WMI_ProcessIdleTasksStart");
    DoneEvent =  OpenEvent(EVENT_ALL_ACCESS, FALSE, L"WMI_ProcessIdleTasksComplete");

    if (!StartEvent || !DoneEvent) {
        ErrorCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // Reset the done event.
    //

    ResetEvent(DoneEvent);

    //
    // Signal the start event.
    //

    SetEvent(StartEvent);

    //
    // Wait for the done event to be signaled.
    //

    Events[0] = DoneEvent;
    Events[1] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 2;

    WaitResult = WaitForMultipleObjects(NumEvents, Events, FALSE, 25 * 60 * 1000);

    switch(WaitResult) {
    case WAIT_OBJECT_0     : ErrorCode = ERROR_SUCCESS; break;
    case WAIT_OBJECT_0 + 1 : ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS; break;
    case WAIT_FAILED       : ErrorCode = GetLastError(); break;
    case WAIT_TIMEOUT      : ErrorCode = WAIT_TIMEOUT; break;
    default                : ErrorCode = ERROR_INVALID_FUNCTION;
    }

    //
    // Fall through with error code.
    //

  cleanup:

    if (StartEvent) {
        CloseHandle(StartEvent);
    }

    if (DoneEvent) {
        CloseHandle(DoneEvent);
    }

    return ErrorCode;
}

BOOL 
PfSvWaitForServiceToStart (
    WCHAR *lpServiceName, 
    DWORD dwMaxWait
    )

/*++

Routine Description:

    Waits for the service to start.

Arguments:

    lpServiceName - Service to wait for.

    dwMaxWait - Timeout in ms.

Return Value:

    Whether the service was started.

--*/

{
    BOOL bStarted = FALSE;
    DWORD dwSize = 512;
    DWORD StartTickCount;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;

    //
    // OpenSCManager and the service.
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }

    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }

    //
    // Query if the service is going to start
    //
    lpServiceConfig = LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }

    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }

        LocalFree (lpServiceConfig);

        lpServiceConfig = LocalAlloc (LPTR, dwSize);

        if (!lpServiceConfig) {
            goto Exit;
        }

        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }

    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }

    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //

    StartTickCount = GetTickCount();

    while (!bStarted) {

        if (WAIT_OBJECT_0 == WaitForSingleObject(PfSvcGlobals.TerminateServiceEvent, 0)) {
            break;
        }

        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(500);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

            bStarted = TRUE;

        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(500);
        } else {
            Sleep(500);
        }
    }

Exit:

    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hScManager) {
        CloseServiceHandle(hScManager);
    }

    return bStarted;
}

//
// Wrappers around the verify routines.
//

BOOLEAN
PfSvVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    This wrapper arounding PfVerifyScenarioBuffer traps exceptions such as in-page errors that
    may happen when the system is under stress. Otherwise these non-fatal failures may take
    down a service-host full of important system services.
    
Arguments:

    See PfVerifyScenarioBuffer.
    
Return Value:

    See PfVerifyScenarioBuffer.

--*/

{
    BOOLEAN Success;
    
    __try {

        Success = PfVerifyScenarioBuffer(Scenario, BufferSize, FailedCheck);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // We should not be masking other types of exceptions.
        //

        PFSVC_ASSERT(GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR);

        Success = FALSE;
        *FailedCheck = (ULONG) GetExceptionCode();
        
    }

    return Success;
    
}

ULONG
PfVerifyImageImportTable (
    IN PVOID BaseAddress,
    IN ULONG MappingSize,
    IN BOOLEAN MappedAsImage
    )

/*++

Routine Description:

    This function tries to verify that walking the imports table of 
    the mapped base portion of an image file won't result in accesses beyond 
    the mapped region. 

    This includes checks to make sure DOS & NT header magics match and
    they are within bounds and that strings in all import table descriptors 
    are NUL terminated etc.

Arguments:

    BaseAddress - Pointer to base of the mapping of the image file.

    MappingSize - Size in bytes of the mapping starting at BaseAddress.

    MappedAsImage - Whether the image is mapping as image or as file.

Return Value:

    0 - It is safe to walk the imports of the image mapped as data.
    Non 0 - It is not safe to walk the imports of the image mapped as data.
      Returned value is the ID of the check failed.

--*/

{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER NtSection;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    PIMAGE_IMPORT_DESCRIPTOR FirstImportDescriptor;
    PCHAR ImportedModuleName;
    ULONG ImportDescriptorRVA;
    ULONG ImportedModuleNameLength;
    ULONG FailedCheckId;
    BOOLEAN Success;

    //
    // Initialize locals.
    //

    FailedCheckId = 1;

    //
    // Is the mapping big enough to contain the DOS header?
    //

    if (MappingSize <= sizeof(IMAGE_DOS_HEADER)) {
        FailedCheckId = 10;
        goto cleanup;
    }

    DosHeader = BaseAddress;

    //
    // Check DOS signature and sanity check where it says NT headers are.
    // The checked size is the same constant used in RtlpImageNtHeader.
    //

    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE ||
        DosHeader->e_lfanew >= 256 * 1024 * 1024) {

        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // Is the NtHeaders within the bounds of mapping?
    //

    NtHeaders = (PIMAGE_NT_HEADERS) ((PUCHAR)BaseAddress + DosHeader->e_lfanew);

    if(!PfWithinBounds(NtHeaders, BaseAddress, MappingSize)) {
        FailedCheckId = 30;
        goto cleanup;
    }

    //
    // Is the full NtHeaders within the bounds of mapping?
    //

    if(!PfWithinBounds(NtHeaders + 1, BaseAddress, MappingSize)) {
        FailedCheckId = 40;
        goto cleanup;
    }

    //
    // Check NT signature.
    //

    if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        FailedCheckId = 50;
        goto cleanup;
    }

    //
    // Check the optional header size in file header.
    //

    if (NtHeaders->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) {
        FailedCheckId = 60;
        goto cleanup;
    }

    OptionalHeader = &NtHeaders->OptionalHeader;

    //
    // Check the optional header magic.
    //

    if (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        FailedCheckId = 70;
        goto cleanup;
    }

    //
    // Verify that the section headers are within the mapped region, since
    // they will be used to translate RVAs to VAs.
    //

    NtSection = IMAGE_FIRST_SECTION(NtHeaders);

    if(!PfWithinBounds(NtSection, BaseAddress, MappingSize)) {
        FailedCheckId = 80;
        goto cleanup;
    }

    if(!PfWithinBounds(NtSection + NtHeaders->FileHeader.NumberOfSections, 
                       BaseAddress, 
                       MappingSize)) {
        FailedCheckId = 90;
        goto cleanup;
    }
    
    //
    // Verify that the import descriptors are within bounds.
    //

    ImportDescriptorRVA = OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    if (MappedAsImage) {
        ImportDescriptor = (PVOID) ((PUCHAR) BaseAddress + ImportDescriptorRVA);
    } else {
        ImportDescriptor = ImageRvaToVa(NtHeaders, BaseAddress, ImportDescriptorRVA, NULL);
    }

    FirstImportDescriptor = ImportDescriptor;

    //
    // Make sure that the first import descriptor is fully within bounds.
    //

    if (!PfWithinBounds(ImportDescriptor, BaseAddress, MappingSize)) {
        FailedCheckId = 100;
        goto cleanup;
    }

    if (!PfWithinBounds(((PCHAR)(ImportDescriptor + 1)) - 1, BaseAddress, MappingSize)) {
        FailedCheckId = 100;
        goto cleanup;
    }

    while (ImportDescriptor->Name && ImportDescriptor->FirstThunk) {

        //
        // Is the first thunk within bounds?
        //

        if (!PfWithinBounds((PUCHAR)BaseAddress + ImportDescriptor->FirstThunk, 
                            BaseAddress, 
                            MappingSize)) {

            FailedCheckId = 110;
            goto cleanup;
        }

        //
        // Is the Name within bounds?
        //

        if (MappedAsImage) {
            ImportedModuleName = (PCHAR) BaseAddress + ImportDescriptor->Name;
        } else {
            ImportedModuleName = ImageRvaToVa(NtHeaders, BaseAddress, ImportDescriptor->Name, NULL);
        }

        //
        // Is the first character within bounds?
        //

        if (!PfWithinBounds(ImportedModuleName, BaseAddress, MappingSize)) {
            FailedCheckId = 120;
            goto cleanup;
        }

        ImportedModuleNameLength = 0;

        while (*ImportedModuleName) {

            ImportedModuleName++;
            ImportedModuleNameLength++;

            //
            // If the import name is too long bail out.
            //

            if (ImportedModuleNameLength >= MAX_PATH) {
                FailedCheckId = 130;
                goto cleanup;
            }

            //
            // Check the next character before accessing it.
            //

            if (!PfWithinBounds(ImportedModuleName, BaseAddress, MappingSize)) {
                FailedCheckId = 140;
                goto cleanup;
            }
        }

        ImportDescriptor++;

        //
        // Make sure that the next import descriptor is fully within bounds
        // before we access its fields in the while loop condition check.
        //

        if (!PfWithinBounds(((PCHAR)(ImportDescriptor + 1)) - 1, BaseAddress, MappingSize)) {
            FailedCheckId = 150;
            goto cleanup;
        }
    }

    //
    // We passed all the checks.
    //

    FailedCheckId = 0;

  cleanup:

    return FailedCheckId;
}

//
// Try to keep the verification code below at the end of the file so it is 
// easier to copy.
//

//
// Verification code shared between the kernel and user mode
// components. This code should be kept in sync with a simple copy &
// paste, so don't add any kernel/user specific code/macros. Note that
// the prefix on the function names are Pf, just like it is with
// shared structures / constants.
//

BOOLEAN
__forceinline
PfWithinBounds(
    PVOID Pointer,
    PVOID Base,
    ULONG Length
    )

/*++

Routine Description:

    Check whether the pointer is within Length bytes from the base.

Arguments:

    Pointer - Pointer to check.

    Base - Pointer to base of mapping/array etc.

    Length - Number of bytes that are valid starting from Base.

Return Value:

    TRUE - Pointer is within bounds.
    
    FALSE - Pointer is not within bounds.

--*/

{
    if (((PCHAR)Pointer < (PCHAR)Base) ||
        ((PCHAR)Pointer >= ((PCHAR)Base + Length))) {

        return FALSE;
    } else {

        return TRUE;
    }
}

BOOLEAN
PfVerifyScenarioId (
    PPF_SCENARIO_ID ScenarioId
    )

/*++

Routine Description:

    Verify that the scenario id is sensible.

Arguments:

    ScenarioId - Scenario Id to verify.

Return Value:

    TRUE - ScenarioId is fine.
    FALSE - ScenarioId is corrupt.

--*/
    
{
    LONG CurCharIdx;

    //
    // Make sure the scenario name is NUL terminated.
    //

    for (CurCharIdx = PF_SCEN_ID_MAX_CHARS; CurCharIdx >= 0; CurCharIdx--) {

        if (ScenarioId->ScenName[CurCharIdx] == 0) {
            break;
        }
    }

    if (ScenarioId->ScenName[CurCharIdx] != 0) {
        return FALSE;
    }

    //
    // Make sure there is a scenario name.
    //

    if (CurCharIdx == 0) {
        return FALSE;
    }

    //
    // Checks passed.
    //
    
    return TRUE;
}

// ISSUE-2002/03/29-ScottMa -- FilePaths and VolumePaths must be upcased in
//   the scenario file, or subsequent comparisons will fail.  Verify the case
//   of the embedded names in this function.

BOOLEAN
PfVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    Verify offset and indices in a scenario file are not beyond
    bounds. This code is shared between the user mode service and
    kernel mode component. If you update this function, update it in
    both.

Arguments:

    Scenario - Base of mapped view of the whole file.

    BufferSize - Size of the scenario buffer.

    FailedCheck - If verify failed, Id for the check that was failed.

Return Value:

    TRUE - Scenario is fine.
    FALSE - Scenario is corrupt.

--*/

{
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD pSection;
    ULONG SectionIdx;
    PPF_PAGE_RECORD Pages;
    PPF_PAGE_RECORD pPage;
    LONG PageIdx;   
    PCHAR FileNames;
    PCHAR pFileNameStart;
    PCHAR pFileNameEnd;
    PWCHAR pwFileName;
    LONG FailedCheckId;
    ULONG NumRemainingPages;
    ULONG NumPages;
    LONG PreviousPageIdx;
    ULONG FileNameSize;
    BOOLEAN ScenarioVerified;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    PWCHAR VolumePath;
    PFILE_PREFETCH FilePrefetchInfo;
    ULONG FilePrefetchInfoSize;
    PPF_COUNTED_STRING DirectoryPath;
    ULONG DirectoryIdx;

    //
    // Initialize locals.
    //

    FailedCheckId = 0;
        
    //
    // Initialize return value to FALSE. It will be set to TRUE only
    // after all the checks pass.
    //
    
    ScenarioVerified = FALSE;

    //
    // The buffer should at least contain the scenario header.
    //

    if (BufferSize < sizeof(PF_SCENARIO_HEADER)) {       
        FailedCheckId = 10;
        goto cleanup;
    }

    if ((ULONG_PTR)Scenario & (_alignof(PF_SCENARIO_HEADER) - 1)) {
        FailedCheckId = 15;
        goto cleanup;
    }

    //
    // Check version and magic on the header.
    //

    if (Scenario->Version != PF_CURRENT_VERSION ||
        Scenario->MagicNumber != PF_SCENARIO_MAGIC_NUMBER) { 

        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // The buffer should not be greater than max allowed size.
    //

    if (BufferSize > PF_MAXIMUM_SCENARIO_SIZE) {
        
        FailedCheckId = 25;
        goto cleanup;
    }

    if (BufferSize != Scenario->Size) {
        FailedCheckId = 26;
        goto cleanup;
    }
        
    //
    // Check for legal scenario type.
    //

    if (Scenario->ScenarioType < 0 || Scenario->ScenarioType >= PfMaxScenarioType) {
        FailedCheckId = 27;
        goto cleanup;
    }

    //
    // Check limits on number of pages, sections etc.
    //

    if (Scenario->NumSections > PF_MAXIMUM_SECTIONS ||
        Scenario->NumMetadataRecords > PF_MAXIMUM_SECTIONS ||
        Scenario->NumPages > PF_MAXIMUM_PAGES ||
        Scenario->FileNameInfoSize > PF_MAXIMUM_FILE_NAME_DATA_SIZE) {
        
        FailedCheckId = 30;
        goto cleanup;
    }

    if (Scenario->NumSections == 0 ||
        Scenario->NumPages == 0 ||
        Scenario->FileNameInfoSize == 0) {
        
        FailedCheckId = 33;
        goto cleanup;
    }
    
    //
    // Check limit on sensitivity.
    //

    if (Scenario->Sensitivity < PF_MIN_SENSITIVITY ||
        Scenario->Sensitivity > PF_MAX_SENSITIVITY) {
        
        FailedCheckId = 35;
        goto cleanup;
    }

    //
    // Make sure the scenario id is valid.
    //

    if (!PfVerifyScenarioId(&Scenario->ScenarioId)) {
        
        FailedCheckId = 37;
        goto cleanup;
    }

    //
    // Initialize pointers to tables.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);

    if ((ULONG_PTR)Sections & (_alignof(PF_SECTION_RECORD) - 1)) {
        FailedCheckId = 38;
        goto cleanup;
    }
       
    if (!PfWithinBounds(Sections, Scenario, BufferSize)) {
        FailedCheckId = 40;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR) &Sections[Scenario->NumSections] - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 45;
        goto cleanup;
    }   

    Pages = (PPF_PAGE_RECORD) ((PCHAR)Scenario + Scenario->PageInfoOffset);

    if ((ULONG_PTR)Pages & (_alignof(PF_PAGE_RECORD) - 1)) {
        FailedCheckId = 47;
        goto cleanup;
    }
       
    if (!PfWithinBounds(Pages, Scenario, BufferSize)) {
        FailedCheckId = 50;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR) &Pages[Scenario->NumPages] - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 55;
        goto cleanup;
    }

    FileNames = (PCHAR)Scenario + Scenario->FileNameInfoOffset;

    if ((ULONG_PTR)FileNames & (_alignof(WCHAR) - 1)) {
        FailedCheckId = 57;
        goto cleanup;
    }
      
    if (!PfWithinBounds(FileNames, Scenario, BufferSize)) {
        FailedCheckId = 60;
        goto cleanup;
    }

    if (!PfWithinBounds(FileNames + Scenario->FileNameInfoSize - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 70;
        goto cleanup;
    }

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    if ((ULONG_PTR)MetadataRecordTable & (_alignof(PF_METADATA_RECORD) - 1)) {
        FailedCheckId = 72;
        goto cleanup;
    }

    if (!PfWithinBounds(MetadataInfoBase, Scenario, BufferSize)) {
        FailedCheckId = 73;
        goto cleanup;
    }

    if (!PfWithinBounds(MetadataInfoBase + Scenario->MetadataInfoSize - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 74;
        goto cleanup;
    }   

    if (!PfWithinBounds(((PCHAR) &MetadataRecordTable[Scenario->NumMetadataRecords]) - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 75;
        goto cleanup;
    }   
    
    //
    // Verify that sections contain valid information.
    //

    NumRemainingPages = Scenario->NumPages;

    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {
        
        pSection = &Sections[SectionIdx];

        //
        // Check if file name is within bounds. 
        //

        pFileNameStart = FileNames + pSection->FileNameOffset;

        if ((ULONG_PTR)pFileNameStart & (_alignof(WCHAR) - 1)) {
            FailedCheckId = 77;
            goto cleanup;
        }


        if (!PfWithinBounds(pFileNameStart, Scenario, BufferSize)) {
            FailedCheckId = 80;
            goto cleanup;
        }

        //
        // Make sure there is a valid sized file name. 
        //

        if (pSection->FileNameLength == 0) {
            FailedCheckId = 90;
            goto cleanup;    
        }

        //
        // Check file name max length.
        //

        if (pSection->FileNameLength > PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
            FailedCheckId = 100;
            goto cleanup;    
        }

        //
        // Note that pFileNameEnd gets a -1 so it is the address of
        // the last byte.
        //

        FileNameSize = (pSection->FileNameLength + 1) * sizeof(WCHAR);
        pFileNameEnd = pFileNameStart + FileNameSize - 1;

        if (!PfWithinBounds(pFileNameEnd, Scenario, BufferSize)) {
            FailedCheckId = 110;
            goto cleanup;
        }

        //
        // Check if the file name is NUL terminated.
        //
        
        pwFileName = (PWCHAR) pFileNameStart;
        
        if (pwFileName[pSection->FileNameLength] != 0) {
            FailedCheckId = 120;
            goto cleanup;
        }

        //
        // Check max number of pages in a section.
        //

        if (pSection->NumPages > PF_MAXIMUM_SECTION_PAGES) {
            FailedCheckId = 140;
            goto cleanup;    
        }

        //
        // Make sure NumPages for the section is at least less
        // than the remaining pages in the scenario. Then update the
        // remaining pages.
        //

        if (pSection->NumPages > NumRemainingPages) {
            FailedCheckId = 150;
            goto cleanup;
        }

        NumRemainingPages -= pSection->NumPages;

        //
        // Verify that there are NumPages pages in our page list and
        // they are sorted by file offset.
        //

        PageIdx = pSection->FirstPageIdx;
        NumPages = 0;
        PreviousPageIdx = PF_INVALID_PAGE_IDX;

        while (PageIdx != PF_INVALID_PAGE_IDX) {
            
            //
            // Check that page idx is within range.
            //
            
            if (PageIdx < 0 || (ULONG) PageIdx >= Scenario->NumPages) {
                FailedCheckId = 160;
                goto cleanup;
            }

            //
            // If this is not the first page record, make sure it
            // comes after the previous one. We also check for
            // duplicate offset here.
            //

            if (PreviousPageIdx != PF_INVALID_PAGE_IDX) {
                if (Pages[PageIdx].FileOffset <= 
                    Pages[PreviousPageIdx].FileOffset) {

                    FailedCheckId = 165;
                    goto cleanup;
                }
            }

            //
            // Update the last page index.
            //

            PreviousPageIdx = PageIdx;

            //
            // Get the next page index.
            //

            pPage = &Pages[PageIdx];
            PageIdx = pPage->NextPageIdx;
            
            //
            // Update the number of pages we've seen on the list so
            // far. If it is greater than what there should be on the
            // list we have a problem. We may have even hit a list.
            //

            NumPages++;
            if (NumPages > pSection->NumPages) {
                FailedCheckId = 170;
                goto cleanup;
            }
        }
        
        //
        // Make sure the section has exactly the number of pages it
        // says it does.
        //

        if (NumPages != pSection->NumPages) {
            FailedCheckId = 180;
            goto cleanup;
        }
    }

    //
    // We should have accounted for all pages in the scenario.
    //

    if (NumRemainingPages) {
        FailedCheckId = 190;
        goto cleanup;
    }

    //
    // Make sure metadata prefetch records make sense.
    //

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        
        //
        // Make sure that the volume path is within bounds and NUL
        // terminated.
        //

        VolumePath = (PWCHAR)(MetadataInfoBase + MetadataRecord->VolumeNameOffset);  

        if ((ULONG_PTR)VolumePath & (_alignof(WCHAR) - 1)) {
            FailedCheckId = 195;
            goto cleanup;
        }
       
        if (!PfWithinBounds(VolumePath, Scenario, BufferSize)) {
            FailedCheckId = 200;
            goto cleanup;
        }

        if (!PfWithinBounds(((PCHAR)(VolumePath + MetadataRecord->VolumeNameLength + 1)) - 1, 
                            Scenario, 
                            BufferSize)) {
            FailedCheckId = 210;
            goto cleanup;
        }

        if (VolumePath[MetadataRecord->VolumeNameLength] != 0) {
            FailedCheckId = 220;
            goto cleanup;           
        }

        //
        // Make sure that FilePrefetchInformation is within bounds.
        //

        FilePrefetchInfo = (PFILE_PREFETCH) 
            (MetadataInfoBase + MetadataRecord->FilePrefetchInfoOffset);

        if ((ULONG_PTR)FilePrefetchInfo & (_alignof(FILE_PREFETCH) - 1)) {
            FailedCheckId = 225;
            goto cleanup;
        }
        
        if (!PfWithinBounds(FilePrefetchInfo, Scenario, BufferSize)) {
            FailedCheckId = 230;
            goto cleanup;
        }

        //
        // Its size should be greater than size of a FILE_PREFETCH
        // structure (so we can safely access the fields).
        //

        if (MetadataRecord->FilePrefetchInfoSize < sizeof(FILE_PREFETCH)) {
            FailedCheckId = 240;
            goto cleanup;
        }

        if (!PfWithinBounds((PCHAR)FilePrefetchInfo + MetadataRecord->FilePrefetchInfoSize - 1, 
                            Scenario, 
                            BufferSize)) {
            FailedCheckId = 245;
            goto cleanup;
        }
       
        //
        // It should be for prefetching file creates.
        //

        if (FilePrefetchInfo->Type != FILE_PREFETCH_TYPE_FOR_CREATE) {
            FailedCheckId = 250;
            goto cleanup;
        }

        //
        // There should not be more entries then are files and
        // directories. The number of inidividual directories may be
        // more than what we allow for, but it would be highly rare to
        // be suspicious and thus ignored.
        //

        if (FilePrefetchInfo->Count > PF_MAXIMUM_DIRECTORIES + PF_MAXIMUM_SECTIONS) {
            FailedCheckId = 260;
            goto cleanup;
        }

        //
        // Its size should match the size calculated by number of file
        // index numbers specified in the header.
        //

        FilePrefetchInfoSize = sizeof(FILE_PREFETCH);
        if (FilePrefetchInfo->Count) {
            FilePrefetchInfoSize += (FilePrefetchInfo->Count - 1) * sizeof(ULONGLONG);
        }

        if (FilePrefetchInfoSize != MetadataRecord->FilePrefetchInfoSize) {
            FailedCheckId = 270;
            goto cleanup;
        }

        //
        // Make sure that the directory paths for this volume make
        // sense.
        //

        if (MetadataRecord->NumDirectories > PF_MAXIMUM_DIRECTORIES) {
            FailedCheckId = 280;
            goto cleanup;
        }

        DirectoryPath = (PPF_COUNTED_STRING) 
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);

        if ((ULONG_PTR)DirectoryPath & (_alignof(PF_COUNTED_STRING) - 1)) {
            FailedCheckId = 283;
            goto cleanup;
        }
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx ++) {
            
            //
            // Make sure head of the structure is within bounds.
            //

            if (!PfWithinBounds(DirectoryPath, Scenario, BufferSize)) {
                FailedCheckId = 285;
                goto cleanup;
            }
        
            if (!PfWithinBounds((PCHAR)DirectoryPath + sizeof(PF_COUNTED_STRING) - 1, 
                                Scenario, 
                                BufferSize)) {
                FailedCheckId = 290;
                goto cleanup;
            }
                
            //
            // Check the length of the string.
            //
            
            if (DirectoryPath->Length >= PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
                FailedCheckId = 300;
                goto cleanup;
            }

            //
            // Make sure end of the string is within bounds.
            //
            
            if (!PfWithinBounds((PCHAR)(&DirectoryPath->String[DirectoryPath->Length + 1]) - 1,
                                Scenario, 
                                BufferSize)) {
                FailedCheckId = 310;
                goto cleanup;
            }
            
            //
            // Make sure the string is NUL terminated.
            //
            
            if (DirectoryPath->String[DirectoryPath->Length] != 0) {
                FailedCheckId = 320;
                goto cleanup;   
            }
            
            //
            // Set pointer to next DirectoryPath.
            //
            
            DirectoryPath = (PPF_COUNTED_STRING) 
                (&DirectoryPath->String[DirectoryPath->Length + 1]);
        }            
    }

    //
    // We've passed all the checks.
    //

    ScenarioVerified = TRUE;

 cleanup:

    *FailedCheck = FailedCheckId;

    return ScenarioVerified;
}

BOOLEAN
PfVerifyTraceBuffer(
    PPF_TRACE_HEADER Trace,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    Verify offset and indices in a trace buffer are not beyond
    bounds. This code is shared between the user mode service and
    kernel mode component. If you update this function, update it in
    both.

Arguments:

    Trace - Base of Trace buffer.

    BufferSize - Size of the scenario file / mapping.

    FailedCheck - If verify failed, Id for the check that was failed.

Return Value:

    TRUE - Trace is fine.
    FALSE - Trace is corrupt;

--*/

{
    LONG FailedCheckId;
    PPF_LOG_ENTRY LogEntries;
    PPF_SECTION_INFO Section;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG SectionLength;
    ULONG EntryIdx;
    ULONG SectionIdx;
    ULONG TotalFaults;
    ULONG PeriodIdx;
    ULONG VolumeIdx;
    BOOLEAN TraceVerified;
    ULONG VolumeInfoSize;

    //
    // Initialize locals:
    //

    FailedCheckId = 0;

    //
    // Initialize return value to FALSE. It will be set to TRUE only
    // after all the checks pass.
    //

    TraceVerified = FALSE;

    //
    // The buffer should at least contain the scenario header.
    //

    if (BufferSize < sizeof(PF_TRACE_HEADER)) {
        FailedCheckId = 10;
        goto cleanup;
    }

    //
    // Check trace header alignment.
    //

    if ((ULONG_PTR)Trace & (_alignof(PF_TRACE_HEADER) - 1)) {
        FailedCheckId = 15;
        goto cleanup;
    }

    //
    // Check version and magic on the header.
    //

    if (Trace->Version != PF_CURRENT_VERSION ||
        Trace->MagicNumber != PF_TRACE_MAGIC_NUMBER) {
        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // The buffer should not be greater than max allowed size.
    //

    if (BufferSize > PF_MAXIMUM_TRACE_SIZE) {
        FailedCheckId = 23;
        goto cleanup;
    }

    //
    // Check for legal scenario type.
    //

    if (Trace->ScenarioType < 0 || Trace->ScenarioType >= PfMaxScenarioType) {
        FailedCheckId = 25;
        goto cleanup;
    }

    //
    // Check limits on number of pages, sections etc.
    //

    if (Trace->NumSections > PF_MAXIMUM_SECTIONS ||
        Trace->NumEntries > PF_MAXIMUM_LOG_ENTRIES ||
        Trace->NumVolumes > PF_MAXIMUM_SECTIONS) {
        FailedCheckId = 30;
        goto cleanup;
    }

    //
    // Check buffer size and the size of the trace.
    //

    if (Trace->Size != BufferSize) {
        FailedCheckId = 35;
        goto cleanup;
    }

    //
    // Make sure the scenario id is valid.
    //

    if (!PfVerifyScenarioId(&Trace->ScenarioId)) {
        
        FailedCheckId = 37;
        goto cleanup;
    }

    //
    // Check Bounds of Trace Buffer
    //

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);

    if ((ULONG_PTR)LogEntries & (_alignof(PF_LOG_ENTRY) - 1)) {
        FailedCheckId = 38;
        goto cleanup;
    }

    if (!PfWithinBounds(LogEntries, Trace, BufferSize)) {
        FailedCheckId = 40;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR)&LogEntries[Trace->NumEntries] - 1, 
                        Trace, 
                        BufferSize)) {
        FailedCheckId = 50;
        goto cleanup;
    }

    //
    // Verify pages contain valid information.
    //

    for (EntryIdx = 0; EntryIdx < Trace->NumEntries; EntryIdx++) {

        //
        // Make sure sequence number is within bounds.
        //

        if (LogEntries[EntryIdx].SectionId >= Trace->NumSections) {
            FailedCheckId = 60;
            goto cleanup;
        }
    }

    //
    // Verify section info entries are valid.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    if ((ULONG_PTR)Section & (_alignof(PF_SECTION_INFO) - 1)) {
        FailedCheckId = 65;
        goto cleanup;
    }

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Make sure the section is within bounds.
        //

        if (!PfWithinBounds(Section, Trace, BufferSize)) {
            FailedCheckId = 70;
            goto cleanup;
        }

        if (!PfWithinBounds((PCHAR)Section + sizeof(PF_SECTION_INFO) - 1, 
                            Trace, 
                            BufferSize)) {
            FailedCheckId = 75;
            goto cleanup;
        }

        //
        // Make sure the file name is not too big.
        //

        if(Section->FileNameLength > PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
            FailedCheckId = 80;
            goto cleanup;
        }
        
        //
        // Calculate size of this section entry.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        //
        // Make sure all of the data in the section info is within
        // bounds.
        //

        if (!PfWithinBounds((PUCHAR)Section + SectionLength - 1, 
                            Trace, 
                            BufferSize)) {

            FailedCheckId = 90;
            goto cleanup;
        }

        //
        // Make sure the file name is NUL terminated.
        //
        
        if (Section->FileName[Section->FileNameLength] != 0) {
            FailedCheckId = 100;
            goto cleanup;
        }

        //
        // Set pointer to next section.
        //

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Check FaultsPerPeriod information.
    //

    TotalFaults = 0;

    for (PeriodIdx = 0; PeriodIdx < PF_MAX_NUM_TRACE_PERIODS; PeriodIdx++) {
        TotalFaults += Trace->FaultsPerPeriod[PeriodIdx];
    }

    if (TotalFaults != Trace->NumEntries) {
        FailedCheckId = 120;
        goto cleanup;
    }

    //
    // Verify the volume information block.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    if ((ULONG_PTR)VolumeInfo & (_alignof(PF_VOLUME_INFO) - 1)) {
        FailedCheckId = 125;
        goto cleanup;
    }

    if (!PfWithinBounds(VolumeInfo, Trace, BufferSize)) {
        FailedCheckId = 130;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR)VolumeInfo + Trace->VolumeInfoSize - 1, 
                        Trace, 
                        BufferSize)) {
        FailedCheckId = 140;
        goto cleanup;
    }
    
    //
    // If there are sections, we should have at least one volume.
    //

    if (Trace->NumSections && !Trace->NumVolumes) {
        FailedCheckId = 150;
        goto cleanup;
    }

    //
    // Verify the volume info structures per volume.
    //

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {
        
        //
        // Make sure the whole volume structure is within bounds. Note
        // that VolumeInfo structure contains space for the
        // terminating NUL.
        //

        if (!PfWithinBounds(VolumeInfo, Trace, BufferSize)) {
            FailedCheckId = 155;
            goto cleanup;
        }

        if (!PfWithinBounds((PCHAR) VolumeInfo + sizeof(PF_VOLUME_INFO) - 1,
                            Trace,
                            BufferSize)) {
            FailedCheckId = 160;
            goto cleanup;
        }
        
        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);
        
        if (!PfWithinBounds((PCHAR) VolumeInfo + VolumeInfoSize - 1,
                            Trace,
                            BufferSize)) {
            FailedCheckId = 165;
            goto cleanup;
        }
        
        //
        // Verify that the volume path string is terminated.
        //

        if (VolumeInfo->VolumePath[VolumeInfo->VolumePathLength] != 0) {
            FailedCheckId = 170;
            goto cleanup;
        }
        
        //
        // Get the next volume.
        //

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // We've passed all the checks.
    //
    
    TraceVerified = TRUE;
    
 cleanup:

    *FailedCheck = FailedCheckId;

    return TraceVerified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\test\pfapp\pfapp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfapp.c

Abstract:

    This module builds a console test program that can be launched
    to test/stress the application launch prefetcher.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

DWORD
PfAppGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    )

/*++

Routine Description:

    Map the all of the specified file to memory.

Arguments:

    FilePath - NUL terminated path to file to map.
    
    BasePointer - Start address of mapping will be returned here.

    FileSize - Size of the mapping/file will be returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE InputHandle;
    HANDLE InputMappingHandle;
    DWORD ErrorCode;
    DWORD SizeL;
    DWORD SizeH;
    BOOLEAN OpenedFile;
    BOOLEAN CreatedFileMapping;

    //
    // Initialize locals.
    //

    OpenedFile = FALSE;
    CreatedFileMapping = FALSE;

    //
    // Note that we are opening the file exclusively. This guarantees
    // that for trace files as long as the kernel is not done writing
    // it we can't open the file, which guarantees we won't have an
    // incomplete file to worry about.
    //

    InputHandle = CreateFile(FilePath, 
                             GENERIC_READ, 
                             0,
                             NULL, 
                             OPEN_EXISTING, 
                             FILE_SHARE_READ, 
                             NULL);

    if (INVALID_HANDLE_VALUE == InputHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedFile = TRUE;

    SizeL = GetFileSize(InputHandle, &SizeH);

    if (SizeL == -1 && (GetLastError() != NO_ERROR )) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SizeH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    if (FileSize) {
        *FileSize = SizeL;
    }

    InputMappingHandle = CreateFileMapping(InputHandle, 
                                           0, 
                                           PAGE_READONLY, 
                                           0,
                                           0, 
                                           NULL);

    if (NULL == InputMappingHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedFileMapping = TRUE;
    
    *BasePointer = MapViewOfFile(InputMappingHandle, 
                                 FILE_MAP_READ, 
                                 0, 
                                 0, 
                                 0);

    if (NULL == *BasePointer) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedFile) {
        CloseHandle(InputHandle);
    }

    if (CreatedFileMapping) {
        CloseHandle(InputMappingHandle);
    }

    return ErrorCode;
}

PWCHAR
PfAppAnsiToUnicode(
    PCHAR str
    )

/*++

Routine Description:

    This routine converts an ANSI string into an allocated wide
    character string. The returned string should be freed by
    free().

Arguments:

    str - Pointer to string to convert.

Return Value:

    Allocated wide character string or NULL if there is a failure.

--*/

{
    ULONG len;
    wchar_t *retstr = NULL;

    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    retstr = (wchar_t *)malloc(len * sizeof(wchar_t));
    if (!retstr) 
    {
        return NULL;
    }
    MultiByteToWideChar(CP_ACP, 0, str, -1, retstr, len);
    return retstr;
}



//
// This does not have to be the actual page size on the platform. It is the
// granularity with which we will make accesses.
//

#define MY_PAGE_SIZE 4096

#define PFAPP_MAX_DATA_PAGES    256

char Data[PFAPP_MAX_DATA_PAGES * MY_PAGE_SIZE] = {1};

#define PFAPP_MAX_FUNCS         16

#pragma code_seg("func0")
DWORD func0(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func1")
DWORD func1(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func2")
DWORD func2(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func3")
DWORD func3(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func4")
DWORD func4(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func5")
DWORD func5(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func6")
DWORD func6(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func7")
DWORD func7(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func8")
DWORD func8(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func9")
DWORD func9(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func10")
DWORD func10(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func11")
DWORD func11(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func12")
DWORD func12(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func13")
DWORD func13(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func14")
DWORD func14(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func15")
DWORD func15(VOID) {return ERROR_SUCCESS;};

#pragma code_seg()

char *PfAppUsage = "pfapp.exe -data datafile\n";

INT 
__cdecl
main(
    INT argc, 
    PCHAR argv[]
    ) 
{
    WCHAR *CommandLine;
    WCHAR *Argument;
    WCHAR *DataFile;
    PCHAR BasePointer;
    DWORD FileSize;
    DWORD FileSizeInMyPages;
    DWORD ErrorCode;
    DWORD FuncNo;
    DWORD NumCalls;
    DWORD CallIdx;
    DWORD DataPage;
    DWORD NumDataAccesses;
    DWORD DataAccessIdx;
    DWORD Sum;

    //
    // Initialize locals.
    //

    CommandLine = GetCommandLine();
    DataFile = NULL;
    BasePointer = NULL;

    //
    // Initialize random generator.
    //

    srand((unsigned)time(NULL));

    //
    // Check arguments.
    //

    if (argc != 3) {
        printf(PfAppUsage);
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Call functions. Each one is on a different page. Basing the number of calls
    // we will make on number of functions/pages we have leads to more interesting
    // access patterns and prefetch policy decisions.
    //

    NumCalls = rand() % PFAPP_MAX_FUNCS;
    NumCalls += PFAPP_MAX_FUNCS / 4;

    for (CallIdx = 0; CallIdx < NumCalls; CallIdx++) {

        FuncNo = rand() % PFAPP_MAX_FUNCS;

        switch(FuncNo) {

        case 0: func0(); break;
        case 1: func1(); break;
        case 2: func2(); break;
        case 3: func3(); break;
        case 4: func4(); break;
        case 5: func5(); break;
        case 6: func6(); break;
        case 7: func7(); break;
        case 8: func8(); break;
        case 9: func9(); break;
        case 10: func10(); break;
        case 11: func11(); break;
        case 12: func12(); break;
        case 13: func13(); break;
        case 14: func14(); break;
        case 15: func15(); break;

        default: break;
        }
    }

    //
    // Access pages in the data section. Basing the number of accesses
    // we will make on number of pages we have adds more regularity to our 
    // accesses so they survive sensitivity based prefetch policy decisions.
    //

    NumDataAccesses = rand() % PFAPP_MAX_DATA_PAGES;
    NumDataAccesses += PFAPP_MAX_DATA_PAGES / 4;

    Sum = 0;

    for (DataAccessIdx = 0; DataAccessIdx < NumDataAccesses; DataAccessIdx++) {

        DataPage = rand() % PFAPP_MAX_DATA_PAGES;

        Sum += Data[DataPage * MY_PAGE_SIZE];
    }

    printf("Bogus sum1 is %d\n", Sum);

    //
    // Map the executable as data.
    //

    DataFile = PfAppAnsiToUnicode(argv[2]);

    if (!DataFile) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    ErrorCode = PfAppGetViewOfFile(DataFile, &BasePointer, &FileSize);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Could not map data file: %x\n", ErrorCode);
        goto cleanup;
    }

    FileSizeInMyPages = FileSize / MY_PAGE_SIZE;

    //
    // Touch the pages of the executable as data pages.
    //

    NumDataAccesses = rand() % FileSizeInMyPages;
    NumDataAccesses += FileSizeInMyPages / 4;

    Sum = 0;

    for (DataAccessIdx = 0; DataAccessIdx < NumDataAccesses; DataAccessIdx++) {

        DataPage = rand() % FileSizeInMyPages;

        Sum += BasePointer[DataPage * MY_PAGE_SIZE];
    }

    printf("Bogus sum2 is %d\n", Sum);
                
    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (DataFile) {
        free(DataFile);
    }

    if (BasePointer) {
        UnmapViewOfFile(BasePointer);
    }
    
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\test\pfctrl\pfctrl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfctrl.c

Abstract:

    This module builds a console test program to control various
    parameters of the prefetcher maintenance service.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include "prefetch.h"
#include "idletask.h"
#include "..\..\pfsvc.h"

WCHAR *PfCtrlUsage = 
L"                                                                          \n"
L"Usage: pfctrl [-override_idle=[0|1]] [-process_all]                       \n"
L"  Controls the prefetcher maintenance service.                            \n"
L"                                                                          \n"
L"Arguments:                                                                \n"
L"  -override_idle=[0|1]  - Whether to wait for system to be idle before    \n"
L"                          processing prefetcher traces.                   \n"
L"  -process_all          - Sets the override-idle event and waits for all  \n"
L"                          current traces to be processed.                 \n"
L"                                                                          \n"
;

int 
__cdecl 
main(int argc, char* argv[])
{
    WCHAR *CommandLine;
    WCHAR *Argument;
    DWORD ErrorCode;
    ULONG OverrideIdle;
    BOOLEAN EventIsSet;
    HANDLE OverrideIdleEvent;
    HANDLE ProcessingCompleteEvent;
    DWORD WaitResult;
    BOOLEAN ResetOverrideIdleEvent;

    //
    // Initialize locals.
    //

    OverrideIdleEvent = NULL;
    ProcessingCompleteEvent = NULL;
    CommandLine = GetCommandLine();

    if (Argument = wcsstr(CommandLine, L"-override_idle=")) {
        
        swscanf(Argument, L"-override_idle=%d", &OverrideIdle);

        //
        // Open the override idle processing event.
        //

        OverrideIdleEvent = OpenEvent(EVENT_ALL_ACCESS,
                                      FALSE,
                                      PFSVC_OVERRIDE_IDLE_EVENT_NAME);

        if (!OverrideIdleEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open override-idle-processing event: %x\n", ErrorCode);
            goto cleanup;
        }

        //
        // Determine the current status of the event.
        //

        WaitResult = WaitForSingleObject(OverrideIdleEvent,
                                         0);
        
        if (WaitResult == WAIT_OBJECT_0) {
            EventIsSet = TRUE;
        } else {
            EventIsSet = FALSE;
        }

        //
        // Do what we are asked to do:
        //

        if (OverrideIdle) {

            if (EventIsSet) {

                wprintf(L"Override event is already set!\n");
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

            } else {
            
                wprintf(L"Setting the override idle processing event.\n");
                SetEvent(OverrideIdleEvent);
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }

        } else {

            if (!EventIsSet) {

                wprintf(L"Override event is already cleared!\n");
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

            } else {

                wprintf(L"Clearing the override idle processing event.\n");
                ResetEvent(OverrideIdleEvent);
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

    } else if (Argument = wcsstr(CommandLine, L"-process_all")) {

        //
        // Open the override-idle-processing and processing-complete
        // events.
        //

        OverrideIdleEvent = OpenEvent(EVENT_ALL_ACCESS,
                                      FALSE,
                                      PFSVC_OVERRIDE_IDLE_EVENT_NAME);

        if (!OverrideIdleEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open override-idle-processing event: %x\n", ErrorCode);
            goto cleanup;
        }
        
        ProcessingCompleteEvent = OpenEvent(EVENT_ALL_ACCESS,
                                            FALSE,
                                            PFSVC_PROCESSING_COMPLETE_EVENT_NAME);

        if (!ProcessingCompleteEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open processing-complete event: %x\n", ErrorCode);
            goto cleanup;
        }

        //
        // Determine the current status of the override-idle event.
        //

        WaitResult = WaitForSingleObject(OverrideIdleEvent,
                                         0);
        
        if (WaitResult == WAIT_OBJECT_0) {
            EventIsSet = TRUE;
        } else {
            EventIsSet = FALSE;
        }
        
        //
        // Set the override-idle event to force processing of traces
        // right away.
        //

        if (!EventIsSet) {

            wprintf(L"Setting override idle event.\n");

            SetEvent(OverrideIdleEvent);

            ResetOverrideIdleEvent = TRUE;

        } else {

            wprintf(L"WARNING: Override-idle event is already set. "
                    L"It won't be reset.\n");

            ResetOverrideIdleEvent = FALSE;
        }

        //
        // Wait for processing complete event to get signaled.
        //
        
        wprintf(L"Waiting for all traces to be processed... ");
        
        WaitResult = WaitForSingleObject(ProcessingCompleteEvent, INFINITE);
        
        if (WaitResult != WAIT_OBJECT_0) {
            
            ErrorCode = GetLastError();
            wprintf(L"There was an error: %x\n", ErrorCode);
            goto cleanup;
        }
        
        wprintf(L"Done!\n");
        
        //
        // Reset the override idle event if necessary.
        //
        
        if (ResetOverrideIdleEvent) {
            
            wprintf(L"Resetting override-idle-processing event.\n");
            ResetEvent(OverrideIdleEvent);
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;

    } else {

        wprintf(PfCtrlUsage);
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);
    
    ErrorCode = ERROR_GEN_FAILURE;

 cleanup:

    if (OverrideIdleEvent) {
        CloseHandle(OverrideIdleEvent);
    }
    
    if (ProcessingCompleteEvent) {
        CloseHandle(ProcessingCompleteEvent);
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\service\test\pftest\pfcontst.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfcontst.c

Abstract:

    This module builds a console test program for the prefetcher
    maintenance service.

    The console test program

     - Can dump the contents of a scenario or trace file.
     - Can create a thread and run as the service would. Press CTRL-C 
       to send the termination signal.
  
    Note that both scenario and trace files are currently dumped after
    putting them into the intermediate format which may change number
    of launches and shift the UsageHistory etc.

    The test programs are built from the same sources as the original. This
    allows the test program to override parts of the original program to run
    it in a managed environment, and be able to test individual functions. 

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#define PFSVC_CONSOLE_TEST

#include "..\..\pfsvc.c"

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

//
// Fake the idletask server internal function.
//

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    )
{
    return TRUE;
}

//
// Dump intermediate scenario structure.
//

VOID
DumpMetadataInfo (
    PPF_SCENARIO_HEADER Scenario
    )
{
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    PWCHAR VolumePath;
    PFILE_PREFETCH FilePrefetchInfo;
    ULONG FileIndexNumberIdx;
    ULONG DirectoryIdx;
    PPF_COUNTED_STRING DirectoryPath;

    //
    // Get pointers to metadata prefetch information.
    //

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    //
    // Dump metadata records and contents.
    //

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        
        //
        // Print volume name.
        //

        VolumePath = (PWCHAR)
            (MetadataInfoBase + MetadataRecord->VolumeNameOffset);  
        
        wprintf(L"VolumePath:%s\n", VolumePath);

        //
        // Print volume identifiers.
        //

        wprintf(L"SerialNumber:%.8x CreationTime:%I64x\n", 
                MetadataRecord->SerialNumber,
                MetadataRecord->CreationTime.QuadPart);

        //
        // Print the directories accessed on this volume.
        //

        wprintf(L"Directories:\n");
        
        DirectoryPath = (PPF_COUNTED_STRING)
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx++) {

            wprintf(L"  %ws\n", DirectoryPath->String);
            
            DirectoryPath = (PPF_COUNTED_STRING) 
                (&DirectoryPath->String[DirectoryPath->Length + 1]);
        }

        //
        // Print file prefetch info structure.
        //

        FilePrefetchInfo = (PFILE_PREFETCH) 
            (MetadataInfoBase + MetadataRecord->FilePrefetchInfoOffset);
        
        wprintf(L"FilePrefetchInfo.Type:%d\n", FilePrefetchInfo->Type);
        wprintf(L"FilePrefetchInfo.Count:%d\n", FilePrefetchInfo->Count);

        //
        // Print file index numbers.
        //

        for(FileIndexNumberIdx = 0;
            FileIndexNumberIdx < FilePrefetchInfo->Count;
            FileIndexNumberIdx++) {

            wprintf(L"0x%016I64x\n", FilePrefetchInfo->Prefetch[FileIndexNumberIdx]);
        }
        
        wprintf(L"\n");
    }

    return;
}
   
VOID
DumpScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    LONG DumpSectionIdx
    )
{
    PPF_SCENARIO_HEADER Scenario;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;
    LONG SectionIdx;
    LONG PageIdx;
    WCHAR UsageHistory[PF_PAGE_HISTORY_SIZE + 1];
    WCHAR PrefetchHistory[PF_PAGE_HISTORY_SIZE + 1];
    ULONG HistoryMask;
    ULONG CharIdx;
    ULONG BitIdx;
    TIME_FIELDS TimeFields;

    Scenario = &ScenarioInfo->ScenHeader;
    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;
    SectionIdx = 0;

    //
    // Print information on the scenario header.
    //
    
    wprintf(L"Scenario: %s-%08X Type: %2d Sects: %5d Pages: %8d "
            L"Launches: %5d Sensitivity: %5d\n",
            Scenario->ScenarioId.ScenName, Scenario->ScenarioId.HashId,
            (ULONG) Scenario->ScenarioType,
            Scenario->NumSections, Scenario->NumPages,
            Scenario->NumLaunches, Scenario->Sensitivity);

    RtlTimeToTimeFields(&Scenario->LastLaunchTime, &TimeFields);

    wprintf(L"  LastLaunchTime(UNC): %04d/%02d/%02d %02d:%02d:%02d, "
            L"MinRePrefetchTime: %10I64d, MinReTraceTime: %10I64d\n\n",
            TimeFields.Year,
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second,
            Scenario->MinReTraceTime.QuadPart,
            Scenario->MinRePrefetchTime.QuadPart);
    
    //
    // Print information per section node.
    //

    while (SectHead != SectNext) {

        SectionNode = (PPFSVC_SECTION_NODE) CONTAINING_RECORD(SectNext,
                                                        PFSVC_SECTION_NODE,
                                                        SectionLink);

        if (DumpSectionIdx == -1 || DumpSectionIdx == SectionIdx) {
            
            wprintf(L"Section %5d: %8d Pages %4s %4s %4s '%s'\n", 
                    SectionIdx, 
                    SectionNode->SectionRecord.NumPages,
                    (SectionNode->SectionRecord.IsIgnore) ? L"Ign" : L"",
                    (SectionNode->SectionRecord.IsImage) ?  L"Img" : L"",
                    (SectionNode->SectionRecord.IsData) ?   L"Dat" : L"",
                    SectionNode->FilePath);
        }

        if (DumpSectionIdx == SectionIdx) {

            wprintf(L"\n");

            PageHead = &SectionNode->PageList;
            PageNext = PageHead->Flink;
        
            PageIdx = 0;
            
            while (PageHead != PageNext) {
            
                PageNode = (PPFSVC_PAGE_NODE) CONTAINING_RECORD(PageNext,
                                                          PFSVC_PAGE_NODE,
                                                          PageLink);

                //
                // Build bitwise representation of the page
                // usage/prefetch histories.
                //

                for (BitIdx = 0; BitIdx < PF_PAGE_HISTORY_SIZE; BitIdx++) {
                    
                    HistoryMask = 0x1 << BitIdx;
                    CharIdx = PF_PAGE_HISTORY_SIZE - BitIdx - 1;

                    if (PageNode->PageRecord.UsageHistory & HistoryMask) {
                        UsageHistory[CharIdx] = L'X';
                    } else {
                        UsageHistory[CharIdx] = L'-';
                    }

                    if (PageNode->PageRecord.PrefetchHistory & HistoryMask) {
                        PrefetchHistory[CharIdx] = L'X';
                    } else {
                        PrefetchHistory[CharIdx] = L'-';
                    }
                }

                //
                // Make sure history strings are NUL terminated.
                //
                
                UsageHistory[PF_PAGE_HISTORY_SIZE] = 0;
                PrefetchHistory[PF_PAGE_HISTORY_SIZE] = 0;
                
                //
                // Print out page record.
                //

                wprintf(L"Page %8d: File Offset: %10x IsImage: %1d IsData: %1d UsageHist: %s PrefetchHist: %s\n", 
                        PageIdx,
                        PageNode->PageRecord.FileOffset,
                        PageNode->PageRecord.IsImage,
                        PageNode->PageRecord.IsData,
                        UsageHistory,
                        PrefetchHistory);
            
                PageIdx++;
                PageNext = PageNext->Flink;
            }
        }

        SectionIdx++;
        SectNext = SectNext->Flink;
    }
}
    
HANDLE PfSvStopEvent = NULL;
HANDLE PfSvThread = NULL;

BOOL
ConsoleHandler(DWORD dwControl)
{
    SetEvent(PfSvStopEvent);   
    
    return TRUE;
}

PFSVC_IDLE_TASK *RunningTask = NULL;
PFSVC_IDLE_TASK g_Tasks[3];

DWORD 
DoWork (
    PFSVC_IDLE_TASK *Task
    )
{
    DWORD ErrorCode;
    DWORD EndTime;
    DWORD TaskNo;

    //
    // Initialize locals.
    //

    TaskNo = (ULONG) (Task - g_Tasks);

    printf("TSTRS: %d: DoWork()\n",TaskNo);

    RunningTask = Task;

    //
    // Randomly determine how long the task should take.
    //

    EndTime = GetTickCount() + rand() % 8192;

    //
    // Run until we are done or told to stop.
    //

    while (GetTickCount() < EndTime) {

        //
        // Check if we should still run.
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("TSTRS: %d: DoWork-ContinueTaskReturned=%x\n",TaskNo, ErrorCode);
            goto cleanup;
        }
    }

    //
    // Sometimes return failure, sometimes success.
    //

    ErrorCode = ERROR_SUCCESS;

    if (rand() % 2) {
        ErrorCode = ERROR_INVALID_FUNCTION;
    }

cleanup:

    RunningTask = NULL;

    printf("TSTRS: %d: DoWork()=%d,%s\n",TaskNo,ErrorCode,(ErrorCode==ERROR_RETRY)?"Retry":"Done");

    return ErrorCode;
}

DWORD
TaskStress(
    VOID
    )
{
    INPUT MouseInput;
    PPFSVC_IDLE_TASK TaskToUnregister;
    ULONG NumTasks;
    ULONG TaskIdx;
    ULONG SleepTime;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN UnregisterRunningTask;

    //
    // Initialize locals.
    //

    RtlZeroMemory(&MouseInput, sizeof(MouseInput));
    MouseInput.type = INPUT_MOUSE;
    MouseInput.mi.dwFlags = MOUSEEVENTF_MOVE;

    NumTasks = sizeof(g_Tasks) / sizeof(g_Tasks[0]);

    for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {
        PfSvInitializeTask(&g_Tasks[TaskIdx]);     
    }

    printf("TSTRS: TaskStress()\n");

    //
    // Loop, reregistering / unregistering tasks, sending user input 
    // etc.
    //

    while (TRUE) {

        //
        // Send user input once in a while to restart idle detection.
        //

        if ((rand() % 3) == 0) {
            printf("TSTRS: TaskStress-SendingInput\n");
            SendInput(1, &MouseInput, sizeof(MouseInput));
        }

        //
        // Once in a while unregister a task.
        //      

        TaskToUnregister = NULL;

        if ((rand() % 4) == 0) {

            TaskToUnregister = RunningTask;
            printf("TSTRS: TaskStress-UnregisterRunningTask\n");

        } else if ((rand() % 3) == 0) {

            TaskIdx = rand() % NumTasks;

            TaskToUnregister = &g_Tasks[TaskIdx];
            printf("TSTRS: TaskStress-UnregisterTaskIdx(%d)\n", TaskIdx);
        }

        if (TaskToUnregister) {
            PfSvUnregisterTask(TaskToUnregister, FALSE);
            printf("TSTRS: TaskStress-Unregistered(%d)\n", TaskToUnregister - g_Tasks);
        }       

        //
        // Register any unregistered tasks.
        //

        for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {

            if (!g_Tasks[TaskIdx].Registered) {

                //
                // Cleanup and reinitialize the task.
                //

                PfSvCleanupTask(&g_Tasks[TaskIdx]);
                PfSvInitializeTask(&g_Tasks[TaskIdx]);

                printf("TSTRS: TaskStress-RegisterTaskIdx(%d)\n", TaskIdx);

                ErrorCode = PfSvRegisterTask(&g_Tasks[TaskIdx], 
                                             ItDiskMaintenanceTaskId,
                                             PfSvCommonTaskCallback,
                                             DoWork);

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }
            }
        }

        SleepTime = 10000 * (rand() % 64) / 64;       

        //
        // Sleep, waiting on the event that will be signaled to stop us.
        //

        printf("TSTRS: TaskStress-MainLoopSleeping(%d)\n", SleepTime);

        WaitResult = WaitForSingleObject(PfSvStopEvent, SleepTime);

        printf("TSTRS: TaskStress-Wokeup(%d)\n", SleepTime);
        
        if (WaitResult == WAIT_OBJECT_0) {
            printf("TSTRS: TaskStress-PfSvStopEventSignaled\n");
            break;
        } else if (WaitResult != WAIT_TIMEOUT) {
            ErrorCode = GetLastError();
            printf("TSTRS: TaskStress-WaitFailed=%x\n", ErrorCode);
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:    

    for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {

        if (g_Tasks[TaskIdx].Registered) {
            printf("TSTRS: TaskStress-Unregistering(%d)\n", TaskIdx);
            PfSvUnregisterTask(&g_Tasks[TaskIdx], FALSE);
        }
        
        printf("TSTRS: TaskStress-Cleanup(%d)\n", TaskIdx);
        PfSvCleanupTask(&g_Tasks[TaskIdx]);
    }

    printf("TSTRS: TaskStress()=%d\n", ErrorCode);

    return ErrorCode;
}

DWORD
DumpTrace (
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Prints out contents of a trace file as is.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SECTION_INFO *SectionTable;
    PPF_SECTION_INFO Section;
    PPF_LOG_ENTRY LogEntries;
    PCHAR pFileName;
    ULONG SectionIdx;
    ULONG EntryIdx;
    DWORD ErrorCode;
    ULONG SectionLength;
    ULONG NextSectionIndex;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    ULONG SectionTableSize;

    //
    // Initialize locals so we know what to clean up.
    //

    SectionTable = NULL;

    //
    // Walk through the volumes in the trace.
    //

    printf("Volume Info\n");

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {

        printf("%16I64x %8x %ws\n", 
               VolumeInfo->CreationTime, 
               VolumeInfo->SerialNumber,
               VolumeInfo->VolumePath);

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // Allocate section table.
    //

    SectionTableSize = sizeof(PPF_SECTION_INFO) * Trace->NumSections;
    SectionTable = PFSVC_ALLOC(SectionTableSize);
    
    if (!SectionTable) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(SectionTable, SectionTableSize);

    //
    // Walk through the sections in the trace.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Put section into the table.
        //

        SectionTable[SectionIdx] = Section;

        //
        // Get the next section record in the trace.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Print out pagefault information.
    //

    printf("\n");
    printf("Page faults\n");

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);
    
    for (EntryIdx = 0; EntryIdx < Trace->NumEntries; EntryIdx++) {

        Section = SectionTable[LogEntries[EntryIdx].SectionId];

        printf("%8x %8d %1d %1d %1d %ws\n", 
               LogEntries[EntryIdx].FileOffset,
               (ULONG) LogEntries[EntryIdx].SectionId,
               (ULONG) LogEntries[EntryIdx].IsImage,
               (ULONG) LogEntries[EntryIdx].InProcess,
               (ULONG) Section->Metafile,
               Section->FileName);
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (SectionTable) {
        PFSVC_FREE(SectionTable);
    }

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()=%x\n", ErrorCode));

    return ErrorCode;
}


wchar_t *PfSvUsage = 
L" pftest -scenario=scenariofile [-sectionid=sectionid] [-realdump]          \n"
L" pftest -scenario=scenariofile -metadata                                   \n"
L" pftest -scenario=scenariofile -layout=outputfile                          \n"
L" pftest -trace=tracefile [-sectionid=sectionid] [-realdump]                \n"
L" pftest -process_trace=tracefile                                           \n"
L" pftest -bootfiles                                                         \n"
L" pftest -service                                                           \n"
L" pftest -cleanupdir                                                        \n"
L" pftest -defragdisks                                                       \n"
L" pftest -updatelayout                                                      \n"
L" pftest -taskstress                                                        \n"
L" pftest -scenfiles=scendir                                                 \n"
L" pftest -verifyimage=imagefile                                             \n"
L" Specify '-noverify' to dump scenario and trace info without verification  \n"
;

INT 
__cdecl
main(
    INT argc, 
    PCHAR argv[]
    ) 
{
    WCHAR FileName[MAX_PATH];
    WCHAR LayoutFile[MAX_PATH];
    LONG SectionId;
    DWORD ErrorCode;
    PPF_SCENARIO_HEADER Scenario;
    PPF_TRACE_HEADER TraceFile;
    PPF_TRACE_HEADER Trace;
    DWORD Size;
    PF_SCENARIO_ID ScenarioId;
    PF_SCENARIO_TYPE ScenarioType;
    PFSVC_SCENARIO_INFO ScenarioInfo;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_VOLUME_NODE VolumeNode;
    PFSVC_PATH_LIST Layout;
    FILETIME FileTime;
    ULONG FailedCheck;
    PFSVC_PATH_LIST PathList;
    PPFSVC_PATH Path;
    WCHAR *CommandLine;
    WCHAR *Argument;
    BOOLEAN DumpOptimalLayout;
    BOOLEAN DumpMetadata;
    BOOLEAN InitializedPfSvGlobals;
    BOOLEAN MappedViewOfTrace;
    BOOLEAN MappedViewOfScenario;
    BOOLEAN InitializedScenarioInfo;
    PF_SYSTEM_PREFETCH_PARAMETERS Parameters;
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    ULONG Length;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PWCHAR DosPathBuffer;
    PVOID ImageFile;
    ULONG DosPathBufferSize;
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    ULONG LoopIdx;
    ULONG NumLoops;
    ULONG NumPrefetchFiles;
    WCHAR ScenarioFilePath[MAX_PATH];
    ULONG ScenarioFilePathMaxChars;
    ULONG FailedCheckId;
    BOOLEAN RealDump;
    BOOLEAN Verify;
    
    //
    // Initialize locals.
    //

    CommandLine = GetCommandLine();
    PfSvInitializePathList(&PathList, NULL, FALSE);
    PfSvInitializePathList(&Layout, NULL, FALSE);
    SectionId = -1;
    InitializedPfSvGlobals = FALSE;
    MappedViewOfScenario = FALSE;
    MappedViewOfTrace = FALSE;
    InitializedScenarioInfo = FALSE;
    Trace = NULL;
    ImageFile = NULL;
    TranslationList = NULL;
    DosPathBuffer = NULL;
    DosPathBufferSize = 0;
    PfSvInitializeScenarioFileCursor(&FileCursor);
    ScenarioFilePathMaxChars = sizeof(ScenarioFilePath) / 
                               sizeof(ScenarioFilePath[0]);
    RealDump = FALSE;
    Verify = TRUE;

    //
    // Initialize globals.
    //

    PfSvStopEvent = NULL;
    PfSvThread = NULL;

    ErrorCode = PfSvInitializeGlobals();
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Could not initialize globals: %x\n", ErrorCode);
        goto cleanup;
    }

    InitializedPfSvGlobals = TRUE;

    //
    // Initialize random.
    //
    
    srand((unsigned)time(NULL));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to get prefetcher service thread priviliges=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Get system prefetch parameters.
    //

    ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to query system prefetch parameters=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Initialize the directory that contains prefetch instructions.
    //
    
    ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to initialize prefetch directory=%x\n", ErrorCode);
        goto cleanup;
    }   

    //
    // Initialize the event the will get set when we get CTRL-C'ed.
    //
    
    PfSvStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (!PfSvStopEvent) {
        ErrorCode = GetLastError();
        printf("Failed to initialize stop event=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Build NT path translation list. We don't need to do this always, but heck,
    // let's do it anyway. It should work.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&TranslationList);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to build NT path translation list=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Should we skip verification?
    //

    if (Argument = wcsstr(CommandLine, L"-noverify")) {
        Verify = FALSE;
    }

    //
    // Are we supposed dump the scenarios and traces as they are?
    //

    if (Argument = wcsstr(CommandLine, L"-realdump")) {
        RealDump = TRUE;
    }

    //
    // Were we asked to run as the service?
    //
    
    if (Argument = wcsstr(CommandLine, L"-service")) {
    
        fprintf(stderr, "Running as service...\n");

        //
        // Set a console handler so we know to stop when Ctrl-C is typed.
        //

        SetConsoleCtrlHandler(ConsoleHandler, TRUE);

        //
        // Create service thread:
        //

        //
        // Cleanup the globals as the service thread will reinitialize
        // them.
        //

        PfSvCleanupGlobals();
        InitializedPfSvGlobals = FALSE;

        PfSvThread = CreateThread(0,0,PfSvcMainThread,&PfSvStopEvent,0,0); 
        
        if (!PfSvThread) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    
        //
        // Wait for the thread to exit.
        //

        WaitForSingleObject(PfSvThread, INFINITE);

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;
    }

    //
    // Were we asked to build the list of boot files?
    //

    if (Argument = wcsstr(CommandLine, L"-bootfiles")) {
            
        ErrorCode = PfSvBuildBootLoaderFilesList(&PathList);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not build boot files list: %d\n", ErrorCode);
            goto cleanup;
        }
            
        Path = NULL;
        
        while (Path = PfSvGetNextPathInOrder(&PathList,Path)) {
            printf("%ws\n", Path->Path);
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Was a section ID specified for trace/scenario dumping?
    //
    
    if (Argument = wcsstr(CommandLine, L"-sectionid=")) {
    
        swscanf(Argument, L"-sectionid=%d", &SectionId);
    }

    //
    // Are we dumping a trace?
    //

    if (Argument = wcsstr(CommandLine, L"-trace=")) {

        swscanf(Argument, L"-trace=%s", FileName);
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &TraceFile,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfTrace = TRUE;

        Trace = PFSVC_ALLOC(Size);

        if (!Trace) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        RtlCopyMemory(Trace, TraceFile, Size);
        
        //
        // Verify it.
        //

        if (Verify) {
            if (!PfVerifyTraceBuffer(Trace, Size, &FailedCheck)) {
                printf("Could not verify:%d\n",FailedCheck);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }
        }

        //
        // If we were asked to do a real as-is dump, do so.
        //

        if (RealDump) {
            DumpTrace(Trace);
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Build a scenario info structure. 
        //

        ScenarioId = Trace->ScenarioId;
        ScenarioType = Trace->ScenarioType;
            
        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &ScenarioId,
                                   ScenarioType);

        InitializedScenarioInfo = TRUE;

        //
        // Allocate memory upfront for trace processing.
        //

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                NULL,
                                                Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not Preallocate=%d\n", ErrorCode);
            goto cleanup;
        }
            
        ErrorCode = PfSvAddTraceInfo(&ScenarioInfo,
                                     Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not AddTraceInfo=%d\n", ErrorCode);
            goto cleanup;
        }

        ErrorCode = PfSvApplyPrefetchPolicy(&ScenarioInfo);
        
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not apply policy=%d\n", ErrorCode);
            goto cleanup;
        }

        DumpScenarioInfo(&ScenarioInfo, SectionId);

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;

    }

    //
    // Are we processing a trace?
    //

    if (Argument = wcsstr(CommandLine, L"-process_trace=")) {

        swscanf(Argument, L"-process_trace=%s", FileName);
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &TraceFile,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfTrace = TRUE;

        Trace = PFSVC_ALLOC(Size);

        if (!Trace) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        RtlCopyMemory(Trace, TraceFile, Size);
        
        //
        // Verify it.
        //

        if (Verify) {
            if (!PfVerifyTraceBuffer(Trace, Size, &FailedCheck)) {
                printf("Could not verify:%d\n",FailedCheck);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }
        }
               
        //
        // Process the trace.
        //

        ErrorCode = PfSvProcessTrace(Trace);
        
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed process trace: %d\n", ErrorCode);
            goto cleanup;
        }
        
        printf("Done.\n");

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;
    }

    //
    // Are we dumping the contents of a scenario?
    //

    if (Argument = wcsstr(CommandLine, L"-scenario=")) {

        swscanf(Argument, L"-scenario=%s", FileName);

        //
        // Are we dumping metadata?
        //

        if(Argument = wcsstr(CommandLine, L"-metadata")) {
            DumpMetadata = TRUE;
        } else {
            DumpMetadata = FALSE;
        }
        
        //
        // Are we dumping layout?
        //

        if (Argument = wcsstr(CommandLine, L"-layout")) {
            
            swscanf(Argument, L"-layout=%s", LayoutFile);
            DumpOptimalLayout = TRUE;

        } else {
            DumpOptimalLayout = FALSE;
        }
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &Scenario,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfScenario = TRUE;
        
        //
        // Verify it.
        //

        if (Verify) {
            if (!PfVerifyScenarioBuffer(Scenario, Size, &FailedCheck)) {
                printf("Could not verify:%d\n",FailedCheck);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }              
        }

        //
        // If we were asked to, dump what the optimal layout file
        // derived just from this scenario would be:
        //

        if (DumpOptimalLayout) {

            //
            // Do this multiple times, it should not change the resulting file.
            //

            for (LoopIdx = 0; LoopIdx < 32; LoopIdx++) {

                if (Scenario->ScenarioType == PfSystemBootScenarioType) {

                    ErrorCode = PfSvBuildBootLoaderFilesList(&Layout);
                        
                    if (ErrorCode != ERROR_SUCCESS) {
                        printf("Could not build boot files list: %d\n", ErrorCode);
                        goto cleanup;
                    }
                }

                ErrorCode = PfSvUpdateLayoutForScenario(&Layout,
                                                        FileName,
                                                        TranslationList,
                                                        &DosPathBuffer,
                                                        &DosPathBufferSize);

                if (ErrorCode != ERROR_SUCCESS) {
                    printf("Failed UpdateLayoutForScenario=%x\n", ErrorCode);
                    goto cleanup;
                }
                                      
                ErrorCode = PfSvSaveLayout (LayoutFile, &Layout, &FileTime);

                if (ErrorCode != ERROR_SUCCESS) {
                    printf("Could not save optimal layout\n");
                    goto cleanup;
                }
            }

            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }


        //
        // If we were asked to dump the metadata, just do that.
        //

        if (DumpMetadata) {
            DumpMetadataInfo(Scenario);
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
        
        //
        // Initialize scenario information.
        //

        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &Scenario->ScenarioId,
                                   Scenario->ScenarioType);

        InitializedScenarioInfo = TRUE;

        //
        // Allocate memory upfront for trace & scenario processing.
        //

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                Scenario,
                                                NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not preallocate: %d\n", ErrorCode);
            goto cleanup;
        }

        //
        // Incorporate information from existing scenario file.
        //

        ErrorCode = PfSvAddExistingScenarioInfo(&ScenarioInfo, Scenario);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not add scenario info: %d\n", ErrorCode);
            goto cleanup;
        }
        
        //
        // Dump contents of the scenario.
        //
        
        DumpScenarioInfo(&ScenarioInfo, SectionId);

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Check if we were asked to perform some tasks that we usually do when the
    // system is idle.
    //

    if (Argument = wcsstr(CommandLine, L"-cleanupdir")) {

        ErrorCode = PfSvCleanupPrefetchDirectory(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed CleanupPrefechDirectory()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-updatelayout")) {

        ErrorCode = PfSvUpdateOptimalLayout(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed UpdateOptimalLayout()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-defragdisks")) {

        ErrorCode = PfSvDefragDisks(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed DefragDisks()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-taskstress")) {

        ErrorCode = TaskStress();
        goto cleanup;
    }

    //
    // Enumerate scenario files in the given directory.
    //

    if (Argument = wcsstr(CommandLine, L"-scenfiles=")) {

        swscanf(Argument, L"-scenfiles=%s", FileName);

        //
        // Go through the files several times before finally
        // printing out the information.
        //

        NumLoops = 10;

        for (LoopIdx = 0; LoopIdx < NumLoops; LoopIdx++) {

            //
            // Count the files for heck.
            //

            ErrorCode = PfSvCountFilesInDirectory(FileName,
                                                  L"*." PF_PREFETCH_FILE_EXTENSION,
                                                  &NumPrefetchFiles);

            if (ErrorCode != ERROR_SUCCESS) {
                printf("Failed CountFilesInDirectory=%x\n", ErrorCode);
                goto cleanup;
            }

            PfSvCleanupScenarioFileCursor(&FileCursor);
            PfSvInitializeScenarioFileCursor(&FileCursor);

            ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, FileName);

            if (ErrorCode != ERROR_SUCCESS) {
                printf("Failed StartScenarioFileCursor: %x\n", ErrorCode);
                goto cleanup;
            }       

            while (!(ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor))) {

                if (LoopIdx == NumLoops - 1) {
                    printf("%5d: %ws\n", FileCursor.CurrentFileIdx, FileCursor.FilePath);
                }

                ErrorCode = ERROR_BAD_FORMAT;

                if (FileCursor.FilePathLength != wcslen(FileCursor.FilePath)) {
                    printf("Bad format id: 10\n");
                    goto cleanup;
                }

                if (FileCursor.FileNameLength != wcslen(FileCursor.FileData.cFileName)) {
                    printf("Bad format id: 20\n");
                    goto cleanup;
                }

                if (wcscmp(FileCursor.FileData.cFileName, FileCursor.FilePath + FileCursor.FileNameStart)) {
                    printf("Bad format id: 30\n");
                    goto cleanup;
                }

                if (wcsncmp(FileCursor.PrefetchRoot, FileCursor.FilePath, FileCursor.PrefetchRootLength)) {
                    printf("Bad format id: 40\n");
                    goto cleanup;
                }

                if (FileCursor.FilePathLength > FileCursor.FilePathMaxLength ||
                    FileCursor.PrefetchRootLength > FileCursor.FilePathLength) {
                    printf("Bad format id: 50\n");
                    goto cleanup;
                }           
            }

            if (ErrorCode != ERROR_NO_MORE_FILES) {
                printf("Failed GetNextScenarioFileInfo: %x\n", ErrorCode);
                goto cleanup;
            }

            if (NumPrefetchFiles != FileCursor.CurrentFileIdx) {
                printf("\n\nNum files in directory changed? %d != %d\n\n", 
                       NumPrefetchFiles, FileCursor.CurrentFileIdx);
            }
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Were we asked to verify import table and headers of an image file?
    //
   
    if (Argument = wcsstr(CommandLine, L"-verifyimage=")) {

        swscanf(Argument, L"-verifyimage=%s", FileName);

        ErrorCode = PfSvGetViewOfFile(FileName, &ImageFile, &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        FailedCheckId = PfVerifyImageImportTable(ImageFile, Size, FALSE);

        if (FailedCheckId) {
            printf("%ws: failed %d check in image import verification.\n", FileName, FailedCheckId);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        } else {
            printf("%ws: passed image import verification.\n", FileName);
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    
    //
    // If we come here, no parameters that we understood were
    // specified.
    //

    printf("%ws", PfSvUsage);

    ErrorCode = ERROR_INVALID_PARAMETER;
    
 cleanup:

    if (PfSvStopEvent) {
        CloseHandle(PfSvStopEvent);
    }

    if (PfSvThread) {
        CloseHandle(PfSvThread);
    }

    if (ImageFile) {
        UnmapViewOfFile(ImageFile);
    }

    if (Trace) {
        PFSVC_FREE(Trace);
    }

    if (MappedViewOfTrace) {
        UnmapViewOfFile(TraceFile);
    }

    if (MappedViewOfScenario) {
        UnmapViewOfFile(Scenario);
    }

    if (InitializedScenarioInfo) {
        PfSvCleanupScenarioInfo(&ScenarioInfo);
    }

    PfSvCleanupPathList(&PathList);

    PfSvCleanupPathList(&Layout);

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (TranslationList) {
        PfSvFreeNtPathTranslationList(TranslationList);
    }

    if (DosPathBuffer) {
        PFSVC_FREE(DosPathBuffer);
    }

    //
    // Uninitialize the globals last.
    //
        
    if (InitializedPfSvGlobals) {
        PfSvCleanupGlobals();
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\setup\setupids.h ===
//#ifndef __SETUP_H__
//#define __SETUP_H__

#define IDS_INSTALL_FAILURE         0
#define IDS_START_FAILURE           1
#define IDS_LOGON_NOTICE_ERROR      3
#define IDS_SERVICE_DISPLAY_NAME    9

//#endif // __SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\setup\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:   Security-related helper functions used by the Task Scheduler
//              setup program to set security on the job folder.
//
//  Classes:    None.
//
//  Functions:
//
//  History:    23-Sep-96  AnirudhS  Copied with minor modifications from
//                  ..\job\security.cxx.
//			October 2001 Maxa	 Updated security.cxx in preparation for addition of auditing.
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "security.hxx"

DWORD
CreateAcl(
    OUT PACL*                   ppAcl,
    IN  DWORD                   dwAclAceCount,
    IN  CONST ACE_DESC*         pAclAces
    );

//+---------------------------------------------------------------------------
//
//  Function:   CreateSecurityDescriptor
//
//  Synopsis:   Create a security descriptor with the ACE information
//              specified.
//
//  Arguments:  [ppSecDesc, out] - pointer to descurity descriptor. Gets filled in if
//                         the function does not encounter an error.
//              [dwDaclAceCount] - number of ACEs for the DACL.
//                         NOTE: use -1 when you want no DACL, 0 for an empty DACL.
//              [pDaclAces]      - pointer to ACE specification array.
//              [dwSaclAceCount] - number of ACEs for the DACL.
//              [pSaclAces]      - pointer to ACE specification array.
//
//  Returns:    win32 error code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
CreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   ppSecurityDescriptor,
    IN  DWORD                   dwDaclAceCount,
    IN  CONST ACE_DESC*         pDaclAces,
    IN  DWORD                   dwSaclAceCount,
    IN  CONST ACE_DESC*         pSaclAces
    )
{
    DWORD                   dwError             = ERROR_SUCCESS;
    BOOL                    bSuccess;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;
    PACL                    pDacl               = 0;
    PACL                    pSacl               = 0;

    *ppSecurityDescriptor = 0;


    //
    // Create the security descriptor.
    //

    pSecurityDescriptor = LocalAlloc(
                              LMEM_FIXED,
                              SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (pSecurityDescriptor == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    bSuccess = InitializeSecurityDescriptor(
                   pSecurityDescriptor,
                   SECURITY_DESCRIPTOR_REVISION);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    if (dwDaclAceCount != DWORD(-1))
    {
        dwError = CreateAcl(
                      &pDacl,
                      dwDaclAceCount,
                      pDaclAces);

        if (dwError != ERROR_SUCCESS)
        {
            goto ErrorExit;
        }

        bSuccess = SetSecurityDescriptorDacl(
                       pSecurityDescriptor,
                       TRUE,
                       pDacl,
                       FALSE);

        if (!bSuccess)
        {
            dwError = GetLastError();
            goto ErrorExit;
        }
    }

    if (dwSaclAceCount)
    {
        dwError = CreateAcl(
                      &pSacl,
                      dwSaclAceCount,
                      pSaclAces);

        if (dwError != ERROR_SUCCESS)
        {
            goto ErrorExit;
        }

        bSuccess = SetSecurityDescriptorSacl(
                       pSecurityDescriptor,
                       TRUE,
                       pSacl,
                       FALSE);

        if (!bSuccess)
        {
            dwError = GetLastError();
            goto ErrorExit;
        }
    }

    *ppSecurityDescriptor = pSecurityDescriptor;

    return ERROR_SUCCESS;

ErrorExit:

    if (pDacl)
    {
        LocalFree(pDacl);
    }

    if (pSacl)
    {
        LocalFree(pSacl);
    }

    if (pSecurityDescriptor)
    {
        LocalFree(pSecurityDescriptor);
    }

    return dwError;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityDescriptor
//
//  Synopsis:   Deallocate the security descriptor allocated in
//              CreateSecurityDescriptor.
//
//  Arguments:  [pSecurityDescriptor] -- SD returned from
//                                       CreateSecurityDescriptor.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR        pSecurityDescriptor)
{
    BOOL                    bSuccess;
    BOOL                    fPresent;
    BOOL                    fDefaulted;
    PACL                    pAcl;

    if (pSecurityDescriptor == 0)
    {
        return;
    }

    pAcl = 0;

    bSuccess = GetSecurityDescriptorDacl(
                   pSecurityDescriptor,
                   &fPresent,
                   &pAcl,
                   &fDefaulted);

    if (bSuccess)
    {
        if (fPresent && pAcl != NULL)
        {
            LocalFree(pAcl);
        }
    }

    pAcl = 0;

    bSuccess = GetSecurityDescriptorSacl(
                   pSecurityDescriptor,
                   &fPresent,
                   &pAcl,
                   &fDefaulted);

    if (bSuccess)
    {
        if (fPresent && pAcl != NULL)
        {
            LocalFree(pAcl);
        }
    }

    LocalFree(pSecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAcl
//
//  Synopsis:   Creates an access control list.
//
//  Arguments:  [pAcl]         -- pointer to ACL.
//              [dwAclAceCount]-- number of ACEs.
//              [pAclAces]     -- ACE descriptions.
//
//  Returns:    win32 error code.
//
//  Notes:      Use LocalFree to delete pAcl once you are done with it.
//
//----------------------------------------------------------------------------
DWORD
CreateAcl(
    OUT PACL*                   ppAcl,
    IN  DWORD                   dwAclAceCount,
    IN  CONST ACE_DESC*         pAclAces
    )
{
    DWORD                   dwError         = ERROR_SUCCESS;
    BOOL                    bSuccess;
    DWORD                   dwAclLength     = sizeof(ACL);
    PACL                    pAcl            = 0;
    CONST ACE_DESC*         pAce;
    DWORD                   i;

    for (i=0,pAce=pAclAces;i < dwAclAceCount;i++,pAce++)
    {
        switch (pAce->Type)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            dwAclLength += sizeof(ACCESS_ALLOWED_ACE);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            dwAclLength += sizeof(ACCESS_DENIED_ACE);
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            dwAclLength += sizeof(SYSTEM_AUDIT_ACE);
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        dwAclLength -= sizeof(DWORD);
        dwAclLength += GetLengthSid(pAce->pSid);
    }

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, dwAclLength);

    if (pAcl == 0)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    bSuccess = InitializeAcl(
                   pAcl,
                   dwAclLength,
                   ACL_REVISION);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    for (i=0,pAce=pAclAces;i < dwAclAceCount;i++,pAce++)
    {
        switch (pAce->Type)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            bSuccess = AddAccessAllowedAceEx(
                           pAcl,
                           ACL_REVISION,
                           pAce->Flags,
                           pAce->AccessMask,
                           pAce->pSid);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            bSuccess = AddAccessDeniedAceEx(
                           pAcl,
                           ACL_REVISION,
                           pAce->Flags,
                           pAce->AccessMask,
                           pAce->pSid);
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            bSuccess = AddAuditAccessAceEx(
                           pAcl,
                           ACL_REVISION,
                           pAce->Flags,
                           pAce->AccessMask,
                           pAce->pSid,
                           FALSE,
                           FALSE);
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        if (!bSuccess)
        {
            dwError = GetLastError();
            goto ErrorExit;
        }
    }

    *ppAcl = pAcl;

    return ERROR_SUCCESS;

ErrorExit:

    if (pAcl)
    {
        LocalFree(pAcl);
    }

    return dwError;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnablePrivilege
//
//  Synopsis:   Tries to enable / disable a privilege for the current process.
//
//  Arguments:  [pszPrivName]  - name of privilege to enable / disable.
//              [bEnable]      - enable / disable switch.
//              [pbWasEnabled] - optional pointer to receive the previous
//                               state of the privilege.
//
//  Returns:    win32 error code.
//
//----------------------------------------------------------------------------
DWORD 
EnablePrivilege(
    IN  PCWSTR                  pszPrivName,
    IN  BOOL                    bEnable,
    OUT PBOOL                   pbWasEnabled    OPTIONAL
    )
{
    DWORD                   dwError         = ERROR_SUCCESS;
    BOOL                    bSuccess;
    HANDLE                  hToken          = 0;
    DWORD                   dwSize;
    TOKEN_PRIVILEGES        privNew;
    TOKEN_PRIVILEGES        privOld;

    bSuccess = OpenProcessToken(
                   GetCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &hToken);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    bSuccess = LookupPrivilegeValue(
                   0,
                   pszPrivName,
                   &privNew.Privileges[0].Luid);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    privNew.PrivilegeCount = 1;
    privNew.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

    bSuccess = AdjustTokenPrivileges(
                   hToken,
                   FALSE,
                   &privNew,
                   sizeof(privOld),
                   &privOld,
                   &dwSize);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    if (pbWasEnabled)
    {
        *pbWasEnabled = (privOld.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                            ? TRUE : FALSE;
    }

Cleanup:

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\setup\setup.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       setup.cxx
//
//  Contents:   Task Scheduler setup program
//
//  Classes:    None.
//
//  Functions:
//
//  History:    04-Apr-96  MarkBl    Created
//              23-Sep-96  AnirudhS  Added SetTaskFolderSecurity, etc.
//              30-Sep-96  AnirudhS  Added /firstlogon and /logon options
//              15-Nov-96  AnirudhS  Conditionally enable the service on NT too
//              01-09-97   DavidMun  Add sysagent.exe path value under
//                                      app paths, backup sysagent.exe
//              04-14-97   DavidMun  Add DoMemphisSetup
//              03-03-01   JBenton   Prefix BUG 333200 use of uninit memory
//              03-10-01   JBenton   BUG 142333 tighten Tasks folder security
//              October 01 Maxa      Updated security on Tasks folder in preparation for addition of auditing.
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <sddl.h>
#include <StrSafe.h>
#include "security.hxx"
#include "setupids.h"

#define ARRAY_LEN(a)                (sizeof(a)/sizeof((a)[0]))
#define ARG_DELIMITERS              TEXT(" \t")
#define MINUTES_BEFORE_IDLE_DEFAULT 15
#define MAX_LOG_SIZE_DEFAULT (0x20)

//
// Note that the svchost registry keys to run schedule service as a part
// of netsvcs is set in hivesft.inx file.
//
#define SCHED_SETUP_SWITCH      TEXT("/setup")
#define SCHED_SERVICE_EXE_PATH      TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs")
#define SCHED_SERVICE_DLL           TEXT("MSTask.dll")
#define SCHED_SERVICE_NAME          TEXT("Schedule")
#define SCHED_SERVICE_GROUP         TEXT("SchedulerGroup")
#define MINUTESBEFOREIDLE           TEXT("MinutesBeforeIdle")
#define MAXLOGSIZEKB                TEXT("MaxLogSizeKB")
#define TASKSFOLDER                 TEXT("TasksFolder")
#define FIRSTBOOT                   TEXT("FirstBoot")
#define SM_SA_KEY                   TEXT("Software\\Microsoft\\SchedulingAgent")

//
// Entry points from mstask.dll
// Note they are used with GetProcAddress, which always wants an ANSI string.
//
#define CONVERT_AT_TASKS_API        "ConvertAtJobsToTasks"

//
// Function pointer types used when loading above functions from mstask.dll
//

typedef HRESULT (__stdcall *PSTDAPI)(void);
typedef BOOL (__stdcall *PBOOLAPI)(void);
typedef VOID (__stdcall *PVOIDAPI)(void);

typedef struct _MYSIDINFO {
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    DWORD                     dwSubAuthority;
    DWORD                     dwSubSubAuthority;
    PSID                      pSid;
} MYSIDINFO;

DWORD SetTaskFolderSecurity(LPCWSTR pwszFolderPath);
DWORD AllocateAndInitializeDomainSid(
            PSID        pDomainSid,
            MYSIDINFO * pDomainSidInfo);

void DoSetup(void);
void ErrorDialog(UINT ErrorFmtStringID, TCHAR * szRoutine, DWORD ErrorCode);

HINSTANCE ghInstance = NULL;

//+----------------------------------------------------------------------------
//
//  Function:   WinMainCRTStartup
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
void _cdecl
main(int argc, char ** argv)
{
    //
    // Skip EXE name and find first parameter, if any
    //
    LPTSTR ptszStart;
    LPTSTR szArg1 = _tcstok(ptszStart = GetCommandLine(), ARG_DELIMITERS);
    szArg1 = _tcstok(NULL, ARG_DELIMITERS);
    //
    // Switch based on the first parameter
    //
    if (szArg1 == NULL)
    {
        ;   // Do nothing
    }
    else if (lstrcmpi(szArg1, SCHED_SETUP_SWITCH) == 0)
    {
        DoSetup();
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DoSetup
//
//  Synopsis:   Performs the normal setup procedure
//
//-----------------------------------------------------------------------------
void
DoSetup(void)
{
#define SCHED_SERVICE_DEPENDENCY    L"RpcSs\0"
#define SCC_AT_SVC_KEY L"System\\CurrentControlSet\\Services\\Schedule"
#define TASKS_FOLDER_DEFAULT        L"%SystemRoot%\\Tasks"

    TCHAR szTasksFolder[MAX_PATH + 1] = TEXT("");
    TCHAR tszDisplayName[50];       // "Task Scheduler"
    DWORD dwTmp;
    HKEY  hKey;

    //
    //  Disable hard-error popups.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    ghInstance = GetModuleHandle(NULL);

    //
    // Load the service display name.
    //
    int cch = LoadString(ghInstance, IDS_SERVICE_DISPLAY_NAME, tszDisplayName,
                         ARRAY_LEN(tszDisplayName));
    if (!(0 < cch && cch < ARRAY_LEN(tszDisplayName) - 1))
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("LoadString"),
                    GetLastError());
        return;
    }

    //
    // Create/open the Scheduling Agent key in Software\Microsoft.
    //
    LONG lErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               SM_SA_KEY,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               &dwTmp);

    if (ERROR_SUCCESS != lErr)
    {
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("RegCreateKeyEx"), lErr);
        return;
    }

    // Creator/Owner, System, Builtin Admins: Full control, 
    // Authenticated users: generic read
    WCHAR pwszSDDL[] = L"D:P(A;OICIIO;FA;;;CO)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)(A;OICI;GR;;;AU)";   
    PSECURITY_DESCRIPTOR pSD = NULL;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(pwszSDDL, SDDL_REVISION_1, &pSD, NULL))
    {
        lErr = (GetLastError());
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("ConvertStringSecurityDescriptorToSecurityDescriptorW"), lErr);
        RegCloseKey(hKey);
        return;
    }

    lErr = RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, pSD);  
    LocalFree(pSD);
    if (ERROR_SUCCESS != lErr)
    {
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("RegSetKeySecurity"), lErr);
        RegCloseKey(hKey);
        return;
    }

    // Set MinutesBeforeIdle to a default value of 15 mins.
    //
    dwTmp = MINUTES_BEFORE_IDLE_DEFAULT;
    lErr = RegSetValueEx(hKey,
                  MINUTESBEFOREIDLE,
                  0,
                  REG_DWORD,
                  (CONST BYTE *)&dwTmp,
                  sizeof(dwTmp));

    if (ERROR_SUCCESS != lErr)
    {
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("RegSetValueEx"), lErr);
        RegCloseKey(hKey);
        return;
    }

    // Set MaxLogSizeKB to 32K or 0x7FFF.
    //
    dwTmp = MAX_LOG_SIZE_DEFAULT;
    lErr = RegSetValueEx(hKey,
                  MAXLOGSIZEKB,
                  0,
                  REG_DWORD,
                  (CONST BYTE *)&dwTmp,
                  sizeof(dwTmp));

    if (ERROR_SUCCESS != lErr)
    {
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("RegSetValueEx"), lErr);
        RegCloseKey(hKey);
        return;
    }

    // Read the tasks folder location. The .INF should've set this.
    // If not, default.
    //
    dwTmp = MAX_PATH * sizeof(TCHAR);
    if (RegQueryValueEx(hKey,
                        TASKSFOLDER,
                        NULL,
                        NULL,
                        (LPBYTE)szTasksFolder,
                        &dwTmp) != ERROR_SUCCESS  ||
        szTasksFolder[0] == TEXT('\0'))
    {
        StringCchCopy(szTasksFolder, MAX_PATH + 1, TASKS_FOLDER_DEFAULT);
    }    

    // Set FirstBoot to non-zero.
    //
    dwTmp = 1;
    lErr = RegSetValueEx(hKey,
                  FIRSTBOOT,
                  0,
                  REG_DWORD,
                  (CONST BYTE *)&dwTmp,
                  sizeof(dwTmp));

    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lErr)
    {
        ErrorDialog(IDS_INSTALL_FAILURE, TEXT("RegSetValueEx"), lErr);
        return;
    }

    //
    // Set the right permissions on the job folder.
    // The default permissions allow anyone to delete any job, which we
    // don't want.
    //
    {
        TCHAR szTaskFolderPath[MAX_PATH + 1];
        DWORD cch = ExpandEnvironmentStrings(szTasksFolder,
                                             szTaskFolderPath,
                                             ARRAY_LEN(szTaskFolderPath));
        if (cch == 0 || cch > ARRAY_LEN(szTaskFolderPath))
        {
            //
            // The job folder path is too long.
            //
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("ExpandEnvironmentStrings"),
                        cch ? ERROR_BUFFER_OVERFLOW : GetLastError());
            return;
        }

        DWORD dwError = SetTaskFolderSecurity(szTaskFolderPath);
        if (dwError != ERROR_SUCCESS)
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("SetTaskFolderSecurity"),
                        dwError);
            return;
        }
    }

    HINSTANCE hinstMSTask = LoadLibrary(SCHED_SERVICE_DLL);
    if (!hinstMSTask)
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    SCHED_SERVICE_DLL,
                    GetLastError());
        return;
    }

    PVOIDAPI pfnConvertLegacyJobsToTasks = (PVOIDAPI)
        GetProcAddress(hinstMSTask, CONVERT_AT_TASKS_API);

    if (!pfnConvertLegacyJobsToTasks)
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("GetProcAddress"),
                    GetLastError());
        return;
    }

    pfnConvertLegacyJobsToTasks();

    //
    // Install the Win32 service.
    //

    SC_HANDLE hSCMgr = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (hSCMgr == NULL)
    {
        //
        // Yow, we're hosed.
        //

        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("OpenSCManager"),
                    GetLastError());
        return;
    }


    //
    // Is the service already installed? If so, change its parameters;
    // otherwise, create it.
    //

    SC_HANDLE hSvc = OpenService(hSCMgr,
                                 SCHED_SERVICE_NAME,
                                 SERVICE_CHANGE_CONFIG | SERVICE_START);

    if (hSvc == NULL)
    {
        hSvc = CreateService(hSCMgr,
                             SCHED_SERVICE_NAME,
                             tszDisplayName,
                             SERVICE_CHANGE_CONFIG | SERVICE_START,
                             SERVICE_WIN32_SHARE_PROCESS,
                             SERVICE_AUTO_START,
                             SERVICE_ERROR_NORMAL,
                             SCHED_SERVICE_EXE_PATH,
                             SCHED_SERVICE_GROUP,
                             NULL,
                             SCHED_SERVICE_DEPENDENCY,
                             NULL,
                             NULL);

        if (hSvc == NULL)
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("CreateService"),
                        GetLastError());
            CloseServiceHandle(hSCMgr);
            return;
        }
    }
    else
    {
        //
        // This path will be followed when we upgrade the At service
        // to the Scheduling Agent.  The service name will remain the
        // same, but the display name will be set to the new display
        // name (the At service had no display name) and the image path
        // will be changed to point to the new exe.
        // (The old binary will be left on disk in order to make it easy
        // to revert to it, in case of compatibility problems.)
        //
        if (!ChangeServiceConfig(
                hSvc,                               // hService
                SERVICE_WIN32_SHARE_PROCESS,   // dwServiceType
                SERVICE_AUTO_START,                 // dwStartType
                SERVICE_ERROR_NORMAL,               // dwErrorControl
                SCHED_SERVICE_EXE_PATH,             // lpBinaryPathName
                SCHED_SERVICE_GROUP,                // lpLoadOrderGroup
                NULL,                               // lpdwTagId
                SCHED_SERVICE_DEPENDENCY,           // lpDependencies
                L".\\LocalSystem",                  // lpServiceStartName
                L"",                                // lpPassword
                tszDisplayName                      // lpDisplayName
                ))
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("ChangeServiceConfig"),
                        GetLastError());
            CloseServiceHandle(hSvc);
            CloseServiceHandle(hSCMgr);
            return;
        }
    }

    // in either case, set the recovery options
    // not checking return - it's a minor glitch, no need to upset the user    
    SC_ACTION actions[3] = {{SC_ACTION_RESTART, 6000},{SC_ACTION_RESTART, 60000},{SC_ACTION_NONE, 0}};
    SERVICE_FAILURE_ACTIONS recoveryInfo = {24*60*60, NULL, NULL, 3, &(actions[0])};
    ChangeServiceConfig2(hSvc,SERVICE_CONFIG_FAILURE_ACTIONS, (LPVOID)&recoveryInfo);

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSCMgr);
}

//+----------------------------------------------------------------------------                                                                                                   
//
//  Function:   ErrorDialog
//
//  Synopsis:   Displays an error message.
//
//-----------------------------------------------------------------------------
void
ErrorDialog(UINT ErrorFmtStringID, TCHAR * szRoutine, DWORD ErrorCode)
{
#define ERROR_BUFFER_SIZE (MAX_PATH * 2)

    TCHAR szErrorFmt[MAX_PATH + 1] = TEXT("");
    TCHAR szError[ERROR_BUFFER_SIZE + 1];
    TCHAR * pszError = szError;

    LoadString(ghInstance, ErrorFmtStringID, szErrorFmt, MAX_PATH);

    if (*szErrorFmt)
    {
        StringCchPrintf(szError, ERROR_BUFFER_SIZE + 1, szErrorFmt, szRoutine, ErrorCode);
    }
    else
    {
        //
        // Not a localizable string, but done just in case LoadString
        // should fail for some reason.
        //

        StringCchCopy(szErrorFmt, MAX_PATH + 1, TEXT("Error installing Task Scheduler; error = 0x%x"));
        StringCchPrintf(szError, ERROR_BUFFER_SIZE + 1, szErrorFmt, ErrorCode);
    }

    MessageBox(NULL, szError, NULL, MB_ICONSTOP | MB_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetTaskFolderSecurity
//
//  Synopsis:   Grant the following permissions to the task folder:
//
//                  LocalSystem             All Access.
//                  Domain Administrators   All Access.
//                  World                   RWX Access (no permission to delete
//                                          child files).
//
//  Arguments:  [pwszFolderPath] -- Task folder path.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
SetTaskFolderSecurity(LPCWSTR pwszFolderPath)
{
    DWORD                   dwError             = ERROR_SUCCESS;
    BOOL                    bSuccess;
    BOOL                    bWasEnabled         = FALSE;
    BOOL                    bSetSacl            = TRUE;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;
    DWORD                   i;
    SECURITY_INFORMATION    dwSecInfo           = 0;

    const DWORD             c_dwBaseSidCount    = 6;
    const DWORD             c_dwDomainSidCount  = 3;
    const DWORD             c_dwDaclAceCountSrv    = 5;
    const DWORD             c_dwDaclAceCountWks    = 4;
    const DWORD             c_dwSaclAceCount    = 2;


    //
    // Build the SIDs that will go in the security descriptor.
    //

    SID_IDENTIFIER_AUTHORITY NtAuth       = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuth    = SECURITY_WORLD_SID_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY CreatorAuth  = SECURITY_CREATOR_SID_AUTHORITY;

    MYSIDINFO rgBaseSidInfo[c_dwBaseSidCount] =
    {
        {
            &NtAuth,                          // Local System.
            SECURITY_LOCAL_SYSTEM_RID,
            NULL
        },
        {
            &NtAuth,                          // Built in domain.  (Used for
            SECURITY_BUILTIN_DOMAIN_RID,      // domain admins SID.)
            NULL
        },
        {
            &NtAuth,                          // Authenticated user.
            SECURITY_AUTHENTICATED_USER_RID,
            NULL
        },
        {
            &CreatorAuth,                     // Creator.
            SECURITY_CREATOR_OWNER_RID,
            NULL
        },
        {
            &WorldAuth,                       // Everyone.
            SECURITY_WORLD_RID,
            NULL
        },
        {
            &NtAuth,                          // Anonymous.
            SECURITY_ANONYMOUS_LOGON_RID,
            NULL
        },


    };

    MYSIDINFO rgDomainSidInfo[c_dwDomainSidCount] =
    {
        {
            NULL,                           // Domain administrators.
            DOMAIN_ALIAS_RID_ADMINS,
            NULL
        },
        {
            NULL,                          // Server Operators.
            DOMAIN_ALIAS_RID_SYSTEM_OPS,
            NULL
        },
        {
            NULL,                          // Backup Operators.
            DOMAIN_ALIAS_RID_BACKUP_OPS,
            NULL
        }
    };


    //
    // Create the base SIDs.
    //

    for (i = 0; i < c_dwBaseSidCount; i++)
    {
        if (!AllocateAndInitializeSid(
                 rgBaseSidInfo[i].pIdentifierAuthority,
                 1,
                 rgBaseSidInfo[i].dwSubAuthority,
                 0, 0, 0, 0, 0, 0, 0,
                 &rgBaseSidInfo[i].pSid))
        {
            dwError = GetLastError();
            break;
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        //
        // Create the domain SIDs.
        //

        for (i = 0; i < c_dwDomainSidCount; i++)
        {
            dwError = AllocateAndInitializeDomainSid(
                          rgBaseSidInfo[1].pSid,
                          &rgDomainSidInfo[i]);

            if (dwError != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    //
    // Create the security descriptor.
    //

    ACE_DESC            rgDaclAcesSrv[c_dwDaclAceCountSrv] =
    {
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgBaseSidInfo[0].pSid          // Local System
        },
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgDomainSidInfo[0].pSid        // Domain admins
        },
        {
            FILE_GENERIC_READ | FILE_GENERIC_EXECUTE | FILE_WRITE_DATA,
            ACCESS_ALLOWED_ACE_TYPE,
            0,
            rgDomainSidInfo[1].pSid          // Backup Operators
        },
        {
            FILE_GENERIC_READ | FILE_GENERIC_EXECUTE | FILE_WRITE_DATA,
            ACCESS_ALLOWED_ACE_TYPE,
            0,
            rgDomainSidInfo[2].pSid          // Server Operators
        },
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
		    OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
            rgBaseSidInfo[3].pSid          // Creator
        }
    };

    ACE_DESC            rgDaclAcesWks[c_dwDaclAceCountWks] =
    {
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgBaseSidInfo[0].pSid          // Local System
        },
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgDomainSidInfo[0].pSid        // Domain admins
        },
        {
            FILE_GENERIC_READ | FILE_GENERIC_EXECUTE | FILE_WRITE_DATA,
            ACCESS_ALLOWED_ACE_TYPE,
            0,
            rgBaseSidInfo[2].pSid          // Authenticated user
        },
        {
            FILE_ALL_ACCESS,
            ACCESS_ALLOWED_ACE_TYPE,
		    OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
            rgBaseSidInfo[3].pSid          // Creator
        }
    };

    ACE_DESC            rgSaclAces[c_dwSaclAceCount] =
    {
        {
            FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC | WRITE_OWNER,
            SYSTEM_AUDIT_ACE_TYPE,
            SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG | OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgBaseSidInfo[4].pSid          // Everyone
        },
        {
            FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC | WRITE_OWNER,
            SYSTEM_AUDIT_ACE_TYPE,
            SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG | OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
            rgBaseSidInfo[5].pSid          // Anonymous
        }
    };

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    // different security on workstation vs server

    OSVERSIONINFOEX verInfo;
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFOW)&verInfo))
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }


    if (verInfo.wProductType == VER_NT_WORKSTATION)
    {

        dwError = CreateSecurityDescriptor(
                      &pSecurityDescriptor,
                      c_dwDaclAceCountWks,
                      rgDaclAcesWks,
                      c_dwSaclAceCount,
                      rgSaclAces);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

    }
    else
    {
        dwError = CreateSecurityDescriptor(
                      &pSecurityDescriptor,
                      c_dwDaclAceCountSrv,
                      rgDaclAcesSrv,
                      c_dwSaclAceCount,
                      rgSaclAces);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }



    //
    // Enable SecurityPrivilege in order to be able
    // to set the SACL.
    //

    dwError = EnablePrivilege(
                  SE_SECURITY_NAME,
                  TRUE,
                  &bWasEnabled);

    if (dwError != ERROR_SUCCESS)
    {
        bSetSacl = FALSE;
    }


    //
    // Finally, set permissions.
    //

    dwSecInfo |= DACL_SECURITY_INFORMATION;

    if (bSetSacl && c_dwSaclAceCount)
    {
        dwSecInfo |= SACL_SECURITY_INFORMATION;
    }

    bSuccess = SetFileSecurity(
                   pwszFolderPath,
                   dwSecInfo,
                   pSecurityDescriptor);



    if (!bWasEnabled)
    {
        EnablePrivilege(
            SE_SECURITY_NAME,
            FALSE,
            0);
    }

    

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    for (i = 0; i < c_dwBaseSidCount; i++)
    {
        if (rgBaseSidInfo[i].pSid != NULL)
        {
            FreeSid(rgBaseSidInfo[i].pSid);
        }
    }
    for (i = 0; i < c_dwDomainSidCount; i++)
    {
        LocalFree(rgDomainSidInfo[i].pSid);
    }
    if (pSecurityDescriptor != NULL)
    {
        DeleteSecurityDescriptor(pSecurityDescriptor);
    }

    return dwError;
}


//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeDomainSid
//
//  Synopsis:
//
//  Arguments:  [pDomainSid]     --
//              [pDomainSidInfo] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
AllocateAndInitializeDomainSid(
    PSID        pDomainSid,
    MYSIDINFO * pDomainSidInfo)
{
    UCHAR DomainIdSubAuthorityCount;
    DWORD SidLength;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount(pDomainSid));
    SidLength = GetSidLengthRequired(DomainIdSubAuthorityCount + 1);

    pDomainSidInfo->pSid = (PSID) LocalAlloc(0, SidLength);

    if (pDomainSidInfo->pSid == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize the new SID to have the same initial value as the
    // domain ID.
    //

    if (!CopySid(SidLength, pDomainSidInfo->pSid, pDomainSid))
    {
        LocalFree(pDomainSidInfo->pSid);
        pDomainSidInfo->pSid = NULL;
        return(GetLastError());
    }

    //
    // Adjust the sub-authority count and add the relative Id unique
    // to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount(pDomainSidInfo->pSid)))++;
    *(GetSidSubAuthority(pDomainSidInfo->pSid,
                         DomainIdSubAuthorityCount)) =
                                            pDomainSidInfo->dwSubAuthority;

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\auditing.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright(C) 2001 - 2002 Microsoft Corporation
//
//  File: auditing.cxx
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#include "authzi.h"
#include "msaudite.h"
#include "security.hxx"
#include "auditing.hxx"

AUTHZ_RESOURCE_MANAGER_HANDLE ghRM             = 0;
AUTHZ_AUDIT_EVENT_TYPE_HANDLE ghAuditEventType = 0;

HRESULT
AuditATJob(const AT_INFO &AtInfo, LPCWSTR pwszFileName)
{
    HRESULT hr = S_OK;

    //
    // Impersonate the caller
    //
    DWORD RpcStatus = RpcImpersonateClient(NULL);
    if (RpcStatus != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        return hr;
    }

    //
    // Open the thread token
    //
    HANDLE hThreadToken = NULL;
    BOOL bTokenOpened = OpenThreadToken(GetCurrentThread(),
                                        TOKEN_QUERY,        // Desired access.
                                        TRUE,               // Open as self.
                                        &hThreadToken);
    //
    // End impersonation.
    //
    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        ERR_OUT("RpcRevertToSelf", RpcStatus);
        schAssert(!"RpcRevertToSelf failed");
        hr = _HRESULT_FROM_WIN32(RpcStatus);
    }

    if (SUCCEEDED(hr))
    {
        if (bTokenOpened)    
        {
    
            DWORD cbAccountSid = MAX_SID_SIZE;
            BYTE  pbTaskSid[MAX_SID_SIZE];
        
            hr = GetNSAccountSid(pbTaskSid, cbAccountSid);
            if (SUCCEEDED(hr))
            {
                hr = AuditJob(hThreadToken, pbTaskSid, pwszFileName);
            }
    
            CloseHandle(hThreadToken);
        }
        else
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}


HRESULT
AuditJob(
    HANDLE hThreadToken, 
    PSID pTaskSid, 
    LPCWSTR pwszFileName
)
{
    //
    //    Caller has already been impersonated and thread token opened prior to calling of this function
    //
    
    HRESULT hr = S_OK;

    //
    // Get the user SID
    //
    BYTE        rgbTokenInformation[USER_TOKEN_STACK_BUFFER_SIZE];
    TOKEN_USER* pTokenUser = (TOKEN_USER*) rgbTokenInformation;
    DWORD       cbReturnLength;
    
    if (GetTokenInformation(hThreadToken,
                            TokenUser,
                            pTokenUser,
                            USER_TOKEN_STACK_BUFFER_SIZE,
                            &cbReturnLength))
    {
        //
        // Get the Authentication ID
        //
        BYTE              rgbTokenStatistics[sizeof(TOKEN_STATISTICS)];
        TOKEN_STATISTICS* pTokenStatistics = (TOKEN_STATISTICS*) rgbTokenStatistics;
        if (GetTokenInformation(hThreadToken,
                                TokenStatistics,
                                pTokenStatistics,
                                sizeof(TOKEN_STATISTICS),
                                &cbReturnLength))
        {
            DWORD dwRet = GenerateJobCreatedAudit(pTokenUser->User.Sid, 
                                                  pTaskSid, 
                                                  &(pTokenStatistics->AuthenticationId), 
                                                  pwszFileName);
            hr = _HRESULT_FROM_WIN32(dwRet);
        }
        else
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;

}


HRESULT
GetJobAuditInfo(
    LPCWSTR pwszFileName, 
    DWORD* pdwFlags,
    LPWSTR* ppwszCommandLine,
    LPWSTR* ppwszTriggers,
    FILETIME* pftNextRun
)
{
    if (!pwszFileName || pwszFileName[0] == L'\0' || !pftNextRun || !ppwszTriggers)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Init
    //
    *pdwFlags = 0;
    *ppwszCommandLine = NULL;
    *ppwszTriggers = NULL;
    
    //
    // Instantiate the job to get its run properties.
    //
    CJob* pJob = CJob::Create();
    if (!pJob)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pJob->LoadP(pwszFileName, 0, FALSE, TRUE);
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "GetTriggerAuditInfo: pJob->LoadP failed with error 0x%x\n", hr));
    }
    else
    {
        //
        // Get the flags
        //
        pJob->GetAllFlags(pdwFlags);    // this call returns void
        
        //
        // Get the application
        //
        WCHAR* pwszApplicationName = NULL;

        hr = pJob->GetApplicationName(&pwszApplicationName);
        if (FAILED(hr))
        {
            schDebugOut((DEB_ERROR, "GetTriggerAuditInfo: pJob->GetApplicationName failed with error 0x%x\n", hr));
        }
        else
        {
            //
            // Get the parameters
            //
            WCHAR* pwszParameters = NULL;
            
            hr = pJob->GetParameters(&pwszParameters);
            if (FAILED(hr))
            {
                schDebugOut((DEB_ERROR, "GetTriggerAuditInfo: pJob->GetParameters failed with error 0x%x\n", hr));
            }
            else
            {
                //
                // Produce command line by concatenating application name and parameters
                //
                size_t cchBuff = lstrlenW(pwszApplicationName) + 1 + lstrlenW(pwszParameters) + 1;
                WCHAR* pwszCommandLine = new WCHAR[cchBuff];
                if (!pwszCommandLine)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    StringCchCopy(pwszCommandLine, cchBuff, pwszApplicationName);
                    StringCchCat(pwszCommandLine, cchBuff, L" ");
                    StringCchCat(pwszCommandLine, cchBuff, pwszParameters);

                    //
                    // Return pointer to the command line string. 
                    // This string will need to be deleted by the caller.
                    //
                    *ppwszCommandLine = pwszCommandLine;
    
                    //
                    // Zero out next run time return value in case of any failures.
                    // Get the next run time, convert it to a local file time then to UTC.
                    //
                    //pftNextRun->dwLowDateTime = 0;
                    //pftNextRun->dwHighDateTime = 0;
                    //
                    // due to temporary issues, use a different value than 0
                    // 1/1/1700 00:00:00,000
                    pftNextRun->dwLowDateTime = 0xAEC64000;
                    pftNextRun->dwHighDateTime = 0x006EFDDD;

                    SYSTEMTIME stNextRun;
                    hr = pJob->GetNextRunTime(&stNextRun);
                    if (S_OK == hr)
                    {
                        FILETIME ftNextRunLocal;
                        if (SystemTimeToFileTime(&stNextRun, &ftNextRunLocal))
                        {
                            LocalFileTimeToFileTime(&ftNextRunLocal, pftNextRun);
                        }
                    }
                    
                    //
                    // Now get the triggers.
                    //
                    // Build up a string consisting of formatted string 
                    // representations of all the triggers for the task.
                    //
                
                    WORD cTriggers;                    
                    hr = pJob->GetTriggerCount(&cTriggers);
                    if (FAILED(hr))
                    {
                        schDebugOut((DEB_ERROR, "GetTriggerAuditInfo: pJob->GetTriggerCount failed with error 0x%x\n", hr));
                    }
                    else                
                    {
                        //
                        // Allocate initial buffer for concatenation of all trigger strings
                        //
                        const DWORD INITIAL_BUFFER_SIZE   = 256;                 // start with enough space for 256 chars including null
                        const DWORD BUFFER_SIZE_INCREMENT = 256;                 // if necessary, grow buffer by this amount
                        DWORD       dwSize                = INITIAL_BUFFER_SIZE;
                        WCHAR*      pwszTriggers          = new WCHAR[dwSize];   // this will need to be deleted by the caller

                        if (!pwszTriggers)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            pwszTriggers[0] = L'\0';

                            DWORD  dwSizeRequired;
                            WCHAR* pwszTemp;
                            WCHAR* pwszTriggerString;

                            for (short nTrigger = 0; nTrigger < cTriggers && SUCCEEDED(hr); nTrigger++)
                            {
                                hr = pJob->GetTriggerString(nTrigger, &pwszTriggerString);
                                if (FAILED(hr))
                                {
                                    schDebugOut((DEB_ERROR, "GetTriggerAuditInfo: pJob->GetTriggerString failed with error 0x%x\n", hr));
                                }
                                else
                                {
                                    //
                                    // If not big enough, create larger buffer, copy, and delete old
                                    //
                                    dwSizeRequired = lstrlenW(pwszTriggers)
                                                     + 2                            // two spaces
                                                     + lstrlenW(pwszTriggerString)
                                                     + 2;                           // period plus null terminator

                                    if (dwSizeRequired > dwSize)
                                    {
                                        dwSize += BUFFER_SIZE_INCREMENT;
                                        if (dwSizeRequired > dwSize)    // if still not big enough (very unlikely),
                                            dwSize = dwSizeRequired;    // make it big enough

                                        pwszTemp = new WCHAR[dwSize];
                                        if (!pwszTemp)
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                        else
                                        {
                                            StringCchCopy(pwszTemp, dwSize, pwszTriggers);
                                            delete [] pwszTriggers;
                                            pwszTriggers = pwszTemp;
                                        }
                                    }

                                    if (SUCCEEDED(hr))
                                    {
                                        if (lstrlenW(pwszTriggers) > 0)
                                            StringCchCat(pwszTriggers, dwSize, L"  ");
                                        
                                        StringCchCat(pwszTriggers, dwSize, pwszTriggerString);
                                        StringCchCat(pwszTriggers, dwSize, L".");
                                    }

                                    CoTaskMemFree(pwszTriggerString);
                                }
                            }

                            if (SUCCEEDED(hr))
                            {
                                //
                                // If all was a success, return the pointer to the string of triggers.
                                // This string will need to be deleted by the caller.
                                //
                                *ppwszTriggers = pwszTriggers;
                            }
                            else
                            {
                                //
                                // If something went wrong, let's go ahead and clean up now.
                                //
                                if (pwszTriggers)
                                    delete [] pwszTriggers;
                            }
                        }
                    }
                }

                CoTaskMemFree(pwszParameters);
            }

            CoTaskMemFree(pwszApplicationName);
        }
    }

    if (pJob)
    {
        pJob->Release();
    }

    return hr;
}


/***************************************************************************\
* FUNCTION:   StartupAuditing
*
* PURPOSE:    Creates the resource manager and the audit event type handles.
*
* PARAMETERS: 
*
* RETURNS:    win32 error code
*
* History:
* 12-05-2001 maxa    Created
*
\***************************************************************************/

DWORD
StartupAuditing(
)
{
    DWORD dwError     = ERROR_SUCCESS;
    BOOL  fResult     = FALSE;
    BOOL  fWasEnabled = TRUE;

    if (ghRM && ghAuditEventType)
    {
        goto Cleanup;
    }

    dwError = EnableNamedPrivilege(
        L"SeAuditPrivilege",
        TRUE,
        &fWasEnabled);

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    fResult = AuthzInitializeResourceManager(
        0,              // no special flags
        NULL,           // PFN_AUTHZ_DYNAMIC_ACCESS_CHECK
        NULL,           // PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS
        NULL,           // PFN_AUTHZ_FREE_DYNAMIC_GROUPS
        L"Scheduler",   // RM name
        &ghRM
    );

    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    fResult = AuthziInitializeAuditEventType(
        0,
        SE_CATEGID_DETAILED_TRACKING, 
        SE_AUDITID_JOB_CREATED,
        7,
        &ghAuditEventType
    );

    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (!fWasEnabled)
    {
        EnableNamedPrivilege(
            L"SeAuditPrivilege",
            FALSE,
            &fWasEnabled);
    }

    if (dwError != ERROR_SUCCESS)
    {
        ShutdownAuditing();
    }

    return dwError;
}


/***************************************************************************\
* FUNCTION:   ShutdownAuditing
*
* PURPOSE:    Deletes the resource manager and the audit event type handles.
*
* PARAMETERS: 
*
* RETURNS:    
*
* History:
* 12-05-2001 maxa   Created
*
\***************************************************************************/

VOID
ShutdownAuditing(
)
{
    if (ghAuditEventType)
    {
        AuthziFreeAuditEventType(ghAuditEventType);
        ghAuditEventType = 0;
    }

    if (ghRM)
    {
        AuthzFreeResourceManager(ghRM);
        ghRM = 0;
    }
}


/***************************************************************************\
* FUNCTION:   GenerateJobCreatedAudit
*
* PURPOSE:    Generates an audit-event indicating that a job has
*             been created.
*
* PARAMETERS: pUserSid:
*               SID of the account that created the job.
*             pTaskSid:
*               SID of the account the job is to run as.
*             pLogonId:
*               LogonId of the account that created the job.
*             pszFileName:
*               File name of the newly created job in the Tasks folder.
*
* RETURNS:    win32 error code
*
* History:
* 10-01-2001 maxa       Created
* 11-07-2001 shbrown    Updated for use with tasks rather than AT jobs
*
\***************************************************************************/

DWORD
GenerateJobCreatedAudit(
    IN PSID pUserSid,
    IN PSID pTaskSid,
    IN PLUID pLogonId,
    IN PCWSTR pwszFileName
)
{
    DWORD                       dwError         = ERROR_SUCCESS;
    BOOL                        fResult         = FALSE;
    AUTHZ_AUDIT_EVENT_HANDLE    hAuditEvent     = NULL;
    AUDIT_PARAMS                AuditParams     = {0};
    AUDIT_PARAM                 ParamArray[10]  = {APT_None};
    PSID                        pDummySid       = NULL;

    ASSERT(pUserSid);
    ASSERT(pTaskSid);
    ASSERT(pLogonId);
    ASSERT(pwszFileName && pwszFileName[0]);
    ASSERT(ghRM);
    ASSERT(ghAuditEventType);


    //
    // Get the job audit info
    //
    DWORD       dwFlags;
    LPWSTR      pwszCommandLine = NULL;     // this will need to be deleted after use
    LPWSTR      pwszTriggers    = NULL;     // this will need to be deleted after use
    FILETIME    ftNextRun;
    HRESULT     hr = GetJobAuditInfo(pwszFileName,  &dwFlags, &pwszCommandLine, &pwszTriggers, &ftNextRun);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    AuditParams.Parameters = ParamArray;

    fResult = AuthziInitializeAuditParams(
        APF_AuditSuccess,
        &AuditParams,
        &pDummySid,
        L"Security",
        7,
        APT_String | AP_Filespec,   pwszFileName,
        APT_String,                 pwszCommandLine,
        APT_String,                 pwszTriggers,
        APT_Time,                   ftNextRun,
        APT_Ulong  | AP_FormatHex,  dwFlags,
        APT_Sid,                    pTaskSid,
        APT_LogonId,                *pLogonId
        );

    if (!fResult)
    {
        goto Error;
    }

    //
    // this is ugly, but currently there is no other way
    // do we still need this?
    //

    ParamArray[0].Data0 = (ULONG_PTR)pUserSid;

    fResult = AuthziInitializeAuditEvent(
        0,                  // flags
        ghRM,               // resource manager
        ghAuditEventType,
        &AuditParams,
        NULL,               // hAuditQueue
        INFINITE,           // time out
        L"", L"", L"", L"", // obj access strings
        &hAuditEvent
    );

    if (!fResult)
    {
        goto Error;
    }

    fResult = AuthziLogAuditEvent(
        0,          // flags
        hAuditEvent,
        NULL        // reserved
    );

    if (!fResult)
    {
        goto Error;
    }

Cleanup:

    if (pwszCommandLine)
    {
        delete [] pwszCommandLine;
    }

    if (pwszTriggers)
    {
        delete [] pwszTriggers;
    }

    if (hAuditEvent)
    {
        AuthzFreeAuditEvent(hAuditEvent);
    }

    if (pDummySid)
    {
        LocalFree(pDummySid);
    }

    return dwError;


Error:

    dwError = GetLastError();
    goto Cleanup;
}


/***************************************************************************\
* FUNCTION:   EnableNamedPrivilege
*
* PURPOSE:    Enable or disable a privilege by its name.
*
* PARAMETERS: pszPrivName:
*               Name of privilege to enable.
*             fEnable:
*               Enable/Disable flag.
*             pfWasEnabled:
*               Optional pointer to flag to receive the previous state.
*
* RETURNS:    win32 error code
*
* History:
* 12-05-2001 maxa   Created
*
\***************************************************************************/

DWORD
EnableNamedPrivilege(
    IN  PCWSTR  pszPrivName,
    IN  BOOL    fEnable,
    OUT PBOOL   pfWasEnabled    OPTIONAL
)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fResult;
    HANDLE                  hToken  = 0;
    DWORD                   dwSize  = 0;
    TOKEN_PRIVILEGES        newPriv;
    TOKEN_PRIVILEGES        oldPriv;

    fResult = OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &hToken);

    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    fResult = LookupPrivilegeValue(
                0,
                pszPrivName,
                &newPriv.Privileges[0].Luid);

    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    newPriv.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
    newPriv.PrivilegeCount = 1;

    fResult = AdjustTokenPrivileges(
                hToken,
                FALSE,
                &newPriv,
                sizeof oldPriv,
                &oldPriv,
                &dwSize);

    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    if (pfWasEnabled)
    {
        if (oldPriv.PrivilegeCount == 0)
        {
            *pfWasEnabled = fEnable;
        }
        else
        {
            *pfWasEnabled =
                (oldPriv.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ?
                    TRUE : FALSE;
        }
    }

Cleanup:

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\atsec.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       atsec.cxx
//
//  Contents:   Net Schedule API access checking routines.
//
//  Functions:  AtCheckSecurity
//              AtCreateSecurityObject
//              AtDeleteSecurityObject
//
//  History:    06-Nov-92   vladimv created.
//              30-May-96   EricB adapted for the scheduling agent.
//
//----------------------------------------------------------------------------

//
// Some NT header definitions conflict with some of the standard windows
// definitions. Thus, the project precompiled header can't be used.
//
extern "C" {
#include <nt.h>                 //  NT definitions
#include <ntrtl.h>              //  NT runtime library definitions
#include <nturtl.h>
#include <netevent.h>
}

#include <windef.h>             //  Win32 type definitions
#include <winbase.h>            //  Win32 base API prototypes
#include <winsvc.h>             //  Win32 service control APIs
#include <winreg.h>             //  HKEY

#include <lmcons.h>             //  LAN Manager common definitions
#include <lmerr.h>              //  LAN Manager network error definitions
#include <netlib.h>             //  LAN Man utility routines
#include <netlibnt.h>           //  NetpNtStatusToApiStatus
#include <rpc.h>                //  DataTypes and runtime APIs
#include <rpcutil.h>            //  Prototypes for MIDL user functions
#include <secobj.h>             //  ACE_DATA

#include <..\..\..\smdebug\smdebug.h>
#include <debug.hxx>

#include "atsec.hxx"

//
// Security descriptor to control user access to the AT schedule service
// configuration information.
//
PSECURITY_DESCRIPTOR AtGlobalSecurityDescriptor = NULL;

#define AT_JOB_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED   |   \
                             AT_JOB_ADD                 |   \
                             AT_JOB_DEL                 |   \
                             AT_JOB_ENUM                |   \
                             AT_JOB_GET_INFO)

//
// Structure that describes the mapping of Generic access rights to
// object specific access rights for the AT schedule service security object.
//
GENERIC_MAPPING     AtGlobalInformationMapping = {

    STANDARD_RIGHTS_READ        |           // Generic read
        AT_JOB_ENUM             |
        AT_JOB_GET_INFO,
    STANDARD_RIGHTS_WRITE       |           // Generic write
        AT_JOB_ADD              |
        AT_JOB_DEL,
    STANDARD_RIGHTS_EXECUTE,                // Generic execute
    AT_JOB_ALL_ACCESS                       // Generic all
};

//+---------------------------------------------------------------------------
//
//  Function:   AtCheckSecurity
//
//  Synopsis:   Verify that the caller has the proper privilege.
//
//  Arguments:  [DesiredAccess] - the type of access.
//
//  Returns:    NERR_Success or reason for failure.
//
//  Notes:      This routine checks if an rpc caller is allowed to perform a
//              given AT service operation. Members of the groups LocalAdmin
//              and LocalBackupOperators are allowed to do all operations and
//              everybody else is not allowed to do anything.
//
//----------------------------------------------------------------------------
NET_API_STATUS
AtCheckSecurity(ACCESS_MASK DesiredAccess)
{
    NTSTATUS        NtStatus;
    NET_API_STATUS  Status;
    HANDLE          ClientToken;
    LPWSTR          StringArray[2];
    WCHAR           ErrorCodeString[25];

    if ((Status = RpcImpersonateClient(NULL)) != NERR_Success)
    {
        ERR_OUT("RpcImpersonateClient", Status);
        return Status;
    }

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                 TOKEN_QUERY,
                                 (BOOLEAN)TRUE,
                                 &ClientToken);

    if (NtStatus != STATUS_SUCCESS)
    {
        ERR_OUT("NtOpenThreadToken", NtStatus);
    }
    else
    {
        PRIVILEGE_SET       PrivilegeSet;
        DWORD               PrivilegeSetLength;
        ACCESS_MASK         GrantedAccess;
        NTSTATUS            AccessStatus;

        PrivilegeSetLength = sizeof( PrivilegeSet);

        //  NtAccessCheck() returns STATUS_SUCCESS if parameters
        //  are correct.  Whether or not access is allowed is
        //  governed by the returned value of AccessStatus.

        NtStatus = NtAccessCheck(
                        AtGlobalSecurityDescriptor,     //  SecurityDescriptor
                        ClientToken,                    //  ClientToken
                        DesiredAccess,                  //  DesiredAccess
                        &AtGlobalInformationMapping,    //  GenericMapping
                        &PrivilegeSet,
                        &PrivilegeSetLength,
                        &GrantedAccess,                 //  GrantedAccess
                        &AccessStatus);                 //  AccessStatus

        if (NtStatus != STATUS_SUCCESS)
        {
            ERR_OUT("NtAccessCheck", NtStatus);
        }
        else
        {
            NtStatus = AccessStatus;
        }
        NtClose(ClientToken);
    }

    if ((Status = RpcRevertToSelf()) != NERR_Success)
    {
        ERR_OUT("RpcRevertToSelf", Status);
        return Status;
    }

    return(NetpNtStatusToApiStatus(NtStatus));
}

//+----------------------------------------------------------------------------
//
//  Function:   AtCreateSecurityObject
//
//  Synopsis:   Creates the scheduler user-mode configuration information
//              object which is represented by a security descriptor.
//
//  Returns:    NERR_Success or reason for failure.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
AtCreateSecurityObject(VOID)
{
    DWORD       SubmitControl;
    NTSTATUS    status;
    DWORD       type;
    DWORD       Length;
    HKEY        LsaKey;

    //
    // Server operators are permitted to manage the AT schedule service only if
    // the key exists and the proper flag is set. In all other case we do not
    // permit server operators to manage the AT schedule service.
    //
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          SCH_LSA_REGISTRY_PATH,
                          0L,
                          KEY_READ,
                          &LsaKey);

    if (status != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx(LsaKey)", status);
        return status;
    }

    Length = sizeof(SubmitControl);

    status = RegQueryValueEx(LsaKey,
                             SCH_LSA_SUBMIT_CONTROL,
                             NULL,
                             &type,
                             (LPBYTE)&SubmitControl,
                             &Length);

    RegCloseKey(LsaKey);

    if (status != ERROR_SUCCESS ||
        type != REG_DWORD       ||
        Length != sizeof(SubmitControl))
    {
        DBG_OUT3("SubmitControl reg value not found, "
                 "ServerOps not enabled for AT cmd.");
        SubmitControl = 0;
    }

    status = NetpCreateWellKnownSids(NULL);
    if (!NT_SUCCESS(status))
    {
        ERR_OUT("Failure to create security object", 0);
        return NetpNtStatusToApiStatus(status);
    }

    //
    //  Order matters!  These ACEs are inserted into the DACL in the
    //  following order.  Security access is granted or denied based on
    //  the order of the ACEs in the DACL.
    //
    //  In win3.1 both LocalGroupAdmins and LocalGroupSystemOps were
    //  allowed to perform all Schedule Service operations.  In win3.5
    //  LocalGroupSystemOps may be disallowed (this is the default case).
    //

    ACE_DATA    aceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasSystemOpsSid}
    };

    status = NetpCreateSecurityObject(
                    aceData,                                    // pAceData
                    (SubmitControl & SCH_SERVER_OPS) ? 2 : 1,   // countAceData
                    NULL,                                       // OwnerSid
                    NULL,                               // PrimaryGroupSid
                    &AtGlobalInformationMapping,
                    &AtGlobalSecurityDescriptor);       // ppNewDescriptor

    if (!NT_SUCCESS(status))
    {
        ERR_OUT("Failure to create security object", 0);
        return NetpNtStatusToApiStatus(status);
    }

    return NERR_Success;
}

//+---------------------------------------------------------------------------
//
//  Function:   AtDeleteSecurityObject
//
//  Synopsis:   Destroys the schedule service user-mode configuration
//              information object.
//
//  Returns:    NERR_Success or reason for failure.
//
//----------------------------------------------------------------------------
void
AtDeleteSecurityObject(VOID)
{
    if (AtGlobalSecurityDescriptor != NULL)
    {
        NetpDeleteSecurityObject(&AtGlobalSecurityDescriptor);
        NetpFreeWellKnownSids();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\conversion.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       conversion.cxx
//
//  Contents:   data conversion functions
//
//  History:    11-Nov-02   Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#include "common.hxx"
#include "security.hxx"
#include "statsync.hxx"

extern CStaticCritSec gcsSSCritSection;

#define SCH_DATA_VERSION L"DataVersion"

//+---------------------------------------------------------------------------
//
//  Function:   CheckDataVersion
//
//  Synopsis:   Check for registry key that will indicate
//              the version of the scheduler data.
//
//  Arguments:  None
//
//  Returns:    DWORD - indicates data version
//
//----------------------------------------------------------------------------
DWORD CheckDataVersion(void)
{
    DWORD dwDataVersion = 0;
    HKEY hSchedKey = NULL;
    long lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             SCH_AGENT_KEY,
                             0,
                             KEY_QUERY_VALUE | KEY_SET_VALUE,
                             &hSchedKey);

    if (lErr == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cb = sizeof(dwDataVersion);
        lErr = RegQueryValueEx(hSchedKey,
                               SCH_DATA_VERSION,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwDataVersion,
                               &cb);

        if (lErr != ERROR_SUCCESS || dwType != REG_DWORD)
        {
            dwDataVersion = 0;
        }
    }

    if (hSchedKey != NULL)
    {
        RegCloseKey(hSchedKey);
    }

    return dwDataVersion;
}

//+---------------------------------------------------------------------------
//
//  Function:   RecordDataVersion
//
//  Synopsis:   Update registry key to record current data version
//
//  Arguments:  dwDataVersion -- version value to store
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT RecordDataVersion(DWORD dwDataVersion)
{
    HRESULT hr = S_OK;
    HKEY hSchedKey = NULL;
    long lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             SCH_AGENT_KEY,
                             0,
                             KEY_QUERY_VALUE | KEY_SET_VALUE,
                             &hSchedKey);

    if (lErr == ERROR_SUCCESS)
    {
        DWORD cb = sizeof(dwDataVersion);                
        RegSetValueEx(hSchedKey,
                      SCH_DATA_VERSION,
                      NULL,
                      REG_DWORD,
                      (CONST BYTE *)&dwDataVersion,
                      cb);

        if (lErr != ERROR_SUCCESS)
        {
            schDebugOut((DEB_ERROR, "RegSetValueEx of RecordDataVersion value failed %ld\n", lErr));
            hr = E_FAIL;
        }
    }

    if (hSchedKey != NULL)
    {
        RegCloseKey(hSchedKey);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertJobIdentityHashMethod
//
//  Synopsis:   Create new identity entries for each job file in the SAI
//              utilizing the new hash method.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT ConvertJobIdentityHashMethod(void)
{
    HCRYPTPROV hCSP = NULL;
    WCHAR*     pwszTasksFolder = NULL;
    HANDLE     hFileEnum = INVALID_HANDLE_VALUE;
    DWORD      cbSAI = 0;
    DWORD      cbSAC = 0;
    BYTE*      pbSAI = NULL;
    BYTE*      pbSAC = NULL;
    BYTE*      pbIdentitySet = NULL;

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //
    HRESULT hr = GetCSPHandle(&hCSP);
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Guard SA security database access.
    //
    EnterCriticalSection(&gcsSSCritSection);
    
    //
    // Read the security database so we can do the lookups
    //
    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);
    if (SUCCEEDED(hr))
    {
        if (cbSAI <= SAI_HEADER_SIZE)
        {
            //
            // Database empty, nothing to do.
            //
        }
        else
        {
            //
            // Enumerate job objects in the task's folder directory.
            //
            hr = GetTasksFolder(&pwszTasksFolder);
            if (SUCCEEDED(hr))
            {
                WCHAR wszSearchPath[MAX_PATH + 1];
                hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCat(wszSearchPath, MAX_PATH + 1, EXTENSION_WILDCARD TSZ_JOB);
                    if (SUCCEEDED(hr))
                    {
                        WIN32_FIND_DATA fd;
                        ZeroMemory(&fd, sizeof(fd));
                        DWORD dwRet = 0;
                        if ((hFileEnum = FindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE)
                        {
                            //
                            // Either no jobs (this is OK), or an error occurred.
                            //
                            dwRet = GetLastError();
                            if (dwRet != ERROR_FILE_NOT_FOUND)
                            {
                                hr = _HRESULT_FROM_WIN32(dwRet);
                            }
                        }
                        else
                        {
                            //
                            // Must concatenate the filename returned from the enumeration onto the folder path
                            // before computing the hash.  Prepare for doing that repeatedly by taking the path,
                            // adding a slash, and remembering the next character position.
                            //
                            hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
                            if (SUCCEEDED(hr))
                            {
                                DWORD iConcatenation = lstrlenW(pwszTasksFolder);
                                wszSearchPath[iConcatenation++] = L'\\';
            
                                //
                                // Process each found file
                                //
                                BYTE  rgbIdentity[HASH_DATA_SIZE];
                                DWORD dwCredentialIndex = 0;
                                BOOL  bIsPasswordNull = FALSE;
                                BYTE* pbFoundIdentity = NULL;
                                DWORD cbFileName = 0;
            
                                while (dwRet != ERROR_NO_MORE_FILES)
                                {
                                    //
                                    // Truncate the existing name after the folder path,
                                    // then concatenate the new filename onto it.
                                    //
                                    wszSearchPath[iConcatenation] = L'\0';
                                    if (SUCCEEDED(StringCchCat(wszSearchPath, MAX_PATH + 1, fd.cFileName)))
                                    {
                                        //
                                        // Hash the job into a unique identity using the old method
                                        //
                                        if (SUCCEEDED(HashJobIdentity(hCSP, wszSearchPath, rgbIdentity, 0)))
                                        {
                                            //
                                            // Find the identity in the SAI for this job
                                            //
                                            hr = SAIFindIdentity(rgbIdentity,
                                                                 cbSAI,
                                                                 pbSAI,
                                                                 &dwCredentialIndex,
                                                                 &bIsPasswordNull,
                                                                 &pbFoundIdentity,
                                                                 NULL,
                                                                 NULL);
                                            
                                            //
                                            // S_OK means the identity was found; S_FALSE means it wasn't
                                            // Other codes are errors.  We process only the S_OKs, of course.
                                            //
                                            if (S_OK == hr)
                                            {
                                                //
                                                // Hash the job into a unique identity using the new method
                                                //
                                                if (SUCCEEDED(HashJobIdentity(hCSP, wszSearchPath, rgbIdentity)))
                                                {
                                                    //
                                                    // Store a NULL password by flipping the last bit of the hash data.
                                                    //
                                                    if (bIsPasswordNull)
                                                    {
                                                        LAST_HASH_BYTE(rgbIdentity) ^= 1;
                                                    }

                                                    //
                                                    // Update the old identity in place with the new one
                                                    //
                                                    hr = SAIUpdateIdentity(rgbIdentity,
                                                                           pbFoundIdentity,
                                                                           cbSAI,
                                                                           pbSAI);
                                                    if (FAILED(hr))
                                                    {
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    //
                                                    // we failed to produce a new hash for this file;
                                                    // while unexpected, it shouldn't be fatal to the conversion process;
                                                    // we just won't be able to convert this job; go on to the next job
                                                    //
                                                }
                                            }
                                            else
                                            {
                                                //
                                                // we failed to find the original job identity;
                                                // perhaps its credentials have already been lost;
                                                // there's nothing we can do; go on to the next job
                                                //
                                                hr = S_OK;
                                            }
                                        }
                                    }
                                
                                    if (!FindNextFile(hFileEnum, &fd))
                                    {
                                        dwRet = GetLastError();
                                        if (dwRet != ERROR_NO_MORE_FILES)
                                        {
                                            hr = _HRESULT_FROM_WIN32(dwRet);
                                        }
                                        break;
                                    }
                                }
                
                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Update security database with the new identities
                                    //
                                    hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (hFileEnum != INVALID_HANDLE_VALUE)
    {
        FindClose(hFileEnum);
    }
    if (pwszTasksFolder)
    {
        delete [] pwszTasksFolder;
    }
    if (pbSAI)
    {
        LocalFree(pbSAI);
    }
    if (pbSAC)
    {
        LocalFree(pbSAC);
    }
    if (hCSP)
    {
        CloseCSPHandle(hCSP);
    }

    LeaveCriticalSection(&gcsSSCritSection);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertNetScheduleJobSignatures
//
//  Synopsis:   Netschedule jobs (AT jobs) are signed internally with a hash so
//              that the service can validate their authenticity at run time.
//              Since we are changing how the hash is created, in order to be
//              runnable again, the AT jobs must be signed again with the new hash.
//              Prior to re-signing, we will verify the jobs using the old hash.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertNetScheduleJobSignatures(void)
{
    HRESULT hr = S_OK;
    HANDLE hFileEnum = INVALID_HANDLE_VALUE;

    WCHAR wszSearchPath[MAX_PATH + 1];
    hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(wszSearchPath, MAX_PATH + 1, L"\\" TSZ_AT_JOB_PREFIX L"*" TSZ_DOTJOB);
        if (SUCCEEDED(hr))
        {
            WIN32_FIND_DATA fd;
            ZeroMemory(&fd, sizeof(fd));
            DWORD dwRet = 0;
            if ((hFileEnum = FindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE)
            {
                //
                // Either no jobs (this is OK), or an error occurred.
                //
                dwRet = GetLastError();
                if (dwRet != ERROR_FILE_NOT_FOUND)
                {
                    hr = _HRESULT_FROM_WIN32(dwRet);
                }
            }
            else
            {
                //
                // Must concatenate the filename returned from the enumeration onto the folder path
                // before loading the job.  Prepare for doing that repeatedly by taking the path,
                // adding a slash, and remembering the next character position.
                //
                hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
                if (SUCCEEDED(hr))
                {
                    DWORD iConcatenation = lstrlenW(g_TasksFolderInfo.ptszPath);
                    wszSearchPath[iConcatenation++] = L'\\';
            
                    //
                    // Process each found file
                    //
                    while (dwRet != ERROR_NO_MORE_FILES)
                    {
                        //
                        // Truncate the existing name after the folder path,
                        // then concatenate the new filename onto it.
                        //
                        wszSearchPath[iConcatenation] = L'\0';
                        if (SUCCEEDED(StringCchCat(wszSearchPath, MAX_PATH + 1, fd.cFileName)))
                        {
                            //
                            // Load, verify, sign, save, and release the job
                            //
                            CJob* pJob = CJob::Create();
                            if (!pJob)
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            
                            if (SUCCEEDED(pJob->Load(wszSearchPath, 0)))
                            {
                                //
                                // verify using the old hash
                                //
                                if (pJob->VerifySignature(0))
                                {
                                    //
                                    // sign using the new hash
                                    //
                                    if (SUCCEEDED(pJob->Sign()))
                                    {
                                        pJob->SaveWithRetry(pJob->GetFileName(),
                                                            FALSE,
                                                            SAVEP_VARIABLE_LENGTH_DATA |
                                                            SAVEP_PRESERVE_NET_SCHEDULE);
                                    }
                                }
                            }
                
                            pJob->Release();
                        }
            
                        if (!FindNextFile(hFileEnum, &fd))
                        {
                            dwRet = GetLastError();
                            if (dwRet != ERROR_NO_MORE_FILES)
                            {
                                hr = _HRESULT_FROM_WIN32(dwRet);
                            }
                            break;
                        }
                    }
                }
            }
        
            if (hFileEnum != INVALID_HANDLE_VALUE)
            {
                FindClose(hFileEnum);
            }
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PerformDataConversions
//
//  Synopsis:   Perform any data conversions that may be required as a result
//              of changes to task scheduler.  This function is intended to
//              allow potential future conversions to be added easily, and to
//              allow conversions of data that may have already had earlier
//              conversions applied.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT PerformDataConversions(void)
{
    HRESULT hr = S_OK;
    
    switch (CheckDataVersion())
    {
        case 0:
            hr = ConvertJobIdentityHashMethod();
            if (SUCCEEDED(hr))
            {
                hr = RecordDataVersion(1);
            }
            // fall through to handle next higher conversion
        case 1:
            if (SUCCEEDED(hr))
            {
                hr = ConvertNetScheduleJobSignatures();
                if (SUCCEEDED(hr))
                {
                    hr = RecordDataVersion(2);
                }
            }
            // fall through to handle next higher conversion
        case 2:
            // nothing to do for now
            // version 2 is currently the highest and already has all changes applied
            break;
        default:
            // if the value is not listed above, then someone has altered the registry;
            // the version value is meaningless to us, so it is safest to not do anything,
            // but reflect the unusual situation in the error code in case we want to log it
            hr = S_FALSE;
            break;     
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\desktop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       desktop.cxx
//
//  Contents:   Creation/initialization of the Scheduling Agent windowstation
//              and its desktop, "SAWinSta\SADesktop". This windowstation
//              needs to exist to run tasks when no user is logged on, or the
//              logged on user is different than the task-specific account.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    26-Jun-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"
#include "..\inc\security.hxx"

#define SA_WINDOW_STATION L"SAWinSta"
#define SA_DESKTOP        L"SADesktop"

//
// Define all access to windows objects
//
// From windows\gina\winlogon\secutil.c
//

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL  (WINSTA_ENUMDESKTOPS     | WINSTA_READATTRIBUTES    | \
                     WINSTA_ACCESSCLIPBOARD  | WINSTA_CREATEDESKTOP     | \
                     WINSTA_WRITEATTRIBUTES  | WINSTA_ACCESSGLOBALATOMS | \
                     WINSTA_EXITWINDOWS      | WINSTA_ENUMERATE         | \
                     WINSTA_READSCREEN       | \
                     STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ATOMS    (WINSTA_ACCESSGLOBALATOMS | \
                         WINSTA_ACCESSCLIPBOARD )

HDESK                CreateSADesktop(HWINSTA hWinSta);
HWINSTA              CreateSAWindowStation(void);
PSID                 GetProcessSid(void);
BOOL                 InitializeSAWindow(void);
BOOL                 SetSADesktopSecurity(
                                    HDESK   hDesktop,
                                    PSID    pSchedAgentSid,
                                    PSID    pBatchSid);
BOOL                 SetSAWindowStationSecurity(
                                    HWINSTA hWinSta,
                                    PSID    pSchedAgentSid,
                                    PSID    pBatchSid);
void                 UninitializeSAWindow(void);

// Globals used in this module exclusively.
// Initialized in InitializeSAWindow, closed in UnitializeSAWindow.
//
HWINSTA ghSAWinsta  = NULL;     // Handle to window station, "SAWinSta".
HDESK   ghSADesktop = NULL;     // Handle to desktop, "SADesktop"

//+---------------------------------------------------------------------------
//
//  Function:   InitializeSAWindow
//
//  Synopsis:   Create and set security info on the windowstation\desktop,
//              "SAWinSta\SADesktop". This desktop exists for tasks which
//              run under an account different than the currently logged
//              on user, or when no user is logged on. Note, these tasks will
//              never appear on the interactive desktop.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Everything succeeded.
//              FALSE -- Encountered an error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
InitializeSAWindow(void)
{
    BOOL    fRet     = TRUE;
    PSID    pBatchSid;
    PSID    pSchedAgentSid;
    HWINSTA hWinSta  = NULL;
    HWINSTA hServiceWinSta = NULL;
    HDESK   hDesktop = NULL;
    BOOL    fChangedWinSta = FALSE;

    //
    // Retrieve local system and batch account SIDs.
    //

    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&SidAuth,
                                  1,
                                  SECURITY_BATCH_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pBatchSid))
    {
        schDebugOut((DEB_ERROR,
            "InitializeSAWindow, AllocateAndInitializeSid failed, " \
            "status = 0x%lx\n",
        GetLastError()));
        return(FALSE);
    }

    if ((pSchedAgentSid = GetProcessSid()) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    //
    // Get current service window station.
    //

    hServiceWinSta = GetProcessWindowStation();

    if (hServiceWinSta == NULL) {
        fRet = FALSE;
        goto CleanExit;
    }

    //
    // Create the window station & desktop.
    //

    if ((hWinSta = CreateSAWindowStation()) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    if (!SetProcessWindowStation(hWinSta))
    {
        schDebugOut((DEB_ERROR,
            "InitializeSAWindow, SetProcessWindowStation failed, " \
            "status = 0x%lx\n",
        GetLastError()));
        fRet = FALSE;
        goto CleanExit;
    }

    fChangedWinSta = TRUE;

    if ((hDesktop = CreateSADesktop(hWinSta)) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    //
    // Set security on the window station & desktop.
    //

    if (!SetSAWindowStationSecurity(hWinSta, pSchedAgentSid, pBatchSid))
    {
        fRet = FALSE;
        goto CleanExit;
    }

    if (!SetSADesktopSecurity(hDesktop, pSchedAgentSid, pBatchSid))
    {
        fRet = FALSE;
        goto CleanExit;
    }

CleanExit:

    //
    // If we have changed the window station, switch back to service window 
    // station.
    //

    if (fChangedWinSta) {
        schAssert(hServiceWinSta);
        if (!SetProcessWindowStation(hServiceWinSta))
        {
            schDebugOut((DEB_ERROR,
                         "InitializeSAWindow, SetProcessWindowStation failed, status = 0x%lx\n",
                         GetLastError()));
            fRet = FALSE;
        }
    }

    if (pBatchSid      != NULL) FreeSid(pBatchSid);
    if (pSchedAgentSid != NULL) LocalFree(pSchedAgentSid);
    if (fRet)
    {
        ghSAWinsta  = hWinSta;
        ghSADesktop = hDesktop;
    }
    else
    {
        if (hWinSta != NULL) CloseHandle(hWinSta);
        if (hDesktop != NULL) CloseHandle(hDesktop);

        //
        // even though the initial NULL values should still be untouched,
        // we'll be extra paranoid here and pretend that gremlins may have fiddled with them
        //
        ghSAWinsta = NULL;
        ghSADesktop = NULL;
    }

    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeSAWindow
//
//  Synopsis:   Close the global window station & desktop handles.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitializeSAWindow(void)
{
    if (ghSADesktop != NULL)
    {
        CloseDesktop(ghSADesktop);
        ghSADesktop = NULL;
    }
    if (ghSAWinsta  != NULL)
    {
        CloseWindowStation(ghSAWinsta);
        ghSAWinsta = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProcessSid
//
//  Synopsis:   Obtain the SID of this process.
//
//  Arguments:  None.
//
//  Returns:    This process' sid.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PSID
GetProcessSid(void)
{
    PSECURITY_DESCRIPTOR psdProcessSD = NULL;
    PSID                 pProcessSid  = NULL;
    PSID                 pProcessSidTmp;
    DWORD                cbSize;
    HANDLE               hProcess;
    BOOL                 fOwnerDefaulted;

    hProcess = GetCurrentProcess();

    if (hProcess == NULL)
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, GetCurrentProcess failed, status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    }

    //
    // Retrieve the buffer size necessary to retrieve this process' SD.
    //

    if (!GetKernelObjectSecurity(hProcess,
                                 OWNER_SECURITY_INFORMATION,
                                 NULL,
                                 0,
                                 &cbSize) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        psdProcessSD = LocalAlloc(LMEM_FIXED, cbSize);

        if (psdProcessSD == NULL)
        {
            schDebugOut((DEB_ERROR,
                "GetProcessSid, process security descriptor allocation " \
                "failure\n"));
            return(NULL);
        }

        //
        // Actually retrieve this process' SD.
        //

        if (!GetKernelObjectSecurity(hProcess,
                                     OWNER_SECURITY_INFORMATION,
                                     psdProcessSD,
                                     cbSize,
                                     &cbSize))
        {
            schDebugOut((DEB_ERROR,
                "GetProcessSid, GetKernelObjectSecurity failed, " \
                "status = 0x%lx\n",
                GetLastError()));
            goto ErrorExit;
        }
    }
    else
    {
        schAssert(0 && "GetKernelObjectSecurity() succeeded!");
        return(NULL);
    }

    //
    // Retrieve the owner SID from the SD.
    //

    if (!GetSecurityDescriptorOwner(psdProcessSD, 
                                    &pProcessSidTmp, 
                                    &fOwnerDefaulted)) 
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, GetSecurityDescriptorOwner failed, " \
            "status = 0x%lx\n",
            GetLastError()));
        goto ErrorExit;
    }

    //
    // An unnecessary check, maybe, but safe.
    //

    if (!IsValidSid(pProcessSidTmp))
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, IsValidSid failed, status = 0x%lx\n",
            GetLastError()));
        goto ErrorExit;
    }

    //
    // Make a copy of the SID since that returned from GetSecuritySD refers
    // within the security descriptor allocated above.
    //

    cbSize = GetLengthSid(pProcessSidTmp);

    pProcessSid = LocalAlloc(LMEM_FIXED, cbSize);

    if (pProcessSid == NULL)
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, process SID allocation failure\n"));
        goto ErrorExit;
    }

    if (!CopySid(cbSize, pProcessSid, pProcessSidTmp))
    {
        LocalFree(pProcessSid);
        pProcessSid = NULL;
        schDebugOut((DEB_ERROR,
            "GetProcessSid, CopySid failed, status = 0x%lx\n",
            GetLastError()));
    }

ErrorExit:
    if (psdProcessSD != NULL) LocalFree(psdProcessSD);

    return(pProcessSid);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateSAWindowStation
//
//  Synopsis:   Create the window station named "SAWinSta".
//
//  Arguments:  None.
//
//  Returns:    Window station handle on success.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HWINSTA
CreateSAWindowStation(void)
{
    HWINSTA hWinSta;

    if ((hWinSta = CreateWindowStation(SA_WINDOW_STATION,
                                       NULL,
                                       MAXIMUM_ALLOWED,
                                       NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CreateSAWindowStation, CreateWindowStation failed, " \
            "status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    }

    return(hWinSta);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateSADesktop 
//
//  Synopsis:   Create the desktop, "SADesktop", on the window station
//              indicated.
//
//  Arguments:  [hWinSta] -- Window station.
//
//  Returns:    Desktop handle on success.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HDESK
CreateSADesktop(HWINSTA hWinSta)
{
    HDESK hDesktop;

    if ((hDesktop = CreateDesktop(SA_DESKTOP,
                                  NULL,
                                  NULL,
                                  0,
                                  MAXIMUM_ALLOWED,
                                  NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CreateSADesktop, CreateDesktop failed, status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    } 

    return(hDesktop);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSAWindowStationSecurity
//
//  Synopsis:   Set permissions on the scheduling agent window station for
//              this process and batch users.
//
//  Arguments:  [hWinSta]        -- Window station.
//              [pSchedAgentSid] -- Scheduling Agent process SID.
//              [pBatchSid]      -- Batch SID.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
SetSAWindowStationSecurity(
    HWINSTA hWinSta,
    PSID    pSchedAgentSid,
    PSID    pBatchSid)
{
#define WS_ACE_COUNT 4

    PACCESS_ALLOWED_ACE rgAce[WS_ACE_COUNT] = {
        NULL, NULL, NULL, NULL };           // Supply this to CreateSD so we
                                            // don't have to allocate memory.
    MYACE rgMyAce[WS_ACE_COUNT] = { 
        { WINSTA_ALL,                       // Acess mask.
          NO_PROPAGATE_INHERIT_ACE,         // Inherit flags.
          pSchedAgentSid },                 // SID.
        { GENERIC_ALL,
          OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
          pSchedAgentSid },
        { WINSTA_ALL & ~(DELETE | WRITE_DAC | WRITE_OWNER),  // need to leave READ_CONTROL in this or jobs can't run
          NO_PROPAGATE_INHERIT_ACE,
          pBatchSid },
        { GENERIC_READ | GENERIC_EXECUTE,
          INHERIT_ONLY_ACE,
          pBatchSid }
    };

    schAssert(WS_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              WS_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    SECURITY_INFORMATION si;
    DWORD                Status = 0;

    if ((pSecurityDescriptor = CreateSecurityDescriptor(WS_ACE_COUNT,
                                                        rgMyAce,
                                                        rgAce)) == NULL)
    {
        return(FALSE);
    }

    si = DACL_SECURITY_INFORMATION;
    if (!SetUserObjectSecurity(hWinSta, &si, pSecurityDescriptor))
    {
        Status = GetLastError();
    }

    DeleteSecurityDescriptor(pSecurityDescriptor);

    if (Status)
    {
        schDebugOut((DEB_ERROR,
            "SetSASetWindowStationSecurity, SetUserObjectSecurity failed, " \
            "status = 0x%lx\n",
            Status));
        return(FALSE);
    }    

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSADesktopSecurity
//
//  Synopsis:   Set permissions on the scheduling agent desktop for this
//              process and batch users.
//
//  Arguments:  [hDesktop]       -- Desktop.
//              [pSchedAgentSid] -- Scheduling Agent process SID.
//              [pBatchSid]      -- Batch SID.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
SetSADesktopSecurity(
    HDESK   hDesktop,
    PSID    pSchedAgentSid,
    PSID    pBatchSid)
{
#define DT_ACE_COUNT 2

    PACCESS_ALLOWED_ACE rgAce[DT_ACE_COUNT] = {
        NULL, NULL };                       // Supply this to CreateSD so we
                                            // don't have to allocate memory.
    MYACE rgMyAce[DT_ACE_COUNT] = { 
        { DESKTOP_ALL,                      // Acess mask.
          0,                                // Inherit flags.
          pSchedAgentSid },                 // SID.
        { DESKTOP_ALL  & ~STANDARD_RIGHTS_REQUIRED,
          0,
          pBatchSid }
    };

    schAssert(DT_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              DT_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    SECURITY_INFORMATION si;
    DWORD                Status = 0;

    if ((pSecurityDescriptor = CreateSecurityDescriptor(DT_ACE_COUNT,
                                                        rgMyAce,
                                                        rgAce)) == NULL)
    {
        return(FALSE);
    }

    si = DACL_SECURITY_INFORMATION;
    if (!SetUserObjectSecurity(hDesktop, &si, pSecurityDescriptor))
    {
        Status = GetLastError();
    }

    DeleteSecurityDescriptor(pSecurityDescriptor);

    if (Status)
    {
        schDebugOut((DEB_ERROR,
            "SetSADesktopSecurity, SetUserObjectSecurity failed, " \
            "status = 0x%lx\n",
            Status));
        return(FALSE);
    }    

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\events.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       events.cxx
//
//  Contents:   Idle and battery event code.
//
//  History:    22-Mar-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "globals.hxx"
#include "svc_core.hxx"
extern "C"
{
#include "msidle.h"
}

#define SCH_NOIDLE_VALUE    TEXT("NoIdle")

BOOL g_fOnBattery;
BOOL g_fIdleInitialized;
HINSTANCE g_hMsidleDll = NULL;

//
// msidle.dll function pointers.
//
_BEGINIDLEDETECTION gpfnBeginIdleDetection;
_ENDIDLEDETECTION   gpfnEndIdleDetection;
_SETIDLETIMEOUT     gpfnSetIdleTimeout;
_SETIDLENOTIFY      gpfnSetIdleNotify;
_SETBUSYNOTIFY      gpfnSetBusyNotify;
_GETIDLEMINUTES     gpfnGetIdleMinutes;


//+----------------------------------------------------------------------------
//
//  Function:   OnIdleNotification
//
//  Synopsis:   Called when the winproc receives idle notifications.
//
//  Arguments:  [wParam] - indicates whether it is for idle start or end.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
void WINAPI
OnIdleNotify(DWORD dwState)
{
    switch (dwState)
    {
    case STATE_USER_IDLE_BEGIN:
        //
        // Received idle notification.
        //
        if (g_pSched != NULL)
        {
            schDebugOut((DEB_ITRACE,
                        "*** OnIdleNotification: entering idle state. ***\n"));
            g_pSched->OnIdleEvent(TRUE);
        }
        break;

    case STATE_USER_IDLE_END:
        //
        // Idle has ended.
        //
        if (g_pSched != NULL)
        {
            schDebugOut((DEB_ITRACE,
                         "*** OnIdleNotification: idle lost. ***\n"));
            g_pSched->OnIdleEvent(FALSE);
        }
        break;

    default:
        schAssert(0);
        break;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   SetNextIdleNotificationFn
//
//  Synopsis:   Set the length of time to wait for the next idle notification.
//
//  Returns:    TRUE for success, and FALSE if unable to make the call.
//
//-----------------------------------------------------------------------------
BOOL
SetNextIdleNotificationFn(WORD wIdleWait)
{
    schDebugOut((DEB_ITRACE, "SetNextIdleNotification(%u)\n", wIdleWait));

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling SetNextIdleNotification before idle init!");
        return FALSE;
    }

    //
    // 0xffff is a flag value meaning that no idle notification is needed.
    //
    if (wIdleWait == 0xffff)
    {
        schDebugOut((DEB_IDLE, "Next idle wait is 0xffff, not requesting"
                               " idle notification\n"));
        //
        // msidle.dll makes it impossible to turn off idle notification
        // completely.  SetIdleNotify(FALSE, 0) will do it temporarily,
        // but if we have also registered for a loss-of-idle notification,
        // then as soon as we get that notification, msidle.dll turns idle
        // notification back on automatically.
        // So we also set a long idle wait period.
        // (It doesn't have to be 0xffff, but it might as well be)
        //
        gpfnSetIdleTimeout(0xffff, 0);
        gpfnSetIdleNotify(FALSE, 0);
        return FALSE;
    }

    schAssert(wIdleWait != 0);
    schDebugOut((DEB_IDLE, "Requesting %u-minute idle notification\n",
                           wIdleWait));

    gpfnSetIdleTimeout(wIdleWait, 0);
    gpfnSetIdleNotify(TRUE, 0);

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   SetIdleLossNotificationFn
//
//  Synopsis:   Registers for idle loss notification.
//
//  Returns:    TRUE for success, and FALSE if unable to make the call.
//
//-----------------------------------------------------------------------------
BOOL
SetIdleLossNotificationFn()
{
    schDebugOut((DEB_ITRACE, "SetIdleLossNotification()\n"));

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling SetIdleLossNotification before idle init!");
        return FALSE;
    }

    schDebugOut((DEB_IDLE, "Requesting idle LOSS notification\n"));
    gpfnSetBusyNotify(TRUE, 0);

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   GetTimeIdle
//
//  Synopsis:   Obtains the length of time the machine has been idle.
//
//-----------------------------------------------------------------------------
DWORD
GetTimeIdle(void)
{
    DWORD dwMinutes;

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling GetTimeIdle before idle init!");
        dwMinutes = 0;
    }
    else
    {
        dwMinutes = gpfnGetIdleMinutes(0);
    }

    schDebugOut((DEB_IDLE, "User has been idle for %u minutes\n", dwMinutes));

    return dwMinutes;
}


//+----------------------------------------------------------------------------
//
//  Function:   OnPowerChange
//
//  Synopsis:   Called when the machine's battery  state changes.
//
//  Arguments:  [fGoingOnBattery] - set to true if going on battery power,
//                                  false if going back on line power.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
OnPowerChange(BOOL fGoingOnBattery)
{
    schDebugOut((DEB_ITRACE, "OnPowerChange: fGoingOnBattery = %s\n",
                 (fGoingOnBattery) ? "TRUE" : "FALSE"));

    //
    // Check to see if our battery state has changed, or if this is just
    // a battery update
    //
    if (g_fOnBattery != fGoingOnBattery) 
    {
        g_fOnBattery = fGoingOnBattery;
    
        //
        // Signal the main thread to recalculate the next wakeup time, since
        // the calculation depends on whether the machine is on batteries.
        // Do this by simply signaling the wakeup timer.  This will cause a
        // recalc.
        //
        g_pSched->SignalWakeupTimer();
    
        if (fGoingOnBattery)
        {
            //
            // Notify the job processor to kill any jobs with the
            // TASK_FLAG_KILL_IF_GOING_ON_BATTERIES flag set.
            //
            CJobProcessor * pjp;
            for (pjp = gpJobProcessorMgr->GetFirstProcessor(); pjp != NULL; )
            {
                pjp->KillIfFlagSet(TASK_FLAG_KILL_IF_GOING_ON_BATTERIES);
                CJobProcessor * pjpNext = pjp->Next();
                pjp->Release();
                pjp = pjpNext;
            }
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   InitBatteryNotification
//
//  Synopsis:   Initialize the battery event boolean.
//
//  Returns:    hresults
//
//  Notes:      Currently only Win95 supports power management.
//
//-----------------------------------------------------------------------------
HRESULT
InitBatteryNotification(void)
{
    DWORD dwErr;

    //
    // Check current battery state and set bool accordingly.
    //
    SYSTEM_POWER_STATUS PwrStatus;

    if (!GetSystemPowerStatus(&PwrStatus))
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND ||
            dwErr == ERROR_CALL_NOT_IMPLEMENTED)
        {
            g_fOnBattery = FALSE;
            schDebugOut((DEB_ITRACE,
                         "InitBatteryNotification: GetSystemPowerStatus"
                         " returned %u, g_fOnBattery set to FALSE\n",
                         dwErr));
            return S_OK;
        }
        ERR_OUT("GetSystemPowerStatus", HRESULT_FROM_WIN32(dwErr));
        return HRESULT_FROM_WIN32(dwErr);
    }

    g_fOnBattery = (PwrStatus.ACLineStatus == 0) ? TRUE : FALSE;

    schDebugOut((DEB_ITRACE, "InitBatteryNotification: g_fOnBattery = %s\n",
                 (g_fOnBattery) ? "TRUE" : "FALSE"));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   InitIdleDetection
//
//  Synopsis:   Called after the message window is created to initialize idle
//              detection and hot corners.
//
//  Arguments:
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
InitIdleDetection()
{
    TRACE_FUNCTION(InitIdleDetection);
    DWORD dwErr;

    //
    // Look in the registry to see if idle detection is disabled.
    //
    long lErr;
    HKEY hSchedKey = NULL;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ,
                        &hSchedKey);
    if (lErr == ERROR_SUCCESS)
    {
        TCHAR tszInit[SCH_MED0BUF_LEN + 1];
        DWORD cb = SCH_MED0BUF_LEN * sizeof(TCHAR);

        lErr = RegQueryValueEx(hSchedKey, SCH_NOIDLE_VALUE, NULL, NULL,
                               (LPBYTE)tszInit, &cb);

        RegCloseKey(hSchedKey);

        if (lErr == ERROR_SUCCESS)
        {
            //
            // The presence of the value is sufficient to disable idle
            // detection. g_fIdleInitialized will remain FALSE, resulting
            // in all idle operations being skipped.
            //
            schDebugOut((DEB_ITRACE, "Idle detection is disabled!!!!!!!!\n"));
            return S_OK;
        }
    }

    // load msidle.dll
    if (g_hMsidleDll == NULL) {
    
        g_hMsidleDll = LoadLibrary(TEXT("MSIDLE.DLL"));

        if (g_hMsidleDll == NULL)
        {
            dwErr = GetLastError();
            ERR_OUT("Load of msidle.dll", dwErr);
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    // get entry points
    gpfnBeginIdleDetection = (_BEGINIDLEDETECTION)
                                GetProcAddress(g_hMsidleDll, (LPSTR)3);
    gpfnEndIdleDetection = (_ENDIDLEDETECTION)
                                GetProcAddress(g_hMsidleDll, (LPSTR)4);
    gpfnSetIdleTimeout = (_SETIDLETIMEOUT)
                                GetProcAddress(g_hMsidleDll, (LPSTR)5);
    gpfnSetIdleNotify = (_SETIDLENOTIFY)
                                GetProcAddress(g_hMsidleDll, (LPSTR)6);
    gpfnSetBusyNotify = (_SETBUSYNOTIFY)
                                GetProcAddress(g_hMsidleDll, (LPSTR)7);
    gpfnGetIdleMinutes = (_GETIDLEMINUTES)
                                GetProcAddress(g_hMsidleDll, (LPSTR)8);

    if (gpfnBeginIdleDetection == NULL ||
        gpfnEndIdleDetection == NULL ||
        gpfnSetIdleTimeout == NULL ||
        gpfnSetIdleNotify == NULL ||
        gpfnSetBusyNotify == NULL ||
        gpfnGetIdleMinutes == NULL)
    {
        dwErr = GetLastError();
        ERR_OUT("Getting msidle.dll entry point addresses", dwErr);
        goto ErrExit;
    }

    // call start monitoring
    dwErr = gpfnBeginIdleDetection(OnIdleNotify, SCH_DEFAULT_IDLE_TIME, 0);
    if (dwErr)
    {
        ERR_OUT("Making initial idle call", dwErr);
        goto ErrExit;
    }

    g_fIdleInitialized = TRUE;

    return S_OK;

ErrExit:

    FreeLibrary(g_hMsidleDll);
    g_hMsidleDll = NULL;
    gpfnBeginIdleDetection = NULL;
    gpfnEndIdleDetection = NULL;
    gpfnSetIdleTimeout = NULL;
    gpfnSetIdleNotify = NULL;
    gpfnSetBusyNotify = NULL;
    gpfnGetIdleMinutes = NULL;

    return HRESULT_FROM_WIN32(dwErr);
}


//+----------------------------------------------------------------------------
//
//  Function:   EndIdleDetection
//
//  Synopsis:   Stop idle detection.
//
//  Arguments:  None.
//
//-----------------------------------------------------------------------------
void
EndIdleDetection()
{
    if (gpfnEndIdleDetection != NULL)
    {
        gpfnEndIdleDetection(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       globals.cxx
//
//  Contents:   Service global data.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    6-Apr-95    MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "svc_core.hxx"
#include "globals.hxx"

//
// The service worker instance.
//

CSchedWorker * g_pSched = NULL;

//
// Job processor manager.
//

CJobProcessorMgr * gpJobProcessorMgr = NULL;

//
// Worker thread manager.
//

CWorkerThreadMgr * gpThreadMgr = NULL;

//
// Service scavenger task.
//

CSAScavengerTask * gpSAScavengerTask = NULL;

//
// Event Source for NetSchedule Job logging
//

HANDLE g_hAtEventSource = NULL;


//
// Global static critsecs.
// These are initialized in the CStaticCritSec constructor and deleted in its destructor.
// Their life span lasts for the duration of the dll load.
//

CStaticCritSec gcsNetScheduleCritSection;		// Used for NetScheduleX thread serialization.
CStaticCritSec gcsUserLogonInfoCritSection;	// Protects global data associated with the locally logged on user.
CStaticCritSec gcsLogCritSection;				// Protects access to log file
CStaticCritSec gcsSSCritSection;				// Protects access to security database

//
// Global data associated with the locally logged on user.
//
GlobalUserLogonInfo gUserLogonInfo(&gcsUserLogonInfoCritSection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\idl\$(O)\$(@F)
    copy ..\idl\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\jqueue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       jqueue.cxx
//
//  Contents:   CJobQueue class implementation.
//
//  Classes:    CJobQueue
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CJobQueue::~CJobQueue
//
//  Synopsis:   Destructor. Destruct job info queue.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobQueue::~CJobQueue()
{
    TRACE3(CJobQueue, ~CJobQueue);

    CRun * pRun, * pRunNext;

    pRun = (CRun *)CQueue::RemoveElement();
//    pRun = (CRun *)CQueue::GetFirstElement();

    while (pRun != NULL)
    {
        pRunNext = (CRun *)CQueue::RemoveElement();
//        pRunNext = pRun->Next();
        delete pRun;
        pRun = pRunNext;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobQueue::FindJob
//
//  Synopsis:   Find the job with matching handle in the job queue.
//
//  Arguments:  [hJob] -- Job handle.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CRun *
CJobQueue::FindJob(HANDLE hJob)
{
    schDebugOut((DEB_USER3,
        "CJobQueue::FindJob(0x%x) hJob(0x%x)\n"));

    CRun * pRun = (CRun *)CQueue::GetFirstElement();

    while (pRun != NULL)
    {
        if (pRun->GetHandle() == hJob)
        {
            schDebugOut((DEB_USER3,
                "CJobQueue::FindJob(0x%x) hJob(0x%x) Found it\n"));

            return(pRun);
        }
        pRun = pRun->Next();
    }

    schDebugOut((DEB_USER3,
        "CJobQueue::FindJob(0x%x) hJob(0x%x) Not found\n"));

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\getuser.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       getuser.cxx
//
//  Contents:   Get the identity of the logged in user.
//
//  History:    19-Jun-96 EricB created
//
//  Notes:      This is for NT only since Win95 doesn't have security.
//
//-----------------------------------------------------------------------------

//
// Some NT header definitions conflict with some of the standard windows
// definitions. Thus, the project precompiled header can't be used.
//
extern "C" {
#include <nt.h>                 //  NT definitions
#include <ntrtl.h>              //  NT runtime library definitions
#include <nturtl.h>
#include <ntlsa.h>              // BUGBUG 254102
}

#include <windows.h>
#define  SECURITY_WIN32         // needed by security.h
#include <security.h>           // GetUserNameEx
#include <winbase.h>            // SecureZeroMemory
#include <StrSafe.h>
#include <lmcons.h>             // BUGBUG 254102
#include <defines.hxx>          // BUGBUG 254102

#include <..\..\..\smdebug\smdebug.h>
#include <debug.hxx>
#include "globals.hxx"
#include <Wtsapi32.h>

const int SCH_BIGBUF_LEN = 256;

//
// Registry key/value for default shell.
//
#define SHELL_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL    L"Shell"
#define DEFAULT_SHELL   L"explorer.exe"

// This function is actually declared in proto.hxx. But including proto.hxx
// brings in alot of things we don't need. Just define it here to the includes
// simple.
//
HANDLE ImpersonateUser(HANDLE hUserToken, HANDLE hImpersonationToken);

// so's this one - here's to hoping that type-safe linkage works well...
HANDLE ImpersonateLoggedInUser(void);

BOOL StopImpersonating(HANDLE ThreadHandle, BOOL fCloseHandle);



// toggle to allow conditional compilation of fix for RAID 720688
// "old" method found user token for shell process (usually explorer.exe)
// "new" method uses Terminal Server functions
#define FIND_USER_WITH_TS

//+----------------------------------------------------------------------------
//
//  Function:   LogonSessionDataCleanup
//
//  Synopsis:   Close all open handles and free memory.
//
//  Notes:                      **** Important ****
//
//              No need to enter gcsLogonSessionInfoCritSection prior to
//              calling this function since it is entered here.
//
//-----------------------------------------------------------------------------
void
LogonSessionDataCleanup(void)
{
    EnterCriticalSection(gUserLogonInfo.CritSection);

    if (gUserLogonInfo.ImpersonationThread != NULL)
    {
        CloseHandle(gUserLogonInfo.ImpersonationThread);
        gUserLogonInfo.ImpersonationThread = NULL;
    }

    if (gUserLogonInfo.DomainUserName != NULL)
    {
        delete gUserLogonInfo.DomainUserName;
        gUserLogonInfo.DomainUserName= NULL;
    }

    if (gUserLogonInfo.ShellToken)
    {
            CloseHandle(gUserLogonInfo.ShellToken);
            gUserLogonInfo.ShellToken = NULL;
    }

    SecureZeroMemory(gUserLogonInfo.Sid, sizeof(gUserLogonInfo.Sid));

    LeaveCriticalSection(gUserLogonInfo.CritSection);
}

//+----------------------------------------------------------------------------
//
//  Function:   ImpersonateUser
//
//  Synopsis:   Impersonate the user associated with the token.
//
//  Arguments:  [hUserToken] - Handle to the token to be impersonated.
//              [ThreadHandle] - Handle to the thread that is to impersonate
//                  hUserToken.  If this is NULL, the function opens a handle
//                  to the current thread.
//
//  Returns:    Handle to the thread that is impersonating hUserToken.
//
//  Notes:      BUGBUG : This code was taken from RAS. It is quite different
//                       than that in winlogon
//                       (windows\gina\winlogon\secutil.c).
//
//-----------------------------------------------------------------------------
HANDLE
ImpersonateUser(HANDLE hUserToken, HANDLE ThreadHandle)
{
    NTSTATUS                    Status;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      ImpersonationToken;
    BOOL                        ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL)
    {
        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES);

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NtDuplicateObject", Status);
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }

    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (hUserToken != NULL)
    {
        //
        // hUserToken is a primary token - create an impersonation token
        // version of it so we can set it on our thread
        //

        InitializeObjectAttributes(&ObjectAttributes,
                                   NULL,
                                   0L,
                                   NULL,
//                                 UserProcessData->NewThreadTokenSD);
                                   NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode =
                                                    SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

        Status = NtDuplicateToken(hUserToken,
                                  TOKEN_IMPERSONATE | TOKEN_READ,
                                  &ObjectAttributes,
                                  FALSE,
                                  TokenImpersonation,
                                  &ImpersonationToken);

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NtDuplicateToken", Status);

            if (ThreadHandleOpened)
            {
                NtClose(ThreadHandle);
            }

            return(NULL);
        }

        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread(ThreadHandle,
                                        ThreadImpersonationToken,
                                        (PVOID)&ImpersonationToken,
                                        sizeof(ImpersonationToken));

        //
        // We're finished with our handle to the impersonation token
        //

        NtClose(ImpersonationToken);

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NTSetInformationThread", Status);

            if (ThreadHandleOpened)
            {
                NtClose(ThreadHandle);
            }

            return(NULL);
        }

    }


    return(ThreadHandle);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLoggedOnUser
//
//  Synopsis:   Called when a user logs in.
//
//  Returns:    None.  Sets the global gUserLogonInfo.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call and continue
//              to remain in this critical section for the lifetime use of
//              the returned string.
//
//              DO NOT attempt to dealloc the returned string! It is a
//              pointer to global memory.
//
//-----------------------------------------------------------------------------
void
GetLoggedOnUser(void)
{
    LPWSTR pwszLoggedOnUser;
    DWORD  cchName = 0;
    DWORD dwErr = ERROR_SUCCESS;

    if (gUserLogonInfo.DomainUserName != NULL)
    {
        //
        // Already done.
        //
        return;
    }

    //
    // Impersonate the logged in user.
    //
    if (ImpersonateLoggedInUser())
    {
        //
        // Get the size of the user name string.
        //
        if (!GetUserNameEx(NameSamCompatible, NULL, &cchName))
        {
            dwErr = GetLastError();
            if (dwErr != ERROR_MORE_DATA || cchName == 0)
            {
                StopImpersonating(gUserLogonInfo.ImpersonationThread, TRUE);
                ERR_OUT("GetLoggedOnUser: GetUserName", dwErr);
                return;
            }
        }
        cchName++;  // contrary to docs, cchName excludes the null

        //
        // Allocate the user name string buffer and get the user name.
        //
        pwszLoggedOnUser = new WCHAR[cchName * 2];

        if (pwszLoggedOnUser != NULL)
        {
            if (!GetUserNameEx(NameSamCompatible, pwszLoggedOnUser, &cchName))
            {
                dwErr = GetLastError();
                ERR_OUT("GetLoggedOnUser: GetUserName", dwErr);
                delete pwszLoggedOnUser;
            }
            else
            {
                schDebugOut((DEB_ITRACE, "GetLoggedOnUser: got '%S'\n",
                             pwszLoggedOnUser));
                cchName++;  // contrary to docs, cchName excludes the null

                //
                // This name is in the format "domain\\user".
                // Make a copy of the domain name right after it, so
                // we end up with a single buffer in the format
                // "domain\\user\0domain".  Set up pointers into this
                // buffer for all 3 parts of the name:
                //      domain
                //      user
                //      domain\user
                //
                gUserLogonInfo.DomainUserName = pwszLoggedOnUser;

                WCHAR *pSlash = wcschr(pwszLoggedOnUser, L'\\');
                schAssert(pSlash != NULL);
                gUserLogonInfo.UserName = pSlash + 1;

                DWORD cchDomain = (DWORD) (pSlash - pwszLoggedOnUser);
                gUserLogonInfo.DomainName = pwszLoggedOnUser + cchName;

                wcsncpy(gUserLogonInfo.DomainName, pwszLoggedOnUser, cchDomain);
                gUserLogonInfo.DomainName[cchDomain] = L'\0';

                schDebugOut((DEB_ITRACE, "GetLoggedOnUser: domain '%S', user '%S'\n",
                             gUserLogonInfo.DomainName, gUserLogonInfo.UserName));
            }
        }
        else
        {
            ERR_OUT("GetLoggedOnUser", ERROR_OUTOFMEMORY);
        }


        //
        // BUGBUG 254102 - Cache the logged-on user's SID, since
        // LookupAccountName doesn't do it when offline.
        // Remove this code when bug 254102 is fixed.
        //
#define USER_TOKEN_STACK_BUFFER_SIZE    \
        (sizeof(TOKEN_USER) + sizeof(SID_AND_ATTRIBUTES) + MAX_SID_SIZE)

        BYTE         rgbTokenInformation[USER_TOKEN_STACK_BUFFER_SIZE];
        TOKEN_USER * pTokenUser = (TOKEN_USER *)rgbTokenInformation;
        DWORD        cbReturnLength;

        if (!GetTokenInformation(gUserLogonInfo.ShellToken,
                                 TokenUser,
                                 pTokenUser,
                                 USER_TOKEN_STACK_BUFFER_SIZE,
                                 &cbReturnLength))
        {
            schAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            SecureZeroMemory(gUserLogonInfo.Sid, sizeof(gUserLogonInfo.Sid));
        }
        else if (!CopySid(sizeof(gUserLogonInfo.Sid),
                          gUserLogonInfo.Sid,
                          pTokenUser->User.Sid))
        {
            schAssert(!"CopySid failed");
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            SecureZeroMemory(gUserLogonInfo.Sid, sizeof(gUserLogonInfo.Sid));
        }


        StopImpersonating(gUserLogonInfo.ImpersonationThread, FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   StopImpersonating
//
//  Synopsis:   Stop impersonating.
//
//  Notes:      This code was taken from winlogon. Specifically:
//              windows\gina\winlogon\secutil.c.
//
//-----------------------------------------------------------------------------
BOOL
StopImpersonating(HANDLE ThreadHandle, BOOL fCloseHandle)
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE   ImpersonationToken;

    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread(ThreadHandle,
                                    ThreadImpersonationToken,
                                    (PVOID)&ImpersonationToken,
                                    sizeof(ImpersonationToken));

    //
    // We're finished with the thread handle
    //

    if (fCloseHandle)
    {
        IgnoreStatus = NtClose(ThreadHandle);
        schAssert(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status))
    {
        schDebugOut((DEB_ERROR,
            "Failed to remove user impersonation token from SA service, " \
            "status = 0x%lx", Status));
    }

    return(NT_SUCCESS(Status));
}


#ifdef FIND_USER_WITH_TS

//+----------------------------------------------------------------------------
//
//  Function:   ImpersonateLoggedInUser
//
//  Synopsis:   Impersonate the shell user.
//
//  Returns:    Handle to thread that's impersonating user
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call.
//
//  GLOBALS:    sets gUserLogonInfo.ShellToken and gUserLogonInfo.ImpersonationThread
//
//-----------------------------------------------------------------------------
HANDLE
ImpersonateLoggedInUser(void)
{
    if (gUserLogonInfo.ShellToken)
    {
        CloseHandle(gUserLogonInfo.ShellToken);
        gUserLogonInfo.ShellToken = NULL;
    }
    
    DWORD sessionID;
        
    sessionID = WTSGetActiveConsoleSessionId();

    if (sessionID == 0xFFFFFFFF)
        return NULL;

    if (!WTSQueryUserToken(sessionID, &gUserLogonInfo.ShellToken))
        return NULL;

    
    if (gUserLogonInfo.ImpersonationThread)
        CloseHandle(gUserLogonInfo.ImpersonationThread);

    return (gUserLogonInfo.ImpersonationThread = ImpersonateUser(
                                gUserLogonInfo.ShellToken,
                                gUserLogonInfo.ImpersonationThread));
}


#else // #ifdef FIND_USER_WITH_TS

HANDLE  GetShellProcessHandle(void);
PSYSTEM_PROCESS_INFORMATION GetSystemProcessInfo(void);
PSYSTEM_PROCESS_INFORMATION FindProcessByName(PSYSTEM_PROCESS_INFORMATION,
                                              LPWSTR);
VOID    FreeSystemProcessInfo(PSYSTEM_PROCESS_INFORMATION pProcessInfo);

//+----------------------------------------------------------------------------
//
//  Function:   GetShellProcessHandle
//
//  Synopsis:   Initialize & return the shell handle of the current logged
//              on user, gUserLogonInfo.ShellHandle.
//
//  Returns:    ERROR_SUCCESS or an error code.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered gUserLogonInfo.CriticalSection
//              for the duration of this call and continue to remain in
//              in it for the lifetime use of the returned handle.
//
//              DO NOT close the returned handle. It is a global handle.
//
//-----------------------------------------------------------------------------
HANDLE
GetShellProcessHandle(void)
{
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    WCHAR    wszShellName[MAX_PATH + 1];
    WCHAR *  pwszShellName = wszShellName;
    WCHAR *  pwsz;
    HKEY     hReg = NULL;
    HANDLE   hProcess = NULL;
    DWORD    dwErr = ERROR_SUCCESS;
    DWORD    dwType;
    DWORD    dwSize;


    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    //

    if (gUserLogonInfo.ShellHandle != NULL)
    {
        //
        // Check if the handle is valid.
        //

        if (WaitForSingleObject(gUserLogonInfo.ShellHandle,
                                0) == WAIT_TIMEOUT)
        {
            //
            // Still valid.
            //

            return(gUserLogonInfo.ShellHandle);
        }

        //
        // Re-acquire handle.
        //

        CloseHandle(gUserLogonInfo.ShellHandle);
        gUserLogonInfo.ShellHandle = NULL;
    }

    StringCchCopy(pwszShellName, MAX_PATH + 1, DEFAULT_SHELL);

    if ((dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SHELL_REGKEY,
                              0,
                              KEY_READ,
                              &hReg)) == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszShellName);

        dwErr = RegQueryValueEx(hReg,
                                SHELL_REGVAL,
                                NULL,
                                &dwType,
                                (PBYTE)pwszShellName,
                                &dwSize);

        RegCloseKey(hReg);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        ERR_OUT("GetShellProcessHandle: RegQueryValueEx", dwErr);
        return(NULL);
    }

    //
    // Remove parameters from command line.
    //

    pwsz = pwszShellName;
    while (*pwsz != L' ' && *pwsz != L'\0')
    {
        pwsz++;
    }
    *pwsz = L'\0';

    //
    // Get the process list.
    //

    pSystemInfo = GetSystemProcessInfo();

    if (pSystemInfo == NULL)
    {
        return(NULL);
    }

    //
    // See if wszShell is running.
    //

    pProcessInfo = FindProcessByName(pSystemInfo, pwszShellName);

    if (pProcessInfo != NULL)
    {
        //
        // Open the process.
        //

        hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                               FALSE,
                               HandleToUlong(pProcessInfo->UniqueProcessId));

#if DBG == 1
        if (hProcess == NULL)
        {
            ERR_OUT("GetShellProcessHandle: OpenProcess", GetLastError());
        }
#endif
    }

    //
    // Free resources.
    //
    FreeSystemProcessInfo(pSystemInfo);

    //
    // Return process handle.
    //
    return(gUserLogonInfo.ShellHandle = hProcess);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetShellProcessToken
//
//  Synopsis:
//
//  Returns:    ERROR_SUCCESS or an error code.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call and continue
//              to remain in this critical section for the lifetime use of
//              the returned handle.
//
//              DO NOT close the returned handle. It is a global handle.
//
//-----------------------------------------------------------------------------
HANDLE
GetShellProcessToken(void)
{
    HANDLE hProcess = GetShellProcessHandle();

    if (hProcess == NULL)
    {
        return(NULL);
    }

    HANDLE hToken = gUserLogonInfo.ShellToken;

    if (gUserLogonInfo.ShellToken == NULL)
    {
        if (OpenProcessToken(hProcess,
                             TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                             &hToken))
        {
            return(gUserLogonInfo.ShellToken = hToken);
        }
        else
        {
            ERR_OUT("GetShellProcessToken: OpenProcessToken", GetLastError());
            return(NULL);
        }
    }

    return gUserLogonInfo.ShellToken;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetSystemProcessInfo
//
//  Synopsis:   Return a block containing information about all processes
//              currently running in the system.
//
//  Returns:    A pointer to the system process information or NULL if it could
//              not be allocated or retrieved.
//
//-----------------------------------------------------------------------------
PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo(void)
{
#define SYSTEM_PROCESS_BUFFER_INCREMENT 4096

    NTSTATUS Status = 0;
    PUCHAR   pBuffer;
    DWORD    cbBufferSize;

    //
    // Get the process list.
    //

    cbBufferSize = SYSTEM_PROCESS_BUFFER_INCREMENT;

    pBuffer = (PUCHAR)LocalAlloc(LMEM_FIXED, cbBufferSize);

    if (pBuffer == NULL)
    {
        ERR_OUT("GetSystemProcessInfo: LocalAlloc", GetLastError());
        return(NULL);
    }

    for (;;)
    {
        Status = NtQuerySystemInformation(SystemProcessInformation,
                                          pBuffer,
                                          cbBufferSize,
                                          NULL);

        if (Status == STATUS_SUCCESS)
        {
            break;
        }
        else if (Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            cbBufferSize += SYSTEM_PROCESS_BUFFER_INCREMENT;
            PUCHAR pTempBuffer = (PUCHAR)LocalReAlloc(pBuffer, cbBufferSize, LMEM_MOVEABLE);
            if (pTempBuffer == NULL)
            {
                LocalFree(pBuffer);  // original handle is still valid; use it to free the memory
                ERR_OUT("GetSystemProcessInfo: LocalReAlloc", GetLastError());
                return(NULL);
            }
            pBuffer = pTempBuffer;  // LocalReAlloc succeeded, so use the new handle now
        }
        else
        {
            break;
        }
    }

    if (Status != STATUS_SUCCESS && pBuffer != NULL)
    {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }

    return (PSYSTEM_PROCESS_INFORMATION)pBuffer;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindProcessByName
//
//  Synopsis:   Given a pointer returned by GetSystemProcessInfo(), find
//              a process by name.
//              Hydra modification: Only processes on the physical console
//              session are included.
//
//  Arguments:  [pProcessInfo] - a pointer returned by GetSystemProcessInfo().
//              [lpExeName]    - a pointer to a Unicode string containing the
//                               process to be found.
//
//  Returns:    A pointer to the process information for the supplied
//              process or NULL if it could not be found.
//
//-----------------------------------------------------------------------------
PSYSTEM_PROCESS_INFORMATION
FindProcessByName(PSYSTEM_PROCESS_INFORMATION pProcessInfo, LPWSTR lpExeName)
{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //
    for (;;)
    {
        if (pProcessInfo->ImageName.Buffer != NULL)
        {
            schDebugOut((DEB_USER3, "FindProcessByName: process: %S (%d)\n",
                         pProcessInfo->ImageName.Buffer,
                         pProcessInfo->UniqueProcessId));
            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
            {
                //
                // Pick this process only if it's
                // running on the physical console session
                //
                DWORD dwSessionId;
                if (! ProcessIdToSessionId(
                            HandleToUlong(pProcessInfo->UniqueProcessId),
                            &dwSessionId))
                {
                    schDebugOut((DEB_ERROR, "ProcessIdToSessionId FAILED, %lu\n",
                                 GetLastError));
                }
                else if (dwSessionId == 0)
                {
                    return pProcessInfo;
                }
            }
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    schDebugOut((DEB_ITRACE, "FindProcessByName: process %ws not found\n", lpExeName));
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeSystemProcessInfo
//
//  Synopsis:   Free a buffer returned by GetSystemProcessInfo().
//
//  Arguments:  [pProcessInfo] - a pointer returned by GetSystemProcessInfo().
//
//-----------------------------------------------------------------------------
VOID
FreeSystemProcessInfo(PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    LocalFree(pProcessInfo);
}


//+----------------------------------------------------------------------------
//
//  Function:   ImpersonateLoggedInUser
//
//  Synopsis:   Impersonate the shell user.
//
//  Returns:
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call.
//
//-----------------------------------------------------------------------------
HANDLE
ImpersonateLoggedInUser(void)
{
    BOOL fDuplicateToken;

    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    if (gUserLogonInfo.ImpersonationThread == NULL)
    {
        if (gUserLogonInfo.ShellHandle == NULL)
        {
            if (GetShellProcessHandle() == NULL)
            {
                return(NULL);
            }
        }

        if (gUserLogonInfo.ShellToken == NULL)
        {
            if (GetShellProcessToken() == NULL)
            {
                return(NULL);
            }
        }
    }

    return(gUserLogonInfo.ImpersonationThread = ImpersonateUser(
                                gUserLogonInfo.ShellToken,
                                gUserLogonInfo.ImpersonationThread));
}







#endif  // FIND_USER_WITH_TS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\jpmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       jpmgr.cxx
//
//  Contents:   CJobProcessorMgr class implementation.
//
//  Classes:    CJobProcessorMgr
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"

// class CJobProcessorQueue
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorQueue::~CJobProcessorQueue
//
//  Synopsis:   Destructor. Destruct job processor queue.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessorQueue::~CJobProcessorQueue()
{
    TRACE3(CJobProcessorQueue, ~CJobProcessorQueue);

    CJobProcessor * pjp;

    while ((pjp = (CJobProcessor *)CQueue::RemoveElement()) != NULL)
    {
        pjp->Release();
    }
}

// class CJobProcessorMgr
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::NewProcessor
//
//  Synopsis:   Create a new job processor object and add it to the queue.
//
//  Arguments:  None.
//
//  Returns:    S_OK    -- Processor created successfully.
//              S_FALSE -- Service shutting down - ignore the request.
//              HRESULT -- On error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessorMgr::NewProcessor(CJobProcessor ** ppjp)
{
    TRACE3(CJobProcessorMgr, NewProcessor);

    CJobProcessor * pjp = new CJobProcessor;

    if (pjp == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = pjp->Initialize();

    if (FAILED(hr))
    {
        delete pjp;
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Check if the service is shutting down.
    //

    if (IsServiceStopping())
    {
        //
        // Shutdown & release the new processor. With a successful call to
        // CJobProcessor::Initialize(), another thread now references pjp.
        // Shutdown instructs the thread to stop servicing the processor.
        //
        // NB : DO NOT delete pjp! The worker thread maintains a reference
        //      until it has completed servicing it.
        //

        pjp->Shutdown();
        pjp->Release();
        return(S_FALSE);
    }

    EnterCriticalSection(&_csProcessorMgrCritSection);

    _JobProcessorQueue.AddElement(pjp);

    pjp->AddRef();      // For return below.

    LeaveCriticalSection(&_csProcessorMgrCritSection);

    *ppjp = pjp;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::GarbageCollection
//
//  Synopsis:   Dequeue and release unused job processor objects. This member
//              is to be called occasionally by an idle thread to clean up the
//              queue. Idle worker threads which have expired call this member
//              upon termination, for example. 
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessorMgr::GarbageCollection(void)
{
    TRACE3(CJobProcessorMgr, GarbageCollection);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    //
    // Evaluate all processors in the queue.
    //

    pjp = _JobProcessorQueue.GetFirstElement();

    while (pjp != NULL)
    {
        //
        // If a processor is idle and unreferenced, dequeue & release it.
        //
        // NB : CJobProcessor::Next() re-enters the critical section entered
        //      above. This is OK, though, since the nesting occurs within
        //      the same thread.
        //      Also, the processor object will be AddRef()'d as a result of
        //      Next(). The release logic undoes this.
        //

        CJobProcessor * pjpNext = pjp->Next();

        if (pjpNext != NULL)
        {
            pjpNext->Release();     // See note above.
        }

        if (pjp->IsIdle())
        {
            _JobProcessorQueue.RemoveElement(pjp);
            pjp->Release();
        }

        pjp = pjpNext;
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::GetFirstProcessor
//
//  Synopsis:   Return the first processor in the queue. This enables the
//              caller to enumerate the queue.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessorMgr::GetFirstProcessor(void)
{
    TRACE3(CJobProcessorMgr, GetFirstProcessor);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    pjp = _JobProcessorQueue.GetFirstElement();

    if (pjp != NULL)
    {
        pjp->AddRef();
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);

    return(pjp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::Shutdown
//
//  Synopsis:   Shutdown & release all processors.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessorMgr::Shutdown(void)
{
    TRACE3(CJobProcessorMgr, Shutdown);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    while ((pjp = _JobProcessorQueue.RemoveElement()) != NULL)
    {
        pjp->Shutdown();
        pjp->Release();
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\job.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job.cxx
//
//  Contents:   Stubs for the Job handler methods that are not in job.lib.
//
//  Notes:      This module allows job.lib to be statically linked into
//              mstask.exe. job.lib is built in sched\job and is linked to
//              both mstask.dll and mstask.exe. The *real* code resides in
//              sched\client\job.cxx.
//
//              BUGBUG : We *must* split CJob et al interface(s) into two
//                       classes: a small core base class, and an OLE
//                       supporting subclass. This would be a *significant*
//                       code savings in the service .exe.  For example,
//                       we would not need the E_NOTIMPL stub functions in 
//                       this file, or the CJob::Save implementation.
//
//  History:    14-Nov-95 EricB  created
//              06-Jun-96 MarkBl Renamed from juistubs.cxx and added
//                               Get/SetAccountInformation.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "svc_core.hxx"

// ref count global (not actually used since the service is an exe not a dll)
// UINT g_cDllRefs;

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::EditWorkItem
//
//  Synopsis:   Stub. Actual code in sched\client\jobedit.cxx and compiled
//              into mstask.dll.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::EditWorkItem(HWND hParent, DWORD dwReserved)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IProvideTaskPage::GetPage
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into job.dll.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetPage(
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetAccountInformation
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into mstask.dll. This is necessary, as otherwise, it would
//              be necessary to include the client rpc code into the service!
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetAccountInformation(
    LPCWSTR pwszAccountName,
    LPCWSTR pwszPassword)
{
    return(E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetAccountInformation
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into mstask.dll. This is necessary, as otherwise, it would
//              be necessary to include the client rpc code into the service!
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetAccountInformation(
    LPWSTR * ppwszAccountName)
{
    return(E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Save
//
//  Synopsis:   saves the object to storage
//
//  Arguments:  [pwszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//
//  Notes:      Sigh... New security code in IPersistFile::Save. The security
//              code is client-only; the service doesn't need it. This is
//              Save() sans security. As mentioned, if the split wasn't made,
//              we'd have to include the client rpc code into the service.
//
//              All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Save(
    LPCOLESTR pwszFileName,
    BOOL fRemember)
{
    HRESULT hr;

    //
    // Always do a full save.  Never alter the running instance count from the
    // COM interface method.
    //
    hr = SaveWithRetry(pwszFileName, fRemember, SAVEP_VARIABLE_LENGTH_DATA);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\log.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       log.cxx
//
//  Contents:   Logging routines for the job scheduler service.
//
//  Classes:    None.
//
//  Functions:  OpenLogFile
//              CloseLogFile
//              LogTaskStatus
//              LogTaskError
//              LogServiceStatus
//              LogServiceError
//              ConstructStatusField
//              ConstructResultField
//              GetSchedulerResultCodeString
//              OverwriteRecordFragment
//              IntegerToString
//
//  History:    1-Feb-96    MarkBl    Created.
//              24-Oct-96   AnirudhS  Modified to handle DBCS.
//              2-Feb-98    jschwart  Modified to handle Unicode.
//              26-Feb-01   JBenton   Prefix bug 294880
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <sddl.h>
#include "globals.hxx"
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "..\inc\common.hxx"

#define CCH_INT 11
#define ARRAY_LEN(a)    (sizeof(a)/sizeof(a[0]))

TCHAR *  ConstructStatusField(DWORD, SYSTEMTIME *, ULONG *);
TCHAR *  ConstructResultField(DWORD, LPTSTR);
TCHAR *  GetSchedulerResultCodeString(DWORD, DWORD);
TCHAR *  IntegerToString(ULONG, TCHAR *);
VOID     OverwriteRecordFragment(VOID);
VOID     WriteLog(LPTSTR);
BOOL     GetDateTime(const SYSTEMTIME *, LPTSTR, LPTSTR);
VOID     LogServiceMessage(LPCTSTR, DWORD);


//
// Note, this buffer must be at least double the size of the ASCII string:
//     "[ ***** Most recent entry is above this line ***** ]\r\n\r\n"
// to leave sufficient space for localization changes.
//
#define MOST_RECENT_ENTRY_MARKER_SIZE   128
static TCHAR gtszMostRecentEntryMarker[MOST_RECENT_ENTRY_MARKER_SIZE + 1] = TEXT("");

extern CStaticCritSec gcsLogCritSection;

HANDLE           ghLog           = NULL;
DWORD            gdwMaxLogSizeKB = NULL;
DWORD            gcbMostRecentEntryMarkerSize;


//+---------------------------------------------------------------------------
//
//  Function:   OpenLogFile
//
//  Synopsis:   Open the log file and position the global file pointer.
//
//              Log file path/name can be specified in in the registry as:
//              HKEY_LOCAL_MACHINE\Software\Microsoft\JobScheduler\LogPath.
//              If this value is not specified, or we fail somehow fetching
//              it, default to the log file name "SCHEDLGU.TXT" in the tasks folder.
//
//              The log file handle is cached as a global.
//
//  Arguments:  None.
//
//  Returns:    HRESULT status code.
//
//  Notes:      ** Important Note **
//
//              This function *must* be called *once* prior to log usage.
//              This function should be called after g_hInstance has been
//              initialized.
//
//----------------------------------------------------------------------------
HRESULT
OpenLogFile(VOID)
{
    TCHAR       tszBuffer[MAX_PATH + 1] = TEXT("\0");
    DWORD       cbBufferSize            = sizeof(tszBuffer);
    DWORD       dwMaxLogSizeKB          = MAX_LOG_SIZE_DEFAULT;
    DWORD       dwType;
    HKEY        hKey;
    HRESULT     hr = S_OK;

#define tszLogPath              TEXT("LogPath")
#define tszMaxLogSizeKB         TEXT("MaxLogSizeKB")
#define tszMarkerSentinel       TEXT("[ *****")
#define MARKER_SENTINEL_LENGTH  (ARRAY_LEN(tszMarkerSentinel) - 1)
#define READ_BUFFER_SIZE        512

    //
    // Even though this function should be called only once at service start up,
    // protect it with a critsec just in case someone tries to start two or more
    // instances of the scheduler service simultaneously
    //
    EnterCriticalSection(&gcsLogCritSection);

    if (ghLog != NULL)
    {
        hr = E_FAIL;
        schAssert(!"ghLog not NULL on entry to OpenLogFile -- attempted to run more than one instance of service?");
        goto ErrorExit;
    }

    // Load the most recent entry marker string from the resource table.
    // Set the size of the marker to the end of the string.  Otherwise,
    // the IsTextUnicode API (called by notepad) thinks this is Ansi.
    //
    gcbMostRecentEntryMarkerSize =

            LoadString(g_hInstance,
                       IDS_MOSTRECENTLOGENTRYMARKER,
                       gtszMostRecentEntryMarker,
                       MOST_RECENT_ENTRY_MARKER_SIZE + 1);

    if (!gcbMostRecentEntryMarkerSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    // Convert to size in bytes
    //
    gcbMostRecentEntryMarkerSize *= sizeof(TCHAR);

    // Read the log path and maximum size from the registry. Note that these
    // are stored in the service's key.
    //
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       SCH_AGENT_KEY,
                       0,
                       KEY_READ | KEY_SET_VALUE,
                       &hKey))
    {
        if (RegQueryValueEx(hKey,
                            tszLogPath,
                            NULL,
                            &dwType,
                            (UCHAR *)tszBuffer,
                            &cbBufferSize) ||
                            (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
        {
            //
            // Value is missing; create it with default
            //
            RegSetValueEx(hKey,
                          tszLogPath,
                          NULL,
                          REG_EXPAND_SZ,
                          (const BYTE *)TSZ_LOG_NAME_DEFAULT,
                          sizeof(TSZ_LOG_NAME_DEFAULT));

            // if this call fails, there isn't much we can do
            // but at least we've defaulted to a reasonable value
            // and can continue with logging
        }

        cbBufferSize = sizeof(dwMaxLogSizeKB);

        if (RegQueryValueEx(hKey,
                            tszMaxLogSizeKB,
                            NULL,
                            &dwType,
                            (UCHAR *)&dwMaxLogSizeKB,
                            &cbBufferSize) || dwType != REG_DWORD)
        {
            //
            // Value is missing; create it with default
            //
            dwMaxLogSizeKB = MAX_LOG_SIZE_DEFAULT;

            RegSetValueEx(hKey,
                          tszMaxLogSizeKB,
                          NULL,
                          REG_DWORD,
                          (CONST BYTE *)&dwMaxLogSizeKB,
                          cbBufferSize);

            // if this call fails, there isn't much we can do
            // but at least we've defaulted to a reasonable value
            // and can continue with logging
        }

        RegCloseKey(hKey);
    }

    // Default log path on error.
    //
    if (!tszBuffer[0])
    {
        StringCchCopy(tszBuffer, MAX_PATH + 1, TSZ_LOG_NAME_DEFAULT);
    }

    // Expand environment strings in the log path.
    //
    TCHAR tszFileName[MAX_PATH+1];
    DWORD cch = ExpandEnvironmentStrings(tszBuffer,
                                         tszFileName,
                                         ARRAY_LEN(tszFileName));
    if (cch == 0 || cch > ARRAY_LEN(tszFileName))
    {
        ERR_OUT("ExpandEnvironmentStrings", cch);
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    //
    // Obtain just the folder path from the full log file path
    //
    TCHAR tszLogFolderPath[MAX_PATH + 1];
    StringCchCopy(tszLogFolderPath, MAX_PATH + 1, tszFileName);
    TCHAR* ptszLastSlash = _tcsrchr(tszLogFolderPath, TEXT('\\'));
    if (ptszLastSlash)
        *ptszLastSlash = TEXT('\0');
    
    DWORD cchLogFolderPath = _tcslen(tszLogFolderPath);

    //
    // Compare the log file path with the tasks folder path;
    // The memory allocated by GetTasksFolder() must be deleted below.
    //
    TCHAR* ptszTasksFolder = NULL;
    hr = GetTasksFolder(&ptszTasksFolder);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    DWORD cchTasksFolder = _tcslen(ptszTasksFolder);

    if (cchLogFolderPath == cchTasksFolder && !_tcsnicmp(tszFileName, ptszTasksFolder, cchTasksFolder))
    {
        //
        // The log file is to be stored under the tasks folder;
        // if the tasks folder doesn't exist, create it and set security
        //
        hr = EnsureTasksFolderExists(ptszTasksFolder);
        if (FAILED(hr))
        {
            goto ErrorExit;
        }
    }
    else
    {
        //
        // The log file is to be stored under a different folder;
        // if the folder doesn't exist, create it and set security,
        // but do not enable our shell extension on this folder
        //
        hr = EnsureTasksFolderExists(tszLogFolderPath, FALSE);
        if (FAILED(hr))
        {
            goto ErrorExit;
        }
    }


    // create an appropriate ACL
    // note that it only takes effect if we're *creating* the file
    // we're basically adding read access for authenticated users on PRO
    //
    PSECURITY_DESCRIPTOR pSD = NULL;
    WCHAR* pwszSDDL = NULL;

    OSVERSIONINFOEX verInfo;
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFOW)&verInfo))
        return E_FAIL;

    if (verInfo.wProductType == VER_NT_WORKSTATION)
    {
        pwszSDDL = 
            L"D:(A;;FA;;;CO)(A;;FR;;;AU)(A;;FA;;;BA)(A;;FA;;;SY)";                
        //
        // generate SD to be used for tasks folder
        //
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(pwszSDDL, SDDL_REVISION_1, &pSD, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            goto ErrorExit;
        }
    }

    SECURITY_ATTRIBUTES sa;
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);


    // Create the file if it doesn't exist, open it if it does.
    //
    HANDLE hLog = CreateFile(tszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             (verInfo.wProductType == VER_NT_WORKSTATION) ? &sa : NULL,
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                             NULL);

    if (hLog == INVALID_HANDLE_VALUE)
    {
        // We're in a fine mess, bail.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        schDebugOut((DEB_ERROR, "Attempted to create file \"" FMT_TSTR "\"\n", tszFileName));
        goto ErrorExit;
    }

    TCHAR rgtBuffer[READ_BUFFER_SIZE / sizeof(TCHAR)];
    DWORD dwRead;
    DWORD iMarker = 0;  // Scope the marker index such that the search may span multiple reads.
    DWORD dwLoops = 0;  // Keep track of how many successful reads we've made.
                        // Used to figure out whether to write the UNICODE
                        // byte order mark (BOM) at the top of the file

    // Seek to the most recent entry marker. Do so by searching for the first
    // several distinguishable characters of the marker - a sentinel.
    //
    for (;;)
    {
        // Save away current file position for later file pointer adjustment.
        //
        LARGE_INTEGER liLogPos;

        liLogPos.QuadPart = 0;

        if ((liLogPos.LowPart = SetFilePointer(hLog,
                                               0,
                                               &liLogPos.HighPart,
                                               FILE_CURRENT)) == -1)
        {
            break;
        }

        if (!ReadFile(hLog, rgtBuffer, READ_BUFFER_SIZE, &dwRead, NULL) ||
                    !dwRead)
        {
            break;
        }

        // Convert to the number of characters (and chop off a stray byte
        // if it exists in the Unicode case)
        //
        dwRead /= sizeof(TCHAR);

        for (DWORD iBuffer = 0; iBuffer < dwRead; iBuffer++)
        {
            // If the first marker character is found, or the marker
            // comparison is continued from the previous read, evaluate
            // remaining marker string.
            //
            if (rgtBuffer[iBuffer] == TEXT('[') || iMarker)
            {
                for (; iMarker < MARKER_SENTINEL_LENGTH && dwRead - iBuffer;
                          iMarker++, iBuffer++)
                {
                    if (rgtBuffer[iBuffer] != tszMarkerSentinel[iMarker])
                    {
                        break;
                    }
                }

                // If the marker is found, stop & re-position the file
                // pointer for future writes.
                //
                if (iMarker == MARKER_SENTINEL_LENGTH)
                {
                    // Adjust file pointer accordingly.
                    //
                    liLogPos.QuadPart += iBuffer * sizeof(TCHAR);
                    liLogPos.QuadPart -= MARKER_SENTINEL_LENGTH * sizeof(TCHAR);

                    if (SetFilePointer(hLog,
                                       liLogPos.LowPart,
                                       &liLogPos.HighPart,
                                       FILE_BEGIN) != -1)
                    {
                        goto MarkerFound;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        CHECK_HRESULT(hr);
                    }
                }
                else if (iMarker < MARKER_SENTINEL_LENGTH && dwRead - iBuffer)
                {
                    // Almost a match, but not quite - reset for continued
                    // search.
                    //
                    iMarker = 0;
                }
            }
        }

    dwLoops++;
    }

    if (!dwLoops && !dwRead)
    {
        // We just created the file and it's empty, so write the Unicode BOM
        //

        DWORD cbWritten;
        WCHAR wcBOM = 0xFEFF;

        if (!WriteFile(hLog, &wcBOM, sizeof(WCHAR), &cbWritten, NULL) ||
                      !cbWritten)
        {
            // If we can't write to the log, we've got problems
            //
            CloseHandle(hLog);
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    // Marker not found. Seek to file end.
    //
    if (SetFilePointer(hLog, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
    {
        // Another fine mess, bail.
        //
        CloseHandle(hLog);
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        schAssert(!"Couldn't seek to log file end");
        goto ErrorExit;
    }

MarkerFound:
    gdwMaxLogSizeKB = dwMaxLogSizeKB;
    ghLog = hLog;

ErrorExit:
    if (pSD)
        LocalFree(pSD);

    if (ptszTasksFolder)
    {
        delete [] ptszTasksFolder;
    }
    LeaveCriticalSection(&gcsLogCritSection);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseLogFile
//
//  Synopsis:   Close log file and invalidate global handle.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      ** Important Note **
//
//              Presumably, this function is called on process closure.
//              Therefore, let the OS delete the critical section, *not* this
//              thread. Otherwise, the critical section can be deleted out
//              from under other threads currently accessing the log.
//
//----------------------------------------------------------------------------
VOID
CloseLogFile(VOID)
{
    //
    // If OpenLogFile has not completed successfully, the critical section
    // won't have been initialized nor the global file handle set.
    //
    if (ghLog != NULL)
    {
        // Handle close gracefully in case another thread is accessing the log.
        // Do so by entering the log critical section, closing the log and
        // invalidating the global log handle (setting it to NULL).
        //
        EnterCriticalSection(&gcsLogCritSection);

        if (ghLog)
        {
            CloseHandle(ghLog);
            ghLog = NULL;
        }

        LeaveCriticalSection(&gcsLogCritSection);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LogTaskStatus
//
//  Purpose:    Log successful task operations.
//
//  Arguments:  [ptszTaskName]   - the task name.
//              [ptszTaskTarget] - the application/document name.
//              [uMsgID]         - this would typically be either:
//                                 IDS_LOG_JOB_STATUS_STARTED or
//                                 IDS_LOG_JOB_STATUS_FINISHED
//              [dwExitCode]     - if uMsgID is IDS_LOG_JOB_STATUS_FINISHED,
//                                 it is the task exit code; ignored otherwise.
//
//----------------------------------------------------------------------------
VOID
LogTaskStatus(
    LPCTSTR ptszTaskName,
    LPTSTR  ptszTaskTarget,
    UINT    uMsgID,
    DWORD   dwExitCode)
{
    TCHAR   tszMsgFormat[SCH_BIGBUF_LEN];
    TCHAR * ptszStatusMsg = NULL;
    ULONG   ccSize;

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(NULL, tszDate, tszTime))
    {
        return;
    }

    TCHAR * ptszResultField = NULL;

    // Load the format string resource.
    //
    if (!LoadString(g_hInstance,
                    uMsgID,
                    tszMsgFormat,
                    ARRAY_LEN(tszMsgFormat)))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    if (uMsgID == IDS_LOG_JOB_STATUS_FINISHED)
    {
        ptszResultField = ConstructResultField(dwExitCode, ptszTaskTarget);

        if (ptszResultField == NULL)
        {
            return;
        }
    }

    TCHAR * rgptszInserts[] = { (TCHAR *)ptszTaskName,
                                (TCHAR *)ptszTaskTarget,
                                tszDate,
                                tszTime,
                                ptszResultField };

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING        |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        tszMsgFormat,
                        0,
                        0,
                        (TCHAR *)&ptszStatusMsg,
                        1,
                        (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        if (ptszResultField != NULL)
        {
            LocalFree(ptszResultField);
        }
        return;
    }

    WriteLog(ptszStatusMsg);

    LocalFree(ptszStatusMsg);
    if (ptszResultField != NULL)
    {
        LocalFree(ptszResultField);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LogTaskError
//
//  Purpose:    Log task warnings and errors.
//
//  Arguments:  [ptszTaskName]     - the task name.
//              [ptszTaskTarget]   - the application/document name.
//              [uSeverityMsgID]   - this would typically be either:
//                                   IDS_LOG_SEVERITY_WARNING or
//                                   IDS_LOG_SEVERITY_ERROR
//              [uErrorClassMsgID] - this indicates the class of error, such
//                                   as "Unable to start task" or "Forced to
//                                   close"
//              [pst]              - the time when the error occured; if NULL,
//                                   enters the current time.
//              [dwErrorCode]      - if non-zero, then an error from the OS
//                                   that would be expanded by FormatMessage.
//              [uHelpHintMsgID]   - if an error, then a suggestion as to a
//                                   possible remedy.
//
//----------------------------------------------------------------------------
VOID
LogTaskError(
    LPCTSTR ptszTaskName,
    LPCTSTR ptszTaskTarget,
    UINT    uSeverityMsgID,
    UINT    uErrorClassMsgID,
    LPSYSTEMTIME pst,
    DWORD   dwErrCode,
    UINT    uHelpHintMsgID)
{
    TCHAR tszEmpty[] = TEXT("");

    //
    // Verify params:
    //

    if (ptszTaskName == NULL)
    {
        ptszTaskName = tszEmpty;
    }
    if (ptszTaskTarget == NULL)
    {
        ptszTaskTarget = tszEmpty;
    }

    TCHAR tszFormat[SCH_BUF_LEN];

    //
    // Compose the first part of the error log entry:
    // "<task name>" (<task target>) <time> ** [WARNING | ERROR] **
    //

    if (!LoadString(g_hInstance,
                    uSeverityMsgID,
                    tszFormat,
                    SCH_BUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(pst, tszDate, tszTime))
    {
        return;
    }

    //
    // Obtain the error message string.
    //

    LPTSTR ptszErrMsg = ComposeErrorMsg(uErrorClassMsgID,
                                        dwErrCode,
                                        uHelpHintMsgID);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    //
    // Glue the whole mess together.
    //

    TCHAR * rgptszInserts[] = { (TCHAR *)ptszTaskName,
                                (TCHAR *)ptszTaskTarget,
                                tszDate,
                                tszTime,
                                ptszErrMsg };

    TCHAR * ptszLogStr;

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        LocalFree(ptszErrMsg);
        return;
    }

    WriteLog(ptszLogStr);

    LocalFree(ptszErrMsg);
    LocalFree(ptszLogStr);
}

//+---------------------------------------------------------------------------
//
//  Function:   LogServiceError
//
//  Purpose:    Log service failures.
//
//  Arguments:  [uErrorClassMsgID] - as above.
//              [dwErrCode]        - as above.
//              [uHelpHintMsgID]   - as above.
//
//----------------------------------------------------------------------------
VOID
LogServiceError(
    UINT uErrorClassMsgID,
    DWORD dwErrCode,
    UINT uHelpHintMsgID)
{
    TCHAR   tszSvcErrMsgFormat[SCH_MEDBUF_LEN];

    if (LoadString(g_hInstance,
                   IDS_LOG_SERVICE_ERROR,
                   tszSvcErrMsgFormat,
                   SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        //
        // Generic error message if things are really foobared.
        //
        StringCchCopy(tszSvcErrMsgFormat, SCH_MEDBUF_LEN,
                TEXT("\042Task Scheduler Service\042 ** FATAL ERROR **\n"));
        WriteLog(tszSvcErrMsgFormat);
        return;
    }

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(NULL, tszDate, tszTime))
    {
        return;
    }

    LPTSTR ptszErrMsg = ComposeErrorMsg(uErrorClassMsgID,
                                        dwErrCode,
                                        uHelpHintMsgID);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    TCHAR * rgptszInserts[] = {tszDate, tszTime, ptszErrMsg};
    TCHAR * ptszLogStr;

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszSvcErrMsgFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        LocalFree(ptszErrMsg);
        return;
    }

    WriteLog(ptszLogStr);

    LocalFree(ptszErrMsg);
    LocalFree(ptszLogStr);
}

//+---------------------------------------------------------------------------
//
//  Function:   LogServiceEvent
//
//  Synopsis:   Write the service event to the log file.
//
//  Purpose:    Note the starting, stopping, pausing, and continuing of the
//              service.
//
//  Arguments:  [uStrId] - a string identifying the event.
//
//----------------------------------------------------------------------------
VOID
LogServiceEvent(UINT uStrId)
{
    TCHAR * ptszSvcMsg;
    ULONG   cbMsgSize;
    SYSTEMTIME st;

    GetLocalTime(&st);

    ptszSvcMsg = ConstructStatusField(uStrId, &st, &cbMsgSize);

	if( NULL == ptszSvcMsg )
	{
		schDebugOut((DEB_ITRACE, "LogServiceEvent - ConstructStatusField(uStrId, &st, &cbMsgSize) failed!\n"));
		return;
	}

    LogServiceMessage(ptszSvcMsg, cbMsgSize);

    LocalFree(ptszSvcMsg);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogMissedRuns
//
//  Synopsis:   Write details about missed runs to the log file.
//
//  Arguments:  [pstLastRun], [pstNow] - times between which runs were missed.
//
//----------------------------------------------------------------------------
VOID
LogMissedRuns(const SYSTEMTIME * pstLastRun, const SYSTEMTIME * pstNow)
{
    TCHAR tszLastRunDate[SCH_MEDBUF_LEN];
    TCHAR tszLastRunTime[SCH_MEDBUF_LEN];
    TCHAR tszNowDate    [SCH_MEDBUF_LEN];
    TCHAR tszNowTime    [SCH_MEDBUF_LEN];

    if (!GetDateTime(pstLastRun, tszLastRunDate, tszLastRunTime) ||
        !GetDateTime(pstNow, tszNowDate, tszNowTime))
    {
        return;
    }

    TCHAR tszMsgFormat[SCH_BIGBUF_LEN];
    if (!LoadString(g_hInstance,
                    IDS_LOG_RUNS_MISSED,
                    tszMsgFormat,
                    SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    TCHAR * rgptszInserts[] = { tszLastRunDate, tszLastRunTime,
                                tszNowDate, tszNowTime };

    TCHAR * ptszLogStr;
    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING        |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszMsgFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    LogServiceMessage(ptszLogStr, (lstrlen(ptszLogStr) + 1) * sizeof(TCHAR));

    LocalFree(ptszLogStr);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogServiceMessage
//
//  Synopsis:   Write a generic service message to the log file.
//
//  Purpose:    Used by LogServiceEvent and LogMissedRuns.
//
//  Arguments:  [ptszStrMsg] - a string message.
//              [cbStrMsg]   - size of pszStrMsg in bytes (may be overestimated,
//                  used only to calculate size of intermediate buffer.)
//
//----------------------------------------------------------------------------
VOID
LogServiceMessage(LPCTSTR ptszStrMsg, DWORD cbStrMsg)
{
    size_t cchMsg = SCH_MEDBUF_LEN + (cbStrMsg / sizeof(TCHAR)) + 1;
    TCHAR * ptszMsg = (TCHAR *)LocalAlloc(LPTR, cchMsg * sizeof(TCHAR));
    if (ptszMsg == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    if (LoadString(g_hInstance,
                   IDS_LOG_SERVICE_TITLE,
                   ptszMsg,
                   SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        //
        // Generic error message if things are really foobared.
        //
        StringCchCopy(ptszMsg, cchMsg, TEXT("\042Task Scheduler Service\042 ** ERROR **\n"));
    }

    if (ptszStrMsg != NULL)
    {
        StringCchCat(ptszMsg, cchMsg, ptszStrMsg);
    }

    WriteLog(ptszMsg);

    LocalFree(ptszMsg);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteLog
//
//  Synopsis:   Write the string to the log file.
//
//----------------------------------------------------------------------------
VOID
WriteLog(LPTSTR ptsz)
{
    LARGE_INTEGER liCurLogSize, liMaxLogSize;
    DWORD cbWritten;
    ULONG cbStringSize = lstrlen(ptsz) * sizeof(TCHAR);
    ULONG cbDataSize = cbStringSize;

    EnterCriticalSection(&gcsLogCritSection);

    schDebugOut((DEB_TRACE, "LOG:\n " FMT_TSTR "", ptsz));

    // Lose some time here by not caching this value, but not much.
    //
    cbDataSize += lstrlen(gtszMostRecentEntryMarker) * sizeof(TCHAR);

    // Get the current log size to see if there is room to write this.
    //
    liCurLogSize.QuadPart = 0;

    if ((liCurLogSize.LowPart = SetFilePointer(ghLog,
                                               0,
                                               &liCurLogSize.HighPart,
                                               FILE_CURRENT)) == -1)
    {
        goto ErrorExit_A;
    }

    // Add current data size. Convert maximum size to bytes for comparison.
    //
    liCurLogSize.QuadPart += cbDataSize;

    liMaxLogSize.QuadPart = gdwMaxLogSizeKB * 1024;

    // Is there sufficient space to write the entry?
    //
    if (liCurLogSize.QuadPart > liMaxLogSize.QuadPart)
    {
        // No, adjust the end of file to eliminate the most recent entry
        // marker & wrap to beginning.
        //
        SetEndOfFile(ghLog);            // Ignore return code.

        //  skip the BOM
        //
        if (SetFilePointer(ghLog, sizeof(WCHAR), NULL, FILE_BEGIN) == -1)
        {
            // Seek failure
            //
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
			schAssert(!"Couldn't seek log file");
			goto ErrorExit_A;
        }
    }

    // Write the string.
    //
    if (!WriteFile(ghLog, ptsz, cbStringSize, &cbWritten, NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    // Write most recent entry marker.
    //
    // First, save the current file pointer position. This will be the
    // starting location of the next log write. Note: double-timing current
    // log size local since it is no longer used.
    //
    liCurLogSize.QuadPart = 0;

    if ((liCurLogSize.LowPart = SetFilePointer(ghLog,
                                               0,
                                               &liCurLogSize.HighPart,
                                               FILE_CURRENT)) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    if (!WriteFile(ghLog,
                   gtszMostRecentEntryMarker,
                   gcbMostRecentEntryMarkerSize,
                   &cbWritten,
                   NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    // If the log has wrapped, it's likely the write pointer is positioned
    // somewhere in the middle of the next record. If this is the case,
    // the remaining partial record must be overwritten with spaces.
    //
    OverwriteRecordFragment();

    // Restore log position for next write.
    //
    if (SetFilePointer(ghLog,
                       liCurLogSize.LowPart,
                       &liCurLogSize.HighPart,
                       FILE_BEGIN) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }

ErrorExit_A:
    LeaveCriticalSection(&gcsLogCritSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   OverwriteRecordFragment
//
//  Synopsis:   If the log has wrapped, the last write most likely has
//              partially overwritten a record. This routine overwrites such
//              record fragments with spaces up to the next record.
//
//              Fundamental assumption - how a record is designated: The start
//              of a new record is designated by the two characters \n". This
//              routine simply fills text with spaces up to but not including
//              this character sequence.
//
//  Arguments:  None.
//
//  Returns:    N/A
//
//  Notes:      Upon exit, the log file pointer is restored to its original
//              position on entry.
//
//----------------------------------------------------------------------------
VOID
OverwriteRecordFragment(VOID)
{
    TCHAR         rgtBuffer[READ_BUFFER_SIZE / sizeof(TCHAR)];
    LARGE_INTEGER liSavedLogPos, liLogPos;
    DWORD         dwRead;

    // Save file pointer position during read for subsequent write.
    //
    liSavedLogPos.QuadPart = 0;

    if ((liSavedLogPos.LowPart = SetFilePointer(ghLog,
                                                0,
                                                &liSavedLogPos.HighPart,
                                                FILE_CURRENT)) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    // From the previous write, the last character is a line feed.
    //
    TCHAR  tchPrev = TEXT('\n');
    TCHAR  tchCur;
    int    cbOverwrite = 0;
    DWORD  i = 0;    // Index of chCur in rgbBuffer

    for (;;)
    {
        if (!ReadFile(ghLog, rgtBuffer, READ_BUFFER_SIZE, &dwRead, NULL) ||
                      !dwRead)
        {
            break;
        }

        // Convert to the number of characters (and chop off a stray byte
        // if it exists in the Unicode case)
        //
        dwRead /= sizeof(TCHAR);

        for ( ; i < dwRead; i++, cbOverwrite += sizeof(TCHAR))
        {
            tchCur = rgtBuffer[i];

            if (tchPrev == TEXT('\n') && tchCur == TEXT('"') && cbOverwrite > 2 * sizeof(TCHAR))
            {
                break;
            }
            tchPrev = tchCur;
        }

        if (i < dwRead)
        {
            // We found the \n" character sequence.  Don't
            // overwrite the \r\n" sequence of the next record.
            //
            cbOverwrite -= 2 * sizeof(TCHAR);
            break;
        }

        i = 0;
    }

    DWORD cbWritten;

    // Overwrite record fragment with spaces.
    //
    if (cbOverwrite > 0)
    {
        // Adjust file pointer from read above.
        //
        if (SetFilePointer(ghLog,
                           liSavedLogPos.LowPart,
                           &liSavedLogPos.HighPart,
                           FILE_BEGIN) != -1)
        {
            for (UINT uCount = 0;
                      uCount < READ_BUFFER_SIZE / sizeof(TCHAR);
                      uCount++)
            {
                rgtBuffer[uCount] = TEXT(' ');
            }

            while (cbOverwrite > 0)
            {
                if (!WriteFile(ghLog,
                               rgtBuffer,
                               min(cbOverwrite, READ_BUFFER_SIZE),
                               &cbWritten,
                               NULL))
                {
                    CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    break;
                }

                cbOverwrite -= cbWritten;
            }
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ConstructStatusField
//
//  Synopsis:   Retrieve the status field with an optional status timestamp
//              insert.
//
//  Arguments:  [dwStatusFieldMsgID] -- Status field format string msg id.
//              [pstStatusTime]      -- Optional status timestamp. If NULL,
//                                      no timestamp is written.
//              [pcbSize]            -- Returned status field size (bytes).
//
//  Returns:    TCHAR * status field
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
ConstructStatusField(
    DWORD        dwStatusFieldMsgID,
    SYSTEMTIME * pstStatusTime,
    ULONG *      pcbSize)
{
    // Note: Insure string buffer sizes are at least double the size of the
    //       largest string they'll contain, for localization reasons.
    //
    TCHAR   tszStatusFieldFormat[SCH_BIGBUF_LEN];
    TCHAR   tszDate[SCH_MEDBUF_LEN];
    TCHAR   tszTime[SCH_MEDBUF_LEN];
    TCHAR * rgptszInserts[] = { tszDate, tszTime };
    TCHAR * ptszStatusField = NULL;

    // The status field may/may not contain a date & time. The first
    // branch is taken for status fields containing them.
    //
    if (pstStatusTime != NULL)
    {
        // Add the date & time as inserts to the status field format string.
        //
        if (!GetDateTime(pstStatusTime, tszDate, tszTime))
        {
            return(NULL);
        }
    }

    ULONG ccSize = 0;

    // Load the status field format string resource.
    //
    if (LoadString(g_hInstance,
                   dwStatusFieldMsgID,
                   tszStatusFieldFormat,
                   SCH_BIGBUF_LEN))
    {
        if (!(ccSize = FormatMessage(FORMAT_MESSAGE_FROM_STRING       |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER |
               (pstStatusTime != NULL ? FORMAT_MESSAGE_ARGUMENT_ARRAY : 0),
                                     tszStatusFieldFormat,
                                     0,
                                     0,
                                     (TCHAR *)&ptszStatusField,
                                     1,
               (pstStatusTime != NULL ? (va_list *) rgptszInserts : NULL))))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }

    *pcbSize = ccSize * sizeof(TCHAR);

    return(ptszStatusField);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConstructResultField
//
//  Synopsis:   Retrieve the result field. Algorithm:
//
//              The result code is the job's exit code. Utilize the following
//              algorithm to obtain the exit code string:
//
//                  Attempt to fetch the the exit code string as a
//                  message binary specified in the Job Scheduler portion of
//                  the registry.
//
//                  If this fails, produce a default
//                  "message not found for exit code (n)" message.
//
//              Insert the result string obtained above as an insert string
//              to the result field format string.
//
//  Arguments:  [dwResultCode]       -- Result field result code.
//              [ptszJobExecutable]  -- Binary name executed by the job.
//
//  Returns:    TCHAR * result field
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
ConstructResultField(
    DWORD  dwResultCode,
    LPTSTR ptszJobExecutable)
{
    // Note: Insure format string buffer size is at least double the size of
    //       the largest string it will contain, for localization reasons.
    //
    TCHAR   tszResultFieldFormat[SCH_MEDBUF_LEN];
    TCHAR   tszResultCodeValue[CCH_INT + 1];
    TCHAR * ptszResultField = NULL;
    TCHAR * ptszResult;

    IntegerToString(dwResultCode, tszResultCodeValue);

    // Job exit code. Fetch the exit code string from the
    // ExitCodeMessageFile associated with the job program.
    //
    if ((ptszResult = GetExitCodeString(dwResultCode,
                                        tszResultCodeValue,
                                        (TCHAR *)ptszJobExecutable)) == NULL)
    {
        // Produce a default "message not found" result string.
        //
        ptszResult = GetSchedulerResultCodeString(
                                         IDS_LOG_EXIT_CODE_MSG_NOT_FOUND,
                                         dwResultCode);
    }

    ULONG ccSize = 0;

    // Load the result field format string resource.
    //
    if (ptszResult != NULL)
    {
        if (LoadString(g_hInstance,
                       IDS_LOG_JOB_RESULT_FINISHED,
                       tszResultFieldFormat,
                       SCH_MEDBUF_LEN))
        {
            TCHAR * rgtszInserts[] = { ptszResult, tszResultCodeValue };

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING       |
                                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               tszResultFieldFormat,
                               0,
                               0,
                               (TCHAR *)&ptszResultField,
                               1,
                               (va_list *) rgtszInserts))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            }

            LocalFree(ptszResult);       // pszResultField now encapsulates
                                        // this string.
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    return(ptszResultField);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSchedulerResultCodeString
//
//  Synopsis:   Fetch the result code from the schedule service process.
//
//  Arguments:  [dwResultMsgID] -- Result message string ID.
//              [dwResultCode]  -- result code.
//
//  Returns:    TCHAR * result code string
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
GetSchedulerResultCodeString(
    DWORD  dwResultMsgID,
    DWORD  dwResultCode)
{
    TCHAR   tszResultCodeValue[SCH_SMBUF_LEN];
    TCHAR   tszErrMsg[SCH_MEDBUF_LEN];
    TCHAR * ptszErrMsg = NULL, * ptszResultCode = NULL;
    DWORD   ccLength;
    TCHAR * rgtszInserts[] = { tszResultCodeValue, ptszErrMsg };

    IntegerToString(dwResultCode, tszResultCodeValue);

    TCHAR tszMsgBuf[MAX_PATH], * ptsz;

    if (LoadString(g_hInstance, dwResultMsgID, tszMsgBuf, MAX_PATH) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return NULL;
    }

    if (dwResultCode != 0)
    {
        BOOL fDelete = FALSE;
        //
        // Try to obtain an error message from the system.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       NULL,
                                       dwResultCode,
                                       LOCALE_SYSTEM_DEFAULT,
                                       (TCHAR *)&ptszErrMsg,
                                       1,
                                       NULL)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));

            if (!LoadString(g_hInstance,
                            IDS_GENERIC_ERROR_MSG,
                            tszErrMsg,
                            SCH_MEDBUF_LEN))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                return NULL;
            }

            ptszErrMsg = tszErrMsg;
        }
        else
        {
            fDelete = TRUE;

            //
            // Overwrite \r\n with a null characters.
            //
            ptsz = ptszErrMsg + ccLength - 2;

            *ptsz++ = TEXT('\0');
            *ptsz   = TEXT('\0');
        }

        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       tszMsgBuf,
                                       0,
                                       0,
                                       (TCHAR *)&ptszResultCode,
                                       2,
                                       (va_list *) rgtszInserts)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            if (fDelete) LocalFree(ptszErrMsg);
            return NULL;
        }

        if (fDelete) LocalFree(ptszErrMsg);
    }
    else
    {
        //
        // No result code. All of the info is encapsulated in dwResultMsgID,
        // which has no inserts.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       tszMsgBuf,
                                       0,
                                       0,
                                       (TCHAR *)&ptszResultCode,
                                       1,
                                       NULL)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return NULL;
        }
    }

    return(ptszResultCode);
}

//+---------------------------------------------------------------------------
//
//  Function:   IntegerToString
//
//  Synopsis:   Converts a 32 bit integer to a string.
//
//  Arguments:  [n]       -- Converted int.
//              [ptszBuf] -- Caller allocated buffer.
//
//  Returns:    Buffer ptr passed.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
TCHAR *
IntegerToString(ULONG n, TCHAR * tszBuf)
{
    //
    // Assemble hex representation into passed buffer, reversed,
    // then reverse in-place into correct format
    //
    // This code deliberately eschews ultoa, since div and mod 16
    // optimize so very nicely.
    //

    UINT ich = 0;

    do
    {
        UINT nDigitValue = (UINT)(n % 16);

        n /= 16;

        if (nDigitValue > 9)
        {
            tszBuf[ich++] = (WCHAR)nDigitValue - 10 + TEXT('a');
        }
        else
        {
            tszBuf[ich++] = (WCHAR)nDigitValue + TEXT('0');
        }

    } while (n > 0);

    tszBuf[ich] = TEXT('\0');

    _tcsrev(tszBuf);

    return(tszBuf);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDateTime
//
//  Synopsis:   Formats the date and time.
//
//  Arguments:  [pst]      - The time to use; if NULL, then the current time
//                           is obtained.
//              [ptszDate] - The date string buffer.
//              [ptszTime] - The time string buffer.
//
//  Returns:    TRUE for success, FALSE for failure.
//
//  Notes:      Note that the buffers must be at least SCH_MEDBUF_LEN in size.
//
//----------------------------------------------------------------------------
BOOL
GetDateTime(const SYSTEMTIME * pst, LPTSTR ptszDate, LPTSTR ptszTime)
{
    SYSTEMTIME st;

    if (pst == NULL)
    {
        GetLocalTime(&st);
        pst = &st;
    }

    if (!GetDateFormat(LOCALE_USER_DEFAULT,
                       LOCALE_NOUSEROVERRIDE,
                       pst,
                       NULL,
                       ptszDate,
                       SCH_MEDBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    if (!GetTimeFormat(LOCALE_USER_DEFAULT,
                       LOCALE_NOUSEROVERRIDE,
                       pst,
                       NULL,
                       ptszTime,
                       SCH_MEDBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\lsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       lsa.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  None.
//
//  History:    15-May-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <ntsecapi.h>
#include <mstask.h>
#include <msterr.h>
#include "lsa.hxx"
#include "debug.hxx"

BYTE grgbDeletedEntryMarker[] =
    { 'D', 'E', 'L', 'E', 'T', 'E', 'D', '_', 'E', 'N', 'T', 'R', 'Y' };

static WCHAR gwszSAI[] = L"SAI";
static WCHAR gwszSAC[] = L"SAC";


//+---------------------------------------------------------------------------
//
//  Function:   ReadSecurityDBase
//
//  Synopsis:
//
//  Arguments:  [pcbSAI] --
//              [ppbSAI] --
//              [pcbSAC] --
//              [ppbSAC] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
ReadSecurityDBase(
    DWORD * pcbSAI,
    BYTE ** ppbSAI,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    HRESULT hr;

    *ppbSAI = *ppbSAC = NULL;

    // Read the SAC.
    //
    hr = ReadLsaData(sizeof(gwszSAC), gwszSAC, pcbSAC, ppbSAC);

    if (SUCCEEDED(hr))
    {
        // Read the SAI.
        //
        hr = ReadLsaData(sizeof(gwszSAI), gwszSAI, pcbSAI, ppbSAI);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Check the sizes. For sizes greater than zero, but less than the
        // header size, deallocate the memory and zero the returned sizes,
        // ptrs.
        //
        // This seems inefficient, but it saves quite a few checks in the
        // SAC/SAI API.
        //

        if (*pcbSAI && *pcbSAI <= SAI_HEADER_SIZE)
        {
            *pcbSAI = 0;
            LocalFree(*ppbSAI);
            *ppbSAI = NULL;
        }

        if (*pcbSAC && *pcbSAC <= SAC_HEADER_SIZE)
        {
            *pcbSAC = 0;
            LocalFree(*ppbSAC);
            *ppbSAC = NULL;
        }

        //
        // Ensure the databases are in sync. The first DWORD is a USN (Update
        // Sequence Number). Its value increases monotonically for every
        // write to the LSA. The SAI & SAC USN values must be equal. If not,
        // they are out of sync with each other - an unrecoverable problem.
        // Also check the SAI SetArrayCount vs. the SAC CredentialCount as
        // these values must also be equal or the they are out of sync.
        //

        if (((*ppbSAI != NULL && *ppbSAC == NULL)  ||
             (*ppbSAI == NULL && *ppbSAC != NULL)) ||
            (*ppbSAI != NULL && *ppbSAC != NULL &&
             ((DWORD)**ppbSAI != (DWORD)**ppbSAC || (DWORD)*(*ppbSAI + USN_SIZE) != (DWORD)*(*ppbSAC + USN_SIZE))
            )
           )
        {
            schAssert(0 && "Scheduling Agent security database out of sync!");
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
        }
    }

    if (FAILED(hr))
    {
        if (*ppbSAI != NULL) LocalFree(*ppbSAI);
        if (*ppbSAC != NULL) LocalFree(*ppbSAC);
        *ppbSAI = *ppbSAC = NULL;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSecurityDBase
//
//  Synopsis:
//
//  Arguments:  [cbSAI] --
//              [pbSAI] --
//              [cbSAC] --
//              [pbSAC] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
WriteSecurityDBase(
    DWORD  cbSAI,
    BYTE * pbSAI,
    DWORD  cbSAC,
    BYTE * pbSAC)
{
    HRESULT hr;

    //
    // Just in case...
    //
    if (!pbSAI || !pbSAC)
    {
        schAssert(0 && "NULL pointers passed to WriteSecurityDBase!");
        return(E_FAIL);
    }

    //
    // If the secrets are out-of-sync, don't write them -- this will help preserve the integrity of the db.
    // Assert on checked builds so we know there still is a problem that leads to out-of-sync condition.
    //
    if ((DWORD)*(pbSAI + USN_SIZE) != (DWORD)*(pbSAC + USN_SIZE))
    {
        schAssert(0 && "Scheduling Agent security database SetArrayCount and CredentialCount out of sync!");
        return(E_FAIL);
    }

    // read the previous SAI so that we can put it back in case of failure
    DWORD cbSAIold;
    BYTE* pbSAIold = NULL;
    hr = ReadLsaData(sizeof(gwszSAI), gwszSAI, &cbSAIold, &pbSAIold);
    if (FAILED(hr))
        return hr;

    //
    // Advance the USN (Update Sequence Numbers) on the SAI & SAC. They
    // should always remain equal. Otherwise, they'll be out of sync
    // with each other - an unrecoverable problem.
    //
    (DWORD)(*pbSAI)++;
    (DWORD)(*pbSAC)++;

    // Write the SAI.
    //
    hr = WriteLsaData(sizeof(gwszSAI), gwszSAI, cbSAI, pbSAI);

    if (SUCCEEDED(hr))
    {
        // Write the SAC.
        //
        hr = WriteLsaData(sizeof(gwszSAC), gwszSAC, cbSAC, pbSAC);

        // attempt to put it back in case of failure.
        // if this fails, there's not much we can do; the db is invalid either way
        // if it succeeds, then we've got a good db again
        // even though this *function* has failed to record the updated db
        if (FAILED(hr))
            WriteLsaData(sizeof(gwszSAI), gwszSAI, cbSAIold, pbSAIold);
    }
    
    if (pbSAIold)
        LocalFree(pbSAIold);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadLsaData
//
//  Synopsis:
//
//  Arguments:  [cbKey]   --
//              [pwszKey] --
//              [pcbData] --
//              [ppbData] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
ReadLsaData(WORD cbKey, LPCWSTR pwszKey, DWORD * pcbData, BYTE ** ppbData)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    PLSA_UNICODE_STRING   psData;
    NTSTATUS              Status;

    //
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    //

    sKey.Length        = cbKey;
    sKey.MaximumLength = cbKey;
    sKey.Buffer        = (LPWSTR)pwszKey;

    //
    // Open the LSA.
    //

    Status = LsaOpenPolicy(NULL,
                           &ObjectAttributes,
                           POLICY_GET_PRIVATE_INFORMATION,
                           &hPolicy);

    if (!(Status >= 0))
    {
        return(E_FAIL);
    }

    //
    // Retrieve the LSA data associated with the key passed.
    //

    Status = LsaRetrievePrivateData(hPolicy, &sKey, &psData);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        (Status >= 0 && psData == NULL))
    {
        LsaClose(hPolicy);
        *pcbData = 0;
        *ppbData = NULL;
        return(S_FALSE);
    }
    else if (!(Status >= 0))
    {
        LsaClose(hPolicy);
        return(E_FAIL);
    }

    LsaClose(hPolicy);

    //
    // Create a copy of the LSA data to return. Why? The LSA private data
    // is callee allocated, so we are not free to reallocate the memory
    // as-needed.
    //

    BYTE * pbData = (BYTE *)LocalAlloc(LMEM_FIXED, psData->Length);

    if (pbData == NULL)
    {
        LsaFreeMemory(psData);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = S_OK;

    //
    // Wrapping in a try/except in case the data read from the LSA is bad.
    //

    __try
    {
        CopyMemory(pbData, psData->Buffer, psData->Length);

        //
        // Update out ptrs.
        //
        // NB : Making the assignment in here to save on an rc check.
        //

        *pcbData = psData->Length;
        *ppbData = pbData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        schAssert(0 &&
                  "Exception reading Scheduling Agent security database!");
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    LsaFreeMemory(psData);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLsaData
//
//  Synopsis:
//
//  Arguments:  [cbKey]   --
//              [pwszKey] --
//              [cbData]  --
//              [pbData]  --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
WriteLsaData(WORD cbKey, LPCWSTR pwszKey, DWORD cbData, BYTE * pbData)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    LSA_UNICODE_STRING    sData;
    NTSTATUS              Status;

    //
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    //

    sKey.Length        = cbKey;
    sKey.MaximumLength = cbKey;
    sKey.Buffer        = (LPWSTR)pwszKey;

    sData.Length        = (WORD)cbData;
    sData.MaximumLength = (WORD)cbData;
    sData.Buffer        = (WCHAR *)pbData;

    //
    // Open the LSA.
    //

    Status = LsaOpenPolicy(NULL,
                           &ObjectAttributes,
                           POLICY_CREATE_SECRET,
                           &hPolicy);

    if (!(Status >= 0))
    {
        return(E_FAIL);
    }

    //
    // Write the LSA data associated with the key passed.
    //

    Status = LsaStorePrivateData(hPolicy, &sKey, &sData);

    if (!(Status >= 0))
    {
        LsaClose(hPolicy);
        return(E_FAIL);
    }

    LsaClose(hPolicy);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteLsaData
//
//  Synopsis:
//
//  Arguments:  [cbKey]   --
//              [pwszKey] --
//
//----------------------------------------------------------------------------
HRESULT
DeleteLsaData(WORD cbKey, LPCWSTR pwszKey)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    NTSTATUS              Status;

    //
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    //

    sKey.Length        = cbKey;
    sKey.MaximumLength = cbKey;
    sKey.Buffer        = (LPWSTR)pwszKey;

    //
    // Open the LSA.
    //

    Status = LsaOpenPolicy(NULL,
                           &ObjectAttributes,
                           POLICY_CREATE_SECRET,
                           &hPolicy);

    if (!(Status >= 0))
    {
        return(E_FAIL);
    }

    //
    // Specifying NULL as the data causes LSA to delete the secret for that key
    //
    Status = LsaStorePrivateData(hPolicy, &sKey, NULL);

    if (!(Status >= 0))
    {
        LsaClose(hPolicy);
        return(E_FAIL);
    }

    LsaClose(hPolicy);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACAddCredential
//
//  Synopsis:
//
//  Arguments:  [pbCredentialIdentity] --
//              [cbCredential]         --
//              [pbCredential]         --
//              [pcbSAC]               --
//              [ppbSAC]               --
//
//  Notes:      try/except unnecessary here. Memory writes are guaranteed to
//              remain within the buffer allocated.
//
//----------------------------------------------------------------------------
HRESULT
SACAddCredential(
    BYTE *  pbCredentialIdentity,
    DWORD   cbEncryptedData,
    BYTE *  pbEncryptedData,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD dwCredentialCount = 1;
    DWORD cbCredentialSize  = HASH_DATA_SIZE + cbEncryptedData;

    //
    // Make room for the new credential.
    //

    DWORD  cbSACNew;
    BYTE * pbSACNew;

    cbSACNew = *pcbSAC + sizeof(cbCredentialSize) + cbCredentialSize;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSACNew > MAX_SECRET_SIZE)
    {
        // BUGBUG : Create a new error code for this error, something like
        // SCHED_E_CRED_LIMIT_EXCEEDED: "The system limit on the storage space 
        // for task account information has been reached."
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAC == 0)
    {
        cbSACNew += SAC_HEADER_SIZE;
        pbSACNew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSACNew);

        if (pbSACNew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //
        SecureZeroMemory(pbSACNew, SAC_HEADER_SIZE);
    }
    else
    {
        pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

        if (pbSACNew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // Adjust total credential count & prepare to write the credential.
    //

    BYTE * pbCredentialSizePos;

    if (*pcbSAC == 0)
    {
        //
        // First entry.
        //   - Write entry after header.
        //   - Initialize credential count to one (in declaration above).
        //

        pbCredentialSizePos = pbSACNew + SAC_HEADER_SIZE;
    }
    else
    {
        //
        // Append entry.
        //  - Append after last credential entry.
        //  - Increase credential count by one.
        //

        pbCredentialSizePos = pbSACNew + *pcbSAC;
        CopyMemory(&dwCredentialCount, pbSACNew + USN_SIZE,
                   sizeof(dwCredentialCount));
        dwCredentialCount++;
    }

    BYTE * pbCredentialIdentityPos;
    pbCredentialIdentityPos = pbCredentialSizePos + sizeof(cbCredentialSize);

    //
    // Update total credential count.
    //

    CopyMemory(pbSACNew + USN_SIZE, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    // Write total credential size, excluding the size value itself.
    //
    CopyMemory(pbCredentialSizePos, &cbCredentialSize,
                    sizeof(cbCredentialSize));

    // Write credential identity.
    //
    CopyMemory(pbCredentialIdentityPos, pbCredentialIdentity,
                        HASH_DATA_SIZE);

    // Finally, write encrypted credentials.
    //
    CopyMemory(pbCredentialIdentityPos + HASH_DATA_SIZE, pbEncryptedData,
                    cbEncryptedData);

    // Update out pointers.
    //
    *pcbSAC = cbSACNew;
    *ppbSAC = pbSACNew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACIndexCredential
//
//  Synopsis:
//
//  Arguments:  [dwCredentialIndex]  --
//              [cbSAC]              --
//              [pbSAC]              --
//              [pcbCredential]      --
//              [ppbFoundCredential] --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACIndexCredential(
    DWORD   dwCredentialIndex,
    DWORD   cbSAC,
    BYTE *  pbSAC,
    DWORD * pcbCredential,
    BYTE ** ppbFoundCredential)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundCredential != NULL) *ppbFoundCredential = NULL;

    if (cbSAC <= SAC_HEADER_SIZE || pbSAC == NULL)
    {
        return(hr);
    }

    BYTE * pbSACEnd = pbSAC + cbSAC;
    BYTE * pb       = pbSAC + USN_SIZE;       // Advance past USN.

    //
    // Read credential count.
    //

    DWORD dwCredentialCount;
    CopyMemory(&dwCredentialCount, pb, sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    //
    // Seek to credential index within the credential array.
    //

    DWORD cbCredentialSize;

    for (DWORD i = 0; (i < dwCredentialIndex) && (i < dwCredentialCount) &&
                ((DWORD)(pb - pbSAC) < cbSAC); i++)
    {
        //
        // Advance to next credential.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize) + cbCredentialSize;
    }

    if ((i == dwCredentialIndex) && (i < dwCredentialCount) &&
                ((DWORD)(pb - pbSAC) < cbSAC))
    {
        //
        // Found it, but ensure the contents referenced are valid.
        // Do so by checking remaining size.
        //

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize);

        if ((pb + cbCredentialSize) <= (pbSAC + cbSAC))
        {
            // Set the credential  & credential size return ptrs.
            //
            *pcbCredential = cbCredentialSize;

            // Optionally return a ptr to the credential.
            //
            if (ppbFoundCredential != NULL)
            {
                *ppbFoundCredential = pb;
            }
            hr = S_OK;
        }
        else
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
        }
    }
    else if ((i != dwCredentialCount) || ((DWORD)(pb - pbSAC) != cbSAC))
    {
        //
        // The database appears to be truncated.
        //

        ASSERT_SECURITY_DBASE_CORRUPT();
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACFindCredential
//
//  Synopsis:
//
//  Arguments:  [pbCredentialIdentity] --
//              [cbSAC]                --
//              [pbSAC]                --
//              [pdwCredentialIndex]   --
//              [pcbEncryptedData]     --
//              [ppbFoundCredential]   --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACFindCredential(
    BYTE *  pbCredentialIdentity,
    DWORD   cbSAC,
    BYTE *  pbSAC,
    DWORD * pdwCredentialIndex,
    DWORD * pcbEncryptedData,
    BYTE ** ppbFoundCredential)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundCredential != NULL) *ppbFoundCredential = NULL;

    if (cbSAC <= SAC_HEADER_SIZE || pbSAC == NULL)
    {
        return(hr);
    }

    BYTE * pbSACEnd = pbSAC + cbSAC;
    BYTE * pb       = pbSAC + USN_SIZE;     // Advance past USN.

    //
    // Read credential count.
    //

    DWORD dwCredentialCount;
    CopyMemory(&dwCredentialCount, pb, sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    //
    // Iterate the SAC credentials for a match against the passed credential
    // identity.
    //

    DWORD cbCredentialSize;

    for (DWORD i = 0; (i < dwCredentialCount) &&
         ((DWORD)(pb - pbSAC) < cbSAC); i++)
    {
        //
        // Ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize);

        //
        // Check remaining buffer size prior to the comparison.
        //

        if ((pb + HASH_DATA_SIZE) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BOOL fFound;
        fFound = (memcmp(pb, pbCredentialIdentity, HASH_DATA_SIZE) == 0);

        pb += HASH_DATA_SIZE;
        cbCredentialSize -= HASH_DATA_SIZE; // Subtract identity size.
                                            // Equals the encrypted data
                                            // size.

        if (fFound)
        {
            //
            // Found it, but ensure the contents referenced are valid.
            // Do so by checking remaining size.
            //

            if ((pb + cbCredentialSize) > pbSACEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            *pcbEncryptedData   = cbCredentialSize;
            *pdwCredentialIndex = i;
            if (ppbFoundCredential != NULL)
            {
                *ppbFoundCredential = pb;
            }
            return(S_OK);
        }

        //
        // Advance to next credential.
        //

        pb += cbCredentialSize;
    }

    if ((i == dwCredentialCount) && ((DWORD)(pb - pbSAC) != cbSAC) ||
        (i != dwCredentialCount) && ((DWORD)(pb - pbSAC) > cbSAC))
    {
        //
        // The database appears to be truncated.
        //

        ASSERT_SECURITY_DBASE_CORRUPT();
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACRemoveCredential
//
//  Synopsis:
//
//  Arguments:  [CredentialIndex] --
//              [pcbSAC]          --
//              [ppbSAC]          --
//
//  Returns:    TBD
//
//  Notes:      try/except unnecessary here since SACIndexCredential will
//              return only valid buffer ptrs.
//
//----------------------------------------------------------------------------
HRESULT
SACRemoveCredential(
    DWORD   CredentialIndex,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD   cbCredential;
    BYTE *  pbCredential;
    HRESULT hr;

    //
    // Index the credential in the SAC.
    //

    hr = SACIndexCredential(CredentialIndex, *pcbSAC, *ppbSAC, &cbCredential,
                            &pbCredential);

    if (hr == S_FALSE)
    {
        return(SCHED_E_ACCOUNT_INFORMATION_NOT_SET);
    }
    else if (FAILED(hr))
    {
        return(hr);
    }

    // Overwrite credential with SAC remaining buffer.
    //
    BYTE * pbDest = pbCredential - sizeof(cbCredential);
    BYTE * pbSrc  = pbCredential + cbCredential;

    MoveMemory(pbDest, pbSrc, (*ppbSAC + *pcbSAC) - pbSrc);

    // Decrement SAC credential count.
    //
    DWORD dwCredentialCount;

    CopyMemory(&dwCredentialCount, *ppbSAC + USN_SIZE,
                    sizeof(dwCredentialCount));
    --dwCredentialCount;
    CopyMemory(*ppbSAC + USN_SIZE, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    DWORD cbSACNew = *pcbSAC - (cbCredential + sizeof(cbCredential));

    // Shrink SAC buffer memory with a realloc.
    //
    BYTE * pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

    if (pbSACNew == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    // Update return ptrs.
    //
    *pcbSAC = cbSACNew;
    *ppbSAC = pbSACNew;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACUpdateCredential
//
//  Synopsis:
//
//  Arguments:  [cbEncryptedData]  --
//              [pbEncryptedData]  --
//              [cbPrevCredential] --
//              [pbPrevCredential] --
//              [pcbSAC]           --
//              [ppbSAC]           --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACUpdateCredential(
    DWORD   cbEncryptedData,
    BYTE *  pbEncryptedData,
    DWORD   cbPrevCredential,
    BYTE *  pbPrevCredential,   // Indexes *ppbSAC.
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD   cbNewCredential = HASH_DATA_SIZE + cbEncryptedData;
    BYTE *  pbSACNew;

    //
    // Ensure the prev credential ptr is within the buffer boundaries.
    // This is probably a redundant check since this ptr was most likely
    // obtained from a call to SACIndex/FindCredential.
    //

    if (*pcbSAC < SAC_HEADER_SIZE                        ||
        pbPrevCredential < (*ppbSAC + SAC_HEADER_SIZE +
                             sizeof(cbNewCredential))    ||
        (pbPrevCredential + cbPrevCredential) > (*ppbSAC + *pcbSAC))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    if (cbNewCredential != cbPrevCredential)
    {
        //
        // Reallocate to either shrink or grow the SAC data.
        //

        DWORD  cbSACNew;
        BYTE * pbDest;
        BYTE * pbSrc;

        if (cbNewCredential > cbPrevCredential)
        {
            //
            // Credential is larger than the previous. Grow the
            // buffer. Must reallocate the buffer FIRST, then
            // relocate contents.
            //

            cbSACNew = *pcbSAC + (cbNewCredential - cbPrevCredential);

            //
            // Keep SAC size in check.
            //

            if (cbSACNew > MAX_SECRET_SIZE)
            {
                // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
                return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
            }

            //
            // Save the linear offset to the previous credential
            // from SAC start, in case realloc changes our ptr.
            //

            DWORD cbPrevCredentialOffset;

            cbPrevCredentialOffset = (DWORD)(pbPrevCredential - *ppbSAC);

            pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

            if (pbSACNew == NULL)
            {
                return(E_OUTOFMEMORY);
            }

            pbPrevCredential = pbSACNew + cbPrevCredentialOffset;

            //
            // Compute start and ending block ptrs for subsequent
            // move.
            //

            pbDest = pbPrevCredential + cbNewCredential;
            pbSrc  = pbPrevCredential + cbPrevCredential;

            //
            // Move remaining buffer up.
            //

            BYTE * pbSACEnd = pbSACNew + *pcbSAC;

            if (pbDest < pbSACEnd)
            {
                MoveMemory(pbDest, pbSrc, pbSACEnd - pbSrc);
            }
        }
        else
        {
            //
            // Credential is smaller than the previous. Shrink the
            // buffer. Must relocate buffer contents FIRST, then
            // realloc.
            //

            cbSACNew = *pcbSAC - (cbPrevCredential - cbNewCredential);

            //
            // Compute start and ending block ptrs for subsequent
            // move.
            //

            pbDest = pbPrevCredential + cbNewCredential;
            pbSrc  = pbPrevCredential + cbPrevCredential;

            //
            // Move remaining buffer down.
            //

            MoveMemory(pbDest, pbSrc, (*ppbSAC + *pcbSAC) - pbSrc);

            pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

            if (pbSACNew == NULL)
            {
                return(E_OUTOFMEMORY);
            }
        }

        // Update out pointers.
        //
        *pcbSAC = cbSACNew;
        *ppbSAC = pbSACNew;
    }

    //
    // Finally, update the credential.
    //
    // Write the credential size.
    //
    CopyMemory(pbPrevCredential - sizeof(cbNewCredential), &cbNewCredential,
                       sizeof(cbNewCredential));

    // No need to update the credential identity. It has not changed.
    //

    // Write the encrypted bits.
    //
    CopyMemory(pbPrevCredential + HASH_DATA_SIZE, pbEncryptedData,
                       cbEncryptedData);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIAddIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity] --
//              [pcbSAI]     --
//              [ppbSAI]     --
//
//  Notes:      try/except unnecessary here. Memory writes are guaranteed to
//              remain within the buffer allocated.
//
//----------------------------------------------------------------------------
HRESULT
SAIAddIdentity(
    BYTE *  pbIdentity,
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    //
    // Make room for the new identity.
    //

    DWORD  dwSetArrayCount = 1;
    DWORD  dwSetSubCount   = 1; // Equal to one in the case of addition.
    DWORD  cbSAINew;
    BYTE * pbSAINew;

    cbSAINew = *pcbSAI + sizeof(dwSetSubCount) + HASH_DATA_SIZE;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSAINew > MAX_SECRET_SIZE)
    {
        // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAI == 0)
    {
        cbSAINew += SAI_HEADER_SIZE;
        pbSAINew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSAINew);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //
        SecureZeroMemory(pbSAINew, SAI_HEADER_SIZE);
    }
    else
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // Write identity set subcount of one & write identity.
    //

    BYTE * pbSetSubCount;

    if (*pcbSAI == 0)
    {
        //
        // First entry.
        //     - Write entry after header.
        //     - Initialize set array count to one.
        //

        pbSetSubCount = pbSAINew + SAI_HEADER_SIZE;
        CopyMemory(pbSAINew + USN_SIZE, &dwSetArrayCount,
                        sizeof(dwSetArrayCount));
    }
    else
    {
        //
        // Append entry.
        //     - Append after last identity array entry.
        //     - Increase set array count by one.
        //

        pbSetSubCount = pbSAINew + *pcbSAI;
        CopyMemory(&dwSetArrayCount, pbSAINew + USN_SIZE,
                        sizeof(dwSetArrayCount));
        dwSetArrayCount++;
        CopyMemory(pbSAINew + USN_SIZE, &dwSetArrayCount,
                        sizeof(dwSetArrayCount));
    }

    CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    CopyMemory(pbSetSubCount + sizeof(dwSetSubCount), pbIdentity,
                        HASH_DATA_SIZE);

    // Update out ptrs.
    //
    *pcbSAI = cbSAINew;
    *ppbSAI = pbSAINew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIFindIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity]          --
//              [cbSAI]               --
//              [pbSAI]               --
//              [pdwCredentialIndex]  --
//              [pfIsPasswordNull]    --
//              [ppbFoundIdentity]    --
//              [pdwSetSubCount]      --
//              [ppbSet]              --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIFindIdentity(
    BYTE *  pbIdentity,
    DWORD   cbSAI,
    BYTE *  pbSAI,
    DWORD * pdwCredentialIndex,
    BOOL *  pfIsPasswordNull,
    BYTE ** ppbFoundIdentity,
    DWORD * pdwSetSubCount,
    BYTE ** ppbSet)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundIdentity != NULL) *ppbFoundIdentity = NULL;

    if (cbSAI <= SAI_HEADER_SIZE || pbSAI == NULL)
    {
        return(hr);
    }

    *pdwCredentialIndex = 0;
    if (pdwSetSubCount != NULL) *pdwSetSubCount = 0;
    if (ppbSet != NULL)         *ppbSet         = NULL;

    BYTE * pbSAIEnd = pbSAI + cbSAI;
    BYTE * pb       = pbSAI + USN_SIZE;       // Advance past USN.

    //
    // Read identity set array count.
    //

    DWORD dwSetArrayCount;
    CopyMemory(&dwSetArrayCount, pb, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    //
    // Iterative identity comparison.
    //

    DWORD  dwSetSubCount;

    for (DWORD i = 0;
         (i < dwSetArrayCount) && ((DWORD)(pb - pbSAI) < cbSAI);
         i++)
    {
        //
        // Read identity set subcount.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BYTE * pbSet;

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pbSet = (pb += sizeof(dwSetSubCount));

        for (DWORD j = 0;
             (j < dwSetSubCount) && ((DWORD)(pb - pbSAI) < cbSAI);
             j++, pb += HASH_DATA_SIZE)
        {
            //
            // Check remaining buffer size prior to the comparison.
            //

            if ((pb + HASH_DATA_SIZE) > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            //
            // We consider the hashed data to be equal even if the last bit
            // is different
            //
            if (memcmp(pb, pbIdentity, HASH_DATA_SIZE - 1) == 0 &&
                ((LAST_HASH_BYTE(pb) ^ LAST_HASH_BYTE(pbIdentity)) & 0xFE) == 0)
            {
                //
                // Found it. No need to further check return ptrs. The
                // buffer size check above accomplished this.
                //

                *pdwCredentialIndex = i;

                if (pfIsPasswordNull != NULL)
                {
                    // Unequal last bits denote a NULL password
                    *pfIsPasswordNull = LAST_HASH_BYTE(pb) ^ LAST_HASH_BYTE(pbIdentity);
                }
                if (pdwSetSubCount != NULL)
                {
                    *pdwSetSubCount = dwSetSubCount;
                }
                if (ppbSet != NULL)
                {
                    *ppbSet = pbSet;
                }

                if (ppbFoundIdentity != NULL)
                {
                    *ppbFoundIdentity = pb;
                }
                return(S_OK);
            }
        }

        //
        // Check for database truncation.
        //

        if ((j != dwSetSubCount) || ((DWORD)(pb - pbSAI) > cbSAI))
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }
    }

    //
    // Check for database truncation.
    //

    if ((i != dwSetArrayCount) || ((DWORD)(pb - pbSAI) != cbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIIndexIdentity
//
//  Synopsis:
//
//  Arguments:  [cbSAI]           --
//              [pbSAI]           --
//              [dwSetArrayIndex] --
//              [dwSetIndex]      --
//              [pdwSetSubCount]  --
//              [ppbSet]          --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIIndexIdentity(
    DWORD   cbSAI,
    BYTE *  pbSAI,
    DWORD   dwSetArrayIndex,
    DWORD   dwSetIndex,
    BYTE ** ppbFoundIdentity,
    DWORD * pdwSetSubCount,
    BYTE ** ppbSet)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundIdentity != NULL) *ppbFoundIdentity = NULL;

    if (cbSAI <= SAI_HEADER_SIZE || pbSAI == NULL)
    {
        return(hr);
    }

    if (pdwSetSubCount != NULL) *pdwSetSubCount = 0;
    if (ppbSet != NULL)         *ppbSet         = NULL;

    BYTE *  pbSAIEnd = pbSAI + cbSAI;
    BYTE *  pb       = pbSAI + USN_SIZE;      // Advance past USN.

    //
    // Read identity array count.
    //

    DWORD dwSetArrayCount;
    CopyMemory(&dwSetArrayCount, pb, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    //
    // Iterative identity comparison.
    //

    for (DWORD i = 0; (i < dwSetArrayCount) &&
         ((DWORD)(pb - pbSAI) < cbSAI); i++)
    {
        DWORD dwSetSubCount;

        //
        // Read identity set subcount.
        // Note, this value may not be on an aligned boundary.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BYTE * pbSet;

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pbSet = (pb += sizeof(dwSetSubCount));

        DWORD j;
        for (j = 0; (j < dwSetSubCount) && ((DWORD)(pb - pbSAI) < cbSAI);
                        j++, pb += HASH_DATA_SIZE)
        {
            if (i == dwSetArrayIndex && j == dwSetIndex)
            {
                //
                // Found it, but ensure the contents referenced are valid.
                // Do so by checking remaining size.
                //

                if ((pb + HASH_DATA_SIZE) > pbSAIEnd)
                {
                    ASSERT_SECURITY_DBASE_CORRUPT();
                    return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
                }

                if (pdwSetSubCount != NULL)
                {
                    *pdwSetSubCount = dwSetSubCount;
                }
                if (ppbSet != NULL)
                {
                    *ppbSet = pbSet;
                }

                if (ppbFoundIdentity != NULL)
                {
                    *ppbFoundIdentity = pb;
                }
                return(S_OK);
            }
        }

        //
        // Check for database truncation.
        //

        if ((j != dwSetSubCount) || ((DWORD)(pb - pbSAI) > cbSAI))
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }
    }

    //
    // Check for database truncation.
    //

    if ((i != dwSetArrayCount) || ((DWORD)(pb - pbSAI) != cbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIInsertIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity] --
//              [pbSAIIndex] --
//              [pcbSAI]     --
//              [ppbSAI]     --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIInsertIdentity(
    BYTE *  pbIdentity,
    BYTE *  pbSAIIndex,     // Indexes *ppbSAI.
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    DWORD dwSetSubCount;

    //
    // Check index boundary.
    //

    if (pbSAIIndex < (*ppbSAI + SAI_HEADER_SIZE + sizeof(dwSetSubCount)) ||
        (pbSAIIndex + HASH_DATA_SIZE) > (*ppbSAI + *pcbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    //
    // Save the linear offset to the identity insertion point from SAI start,
    // in case realloc changes our ptr.
    //

    DWORD cbInsertionOffset = (DWORD)(pbSAIIndex - *ppbSAI);

    //
    // Make room for the new identity.
    //

    DWORD  cbSAINew = *pcbSAI + HASH_DATA_SIZE;
    BYTE * pbSAINew;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSAINew > MAX_SECRET_SIZE)
    {
        // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAI == 0)
    {
        cbSAINew += SAI_HEADER_SIZE;
        pbSAINew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSAINew);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //
        SecureZeroMemory(pbSAINew, SAI_HEADER_SIZE);
    }
    else
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pbSAIIndex = pbSAINew + cbInsertionOffset;

    //
    // Move buffer content down.
    //

    BYTE * pbSetSubCount   = pbSAIIndex - sizeof(dwSetSubCount);
    BYTE * pbIdentityStart = pbSAIIndex;

    MoveMemory(pbIdentityStart + HASH_DATA_SIZE, pbIdentityStart,
                   (pbSAINew + *pcbSAI) - pbIdentityStart);

    //
    // Update identity count & write new identity.
    //

    CopyMemory(&dwSetSubCount, pbSetSubCount, sizeof(dwSetSubCount));
    dwSetSubCount++;
    CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    CopyMemory(pbIdentityStart, pbIdentity, HASH_DATA_SIZE);

    // Update out ptrs.
    //
    *pcbSAI = cbSAINew;
    *ppbSAI = pbSAINew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIRemoveIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity]      --
//              [pbSet]           --
//              [pcbSAI]          --
//              [ppbSAI]          --
//              [CredentialIndex] --
//              [pcbSAC]          --
//              [ppbSAC]          --
//
//  Returns:    TBD
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
SAIRemoveIdentity(
    BYTE *  pbIdentity,
    BYTE *  pbSet,
    DWORD * pcbSAI,
    BYTE ** ppbSAI,
    DWORD   CredentialIndex,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    HRESULT hr = S_OK;
    DWORD   dwSetSubCount;

    //
    // Check identity, set ptr values. If this fails, it is either a developer
    // error (hence, the assertion) or the database is hosed. In either case,
    // return an error vs. writing blindly to memory.
    //

    if ((pbSet > pbIdentity)                                          ||
        (pbSet < (*ppbSAI + SAI_HEADER_SIZE + sizeof(dwSetSubCount))) ||
        ((pbIdentity + HASH_DATA_SIZE) > (*ppbSAI + *pcbSAI)))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    BYTE *  pbSetSubCount;

    //
    // Read and decrement identity array count.
    //

    pbSetSubCount = pbSet - sizeof(dwSetSubCount);
    CopyMemory(&dwSetSubCount, pbSetSubCount, sizeof(dwSetSubCount));
    --dwSetSubCount;

    //
    // If this is the last identity in the set,
    //     overwrite the set count value & the identity with remaining SAI
    //       buffer content;
    //     remove associated credential from the SAC.
    // If this is not the last entry,
    //     overwrite the identity with the remaining SAI buffer content &
    //       decrement the identity set count.
    //

    BYTE * pbDest, * pbSrc;
    DWORD  cbSAINew;

    if (dwSetSubCount == 0)             // Last entry.
    {
        // Remove associated credential in the SAC.
        //
        hr = SACRemoveCredential(CredentialIndex, pcbSAC, ppbSAC);

        if (SUCCEEDED(hr))
        {
            // Overwrite identity set with SAI remaining buffer.
            // Includes the set array count and the single identity
            // element. Actual move accomplished following this condition.
            //
            pbDest = pbSetSubCount;
            pbSrc  = pbSet + HASH_DATA_SIZE;

            cbSAINew = *pcbSAI - (HASH_DATA_SIZE + sizeof(dwSetSubCount));

            // Decrement SAI identity set count. That is, the count of
            // identity sets in the SAI. Note, overloading dwSetSubCount.
            //
            CopyMemory(&dwSetSubCount, *ppbSAI + USN_SIZE,
                            sizeof(dwSetSubCount));
            --dwSetSubCount;
            CopyMemory(*ppbSAI + USN_SIZE, &dwSetSubCount,
                            sizeof(dwSetSubCount));
        }
    }
    else                                // More entries remain.
    {
        // Overwrite identity with SAI remaining buffer.
        // Actual move accomplished following this condition.
        //
        pbDest = pbIdentity;
        pbSrc  = pbIdentity + HASH_DATA_SIZE;

        cbSAINew = *pcbSAI - HASH_DATA_SIZE;

        // Update identity set array count to reflect removed entry.
        //
        CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    }

    if (SUCCEEDED(hr))
    {
        MoveMemory(pbDest, pbSrc, (*ppbSAI + *pcbSAI) - pbSrc);

        // Shrink SAI buffer memory with a realloc.
        //
        BYTE * pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew,
                                                LMEM_MOVEABLE);

        if (pbSAINew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAI = cbSAINew;
            *ppbSAI = pbSAINew;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   SAIUpdateIdentity
//
//  Synopsis:   Updates the hash data stored for a job in place.
//
//  Arguments:  [pbNewIdentity] -- the new hash data to be stored
//              [pbFoundIdentity] -- pointer to the previously found hash data
//              [cbSAI] --
//              [pbSAI] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAIUpdateIdentity(
    const BYTE * pbNewIdentity,
    BYTE *  pbFoundIdentity,
    DWORD   cbSAI,
    BYTE *  pbSAI)
{
    schAssert(pbSAI <= pbFoundIdentity && pbFoundIdentity < pbSAI + cbSAI);
    UNREFERENCED_PARAMETER(cbSAI);
    UNREFERENCED_PARAMETER(pbSAI);

    CopyMemory(pbFoundIdentity, pbNewIdentity, HASH_DATA_SIZE);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SAICoalesceDeletedEntries
//
//  Synopsis:   Removed entries marked for deletion and reallocate the buffer.
//
//  Arguments:  [pcbSAI] --
//              [ppbSAI] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAICoalesceDeletedEntries(
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    schAssert(pcbSAI != NULL && ppbSAI != NULL && *ppbSAI != NULL);

    if (*pcbSAI <= SAI_HEADER_SIZE)
    {
        //
        // Nothing to do.
        //

        return(S_OK);
    }

    //
    // Read set array count.
    //

    DWORD  cbSAINew     = *pcbSAI;
    DWORD  cSetsRemoved = 0;
    DWORD  dwSetArrayCount;
    DWORD  dwSetSubCount;
    DWORD  cEntriesDeleted;
    BYTE * pb;
    BYTE * pbSetArrayCount;
    BYTE * pbSAIEnd     = *ppbSAI + *pcbSAI;
    BYTE * pbSAINew;
    BYTE * pbDest;
    BYTE * pbSrc;

    pb = pbSetArrayCount = *ppbSAI + USN_SIZE;

    CopyMemory(&dwSetArrayCount, pbSetArrayCount, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    for (DWORD i = 0; i < dwSetArrayCount && pb < pbSAIEnd; i++)
    {
        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));

        pbDest = pb;
        pb += sizeof(dwSetSubCount);
        pbSrc = pb;

        //
        // Must scan the set to see if all entries are to be removed.
        // To know if the set subcount can be removed as well.
        //
        cEntriesDeleted = 0;
        for (DWORD j = 0; j < dwSetSubCount && pbSrc < pbSAIEnd; j++)
        {
            //
            // Deleted entry marker size is less than HASH_DATA_SIZE.
            //

            if ((pbSrc + HASH_DATA_SIZE) > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            if (DELETED_ENTRY(pbSrc))
            {
                cEntriesDeleted++;
            }

            pbSrc += HASH_DATA_SIZE;
        }

        //
        // Anything to remove?
        //

        if (cEntriesDeleted != 0)
        {
            //
            // Reduce SAI size by the total no. of deleted entries.
            // After the above, we can safely dispense with buffer boundary
            // checks.
            //

            DWORD cbBytesDeleted = (HASH_DATA_SIZE * cEntriesDeleted);

            if (cEntriesDeleted == dwSetSubCount)
            {
                //
                // Removing entire set.
                // Update total no. of sets removed.
                //

                cSetsRemoved++;
                cbBytesDeleted += sizeof(dwSetSubCount);
                MoveMemory(pbDest, pbSrc, pbSAIEnd - pbSrc);
            }
            else
            {
                //
                // Removing individual set entries.
                // First, update the set array count.
                // pbDest is positioned on the set subcount, pb just after it.
                //

                dwSetSubCount -= cEntriesDeleted;
                CopyMemory(pbDest, &dwSetSubCount, sizeof(dwSetSubCount));

                pbDest = pbSrc = pb;

                for ( ; cEntriesDeleted && pbSrc < pbSAIEnd; )
                {
                    pbSrc += HASH_DATA_SIZE;

                    if (DELETED_ENTRY(pbDest))
                    {
                        cEntriesDeleted--;
                        MoveMemory(pbDest, pbSrc, pbSAIEnd - pbSrc);
                        pbSrc = pbDest;
                    }

                    pbDest = pbSrc;
                }

                //
                // Advance to next set.
                //

                pbDest = pb + (HASH_DATA_SIZE * dwSetSubCount);
            }

            cbSAINew -= cbBytesDeleted;
            pbSAIEnd -= cbBytesDeleted;
        }
        else
        {
            //
            // Advance to next set.
            //

            pbDest += (HASH_DATA_SIZE * dwSetSubCount) +
                        sizeof(dwSetSubCount);
        }

        pb = pbDest;
    }

    //
    // Fix up set array count to reflect removed sets.
    //

    dwSetArrayCount -= cSetsRemoved;
    CopyMemory(pbSetArrayCount, &dwSetArrayCount, sizeof(dwSetArrayCount));

    //
    // Finally, reallocate the array. That is, if it changed.
    //

    if (*pcbSAI != cbSAINew)
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAI = cbSAINew;
            *ppbSAI = pbSAINew;
        }
        else
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACCoalesceDeletedEntries
//
//  Synopsis:   Removed entries marked for deletion and reallocate the buffer.
//
//  Arguments:  [pcbSAC] --
//              [ppbSAC] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SACCoalesceDeletedEntries(
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    schAssert(pcbSAC != NULL && ppbSAC != NULL && *ppbSAC != NULL);

    if (*pcbSAC <= SAC_HEADER_SIZE)
    {
        //
        // Nothing to do.
        //

        return(S_OK);
    }

    BYTE * pb;
    BYTE * pbCredentialCount;
    DWORD  dwCredentialCount;
    DWORD  cbCredentialSize;
    DWORD  cCredentialsRemoved = 0;
    DWORD  cbSACNew            = *pcbSAC;
    BYTE * pbSACNew;
    BYTE * pbSACEnd            = *ppbSAC + *pcbSAC;
    BYTE * pbSrc;
    BYTE * pbDest;
    BYTE * pbNext;
    DWORD  cbBytesDeleted;

    //
    // Read credential count.
    //

    pb = pbCredentialCount = *ppbSAC + USN_SIZE;

    CopyMemory(&dwCredentialCount, pbCredentialCount,
                    sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    for (DWORD i = 0; i < dwCredentialCount && pb < pbSACEnd; i++)
    {
        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        cbBytesDeleted = 0;
        pbDest = pbSrc = pb;

        //
        // Move consecutive entries.
        //

        for ( ; i < dwCredentialCount && pb < pbSACEnd; i++)
        {
            CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
            pb += sizeof(cbCredentialSize);
            pbNext = pb + cbCredentialSize;

            //
            // A credential could never be less than the deleted entry size,
            // unless it is bogus.
            //

            if (cbCredentialSize  < DELETED_ENTRY_MARKER_SIZE ||
                (pb + DELETED_ENTRY_MARKER_SIZE) > pbSACEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            if (DELETED_ENTRY(pb))
            {
                //
                // Update the new SAC size to reflect the removed entry.
                // Also update the total no. of credentials removed.
                //

                cbBytesDeleted += sizeof(cbCredentialSize) + cbCredentialSize;
                cCredentialsRemoved++;
                pbSrc = pb = pbNext;
            }
            else
            {
                pb = pbNext;
                break;
            }
        }

        if (pbDest != pbSrc)
        {
            MoveMemory(pbDest, pbSrc, pbSACEnd - pbSrc);
            pb = pbDest + sizeof(cbCredentialSize) + cbCredentialSize;
            cbSACNew -= cbBytesDeleted;
            pbSACEnd -= cbBytesDeleted;
        }
    }

    //
    // Fix up credential count to reflect removed sets.
    //

    dwCredentialCount -= cCredentialsRemoved;
    CopyMemory(pbCredentialCount, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    //
    // Finally, reallocate the array. That is, if it changed.
    //

    if (*pcbSAC != cbSACNew)
    {
        pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

        if (pbSACNew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAC = cbSACNew;
            *ppbSAC = pbSACNew;
        }
        else
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\netsch.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       netsch.cxx
//
//  Contents:   Server-side Net Scheduler RPC implementation.
//
//  Classes:    None.
//
//  RPC:        NetrJobAdd
//              NetrJobDel
//              NetrJobEnum
//              NetrJobGetInfo
//
//  Functions:  CreateAtJobPath
//              GetAtJobIdFromFileName
//              InitializeNetScheduleApi
//              UninitializeNetScheduleApi
//
//  History:    11-Nov-95   MarkBl  Created.
//              02-Feb-01   JBenton Fixed BUG 303146 - 64bit pointer alignment problem
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include <align.h>
#include <apperr.h>
#include <lmerr.h>
#include <netevent.h>
extern "C" {
#include <netlib.h>
}
#include "atsvc.h"
#include "..\inc\resource.h"
#include "globals.hxx"
#include "svc_core.hxx"
#include "atsec.hxx"
#include "proto.hxx"

//
// Manifests below taken from the existing At service. Values must *not*
// change to maintain compatibility.
//

#define MAXIMUM_COMMAND_LENGTH          (MAX_PATH - 1)
#define MAXIMUM_JOB_TIME                (24 * 60 * 60 * 1000 - 1)
#define DAYS_OF_WEEK                    0x7F        // 7 bits for 7 days.
#define DAYS_OF_MONTH                   0x7FFFFFFF  // 31 bits for 31 days.

// This is not localized - it is a registry key (indirectly) from the At service

#define SCHEDULE_EVENTLOG_NAME          TEXT("Schedule")

//
// Converts an HRESULT to a WIN32 status code. Masks off everything but
// the error code.
//
// BUGBUG : Review.
//

#define WIN32_FROM_HRESULT(x)           (HRESULT_CODE(x))

//
// Minimum and maximum buffer size returned in an enumeration.
//

// 02/05/01-jbenton : this macro is used to a unicode buffer so must be even
// to avoid alignment problems (bug 303146).
#define BUFFER_LENGTH_MINIMUM (sizeof(AT_ENUM) + (MAXIMUM_COMMAND_LENGTH+1)*sizeof(WCHAR))
#define BUFFER_LENGTH_MAXIMUM 65536

//
// Ballpark maximum command string length.
//
// BUGBUG : Review this value.
//

#define COMMAND_STRING_LENGTH_APPROX    (((MAX_PATH / 4) + 1) * sizeof(WCHAR))

#define ASTERISK_STR                    L"*"
#define BACKSLASH_STR                   L"\\"

void           CreateAtJobPath(DWORD, WCHAR *, size_t);
DWORD          GetAtJobIdFromFileName(WCHAR *);
void           GetNextAtID(LPDWORD);

WCHAR * gpwszAtJobPathTemplate   = NULL;


//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobAdd
//
//  Synopsis:   Add a single At job.
//
//  Arguments:  [ServerName] -- Unused.
//              [pAtInfo]    -- New job information.
//              [pJobId]     -- Returned job id.
//
//  Returns:    BUGBUG : Problem mapping a HRESULT to WIN32. Masking off the
//                       facility & error bits is insufficient.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobAdd(ATSVC_HANDLE ServerName, LPAT_INFO pAtInfo, LPDWORD pJobId)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobAdd ServerName(%ws), pAtInfo(0x%x)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        pAtInfo));

    UNREFERENCED_PARAMETER(ServerName);

    NET_API_STATUS Status = NERR_Success;

    Status = AtCheckSecurity(AT_JOB_ADD);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate arguments.
    //

    if ( (pAtInfo->Command        == NULL)                   ||
         (wcslen(pAtInfo->Command) > MAXIMUM_COMMAND_LENGTH) ||
         (pAtInfo->JobTime         > MAXIMUM_JOB_TIME)       ||
         (pAtInfo->DaysOfWeek      & ~DAYS_OF_WEEK)          ||
         (pAtInfo->DaysOfMonth     & ~DAYS_OF_MONTH)         ||
         (pAtInfo->Flags           & ~JOB_INPUT_FLAGS))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // TBD : Logic to punt the submission if the service is paused.
    //

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Have the global schedule instance add the At job.
    //

    HRESULT hr = g_pSched->m_pSch->AddAtJobWithHash(*pAtInfo, pJobId);

    if (FAILED(hr))
    {
        //
        // Convert the HRESULT to a WIN32 status code.
        //

        Status = WIN32_FROM_HRESULT(hr);
    }

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobDel
//
//  Synopsis:   Delete the At jobs in the range specified.
//
//  Arguments:  [ServerName] -- Unused.
//              [MinJobId]   -- Range lower bound, inclusive.
//              [MaxJobId]   -- Range upper bound, inclusive.
//
//  Returns:    NERR_Sucess
//              ERROR_INVALID_PARAMETER
//              APE_AT_ID_NOT_FOUND
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobDel(ATSVC_HANDLE ServerName, DWORD MinJobId, DWORD MaxJobId)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobDel ServerName(%ws), MinJobId(%d), MaxJobId(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        MinJobId,
        MaxJobId));

    UNREFERENCED_PARAMETER(ServerName);

    NET_API_STATUS Status;

    Status = AtCheckSecurity(AT_JOB_DEL);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate range.
    //

    if (MinJobId > MaxJobId)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Delete the indicated At job objects from storage.
    //
    // NB : To maintain compatibility with the existing AT service, if at
    //      least one job is deleted successfully, return success; otherwise,
    //      return APE_ID_NOT_FOUND.
    //

    WCHAR   wszPath[MAX_PATH + 1];
    BOOL    fJobDeleted = FALSE;
    HRESULT hr;
    BOOL    fDeleteAll = FALSE;

    //
    // Test for delete-all; signaled by passing a MaxJobId of 0xffffffff.
    //

    if (MaxJobId == 0xffffffff)
    {
        //
        // Get the actual maximum ID value (this fixes bug 55839).
        //

        GetNextAtID(&MaxJobId);
        fDeleteAll = TRUE;
    }

    CJob * pJob = CJob::Create();

    if (pJob)
    {
        for (DWORD i = MinJobId; i <= MaxJobId; i++)
        {
            CreateAtJobPath(i, wszPath, MAX_PATH + 1);

            //
            // Make sure this is really an AT job, and not one that's just
            // named like one.  Just load the fixed-length data and check for
            // the at flag.
            //

            hr = pJob->LoadP(wszPath, 0, FALSE, FALSE);

            if (SUCCEEDED(hr))
            {
                DWORD rgFlags;

                pJob->GetAllFlags(&rgFlags);

                if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
                {
                    if (DeleteFile(wszPath))
                    {
                        fJobDeleted = TRUE;
                    }
                }
            }
            else
            {
                schDebugOut((DEB_IWARN, "LoadP(%S) hr=0x%x\n", wszPath, hr));
            }
        }
        pJob->Release();
    }

    //
    // If the user asked to delete all at jobs, reset the next id to 1
    //

    if (fDeleteAll)
    {
        (void) g_pSched->m_pSch->ResetAtID();
    }

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    Status = fJobDeleted ? NERR_Success : APE_AT_ID_NOT_FOUND;

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobEnum
//
//  Synopsis:   Enumerate At jobs.
//
//  Arguments:  [ServerName]             -- Unused.
//              [pEnumContainer]         -- Returned enumeration (AT_JOB_INFO
//                                          array and size).
//              [PreferredMaximumLength] -- Preferred buffer size maximum. If
//                                          -1, allocate as needed.
//              [pTotalEntries]          -- Returns the total number of
//                                          entries available.
//              [pResumeHandle]          -- Enumeration context. Indexes the
//                                          the At jobs directory.
//
//  Returns:    BUGBUG : Problem here too with HRESULTs mapped to WIN32 status
//                       codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobEnum(
    ATSVC_HANDLE        ServerName,
    LPAT_ENUM_CONTAINER pEnumContainer,
    DWORD               PreferredMaximumLength,
    LPDWORD             pTotalEntries,
    LPDWORD             pResumeHandle)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobEnum ServerName(%ws), pEnumContainer(0x%x), " \
        "PreferredMaximumLength(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        pEnumContainer,
        PreferredMaximumLength));

    UNREFERENCED_PARAMETER(ServerName);

    WCHAR           wszCommand[MAX_PATH + 1];
    WIN32_FIND_DATA fd;
    NET_API_STATUS  Status;
    HANDLE          hFileFindContext;
    LPBYTE          pbBuffer;
    LPBYTE          pbStringsOffset;
    PAT_ENUM        pAtEnum;
    DWORD           cbBufferSize;
    DWORD           cbCommandSize;
    DWORD           cJobsEnumerated;
    DWORD           iEnumContext;
    DWORD           i;
    DWORD           rgFlags;
    HRESULT         hr;

    Status          = NERR_Success;
    pbBuffer        = NULL;
    cJobsEnumerated = 0;
    i               = 0;

    //
    // pEnumContainer is defined in the IDL file as [in,out] though it
    // should only be [out].  This can't be changed in the IDL file for
    // backwards compatibility, so check it here.  Without this check,
    // we'll leak memory if the user gives a non-NULL buffer.
    //
    if (pEnumContainer->Buffer != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AtCheckSecurity(AT_JOB_ENUM);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    if (pResumeHandle != NULL)
    {
        iEnumContext = *pResumeHandle;
    }
    else
    {
        iEnumContext = 0;
    }
    //
    // Allocate one job object that will be reused.
    //
    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Compute the total number of At jobs (i.e., the number of At jobs in
    // the At subdirectory). This number is used to update the pTotalEntries
    // argument, and may be used for enumeration buffer size computation.
    //

    DWORD cAtJobTotal = 0;

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    do
    {
        //
        // If somebody renamed an At job, don't enumerate it.  This is to
        // prevent us from returning duplicate IDs as a result of finding jobs
        // like At1.job and At01.job.
        //

        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        hr = LoadAtJob(pJob, fd.cFileName);
        if (FAILED(hr))
        {
            // we don't want to return the job,
            // but failing altogether is a little drastic
            // ERR_OUT("NetrJobEnum: pJob->Load", hr);
            // Status = WIN32_FROM_HRESULT(hr);
            // FindClose(hFileFindContext);
            // goto EnumExit;
            continue; // skip it and go on
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            cAtJobTotal++;
        }
    } while (FindNextFile(hFileFindContext, &fd));

    FindClose(hFileFindContext);

    if (!cAtJobTotal)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    //
    // Get buffer size.
    //

    if (PreferredMaximumLength != -1)
    {
        //
        // Caller has specified a preferred buffer size.
        //

       // 02/05/01-jbenton : buffer size must be even to avoid
	   // alignment errors. (bug 303146).
        cbBufferSize = ROUND_DOWN_COUNT(PreferredMaximumLength, ALIGN_WCHAR);
    }
    else
    {
        //
        // Compute a "best-guess" buffer size to return all of the data.
        // If we underestimate the buffer size, we'll return as much data
        // as the buffer allows, plus a return code of ERROR_MORE_DATA.
        //

        cbBufferSize = (sizeof(AT_ENUM) + COMMAND_STRING_LENGTH_APPROX) *
                                cAtJobTotal;
    }

    //
    // Restrict buffer size.
    //

    cbBufferSize = (DWORD)max(cbBufferSize, BUFFER_LENGTH_MINIMUM);
    cbBufferSize = min(cbBufferSize, BUFFER_LENGTH_MAXIMUM);

    //
    // The enumeration context is utilized as an index in the find first/next
    // file result. If non-zero, enumerate the directory until the number
    // of AT jobs enumerated equals the caller's enumeration context.
    //
    // BUGBUG : This is quite a departure from the existing At service, but
    //          I'm confident it should not present a problem. Note for
    //          review.
    //
    // Seek to the enumeration context index.
    //

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    i = 0;
    do
    {
        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        hr = LoadAtJob(pJob, fd.cFileName);
        if (FAILED(hr))
        {
            // we don't want to return the job,
            // but failing altogether is a little drastic
            // ERR_OUT("NetrJobEnum: pJob->Load", hr);
            // Status = WIN32_FROM_HRESULT(hr);
            // FindClose(hFileFindContext);
            // goto EnumExit;
            continue; // skip it and go on
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            i++;

            if (i > iEnumContext)
            {
                break;
            }
        }

    } while (FindNextFile(hFileFindContext, &fd));

    if (i <= iEnumContext)
    {
        //
        // The above enumeration seek failed to find any more AT jobs
        // beyond the Resume handle count. Thus, the enumeration is
        // complete. Nothing else to enumerate.
        //

        FindClose(hFileFindContext);
        *pTotalEntries = 0;
        goto EnumExit;
    }

    //
    // Update pTotalEntries argument. It is the difference between the total
    // number of jobs and the number of jobs previously enumerated.
    //

    *pTotalEntries = cAtJobTotal - i + 1;

    pbBuffer = (LPBYTE)MIDL_user_allocate(cbBufferSize);

    if (pbBuffer == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
        goto EnumExit;
    }

    //
    // Begin the enumeration.
    //

    pbStringsOffset = pbBuffer + cbBufferSize;
    pAtEnum = (PAT_ENUM)pbBuffer;

    //
    // To have arrived here, the resume handle seek above will have left us
    // a valid AT job object in pJob and the corresponding rgFlags.
    //
    do
    {
        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            if (pbStringsOffset <= (LPBYTE)pAtEnum + sizeof(AT_ENUM))
            {
                //
                // Buffer full.
                //

                Status = ERROR_MORE_DATA;
                break;
            }

            //
            // Get At job information.
            //

            DWORD CommandSize = MAX_PATH + 1;
            AT_INFO         AtInfo;

            hr = pJob->GetAtInfo(&AtInfo, wszCommand, &CommandSize);

            if (SUCCEEDED(hr))
            {
                //
                // Copy fixed portion.
                //

                pAtEnum->JobId       = GetAtJobIdFromFileName(fd.cFileName);
                pAtEnum->JobTime     = AtInfo.JobTime;
                pAtEnum->DaysOfMonth = AtInfo.DaysOfMonth;
                pAtEnum->DaysOfWeek  = AtInfo.DaysOfWeek;
                pAtEnum->Flags       = AtInfo.Flags;

                //
                // Copy variable data.
                //

                // whack one off of CommandSize
                // because NetpCopyStringToBuffer doesn't want the NULL counted
                BOOL fRet = NetpCopyStringToBuffer(
                                            wszCommand,
                                            CommandSize -1,
                                            (LPBYTE)(pAtEnum + 1),
                                            (LPWSTR *)&pbStringsOffset,
                                            &pAtEnum->Command);

                if (!fRet)
                {
                    Status = ERROR_MORE_DATA;
                    break;
                }

                pAtEnum++; cJobsEnumerated++; iEnumContext++;
            }
        }

        //
        // Get the next filename, skipping any that have been renamed
        //

        BOOL fFoundAnotherAtJob = FALSE;

        do 
        {

            while (fFoundAnotherAtJob = FindNextFile(hFileFindContext, &fd))
            {
                if (IsValidAtFilename(fd.cFileName))
                {
                    break;
                }
            }

            if (!fFoundAnotherAtJob)
            {
                //
                // No more files.
                //
                break;
            }

            hr = LoadAtJob(pJob, fd.cFileName);
        }
        // we wish to continue doing this until we find a good one
        while (FAILED(hr));
        // but if we broke out without finding a good job above, we're done
        if (!fFoundAnotherAtJob)
            break;            
        
        pJob->GetAllFlags(&rgFlags);

    } while (TRUE);

    FindClose(hFileFindContext);

    //
    // Reset enumeration context if everything has been read.
    //

    if (Status == NERR_Success)
    {
        iEnumContext = 0;
    }

EnumExit:

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    if (pJob)
    {
        pJob->Release();
    }

    pEnumContainer->EntriesRead = cJobsEnumerated;

    if (cJobsEnumerated == 0 && pbBuffer != NULL)
    {
        MIDL_user_free(pbBuffer);
        pbBuffer = NULL;
    }

    pEnumContainer->Buffer = (LPAT_ENUM)pbBuffer;

    if (pResumeHandle != NULL)
    {
        *pResumeHandle = iEnumContext;
    }

    return(Status);
}




//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobGetInfo
//
//  Synopsis:   Get information on an At job.
//
//  Arguments:  [ServerName] -- Unused.
//              [JobId]      -- Target At job.
//              [ppAtInfo]   -- Returned information.
//
//  Returns:    BUGBUG : Problem here too with HRESULTs mapped to WIN32 status
//                       codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobGetInfo(ATSVC_HANDLE ServerName, DWORD JobId, LPAT_INFO * ppAtInfo)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobGetInfo ServerName(%ws), JobId(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        JobId));

    UNREFERENCED_PARAMETER(ServerName);

    AT_INFO         AtInfo;
    PAT_INFO        pAtInfo;
    NET_API_STATUS  Status;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszCommand[MAX_PATH + 1];
    WCHAR           wszJobId[10 + 1];
    DWORD           CommandSize;
    HRESULT         hr;

    Status  = NERR_Success;
    pAtInfo = NULL;

    Status = AtCheckSecurity(AT_JOB_GET_INFO);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Create the file name from the ID.
    //
    CreateAtJobPath(JobId, wszPath, MAX_PATH + 1);
    schDebugOut((DEB_ITRACE, "At job name: %S\n", wszPath));

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Ensure the job object exists in storage.
    //

    if (GetFileAttributes(wszPath) == -1 &&
        GetLastError() == ERROR_FILE_NOT_FOUND)
    {
        //
        // Job object does not exist.
        //

        Status = APE_AT_ID_NOT_FOUND;
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        goto GetInfoExit;
    }

    //
    // Command size. A character count throughout the call to GetAtJob;
    // a byte count thereafter.
    //

    CommandSize = MAX_PATH + 1;

    //
    // Get At job information.
    //

    hr = g_pSched->m_pSch->GetAtJob(wszPath, &AtInfo, wszCommand, &CommandSize);

    if (FAILED(hr))
    {
        //
        // Convert the HRESULT to a WIN32 status code.
        //

        Status = WIN32_FROM_HRESULT(hr);

        if (Status == ERROR_FILE_NOT_FOUND)
        {
            Status = APE_AT_ID_NOT_FOUND;
        }
        goto GetInfoExit;
    }

    CommandSize *= sizeof(WCHAR);   // Character count -> Byte count

    pAtInfo = (PAT_INFO)MIDL_user_allocate(sizeof(AT_INFO) + CommandSize);

    if (pAtInfo == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        goto GetInfoExit;
    }

    *pAtInfo = AtInfo;

    pAtInfo->Command = (LPWSTR)(pAtInfo + 1);

    CopyMemory(pAtInfo->Command, wszCommand, CommandSize);


GetInfoExit:

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    *ppAtInfo = pAtInfo;

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAtJobIdFromFileName
//
//  Synopsis:   Return the DWORD At job id from an At filename. At filenames
//              are named according the following convention: "At<nnnn>.Job".
//              The "<nnnn>" portion is the At job id in string form.
//              eg: "At132.Job"
//
//  Arguments:  [pwszAtFileName] -- At path/filename.
//
//  Returns:    Non-zero At job id.
//              Zero if the filename is not recognized as an At filename.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
GetAtJobIdFromFileName(WCHAR * pwszAtFileName)
{
    static ULONG ccAtJobFilenamePrefix = 0;

    schAssert(pwszAtFileName != NULL);

    if (ccAtJobFilenamePrefix == 0)
    {
        ccAtJobFilenamePrefix = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1;
    }

    //
    // Refer to the last (right-most) path element.
    //

    WCHAR * pwsz = wcsrchr(pwszAtFileName, L'\\');

    if (pwsz == NULL)
    {
        pwsz = pwszAtFileName;
    }

    //
    // Skip past the "At" filename portion.
    //

    if (_wcsnicmp(pwsz, TSZ_AT_JOB_PREFIX, ccAtJobFilenamePrefix) == 0)
    {
        pwsz += ccAtJobFilenamePrefix;
    }
    else
    {
        //
        // Unknown filename. At least, it's known if this is an At job.
        // Proceed no further.
        //

        return(0);
    }

    //
    // Isolate the At job Id portion of the path. Do so by temporarilly
    // replacing the extension period character with a null character.
    //

    WCHAR * pwszExt = wcsrchr(pwsz, L'.');

    if (pwszExt != NULL)
    {
        *pwszExt = L'\0';
    }

    //
    // Convert the Id to integer from string form.
    //

    DWORD AtJobId = _wtol(pwsz);

    //
    // Restore period character.
    //

    if (pwszExt != NULL)
    {
        *pwszExt = L'.';
    }

    return(AtJobId);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAtJobPath
//
//  Synopsis:   Constructs a path in the form:
//                  "...\Jobs\At_Jobs\At<nnnn>.job"
//              where <nnnn> is the At job id.
//
//  Arguments:  [JobId]    -- At job Id.
//              [pwszPath] -- Returned path.
//              [cchBuff]  -- size of path buffer
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CreateAtJobPath(DWORD JobId, WCHAR* pwszPath, size_t cchBuff)
{
    WCHAR wszJobId[10 + 1];

    StringCchPrintf(wszJobId, 10 + 1, L"%d", JobId);

    StringCchCopy(pwszPath, cchBuff, gpwszAtJobPathTemplate);
    StringCchCat(pwszPath, cchBuff, wszJobId);
    StringCchCat(pwszPath, cchBuff, TSZ_DOTJOB);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeNetScheduleApi
//
//  Synopsis:   Initializes globals used by the server-side NetScheduleXXX.
//              Associated globals:
//
//              gpwszAtJobPathTemplate    -- Used to construct full paths to
//                                           At jobs in the At jobs directory.
//                                           (eg: "...\At_Jobs\At")
//              gcsNetScheduleCritSection -- Used to serialize thread access
//                                           to server-side NetScheduleXXX
//                                           RPC.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
InitializeNetScheduleApi(void)
{
    WCHAR   wszBuffer[MAX_PATH + 1];
    ULONG   ccAtJobPathTemplate;
    HRESULT hr;

    NET_API_STATUS Status;

    Status = AtCreateSecurityObject();

    if (Status != NERR_Success)
    {
        hr = Status;
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    schAssert(g_TasksFolderInfo.ptszPath);

    ULONG ccFolderPath;
    ccFolderPath = wcslen(g_TasksFolderInfo.ptszPath);

    //
    // Create the At job path template. For use in NetScheduleJobAdd/Del.
    // Example: "<Job Folder Path>\At". To which the Job Id (string form) +
    // the ".job" extension is appended.
    //

    ccAtJobPathTemplate = wcslen(g_TasksFolderInfo.ptszPath) +
                          ARRAY_LEN(TSZ_AT_JOB_PREFIX)       +
                          1;  // '\' + null terminator

    gpwszAtJobPathTemplate = new WCHAR[ccAtJobPathTemplate];

    if (gpwszAtJobPathTemplate == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    StringCchCopy(gpwszAtJobPathTemplate, ccAtJobPathTemplate, g_TasksFolderInfo.ptszPath);
    StringCchCat(gpwszAtJobPathTemplate, ccAtJobPathTemplate, BACKSLASH_STR TSZ_AT_JOB_PREFIX);

    //
    // Register the Event Source, which is used to report NetSchedule
    // errors in the event log - for NT4 ATSVC compatibility
    //

    g_hAtEventSource = RegisterEventSource(NULL, SCHEDULE_EVENTLOG_NAME);
    if (g_hAtEventSource == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    return(S_OK);

InitializeError:

    if (gpwszAtJobPathTemplate != NULL)
    {
        delete gpwszAtJobPathTemplate;
        gpwszAtJobPathTemplate = NULL;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeNetScheduleApi
//
//  Synopsis:   Un-does work done in InitializeNetScheduleApi.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitializeNetScheduleApi(void)
{
    //
    // Clean up the event logging for downlevel jobs
    //

    if (g_hAtEventSource != NULL)
    {
        DeregisterEventSource(g_hAtEventSource);
        g_hAtEventSource = NULL;
    }

    if (gpwszAtJobPathTemplate != NULL)
    {
        delete gpwszAtJobPathTemplate;
        gpwszAtJobPathTemplate = NULL;
    }

    AtDeleteSecurityObject();
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAdminFileOwner
//
//  Synopsis:   Ensure the file owner is an adminstrator. Currently used to
//              determine if AT jobs are owned by administrators. Local system
//              ownership is allowed as well.
//
//  Arguments:  [pwszFile] -- Checked file.
//
//  Returns:    TRUE  -- The owner is an admin or local system.
//              FALSE -- The owner isn't an admin or local system, or the
//                       attempt to confirm ownership identity failed.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
IsAdminFileOwner(LPCWSTR pwszFile)
{
#define SECDESCR_STACK_BUFFER_SIZE  512

    BYTE                 rgbBuffer[SECDESCR_STACK_BUFFER_SIZE];
    PSECURITY_DESCRIPTOR pOwnerSecDescr = rgbBuffer;
    DWORD                cbSize       = SECDESCR_STACK_BUFFER_SIZE;
    DWORD                cbSizeNeeded = 0;
    BOOL                 fAllocatedBuffer;

    if (GetFileSecurity(pwszFile,
                        OWNER_SECURITY_INFORMATION,
                        pOwnerSecDescr,
                        cbSize,
                        &cbSizeNeeded))
    {
        //
        // The information fit within the stack-allocated buffer.
        // This should cover 90% of the cases.
        //
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER && cbSizeNeeded)
    {
        //
        // Too much data. We'll need to allocate memory on the heap.
        //

        fAllocatedBuffer = TRUE;
        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            return FALSE;
        }

        if (!GetFileSecurity(pwszFile,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            delete pOwnerSecDescr;
            return FALSE;
        }
    }
    else
    {
        //
        // An unexpected error occurred. Disallow access.
        //

        return FALSE;
    }

    //
    // Get the owner sid.
    //

    PSID pOwnerSid;
    BOOL fOwnerDefaulted;
    BOOL fRet = FALSE;

    if (GetSecurityDescriptorOwner(pOwnerSecDescr, &pOwnerSid,
                                    &fOwnerDefaulted))
    {
        if (IsValidSid(pOwnerSid))
        {
            //
            // Enumerate the subauthorities to check for the admin RID.
            //

            for (DWORD i = *GetSidSubAuthorityCount(pOwnerSid); i; i--)
            {
                DWORD SubAuthority = *GetSidSubAuthority(pOwnerSid, i);

                if (SubAuthority == DOMAIN_ALIAS_RID_ADMINS ||
                    SubAuthority == SECURITY_LOCAL_SYSTEM_RID)
                {
                    //
                    // Done. Owner is an admin or local system.
                    //

                    fRet = TRUE;
                    break;
                }
            }
        }
    }

    if (pOwnerSecDescr != rgbBuffer)
    {
        delete pOwnerSecDescr;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\msidle.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.h
//
//  Contents:   Types and prototypes for idle detection callback dll
//
//  Classes:
//
//  Functions:
//
//  History:    05-26-1997  darrenmi (Darren Mitchell) Created
//              07-11-1997  anirudhs Temporarily added to NT admin project,
//                  BUGBUG  NEEDS TO BE REMOVED when Darren checks in for NT
//
//----------------------------------------------------------------------------

//
// Idle callback type
//
typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\queue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       queue.cxx
//
//  Contents:   CQueue class implementation.
//
//  Classes:    CQueue
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "queue.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CQueue::AddElement
//
//  Synopsis:   Add an element to the linked list.
//
//  Arguments:  [pdl] -- Doubly-linked list element.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CQueue::AddElement(CDLink * pdl)
{
    schAssert(pdl != NULL);

    //
    // NB: maintain a circular list to insure FIFO ordering.
    //

    if (_pdlFirst == NULL)
    {
        _pdlFirst = pdl;
    }
    else
    {
        pdl->LinkAfter(_pdlFirst->Prev());
    }

    _pdlFirst->SetPrev(pdl);

    ++_cElems;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueue::RemoveElement
//
//  Synopsis:   Remove an element to the linked list.
//
//  Arguments:  [pdl] -- Doubly-linked list element.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CDLink *
CQueue::RemoveElement(CDLink * pdl)
{
    if (pdl != NULL)
    {
        if (pdl == _pdlFirst)
        {
            //
            // Special case list head.
            //

            if (pdl->Next() != NULL)
            {
                pdl->Next()->SetPrev(pdl->Prev());
            }
            _pdlFirst = pdl->Next(); 

            pdl->SetNext(NULL);
            pdl->SetPrev(NULL);
        }
        else
        {
            //
            // If deleting last entry in list, must make list head
            // point to new last entry.  
            //

            if (pdl == _pdlFirst->Prev())
            {
                _pdlFirst->SetPrev(pdl->Prev());    
            }

            //
            // Standard node deletion.
            //

            pdl->UnLink();
        }

        --_cElems;
    }

    return(pdl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\path.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       path.cxx
//
//  Contents:   Functions to manipulate file path strings
//
//  History:    02-Jul-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "path.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   OnExtList
//
//-----------------------------------------------------------------------------
BOOL
OnExtList(LPCWSTR pszExtList, LPCWSTR pszExt)
{
    for (; *pszExtList; pszExtList += lstrlen(pszExtList) + 1)
    {
        if (!lstrcmpi(pszExt, pszExtList))
        {
            return TRUE;        // yes
        }
    }

    return FALSE;
}

// Character offset where binary exe extensions begin in above

#define BINARY_EXE_OFFSET 15
#define EXT_TABLE_SIZE    26    // Understand line above before changing

static const WCHAR achExes[EXT_TABLE_SIZE] = L".cmd\0.bat\0.pif\0.exe\0.com\0";

//+----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:  [] -
//
//-----------------------------------------------------------------------------
BOOL WINAPI
PathIsBinaryExe(LPCWSTR szFile)
{
	Win4Assert( szFile );
    return OnExtList(achExes+BINARY_EXE_OFFSET, PathFindExtension(szFile));
}

//+----------------------------------------------------------------------------
//
//  Function:   PathIsExe
//
//  Synopsis:   Determine if a path is a program by looking at the extension
//
//  Arguments:  [szFile] - the path name.
//
//  Returns:    TRUE if it is a program, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL WINAPI
PathIsExe(LPCWSTR szFile)
{
    LPCWSTR temp = PathFindExtension(szFile);
	Win4Assert( temp );
    return OnExtList(achExes, temp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\procssr.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       procssr.cxx
//
//  Contents:   CJobProcessor class implementation.
//
//  Classes:    CJobProcessor
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//				11/16/00	Dgrube remove (dwRet >= WAIT_OBJECT_0) && 
//							from "else if ((dwRet >= WAIT_OBJECT_0) && (dwRet < WAIT_ABANDONED_0))"
//							since dwRet is a DWORD. It would never occur and
//							is causing compile errors.
//
//-----------------------------------------------------------------------------
//

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "globals.hxx"
#include "svc_core.hxx"
#include "..\inc\resource.h"

// something to differentiate returns from RunDll32 from our returns
#define ERROR_LEVEL_OFFSET 100

// Parameters to CloseWindowEnumProc and ThreadWindowEnumProc
struct ENUMPROCPARMS
{
    DWORD   dwProcessId;    // IN - pid of the process being closed
    BOOL    fWindowFound;   // OUT - whether WM_CLOSE was sent to any window
};

BOOL CALLBACK CloseWindowEnumProc(HWND, LPARAM);
BOOL CALLBACK ThreadWindowEnumProc(HWND, LPARAM);
BOOL CloseWindowForProcess(CRun* pRun);


//
// Notes on the use of CRun's m_dwMaxRunTime and m_ftKill fields:
//
// m_ftKill is the time when the job processor thread monitoring the
// job should try to kill the job, if it hasn't already terminated.
// It is an absolute time.  It is computed when the job is launched, based
// on a combination of (1) the duration-end of triggers that have
// TASK_TRIGGER_FLAG_KILL_AT_DURATION_END set and (2) the MaxRunTime set on
// the job itself.
// (1) can be predicted before the job runs, so it is calculated in
// GetTriggerRunTimes() and stored in m_ftKill.
// (2) is a relative time, so in many cases its end time cannot be
// predicted until the job runs.  It is temporarily stored in m_dwMaxRunTime
// when the CRun object is created; but it is converted to an absolute time
// and combined with m_ftKill when the job is launched in RunJobs().
//
// Once the job is launched, m_ftKill remains the same for the lifetime of
// the CRun object, even if the job is killed because of
// TASK_FLAG_KILL_ON_IDLE_END and restarted because of
// TASK_FLAG_RESTART_ON_IDLE_RESUME.
//
// m_dwMaxRunTime is the remaining number of milliseconds that the
// CJobProcessor::PerformTask() thread will wait for the job to terminate.
// It is initialized to (m_ftKill - current time) in CJobProcessor::
// SubmitJobs() and repeatedly adjusted downwards each time the job processor
// thread wakes up.  If the job is killed and restarted, m_dwMaxRunTime is
// recomputed from the original m_ftKill and the new current time.
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::~CJobProcessor
//
//  Synopsis:   Job processor destructor. This object is reference counted,
//              ala class CTask inheritance. As a result, we are guaranteed
//              all of this is safe to do, as no outstanding references
//              remain.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessor::~CJobProcessor()
{
    TRACE3(CJobProcessor, ~CJobProcessor);

    if (_rgHandles != NULL)
    {
        //
        // Close the processor notification event handle & delete the handle
        // array.
        //

        if (_rgHandles)
        {            
            if (_rgHandles[0])
                CloseHandle(_rgHandles[0]);

            delete _rgHandles;
            _rgHandles = NULL;
        }
    }

    DeleteCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Initialize
//
//  Synopsis:   Perform the initialization steps that would have otherwise
//              been performed in the constructor. This method enables return
//              of a status code if initialization should fail.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessor::Initialize(void)
{
    TRACE3(CJobProcessor, Initialize);

    HRESULT hr;

    schAssert(_rgHandles == NULL);

    //
    // Create the handle array with the processor notification event handle
    // as the sole element.
    //

    _rgHandles = new HANDLE[1];

    if (_rgHandles == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }


    //
    // Create the processor notification event and assign its handle to the
    // handle array.
    //

    _rgHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (_rgHandles[0] == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Request a thread to service this object.
    //

    hr = RequestService(this);

    if (SUCCEEDED(hr))
    {
        this->InService();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::IsIdle
//
//  Synopsis:   This member is called during job processor pool garbage
//              collection to determine if this processor can be removed
//              from the pool. This method is problematic, but this is OK,
//              since the worst that can happen is this processor may
//              be removed from the pool prematurely, requiring use of a
//              additional, redundant job processor object.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
CJobProcessor::IsIdle(void)
{
    TRACE3(CJobProcessor, IsIdle);

    if ((_RequestQueue.GetCount() + _ProcessingQueue.GetCount()) == 0)
    {
        return(this->GetReferenceCount() == 1 ? TRUE : FALSE);
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Next
//
//  Synopsis:   Return the next processor this object refers to. The returned
//              object is AddRef()'d to reflect the new reference.
//
//  Arguments:  None.
//
//  Notes:      The processor pool is locked to ensure this thread is the
//              sole thread accessing the pool throughout this operation.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessor::Next(void)
{
    TRACE3(CJobProcessor, Next);

    gpJobProcessorMgr->LockProcessorPool();

    CJobProcessor * pjpNext = (CJobProcessor *)CDLink::Next();

    if (pjpNext != NULL)
    {
        pjpNext->AddRef();
    }

    gpJobProcessorMgr->UnlockProcessorPool();

    return(pjpNext);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Prev
//
//  Synopsis:   Return the previous processor this object refers to. The
//              returned object is AddRef()'d to reflect the new reference.
//
//  Arguments:  None.
//
//  Notes:      The processor pool is locked to ensure this thread is the
//              sole thread accessing the pool throughout this operation.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessor::Prev(void)
{
    TRACE3(CJobProcessor, Prev);

    gpJobProcessorMgr->LockProcessorPool();

    CJobProcessor * pjpPrev = (CJobProcessor *)CDLink::Prev();

    if (pjpPrev != NULL)
    {
        pjpPrev->AddRef();
    }

    gpJobProcessorMgr->UnlockProcessorPool();

    return(pjpPrev);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::PerformTask
//
//  Synopsis:   This is the function performed by the worker thread on the
//              job processor. The processor thread enters a wait on the array
//              of handles in the private data member, _rgHandles. The first
//              array element is a handle to the processor notification event.
//              This event is signals this thread that new jobs have been sub-
//              mitted to this processor. The remaining n-1 handles in the
//              array are job process handles signaled on job completion.
//              When a job completes, the persisted job object is updated with
//              the job's exit status code, completion time, etc.
//
//              It's possible the wait for one or more jobs may time out. If
//              the processor notification event wait times out, the wait is
//              re-entered. If a job times out, its handle is removed from
//              wait handle array and the job's job info object removed from
//              the processing queue.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::PerformTask(void)
{
#define CLOSE_WAIT_TIME     (3 * 60 * 1000)      //  3 mins (milliseconds).
#define WAIT_TIME_DEFAULT   (10 * 3 * 60 * 1000) // 30 mins (milliseconds).

    TRACE3(CJobProcessor, PerformTask);

    CRun * pRun;
    DWORD      dwObjectIndex;

    //
    // Initialize this thread's keep-awake count.
    //
    InitThreadWakeCount();

    for (;;)
    {
        //
        // Wait for job completion, timeout, or processor notification.
        //
        // NB :  ProcessQueue count + 1 since there is no processing queue
        //       entry for the first handle, the new submission event
        //       handle.
        //
        //       There will never be a discrepancy between the processing
        //       queue count and the actual number of handles in _rgHandles
        //       since this thread exclusively updates the processing queue.
        //

        DWORD dwTimeoutInterval = WAIT_TIME_DEFAULT;
        DWORD cHandles          = _ProcessingQueue.GetCount() + 1;

        if (cHandles > 1)
        {
            //
            // There are jobs to process.
            //
            // Scan job info objects in the processor queue for the minimum
            // value of the job's maximum run time. This will be the wait
            // time on WaitForMultipleObjects.
            //

            for (pRun = _ProcessingQueue.GetFirstElement();
                 pRun != NULL;
                 pRun = pRun->Next())
            {
                schDebugOut((DEB_USER3,
                    "PerformTask(0x%x) Job " FMT_TSTR " remaining time %u ms\n",
                    this,
                    pRun->GetName(),
                    pRun->GetMaxRunTime()));

                dwTimeoutInterval = min(dwTimeoutInterval,
                                        pRun->GetMaxRunTime());
            }
        }

        schDebugOut((DEB_USER3,
            "PerformTask(0x%x) Processor entering wait; p queue cnt(%d); " \
            "wait time %u ms\n",
            this,
            cHandles - 1,
            dwTimeoutInterval));

        DWORD dwWaitTime = GetTickCount();
        DWORD dwRet = WaitForMultipleObjects(cHandles,
                                             _rgHandles,
                                             FALSE,
                                             dwTimeoutInterval);

        //
        // Serialize processor data structure access.
        //

        EnterCriticalSection(&_csProcessorCritSection);

        //
        // (Note that GetTickCount() wrap is automatically taken care of
        // by 2's-complement subtraction.)
        //
        dwWaitTime = GetTickCount() - dwWaitTime;

        schDebugOut((DEB_USER3,
            "PerformTask(0x%x) Processor awake after %u ms\n",
            this,
            dwWaitTime));

        //
        // Decrement each job's max run time by the amount of time waited.
        // Skip jobs with zeroed max run time values.
        //

        for (pRun = _ProcessingQueue.GetFirstElement();
             pRun != NULL;
             pRun = pRun->Next())
        {
            //
            // NB : Jobs with infinite run times do not expire. Therefore, do
            //      not decrease the max run time value.
            //

            if (pRun->GetMaxRunTime() != 0  &&
                pRun->GetMaxRunTime() != INFINITE)
            {
                if (pRun->GetMaxRunTime() > dwWaitTime)
                {
                    pRun->SetMaxRunTime(pRun->GetMaxRunTime() - dwWaitTime);
                }
                else
                {
                    pRun->SetMaxRunTime(0);
                }
            }
        }

        if (dwRet == WAIT_FAILED)
        {
            //
            // Wait attempt failed. Shutdown the processor & bail out.
            //
            // BUGBUG : Should probably log this.
            //

            schDebugOut((DEB_ERROR,
                "PerformTask(0x%x) Wait failure(0x%x) - processor " \
                "shutdown initiated\n",
                this,
                HRESULT_FROM_WIN32(GetLastError())));
            this->_Shutdown();
            LeaveCriticalSection(&_csProcessorCritSection);
            break;
        }

        if (dwRet == WAIT_TIMEOUT)
        {
            if (!_ProcessingQueue.GetCount() && !_RequestQueue.GetCount())
            {
                //
                // Shutdown this processor. The wait has expired and no jobs
                // are in service, nor are there new requests queued.
                //

                schDebugOut((DEB_TRACE,
                    "PerformTask(0x%x) Processor idle - shutdown " \
                    "initiated\n",
                    this));
                this->_Shutdown();
                LeaveCriticalSection(&_csProcessorCritSection);
                break;
            }

            //
            // One or more jobs timed out (those with max run time values of
            // zero). Close associated event handle, overwrite event handle
            // array entry, then remove and destroy the associated job info
            // object from the processor queue.
            //

            schDebugOut((DEB_USER3,
                "PerformTask(0x%x) Wait timeout\n",
                this));

            CRun * pRunNext;
            DWORD i;
            for (pRun = _ProcessingQueue.GetFirstElement(), i = 1;
                 pRun != NULL;
                 pRun = pRunNext, i++)
            {
                pRunNext = pRun->Next();

                if (pRun->GetMaxRunTime() != 0)
                {
                    continue;
                }

                //
                // Post a WM_CLOSE message to the job if this is the
                // first attempt at closure. If WM_CLOSE was issued
                // previously and the job is still running, resort to
                // TerminateProcess.
                //

                if (!(pRun->IsFlagSet(RUN_STATUS_CLOSE_PENDING)))
                {
                    pRun->SetFlag(RUN_STATUS_TIMED_OUT);

                    schDebugOut((DEB_ITRACE,
                        "PerformTask(0x%x) Forced closure; issuing " \
                        "WM_CLOSE to job " FMT_TSTR "\n",
                        this,
                        pRun->GetName()));

                    //
                    // Log job closure, post WM_CLOSE, then re-enter the
                    // wait for closure.
                    //

                    SYSTEMTIME stFinished;
                    GetLocalTime(&stFinished);

                    g_pSched->JobPostProcessing(pRun, stFinished);


                    /*******


                    // Attach to the correct desktop prior to enumerating
                    // the windows
                    //
                    HWINSTA hwinstaSave = NULL;
                    HDESK hdeskSave = NULL;
                    HWINSTA hwinsta = NULL;

                    DWORD dwTreadId = GetCurrentThreadId( );

                    if( NULL == dwTreadId )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetCurrentThreadId " ));
					}
                    else
					{
                         hdeskSave = GetThreadDesktop( dwTreadId );
					}

                    if( NULL == hdeskSave )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetThreadDesktop " ));
					}
                    else
					{
	                     hwinstaSave = GetProcessWindowStation( );
					}

                    if( NULL == hwinstaSave )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetProcessWindowStation " ));
					}


                    hwinsta = OpenWindowStation(
	                              pRun->GetStation( ),
	                              TRUE,
	                              MAXIMUM_ALLOWED );

                    if( NULL == hwinsta )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, OpenWindowStation " ));
					}
                    else if( !SetProcessWindowStation( hwinsta ) )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, SetProcessWindowStation " ));
					}

                    HDESK hDesk = OpenDesktop(
		                              pRun->GetDesktop(),  
		                              0,						//No hooks allowed
		                              TRUE,					//No inheritance
			                          MAXIMUM_ALLOWED
		                              );

                    if( !SetThreadDesktop( hDesk ) )
					{
                          schDebugOut((DEB_ERROR,
	                            "CJobProcessor::PerformTask, OpenDesktop failed, " \
	                            "status = 0x%lx\n",
	                            GetLastError()));
					}
                    else
					{

                          // Success enumerate windows else SetMaxRunTime to 0
                          // and ultimately kill the process (not very graceful)
			              //
                          EnumWindows(CloseWindowEnumProc, (LPARAM) &Parms);
					}
                    ********************/

					
					pRun->SetFlag(RUN_STATUS_CLOSE_PENDING);
                    BOOL fFoundWindow = CloseWindowForProcess(pRun);
					 
					if (fFoundWindow)
				    {
					    pRun->SetMaxRunTime(CLOSE_WAIT_TIME);
					}
					else
					{
					    schDebugOut((DEB_ITRACE, "PerformTask: no windows found\n"));

					    //
						// If WM_CLOSE was not sent to any windows, there is no
						// point waiting for the job to terminate.
						// DCR: It would be polite, and perhaps help the app to 
						// avoid data loss (depending on the app), to send some other
						// notification, such as a CTRL_C_EVENT.  See bug 65251.
						//
						pRun->SetMaxRunTime(0);
					}
                }
                else
                {
                    schDebugOut((DEB_ITRACE,
                        "PerformTask(0x%x) 2nd forced closure; issuing " \
                        "TerminateProcess on job " FMT_TSTR "\n",
                        this,
                        pRun->GetName()));

                    DWORD dwExitCode = 0;
                    GetExitCodeProcess(pRun->GetHandle(), &dwExitCode);

                    if (dwExitCode == STILL_ACTIVE)
                    {
                        TerminateProcess(pRun->GetHandle(), (UINT)-1);
                    }

                    if (i < _ProcessingQueue.GetCount()) // Ignore last
                                                         // entry.
                    {
                        CopyMemory(&_rgHandles[i],
                                   &_rgHandles[i + 1],
                                   sizeof(HANDLE) *
                            (_ProcessingQueue.GetCount() - i));
                    }

                    i--;    // Reflect overwritten array entry.

                    //
                    // Remove CRun object from the processing queue
                    // and destroy it.
                    //

                    _ProcessingQueue.RemoveElement(pRun);

                    if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                    {
                        //
                        // This thread is monitoring one less system-
                        // required job
                        //
                        WrapSetThreadExecutionState(FALSE,
                            "processor - forced close of task");
                    }

                    if (pRun->IsFlagSet(RUN_STATUS_RESTART_ON_IDLE_RESUME)
                        && pRun->GetWait() > 0)
                    {
                        //
                        // Ask the main thread to move it back into the
                        // idle wait queue
                        //
                        pRun->ClearFlag(JOB_INTERNAL_FLAG_MASK);
                        pRun->SetMaxRunTime(INFINITE);
                        g_pSched->SubmitIdleRun(pRun);
                        //
                        // Note that we changed (reduced) pRun's MaxRunTime
                        // when we killed it.  However we didn't mess with
                        // the kill time.  The MaxRunTime will be recomputed
                        // based on the same kill time as before when this
                        // run is next submitted to a processor.
                        //
                    }
                    else
                    {
                        delete pRun;
                    }
                }
            }
        }
        else if (dwRet < WAIT_ABANDONED_0)
        {
            //
            // One or more jobs completed.
            //

            dwObjectIndex = dwRet - WAIT_OBJECT_0;

            if (dwObjectIndex == 0)
            {
                //
                // Processor notification event signaled. Either new jobs
                // have been submitted or the service is stopping.
                //

                if (IsServiceStopping())
                {
                    //
                    // Service stop. Shutdown the processor.
                    //

                    schDebugOut((DEB_TRACE,
                        "PerformTask(0x%x) Service stop - processor " \
                        "shutdown initiated\n",
                        this));
                    this->_Shutdown();
                    LeaveCriticalSection(&_csProcessorCritSection);
                    break;
                }

                ResetEvent(_rgHandles[0]);

                //
                // Move jobs from request to processing queue.
                //

                _ProcessRequests();

                //
                // Unblock the thread that called SubmitJobs().
                // (We happen to know it's the thread in the main service
                // loop so we can use the global event.  A cleaner model
                // would be to either pass the handle of the event to
                // SubmitJobs, or use an event private to SubmitJobs and
                // PerformTask.)
                //
                g_pSched->Unblock();
            }
            else if (dwObjectIndex < cHandles)
            {
                //
                // A job has finished (or closed).
                // Find the CRun object associated with the handle.
                //

                if ((pRun = _ProcessingQueue.FindJob(
                                    _rgHandles[dwObjectIndex])) != NULL)
                {
                    pRun->ClearFlag(RUN_STATUS_RUNNING);

                    if (!(pRun->GetFlags() & RUN_STATUS_CLOSE_PENDING))
                    {
                        schDebugOut((DEB_USER3,
                            "PerformTask(0x%x) Job " FMT_TSTR " completed\n",
                            this,
                            pRun->GetName()));

                        //
                        // The job finished on its own. Log completion
                        // status. Fetch job completion time for pending log
                        // entry.
                        //

                        pRun->SetFlag(RUN_STATUS_FINISHED);

                        SYSTEMTIME stFinished;
                        GetLocalTime(&stFinished);

                        //
                        // Standard job post processing.
                        //

                        g_pSched->JobPostProcessing(pRun, stFinished);
                    }
                    else
                    {
                        // (NOTE: This may not be necessary - this info
                        //      is not used yet.)
                        //
                        pRun->SetFlag(RUN_STATUS_CLOSED);
                    }

                    //
                    // Fix up handle array to reflect processed entry.
                    //

                    if (dwObjectIndex < _ProcessingQueue.GetCount())
                    {
                        CopyMemory(&_rgHandles[dwObjectIndex],
                                   &_rgHandles[dwObjectIndex + 1],
                                   sizeof(HANDLE) *
                        (_ProcessingQueue.GetCount() - dwObjectIndex));
                    }

                    //
                    // Remove CRun object from the processing queue and
                    // destroy it.
                    //

                    _ProcessingQueue.RemoveElement(pRun);

                    if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                    {
                        //
                        // This thread is monitoring one less system-
                        // required job
                        //
                        WrapSetThreadExecutionState(FALSE,
                            "processor - last task exited");
                    }

                    if (pRun->IsFlagSet(RUN_STATUS_CLOSE_PENDING) &&
                        pRun->IsFlagSet(RUN_STATUS_RESTART_ON_IDLE_RESUME) &&
                        pRun->GetWait() > 0)
                    {
                        //
                        // Ask the main thread to move it back into the
                        // idle wait queue
                        //
                        pRun->ClearFlag(JOB_INTERNAL_FLAG_MASK);
                        pRun->SetMaxRunTime(INFINITE);
                        g_pSched->SubmitIdleRun(pRun);
                        //
                        // Note that we changed (reduced) pRun's MaxRunTime
                        // when we killed it.  However we didn't mess with
                        // the kill time.  The MaxRunTime will be reset to
                        // match the same kill time as before when this run
                        // is next submitted to a processor.
                        //
                    }
                    else
                    {
                        delete pRun;
                    }
                }
            }
            else
            {
                //
                // Index out of range.  This should never happen.
                //

                schDebugOut((DEB_ERROR,
                    "PerformTask(0x%x) Wait array index (%d) out of " \
                    "range! Handle count(%d)\n",
                    this,
                    dwObjectIndex,
                    cHandles));

				schAssert(0);

                LeaveCriticalSection(&_csProcessorCritSection);
                continue;
            }
        }
        else
        {
            //
            // Clueless how we got here. Just continue the wait.
            //

            schAssert(!"How did this branch get evaluated?");
            LeaveCriticalSection(&_csProcessorCritSection);
            continue;
        }

        LeaveCriticalSection(&_csProcessorCritSection);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseWindowForProcess
//
//  Synopsis:   launches separate process to issue WM_CLOSE to main window
//
//  Arguments:  CRun for the job of interest
//
//  Return value: true if a window was found.
//
//  Notes:      
//
//----------------------------------------------------------------------------
BOOL CloseWindowForProcess(CRun* pRun)
{
    // processID == 0 means we can't find / don't have a proc id
    if (pRun->GetProcessId() == 0)
        return FALSE;

    BOOL fWindowClosed = false;

    // okay - it might not be the default desktop, but is the best guess we have
    // if we guess wrong, no harm done - the PID is unique & we won't close the wrong proc
    BOOL fIsDefaultWinsta = (NULL == pRun->GetStation()) || (NULL == pRun->GetDesktop());
    
    // create process in proper winsta
    // process is rundll32 to invoke CloseProc

    WCHAR dllPath[MAX_PATH +2];
    WCHAR runDllPath[MAX_PATH +2];
    BOOL bLaunched = false;
    HANDLE hProc = INVALID_HANDLE_VALUE;
    
    if (ExpandEnvironmentStringsW(L"%windir%\\system32\\rundll32.exe", runDllPath, MAX_PATH +1) && 
        GetModuleFileNameW(g_hInstance, dllPath, MAX_PATH +1))
    {
        WCHAR templitt[] = L"%s %s,CloseProc %u";

        size_t cchCommandLine = wcslen(runDllPath) + wcslen(dllPath) + wcslen(templitt) + 20;
        WCHAR* pCommandLine   = new WCHAR[cchCommandLine];

        size_t cchDesktop;
        WCHAR* pDesktop = NULL;
        if (fIsDefaultWinsta)
            pDesktop = L"WinSta0\\Default";
        else
        {
            cchDesktop = wcslen(pRun->GetStation()) + wcslen(pRun->GetDesktop()) + 5;
            pDesktop = new WCHAR[cchDesktop];
        }
        
        if (pCommandLine && pDesktop)
        {
            StringCchPrintf(pCommandLine, cchCommandLine, templitt, runDllPath, dllPath, pRun->GetProcessId());  

            if (!fIsDefaultWinsta)
            {
                StringCchCopy(pDesktop, cchDesktop, pRun->GetStation());
                StringCchCat(pDesktop, cchDesktop, L"\\");
                StringCchCat(pDesktop, cchDesktop, pRun->GetDesktop());
            }
            // else - pDesktop was init'd above
            
            PROCESS_INFORMATION procInfo;
            STARTUPINFO startInfo;
            SecureZeroMemory(&startInfo, sizeof(startInfo));
            startInfo.lpDesktop = pDesktop;
            startInfo.cb = sizeof(STARTUPINFO);

            bLaunched = CreateProcessW(NULL, pCommandLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
                                       NULL, NULL, &startInfo, &procInfo);
            hProc = procInfo.hProcess;
        }

        // if fIsDefaultWinsta, then pDesktop is pointing at static memory
        if (pDesktop && !fIsDefaultWinsta) delete[] pDesktop;
        if (pCommandLine) delete[] pCommandLine;
    }

    if (bLaunched)
    {
        if (WaitForSingleObject(hProc, 60000) == WAIT_OBJECT_0)
        {
            DWORD exitCode;
            if (GetExitCodeProcess(hProc, &exitCode))
                fWindowClosed = exitCode - ERROR_LEVEL_OFFSET;
        }

        CloseHandle(hProc);
    }
    
    return fWindowClosed;
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseProcEx
//
//  Synopsis:   Entry point used with RunDll32
//              closes down window via WM_CLOSE
//
//  Arguments:  [hwnd]        -- ignored
//              [hinst]       -- uninteresting
//              [nCmdShow]    -- boring
//              [lpszCmdLine] -- command line from invocation 
//
//  Notes:      command line should be proc id.
//              CloseProc in main is a straight passthrough to this one.
//
//----------------------------------------------------------------------------
extern "C" void CALLBACK CloseProcEx(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    BOOL fFoundWindow = FALSE;

    ENUMPROCPARMS params;
    params.fWindowFound = 0;

    if (lpszCmdLine && strlen(lpszCmdLine))
    {
        if (sscanf(lpszCmdLine, "%u", &params.dwProcessId))  // SEC:REVIEWED 2002-04-30
                                                             // this function does not involve an unbounded string copy
        {        
            EnumWindows(CloseWindowEnumProc, (LPARAM) &params);
            fFoundWindow = params.fWindowFound;
        }
    }    

    ExitProcess(fFoundWindow +ERROR_LEVEL_OFFSET);
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseWindowEnumProc
//
//  Synopsis:
//
//  Arguments:  [hWnd]   --
//              [lParam] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CALLBACK
CloseWindowEnumProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwProcessId, dwThreadId;
    ENUMPROCPARMS * pParms = (ENUMPROCPARMS *) lParam;

    dwThreadId = GetWindowThreadProcessId(hWnd, &dwProcessId);

    if (dwProcessId == pParms->dwProcessId)
    {
        //
        // Enumerate and close each owned, non-child window. This will close
        // open dialogs along with the main window(s).
        //

        DWORD dwErr;
        if (!EnumThreadWindows(dwThreadId, ThreadWindowEnumProc, lParam))
            dwErr = GetLastError();
           
        // some processes, e.g. cmd.exe don't get enumerated by EnumThreadWindows
        // if so, we'll try one close message to the top window.  
        if ((pParms->fWindowFound == false) && IsWindow(hWnd))
        {
            PostMessage(hWnd, WM_CLOSE, 0, 0);
            pParms->fWindowFound = true;
        }

        return FALSE;
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ThreadWindowEnumProc
//
//  Synopsis:   Enumeration procedure.
//
//  Arguments:  [hWnd]   -- The window handle.
//              [lParam] -- The process ID.
//
//----------------------------------------------------------------------------
BOOL CALLBACK
ThreadWindowEnumProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwProcessId;
    ENUMPROCPARMS * pParms = (ENUMPROCPARMS *) lParam;

    GetWindowThreadProcessId(hWnd, &dwProcessId);

    if (dwProcessId == pParms->dwProcessId)
    {
        //
        // Close any dialogs.
        //

        //
        // The most common dialog we are likely to see at this point is a
        // "save changes" dialog. First try to send no to close that dialog
        // and then try a cancel.
        //
        if( !PostMessage(hWnd, WM_COMMAND, 0, MAKEWPARAM(IDNO, 0)) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg1, " \
				"status = 0x%lx\n",
				GetLastError()));
		}

        if( !PostMessage(hWnd, WM_COMMAND, 0, MAKEWPARAM(IDCANCEL, 0)) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg2, " \
				"status = 0x%lx\n",
				GetLastError()));
		}
        //
        // Close any non-child windows.
        //

        if( !PostMessage(hWnd, WM_CLOSE, 0, 0) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg3, " \
				"status = 0x%lx\n",
				GetLastError()));
		}
        //
        // Tell the calling function that we found a matching window.
        //
        pParms->fWindowFound = TRUE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::SubmitJobs
//
//  Synopsis:   This method is used to submit new jobs to this processor.
//
//              Each processor can handle a maximum of (MAXIMUM_WAIT_OBJECTS
//              - 1) jobs (from the WaitForMultipleObjects constraint of
//              at most MAXIMUM_WAIT_OBJECTS). Subject to processor capacity,
//              all, or a subset of the jobs passed may be taken.
//
//  Arguments:  [pRunList] -- Submitted job linked list object. Jobs taken are
//                            transferred from this list to a private one.
//
//  Returns:    S_OK    -- No submissions taken (as a result of a normal
//                         condition, such as the job processor already full,
//                         or the job processor shutting down).
//              S_SCHED_JOBS_ACCEPTED -- Some submissions taken.
//                         On return, GetFirstJob() will return NULL if all
//                         submissions were taken.
//              S_FALSE -- The service is shutting down. Call Shutdown()
//                         on this processor immediately after this return
//                         code. Submissions were likely taken, but they will
//                         not execute.
//              HRESULT -- On error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessor::SubmitJobs(CRunList * pRunList)
{
    TRACE3(CJobProcessor, SubmitJobs);
    schAssert(pRunList != NULL);

    HRESULT hr = S_OK;
    BOOL fJobsAccepted = FALSE;

    schDebugOut((DEB_USER3,
        "SubmitJobs(0x%x) pRunList(0x%x)\n",
        this,
        pRunList));

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    FILETIME ftNow = GetLocalTimeAsFileTime();
    schDebugOut((DEB_USER3, "SubmitJobs: Time now = %lx %lx\n",
                 ftNow.dwLowDateTime, ftNow.dwHighDateTime));

    //
    // Add as many jobs as this processor will allow to the request queue.
    // See synopsis for details.
    //
    // NB : Adding one to the request/processing queue sum to reflect the new
    //      processor notification event handle. For this handle array entry,
    //      there is no processing queue entry.
    //

    CRun * pRun = pRunList->GetFirstJob();

    //
    // First, check if this processor is in the process of shutting down.
    // The data member, _rgHandles, is utilized as a flag to indicate this.
    // If it is NULL, this processor has shutdown and will take no more jobs.
    //

    if (_rgHandles != NULL)
    {
        while ( !pRun->IsNull() &&
                (MAXIMUM_WAIT_OBJECTS - (this->_RequestQueue.GetCount()    +
                                         this->_ProcessingQueue.GetCount() +
                                         1) ))
        {
            CRun * pRunNext = pRun->Next();

            pRun->UnLink();

            schDebugOut((DEB_USER3,
                "SubmitJobs: pRun(%#lx) (" FMT_TSTR ") KillTime = %lx %lx\n",
                pRun, pRun->GetName(), pRun->GetKillTime().dwLowDateTime,
                pRun->GetKillTime().dwHighDateTime));

            //
            // Compute the max run time (the time we will wait for
            // this job to complete) based on the kill time
            //
            DWORDLONG MaxRunTime;
            if (FTto64(pRun->GetKillTime()) < FTto64(ftNow))
            {
                MaxRunTime = 0;
            }
            else
            {
                MaxRunTime = (FTto64(pRun->GetKillTime()) - FTto64(ftNow)) /
                                FILETIMES_PER_MILLISECOND;
                MaxRunTime = min(MaxRunTime, MAXULONG);
            }
            pRun->SetMaxRunTime((DWORD) MaxRunTime);
            schDebugOut((DEB_USER3, "SubmitJobs: MaxRunTime = %lu\n", MaxRunTime));

            _RequestQueue.AddElement(pRun);

            fJobsAccepted = TRUE;

            pRun = pRunNext;
        }

        //
        // Is there a thread servicing this object? If not, request one.
        //

        if (!this->IsInService())
        {
            //
            // NB : A RequestService() return code of S_FALSE indicates the
            //      service is shutting down. Simply propagate this return
            //      code. It will then be the caller's responsibility to
            //      shut down this processor.
            //

            hr = RequestService(this);

            if (SUCCEEDED(hr) && hr != S_FALSE)
            {
                this->InService();
            }
        }

        //
        // Set the processor notification event.
        //

        schDebugOut((DEB_USER3,
            "CJobProcessor::SubmitJobs(0x%x) Signalling processor thread\n"));

        //
        // A NOP if RequestService() failed above.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);

    if (hr == S_OK && fJobsAccepted)
    {
        hr = S_SCHED_JOBS_ACCEPTED;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::KillJob
//
//  Synopsis:   Kill all instances of the job indicated, if in service by
//              this processor.
//
//  Arguments:  [ptszJobName] -- Job name.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::KillJob(LPTSTR ptszJobName)
{
    TRACE(CJobProcessor, KillJob);
    BOOL fContractInitiated = FALSE;

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    //
    // Is the job serviced by this processor?
    // Find associated job info object(s) in the processing queue.
    //
    // NB : Rarely, but it is possible there may be more than one instance.
    //

    CRun * pRun;
    for (pRun = _ProcessingQueue.GetFirstElement(); pRun != NULL;
                        pRun = pRun->Next())
    {
        //
        // The abort flag check addresses the case where more than one user
        // simultaneously aborts the same job.
        //

        if (!lstrcmpi(ptszJobName, pRun->GetName()) &&
            !(pRun->GetFlags() & RUN_STATUS_ABORTED))
        {
            //
            // Set flags for immediate timeout and closure.
            //

            pRun->SetMaxRunTime(0);
            pRun->SetFlag(RUN_STATUS_ABORTED);
            fContractInitiated = TRUE;
        }
    }

    if (fContractInitiated)
    {
        //
        // This logic will induce the PerformTask thread to respond as
        // follows:
        //     - The wait will unblock and the next wait time re-calculated;
        //       this value will be zero since the min value is taken.
        //     - The wait is re-entered and immediately times out.
        //     - Jobs with max run times of zero are closed in the
        //       WAIT_TIMEOUT condition. As a result, the jobs are killed.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::KillIfFlagSet
//
//  Synopsis:   Kill all jobs that have the passed in flag set, if in service
//              by this processor.
//
//  Arguments:  [dwFlag] - Job flag value, one of TASK_FLAG_KILL_ON_IDLE_END
//                         or TASK_FLAG_KILL_IF_GOING_ON_BATTERIES.
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::KillIfFlagSet(DWORD dwFlag)
{
    TRACE(CJobProcessor, KillIfFlagSet);
    BOOL fContractInitiated = FALSE;

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    //
    // Is the job serviced by this processor?
    // Find associated job info object(s) in the processing queue.
    //

    CRun * pRun;
    for (pRun = _ProcessingQueue.GetFirstElement(); pRun != NULL;
                        pRun = pRun->Next())
    {
        //
        // The abort flag check addresses the case where more than one user
        // simultaneously aborts the same job.
        //

        if ((pRun->GetFlags() & dwFlag) &&
            !(pRun->GetFlags() & RUN_STATUS_ABORTED))
        {
            //
            // Set flags for immediate timeout and closure.
            //

            pRun->SetMaxRunTime(0);
            pRun->SetFlag(RUN_STATUS_ABORTED);
            if (dwFlag == TASK_FLAG_KILL_ON_IDLE_END &&
                pRun->IsFlagSet(TASK_FLAG_RESTART_ON_IDLE_RESUME) &&
                ! pRun->IsIdleTriggered())
            {
                //
                // Note that this is the only case in which we set
                // RUN_STATUS_RESTART_ON_IDLE_RESUME.  If a job is terminated
                // because a user explicitly terminated it, for example, we
                // don't want to restart it on idle resume.
                //
                pRun->SetFlag(RUN_STATUS_RESTART_ON_IDLE_RESUME);
            }
            fContractInitiated = TRUE;
        }
    }

    if (fContractInitiated)
    {
        //
        // This logic will induce the PerformTask thread to respond as
        // follows:
        //     - The wait will unblock and the next wait time re-calculated;
        //       this value will be zero since the min value is taken.
        //     - The wait is re-entered and immediately times out.
        //     - Jobs with max run times of zero are closed in the
        //       WAIT_TIMEOUT condition. As a result, the jobs are killed.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Shutdown
//
//  Synopsis:   Effect processor shutdown. Do so by signalling the
//              PerformTask thread. The thread will check the global service
//              status flag. If the service is stopped (actually, in the
//              process of stopping), the thread will execute the processor
//              shutdown code & relinquish itself.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::Shutdown(void)
{
    TRACE3(CJobProcessor, Shutdown);

    EnterCriticalSection(&_csProcessorCritSection);

    if (_rgHandles != NULL)
    {
        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_EmptyJobQueue
//
//  Synopsis:   Empty respective job queue and log, per job, the reason why.
//
//  Arguments:  [JobQueue] -- Reference to CJobQueue instance.
//              [dwMsgId]  -- Why each job was abandoned. A value of zero 
//					indicates no reason; nothing is logged.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_EmptyJobQueue(CJobQueue & JobQueue, DWORD dwMsgId)
{
    TRACE3(CJobProcessor, _EmptyJobQueue);

    CRun * pRun;

    for (pRun = JobQueue.RemoveElement(); pRun != NULL;
            pRun = JobQueue.RemoveElement())
    {
        if (!dwMsgId)
        {
            //
            // BUGBUG : Log job info + reason why the job was abandoned.
            //          Should logging be per job? Per incident w/ job list?
            //
        }

        delete pRun;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_ProcessRequests
//
//  Synopsis:   Transfer submitted jobs from the request queue to the
//              processing queue and rebuild the wait handle array.
//
//  Arguments:  None.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_ProcessRequests(void)
{
    TRACE3(CJobProcessor, _ProcessRequests);

    if (_RequestQueue.GetCount())
    {
        //
        // Sum request, processing queue counts.
        //

        DWORD cJobs = _RequestQueue.GetCount() +
                     _ProcessingQueue.GetCount() + 1;

        schDebugOut((DEB_USER3,
            "CJobProcessor::_ProcessRequests(0x%x) Total job count(%d) = " \
            "request(%d) + processing(%d) + 1\n",
            this,
            cJobs,
            _RequestQueue.GetCount(),
            _ProcessingQueue.GetCount()));

        //
        // Logic in SubmitJobs should prevent this from becoming false.
        //

        schAssert(cJobs <= MAXIMUM_WAIT_OBJECTS);

        HANDLE * rgHandles = new HANDLE[cJobs];

        if (rgHandles == NULL)
        {
            //
            // Leave request, processing queues as-is.
            //
            LogServiceError(IDS_FATAL_ERROR,
                            ERROR_NOT_ENOUGH_MEMORY,
                            IDS_HELP_HINT_CLOSE_APPS);
            ERR_OUT("JobProcessor: ProcessRequests", E_OUTOFMEMORY);
            return;
        }

        //
        // Copy existing handles.
        //

        CopyMemory(rgHandles,
                   _rgHandles,
                   sizeof(HANDLE) * (_ProcessingQueue.GetCount() + 1));

        //
        // Copy new job handles from request queue and transfer request
        // queue contents to the tail of the processing queue.
        //

        for (DWORD i = _ProcessingQueue.GetCount() + 1; i < cJobs; i++)
        {
            CRun * pRun = _RequestQueue.RemoveElement();
			
			Win4Assert( pRun != NULL );
            
			rgHandles[i] = pRun->GetHandle();
            _ProcessingQueue.AddElement(pRun);

            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                //
                // Increment the count of running system_required jobs
                // handled by this thread.  If this is the first such
                // job, tell the system not to sleep until further notice.
                //
                WrapSetThreadExecutionState(TRUE, "processor - new job");
            }
        }

        delete _rgHandles;
        _rgHandles = rgHandles;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_Shutdown
//
//  Synopsis:   Take no more requests and dump whatever jobs remain in the
//              request & processing queues.
//
//  Arguments:  None.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_Shutdown(void)
{
    TRACE3(CJobProcessor, _Shutdown);

    //
    // Utilizing the handle array member as a flag to indicate that this
    // processor will take no more new jobs. Set this member to NULL on
    // shutdown.
    //
    // First close the processor notification event handle & delete the
    // array.
    //

    // No need to keep the machine awake for this thread any more
    if (pfnSetThreadExecutionState != NULL)
    {
        schDebugOut((DEB_USER5, "RESETTING sys-required state: processor shutdown\n"));
        (pfnSetThreadExecutionState)(ES_CONTINUOUS);
    }

    CloseHandle(_rgHandles[0]);
    _rgHandles[0] = NULL;
    delete _rgHandles;
    _rgHandles = NULL;

    //
    // Now, empty request & processing queues.
    //
    // BUGBUG : Log job abandoned message.
    //

    this->_EmptyJobQueue(_RequestQueue);
    this->_EmptyJobQueue(_ProcessingQueue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::JobPostProcessing
//
//  Synopsis:   Set the exit code, current status, and NextRunTime on the
//              job object and log the run exit.
//
//  Arguments:  [pRun]          -- Job run information object.
//              [stFinished]    -- Job finish time (local time). For logging.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSchedWorker::JobPostProcessing(
    CRun *       pRun,
    SYSTEMTIME & stFinished)
{
    TRACE3(CSchedWorker, JobPostProcessing);
    schDebugOut((DEB_ITRACE,
        "JobPostProcessing pRun(0x%x) flags(0x%x)\n",
        pRun,
        pRun->GetFlags()));

    DWORD dwExitCode;

    CJob * pJob = NULL;

    //
    // Instantiate the job so that the exit status can be saved.
    //
    // Note: if any of the variable length properties or the triggers are
    // needed, then a full activation will be necessary.
    //
    // Important: the running instance count must be protected by the
    // critical section here, where it is decremented, and in RunJobs, where
    // it is incremented. These are the only sections of code that change
    // the running instance count on the file object.
    //

    EnterCriticalSection(&m_SvcCriticalSection);

    HRESULT hr = ActivateWithRetry(pRun->GetName(), &pJob, FALSE);
    if (FAILED(hr))
    {
        //
        // The job object may have been deleted.  We can't supply LogTaskError
        // with the name of the run target, since that's on the job object,
        // which we just failed to load.
        //

        LogTaskError(pRun->GetName(),
                     NULL,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                     NULL,
                     (DWORD)hr);
        ERR_OUT("JobPostProcessing Activate", hr);
        LeaveCriticalSection(&m_SvcCriticalSection);
        return;
    }

    //
    // Isolate the executable name.
    //

    TCHAR tszExeName[MAX_PATH + 1];
    GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

    if (pRun->GetFlags() & RUN_STATUS_FINISHED)
    {
        //
        // Only check the exit code if the job completed normally, that is,
        // it wasn't timed-out or aborted.
        //
        if (!GetExitCodeProcess(pRun->GetHandle(), &dwExitCode))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_GET_EXITCODE,
                         NULL,
                         GetLastError());
            ERR_OUT("GetExitCodeProcess", GetLastError());
        }
    }
    else
    {
        //
        // BUGBUG : What is written on the job when not complete?
        //
    }

    //
    // PostRunUpdate updates the flags and instance count, so always call it.
    //
    pJob->PostRunUpdate(dwExitCode, pRun->GetFlags() & RUN_STATUS_FINISHED);

    //
    // If the last run and the delete flag is set, delete the job object.
    //

    if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS) &&
        pJob->IsFlagSet(TASK_FLAG_DELETE_WHEN_DONE))
    {
        hr = pJob->Delete();
        if (FAILED(hr))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_DELETE_JOB,
                         NULL,
                         GetLastError());
            ERR_OUT("JobPostProcessing, delete-when-done", hr);
        }
    }
    else
    {
        //
        // Write the updated status to the job object. If there are sharing
        // violations, retry two times.
        //
        hr = pJob->SaveWithRetry(NULL,
                                 FALSE,
                                 SAVEP_RUNNING_INSTANCE_COUNT |
                                 SAVEP_PRESERVE_NET_SCHEDULE);
        if (FAILED(hr))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_UPDATE_JOB,
                         NULL,
                         GetLastError());
            ERR_OUT("JobPostProcessing, Saving run-completion-status", hr);
        }
    }

    LeaveCriticalSection(&m_SvcCriticalSection);

    if (pRun->GetFlags() & RUN_STATUS_FINISHED)
    {
        // Log job finish time & result.
        //
        LogTaskStatus(pRun->GetName(),
                      tszExeName,
                      IDS_LOG_JOB_STATUS_FINISHED,
                      dwExitCode);
    }
    else if (pRun->GetFlags() & RUN_STATUS_ABORTED)
    {
        // Log job closure on abort warning.
        //
        LogTaskError(pRun->GetName(),
                     tszExeName,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_ABORTED,
                     &stFinished);
    }
    else if (pRun->GetFlags() & RUN_STATUS_TIMED_OUT)
    {
        // Log job closure on timeout warning.
        //
        LogTaskError(pRun->GetName(),
                     tszExeName,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_TIMEOUT,
                     &stFinished,
                     0,
                     IDS_HELP_HINT_TIMEOUT);
    }

    pJob->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\rpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpc.cxx
//
//  Contents:   RPC related routines.
//
//  Classes:    None.
//
//  Functions:  StartRpcServer
//              StopRpcServer
//
//  RPC:
//
//  History:    25-Oct-95   MarkBl  Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "atsvc.h"
#include "SASecRPC.h"

RPC_BINDING_VECTOR * gpBindingVector = NULL;

//
// We have to register protocol sequences and known end points only once
// per process.
//

BOOL gRegisteredProtocolSequences = FALSE;

WCHAR *              grgpwszProtocolSequences[] = {
                            L"ncalrpc",         // Local RPC
                            L"ncacn_ip_tcp",    // Connection-oriented TCP/IP
                            L"ncacn_spx",       // Connection-oriented SPX
                            NULL
};

//+---------------------------------------------------------------------------
//
//  Function:   StartRpcServer
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
StartRpcServer(void)
{
    RPC_STATUS  RpcStatus;
    HRESULT     hr = S_OK;

    //
    // Register protocol sequences and known end points onlt if we have not 
    // already done so in this process.
    //

    if (!gRegisteredProtocolSequences) {

        //
        // Support all available protocols.
        //
        // NB : Named pipe support is handled specifically below.
        //

        for (int i = 0; grgpwszProtocolSequences[i] != NULL; i++)
        {
            RpcStatus = RpcServerUseProtseq(grgpwszProtocolSequences[i],
                                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                            NULL);

            if (RpcStatus != RPC_S_OK && RpcStatus != RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
                //
                // Bail on error other than protseq not supported; may be out
                // of memory.
                //

                CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));

                goto RpcError;
            }
        }

        //
        // Now, explicitly handle named pipe support. Register a specific
        // endpoint for named pipes.
        //

        RpcStatus = RpcServerUseProtseqEp(L"ncacn_np",
                                          RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                          L"\\PIPE\\atsvc",
                                          NULL);

        if (RpcStatus)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            goto RpcError;
        }

        gRegisteredProtocolSequences = TRUE;
    }

    //
    // Register the protocol handles with the endpoint-mapping service.
    //

    if (RpcStatus = RpcServerInqBindings(&gpBindingVector))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(HRESULT_FROM_WIN32(RpcStatus));
    }

    // AT service interface.
    //
    RpcStatus = RpcEpRegister(atsvc_ServerIfHandle,
                              gpBindingVector,
                              NULL,
                              NULL);

    if (RpcStatus)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    // Scheduling Agent security interface.
    //
    RpcStatus = RpcEpRegister(sasec_ServerIfHandle,
                              gpBindingVector,
                              NULL,
                              NULL);

    if (RpcStatus)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    //
    // Set up secure RPC. Note, if the RPC client doesn't explicitly state
    // they wish the RPC connection to be secured, the connection defaults
    // to non-secure.
    //

    if (RpcStatus = RpcServerRegisterAuthInfo(NULL,
                                              RPC_C_AUTHN_WINNT,
                                              NULL,
                                              NULL))
    {
        if (RpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            //
            // This happens when NTLMSSP -- which is used for authentication
            // on the named pipes transport -- is not installed.  Typically
            // happens when "Client for Microsoft Networks" is not installed.
            // However, local users can still be authenticated by LRPC.
            //
            // Note, if "Client for Microsoft Networks" is subsequently
            // installed, remote callers will get RPC_S_UNKNOWN_AUTHN_SERVICE
            // until the service is restarted.  BUGBUG  Fix this by noticing
            // the PNP event that indicates the net has arrived, and then
            // calling RpcServerRegisterAuthInfo again.
            //
            schDebugOut((DEB_ERROR, "**** No authentication provider is "
                         "installed.  Remote clients will get error "
                         "RPC_S_UNKNOWN_AUTHN_SERVICE.\n"));
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            goto RpcError;
        }
    }

    //
    // Finally, register the interface(s) and listen on them.
    //

    if (RpcStatus = RpcServerRegisterIfEx(atsvc_ServerIfHandle,
                                          NULL,
                                          NULL,
                                          RPC_IF_AUTOLISTEN,
                                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                          NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    if (RpcStatus = RpcServerRegisterIfEx(sasec_ServerIfHandle,
                                          NULL,
                                          NULL,
                                          RPC_IF_AUTOLISTEN,
                                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                          NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    return(S_OK);

RpcError:

    if (gpBindingVector != NULL)
    {
        RpcBindingVectorFree(&gpBindingVector);
        gpBindingVector = NULL;
    }

    return(HRESULT_FROM_WIN32(RpcStatus));
}

//+---------------------------------------------------------------------------
//
//  Function:   StopRpcServer
//
//  Synopsis:   Stop the RPC server.
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
StopRpcServer(void)
{
    RpcServerUnregisterIf(atsvc_ServerIfHandle, NULL, 0);
    RpcServerUnregisterIf(sasec_ServerIfHandle, NULL, 0);

    if (gpBindingVector != NULL)
    {
        RpcEpUnregister(atsvc_ServerIfHandle, gpBindingVector, NULL);
        RpcEpUnregister(sasec_ServerIfHandle, gpBindingVector, NULL);
        RpcBindingVectorFree(&gpBindingVector);

        gpBindingVector = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\runjob.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       runjob.cxx
//
//  Contents:   Functions to run the target file.
//
//  History:    02-Jul-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <lmerr.h>          // NERR_Success
#include <dsgetdc.h>        // DsGetDcName
#include <lmaccess.h>       // NetUserGetInfo
#include <lmapibuf.h>       // NetApiBufferFree
#include <netevent.h>       // for logging to event log
#include "globals.hxx"
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "path.hxx"
#include "..\inc\common.hxx"
#include "..\inc\runobj.hxx"
#include <wtsapi32.h>
 

HRESULT
ComposeBatchParam(
    LPCTSTR pwszPrefix,
    LPCTSTR wszAppPathName,
    LPCTSTR pwszParameters,
    LPTSTR * ppwszCmdLine
    );

HRESULT
ComposeParam(BOOL fTargetIsExe,
             LPTSTR ptszRunTarget,
             LPTSTR ptszParameters,
             LPTSTR * pptszCmdLine);

#include <userenv.h>  // LoadUserProfile

BOOL AllowInteractiveServices(void);
BOOL LogonAccount(
                LPCWSTR   pwszJobFile,
                CJob *    pJob,
                DWORD *   pdwErrorMsg,
                HRESULT * pdwSpecificError,
				//CRun *	  pRun,
                HANDLE *  phToken,
                BOOL *    pfTokenIsShellToken,
                LPWSTR *  ppwsz,
                HANDLE *  phUserProfile);
HANDLE
LoadAccountProfile(
    HANDLE  hToken,
    LPCWSTR pwszUser,
    LPCWSTR pwszDomain);

BOOL GetUserTokenFromSession(
	LPTSTR lpszUsername,
	LPTSTR lpszDomain,
	PHANDLE phUserToken
);

DWORD   SchedUPNToAccountName(
                IN  LPCWSTR lpUPN,
                OUT LPWSTR  *ppAccountName);

void InitializeStartupInfo(
                CJob *        pJob,
                LPTSTR        ptszDesktop,
                STARTUPINFO * psi);
HRESULT MapFindExecutableError(HINSTANCE hRet);
BOOL WaitForStubExe(HANDLE hProcess);


#define WSZ_INTERACTIVE_DESKTOP L"WinSta0\\Default"
#define WSZ_SA_DESKTOP          L"SAWinSta\\SADesktop"
#define CMD_PREFIX          TEXT("cmd.exe /c ")
#define STUB_PREFIX         L"RUNDLL32.EXE Shell32.DLL,ShellExec_RunDLL ?0x400?"
                                // 0x400 is SEE_MASK_FLAG_NO_UI
#define USERNAME            L"USERNAME"
#define USERDOMAIN          L"USERDOMAIN"
#define USERPROFILE         L"USERPROFILE"

#define DQUOTE              TEXT("\"")
#define SPACE               TEXT(" ")

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunNTJob
//
//  Synopsis:   Run an NT Job.
//
//  Arguments:  [pJob] - the job object to be run.
//              [pRun] - the run information object.
//              [phrRet] - a place to return launch failure info.
//              [pdwErrMsgID] - message ID for failure reporting.
//
//  Returns:    S_OK - if job launched.
//              S_FALSE - if job not launched.
//              HRESULT - other, fatal, error.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunNTJob(CJob * pJob, CRun * pRun, HRESULT * phrRet,
                       DWORD * pdwErrMsgID)
{
    LPWSTR pwszRunTarget,
           pwszWorkingDir = pJob->m_pwszWorkingDirectory,
           pwszParameters = pJob->m_pwszParameters;
    DWORD  cch;
    BOOL   fRanJob              = FALSE;
    LPTSTR ptszDesktop          = NULL;
    HANDLE hImpersonationHandle = NULL;
    HANDLE hToken               = NULL;
    BOOL   fTokenIsShellToken   = FALSE;
    HANDLE hUserProfile         = NULL;
    BOOL   fTargetIsExe         = FALSE;
    BOOL   fTargetIsBinaryExe   = FALSE;
    BOOL   fUseStubExe          = FALSE;


    *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

    size_t cchBuff = lstrlen(pJob->m_pwszApplicationName) + 1;
    pwszRunTarget = new WCHAR[cchBuff];

    if (pwszRunTarget == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    StringCchCopy(pwszRunTarget, cchBuff, pJob->m_pwszApplicationName);

    schDebugOut((DEB_TRACE, "*** Running job %S\n", pJob->m_ptszFileName));
    schDebugOut((DEB_USER3, "*** with MaxRunTime of %u\n", pJob->m_dwMaxRunTime));

    HRESULT hr = S_OK;
    WCHAR wszAppPathName[MAX_PATH + 1];
    LPWSTR pwszCmdLine = NULL;

    //
    // Logon the account associated with the job and set the security token
    // and desktop appropriately based on several factors: is this an AT job,
    // is the account the same as the currently logged-on user, etc.
    //

    if (!LogonAccount(pJob->m_ptszFileName,
                      pJob,
                      pdwErrMsgID,
                      phrRet,
					  //pRun,
                      &hToken,
                      &fTokenIsShellToken,
                      &ptszDesktop,
                      &hUserProfile))
    {
        hr = S_FALSE;
        goto cleanup;
    }

	if( NULL != ptszDesktop )
	{
		hr = pRun->SetDesktop( _tcschr( ptszDesktop, '\\' ) + 1 );
		if( FAILED( hr ) )
		{
		    LogServiceError(IDS_NON_FATAL_ERROR,
		                    ERROR_OUTOFMEMORY,
		                    IDS_HELP_HINT_CLOSE_APPS);
		    ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
		    goto cleanup;
		}

		TCHAR ptszStation[MAX_PATH];

		SecureZeroMemory( ptszStation, sizeof(ptszStation) );

		wcsncpy( ptszStation, ptszDesktop, 
			( _tcschr( ptszDesktop, '\\' ) - ptszDesktop ) );

		hr = pRun->SetStation( ptszStation );

		if( FAILED( hr ) )
		{
		    LogServiceError(IDS_NON_FATAL_ERROR,
		                    ERROR_OUTOFMEMORY,
		                    IDS_HELP_HINT_CLOSE_APPS);
		    ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
		    goto cleanup;
		}
	}

	//
    // NOTE: After this point, if fTokenIsShellToken is TRUE, we must leave
    // gUserLogonInfo.CritSection.
    //

    //
    // For all but AT jobs, impersonate the user to ensure the user
    // gets access checked correctly on the file executed.
    //

    hImpersonationHandle = NULL;

    if (!pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        if (fTokenIsShellToken)
        {
            hImpersonationHandle = ImpersonateLoggedInUser();
        }
        else
        {
            hImpersonationHandle = ImpersonateUser(hToken,
                                                   hImpersonationHandle);
        }

        if (hImpersonationHandle == NULL)
        {
            *phrRet      = 0;
            *pdwErrMsgID = IDS_ACCOUNT_LOGON_FAILED;
            hr = S_FALSE;
            goto cleanup2;
        }
    }

    //
    // Change to the job's working dir before searching for the
    // executable.
    //
    if (pwszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(pwszWorkingDir))
        {
            //
            // An invalid working directory may not prevent the job from
            // running, so this is not a fatal error. Log it though, to
            // inform the user.
            //
            TCHAR tszExeName[MAX_PATH + 1];

            GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_BAD_DIR,
                         NULL,
                         GetLastError(),
                         IDS_HELP_HINT_BADDIR);

            //
            // Set the pointer to NULL so that CreateProcess will ignore it.
            //
            pwszWorkingDir = NULL;
        }
    }

    //
    // Check if the run target has an extension and determine if the run
    // target is a program, a batch or command file (.bat or .cmd), or a
    // document.  If there is no extension, then it is assumed that it is a
    // program.
    //
    WCHAR* pExtension = PathFindExtension(pwszRunTarget);

    if (*pExtension == '\0')
    {
        fTargetIsExe = TRUE;
        fTargetIsBinaryExe = TRUE;
    }
    else if (PathIsExe(pwszRunTarget))
    {
        fTargetIsExe = TRUE;

        if (PathIsBinaryExe(pwszRunTarget))
        {
            fTargetIsBinaryExe = TRUE;
        }
    }

    if (fTargetIsExe)
    {
        if (fTargetIsBinaryExe)
        {
            DBG_OUT("Job target is a binary executable");
        }
        else
        {
            DBG_OUT("Job target is a batch file");
        }

        if (pwszRunTarget[1] == L':' || pwszRunTarget[1] == L'\\')
        {
            //
            // If the second character is a colon or a backslash, then this
            // must be a fully qualified path. If so, don't call SearchPath.
            //

            StringCchCopy(wszAppPathName, MAX_PATH + 1, pwszRunTarget);
        }
        else
        {
            //
            // Build a full path name for the application.
            //

            DWORD cchFound;

            cchFound = SearchPath(NULL, pwszRunTarget, DOTEXE, MAX_PATH + 1,
                                  wszAppPathName, NULL);

            if (!cchFound || cchFound >= MAX_PATH)
            {
                //
                // Error, cannot locate job target application. Note that this
                // is not a fatal error (probably file-not-found) so
                // processing will continue with other jobs in the list.
                //

                //
                // phrRet and pdwErrMsgId are used by LogTaskError on return.
                //
                *phrRet = HRESULT_FROM_WIN32(GetLastError());
                *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

                hr = S_FALSE;
                goto cleanup3;
            }
        }

        if (fTargetIsBinaryExe)
        {
            schDebugOut((DEB_ITRACE, "*** Running '%S'\n", wszAppPathName));
        }
    }
    else
    {
        DBG_OUT("Job target is a document");

        HINSTANCE hRet = FindExecutable(pwszRunTarget,
                                        pwszWorkingDir,
                                        wszAppPathName);
        if (hRet == (HINSTANCE)31)
        {
            //
            // No association found.  Try using rundll32.exe with ShellExecute
            // to run the document.
            //
            fUseStubExe = TRUE;

            fTargetIsExe = TRUE;
            fTargetIsBinaryExe = FALSE;

            StringCchCopy(wszAppPathName, MAX_PATH + 1, pwszRunTarget);
        }
        else if (hRet < (HINSTANCE)32)
        {
            //
            // This is not a fatal error, so RunJobs will just log the failure
            // and continue with any other pending jobs.
            //

            //
            // phrRet and pdwErrMsgId are used by LogTaskError on return.
            //
            schDebugOut((DEB_ERROR, "FindExecutable FAILED with %d for '%ws'\n",
                         hRet, pwszRunTarget));
            *phrRet = MapFindExecutableError(hRet);
            *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

            hr = S_FALSE;
            goto cleanup3;
        }
        else
        {
            //
            // If running a document by association, the parameter property is
            // ignored and the run target property is passed as the parameter.
            //
            pwszParameters = pwszRunTarget;
            pwszRunTarget = wszAppPathName;

            schDebugOut((DEB_ITRACE, "*** Running '%S'\n", pwszParameters));
        }
    }

    if (fTargetIsExe && !fTargetIsBinaryExe)
    {
        hr = ComposeBatchParam(fUseStubExe ? STUB_PREFIX : CMD_PREFIX,
                               wszAppPathName,
                               pwszParameters,
                               &pwszCmdLine);

        if (FAILED(hr))
        {
            goto cleanup3;
        }

        schDebugOut((DEB_ITRACE, "*** Running batch file '%S'\n", pwszCmdLine));
    }
    else
    {
        //
        // Add the app name as the first token of the command line param.
        //

        if (pwszParameters != NULL)
        {
            hr = ComposeParam(fTargetIsExe,
                              pwszRunTarget,
                              pwszParameters,
                              &pwszCmdLine);

            if (FAILED(hr))
            {
                goto cleanup3;
            }

            schDebugOut((DEB_ITRACE, "*** With cmd line '%S'\n", pwszCmdLine));
        }
    }

    STARTUPINFO startupinfo;

    InitializeStartupInfo(pJob, ptszDesktop, &startupinfo);

    if (pJob->IsFlagSet(TASK_FLAG_HIDDEN))
    {
        startupinfo.wShowWindow = SW_HIDE;
    }

    //
    // Modify the path if the application has an app path registry entry
    //

    BOOL  fChangedPath;
    LPWSTR pwszSavedPath;

    fChangedPath = SetAppPath(wszAppPathName, &pwszSavedPath);

    //
    // Launch job.
    //
    // NB : Must call CreateProcess when the token handle is
    //      NULL (in the case of AT jobs running as local system),
    //      since CreateProcessAsUser rejects NULL handles.
    //      Alternatively, OpenProcessToken could be used,
    //      but then we have to deal with the failure cases,
    //      logging appropriate errors, closing the token
    //      handle, etc.
    //

    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwProcessId = 0;

    if (hToken == NULL)
    {
        PROCESS_INFORMATION processinfo;
        ZeroMemory(&processinfo, sizeof(PROCESS_INFORMATION));

        fRanJob = CreateProcess((fTargetIsExe && !fTargetIsBinaryExe) ?
                                    NULL : wszAppPathName,
                                pwszCmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                pJob->m_dwPriority          |
                                    CREATE_NEW_CONSOLE      |
                                    CREATE_SEPARATE_WOW_VDM,
                                NULL,
                                pwszWorkingDir,
                                &startupinfo,
                                &processinfo);

        hProcess    = processinfo.hProcess;
        hThread     = processinfo.hThread;
        dwProcessId = processinfo.dwProcessId;
    }
    else
    {
        LPVOID  lpEnvironment;

        //
        // Launch the job with the appropriate environment
        //

        schDebugOut((DEB_ITRACE, "Calling CreateEnvironmentBlock...\n"));
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hToken,
                                    FALSE))
        {
            ERR_OUT("CreateEnvironmentBlock", GetLastError());
            lpEnvironment = NULL;
        }
        else
        {
            schDebugOut((DEB_ITRACE, "... CreateEnvironmentBlock succeded\n"));
        }

        PROCESS_INFORMATION processinfo;
        ZeroMemory(&processinfo, sizeof(PROCESS_INFORMATION));

        fRanJob = CreateProcessAsUser(hToken,
                                      (fTargetIsExe && !fTargetIsBinaryExe) ?
                                          NULL : wszAppPathName,
                                      pwszCmdLine,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      pJob->m_dwPriority          |
                                          CREATE_NEW_CONSOLE      |
                                          CREATE_SEPARATE_WOW_VDM |
                                          CREATE_UNICODE_ENVIRONMENT,
                                      lpEnvironment,
                                      pwszWorkingDir,
                                      &startupinfo,
                                      &processinfo);

        hProcess    = processinfo.hProcess;
        hThread     = processinfo.hThread;
        dwProcessId = processinfo.dwProcessId;

        //
        // DestroyEnvironmentBlock handles NULL
        //

        DestroyEnvironmentBlock(lpEnvironment);
    }

    if (fRanJob && fUseStubExe)
    {
        //
        // If we launched the stub exe, we must wait for it to exit, and check
        // its exit code.
        //
        fRanJob = WaitForStubExe(hProcess);

        //
        // It's not interesting to copy info about the stub exe into pRun
        //
        CloseHandle(hProcess);
        CloseHandle(hThread);
        hProcess =  NULL;
        dwProcessId = NULL;
    }

    if (fRanJob)
    {
        //
        // Successfully launched job.
        //
        hr = S_OK;

        pRun->SetHandle(hProcess);
        pRun->SetProcessId(dwProcessId);

        if (fUseStubExe)
        {
            pRun->ClearFlag(RUN_STATUS_RUNNING);    // was set by SetHandle
            fRanJob = FALSE;    

            // HMH: okay, I don't like this logic, but that's the way it worked 
            // when I got here.  It seems like the process launched by the stub
            // would want the user profile, etc, available...
            //                  ... but then we wouldn't know when to close it!

            if (hUserProfile)
                UnloadUserProfile(hToken, hUserProfile);

            if (hToken && !fTokenIsShellToken)
                CloseHandle(hToken);
        }
        else
        {
            CloseHandle(hThread);
            pRun->SetProfileHandles(hToken, hUserProfile, !fTokenIsShellToken);
        }
    }
    else
    {
        //
        // Job launch failed.
        //
        hr = S_FALSE;

        // so, let's clean up - shall we?
        if (hUserProfile)
            UnloadUserProfile(hToken, hUserProfile);

        if (hToken && !fTokenIsShellToken)
            CloseHandle(hToken);

        //
        // phrRet and pdwErrMsgId are used by LogTaskError on return.
        //
        *phrRet = HRESULT_FROM_WIN32(GetLastError());
        *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;
        schDebugOut((DEB_ERROR, "*** CreateProcess for job %S failed, %lu\n",
                     pJob->m_ptszFileName, GetLastError()));
    }

    if (fChangedPath)
    {
        SetEnvironmentVariable(L"PATH", pwszSavedPath);
        delete [] pwszSavedPath;
        pwszSavedPath = NULL;
    }

    //
    // If impersonating, stop.
    //

cleanup3:

    if (!pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        StopImpersonating(hImpersonationHandle, !fTokenIsShellToken);
    }

cleanup2:

    if (fTokenIsShellToken)
    {
        LeaveCriticalSection(gUserLogonInfo.CritSection);
    }

cleanup:

    //
    // If the job ran successfully, then the CRun object pointed to by pRun
    // has the profile and user tokens and will release them when the job
    // quits.  


    //
    // Change back to the service's working directory.
    //
    if (pwszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(m_ptszSvcDir))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, GetLastError(), 0);
            ERR_OUT("RunJobs: changing back to the service's directory",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    if (pwszRunTarget != wszAppPathName)
    {
        delete [] pwszRunTarget;
    }
    else
    {
        delete [] pwszParameters;
    }

    if (pwszCmdLine != NULL)
    {
        delete [] pwszCmdLine;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   LogonAccount
//
//  Synopsis:   Retrieve the account information associated with the job
//              and logon.
//
//              Non-AT jobs:
//              Account == Current logged on user:
//              If the logon succeeds and the account matches that of the
//              currently logged on user, return the shell security token
//              to be used with CreateProcessAsUser. This enables jobs to
//              show up on the user's desktop.
//
//              Account != Current logged on user or no user logged on:
//              If the logon succeeds, but the currently logged on user is
//              different than the account, or there is no-one logged on,
//              return the account token. Also return the scheduling agent's
//              desktop name in the desktop return argument so this job can
//              run on it.
//
//              AT jobs:
//              Ensure the AT job owner is an administrator and return an
//              account token.  AT jobs never get the shell token, since
//              that's how the original schedule service worked.  Also
//              return the desktop name, "WinSta0\Default".
//
//  Arguments:  [pwszJobFile]         -- Path to the job object file.
//              [pJob]                -- Job object to execute under the
//                                       associated account.
//              [pdwErrorMsg]         -- SCHED_E error message on error.
//              [pdwSpecificError]    -- HRESULT on error.
//              [phToken]             -- Returned token.
//              [pfTokenIsShellToken] -- If TRUE, the token returned is the
//                                       shell's.
//              [ppwszDesktop]        -- Desktop to launch the job on.
//              [phUserProfile]       -- user profile token
//
//  Returns:    TRUE  -- Logon successful.
//              FALSE -- Logon failure.
//
//  Notes:      DO NOT delete:
//                  *pptszDestkop. If non-NULL, it refers to a static string.
//                  *phToken if *pfTokenIsShellToken == TRUE. This token
//                    cannot be duplicated. You delete it and you've got
//                    problems.
//              If *pfTokenIsShellToken, the logon session critical section
//              has been entered! Right after the call to CreateProcessAsUser
//              leave this critical section if this flag value is TRUE.
//
//-----------------------------------------------------------------------------
BOOL
LogonAccount(LPCWSTR   pwszJobFile,
             CJob *    pJob,
             DWORD *   pdwErrorMsg,
             HRESULT * phrSpecificError,
			 // CRun *	   pRun,
             HANDLE *  phToken,
             BOOL *    pfTokenIsShellToken,
             LPWSTR *  ppwszDesktop,
             HANDLE *  phUserProfile)
{
    JOB_CREDENTIALS jc;
    HANDLE          hToken = NULL;
    HRESULT         hr;
    WCHAR           wszProfilePath[MAX_PATH+1] = L"";
    ULONG           cchPath = ARRAY_LEN(wszProfilePath);

    *pdwErrorMsg         = 0;
    *phrSpecificError    = S_OK;
    *phToken             = NULL;
    *pfTokenIsShellToken = FALSE;
    *ppwszDesktop        = NULL;
    *phUserProfile       = NULL;

    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        //
        // Verify the job's signature.
        //
        if (! pJob->VerifySignature())
        {
            *phrSpecificError = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            *pdwErrorMsg      = IDS_FILE_ACCESS_DENIED;
            return(FALSE);
        }

        *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;

        hr = GetNSAccountInformation(&jc);

        if (SUCCEEDED(hr))
        {
            if (hr == S_OK)
            {
                if (!LogonUser(jc.wszAccount,
                               jc.wszDomain,
                               jc.wszPassword,
                               LOGON32_LOGON_BATCH,
                               LOGON32_PROVIDER_DEFAULT,
                               &hToken))
                {
                    *pdwErrorMsg      = IDS_NS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(GetLastError());
                }

                //
                // Don't leave the plain-text password on the stack.
                //

                ZERO_PASSWORD(jc.wszPassword);

                if (*phrSpecificError)
                {
                    return(FALSE);
                }

                // If the job was scheduled to run in any account other than LocalSystem account
                if ((!jc.fIsPasswordNull) ||(jc.wszAccount[0] != L'\0'))
                {
                    // If Fast User Switching is enabled and the task user
                    // is logged on in any of the sessions then use the session's 
                    // user token in place of that obtained above so any UI associated 
                    // with the job can show up on the user's desktop.

                    // If terminal serveice is running but FUS is disabled, WTSEnumerateSessions
                    // will return the only user logged on. If the username and domain name of that 
                    // user matches with the jc.wszDomain and jc.wszAccount respectively, then  
                    // GetUserTokenFromSession will return TRUE with the token of that user

                    HANDLE hSessionUserToken = INVALID_HANDLE_VALUE;
                    BOOL bUserLoggedOn = GetUserTokenFromSession(jc.wszAccount,jc.wszDomain,&hSessionUserToken);

                    if(bUserLoggedOn)
                    {
                        schDebugOut((DEB_TRACE, "*** user session found\n"));

                        if (!jc.fIsPasswordNull)
                        {
                            // pRun->SetProfileHandles(hSessionUserToken, *phUserProfile);
                            *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
                        }

                        hToken = hSessionUserToken;
                    }
                }

				*phToken = hToken;
                *phUserProfile = LoadAccountProfile(hToken,
                                                    jc.wszAccount,
                                                    jc.wszDomain);
            }
        }
        else
        {
            CHECK_HRESULT(hr);
            *pdwErrorMsg      = IDS_FAILED_NS_ACCOUNT_RETRIEVAL;
            *phrSpecificError = hr;
            return(FALSE);
        }
    }
    else 
    {
        hr = GetAccountInformation(pJob->GetFileName(), &jc);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            *pdwErrorMsg      = IDS_FAILED_ACCOUNT_RETRIEVAL;
            *phrSpecificError = hr;
            return(FALSE);
        }

        //
        // If the job was set with a NULL password, we don't need to log it on.
        //
        if (jc.fIsPasswordNull)
        {
            //
            // If the job was scheduled to run in the LocalSystem account
            // (Accountname is the empty string), the NULL password is valid.
            //
            if (jc.wszAccount[0] == L'\0')
            {
                //
                // It's LocalSystem, so we don't need to log on the account.
                // Since the token is zeroed out above, this works
                //
                schDebugOut((DEB_TRACE, "Running %ws as LocalSystem\n",
                             pJob->GetFileName()));
                *ppwszDesktop = WSZ_SA_DESKTOP;
                return(TRUE);
            }
            else
            {
                //
                // It's not LocalSystem, so make sure this job has
                // the appropriate flags for a NULL password set
                //
                if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
                {
                    schDebugOut((DEB_ERROR, "%ws is scheduled to run in "
                                 "a user account with a NULL password, but"
                                 " lacks TASK_FLAG_RUN_ONLY_IF_LOGGED_ON\n",
                                 pJob->GetFileName()));
                    //
                    // Not a completely accurate error message, but since there
                    // is no UI for this task option, it's good enough.
                    //
                    *pdwErrorMsg        = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError   = SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
                }
            }
        }
        else
        {
            //
            // If the name was stored as a UPN, convert it to a SAM name first.
            //
            if (jc.wszDomain[0] == L'\0')
            {
                LPWSTR pwszSamName;
                DWORD dwErr = SchedUPNToAccountName(jc.wszAccount, &pwszSamName);
                if (dwErr != NO_ERROR)
                {
                    *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(dwErr);
                    CHECK_HRESULT(*phrSpecificError);
                }
                else
                {
                    WCHAR * pSlash = wcschr(pwszSamName, L'\\');
                    schAssert(pSlash);
                    *pSlash = L'\0';
                    StringCchCopy(jc.wszDomain, MAX_DOMAINNAME + 1, pwszSamName);
                    StringCchCopy(jc.wszAccount, MAX_USERNAME + 1, pSlash + 1);
                    delete pwszSamName;
                }
            }

            if (SUCCEEDED(*phrSpecificError))
            {
                if (!LogonUser(jc.wszAccount,
                               jc.wszDomain,
                               jc.wszPassword,
                               LOGON32_LOGON_BATCH,
                               LOGON32_PROVIDER_DEFAULT,
                               &hToken))
                {
                    *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }

        //
        // Don't leave the plain-text password on the stack.
        //

        ZERO_PASSWORD(jc.wszPassword);

		if (*phrSpecificError)
        {
            return(FALSE);
        }

        //
        // Load the user profile associated with the account just logged on.
        // (If the user is already logged on, this will just increment the
        // profile ref count, to be decremented when the job stops.)
        // Don't bother doing this if the job is "run-only-if-logged-on", in
        // which case it's OK to unload the profile when the user logs off.
        //

        if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
        {
			*phToken = hToken;
            *phUserProfile = LoadAccountProfile(*phToken,
                                                jc.wszAccount,
                                                jc.wszDomain);
        }

      
        // If Fast User Switching is enabled and the task user
        // is logged on in any of the sessions then use the session's 
        // user token in place of that obtained above so any UI associated 
        // with the job can show up on the user's desktop.

        // If terminal serveice is running but FUS is disabled, WTSEnumerateSessions
        // will return the only user logged on. If the username and domain name of that 
        // user matches with the jc.wszDomain and jc.wszAccount respectively, then  
        // GetUserTokenFromSession will return TRUE with the token of that user

        HANDLE hSessionUserToken = INVALID_HANDLE_VALUE;
        BOOL bUserLoggedOn = GetUserTokenFromSession(jc.wszAccount,jc.wszDomain,&hSessionUserToken);
		
        if(bUserLoggedOn)
        {
            schDebugOut((DEB_TRACE, "*** Terminal services running and user session found\n"));
            
            if (!jc.fIsPasswordNull)
            {
                *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
            }

            // we're not passing this one out, close it
            if (hToken)
                CloseHandle(hToken);

            *phToken             = hSessionUserToken;
            *pfTokenIsShellToken = FALSE;
        }
	
        else
        {
            schDebugOut((DEB_TRACE, "*** user session not found executing old code\n"));
            //
		    // Providing a user is logged on locally, is the account logged
            // on above the same as that of the currently logged on user?
            // If so, use the shell's security token in place of that
            // obtained above so any UI associated with the job can
            // show up on the user's desktop.
            //
            //                  ** Important **
            //
            // Only perform this check if the account logon succeeded
            // above. Otherwise, it would be possible to specify an
            // account name with an invalid password and have the job
            // run anyway.
            //

		    EnterCriticalSection(gUserLogonInfo.CritSection);

            GetLoggedOnUser();

            if (gUserLogonInfo.DomainUserName != NULL &&
                _wcsicmp(jc.wszAccount, gUserLogonInfo.UserName) == 0 &&
                _wcsicmp(jc.wszDomain, gUserLogonInfo.DomainName) == 0)

		    {
                if (!jc.fIsPasswordNull)
                {
				    *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
                }

                // we're not passing this one out, so close it
                if (hToken)
                    CloseHandle(hToken);

                *phToken             = gUserLogonInfo.ShellToken;
                *pfTokenIsShellToken = TRUE;
            }
            else
            {
                LeaveCriticalSection(gUserLogonInfo.CritSection);

                //
                // Is this "run-only-if-logged-on"?
                //
                if (pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
                {
                    //
                    // The job is "run-only-if-logged-on" and the user is
                    // not currently logged on, so fail silently
                    //
                    schDebugOut((DEB_TRACE, "Not running %ws because user is not logged on\n",
                                 pJob->GetFileName()));
                    *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;   // not really used
                    *phrSpecificError = S_FALSE;    // suppress error logging
                    if (!jc.fIsPasswordNull)
                    {
                        CloseHandle(hToken);
                    }
                    return(FALSE);
                }

                *phToken      = hToken;
                *ppwszDesktop = WSZ_SA_DESKTOP;
                //
                // Load the user profile associated with the account just logged on.
                // (If the user is already logged on, this will just increment the
                // profile ref count, to be decremented when the job stops.)
                // Don't bother doing this if the job is "run-only-if-logged-on", in
                // which case it's OK to unload the profile when the user logs off.
                //
			    if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON) && (NULL == *phUserProfile))
			    {
				    *phUserProfile = LoadAccountProfile(*phToken,
                                                    jc.wszAccount,
                                                    jc.wszDomain);
			    }
            }
        }
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadAccountProfile
//
//  Synopsis:   Attempt to load the profile for the specified user.
//
//  Arguments:  [hToken]     - handle representing user
//              [pwszUser]   - user name
//              [pwszDomain] - domain name
//
//  Returns:    Profile handle or NULL.
//
//  History:    10-04-96   DavidMun   Created
//              07-07-99   AnirudhS   Rewrote to use NetUserGetInfo
//
//  Notes:      Returned profile handle must be closed with
//                  UnloadUserProfile(hToken, hUserProfile);
//              CODEWORK  Delay-load netapi32.dll.
//
//----------------------------------------------------------------------------

HANDLE
LoadAccountProfile(
    HANDLE  hToken,
    LPCWSTR pwszUser,
    LPCWSTR pwszDomain
    )
{
    schDebugOut((DEB_TRACE, "Loading profile for '%ws%'\\'%ws'\n",
                 pwszDomain, pwszUser));

    //
    // Determine the server on which to look up the account info
    // Skip this for for local accounts
    // CODEWORK  lstrcmpi won't work if pwszDomain is a DNS name.
    //
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    LPWSTR  pwszDC = NULL;

    if (lstrcmpi(pwszDomain, gpwszComputerName) != 0)
    {
        DWORD err = DsGetDcName(NULL, pwszDomain, NULL, NULL, 0, &pDcInfo);
        if (err == NO_ERROR)
        {
            pwszDC = pDcInfo->DomainControllerName;
        }
        else
        {
            schDebugOut((DEB_ERROR, "DsGetDcName for '%ws' FAILED, %u\n",
                         pwszDomain, err));

            // continue anyway, using NULL as the server
        }
    }

    //
    // Impersonate the user before calling NetUserGetInfo
    //
    if (!ImpersonateLoggedOnUser(hToken))
    {
        ERR_OUT("ImpersonateLoggedOnUser", GetLastError());
    }

    //
    // Look up the path to the profile for the account
    //
    LPUSER_INFO_3 pUserInfo = NULL;

    NET_API_STATUS nerr = NetUserGetInfo(pwszDC, pwszUser, 3,
                                         (LPBYTE *) &pUserInfo);
    //
    // Stop impersonating
    //
    if (!RevertToSelf())
    {
        ERR_OUT("RevertToSelf", GetLastError());
    }

    if (nerr != NERR_Success)
    {
        schDebugOut((DEB_ERROR, "NetUserGetInfo on '%ws' for '%ws' FAILED, %u\n",
                     pwszDC, pwszUser, nerr));
        NetApiBufferFree(pDcInfo);
        SetLastError(nerr);
        return NULL;
    }

    NetApiBufferFree(pDcInfo);

    schDebugOut((DEB_USER3, "Profile path is '%ws'\n", pUserInfo->usri3_profile));

    //
    // LoadUserProfile changes our USERPROFILE environment variable, so save
    // its value before calling LoadUserProfile
    //
    WCHAR  wszOrigUserProfile[MAX_PATH + 1] = L"";

    GetEnvironmentVariable(USERPROFILE,
                           wszOrigUserProfile,
                           ARRAY_LEN(wszOrigUserProfile));

    //
    // Load the profile
    //
    PROFILEINFO ProfileInfo;

    SecureZeroMemory(&ProfileInfo, sizeof(ProfileInfo));
    ProfileInfo.dwSize = sizeof(ProfileInfo);
    ProfileInfo.dwFlags = PI_NOUI;
    ProfileInfo.lpUserName = (LPWSTR) pwszUser;
    if (pUserInfo != NULL)
    {
        ProfileInfo.lpProfilePath = pUserInfo->usri3_profile;
    }

    if (!LoadUserProfile(hToken, &ProfileInfo))
    {
        schDebugOut((DEB_ERROR, "LoadUserProfile from '%ws' FAILED, %lu\n",
                     ProfileInfo.lpProfilePath, GetLastError()));
        ProfileInfo.hProfile = NULL;
    }

    NetApiBufferFree(pUserInfo);

    //
    // Restore environment variables changed by LoadUserProfile
    //
    SetEnvironmentVariable(USERPROFILE, wszOrigUserProfile);

    return ProfileInfo.hProfile;
}


//+----------------------------------------------------------------------------
//
//  Function:   AllowInteractiveServices
//
//  Synopsis:   Tests the NoInteractiveServices value in the Microsoft\Windows
//              key. If the value is present and its value is non-zero return
//              FALSE; return TRUE otherwise.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Allow interactive services.
//              FALSE -- Disallow interactive services.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
BOOL
AllowInteractiveServices(void)
{
#define WINDOWS_REGISTRY_PATH L"System\\CurrentControlSet\\Control\\Windows"
#define NOINTERACTIVESERVICES L"NoInteractiveServices"

    HKEY  hKey;
    DWORD dwNoInteractiveServices, dwSize, dwType;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     WINDOWS_REGISTRY_PATH,
                     0L,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwNoInteractiveServices);

        if (RegQueryValueEx(hKey,
                            NOINTERACTIVESERVICES,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwNoInteractiveServices,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                return(dwNoInteractiveServices == 0);
            }
        }

        RegCloseKey(hKey);
    }

    //
    // I really hate to have this be the default, but AT does this currently.
    //

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   InitializeStartupInfo
//
//  Synopsis:   Initialize the STARTUPINFO structure passed. If the job is
//              an AT interactive job, set structure fields accordingly.
//
//  Arguments:  [pJob]        -- Job object.
//              [ptszDesktop] -- Desktop name.
//              [psi]         -- Structure to initialized.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
InitializeStartupInfo(
    CJob *        pJob,
    LPTSTR        ptszDesktop,
    STARTUPINFO * psi)
{
    //
    // NT only.
    //
    // Check if the job is to run interactively. Applicable only for AT jobs.
    //
    //     If the job is an AT job AND
    //     if the interactive flag is set AND
    //     if the NoInteractiveServices is not set in the registry THEN
    //
    // initialize the STARTUPINFO struct such that the AT job will run
    // interactively.
    //

    BOOL fInteractive = pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) &&
                        pJob->IsFlagSet(TASK_FLAG_INTERACTIVE)   &&
                        AllowInteractiveServices();
    //
    // Emulate the NT4 AT_SVC and log an error to the event log, if the
    // task is supposed to be interactive, but we can't be, due to
    // system settings.
    //
    // Note this query is NOT fInteractive.
    //

    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) &&
        pJob->IsFlagSet(TASK_FLAG_INTERACTIVE) &&
        !AllowInteractiveServices())
    {
       LPWSTR StringArray[1];
       HRESULT hr;

       //
       // EVENT_COMMAND_NOT_INTERACTIVE
       //  The %1 command is marked as an interactive command.  However, the system is
       //  configured to not allow interactive command execution.  This command may not
       //  function properly.
       //

       hr = pJob->GetCurFile(&StringArray[0]);
       if (FAILED(hr))
       {
            ERR_OUT("Failed to obtain file name for non-interactive AT job", hr);
       }
       else
       {
            if (! ReportEvent(g_hAtEventSource,                      // source handle
                         EVENTLOG_WARNING_TYPE,                 // event type
                         0,                                     // event category
                         EVENT_COMMAND_NOT_INTERACTIVE,         // event id
                         NULL,                                  // user sid
                         1,                                     // number of strings
                         0,                                     // data block length
                         (LPCWSTR *)StringArray,                // string array
                         NULL))                                 // data block
            {
                 // Not fatal, but why did we fail?
                 ERR_OUT("Failed to report the non-interactive event to the eventlog", GetLastError());
            }
            //
            // Clean up -- Theoretically, we should use IMalloc::Free here, but we are in
            // the same process, and the memory was allocated from CoTaskMemAlloc,
            // so CoTaskMemFree is the appropriate call
            //
            CoTaskMemFree(StringArray[0]);
       }
    }

    GetStartupInfo(psi);

    psi->dwFlags    |= STARTF_USESHOWWINDOW;
    psi->wShowWindow = SW_SHOWNOACTIVATE;

    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        if (fInteractive)
        {
            psi->lpDesktop = ptszDesktop;
            psi->dwFlags  |= STARTF_DESKTOPINHERIT;
        }
        else
        {
            psi->lpDesktop = WSZ_SA_DESKTOP;
            psi->dwFlags  &= ~STARTF_DESKTOPINHERIT;
        }
    }
    else
    {
        psi->lpDesktop = ptszDesktop;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   ComposeBatchParam
//
//  Synopsis:   Builds the CreateProcess command line parameter
//
//  Arguments:  [pwszPrefix]   -
//              [pwszAppPathName]  - The run target task property.
//              [pwszParameters] - The parameters task propery.
//              [ppwszCmdLine]    - The command line to return.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//-----------------------------------------------------------------------------
HRESULT
ComposeBatchParam(
    LPCTSTR pwszPrefix,
    LPCTSTR pwszAppPathName,
    LPCTSTR pwszParameters,
    LPTSTR * ppwszCmdLine)
{
    ULONG cchCmdLine;
    BOOL fBatchNameHasSpaces = HasSpaces(pwszAppPathName);

    //
    // Space for the command line is length of prefix "cmd /c " plus batch
    // file name, plus two if the batch file name will be surrounded with
    // spaces, plus length of parameters, if any, plus one for the space
    // preceding the parameters, plus one for the terminating nul.
    //

    cchCmdLine = lstrlen(pwszPrefix) + 1 +
                 lstrlen(pwszAppPathName) +
                 (fBatchNameHasSpaces ? 2 : 0) +
                 (pwszParameters ? 1 + lstrlen(pwszParameters) : 0);

    *ppwszCmdLine = new TCHAR[cchCmdLine];

    if (!*ppwszCmdLine)
    {
        schDebugOut((DEB_ERROR,
                     "RunNTJob: Can't allocate %u for cmdline\n",
                     cchCmdLine));
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszCmdLine, cchCmdLine, pwszPrefix);

    if (fBatchNameHasSpaces)
    {
        StringCchCat(*ppwszCmdLine, cchCmdLine, DQUOTE);
    }

    StringCchCat(*ppwszCmdLine, cchCmdLine, pwszAppPathName);

    if (fBatchNameHasSpaces)
    {
        StringCchCat(*ppwszCmdLine, cchCmdLine, DQUOTE);
    }

    if (pwszParameters)
    {
        StringCchCat(*ppwszCmdLine, cchCmdLine, SPACE);
        StringCchCat(*ppwszCmdLine, cchCmdLine, pwszParameters);
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   ComposeParam
//
//  Synopsis:   Builds the CreateProcess command line parameter
//
//  Arguments:  [fTargetIsExe]   - Is pwszRunTarget an exe or a document.
//              [ptszRunTarget]  - The run target task property.
//              [ptszParameters] - The parameters task propery.
//              [ptszCmdLine]    - The command line to return.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//-----------------------------------------------------------------------------
HRESULT
ComposeParam(BOOL fTargetIsExe,
             LPTSTR ptszRunTarget,
             LPTSTR ptszParameters,
             LPTSTR * pptszCmdLine)
{
    LPTSTR ptszCmdLine;

    //
    // Check for whitespace in the app name.
    //

    BOOL fAppNameHasSpaces = HasSpaces(ptszRunTarget);

    //
    // If running a document, check for spaces in the doc path name.
    //

    BOOL fParamHasSpaces = FALSE;

    if (!fTargetIsExe && HasSpaces(ptszParameters))
    {
        fParamHasSpaces = TRUE;
    }

    //
    // Figure the length, adding 1 for the space and 1 for the null,
    // plus 2 for the quotes, if needed.
    //

    DWORD cch = lstrlen(ptszRunTarget) + lstrlen(ptszParameters) + 2
                + (fAppNameHasSpaces ? 2 : 0)
                + (fParamHasSpaces ? 2 : 0);

    ptszCmdLine = new TCHAR[cch];
    if (!ptszCmdLine)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("CSchedWorker::RunWin95Job", E_OUTOFMEMORY);
        *pptszCmdLine = NULL;
        return E_OUTOFMEMORY;
    }

    if (fAppNameHasSpaces)
    {
        //
        // Enclose the app name in quotes if it contains whitespace.
        //
        StringCchCopy(ptszCmdLine, cch, DQUOTE);
        StringCchCat(ptszCmdLine, cch, ptszRunTarget);
        StringCchCat(ptszCmdLine, cch, DQUOTE);
    }
    else
    {
        StringCchCopy(ptszCmdLine, cch, ptszRunTarget);
    }

    StringCchCat(ptszCmdLine, cch, SPACE);

    if (fParamHasSpaces)
    {
        StringCchCat(ptszCmdLine, cch, DQUOTE);
    }

    StringCchCat(ptszCmdLine, cch, ptszParameters);

    if (fParamHasSpaces)
    {
        StringCchCat(ptszCmdLine, cch, DQUOTE);
    }

    *pptszCmdLine = ptszCmdLine;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   MapFindExecutableError
//
//  Synopsis:   Converts the poorly designed error codes returned by the
//              FindExecutable API to HRESULTs
//
//  Arguments:  [hRet] - Error return code from FindExecutable
//
//  Returns:    HRESULT (with FACILITY_WIN32) for the same error
//
//-----------------------------------------------------------------------------
HRESULT
MapFindExecutableError(HINSTANCE hRet)
{
    schAssert((DWORD_PTR)hRet <= 32);

    HRESULT hr;
    if (hRet == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }
    else if ((DWORD_PTR)hRet == 31)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    }
    else
    {
        hr = HRESULT_FROM_WIN32((DWORD_PTR)hRet);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   WaitForStubExe
//
//  Synopsis:   Waits for the stub exe to launch the job
//
//  Arguments:  [hProcess] - Handle to the stub exe process
//
//  Returns:    TRUE if stub exe launched job
//              FALSE if stub exe didn't launch job.  Last error is set to the
//              exit code from the stub exe.
//
//-----------------------------------------------------------------------------
BOOL
WaitForStubExe(HANDLE hProcess)
{
    BOOL fRanJob = FALSE;

    DWORD dwWait = WaitForSingleObject(hProcess, 90000);
    if (dwWait == WAIT_OBJECT_0)
    {
        DWORD dwExitCode;
        if (!GetExitCodeProcess(hProcess, &dwExitCode))
        {
            ERR_OUT("GetExitCodeProcess", GetLastError());
        }
        else if (dwExitCode == 0)
        {
            fRanJob = TRUE;
        }
        else
        {
            ERR_OUT("Stub exe run", dwExitCode);
            SetLastError(dwExitCode);
        }
    }
    else if (dwWait == WAIT_TIMEOUT)
    {
        schAssert(!"Stub exe didn't exit in 90 sec!");
        SetLastError(ERROR_TIMEOUT);
    }
    // else WAIT_FAILED - last error will be set to failure code

    return fRanJob;
}



//+----------------------------------------------------------------------------
//
//  Function:   GetUserTokenFromSession
//
//  Synopsis:   Enumerates the sessions and returns token of the session in 
//				which the given user has logged on
//
//  Arguments:  [IN lpszUsername] - user account name
//				[IN lpszDomain]   - domain name
//				[OUT phUserToken] - token to be returned
//
//  Returns:    FALSE if the given user is not found in the enumerated sessions
//				TRUE if the user is found in the the enumerated sessions array
//				
//				This function enumerates the sessions and compared the user name
//				and domainname of the session with the given username and domain
//				name. If such session is found, it checks to see if it is a console 
//				session. 
//				If it is a console session, the search is terminated and the token 
//				given by the session is returned in  phUserToken
//				Else the token from first session saved and search is continued
//				
//				At the end of the search if no console session is found then
//				the saved first session token is returned.
//
//				Else if no session found whatsoever then the function returns FALSE
//-----------------------------------------------------------------------------

BOOL GetUserTokenFromSession(
    LPTSTR lpszUsername,    // user name
    LPTSTR lpszDomain,      // domain or server
    PHANDLE phUserToken     // receive tokens handle	
)
{

    PWTS_SESSION_INFO pWTSSessionInfo = NULL;
    DWORD  WTSSessionInfoCount = 0;

    //WTS_CURRENT_SERVER_HANDLE indicates the terminal server
    //on which your application is running

    BOOL result = WTSEnumerateSessions(
        WTS_CURRENT_SERVER_HANDLE,
        0,  //Reserved; must be zero
        1,  //version of the enumeration request. Must be 1
        &pWTSSessionInfo,
        &WTSSessionInfoCount);

    if(!result)
    {
        schDebugOut((DEB_TRACE, "*** WTSEnumerateSessions failed\n"));
        return (FALSE);
    }

    schDebugOut((DEB_TRACE, "*** WTSEnumerateSessions returned %d sessions\n",WTSSessionInfoCount));

    LPTSTR pWTSDomainNameBuffer = NULL;
    LPTSTR pWTSUserNameBuffer = NULL;

    HANDLE hNewToken = INVALID_HANDLE_VALUE;
    HANDLE hFirstToken = INVALID_HANDLE_VALUE;
    HANDLE hConsoleToken = INVALID_HANDLE_VALUE;

    // Get the session id of the session attached to the console. If there is 
    // no session attached to console then this return 0xFFFFFFFF
    DWORD ConsoleSessionID = WTSGetActiveConsoleSessionId ();

    BOOL bSuccess = FALSE;
    
    //Check each session to see if the user name and the domain name matches with the
    //ones that are passed to this function
    for (DWORD i = 0; i < WTSSessionInfoCount; i++)
    {
        WTS_INFO_CLASS WTSInfoClass;
        pWTSDomainNameBuffer = NULL;
        pWTSUserNameBuffer = NULL;
        DWORD BytesReturned = 0;

        BOOL bDomainNameResult = WTSQuerySessionInformation(
                            WTS_CURRENT_SERVER_HANDLE,
                            pWTSSessionInfo[i].SessionId,
                            WTSDomainName,			//the type of information to retrieve
                            &pWTSDomainNameBuffer,				
                            &BytesReturned
                        );

        BOOL bUserNameResult = WTSQuerySessionInformation(
                            WTS_CURRENT_SERVER_HANDLE,
                            pWTSSessionInfo[i].SessionId,
                            WTSUserName,			//the type of information to retrieve
                            &pWTSUserNameBuffer,				
                            &BytesReturned
                        );
		
        if (bDomainNameResult && bUserNameResult)
        {
            
            schDebugOut((DEB_TRACE, "*** \n Comparing %s with %s and %s with %s",
                                        lpszUsername,pWTSUserNameBuffer,
                                        lpszDomain, pWTSDomainNameBuffer));

            if (_wcsicmp(lpszUsername, pWTSUserNameBuffer) == 0 &&
                _wcsicmp(lpszDomain, pWTSDomainNameBuffer) == 0)
            {
                // Call WTSQueryUserToken to retrieve a handle to the user access 
                // token for this session. Token returned by WTSQueryUserToken is
                // a primary token and can be passed to CreateProcessAsUser 
                
                BOOL fRet = WTSQueryUserToken(pWTSSessionInfo[i].SessionId, &hNewToken);

                if(fRet)
                {
                    // Check to see if it is a console session
                    
                    if(pWTSSessionInfo[i].SessionId == ConsoleSessionID)
                    {
                        schDebugOut((DEB_TRACE, "*** Console session found\n"));
                        // We have have found the user session that is attached to console
                        // No need to search the remaining So we can break from here
                        hConsoleToken = hNewToken;

                        WTSFreeMemory(pWTSUserNameBuffer);
                        WTSFreeMemory(pWTSDomainNameBuffer);

                        bSuccess = TRUE;
                        break;
                    }

                    // Else if this is the first token that matches then save it in hFirstToken
                    // and proceed to search for console session that matches with the user
                    // If such session is not found then we will use this token
                    else if (!bSuccess)
                    {
                        schDebugOut((DEB_TRACE, "*** First session found\n"));

                        hFirstToken = hNewToken;
                        bSuccess = TRUE;
                    }
					
                    else
                    {
                        if (hNewToken != INVALID_HANDLE_VALUE)
                        {
                            CloseHandle(hNewToken);
                            hNewToken = INVALID_HANDLE_VALUE;
                        }
                    }

                    // else keep seaching as we may get console session id in the remaining 
                    // list
                }
            }
        }

        // pWTSUserNameBuffer may be non-null if bUserNameResult is false
        if (pWTSUserNameBuffer)
        {
            WTSFreeMemory(pWTSUserNameBuffer);
        }

        // pWTSDomainNameBuffer may be non-null if bDomainNameResult is false
        if (pWTSDomainNameBuffer)
        {
            WTSFreeMemory(pWTSDomainNameBuffer);
        }
    }

    WTSFreeMemory(pWTSSessionInfo);

    if(bSuccess)
    {
        // We may have either one or both open tokens.
        // If we get hConsoleToken then we return hConsoleToken
        // In that case if hFirstToken is open then we close hFirstToken
        // If we dont get hConsoleToken then we return hFirstToken
        if(hConsoleToken != INVALID_HANDLE_VALUE)
        {
            if(hFirstToken != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFirstToken);
            }

            *phUserToken = hConsoleToken;

            schDebugOut((DEB_TRACE, "*** Returning TRUE with Console Session Token\n"));
        }
        else
        {
            *phUserToken = hFirstToken;

            schDebugOut((DEB_TRACE, "*** Returning TRUE with First Session Token\n"));
        }
    }

	else
    {
        schDebugOut((DEB_TRACE, "*** Returning FALSE\n"));
    }
    
    return (bSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\statsync.cxx ===
/*++

Copyright (C) 1996-2002 Microsoft Corporation

Module Name:

    SYNC.CXX

Abstract:

    Synchronization

History:

--*/

#include "..\pch\headers.hxx"
#include "statsync.hxx"

//
//
// Critical Section to be used when it's a Global or class static
//
///////////////////////////////////////////////////

BOOL CStaticCritSec::anyFailed_ = FALSE; 

CStaticCritSec::CStaticCritSec(): initialized_(false)  
{
    initialized_ = (InitializeCriticalSectionAndSpinCount(this,0))?true:false;
    if (!initialized_) anyFailed_ = TRUE;
}
 
CStaticCritSec::~CStaticCritSec()
{
    if(initialized_)
        DeleteCriticalSection(this);
}

BOOL CStaticCritSec::anyFailure()
{ 
    return anyFailed_;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\sch_wkr.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_wkr.cxx
//
//  Contents:   job scheduler service worker class impementation
//
//  Classes:    CSchedWorker
//
//  History:    15-Sep-95 EricB created
//              25-Jun-99 AnirudhS  Extensive fixes to close windows in
//                  MainServiceLoop algorithms.
//              15-Feb-01 Jbenton Bug 315821 - NULL pJob pointer being
//                  dereferenced when ActivateJob failed with OUT_OF_MEMORY.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "globals.hxx"
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include <sddl.h>

#define CONTROL_WINDOWS_KEY     TEXT("System\\CurrentControlSet\\Control\\Windows")
#define NOBOOTPOPUPS_VALUENAME  TEXT("NoPopupsOnBoot")

extern HANDLE g_WndEvent;

DWORD CalcWait(LPFILETIME pftNow, LPFILETIME pftJob);
void  ReportMissedRuns(const SYSTEMTIME * pstLastRun,
                       const SYSTEMTIME * pstNow);
DWORD WINAPI PopupThread(LPVOID lpParameter);

#if DBG
LPSTR SystemTimeString(const SYSTEMTIME& st, CHAR * szBuf, size_t cchBuf)
{
    StringCchPrintfA(szBuf, cchBuf, "%2d/%02d/%d %2d:%02d:%02d.%03d",
             st.wMonth, st.wDay, st.wYear,
             st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    return szBuf;
}

LPSTR FileTimeString(FILETIME ft, CHAR * szBuf, size_t cchBuf)
{
    SYSTEMTIME st;
    FileTimeToSystemTime(&ft, &st);
    return (SystemTimeString(st, szBuf, cchBuf));
}
#endif

LONG    g_fPopupDisplaying;  // = FALSE


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::Init
//
//  Synopsis:   Two phase constrution - do class init that could fail here.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::Init()
{
    m_pSch = new CSchedule;
    if (m_pSch == NULL)
    {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = m_pSch->Init();
    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init, m_pSch->Init", hr);
        delete m_pSch;
        return hr;
    }

    hr = m_pSch->InitAtID();
    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init, m_pSch->Init", hr);
        delete m_pSch;
        return hr;
    }

    //
    // Compose the job search string. It will be composed of the following:
    // g_TasksFolderInfo.ptszPath\*.TSZ_JOB
    //
    UINT cch = lstrlen(g_TasksFolderInfo.ptszPath) + 3 +
                    ARRAY_LEN(TSZ_JOB);
    m_ptszSearchPath = new TCHAR[cch];
    if (!m_ptszSearchPath)
    {
        ERR_OUT("CSchedWorker::Init", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    StringCchCopy(m_ptszSearchPath, cch, g_TasksFolderInfo.ptszPath);
    StringCchCat(m_ptszSearchPath, cch, TEXT("\\*.") TSZ_JOB);

    //
    // Create the service control event.
    //
    m_hServiceControlEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hServiceControlEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the on idle event.
    //
    m_hOnIdleEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hOnIdleEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the idle loss event.
    //
    m_hIdleLossEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hIdleLossEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the event used for synchronization with processor threads.
    //
    m_hMiscBlockEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hMiscBlockEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the timer that will wake the system when it's time to run
    // a job with TASK_FLAG_SYSTEM_REQUIRED.
    //
    HINSTANCE hKernel32Dll = GetModuleHandle(TEXT("KERNEL32.DLL"));
    if (hKernel32Dll == NULL)
    {
        DWORD dwErr = GetLastError();
        ERR_OUT("Load of kernel32.dll", dwErr);
        return HRESULT_FROM_WIN32(dwErr);
    }

    pfnSetThreadExecutionState = (PFNSetThreadExecutionState)
            GetProcAddress(hKernel32Dll, "SetThreadExecutionState");
    if (pfnSetThreadExecutionState == NULL)
    {
        ERR_OUT("GetProcAddress for SetThreadExecutionState", GetLastError());
    }

    m_hSystemWakeupTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (m_hSystemWakeupTimer == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateWaitableTimer", hr);
        return hr;
    }

    //
    // Save the service's working directory.
    //
    cch = GetCurrentDirectory(0, m_ptszSvcDir);
    if (cch == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedWorker::Init, GetCurrentDirectory", hr);
        return hr;
    }

    m_ptszSvcDir = new TCHAR[cch + 1];
    if (m_ptszSvcDir == NULL)
    {
        ERR_OUT("CSchedWorker::Init, service directory", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    if (GetCurrentDirectory(cch + 1, m_ptszSvcDir) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedWorker::Init, GetCurrentDirectory", hr);
        return hr;
    }

    //
    // Tell the queue of service controls which event to signal when a
    // control is in the queue.
    //
    m_ControlQueue.Init(m_hServiceControlEvent);

    //
    // Record the start up time as the directory-last-checked-time.
    //
    GetSystemTimeAsFileTime(&m_ftLastChecked);

    //
    // Also use this as the beginning of the wait list period.
    //
    FileTimeToLocalFileTime(&m_ftLastChecked, &m_ftBeginWaitList);

    //
    // Set the initial end-of-wait-list-period.
    //
    SYSTEMTIME st;
    FileTimeToSystemTime(&m_ftBeginWaitList, &st);
    schDebugOut((DEB_ITRACE, "Init: time now is %u/%u/%u %u:%02u:%02u\n",
                 st.wMonth, st.wDay, st.wYear,
                 st.wHour, st.wMinute, st.wSecond));
    SetEndOfWaitListPeriod(&st);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::BuildWaitList
//
//  Synopsis:   Examines the job objects in the scheduler folder and builds
//              a run time list.
//
//  Arguments:  [fStartup] - if true, then being called at initial service
//                           start up. If this is the case, then verify and fix
//                           job state consistency and run any jobs with
//                           startup triggers.
//              [fReportMisses] - whether to detect and report task runs that
//                           were missed (because the service was not running
//                           or the machine was asleep).  This is TRUE when
//                           called on machine wakeup and service start or
//                           continue, FALSE otherwise.
//              [fSignAtJobs] - whether to trust and sign all At jobs that
//                           an owner of Admin or LocalSystem (the pre-NT5
//                           check).  This is TRUE the first time the service
//                           runs on NT5.
//
//  Returns:    hresults
//
//  Notes:      Currently gets all runs from now until midnight. A later
//              enhancement will be to allow a different period to be
//              specified.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::BuildWaitList(
    BOOL    fStartup,
    BOOL    fReportMisses,
    BOOL    fSignAtJobs
    )
{
    TRACE(CSchedWorker, BuildWaitList);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    BOOL    fMisses = FALSE;    // Whether runs were missed

    m_WaitList.FreeList();
    m_IdleList.FreeExpiredOrRegenerated();
    m_ftFutureWakeup = MAX_FILETIME;

    fReportMisses = (fReportMisses && g_fNotifyMiss);

    //
    // The start of the wait list period was picked elsewhere.
    //
    SYSTEMTIME stBegin;
    FileTimeToSystemTime(&m_ftBeginWaitList, &stBegin);
    FILETIME   ftSTBegin;
    LocalFileTimeToFileTime(&m_ftBeginWaitList, &ftSTBegin);

    //
    // Set the end of the wait list period.
    //
    SYSTEMTIME stEnd = stBegin;
    SetEndOfWaitListPeriod(&stEnd);

    schDebugOut((DEB_TRACE, "BuildWaitList %s to %s\n",
                        CSystemTimeString(stBegin).sz(),
                        CSystemTimeString(stEnd).sz()));

    //
    // Save the time of last (starting to) scan the folder.
    //
    GetSystemTimeAsFileTime(&m_ftLastChecked);

    m_cJobs = 0;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            //
            // No job files.
            //
            schDebugOut((DEB_ITRACE, "No jobs found!\n"));
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    //
    // Read the last task run time from the registry.  If it's absent,
    // as it will be the first time the service runs, use stBegin (so no
    // misses will be reported).
    //
    SYSTEMTIME stLastRun;
    if (fReportMisses)
    {
        if (!ReadLastTaskRun(&stLastRun))
        {
            stLastRun = stBegin;
        }
    }

    CJob * pJob = NULL;

    CRunList * pStartupList = new CRunList;
    if (pStartupList == NULL)
    {
        ERR_OUT("BuildWaitList list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    do
    {
        DWORD dwSavePFlags = 0;

        //
        // Check if the service is shutting down. We check the event rather
        // than simply checking GetCurrentServiceState because this method is
        // called by the main loop which won't be able to react to the shut
        // down event while in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
                ERR_OUT("BuildWaitList: SetEvent",
                        HRESULT_FROM_WIN32(GetLastError()));
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("BuildWaitList: Service shutting down");
                //
                // The service is shutting down. Free job info objects.
                //
                delete pStartupList;
                m_WaitList.FreeList();
                return S_OK;
            }
        }

        m_cJobs++;

        //
        // Activate the job.
        // If we've been asked to sign At jobs, do a full load (because we
        // will be writing some variable-length job properties, and we don't
        // want to lose the others).  Otherwise a partial load is enough.
        //
        BOOL fTriggersLoaded = fSignAtJobs;

        hr = m_pSch->ActivateJob(fd.cFileName, &pJob, fSignAtJobs);
        if (FAILED(hr))
        {
            LogTaskError(fd.cFileName,
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                         NULL,
                         (DWORD)hr);
            ERR_OUT("BuildWaitList Activate", hr);
            hr = S_OK;
            goto CheckNext;
        }

        if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) && fSignAtJobs)
        {
            //
            // We're about to sign this At job, because it's the first time
            // the service is running and At jobs didn't have signatures
            // before NT5.  First verify that the job at least passes the
            // pre-NT5 test for authenticity.
            //
            if (g_TasksFolderInfo.FileSystemType == FILESYSTEM_NTFS &&
                !IsAdminFileOwner(pJob->GetFileName()))
            {
                //
                // Bogus job.  Leave it unsigned.
                //
                schDebugOut((DEB_ERROR,
                             "BuildWaitList: file not owned by Admin:  %ws\n",
                             pJob->GetFileName()));
                hr = S_OK;
                goto CheckNext;
            }

            //
            // Sign the job
            //
            hr = pJob->Sign();

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CheckNext;
            }

            //
            // Force the updated job to be written to disk
            //
            dwSavePFlags |= SAVEP_VARIABLE_LENGTH_DATA;
        }

        FILETIME ftSTNow;   // time just after activating job
        GetSystemTimeAsFileTime(&ftSTNow);

        if (fStartup)
        {
            //
            // Let the service controller know we're making progress.
            //
            StartupProgressing();

            //
            // Do service startup processing. First load the triggers.
            //
            hr = pJob->LoadTriggers();
            if (FAILED(hr))
            {
                LogTaskError(fd.cFileName,
                             NULL,
                             IDS_LOG_SEVERITY_WARNING,
                             IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                             NULL,
                             (DWORD)hr);
                ERR_OUT("BuildWaitList, pJob->LoadTriggers", hr);
                hr = S_OK;
                goto CheckNext;
            }

            fTriggersLoaded = TRUE;

            pJob->UpdateJobState(FALSE);

            //
            // If this job has no more runs and the delete-when-done flag is
            // set, then delete the job.
            //
            if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS) &&
                pJob->IsFlagSet(TASK_FLAG_DELETE_WHEN_DONE))
            {
                hr = pJob->Delete();
                if (FAILED(hr))
                {
                    LogTaskError(fd.cFileName,
                                 NULL,
                                 IDS_LOG_SEVERITY_WARNING,
                                 IDS_CANT_DELETE_JOB,
                                 NULL,
                                 (DWORD)hr);
                    ERR_OUT("JobPostProcessing, delete-when-done", hr);
                }
                goto CheckNextNoSave;
            }

            //
            // Make sure that the job object status is in a consistent state.
            // The state can be left inconsistent if the service is stopped
            // while jobs are running.
            //
            if (pJob->IsStatus(SCHED_S_TASK_RUNNING))
            {
                if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS))
                {
                    pJob->SetStatus(SCHED_S_TASK_NO_MORE_RUNS);
                }
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }

            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW) ||
                pJob->IsFlagSet(JOB_I_FLAG_ABORT_NOW))
            {
                pJob->ClearFlag(JOB_I_FLAG_RUN_NOW | JOB_I_FLAG_ABORT_NOW);
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }

            if (pJob->m_cRunningInstances)
            {
                pJob->m_cRunningInstances = 0;
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }
        }

        //
        // Check if job can run.
        //
        if (!pJob->IsFlagSet(TASK_FLAG_DISABLED) &&
            pJob->IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
        {
            //
            // LoadTriggers will set or clear the JOB_I_FLAG_HAS_TRIGGERS flag
            // as appropriate.
            //
            if (!fTriggersLoaded)
            {
                hr = pJob->LoadTriggers();
                if (FAILED(hr))
                {
                    LogTaskError(fd.cFileName,
                                 NULL,
                                 IDS_LOG_SEVERITY_WARNING,
                                 IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                                 NULL,
                                 (DWORD)hr);
                    ERR_OUT("BuildWaitList, pJob->LoadTriggers", hr);
                    hr = S_OK;
                    goto CheckNext;
                }
            }

            if (pJob->IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS))
            {
                //
                // Add startup-triggered runs to the startup list, if this
                // is startup
                //
                if (fStartup && !g_fUserStarted)
                {
                    hr = pJob->IfStartupJobAddToList(fd.cFileName,
                                                     pStartupList,
                                                     &m_IdleList);
                    if (FAILED(hr))
                    {
                        ERR_OUT("BuildWaitList IfStartupJobAddToList", hr);
                        goto Cleanup;
                    }
                }

                //
                // See if the job had missed runs (runs scheduled between
                // stLastRun and stBegin)
                //
                if (fReportMisses)
                {
                    CTimeRunList MissedList;
                    WORD cMissedRuns = 0;
                    hr = pJob->GetRunTimesP(&stLastRun, &stBegin, &cMissedRuns,
                                            1, &MissedList, fd.cFileName);
                    if (FAILED(hr))
                    {
                        schDebugOut((DEB_ERROR, "BuildWaitList: Get Missed RunTimes for "
                                     FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                        // BUGBUG  Log this?  Disable the job?
                        hr = S_OK;
                    }

                    if (cMissedRuns != 0)
                    {
                        fMisses = TRUE;
                        pJob->SetFlag(JOB_I_FLAG_MISSED |
                                      JOB_I_FLAG_PROPERTIES_DIRTY);

                        FILETIME ftMissed;
                        schAssert(MissedList.PeekHeadTime(&ftMissed) == S_OK);
                        schDebugOut((DEB_TRACE,
                                     FMT_TSTR " missed a run (at %s) between %s and %s\n",
                                     fd.cFileName,
                                     CFileTimeString(ftMissed).sz(),
                                     CSystemTimeString(stLastRun).sz(),
                                     CSystemTimeString(stBegin).sz()
                                     ));
                    }
                }

                //
                // Add time-triggered runs to the wait list
                //
                // If the file has a creation time between stBegin and now,
                // start its run list from that time, instead of stBegin.
                // This prevents the most common case of a task being run
                // even though it was created after its scheduled run time.
                // We can't use the task write time because that could cause
                // runs to be skipped if non-schedule changes were made to
                // the task after it was submitted.
                //
                // BUGBUG  We will still run a task if it was created at
                // 5:00:00, and modified at 8:03:20 to run at 8:03:00, and
                // we haven't yet run an 8:03:00 batch by 8:03:20.
                //
                SYSTEMTIME stJobBegin = stBegin;
                if (CompareFileTime(&ftSTBegin, &fd.ftCreationTime) < 0
                        // recently created
                    &&
                    CompareFileTime(&fd.ftCreationTime, &ftSTNow) < 0
                        // created "in the future" would mean a time change
                        // or a drag-drop occurred, so forget this adjustment
                    )
                {
                    FILETIME ftJobBegin;
                    FileTimeToLocalFileTime(&fd.ftCreationTime, &ftJobBegin);
                    FileTimeToSystemTime(&ftJobBegin, &stJobBegin);
                    schDebugOut((DEB_TRACE, "Using %s for " FMT_TSTR "\n",
                                 CSystemTimeString(stJobBegin).sz(),
                                 fd.cFileName));
                }

                WORD cRuns = 0;
                hr = pJob->GetRunTimesP(&stJobBegin, &stEnd, &cRuns,
                                        TASK_MAX_RUN_TIMES, &m_WaitList,
                                        fd.cFileName);
                if (FAILED(hr))
                {
                    schDebugOut((DEB_ERROR, "BuildWaitList: GetRunTimesP for "
                                 FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                    // BUGBUG  Log this?  Disable the job?
                    hr = S_OK;
                }

                if (cRuns == 0)
                {
                    schDebugOut((DEB_TRACE,
                                 "There are no runs scheduled for " FMT_TSTR ".\n",
                                 fd.cFileName));
                }

                //
                // If the system must be woken to run this task, also
                // compute its first run time AFTER the wait list period.
                // Remember the first of all such run times.
                //
                if (pJob->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                {
                    CTimeRunList RunList;
                    WORD cRuns = 0;
                    hr = pJob->GetRunTimesP(&stEnd, NULL, &cRuns, 1,
                                            &RunList, NULL);

                    if (hr == S_OK && cRuns != 0)
                    {
                        FILETIME ft;
                        RunList.PeekHeadTime(&ft);

                        m_ftFutureWakeup = minFileTime(m_ftFutureWakeup, ft);
                    }
                }

                //
                // Add idle-triggered runs to the idle list
                //
                hr = pJob->IfIdleJobAddToList(fd.cFileName, &m_IdleList);

                if (FAILED(hr))
                {
                    schDebugOut((DEB_ERROR, "BuildWaitList: IfIdleJobAddToList for "
                                 FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                    // BUGBUG  Log this?  Disable the job?
                    hr = S_OK;
                }
            }
        }

CheckNext:
        if (pJob != NULL &&
			(pJob->IsFlagSet(JOB_I_FLAG_PROPERTIES_DIRTY) ||
            !pJob->IsFlagSet(JOB_I_FLAG_NO_RUN_PROP_CHANGE)))
        {
            //
            // Mark this job as clean
            //
            pJob->SetFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);

            //
            // Write out the cleaned up state.  Be sure not to clear the
            // AT bit on an AT job just because we're updating its run
            // state.
            //
            dwSavePFlags |= (SAVEP_PRESERVE_NET_SCHEDULE |
                                SAVEP_RUNNING_INSTANCE_COUNT);

            hr = pJob->SaveWithRetry(NULL,
                                     FALSE,
                                     dwSavePFlags);

            if (FAILED(hr))
            {
                ERR_OUT("BuildWaitList, pJob->Save", hr);
                goto Cleanup;
            }
        }

CheckNextNoSave:
        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                ERR_OUT("CSchedWorker::BuildWaitList, FindNextFile", dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
        }
    }
    while (SUCCEEDED(hr));

Cleanup:
    if (pJob)
    {
        pJob->Release();
    }

    FindClose(hFind);

    if (FAILED(hr))
    {
        m_WaitList.FreeList();
        m_IdleList.FreeList();
        delete pStartupList;
        return hr;
    }

    //
    // Report missed runs
    //
    if (fMisses)
    {
        ReportMissedRuns(&stLastRun, &stBegin);
    }

    if (fStartup)
    {
        //
        // If this is the first time in BuildWaitList, wait until the other
        // thread has created the window and initialized idle detection.
        //
        // This code is executed by the main thread of the service,
        // which is the state machine thread, not the window thread.
        // So it must wait for the window thread to initialize.
        //
        // Currently waiting for 15 minutes. If the window has not been
        // created by then, we are in trouble.
        //
        #define WINDOW_WAIT_TIMEOUT  (15 * 60 * 1000)

        if (WaitForSingleObject(g_WndEvent, WINDOW_WAIT_TIMEOUT)
            == WAIT_TIMEOUT)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_WINDOW_HANDLE);
            ERR_OUT("Waiting for window creation", hr);
            delete pStartupList;
            return hr;
        }
    }

    //
    // If there are any idle-dependent tasks, set the initial idle wait time.
    //
    // (Possible optimization: It may be safe to get rid of this crit sec)
    EnterCriticalSection(&m_SvcCriticalSection);

    SetNextIdleNotification(m_IdleList.GetFirstWait());

    LeaveCriticalSection(&m_SvcCriticalSection);


    if (!pStartupList->GetFirstJob()->IsNull())
    {
        //
        // Run all jobs with startup triggers.
        //
        schDebugOut((DEB_ITRACE, "Running startup jobs...\n"));
        hr = RunJobs(pStartupList);  // RunJobs *should* handle deleting pStartupList, even in failure cases
        if (FAILED(hr))
        {
            ERR_OUT("Running startup jobs", hr);
            return hr;
        }
    }
    else
    {
        delete pStartupList;
    }

    return (hr == S_FALSE) ? S_OK : hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::GetNextListTime
//
//  Synopsis:   Returns the time at which the next job needs to run or
//              the end of the current wait list period.
//
//  Arguments:  None.
//
//  Returns:    Wait time in milliseconds.
//
//-----------------------------------------------------------------------------
FILETIME
CSchedWorker::GetNextListTime()
{
    //TRACE(CSchedWorker, GetNextListTime);

    FILETIME ftJob;
    if (m_WaitList.PeekHeadTime(&ftJob) == S_FALSE)
    {
        //
        // No more jobs in list, return the end of the wait list period
        // instead.
        //
        SystemTimeToFileTime(&m_stEndOfWaitListPeriod, &ftJob);
    }

    return ftJob;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::GetNextRunWait
//
//  Synopsis:   Returns the wait time until the next job needs to run or until
//              the end of the current wait list period.
//
//  Arguments:  None.
//
//  Returns:    Wait time in milliseconds.
//
//-----------------------------------------------------------------------------
DWORD
CSchedWorker::GetNextRunWait()
{
    //TRACE(CSchedWorker, GetNextRunWait);

    FILETIME ftJob = GetNextListTime();

    FILETIME ftNow = GetLocalTimeAsFileTime();

    return (CalcWait(&ftNow, &ftJob));
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::NextWakeupTime
//
//  Synopsis:   Finds the next time at which the machine must be awake.
//
//  Arguments:  [ftNow] - the current time.
//
//  Returns:    The next time at which the machine must be awake.
//
//  Notes:      Finds the first run of a SYSTEM_REQUIRED job that is at least
//              5 seconds into the future, and returns its time.
//              If there's no such run, returns MAX_FILETIME.
//-----------------------------------------------------------------------------
FILETIME
CSchedWorker::NextWakeupTime(FILETIME ftNow)
{
    FILETIME ftWakeup = FTfrom64(FTto64(ftNow) + SCHED_WAKEUP_CALC_MARGIN);

    for (CRun * pRun = m_WaitList.GetFirstJob();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED) &&
            CompareFileTime(pRun->GetTime(), &ftWakeup) > 0 &&
            !(g_fOnBattery && pRun->IsFlagSet(TASK_FLAG_DONT_START_IF_ON_BATTERIES)))
        {
            return (* (pRun->GetTime()));
        }
    }

    //
    // No suitable run time in the list.  Use m_ftFutureWakeup, unless
    // it's MAX_FILETIME.
    //
    ftWakeup = m_ftFutureWakeup;
    if (CompareFileTime(&ftWakeup, &MAX_FILETIME) < 0)
    {
        if (CompareFileTime(&ftWakeup, &ftNow) < 0)
        {
            //
            // The "future wakeup time" is in the past.
            // This can happen if the time is changed and the service hasn't
            // received the WM_TIMECHANGE message yet.  This check avoids an
            // infinite loop of WAKEUP_TIME_EVENT and NextWakeupTime().
            // It could also happen if, e.g., the future wakeup time was
            // 12:01 am and we passed that time and got here before rebuilding
            // the wait list.
            //
            schDebugOut((DEB_ERROR, "***** WARNING: Wakeup time in past!  "
                "Machine time changed without receiving WM_TIMECHANGE. *****\n"));
            ftWakeup = MAX_FILETIME;

            //
            // When the WM_TIMECHANGE is received, we'll rebuild the wait
            // list and recalculate m_ftFutureWakeup.
            // If the WM_TIMECHANGE is never received, the wakeup time won't
            // be set and the machine could fail to wakeup.  (e.g. on NT 4.0
            // the "time" command changes the time without sending the
            // message.)  Send ourselves the message to be sure.
            //
            schDebugOut((DEB_TRACE, "Sending ourselves a WM_TIMECHANGE message\n"));
            PostMessage(g_hwndSchedSvc, WM_TIMECHANGE, 0, 0);
        }
    }
    return ftWakeup;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SetNextWakeupTime
//
//  Synopsis:   Sets the wakeup timer to the next time at which the machine
//              must be awake.
//
//  Arguments:  None.
//
//  Returns:    The next time at which the machine must be awake.
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::SetNextWakeupTime()
{
#if DBG
    CHAR szDbgTime[40], szDbgTime2[40];
#endif

    //
    // Remember the time that we set the timer for.  It is used on waking
    // to make sure we don't miss any runs.
    //
    m_ftLastWakeupSet = NextWakeupTime(GetLocalTimeAsFileTime());

    if (m_hSystemWakeupTimer != NULL)
    {
        if (CompareFileTime(&m_ftLastWakeupSet, &MAX_FILETIME) < 0)
        {
            schDebugOut((DEB_TRACE, "SetNextWakeupTime: now %s, setting to %s\n",
                             FileTimeString(GetLocalTimeAsFileTime(),szDbgTime2, 40),
                         FileTimeString(m_ftLastWakeupSet, szDbgTime, 40)));
        
            // Convert to UTC
            FILETIME ft;
            LocalFileTimeToFileTime(&m_ftLastWakeupSet, &ft);
            LARGE_INTEGER li = { ft.dwLowDateTime, ft.dwHighDateTime };
            if (! SetWaitableTimer(
                                   m_hSystemWakeupTimer,
                                   &li,
                                   0,       // not periodic
                                   NULL,
                                   NULL,
                                   TRUE))   // wake up system when signaled
            {
                ERR_OUT("SetNextWakeupTime SetWaitableTimer", HRESULT_FROM_WIN32(GetLastError()));
            }
        }
        else
        {
            CancelWakeup();
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CancelWakeup
//
//  Synopsis:   Cancels the wakeup timer.  (Usually done when going into a
//              PAUSED state.  Also done if there are no more jobs with
//              TASK_FLAG_SYSTEM_REQUIRED.)
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::CancelWakeup()
{
    schDebugOut((DEB_TRACE, "Canceling wakeup timer\n"));

    if (m_hSystemWakeupTimer)
    {
        if (!CancelWaitableTimer(m_hSystemWakeupTimer))
        {
            ERR_OUT("CancelWaitableTimer", GetLastError());
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SignalWakeupTimer
//
//  Synopsis:   Signals the wakeup timer.
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::SignalWakeupTimer()
{
    schDebugOut((DEB_TRACE, "Signaling wakeup timer\n"));

    if (m_hSystemWakeupTimer != NULL)
    {
        // Signal the timer 1 time unit in the future (i.e. now)
        LARGE_INTEGER li = { 0xFFFFFFFF, 0xFFFFFFFF };
        if (! SetWaitableTimer(
                               m_hSystemWakeupTimer,
                               &li,
                               0,       // not periodic
                               NULL,
                               NULL,
                               TRUE))   // wake up system when signaled
        {
            ERR_OUT("SignalWakeupTimer SetWaitableTimer", HRESULT_FROM_WIN32(GetLastError()));
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CalcWait
//
//  Synopsis:   return the time difference between the FILETIME params
//
//  Arguments:  [pftNow]
//              [pftThen]
//
//  Returns:    time difference in milliseconds
//              0 if pftThen was before pftNow
//
//-----------------------------------------------------------------------------
DWORD
CalcWait(LPFILETIME pftNow, LPFILETIME pftThen)
{
    if (CompareFileTime(pftNow, pftThen) >= 0)
    {
        //
        // Job run time is in the past.
        //
        return 0;
    }

    //
    // subtract now-time from job-time to get the wait in 100-nano-seconds unit
    //
    ULARGE_INTEGER uliNow, uliJob;
    uliNow.LowPart  = pftNow->dwLowDateTime;
    uliNow.HighPart = pftNow->dwHighDateTime;
    uliJob.LowPart  = pftThen->dwLowDateTime;
    uliJob.HighPart = pftThen->dwHighDateTime;

    __int64 n64Wait = uliJob.QuadPart - uliNow.QuadPart;

    //
    // convert to milliseconds
    //
    DWORD dwWait = (DWORD)(n64Wait / FILETIMES_PER_MILLISECOND);

#if DBG == 1
    SYSTEMTIME stNow, stRun;
    FileTimeToSystemTime(pftNow, &stNow);
    FileTimeToSystemTime(pftThen, &stRun);
    schDebugOut((DEB_TRACE, "Run time is %u:%02u\n",
                 stRun.wHour, stRun.wMinute));
    DWORD dwSeconds = dwWait / 1000;
    schDebugOut((DEB_TRACE, "*** Wait time to next run is %u:%02u:%02u (h:m:s)\n",
                 dwSeconds / 3600, dwSeconds / 60 % 60, dwSeconds % 60));
#endif

    return dwWait;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunNextJobs
//
//  Synopsis:   Run the jobs at the top of the list that have the same run
//              time.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunNextJobs(void)
{
    TRACE(CSchedWorker, RunNextJobs);

    FILETIME ftCurJob;
    if (m_WaitList.PeekHeadTime(&ftCurJob) != S_OK)
    {
        return S_FALSE; // list is empty
    }

    //
    // Set the beginning of any wait list we build in future to one second
    // past the scheduled run time of the last scheduled jobs we ran.
    //
    m_ftBeginWaitList = FTfrom64(FTto64(ftCurJob) + FILETIMES_PER_SECOND);

    CRunList * pJobList = new CRunList;
    if (pJobList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunNextJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Collect all jobs with the same start time as the first job.
    //

    FILETIME ftNextJob;
    BOOL fIdleWaitChanged = FALSE;
    while (m_WaitList.PeekHeadTime(&ftNextJob) == S_OK &&
           CompareFileTime(&ftCurJob, &ftNextJob) == 0)
    {
        CRun * pRun = m_WaitList.Pop();
        schAssert(pRun);

        if ((pRun->GetFlags() & TASK_FLAG_START_ONLY_IF_IDLE) &&
            pRun->GetWait() > 0)
        {
            //
            // The job has to wait for an idle period before running, so
            // move it to the idle wait list.
            //
            schDebugOut((DEB_IDLE, "Time to run " FMT_TSTR ", but it needs a "
                         "%d-minute idle period - moving to idle list\n",
                         pRun->GetName(), pRun->GetWait()));
            m_IdleList.AddSortedByIdleWait(pRun);
            fIdleWaitChanged = TRUE;

            // Optimization:  If idle detection is disabled, we will never get an
            // idle notification, so the run will stay in the idle list until
            // its deadline passes.  This could cause a big accumulation of
            // runs in the idle list.  It would be more space-efficient to just discard all
            // runs that are added to the idle list, or never generate runs
            // for tasks with TASK_FLAG_START_ONLY_IF_IDLE (and log one error
            // about them).
        }
        else
        {
            //
            // Move it to the list of jobs that we are about to run.
            //
            schDebugOut((DEB_IDLE, "Time to run " FMT_TSTR ", and it needs "
                         "no idle period\n", pRun->GetName()));
            pJobList->Add(pRun);
        }
    }

    if (fIdleWaitChanged)
    {
        SetNextIdleNotification(m_IdleList.GetFirstWait());
    }

    if (pJobList->GetFirstJob()->IsNull())
    {
        // RunJobs won't accept an empty list
        delete pJobList;
        return S_OK;
    }
    else
    {
        schDebugOut((DEB_TRACE, "RunNextJobs: Running %s jobs\n",
                     CFileTimeString(ftCurJob).sz()));

        HRESULT hr = RunJobs(pJobList);  // RunJobs *should* handle deleting pJobList, even in failure cases

        schDebugOut((DEB_TRACE, "RunNextJobs: Done running %s jobs\n",
                     CFileTimeString(ftCurJob).sz()));

        if (SUCCEEDED(hr))
        {
            //
            // Save the last scheduled run time at which we ran jobs
            //
            ftCurJob = FTfrom64(FTto64(ftCurJob) + FILETIMES_PER_SECOND);
            SYSTEMTIME stCurJob;
            FileTimeToSystemTime(&ftCurJob, &stCurJob);
            WriteLastTaskRun(&stCurJob);
        }

        return hr;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunLogonJobs
//
//  Synopsis:   Run all jobs with a Logon trigger.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunLogonJobs(void)
{
    TRACE(CSchedWorker, RunLogonJobs);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            //
            // No job files.
            //
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    CJob * pJob = NULL;
    CRunList * pRunLogonList = new CRunList;
    if (pRunLogonList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunLogonJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    do
    {
        hr = m_pSch->ActivateJob(fd.cFileName, &pJob, FALSE);
        if (FAILED(hr))
        {
            LogTaskError(fd.cFileName,
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                         NULL,
                         (DWORD)hr);
            ERR_OUT("RunLogonJobs Activate", hr);
            if (pJob)
            {
                pJob->Release();
            }
            FindClose(hFind);
            delete pRunLogonList;
            return hr;
        }

        //
        // Check if job can run.
        // TODO: similar checks for account flags.
        //
        if (!pJob->IsFlagSet(TASK_FLAG_DISABLED) &&
            pJob->IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
        {
            //
            // LoadTriggers will set or clear the JOB_I_FLAG_HAS_TRIGGERS flag
            // as appropriate.
            //
            hr = pJob->LoadTriggers();
            if (FAILED(hr))
            {
                LogTaskError(fd.cFileName,
                             NULL,
                             IDS_LOG_SEVERITY_WARNING,
                             IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                             NULL,
                             (DWORD)hr);
                ERR_OUT("RunLogonJobs, pJob->LoadTriggers", hr);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return hr;
            }

            hr = pJob->IfLogonJobAddToList(fd.cFileName, pRunLogonList,
                                           &m_IdleList);
            if (FAILED(hr))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
                ERR_OUT("RunLogonJobs IfLogonJobAddToList", hr);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return hr;
            }
        }

        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                LogServiceError(IDS_NON_FATAL_ERROR, dwRet);
                ERR_OUT("RunLogonJobs, FindNextFile", dwRet);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return HRESULT_FROM_WIN32(dwRet);
            }
        }
    }
    while (SUCCEEDED(hr));

    pJob->Release();

    FindClose(hFind);

    //
    // If any jobs with a TASK_EVENT_TRIGGER_AT_LOGON trigger were found, then
    // run them now.
    //
    if (!pRunLogonList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunLogonList);  // RunJobs *should* handle deleting pRunLogonList, even in failure cases

        if (FAILED(hr))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("Running idle jobs", hr);
        }
    }
    else
    {
        delete pRunLogonList;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunIdleJobs
//
//  Synopsis:   Run all jobs with an OnIdle trigger.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunIdleJobs(void)
{
    TRACE(CSchedWorker, RunIdleJobs);
    HRESULT hr = S_OK;
    CRun *pRun, *pNext;

    //
    // Move pending idle runs, if any, into the idle list. (See SubmitIdleRun.)
    //
    if (! m_PendingList.IsEmpty())
    {
        EnterCriticalSection(&m_PendingListCritSec);
        for (pRun = m_PendingList.GetFirstJob();
             !pRun->IsNull();
             pRun = pNext)
        {
            pNext = pRun->Next();

            schDebugOut((DEB_IDLE, "Moving " FMT_TSTR " from pending to idle list\n",
                         pRun->GetName()));
            pRun->UnLink();
            m_IdleList.AddSortedByIdleWait(pRun);
        }
        LeaveCriticalSection(&m_PendingListCritSec);
    }


    DWORD wCumulativeIdleTime = GetTimeIdle();

    CRunList * pRunIdleList = new CRunList;
    if (pRunIdleList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunIdleJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Use the critical section to protect the idle struct assignments since
    // assignments can be made asynchronously from two different threads. This
    // is called on the main event-loop/state-machine thread.
    //
    EnterCriticalSection(&m_SvcCriticalSection);

    //
    // Run all unexpired tasks whose idle wait is less than or equal
    // to the current cumulative idle time.  But don't start a task
    // more than once in any period of idleness.
    //

    FILETIME ftNow;
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    for (pRun = m_IdleList.GetFirstJob();
         !pRun->IsNull() && pRun->GetWait() <= wCumulativeIdleTime;
         pRun = pNext)
    {
        pNext = pRun->Next();

        if (pRun->m_fStarted)
        {
            continue;
        }

        if (CompareFileTime(pRun->GetDeadline(), &ftNow) < 0)
        {
            //
            // The run has missed its deadline - delete it.
            // (This is also done when rebuilding the wait list.)
            //
            schDebugOut((DEB_IDLE, "Run of " FMT_TSTR " has missed its deadline - deleting\n",
                         pRun->GetName()));
            //
            // Log the reason for not running.
            //
            LogTaskError(pRun->GetName(),
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_NOT_IDLE,
                         &stNow);

            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE, "CSchedWorker::RunIdleJobs 1");
            }

            delete pRun;
            continue;
        }

        if (pRun->IsIdleTriggered())
        {
            //
            // Run it, and keep it in the idle list
            //
            schDebugOut((DEB_IDLE, "COPYING idle-triggered run of " FMT_TSTR " to run list\n",
                         pRun->GetName()));
            hr = pRunIdleList->AddCopy(pRun);
            if (FAILED(hr))
            {
                LogServiceError(IDS_NON_FATAL_ERROR,
                                ERROR_OUTOFMEMORY,
                                IDS_HELP_HINT_CLOSE_APPS);
                ERR_OUT("RunIdleJobs CRun allocation", E_OUTOFMEMORY);
                LeaveCriticalSection(&m_SvcCriticalSection);
                delete pRunIdleList;
                return E_OUTOFMEMORY;
            }
            pRun->m_fStarted = TRUE;
        }
        else
        {
            //
            // Run it, and remove it from the idle list
            //
            schDebugOut((DEB_IDLE, "MOVING run of " FMT_TSTR " to run list\n",
                         pRun->GetName()));
            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE, "CSchedWorker::RunIdleJobs 2");
            }

            pRunIdleList->Add(pRun);
        }
    }

    //
    // Set the next idle wait time.
    //
    WORD wIdleWait = m_IdleList.GetFirstWait();

    LeaveCriticalSection(&m_SvcCriticalSection);

    //
    // If more idle-trigger tasks to run, then set the wait time for
    // their notification.
    //
    SetNextIdleNotification(wIdleWait);

    //
    // Run any tasks with a matching idle wait time.
    //
    if (!pRunIdleList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunIdleList);  // RunJobs *should* handle deleting pRunIdleList, even in failure cases

        if (FAILED(hr))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("Running idle jobs", hr);
        }
    }
    else
    {
        delete pRunIdleList;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SubmitIdleRun
//
//  Synopsis:   Submits a CRun for insertion in the idle list.
//
//  Notes:      This method is called by job processor threads for jobs with
//              TASK_FLAG_RESTART_ON_IDLE_RESUME set.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::SubmitIdleRun(CRun * pRun)
{
    //
    // Insert the run in the pending list.
    // We don't insert directly into the idle list because we want to avoid
    // having a critical section to guard the idle list.
    //
    schAssert(pRun->GetWait() != 0);
    EnterCriticalSection(&m_PendingListCritSec);
    schDebugOut((DEB_IDLE, "Submitting " FMT_TSTR " to pending idle list\n",
                 pRun->GetName()));
    m_PendingList.Add(pRun);
    LeaveCriticalSection(&m_PendingListCritSec);

    //
    // Wake up the main thread, which will move the run into the idle list
    // and register for idle notification if necessary.
    //
    SetEvent(m_hOnIdleEvent);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CControlQueue methods
//
//  Synopsis:   Ensure that controls sent to the service are processed in the
//              order received
//
//-----------------------------------------------------------------------------
CSchedWorker::CControlQueue::~CControlQueue()
{
    DeleteCriticalSection(&_Lock);

    while (!IsListEmpty(&_ListHead))
    {
        QueueEntry * pEntry =
            CONTAINING_RECORD(_ListHead.Flink, QueueEntry, Links);
        RemoveEntryList(&pEntry->Links);
        delete pEntry;
    }
}

void
CSchedWorker::CControlQueue::AddEntry(DWORD dwControl)
{
    QueueEntry * pNew = new QueueEntry;
    if (pNew == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
        ERR_OUT("new QueueEntry", GetLastError());
        return;
    }

    pNew->dwControl = dwControl;

    EnterCriticalSection(&_Lock);

    InsertTailList(&_ListHead, &pNew->Links);

    if (!SetEvent(_Event))
    {
        LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
        ERR_OUT("CControlQueue::AddEntry: SetEvent", GetLastError());
    }

    LeaveCriticalSection(&_Lock);
}

DWORD
CSchedWorker::CControlQueue::GetEntry()
{
    DWORD   dwControl;

    EnterCriticalSection(&_Lock);

    if (IsListEmpty(&_ListHead))
    {
        dwControl = 0;
    }
    else
    {
        QueueEntry * pEntry =
            CONTAINING_RECORD(_ListHead.Flink, QueueEntry, Links);
        dwControl = pEntry->dwControl;
        RemoveEntryList(&pEntry->Links);
        delete pEntry;

        //
        // If there are still controls in the queue, make sure we get
        // signaled again.
        //
        if (!IsListEmpty(&_ListHead))
        {
            if (!SetEvent(_Event))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
                ERR_OUT("CControlQueue::GetEntry: SetEvent", GetLastError());
            }
        }
    }

    LeaveCriticalSection(&_Lock);

    return dwControl;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::OnIdleEvent
//
//  Synopsis:   Called when the machine's idle state changes.
//
//  Arguments:  [fIdle] - set to true if receiving an idle time notification,
//                        false if leaving the idle state.
//
//  Returns:    S_OK unless there is a SetEvent error.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::OnIdleEvent(BOOL fIdle)
{
    TRACE(CSchedWorker, OnIdleEvent);
    HRESULT hr = S_OK;

    if (fIdle)
    {
        //
        // Notify the main service loop that the machine has entered the idle
        // state.
        //
        schDebugOut((DEB_IDLE, "Setting idle event\n"));
        if (!SetEvent(m_hOnIdleEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("OnIdleChange: SetEvent", hr);
        }
    }

    if (!fIdle)
    {
        //
        // Notify the main service loop that idle has been lost.
        //
        schDebugOut((DEB_IDLE, "Setting idle loss event\n"));
        if (!SetEvent(m_hIdleLossEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("OnIdleChange: SetEvent(IdleLoss)", hr);
        }

        //
        //
        // Notify the job processor to kill any jobs with the
        // TASK_FLAG_KILL_ON_IDLE_END flag set.
        //
        CJobProcessor * pjp;
        for (pjp = gpJobProcessorMgr->GetFirstProcessor(); pjp != NULL; )
        {
            pjp->KillIfFlagSet(TASK_FLAG_KILL_ON_IDLE_END);
            CJobProcessor * pjpNext = pjp->Next();
            pjp->Release();
            pjp = pjpNext;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CSchedWorker
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CSchedWorker::CSchedWorker(void) :
    m_pSch(NULL),
    m_hChangeNotify(INVALID_HANDLE_VALUE),
    m_hServiceControlEvent(NULL),
    m_hOnIdleEvent(NULL),
    m_hIdleLossEvent(NULL),
    m_hSystemWakeupTimer(NULL),
    m_hMiscBlockEvent(NULL),
    m_ptszSearchPath(NULL),
    m_ptszSvcDir(NULL),
    m_cJobs(0)
{
    TRACE(CSchedWorker, CSchedWorker);
    InitializeCriticalSection(&m_SvcCriticalSection);
    InitializeCriticalSection(&m_PendingListCritSec);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::~CSchedWorker
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CSchedWorker::~CSchedWorker(void)
{
    TRACE(CSchedWorker, ~CSchedWorker);
    //
    // Free resources and close handles.
    //
    if (m_pSch != NULL)
    {
        m_pSch->Release();
    }

    if (m_hChangeNotify != INVALID_HANDLE_VALUE)
    {
        FindCloseChangeNotification(m_hChangeNotify);
        m_hChangeNotify = INVALID_HANDLE_VALUE;
    }

    if (m_hServiceControlEvent != NULL)
    {
        CloseHandle(m_hServiceControlEvent);
        m_hServiceControlEvent = NULL;
    }

    if (m_hOnIdleEvent != NULL)
    {
        CloseHandle(m_hOnIdleEvent);
        m_hOnIdleEvent = NULL;
    }

    if (m_hIdleLossEvent != NULL)
    {
        CloseHandle(m_hIdleLossEvent);
        m_hIdleLossEvent = NULL;
    }

    if (m_hSystemWakeupTimer != NULL)
    {
        CloseHandle(m_hSystemWakeupTimer);
        m_hSystemWakeupTimer = NULL;
    }

    if (m_hMiscBlockEvent != NULL)
    {
        CloseHandle(m_hMiscBlockEvent);
        m_hMiscBlockEvent = NULL;
    }

    DeleteCriticalSection(&m_PendingListCritSec);
    DeleteCriticalSection(&m_SvcCriticalSection);

    if (m_ptszSearchPath)
    {
        delete [] m_ptszSearchPath;
    }

    if (m_ptszSvcDir != NULL)
    {
        delete [] m_ptszSvcDir;
    }

    m_WaitList.FreeList();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SetEndOfWaitListPeriod
//
//  Synopsis:   Advance the passed in time to the end of the current run
//              period.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::SetEndOfWaitListPeriod(LPSYSTEMTIME pstEnd)
{
    //
    // Set pstEnd to a few seconds after midnight so that midnight jobs are
    // included. Midnight is 0:0:0 of the next day.
    //
    pstEnd->wHour = pstEnd->wMinute = 0;
    pstEnd->wSecond = 10;

    IncrementDay(pstEnd);

    //
    // Save it for use in GetNextRunWait.
    //
    m_stEndOfWaitListPeriod = *pstEnd;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::ActivateWithRetry
//
//  Synopsis:   Load the job object from disk with failure retry.
//
//  Arguments:  [ptszName] - name of the job to activate.
//              [pJob]     - Job object to activate.
//              [fFullActivate] - load the entire object?
//
//----------------------------------------------------------------------------
HRESULT
CSchedWorker::ActivateWithRetry(LPTSTR ptszName, CJob ** ppJob,
                                BOOL fFullActivate)
{
    HRESULT hr;

    //
    // Load the job object. If there are sharing violations, retry two times.
    //
    for (int i = 0; i < 3; i++)
    {
        hr = m_pSch->ActivateJob(ptszName, ppJob, fFullActivate);
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }
        if (hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            //
            // If we have a failure other than sharing violation, we will
            // retry anyway after reporting the error.
            //
            ERR_OUT("ActivateWithRetry, Loading job object", hr);
        }

        //
        // Wait 300 milliseconds before trying again.
        //
        Sleep(300);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureTasksFolderSecurity
//
//  Synopsis:   at this point, we assume the task folder exists
//
//  Arguments:  voidness
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT EnsureTasksFolderSecurity(void)
{
    HRESULT hr = S_OK;

    PSECURITY_DESCRIPTOR pSD = NULL;
    WCHAR* pwszSDDL = NULL;

    OSVERSIONINFOEX verInfo;
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFOW)&verInfo))
        return E_FAIL;

    if (verInfo.wProductType == VER_NT_WORKSTATION)
        pwszSDDL = 
            L"D:P(A;OICIIO;FA;;;CO)(A;;0x1200ab;;;AU)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)"                
            L"S:(AU;SAFAOICI;FWDCSDWDWO;;;WD)(AU;SAFAOICI;FWDCSDWDWO;;;AN)";
    else
        pwszSDDL = 
            L"D:P(A;OICIIO;FA;;;CO)(A;;0x1200ab;;;BO)(A;;0x1200ab;;;SO)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)"
            L"S:(AU;SAFAOICI;FWDCSDWDWO;;;WD)(AU;SAFAOICI;FWDCSDWDWO;;;AN)";        
    //
    // generate SD to be used for tasks folder
    //
    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(pwszSDDL, SDDL_REVISION_1, &pSD, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        return hr;
    }


    if (SUCCEEDED(hr))
    {  
        if (!SetFileSecurity(g_TasksFolderInfo.ptszPath, DACL_SECURITY_INFORMATION, pSD))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (pSD)
        LocalFree(pSD);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::InitialDirScan
//
//  Synopsis:   Do the startup BuildWaitList and create the change events.
//
//----------------------------------------------------------------------------
HRESULT
CSchedWorker::InitialDirScan(void)
{
    HRESULT hr;
    DWORD   dwFirstBoot = 0;
    DWORD   dwType;
    DWORD   cb = sizeof(dwFirstBoot);
    HKEY    hSchedKey = NULL;
    LONG    lErr;

    //
    // Find out if this is the first boot by checking the FirstBoot
    // value under the schedule agent key
    //
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        SCH_AGENT_KEY,
                        0,
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &hSchedKey);

    if (lErr == ERROR_SUCCESS)
    {
        //
        // Get the first boot value
        //
        lErr = RegQueryValueEx(hSchedKey,
                               SCH_FIRSTBOOT_VALUE,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwFirstBoot,
                               &cb);

        if (lErr == ERROR_SUCCESS && dwFirstBoot != 0)
        {
            schDebugOut((DEB_TRACE, "First boot -- will sign At jobs\n"));
        }
    }

    // ensure task folder security is set properly upon first bootup
    if (dwFirstBoot)
    {
        hr = EnsureTasksFolderSecurity();

        if (FAILED(hr))
        {
            LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
            ERR_OUT("InitialDirScan, EnsureTasksFolderSecurity", hr);
            RegCloseKey(hSchedKey);
            return hr;
        }
    }

    //
    // Do the initial job folder read -- a non-zero dwValue means
    // this is the first boot of the Task Scheduler on NT5.
    //
    hr = BuildWaitList(TRUE, TRUE, dwFirstBoot);
    if (FAILED(hr))
    {
        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
        ERR_OUT("InitialDirScan, BuildWaitList", hr);
        RegCloseKey(hSchedKey);
        return hr;
    }

    if (hSchedKey != NULL)
    {
        //
        // No more need for this reg value
        //
        RegDeleteValue(hSchedKey, SCH_FIRSTBOOT_VALUE);

        RegCloseKey(hSchedKey);
    }

    //
    // Set up the folder change notification.
    //
    // If a job is created, deleted, renamed, or modified then
    // m_hChangeNotify will be triggered.
    //
    // This is done after the initial call to BuildWaitList since there is no
    // reason to field change notifications until the main loop is entered.
    //
    m_hChangeNotify = FindFirstChangeNotification(
                                    g_TasksFolderInfo.ptszPath,
                                    FALSE,  // no subdirs
                                    FILE_NOTIFY_CHANGE_FILE_NAME |
                                        FILE_NOTIFY_CHANGE_LAST_WRITE);

    if (m_hChangeNotify == INVALID_HANDLE_VALUE)
    {
        ULONG ulLastError = GetLastError();

        LogServiceError(IDS_FATAL_ERROR, ulLastError, 0);
        ERR_OUT("InitialDirScan, FindFirstChangeNotification", ulLastError);
        return HRESULT_FROM_WIN32(ulLastError);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportMissedRuns
//
//  Synopsis:   Pops up a message indicating that some runs were missed, and
//              logs this to the event log and task scheduler log.
//
//  Arguments:  [pstLastRun], [pstNow] - times between which runs were missed.
//
//----------------------------------------------------------------------------
void
ReportMissedRuns(const SYSTEMTIME * pstLastRun, const SYSTEMTIME * pstNow)
{
    //
    // Write to the task scheduler log
    //
    LogMissedRuns(pstLastRun, pstNow);

    //
    // Spin a thread to popup a message.
    // Suppress the popup if NoPopupsOnBoot is indicated in the registry.
    //
    DWORD   PopupStatus;
    BOOL    bPopups = TRUE;     // FALSE means suppress popups on boot
    HKEY    WindowsKey=NULL;

    PopupStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CONTROL_WINDOWS_KEY,
                                0, KEY_READ, &WindowsKey);
    if (PopupStatus == ERROR_SUCCESS)
    {
        DWORD Type;
        DWORD Data;
        DWORD cbData = sizeof(Data);

        PopupStatus = RegQueryValueEx(WindowsKey, NOBOOTPOPUPS_VALUENAME,
                                      NULL, &Type, (LPBYTE) &Data, &cbData);

        //
        // Popups are suppressed if the NOBOOTPOPUPS_VALUENAME value is
        // present, is a REG_DWORD and is non-zero.
        //
        if (PopupStatus == ERROR_SUCCESS &&
            Type == REG_DWORD &&
            Data != 0)
        {
            bPopups = FALSE;
        }

        RegCloseKey(WindowsKey);
    }

    if (bPopups &&
        //
        // If the message has already been popped up on the screen, and hasn't
        // been dismissed yet, don't pop up another one.
        //
        ! InterlockedExchange(&g_fPopupDisplaying, TRUE))
    {
        DWORD dwThreadId;
        HANDLE hThread = CreateThread(
                           NULL,
                           0L,
                           (LPTHREAD_START_ROUTINE) PopupThread,
                           0,   // parameter
                           0L,
                           &dwThreadId
                           );

        if (hThread == NULL)
        {
            ERR_OUT("CreateThread PopupThread", GetLastError());
            g_fPopupDisplaying = FALSE;
        }
        else
        {
            CloseHandle(hThread);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   PopupThread
//
//  Synopsis:   Pops up a message indicating that some runs were missed.
//
//  Arguments:  [lpParameter] - ignored.
//
//----------------------------------------------------------------------------
DWORD WINAPI
PopupThread(LPVOID lpParameter)
{
    CHAR szTitle[SCH_MEDBUF_LEN];
    CHAR szMsg[SCH_BIGBUF_LEN];

    if (LoadStringA(g_hInstance,
                    IDS_POPUP_SERVICE_TITLE,
                    szTitle,
                    SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }
    else if (LoadStringA(g_hInstance,
                    IDS_POPUP_RUNS_MISSED,
                    szMsg,
                    SCH_BIGBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }
    else
    {
        MessageBoxA(NULL, szMsg, szTitle,
                    MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL);
    }

    g_fPopupDisplaying = FALSE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\secmisc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       secmisc.cxx
//
//  Contents:   Code to retrieve security-related information from the job
//              object. Function names partially describe the intended
//              function - we don't want to give too much away.
//
//  Classes:    None.
//
//  Functions:  CloseFile
//              GetFileInformation
//
//  History:    15-May-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <ntsecapi.h>
#include <mstask.h>
#include <msterr.h>
#include "debug.hxx"
#include "lsa.hxx"
#include "globals.hxx"
#include "misc.hxx"

BOOL WaitForMUP (DWORD dwMaxWait);
BOOL WaitForServiceToStart (LPTSTR lpServiceName, DWORD dwMaxWait);

//
// Defined in globals.cxx
//
extern CStaticCritSec gcsSSCritSection;

//
// Defined in security.cxx.
//
extern DWORD                        gdwKeyElement;
extern POLICY_ACCOUNT_DOMAIN_INFO * gpDomainInfo;
extern WCHAR                        gwszComputerName[MAX_COMPUTERNAME_LENGTH + 2];

//+---------------------------------------------------------------------------
//
//  Function:   CloseFile
//
//  Synopsis:
//
//  Arguments:  [hFile]          --
//              [ccApplication]  --
//              [wszApplication] --
//              [hrPrevious]     --
//
//  Returns:    S_OK
//              SCHED_E_INVALID_TASK
//              E_UNEXPECTED
//              HRESULT argument, if it is an error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CloseFile(
    HANDLE  hFile,
    WORD    ccApplication,
    WCHAR   wszApplication[],
    HRESULT hrPrevious)
{
    HRESULT hr = S_OK;
    DWORD   dwBytesRead;
    WCHAR * pwsz;
    WORD    wAppOffset;
    WORD    cch;

    //
    // If the previous operation failed, skip the application read.
    //

    if (FAILED(hrPrevious))
    {
        hr = hrPrevious;
        goto ErrorExit;
    }

    //
    // Read the offset to the application name.
    //

    if (!ReadFile(hFile, &wAppOffset, sizeof(wAppOffset), &dwBytesRead, NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        hr = SCHED_E_INVALID_TASK;
        goto ErrorExit;
    }

    //
    // Move to read the application name.
    //

    if (SetFilePointer(hFile, wAppOffset, NULL, FILE_BEGIN) != -1)
    {
        //
        // Read the application size, allocate sufficient buffer space
        // and read the application string.
        //

        if (!ReadFile(hFile, &cch, sizeof(cch), &dwBytesRead, NULL) ||
            dwBytesRead != sizeof(cch))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            hr = SCHED_E_INVALID_TASK;
            goto ErrorExit;
        }

        if (!cch)
        {
            wszApplication[0] = L'\0';
        }
        else if (cch > ccApplication)
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
        else
        {
            if (!ReadFile(hFile,
                          wszApplication,
                          cch * sizeof(WCHAR),
                          &dwBytesRead,
                          NULL))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                hr = SCHED_E_INVALID_TASK;
                goto ErrorExit;
            }

            if (dwBytesRead != (cch * sizeof(WCHAR)))
            {
                hr = SCHED_E_INVALID_TASK;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            if (wszApplication[cch - 1] != L'\0')
            {
                hr = SCHED_E_INVALID_TASK;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        hr = SCHED_E_INVALID_TASK;
    }

ErrorExit:
    if (hFile != NULL) CloseHandle(hFile);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFileInformation
//
//  Synopsis:
//
//  Arguments:  [pwszFileName]      --
//              [hFile]             --
//              [pcbOwnerSid]       --
//              [ppOwnerSid]        --
//              [ppOwnerSecDescr]   --
//              [ccOwnerName]       --
//              [ccOwnerDomain]     --
//              [ccApplication]     --
//              [wszOwnerName]      --
//              [wszOwnerDomain]    --
//              [wszApplication]    --
//              [pftCreationTime]   --
//              [pdwVolumeSerialNo] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileInformation(
    LPCWSTR                pwszFileName,
    DWORD *                pcbOwnerSid,
    PSID *                 ppOwnerSid,
    PSECURITY_DESCRIPTOR * ppOwnerSecDescr,
    UUID *                 pJobID,
    DWORD                  ccOwnerName,
    DWORD                  ccOwnerDomain,
    DWORD                  ccApplication,
    WCHAR                  wszOwnerName[],
    WCHAR                  wszOwnerDomain[],
    WCHAR                  wszApplication[],
    FILETIME *             pftCreationTime,
    DWORD *                pdwVolumeSerialNo)
{
    BY_HANDLE_FILE_INFORMATION hinfo;
    HANDLE                     hFile;
    SECURITY_DESCRIPTOR *      pOwnerSecDescr = NULL;
    PSID                       pOwnerSid  = NULL;
    DWORD                      cbOwnerSid = 0;
    DWORD                      cbSizeNeeded;
    BOOL                       fRet, fOwnerDefaulted;
    static                     s_bWaitForWorkStation = TRUE;

    HRESULT hr = OpenFileWithRetry(pwszFileName, GENERIC_READ, FILE_SHARE_READ, &hFile);

    if (FAILED(hr))
    {
        return hr;
    }
    else
    {
        //
        // Read the UUID from the job indicated.
        //

        BYTE  pbBuffer[sizeof(DWORD) + sizeof(UUID)];
        DWORD dwBytesRead;

        if (!ReadFile(hFile, pbBuffer, sizeof(pbBuffer), &dwBytesRead, NULL))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            CloseHandle(hFile);
            return SCHED_E_INVALID_TASK;
        }

        if (dwBytesRead != sizeof(pbBuffer))
        {
            CHECK_HRESULT(SCHED_E_INVALID_TASK);
            CloseHandle(hFile);
            return SCHED_E_INVALID_TASK;
        }

        CopyMemory(pJobID, pbBuffer + sizeof(DWORD), sizeof(*pJobID));
    }

    //
    // Retrieve file creation time and the volume serial number.
    //

    if (!GetFileInformationByHandle(hFile, &hinfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Retrieve the file owner. Call GetFileSecurity twice - first to get
    // the buffer size, then the actual information retrieval.
    //

    if (GetFileSecurity(pwszFileName,
                        OWNER_SECURITY_INFORMATION,
                        NULL,
                        0,
                        &cbSizeNeeded))
    {
        //
        // Didn't expect this to succeed!
        //

        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) && (cbSizeNeeded > 0))
    {
        //
        // Allocate the buffer space necessary and retrieve the info.
        //

        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        if (!GetFileSecurity(pwszFileName,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Retrieve & validate the owner sid.
    //
    // NB : After this, pOwnerSid will point into the security descriptor,
    //      pOwnerSecDescr; hence, the descriptor must exist for the
    //      lifetime of pOwnerSid.
    //

    fRet = GetSecurityDescriptorOwner(pOwnerSecDescr,
                                      &pOwnerSid,
                                      &fOwnerDefaulted);

    if (fRet)
    {
        if (fRet = IsValidSid(pOwnerSid))
        {
            cbOwnerSid = GetLengthSid(pOwnerSid);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    if (!fRet)
    {
        goto ErrorExit;
    }

   //
   // Retrieve the account name & domain name from the file owner sid.
   //

    SID_NAME_USE snu;
    BOOL         bDoLookupAgain;

    //
    //Startup jobs for domain users will fail if workstation is not initialized
    //If LookupAccountSid fails and we are booting then force the service to 
    //  wait until workstation is fully initialized and then try again
    //
    do
    {
       bDoLookupAgain = FALSE;

       schDebugOut((DEB_TRACE, "GetFileInformation: Calling LookupAccountSid\n"));

       if (!LookupAccountSid(NULL,
                             pOwnerSid,
                             wszOwnerName,
                             &ccOwnerName,
                             wszOwnerDomain,
                             &ccOwnerDomain,
                             &snu))
       {
           hr = HRESULT_FROM_WIN32(GetLastError());
           CHECK_HRESULT(hr);

           if( s_bWaitForWorkStation )
           {
              schDebugOut((DEB_TRACE, "GetFileInformation: Delaying LookupAccountSid for boot\n"));

              WaitForMUP(120000);
              WaitForServiceToStart(L"workstation",120000);
              WaitForServiceToStart(L"netlogon",120000);

              bDoLookupAgain        = TRUE;
              s_bWaitForWorkStation = FALSE;

              //Reset since CloseFile returns this value if failure
              hr = ERROR_SUCCESS;  

           } else {
              goto ErrorExit;
           }
       }

    } while(bDoLookupAgain);


ErrorExit:
    //
    // Being a little sneaky here and reading the job application whilst
    // closing the file handle. That is, if all succeeded above.
    //

    hr = CloseFile(hFile, (WORD)ccApplication, wszApplication, hr);

    if (SUCCEEDED(hr))
    {
        *pftCreationTime = hinfo.ftCreationTime;
        *pdwVolumeSerialNo = hinfo.dwVolumeSerialNumber;
        *pcbOwnerSid       = cbOwnerSid;
        *ppOwnerSid        = pOwnerSid;
        *ppOwnerSecDescr   = pOwnerSecDescr;

        //
        // If not already done so, set the 'mystery' global DWORD.
        // This DWORD, in addition to other data, is used to generate
        // the encryption key for the SAC/SAI database.
        //
        // The reason why this is done here is to spread the key generation
        // code around a bit.
        //

        if (!gdwKeyElement)
        {
            SetMysteryDWORDValue();
        }
    }
    else
    {
        delete pOwnerSecDescr;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetMysteryDWORDValue
//
//  Synopsis:   Initialize a global DWORD to be used as a data element in
//              generation of the SAC/SAI database encryption key.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
SetMysteryDWORDValue(void)
{
    //
    // Set the global mystery dword to the first dword of the job or queue
    // class ids, depending on the value of the machine sid.
    //

    EnterCriticalSection(&gcsSSCritSection);

    if (!gdwKeyElement)
    {
        DWORD dwTmp;

        //
        // The last (3) subauthorities of the machine SID are unique per
        // machine. Test LSB of the 2nd from the last subauthority.
        //

        PUCHAR pSidSubAuthorityCount = GetSidSubAuthorityCount(
                                                gpDomainInfo->DomainSid);
        schAssert(pSidSubAuthorityCount != NULL);
        DWORD   nSubAuthority = (pSidSubAuthorityCount != NULL ?
                        max(*pSidSubAuthorityCount, 2) : 2);
        DWORD * pSubAuthority = GetSidSubAuthority(
                                                gpDomainInfo->DomainSid,
                                                nSubAuthority - 2);
        schAssert(pSubAuthority != NULL);

        if (pSubAuthority != NULL && *pSubAuthority & 0x00000001)
        {
            dwTmp = 0x255b3f60; // CLSID_CQueue.Data1
        }
        else
        {
            dwTmp = CLSID_CTask.Data1;
        }

        //
        // Apply a mask to the mystery value to further disguise it.
        //

        if (gwszComputerName[0] & 0x0100)
        {
            dwTmp &= 0xC03F71C3;
        }
        else
        {
            dwTmp &= 0xE3507233;
        }

        gdwKeyElement = dwTmp;
    }

    LeaveCriticalSection(&gcsSSCritSection);
}

//*************************************************************
//
//  WaitForServiceToStart()
//
//  Purpose:    Waits for the specified service to start
//
//  Parameters: dwMaxWait  -  Max wait time
//
//
//  Return:     TRUE if the network is started
//              FALSE if not
//
//*************************************************************
BOOL WaitForServiceToStart (LPTSTR lpServiceName, DWORD dwMaxWait)
{
    BOOL bStarted                          = FALSE;
    DWORD dwSize                           = 512;
    SC_HANDLE hScManager                   = NULL;
    SC_HANDLE hService                     = NULL;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;
    DWORD dwPoleWait                       = 1000;
    DWORD StartTickCount;
    SERVICE_STATUS ServiceStatus;
 
    //
    // OpenSCManager and the rpcss service
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }
 
    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }
 
    //
    // Query if the service is going to start
    //
    lpServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }
 
    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
 
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }
 
        LocalFree (lpServiceConfig);
 
        lpServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc (LPTR, dwSize);
 
        if (!lpServiceConfig) {
            goto Exit;
        }
 
        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }
 
    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }
 
    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //
 
    StartTickCount = GetTickCount();
 
    while (!bStarted) {
 
        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }
 
        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(dwPoleWait);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {
 
            bStarted = TRUE;
 
        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(dwPoleWait);
        } else {
            Sleep(dwPoleWait);
        }
    }
 

Exit:
 
    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }
 
    if (hService) {
        CloseServiceHandle(hService);
    }
 
    if (hScManager) {
        CloseServiceHandle(hScManager);
    }
 
    return bStarted;
}
 

//*************************************************************
//
//  WaitForMUP()
//
//  Purpose:    Waits for the MUP to finish initializing
//
//  Parameters: dwMaxWait     -  Max wait time
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL WaitForMUP (DWORD dwMaxWait)
{
    HANDLE hEvent = NULL;
    BOOL bResult;
    INT i = 0;
 
    //
    // Try to open the event
    //
    do {
        hEvent = OpenEvent (SYNCHRONIZE, FALSE,
                            TEXT("wkssvc:  MUP finished initializing event"));
        if (hEvent) {
            break;
        }
 
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            break;
        }
 
        Sleep(500);
        i++;
    } while (i < 20);
 
    if (!hEvent) {
        return FALSE;
    }
 
    //
    // Wait for the event to be signalled
    //
    bResult = (WaitForSingleObject (hEvent, dwMaxWait) == WAIT_OBJECT_0);
 
    //
    // Clean up
    //
    CloseHandle (hEvent);
 
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  None.
//
//  History:    15-May-96   MarkBl  Created
//              26-Feb-01   JBenton Prefix Bug 160502 - using uninit memory
//              17-Apr-01   a-JyotiG Fixed Bug 367263 - Should not assign any privilege/right 
//                          to system account.  
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#include <modes.h>          // found in private\inc\crypto
#include <ntsecapi.h>
#include <ntdsapi.h>        // DsCrackNames
#include "resource.h"
#include "globals.hxx"      // BUGBUG 254102
#include "sch_cls.hxx"      // To implement AddAtJobWithHash
#include "authzi.h"         // for auditing
#include <FolderSecurity.h>
#include "svc_core.hxx"
#include "security.hxx"
#include "auditing.hxx"
#include "misc.hxx"

//
// some prototypes for functions not in a header
//
BOOL    IsThreadCallerAnAdmin(
                HANDLE  hThreadToken);

//
// global stuff
//
WCHAR                         gwszComputerName[MAX_COMPUTERNAME_LENGTH + 2] = L""; // this buffer must remain this size or it will break old credentials
LPWSTR                        gpwszComputerName = NULL;
DWORD                         gdwKeyElement   = 0;
DWORD                         gccComputerName = MAX_COMPUTERNAME_LENGTH + 2;
POLICY_ACCOUNT_DOMAIN_INFO*   gpDomainInfo = NULL;
DWORD                         gcbMachineSid   = 0;
PSID                          gpMachineSid    = NULL;
extern CStaticCritSec         gcsSSCritSection;

//+---------------------------------------------------------------------------
//
//  Helper function: ValidateRunAs
//
//  Synopsis:   Verify that password entered for Run As account is correct
//              by actually trying to log on using the credentials
//
//              *** Verification of NULL passwords is handled elsewhere ***
//
//  Returns:    bool
//
//----------------------------------------------------------------------------
bool ValidateRunAs(
    LPCWSTR pwszAccount,
    LPCWSTR pwszDomain,
    LPCWSTR pwszPassword)
{
    // NOTE - don't zero out the password anywhere in here -- we still need it!

    //
    // copy to buffers we can manipulate
    //
    WCHAR wszDomain  [MAX_DOMAINNAME + 1];
    WCHAR wszAccount [MAX_USERNAME + 1];

    //
    // if the domain is present in the account name (SAM names), skip over it
    //
    WCHAR* pSlash = (WCHAR *) wcschr(pwszAccount, L'\\');
    if (pSlash)
        StringCchCopy(wszAccount, MAX_USERNAME + 1, pSlash + 1);
    else   
        StringCchCopy(wszAccount, MAX_USERNAME + 1, pwszAccount);

    StringCchCopy(wszDomain, MAX_DOMAINNAME + 1, pwszDomain);

    //
    // If the name was passed in as a UPN, convert it to a SAM name first.
    // Treat the account name as a UPN if it lacks a \ and has an @.
    // Otherwise, treat it as a SAM name.
    //
    if (wcschr(pwszAccount, L'\\') == NULL && wcschr(pwszAccount, L'@') != NULL)
    {
        LPWSTR pwszSamName;
        DWORD dwErr = SchedUPNToAccountName(pwszAccount, &pwszSamName);
        if (dwErr != NO_ERROR)
        {
            return false;
        }
        else
        {
            pSlash = wcschr(pwszSamName, L'\\');
            schAssert(pSlash);
            *pSlash = L'\0';
            StringCchCopy(wszDomain, MAX_DOMAINNAME + 1, pwszSamName);
            StringCchCopy(wszAccount, MAX_USERNAME + 1, pSlash + 1);
            delete pwszSamName;
        }
    }

    HANDLE hToken = NULL;
    if (LogonUser(wszAccount,
                  wszDomain,
                  pwszPassword,
                  LOGON32_LOGON_NETWORK,
                  LOGON32_PROVIDER_DEFAULT,
                  &hToken))
    {
        CloseHandle(hToken);
        return true;        
    }
    else
    {
        return false;        
    }
}

//+---------------------------------------------------------------------------
//
//  Helper function: NotifyLsaOfPasswordChange
//
//  Synopsis:   Notify LSA if the password has been changed for an account so
//              that it can determine if any user sessions need to be refreshed.
//
//              This code was stolen and modified from base\cluster\service\nm\setpass.c.
//
//  Returns:    ERROR_SUCCESS if successful, Win32 error code otherwise.
//
//----------------------------------------------------------------------------
DWORD NotifyLsaOfPasswordChange(
    LPCWSTR pwszAccount,
    LPCWSTR pwszDomain,
    LPCWSTR pwszPassword)
{
    DWORD      ReturnStatus;
    NTSTATUS   Status;
    NTSTATUS   SubStatus;
    LSA_STRING LsaStringBuf;
    char*      AuthPackage = MSV1_0_PACKAGE_NAME;
    HANDLE     LsaHandle = NULL;
    ULONG      PackageId;

    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    ULONG RequestSize;
    PBYTE Where;
    PVOID Response = NULL;
    ULONG ResponseSize;

    //
    // Change password in LSA cache
    //
    Status = LsaConnectUntrusted(&LsaHandle);

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        goto ErrorExit;
    }
    
    RtlInitString(&LsaStringBuf, AuthPackage);

    Status = LsaLookupAuthenticationPackage(
                 LsaHandle,      // Handle
                 &LsaStringBuf,  // MSV1_0 authentication package 
                 &PackageId      // output: authentication package identifier
                 );

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        goto ErrorExit;
    }

    //
    // Prepare to call LsaCallAuthenticationPackage() 
    //
    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                  ( ( wcslen(pwszAccount) +
                      wcslen(pwszDomain) +
                      wcslen(pwszPassword) + 3
                    ) * sizeof(WCHAR)
                  );

    Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) 
              HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, RequestSize);

    if (Request == NULL)
    {
        ReturnStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    ULONG BuffSize = RequestSize;

    Where = (PBYTE) (Request + 1);
    BuffSize--;
    Request->MessageType = MsV1_0ChangeCachedPassword;
    StringCbCopy((LPWSTR) Where, BuffSize, pwszDomain );
    RtlInitUnicodeString( &Request->DomainName,  (wchar_t *) Where );
    Where += Request->DomainName.MaximumLength;
    BuffSize -= Request->DomainName.MaximumLength;

    StringCbCopy((LPWSTR) Where, BuffSize , pwszAccount );
    RtlInitUnicodeString( &Request->AccountName,  (wchar_t *) Where );
    Where += Request->AccountName.MaximumLength;
    BuffSize -= Request->AccountName.MaximumLength;

    StringCbCopy((LPWSTR) Where, BuffSize , pwszPassword );
    RtlInitUnicodeString( &Request->NewPassword,  (wchar_t *) Where );
    Where += Request->NewPassword.MaximumLength;

    Status = LsaCallAuthenticationPackage(
                 LsaHandle,  
                 PackageId,  
                 Request,    // MSV1_0_CHANGEPASSWORD_REQUEST
                 RequestSize,
                 &Response,  
                 &ResponseSize, 
                 &SubStatus  // Receives NSTATUS code indicating the 
                             // completion status of the authentication 
                             // package if ERROR_SUCCESS is returned. 
                 );


    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        goto ErrorExit;
    } 
    else if (LsaNtStatusToWinError(SubStatus) != ERROR_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(SubStatus);
        goto ErrorExit;
    }
    
    ReturnStatus = ERROR_SUCCESS;

ErrorExit:

    if (LsaHandle != NULL)
    {
        Status = LsaDeregisterLogonProcess(LsaHandle);
        if (Status != STATUS_SUCCESS)
        {
            // ignore; could possibly log this
        }
    }

    if (Request != NULL)
    {
        if (!HeapFree(GetProcessHeap(), 0, Request))
        {
            // ignore; could possibly log this
        }
    }

    if (Response != NULL)
    {
        Status = LsaFreeReturnBuffer(Response);
        if (Status != STATUS_SUCCESS)
        {
            // ignore; could possibly log this
        }
    }

    return ReturnStatus;
}

//+---------------------------------------------------------------------------
//
//  RPC:        SASetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [Handle]       --
//              [pwszJobName]  -- Relative job name. eg: MyJob.job.
//              [pwszAccount]  --
//              [pwszPassword] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SASetAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszJobName,
    LPCWSTR      pwszAccount,
    LPCWSTR      pwszPassword,
    DWORD        dwJobFlags)
{
    HRESULT hr = S_OK;

    // we're going to do the access check in two stages, 
	// first make sure that the principal is allowed to 
	// do any scheduling whatsoever - later on, we'll
	// check permissions on the specific file in question
	if (FAILED(hr = RPCFolderAccessCheck(g_TasksFolderInfo.ptszPath, FILE_WRITE_DATA, HandleImpersonation)))
    {
        CHECK_HRESULT(hr);
		return hr;
    }

    //
    // Check for invalid params (note that pwszPassword is allowed to be NULL)
    //
    if (pwszJobName == NULL || pwszAccount == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Disallow files outside the tasks folder
    //
    if (wcschr(pwszJobName, L'\\') || wcschr(pwszJobName, L'/'))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Append the job name to the local Task's folder path.
    //
    schAssert(g_TasksFolderInfo.ptszPath != NULL);
    WCHAR wszJobPath[MAX_PATH + 1];
    if ((wcslen(g_TasksFolderInfo.ptszPath) + 1 + wcslen(pwszJobName) + 1) > (MAX_PATH + 1))
    {
        CHECK_HRESULT(SCHED_E_CANNOT_OPEN_TASK);
        return(SCHED_E_CANNOT_OPEN_TASK);
    }
    StringCchCopy(wszJobPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    StringCchCat(wszJobPath, MAX_PATH + 1, L"\\");
    StringCchCat(wszJobPath, MAX_PATH + 1, pwszJobName);

    // 
    // Get the account's SID and domain
    //
    PSID     pAccountSid = NULL;
    DWORD    cbAccountSid = MAX_SID_SIZE;
    DWORD    ccDomain = MAX_DOMAINNAME + 1;
    BYTE     pbAccountSid[MAX_SID_SIZE];
    WCHAR    wszDomain[MAX_DOMAINNAME + 1] = L"";

    HRESULT hrGetAccountSidAndDomain = GetAccountSidAndDomain(pwszAccount, pbAccountSid, cbAccountSid, wszDomain, ccDomain);
    if (FAILED(hrGetAccountSidAndDomain))
    {
        // continue on -- we don't want to return yet on failure, because we don't want to reveal that
        // the "run as" account is invalid if the caller shouldn't even be allowed to make this call;
    }
    else
    {
        pAccountSid = pbAccountSid;
    }

    //
    // Impersonate the caller, open his token, then end impersonation so we aren't impersonated during Auditing
    //
    DWORD RpcStatus = RpcImpersonateClient(NULL);
    if (RpcStatus != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        return hr;
    }

    HANDLE hToken;
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,    // Desired access.
                         TRUE,           // Open as self.
                         &hToken))
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto Clean0;
    }

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        goto Clean1;
    }

    //
    // Now that we have the thread token, audit the job creation.
    // We do this here regardless of whether the user gets access denied down below.
    // However, we can only do this if we succeeded in looking up the "run as" account,
    // as that information is needed for the audit logging.
    //
    if (SUCCEEDED(hrGetAccountSidAndDomain))
    {
        hr = AuditJob(hToken, pAccountSid, wszJobPath);
        if (FAILED(hr))
        {
            ERR_OUT("SASetAccountInformation: AuditJob", hr);

            // let's just forget this happened, OK?
            hr = S_OK; 
        }
    }

    //
    // Reimpersonate client
    //
    RpcStatus = RpcImpersonateClient(NULL);
    if (RpcStatus != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        goto Clean1;
    }

    //
    // Check whether caller should even be allowed to make this call
    //
    if (FAILED(hr = FolderAccessCheck(wszJobPath, hToken, FILE_WRITE_DATA)))
    {
        CHECK_HRESULT(hr);
        goto Clean1;
    }

    if (FAILED(hrGetAccountSidAndDomain))
    {
        //
        // OK, caller passed the above access check, so reveal that the "run as" account is bad
        //
        hr = hrGetAccountSidAndDomain;
        CHECK_HRESULT(hr);
        goto Clean1;
    }

    //
    // If the password is NULL, this task is meant to be run
    // without prompting the user for credentials
    //
    if (pwszPassword == NULL)
    {
        DWORD dwError   = NO_ERROR;
        
        do  // Not a loop.  Error break out.
        {
            //
            // If the caller has a restricted token (e.g., an ActiveX
            // control), it's not allowed to use a NULL password.
            //
            if (IsTokenRestricted(hToken))
            {
                dwError = ERROR_ACCESS_DENIED;
                schDebugOut((DEB_ERROR, "Restricted token tried to set NULL "
                             "password for %ws.  Denying access.\n", pwszJobName));
                break;
            }

            //
            // To set credentials for the job, the caller must have write
            // access to the job file.
            //
            HANDLE  hFile;
            hr = OpenFileWithRetry(wszJobPath, GENERIC_WRITE, FILE_SHARE_WRITE, &hFile);
            if (FAILED(hr))
            {
                ERR_OUT("SASetAccountInformation: caller's open of task file", hr);
                break;
            }

            CloseHandle(hFile);

            //
            // Unless the task is being set to run as LocalSystem, a NULL
            // password means that the task must be scheduled to run only
            // if the user is logged on, so make sure that flag is set in
            // that case
            //
            // An account name of "" signifies the local system account.
            //
            BOOL  fIsAccountLocalSystem = (pwszAccount[0] == L'\0');
            
            if (!fIsAccountLocalSystem
                &&
                !(dwJobFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
            {
                schDebugOut((DEB_ERROR, "SetAccountInformation with NULL "
                             "password is only supported for LocalSystem "
                             "account or for job with "
                             "TASK_FLAG_RUN_ONLY_IF_LOGGED_ON\n",
                             pwszJobName));
                hr = SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
                break;
            }

            //
            // The caller must be either LocalSystem, an administrator or
            // the user named in pwszAccount (the latter being the most
            // common case.  CODEWORK - rearrange to optimize for that case?)
            //

            BOOL fIsCallerLocalSystem;
            SID  LocalSystemSid = {SID_REVISION,
                                   1,
                                   SECURITY_NT_AUTHORITY,
                                   SECURITY_LOCAL_SYSTEM_RID };

            if (!CheckTokenMembership(hToken,
                                      &LocalSystemSid,
                                      &fIsCallerLocalSystem))
            {
                dwError = GetLastError();
                ERR_OUT("CheckTokenMembership", dwError);
                // translate this to E_UNEXPECTED?
                break;
            }

            if (fIsCallerLocalSystem || IsThreadCallerAnAdmin(hToken))
            {
                //
                // (success)
                //
                break;
            }

            if (fIsAccountLocalSystem)
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                schDebugOut((DEB_ERROR, "Non-system, non-admin tried "
                             "to schedule task as LocalSystem\n"));
                break;
            }

            //
            // Compare the caller's token with the account's SID
            //
            BOOL fIsCallerAccount;
            if (!CheckTokenMembership(hToken,
                                      pAccountSid,
                                      &fIsCallerAccount))
            {
                dwError = GetLastError();
                ERR_OUT("CheckTokenMembership", dwError);
                // translate this to E_UNEXPECTED?
                break;
            }

            if (! fIsCallerAccount)
            {
                schDebugOut((DEB_ERROR, "Caller is neither LocalSystem "
                             "nor admin nor the named account\n"));
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }

            //
            // else success -- the caller is the named account
            //
        } while (0);

        if (dwError != NO_ERROR)
        {
            hr = _HRESULT_FROM_WIN32(dwError);
        }

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
        }
        else
        {
            schDebugOut((DEB_TRACE, "Saving NULL password for %ws\n", pwszJobName));
        }

        // end of NULL password stuff
    }
    else
    {
        //
        // Verify that the credentials entered actually work.
        // This prevents someone from scheduling jobs for a valid account with an invalid password
        // and causing the credential database to be updated with the bad password.
        // It also prevents someone from creating lots of bogus jobs.
        //
        if (!ValidateRunAs(pwszAccount, wszDomain, pwszPassword))
        {
            hr = E_ACCESSDENIED;
            CHECK_HRESULT(hr);
        }
    }

Clean1:
    //
    // Close the handle to the thread token
    //
    CloseHandle(hToken);

Clean0:
    //
    // End impersonation.
    //
    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        ERR_OUT("RpcRevertToSelf", RpcStatus);
        schAssert(!"RpcRevertToSelf failed");
    }

    if (SUCCEEDED(hr))
    {
        //
        // Write the credentials to the database
        // If given a UPN, save "" for the domain and the entire UPN for the user.
        // Treat the account name as a UPN if it lacks a \ and has an @.
        // Otherwise, treat it as a SAM name.
        //
        BOOL  fUpn = (wcschr(pwszAccount, L'\\') == NULL && wcschr(pwszAccount, L'@') != NULL);

        //
        // Retrieve the original creds and compare with the ones we're about to save
        // in order to determine if just the password is being updated.  If so, notify LSA.
        // There's no need to do any of this for local system, and we also shouldn't do this
        // if the job is flagged to run only if logged on, as the NULL password supplied in
        // this case is not really the user's password. We can exclude both cases by testing
        // for a non-NULL password as there is no other situation where a NULL password will
        // be allowed.  Blank passwords are legit, but they are non-NULL and therefore OK.
        //
        if (pwszPassword)
        {
            JOB_CREDENTIALS jc;
            hr = GetAccountInformation(wszJobPath, &jc);
            if (SUCCEEDED(hr))
            {
                if ((lstrcmpiW(jc.wszAccount, fUpn ? pwszAccount : SkipDomainName(pwszAccount)) == 0) &&
                    (lstrcmpiW(jc.wszPassword, pwszPassword) != 0))
                {
                    NotifyLsaOfPasswordChange(fUpn ? pwszAccount : SkipDomainName(pwszAccount),
                                              fUpn ? L"" : wszDomain,
                                              pwszPassword);
                }
                ZERO_PASSWORD(jc.wszPassword);
            }
        }

        hr = SaveJobCredentials(
                        wszJobPath,
                        fUpn ? pwszAccount : SkipDomainName(pwszAccount),
                        fUpn ? L"" : wszDomain,
                        pwszPassword,
                        pAccountSid
                        );
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function: GetAccountSidAndDomain
//
//  Synopsis: Gets the SID and Domain of an account.
//            This was factored out of SASetAccountInformation() above, because this is a 
//            task that now needs to be performed in more than one place, and I did not 
//            wish to duplicate code.
//
//  Arguments:
//            IN     LPCWSTR pwszAccount  -- account to look up
//            IN OUT PSID    pAccountSid  -- pointer to buffer to receive SID
//            IN     DWORD   cbAccountSid -- size of buffer
//            IN OUT LPWSTR  pwszDomain   -- pointer to buffer to receive domain
//            IN     DWORD   ccDomain     -- size of buffer
//
//  Returns:  HRESULT
//
//----------------------------------------------------------------------------

HRESULT
GetAccountSidAndDomain(
    LPCWSTR pwszAccount, 
    PSID pAccountSid, 
    DWORD cbAccountSid,
    LPWSTR pwszDomain,
    DWORD ccDomain)
{
    HRESULT hr = S_OK;

    if (pwszAccount == NULL || pAccountSid == NULL || pwszDomain == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // An account name of "" signifies the local system account.
    //
    BOOL  fIsAccountLocalSystem = (pwszAccount[0] == L'\0');

    //
    // Get the account's SID
    //
    if (fIsAccountLocalSystem)
    {
        SID LocalSystemSid = {SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };
    
        if (!CopySid(cbAccountSid, pAccountSid, &LocalSystemSid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return hr;
        }
    }
    else
    {
        //
        // Treat the account name as a UPN if it lacks a \ and has an @.
        // Otherwise, treat it as a SAM name.
        //
        BOOL  fUpn = (wcschr(pwszAccount, L'\\') == NULL && wcschr(pwszAccount, L'@') != NULL);
        schDebugOut((DEB_TRACE, "Name '%S' is a %s name\n", pwszAccount, fUpn ? "UPN" : "SAM"));

        LPWSTR pwszSamName;

        if (fUpn)
        {
            //
            // Get the SAM name, so we can call LookupAccountName
            //
            DWORD dwErr = SchedUPNToAccountName(pwszAccount, &pwszSamName);
            if (dwErr != NO_ERROR)
            {
                hr = HRESULT_FROM_WIN32(dwErr);
                CHECK_HRESULT(hr);
                return hr;
            }
        }
        else
        {
            pwszSamName = (LPWSTR) pwszAccount;
        }

        DWORD        ccDomain = MAX_DOMAINNAME + 1;
        WCHAR        wszDomain[MAX_DOMAINNAME + 1] = L"";
        SID_NAME_USE snu;

        if (!LookupAccountNameWrap(NULL,
                                   pwszSamName,
                                   pAccountSid,
                                   &cbAccountSid,
                                   pwszDomain,
                                   &ccDomain,
                                   &snu))
        {
            CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
            hr = SCHED_E_ACCOUNT_NAME_NOT_FOUND;
        }

        if (fUpn)
        {
            delete pwszSamName;
        }

        if (FAILED(hr))
        {
            return hr;
        }

        schAssert(IsValidSid(pAccountSid));

    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:    GetNSAccountSid
//
//  Synopsis:    Gets the SID of the account set to be used with the Net Schedule API (AT command).
//
//  Arguments:
//            IN OUT PSID  pAccountSid  -- pointer to buffer to receive SID
//            IN     DWORD cbAccountSid -- size of buffer
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
GetNSAccountSid(
    PSID pAccountSid,
    DWORD cbAccountSid)
{
    HRESULT hr = S_OK;

    if (pAccountSid == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // get the name of the AT service account
    //
    DWORD cchAccount = MAX_USERNAME + 1;
    WCHAR wszAccount[MAX_USERNAME + 1];
    hr = SAGetNSAccountInformation(NULL, cchAccount, wszAccount);
    if (FAILED(hr))
        return hr;

    // 
    // Get the account's SID
    //
    DWORD ccDomain = MAX_DOMAINNAME + 1;
    WCHAR wszDomain[MAX_DOMAINNAME + 1] = L"";
    hr = GetAccountSidAndDomain(wszAccount, pAccountSid, cbAccountSid, wszDomain, ccDomain);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveJobCredentials
//
//  Synopsis:   Writes the job credentials to the credential database
//
//  Arguments:
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
SaveJobCredentials(
    LPCWSTR pwszJobPath,
    LPCWSTR pwszAccount,
    LPCWSTR pwszDomain,
    LPCWSTR pwszPassword,
    PSID    pAccountSid
    )
{
    BYTE         rgbIdentity[HASH_DATA_SIZE];
    BYTE         rgbHashedAccountSid[HASH_DATA_SIZE] = { 0 };
    RC2_KEY_INFO RC2KeyInfo;
    HRESULT      hr;
    DWORD        cbSAI;
    DWORD        cbSAC;
    DWORD        cbCredentialNew;
    DWORD        cbEncryptedData;
    DWORD        CredentialIndexNew, CredentialIndexPrev;
    BYTE *       pbEncryptedData;
    BYTE *       pbFoundIdentity;
    BYTE *       pbIdentitySet;
    BYTE *       pbCredentialNew    = NULL;
    BYTE *       pbSAI              = NULL;
    BYTE *       pbSAC              = NULL;
    HCRYPTPROV   hCSP               = NULL;

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Hash the job into a unique identity.
    //

    hr = HashJobIdentity(hCSP, pwszJobPath, rgbIdentity);

    if (FAILED(hr))
    {
        CloseCSPHandle(hCSP);
        return(hr);
    }

    //
    // Store a NULL password by flipping the last bit of the hash data.
    //

    if (pwszPassword == NULL)
    {
        LAST_HASH_BYTE(rgbIdentity) ^= 1;
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Generate the encryption key & encrypt the account information passed.
    //

    hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    hr = EncryptCredentials(RC2KeyInfo,
                            pwszAccount,
                            pwszDomain,
                            pwszPassword,
                            pAccountSid,
                            &cbEncryptedData,
                            &pbEncryptedData);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Read SAI & SAC databases.
    //

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Check whether we will be in danger of exceeding the max secret size.
    // We don't know at this time whether we'll be increasing the size of the
    // secret as the data may already be present, but if it does need to be added,
    // the calculation below will show if the size will be over the limit.  If so,
    // do a scavenge operation first as a precaution to remove all unused data,
    // then reread the db.
    //
    if ((cbSAI + sizeof(DWORD) + HASH_DATA_SIZE) > MAX_SECRET_SIZE ||
        (cbSAC + sizeof(DWORD) + HASH_DATA_SIZE + cbEncryptedData) > MAX_SECRET_SIZE)
    {
        if (pbSAI != NULL) LocalFree(pbSAI);
        if (pbSAC != NULL) LocalFree(pbSAC);
        pbSAI = pbSAC = NULL;

        ScavengeSASecurityDBase();

        hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);
        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    //
    // Check if the identity exists in the SAI.
    // (Note, SAIFindIdentity ignores the last bit of the hash data
    // when searching for a match.)
    //

    hr = SAIFindIdentity(rgbIdentity,
                         cbSAI,
                         pbSAI,
                         &CredentialIndexPrev,
                         NULL,
                         &pbFoundIdentity,
                         NULL,
                         &pbIdentitySet);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Check if the caller-specified credentials already exist in the SAC.
    // Ensure also, if the credentials exist, that the caller has access.
    //

    hr = CredentialLookupAndAccessCheck(hCSP,
                                        pAccountSid,
                                        cbSAC,
                                        pbSAC,
                                        &CredentialIndexNew,
                                        rgbHashedAccountSid,
                                        &cbCredentialNew,
                                        &pbCredentialNew);

    if (FAILED(hr) && hr != SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
    {
        goto ErrorExit;
    }

    if (pbFoundIdentity == NULL)
    {
        //
        // This job is new to the SAI. That is, there are no credentials
        // associated with this job yet.
        //

        if (pbCredentialNew != NULL)
        {
            //
            // If the credentials the caller specified already exist in the
            // SAC, use them. Note, we've already established the caller
            // has permission to use them.
            //
            // Insert the job identity into the SAI identity set associated
            // with this credential.
            //

            hr = SAIIndexIdentity(cbSAI,
                                  pbSAI,
                                  CredentialIndexNew,
                                  0,
                                  NULL,
                                  NULL,
                                  &pbIdentitySet);

            if (hr == S_FALSE)
            {
                //
                // The SAC & SAI databases are out of sync.
                // Should *never* occur. Logic on exit handles this.
                //

                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
            else if (SUCCEEDED(hr))
            {
                hr = SAIInsertIdentity(rgbIdentity,
                                       pbIdentitySet,
                                       &cbSAI,
                                       &pbSAI);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr) && pwszPassword != NULL)
                {
                    //
                    // Simply change of existing credentials (password change).
                    // If we're setting a NULL password, we're setting it for
                    // this job alone, and we don't need to touch the SAC.
                    // If we're setting a non-NULL password, we're setting it
                    // for all jobs in this account, and we need to update the
                    // SAC credential in-place.
                    //

                    hr = SACUpdateCredential(cbEncryptedData,
                                             pbEncryptedData,
                                             cbCredentialNew,
                                             pbCredentialNew,
                                             &cbSAC,
                                             &pbSAC);
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // The credentials didn't exist in the SAC.
            //
            // Append new credentials to the SAC & append the new job
            // identity to the SAI. As a result, the identity will be
            // associated with the new credentials.
            //

            hr = SACAddCredential(rgbHashedAccountSid,
                                  cbEncryptedData,
                                  pbEncryptedData,
                                  &cbSAC,
                                  &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            hr = SAIAddIdentity(rgbIdentity, &cbSAI, &pbSAI);
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        //
        // Account change for an existing job's credentials.
        //
        // Ensure the caller has permission to change account information.
        // Do so by verifying caller access to the existing credentials.
        //

        DWORD  cbCredentialPrev;
        BYTE * pbCredentialPrev;

        hr = SACIndexCredential(CredentialIndexPrev,
                                cbSAC,
                                pbSAC,
                                &cbCredentialPrev,
                                &pbCredentialPrev);

        if (hr == S_FALSE)
        {
            //
            // Credential not found? The SAC & SAI databases are out of sync.
            // This should *never* occur. Logic on exit handles this.
            //

            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }
        else if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Only check the credentials if we're dealing with a non-NULL password
        //
        if (pwszPassword != NULL)
        {
            //
            // pbCredentialPrev points to the start of the credential identity.
            //

            if (!CredentialAccessCheck(hCSP,
                                       pbCredentialPrev))
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }

        if ((pbCredentialNew != NULL) &&
            (CredentialIndexPrev != CredentialIndexNew))
        {
            //
            // The credentials the caller wishes to use already exist in the
            // SAC, yet it differs from the previous.
            //
            // Remove the job identity from its existing SAI position
            // (associated with the previous credentials) and relocate
            // to be associated with the new credentials.
            //
            // SAIRemoveIdentity could result in removal of the associated
            // credential, if this was the last identity associated with it.
            // Save away the original SAC size to see if we must fix up the
            // new credential index on remove.
            //

            DWORD cbSACOrg = cbSAC;

            hr = SAIRemoveIdentity(pbFoundIdentity,
                                   pbIdentitySet,
                                   &cbSAI,
                                   &pbSAI,
                                   CredentialIndexPrev,
                                   &cbSAC,
                                   &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            if (cbSACOrg != cbSAC)
            {
                //
                // The new credential index must be adjusted.
                //

                if (CredentialIndexNew > CredentialIndexPrev)
                {
                    CredentialIndexNew--;
                }
            }

            hr = SAIIndexIdentity(cbSAI,
                                  pbSAI,
                                  CredentialIndexNew,
                                  0,
                                  NULL,
                                  NULL,
                                  &pbIdentitySet);  // [out] ptr.

            if (hr == S_FALSE)
            {
                //
                // The SAC & SAI databases are out of sync. This should
                // *never* occur. Logic on exit handles this.
                //

                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
            else if (SUCCEEDED(hr))
            {
                hr = SAIInsertIdentity(rgbIdentity,
                                       pbIdentitySet,
                                       &cbSAI,
                                       &pbSAI);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr) && pwszPassword != NULL)
                {
                    //
                    // Update the existing credentials if the user has
                    // specified a non-NULL password.
                    //
                    // First, re-index the credential since the remove
                    // above may have altered SAC content.
                    //

                    hr = SACIndexCredential(CredentialIndexNew,
                                            cbSAC,
                                            pbSAC,
                                            &cbCredentialNew,
                                            &pbCredentialNew);

                    if (hr == S_FALSE)
                    {
                        //
                        // Something is terribly wrong. This should *never*
                        // occur. Logic on exit handles this.
                        //

                        ASSERT_SECURITY_DBASE_CORRUPT();
                        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                        goto ErrorExit;
                    }
                    else if (FAILED(hr))
                    {
                        CHECK_HRESULT(hr);
                        goto ErrorExit;
                    }

                    hr = SACUpdateCredential(cbEncryptedData,
                                             pbEncryptedData,
                                             cbCredentialNew,
                                             pbCredentialNew,
                                             &cbSAC,
                                             &pbSAC);
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else if (pbCredentialNew == NULL)
        {
            //
            // The credentials the caller wishes to use do not exist in the
            // SAC.
            //
            // Remove the job identity from its existing SAI position
            // (associated with the previous credentials), then add both
            // the new credentials and the identity to the SAC & SAI
            // respectively. As a result, the identity will be associated
            // with the new credentials.
            //

            //
            // NB : This routine also removes the associated credential from
            //      the SAC if this was the last identity associated with it.
            //      Also, do not reference pbFoundIdentity & pbIdentitySet
            //      after this call, as they will be invalid.
            //

            hr = SAIRemoveIdentity(pbFoundIdentity,
                                   pbIdentitySet,
                                   &cbSAI,
                                   &pbSAI,
                                   CredentialIndexPrev,
                                   &cbSAC,
                                   &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            //
            // Append the identity and the new credentials to the SAI and
            // SAC respectively.
            //

            hr = SACAddCredential(rgbHashedAccountSid,
                                  cbEncryptedData,
                                  pbEncryptedData,
                                  &cbSAC,
                                  &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            hr = SAIAddIdentity(rgbIdentity, &cbSAI, &pbSAI);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Simply change of existing credentials (password change).
            // If we're setting a NULL password, we're setting it for this job
            // alone, and we don't need to touch the SAC.  If we're setting a
            // non-NULL password, we're setting it for all jobs in this
            // account, and we need to update the SAC credential in-place.
            //

            if (pwszPassword != NULL)
            {
                hr = SACUpdateCredential(cbEncryptedData,
                                         pbEncryptedData,
                                         cbCredentialPrev,
                                         pbCredentialPrev,
                                         &cbSAC,
                                         &pbSAC);

                if (FAILED(hr))
                {
                    CHECK_HRESULT(hr);
                    goto ErrorExit;
                }
            }

            //
            // We also need to rewrite the SAI data, because if the password
            // changed from NULL to non-NULL or vice versa, the last bit of
            // the SAI data will have changed.
            //
            hr = SAIUpdateIdentity(rgbIdentity,
                                   pbFoundIdentity,
                                   cbSAI,
                                   pbSAI);

            CHECK_HRESULT(hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            //
            // Grant the account batch privilege.
            // We could choose to ignore the return code here, since the
            // privilege can still be granted later; but if we ignored it,
            // a caller might never know that the call failed until it was
            // time to run the job, which is not good behavior.  (See
            // bug 366582)
            //
            
            //Also we should not assign any privilege/right to system account. Refer to bug 367263
            SID LocalSystemSid = { SID_REVISION,
                                   1,
                                   SECURITY_NT_AUTHORITY,
                                   SECURITY_LOCAL_SYSTEM_RID };

            if(!EqualSid(&LocalSystemSid,pAccountSid)) {
                hr = GrantAccountBatchPrivilege(pAccountSid);
            }            
        }
    }

ErrorExit:
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);
    if (hCSP  != NULL) CloseCSPHandle(hCSP);

    //
    // Log an error & rest the SA security dbases SAI & SAC if corruption
    // is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //

        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                            (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  RPC:        SASetNSAccountInformation
//
//  Synopsis:   Configure the NetSchedule account.
//
//  Arguments:  [Handle]       -- Unused.
//              [pwszAccount]  -- Account name. If NULL, reset the credential
//                                information to zero.
//              [pwszPassword] -- Account password.
//
//  Returns:    S_OK    -- Operation successful.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SASetNSAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszAccount,
    LPCWSTR      pwszPassword)
{
   
    HRESULT    hr = S_OK;
    RPC_STATUS RpcStatus;

    //
    // If not done so already, initialize the DWORD global data element to be
    // used in generation of the encryption key. It's possible this hasn't
    // been performed yet.
    //

    if (!gdwKeyElement)
    {
        //
        // NB : This routine enters (and leaves) the gcsSSCritSection
        //      critical section.
        //

        SetMysteryDWORDValue();
    }

    //
    // The RPC caller must be an administrator to perform this function.
    //
    // Impersonate the caller.
    //

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (! IsThreadCallerAnAdmin(NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    //
    // End impersonation.
    //

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        //
        // BUGBUG : What to do if the impersonation revert fails?
        //

        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        schAssert(!"Couldn't revert to self");
    }

    if (FAILED(hr))
    {
        return(hr);
    }

    if (pwszPassword && wcslen(pwszPassword) > REAL_PWLEN)
        return _HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    //
    // Privilege level check above succeeded if we've gotten to this point.
    //
    // Retrieve the SID of the account name specified.
    //

    RC2_KEY_INFO RC2KeyInfo;
    BYTE         pbAccountSid[MAX_SID_SIZE];
    PSID         pAccountSid                   = NULL;
    WCHAR        wszDomain[MAX_DOMAINNAME + 1] = L"";
    DWORD        cbAccountSid                  = MAX_SID_SIZE;
    DWORD        ccDomain                      = MAX_DOMAINNAME + 1;
    DWORD        dwZero                        = 0;
    DWORD        cbEncryptedData               = 0;
    BYTE *       pbEncryptedData               = NULL;
    SID_NAME_USE snu;
    HCRYPTPROV   hCSP                          = NULL;

    if (pwszAccount != NULL)
    {
        if (!LookupAccountName(NULL,
                               pwszAccount,
                               pbAccountSid,
                               &cbAccountSid,
                               wszDomain,
                               &ccDomain,
                               &snu))
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(SCHED_E_ACCOUNT_NAME_NOT_FOUND);
        }

        pAccountSid = pbAccountSid;
        pwszAccount = SkipDomainName(pwszAccount);
    
        //
        // Verify that the credentials entered actually work.
        // Also note that for NetSchedule jobs, there is no TASK_FLAG_RUN_ONLY_IF_LOGGED_ON,
        // so if a NULL password is entered that mean the password really is supposed to be NULL.
        //
        if (!ValidateRunAs(pwszAccount, wszDomain, pwszPassword))
        {
            hr = E_ACCESSDENIED;
            CHECK_HRESULT(hr);
            return hr;
        }

        //
        // Retrieve the original creds and compare with the ones we're about to save
        // in order to determine if just the password is being updated.  If so, notify LSA.
        //
        JOB_CREDENTIALS jc;
        hr = GetNSAccountInformation(&jc);
        if (SUCCEEDED(hr))
        {
            if ((lstrcmpiW(jc.wszAccount, pwszAccount) == 0) &&
                (lstrcmpiW(jc.wszPassword, pwszPassword) != 0))
            {
                NotifyLsaOfPasswordChange(pwszAccount, wszDomain, pwszPassword);
            }
            ZERO_PASSWORD(jc.wszPassword);
        }
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    if (pwszAccount == NULL)
    {
        //
        // zero the cred info out to indicate LocalSystem
        //
        hr = WriteLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, sizeof(dwZero),
                                    (BYTE *)&dwZero);
        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Obtain a provider handle to the CSP (for use with Crypto API).
        //

        hr = GetCSPHandle(&hCSP);

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        //
        // Generate the encryption key & encrypt the account information
        // passed.
        //

        hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = EncryptCredentials(RC2KeyInfo,
                                pwszAccount,
                                wszDomain,
                                pwszPassword,
                                pAccountSid,
                                &cbEncryptedData,
                                &pbEncryptedData);

        // Clear key content.
        //
        SecureZeroMemory(&RC2KeyInfo, sizeof(RC2KeyInfo));

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = WriteLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, cbEncryptedData,
                                    pbEncryptedData);

        delete [] pbEncryptedData;

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    //
    // Grant the account batch privilege.
    // We could choose to ignore the return code here, since the
    // privilege can still be granted later; but if we ignored it,
    // a caller might never know that the call failed until it was
    // time to run the job, which is not good behavior.  (See
    // bug 366582)
    //
    if (pAccountSid != NULL)
    {
        hr = GrantAccountBatchPrivilege(pAccountSid);
    }

ErrorExit:
    LeaveCriticalSection(&gcsSSCritSection);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  RPC:        SAGetNSAccountInformation
//
//  Synopsis:   Retrieve the NetSchedule account name.
//
//  Arguments:  [Handle]       --
//              [ccBufferSize] --
//              [wszBuffer]    --
//
//  Returns:    S_OK    -- Operation successful.
//              S_FALSE -- No account specified.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAGetNSAccountInformation(
    SASEC_HANDLE Handle,
    DWORD        ccBufferSize,
    WCHAR        wszBuffer[])
{
    HRESULT hr = S_OK;

    //
    // Verify that caller has permission before proceeding any further
    //
    schAssert(g_TasksFolderInfo.ptszPath != NULL);
    if (FAILED(hr = RPCFolderAccessCheck(g_TasksFolderInfo.ptszPath, FILE_READ_DATA, HandleImpersonation)))
        return hr;

    //
    // Check for invalid params
    //
    if (!wszBuffer)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Retrieve the NetSchedule credentials, but return only the account name.
    //
    JOB_CREDENTIALS jc;
    hr = GetNSAccountInformation(&jc);

    if (SUCCEEDED(hr) && hr != S_FALSE)
    {
        ZERO_PASSWORD(jc.wszPassword);      // Not needed; NULL handled.

        if (ccBufferSize > (jc.ccAccount + 1 + jc.ccDomain))
        {
            StringCchCopy(wszBuffer, ccBufferSize, jc.wszDomain);
            StringCchCat(wszBuffer, ccBufferSize, L"\\");
            StringCchCat(wszBuffer, ccBufferSize, jc.wszAccount);
        }
        else
        {
            //
            // Should *never* occur.
            //

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        //
        // Note that LocalSystem accounts will be returned under the S_FALSE condition;
        // set the buffer to the empty string to reflect this
        //
        if (S_FALSE == hr)
        {
            StringCchCopy(wszBuffer, ccBufferSize, L"");
        }
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNSAccountInformation
//
//  Synopsis:   Retrieve the NetSchedule account credentials.
//
//  Arguments:  [pjc] -- Returned credentials.
//
//  Returns:    S_OK    -- Operation successful.
//              S_FALSE -- No account specified.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetNSAccountInformation(
    PJOB_CREDENTIALS pjc)
{
    RC2_KEY_INFO RC2KeyInfo;
    DWORD        cbEncryptedData = 0;
    BYTE *       pbEncryptedData = NULL;
    HCRYPTPROV   hCSP            = NULL;
    HRESULT      hr;

    //
    // If not done so already, initialize the DWORD global data element to be
    // used in generation of the encryption key. It's possible this hasn't
    // been performed yet.
    //

    if (!gdwKeyElement)
    {
        //
        // NB : This routine enters (and leaves) the gcsSSCritSection
        //      critical section.
        //

        SetMysteryDWORDValue();
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Read SAI & SAC databases.
    //

    hr = ReadLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, &cbEncryptedData,
                            &pbEncryptedData);

    if (FAILED(hr) || hr == S_FALSE)
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    else if (cbEncryptedData <= sizeof(DWORD))
    {
        //
        // The information was specified previously but has been reset since.
        //
        // NOTE:  This will be the case if the value has been reset back to LocalSystem,
        // as it merely stores a dword = 0x00000000 in that case
        //
        hr = S_FALSE;
        goto ErrorExit;
    }

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Generate key & decrypt the credentials.
    //

    hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

    if (SUCCEEDED(hr))
    {
        //                      *** Important ***
        //
        // The encrypted credentials passed are decrypted *in-place*.
        // The decrypted data must be zeroed immediately following decryption
        // (even in a failure case).
        //

        hr = DecryptCredentials(RC2KeyInfo,
                                cbEncryptedData,
                                pbEncryptedData,
                                pjc);

        // Don't leave the plain-text password on the heap.
        //
        SecureZeroMemory(pbEncryptedData, cbEncryptedData);

        // Clear key content.
        //
        SecureZeroMemory(&RC2KeyInfo, sizeof(RC2KeyInfo));
    }

ErrorExit:
    LeaveCriticalSection(&gcsSSCritSection);

    if (pbEncryptedData != NULL) LocalFree(pbEncryptedData);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  RPC:        SAGetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [pwszJobName]  -- Relative job name. eg: MyJob.job.
//              [ccBufferSize] --
//              [wszBuffer]    --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAGetAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszJobName,
    DWORD        ccBufferSize,
    WCHAR        wszBuffer[])
{
    HRESULT hr = S_OK;

    // we're going to do the access check in two stages, 
	// first make sure that the principal is allowed to 
	// do any scheduling whatsoever - later on, we'll
	// check permissions on the specific file in question
	if (FAILED(hr = RPCFolderAccessCheck(g_TasksFolderInfo.ptszPath, FILE_READ_DATA, HandleImpersonation)))
    {
        CHECK_HRESULT(hr);
		return hr;
    }

    //
    // Check for invalid params
    //
    if (pwszJobName == NULL || wszBuffer == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Disallow files outside the tasks folder
    //
    if (wcschr(pwszJobName, L'\\') || wcschr(pwszJobName, L'/'))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Append the job name to the local Task's folder path.
    //
    WCHAR wszJobPath[MAX_PATH + 1];
    schAssert(g_TasksFolderInfo.ptszPath != NULL);
    if ((wcslen(g_TasksFolderInfo.ptszPath) + 1 + wcslen(pwszJobName) + 1) > (MAX_PATH + 1))
    {
        CHECK_HRESULT(SCHED_E_CANNOT_OPEN_TASK);
        return(SCHED_E_CANNOT_OPEN_TASK);
    }

    StringCchCopy(wszJobPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    StringCchCat(wszJobPath, MAX_PATH + 1, L"\\");
    StringCchCat(wszJobPath, MAX_PATH + 1, pwszJobName);

    //
    // Verify that caller has permission before proceeding any further
    //
    if (FAILED(hr = RPCFolderAccessCheck(wszJobPath, FILE_READ_DATA, HandleImpersonation)))
        return hr;

    //
    // Retrieve the job's credentials, but return only the account name.
    //
    JOB_CREDENTIALS jc;
    hr = GetAccountInformation(wszJobPath, &jc);

    if (SUCCEEDED(hr))
    {
        ZERO_PASSWORD(jc.wszPassword);      // Not needed; NULL handled.

        if (ccBufferSize > (jc.ccAccount + 1 + jc.ccDomain))
        {
            //
            // If the job was scheduled to run in the LocalSystem account,
            // Accountname is the empty string
            //
            if (jc.wszAccount[0] == L'\0')
            {
                wszBuffer[0] = L'\0';
            }
            else
            {
                //
                // If the account was supplied as a UPN, DomainName is
                // the empty string
                //
                StringCchCopy(wszBuffer, ccBufferSize, jc.wszDomain);
                if (wszBuffer[0] != L'\0')
                {
                    StringCchCat(wszBuffer, ccBufferSize, L"\\");
                }
                StringCchCat(wszBuffer, ccBufferSize, jc.wszAccount);
            }
        }
        else
        {
            //
            // Should *never* occur.
            //

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(hr);
        }
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [pwszJobPath] -- Fully qualified job path.
//                               eg: D:\NT\Tasks\MyJob.job.
//              [pjc]         --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetAccountInformation(
    LPCWSTR          pwszJobPath,
    PJOB_CREDENTIALS pjc)
{
    BYTE       rgbIdentity[HASH_DATA_SIZE];
    HCRYPTPROV hCSP = NULL;
    DWORD      CredentialIndex;
    DWORD      cbSAI;
    DWORD      cbSAC;
    DWORD      cbCredential;
    BYTE *     pbCredential;
    BYTE *     pbSAI = NULL;
    BYTE *     pbSAC = NULL;
    BOOL       fIsPasswordNull = FALSE;
    HRESULT    hr;

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Hash the job into a unique identity.
    // It will be used for credential lookup.
    //

    hr = HashJobIdentity(hCSP, pwszJobPath, rgbIdentity);

    if (FAILED(hr))
    {
        CloseCSPHandle(hCSP);
        return(hr);
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Read SAI & SAC databases.
    //

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Does this identity exist in the LSA?
    //

    hr = SAIFindIdentity(rgbIdentity,
                         cbSAI,
                         pbSAI,
                         &CredentialIndex,
                         &fIsPasswordNull);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    else if (hr == S_OK)                    // Found it.
    {
        //
        // Index the credential associated with the identity.
        //

        hr = SACIndexCredential(CredentialIndex,
                                cbSAC,
                                pbSAC,
                                &cbCredential,
                                &pbCredential);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
        else if (hr == S_FALSE)
        {
            //
            // Credential not found? The SAC & SAI databases are out of sync.
            // This should *never* occur.
            //

            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        //
        // Generate key & decrypt the credentials.
        //

        RC2_KEY_INFO RC2KeyInfo;

        hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

        if (SUCCEEDED(hr))
        {
            //           *** Important ***
            //
            // The encrypted credentials passed are decrypted
            // *in-place*. Therefore, SAC buffer content has been
            // compromised; plus, the decrypted data must be zeroed
            // immediately following decryption (even in a failure
            // case).
            //
            // NB : The start of the credential refers to the
            //      credential identity. Skip over this to refer
            //      to the encrypted bits.
            //

            DWORD  cbEncryptedData = cbCredential - HASH_DATA_SIZE;
            BYTE * pbEncryptedData = pbCredential + HASH_DATA_SIZE;

            hr = DecryptCredentials(RC2KeyInfo,
                                    cbEncryptedData,
                                    pbEncryptedData,
                                    pjc);

            CHECK_HRESULT(hr);
            if (SUCCEEDED(hr))
            {
                // Don't leave the plain-text password on the heap.
                //
                SecureZeroMemory(pbEncryptedData, cbEncryptedData);

                //
                // If the SAI said this job has a null password, that
                // overrides the password read from the SAC.
                //
                if (fIsPasswordNull)
                {
                    pjc->fIsPasswordNull = TRUE;
                    SecureZeroMemory(pjc->wszPassword, sizeof pjc->wszPassword);
                    pjc->ccPassword = 0;
                }
            }
            // Clear key content.
            //
            SecureZeroMemory(&RC2KeyInfo, sizeof(RC2KeyInfo));
        }
    }
    else
    {
        hr = SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    }

ErrorExit:
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    //
    // Log an error & rest the SA security dbases SAI & SAC
    // if corruption is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //

        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                                (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HashJobIdentity
//
//  Synopsis:   calculate a hash from several pieces of data specific to the job file
//              that can help to uniquely identify the job and detect tampering
//
//  Arguments:  [hCSP]         -- handle to cryptographic service provider
//              [pwszFileName] -- job file name
//              [rgbHash]      -- hashed identity
//              [dwHashMethod  -- dword value indicating which hash method to use;
//                                Default if not specified is the latest method.
//
//  Returns:    HRESULT
//
//  Notes:      11/09/2002 - it was discovered that the value retrieved for domain name
//              (and possibly account name) may not always be the same case, thus causing
//              different hashes to be produced even though the domain had not changed,
//              and the file had not been touched.  Always forcing the names to upper case
//              prior to calculating the hash prevents such a change from affecting the
//              hash.  Removing the values from the hash calculation altogether also
//              avoids the problem and prevents localization from having negative affects
//              as well.  A new parameter, dwHashMethod, has been introduced to allow different
//              hashing methods to be employed to facilitate conversion of existing data.
//
//----------------------------------------------------------------------------
HRESULT
HashJobIdentity(
    HCRYPTPROV hCSP,
    LPCWSTR    pwszFileName,
    BYTE       rgbHash[],
    DWORD      dwHashMethod /* = 1 */)
{
    WCHAR                wszApplication[MAX_PATH + 1]       = L"";
    WCHAR                wszOwnerName[MAX_USERNAME + 1]     = L"";
    WCHAR                wszOwnerDomain[MAX_DOMAINNAME + 1] = L"";
    UUID                 JobID;
    FILETIME             ftCreationTime;
    PSECURITY_DESCRIPTOR pOwnerSecDescr                     = NULL;
    DWORD                cbOwnerSid;
    PSID                 pOwnerSid;
    DWORD                dwVolumeSerialNo;
    HRESULT              hr;

    hr = GetFileInformation(pwszFileName,
                            &cbOwnerSid,
                            &pOwnerSid,
                            &pOwnerSecDescr,
                            &JobID,
                            MAX_USERNAME + 1,
                            MAX_DOMAINNAME + 1,
                            MAX_PATH + 1,
                            wszOwnerName,
                            wszOwnerDomain,
                            wszApplication,
                            &ftCreationTime,
                            &dwVolumeSerialNo);

    if (SUCCEEDED(hr))
    {
        DWORD  cbHash  = HASH_DATA_SIZE;
        BYTE * pbHash  = rgbHash;

        if (dwHashMethod == 0)
        {
            hr = MarshalData(hCSP,
                             NULL,
                             HashAndSign,
                             &cbHash,
                             &pbHash,
                             7,
                             cbOwnerSid,
                             pOwnerSid,
                             sizeof(JobID),
                             &JobID,
                             (wcslen(wszOwnerName) + 1) * sizeof(WCHAR),
                             wszOwnerName,
                             (wcslen(wszOwnerDomain) + 1) * sizeof(WCHAR),
                             wszOwnerDomain,
                             (wcslen(wszApplication) + 1) * sizeof(WCHAR),
                             wszApplication,
                             sizeof(ftCreationTime),
                             &ftCreationTime,
                             sizeof(dwVolumeSerialNo),
                             &dwVolumeSerialNo);
        }
        else /* if (dwHashMethod == 1) */
        {
            hr = MarshalData(hCSP,
                             NULL,
                             HashAndSign,
                             &cbHash,
                             &pbHash,
                             5,
                             cbOwnerSid,
                             pOwnerSid,
                             sizeof(JobID),
                             &JobID,
                             (wcslen(wszApplication) + 1) * sizeof(WCHAR),
                             wszApplication,
                             sizeof(ftCreationTime),
                             &ftCreationTime,
                             sizeof(dwVolumeSerialNo),
                             &dwVolumeSerialNo);
        }

        schAssert(pbHash == rgbHash);
    }

    // BUGBUG  Is pOwnerSid leaked???

    delete pOwnerSecDescr;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GrantAccountBatchPrivilege
//
//  Synopsis:   Grant the account batch privilege.
//
//  Arguments:  [pAccountSid] -- Account set.
//
//  Arguments:  None.
//
//  Returns:    HRESULTs
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GrantAccountBatchPrivilege(PSID pAccountSid)
{
    HRESULT hr = S_OK;

    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    LSA_HANDLE            hPolicy;

    NTSTATUS Status = LsaOpenPolicy(NULL,
                                    &ObjectAttributes,
                                    POLICY_CREATE_ACCOUNT,
                                    &hPolicy);
    if (Status >= 0)
    {
        LSA_UNICODE_STRING PrivilegeString = {
            sizeof(SE_BATCH_LOGON_NAME) - 2,
            sizeof(SE_BATCH_LOGON_NAME),
            SE_BATCH_LOGON_NAME,
        };

        Status = LsaAddAccountRights(hPolicy, pAccountSid, &PrivilegeString, 1);
        if (Status < 0)
        {
            ERR_OUT("LsaAddAccountRights", Status);
        }

        LsaClose(hPolicy);
    }
    else
    {
        ERR_OUT("LsaOpenPolicy", Status);
    }

    if (Status < 0)
    {
        schAssert(!"Grant Batch Privilege failed, shouldn't have");
        DWORD err = RtlNtStatusToDosError(Status);
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   MarshalData
//
//  Synopsis:   [hCSP]            --
//              [phHash]          --
//              [MarshalFunction] --
//              [pcbSignature]    --
//              [ppbSignature]    --
//              [cArgs]           --
//              [...]             --
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
MarshalData(
    HCRYPTPROV       hCSP,
    HCRYPTHASH *     phHash,
    MARSHAL_FUNCTION MarshalFunction,
    DWORD *          pcbSignature,
    BYTE **          ppbSignature,
    DWORD            cArgs,
    ...)
{
#define COPYMEMORY(dest, src, size) { \
    CopyMemory(*dest, src, size);     \
    *(BYTE **)dest += size;           \
}

    HCRYPTHASH hHash       = NULL;
    DWORD      cbSignature = 0;
    BYTE *     pbSignature = NULL;
    HRESULT    hr          = S_OK;

    va_list pvarg;

    va_start(pvarg, cArgs);

    DWORD i, cbSize, cbData = 0;

    for (i = cArgs; i--; )
    {
        cbData += va_arg(pvarg, DWORD);
        va_arg(pvarg, BYTE *);
    }

    BYTE * pbData, * pb;

    pbData = pb = new BYTE[cbData];

    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    va_start(pvarg, cArgs);

    for (i = cArgs; i--; )
    {
        cbSize = va_arg(pvarg, DWORD);
        COPYMEMORY(&pb, va_arg(pvarg, BYTE *), cbSize);
    }

    if (MarshalFunction == Marshal)
    {
        //
        // Done. Return marshal data in the signature return args.
        //

        *pcbSignature = cbData;
        *ppbSignature = pbData;
        va_end(pvarg);
        return(S_OK);
    }

    //
    // Acquire a handle to an MD5 hashing object. MD5 is the most secure
    // hashing algorithm.
    //

    schAssert(hCSP != NULL);

#if DBG
    //
    // We must not be impersonating while calling the Crypto APIs.
    // If we are, the key data will go in the wrong hives.
    //
    HANDLE hToken;
    schAssert(!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken));
#endif

    if (!CryptCreateHash(hCSP,
                         CALG_MD5,              // Use MD5 hashing.
                         0,                     // MD5 is non-keyed.
                         0,                     // New key container.
                         &hHash))               // Returned handle.
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Hash and optionally sign the data. The hash is cached w/in the hash
    // object and returned upon signing.
    //

    if (!CryptHashData(hHash,
                       pbData,                  // Hash data.
                       cbData,                  // Hash data size.
                       0))                      // No special flags.
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if (MarshalFunction == HashAndSign)
    {
        //
        // First, determine necessary signature buffer size & allocate it.
        //

        if (!CryptSignHash(hHash,
                           AT_SIGNATURE,        // Signature private key.
                           NULL,                // No signature.
                           0,                   // Reserved.
                           NULL,                // NULL return buffer.
                           &cbSignature))       // Returned size.
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Caller can supply a buffer to return the signed data only with
        // the HashAndSign option. This is an optimization to reduce the
        // number of memory allocations with known data sizes such as
        // hashed data.
        //

        if (*pcbSignature)
        {
            if (*pcbSignature >= cbSignature)
            {
                //
                // Caller supplied a buffer & the signed data will fit in it.
                //

                pbSignature = *ppbSignature;
            }
            else
            {
                //
                // Caller supplied buffer insufficient size.
                // This is a developer error only.
                //

                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                schAssert(0 && "MarshalData insufficient buffer!");
                goto ErrorExit;
            }
        }
        else
        {
            pbSignature = new BYTE[cbSignature];

            if (pbSignature == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }

        //
        // Perform the actual signing.
        //

        if (!CryptSignHash(hHash,
                           AT_SIGNATURE,        // Signature private key.
                           NULL,                // No signature.
                           0,                   // Reserved.
                           pbSignature,         // Signature buffer.
                           &cbSignature))       // Buffer size.
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        *pcbSignature = cbSignature;
        *ppbSignature = pbSignature;
    }

    if (phHash != NULL)
    {
        *phHash = hHash;
        hHash   = NULL;
    }

ErrorExit:
    delete pbData;
    if (FAILED(hr))
    {
        //
        // Caller may have supplied the signature data buffer in the
        // HashAndSign option. If so, don't delete it.
        //

        if (pbSignature != *ppbSignature)
        {
            delete pbSignature;
        }
    }
    if (hHash != NULL) CryptDestroyHash(hHash);
    va_end(pvarg);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HashSid
//
//  Synopsis:   [hCSP]    --
//              [pSid]    --
//              [rgbHash] --
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
HashSid(
    HCRYPTPROV hCSP,
    PSID       pSid,
    BYTE       rgbHash[])
{
    DWORD                      rgdwSubAuthorities[SID_MAX_SUB_AUTHORITIES];
    SID_IDENTIFIER_AUTHORITY * pAuthority;

    //
    // Validate the sid passed. This is important since the win32
    // documentation for the sid-related api states the returns are
    // undefined if the functions fail.
    //

    if (!IsValidSid(pSid))
    {
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return(E_UNEXPECTED);
    }

    //
    // Fetch the sid identifier authority.
    // BUGBUG : I hate this. The doc states if these functions fail, the
    //          return value is undefined. How to determine failure?
    //

    pAuthority = GetSidIdentifierAuthority(pSid);

    //
    // Fetch all sid subauthorities. Copy them to a temporary buffer in
    // preparation for hashing.
    //

    PUCHAR pcSubAuthorities = GetSidSubAuthorityCount(pSid);

    UCHAR  cSubAuthoritiesCopied = min(*pcSubAuthorities,
                                       SID_MAX_SUB_AUTHORITIES);

    for (UCHAR i = 0; i < cSubAuthoritiesCopied; i++)
    {
        rgdwSubAuthorities[i] = *GetSidSubAuthority(pSid, i);
    }

    DWORD  cbHash = HASH_DATA_SIZE;
    BYTE * pbHash = rgbHash;

    HRESULT hr = MarshalData(hCSP,
                             NULL,
                             HashAndSign,
                             &cbHash,
                             &pbHash,
                             2,
                             sizeof(SID_IDENTIFIER_AUTHORITY),
                             pAuthority,
                             cSubAuthoritiesCopied * sizeof(DWORD),
                             rgdwSubAuthorities);

    schAssert(pbHash == rgbHash);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitSS
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
InitSS(void)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    NTSTATUS Status;
    HRESULT  hr;

    gccComputerName = sizeof(gwszComputerName) / sizeof(TCHAR);

    if (!GetComputerName(gwszComputerName, &gccComputerName))
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // gwszComputerName will be munged.  Save an unmunged copy in
    // gpwszComputerName.
    //
    gpwszComputerName = new WCHAR[gccComputerName + 1];
    if (gpwszComputerName == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    StringCchCopy(gpwszComputerName, gccComputerName + 1, gwszComputerName);

    //
    // gwszComputerName is used only for credential encryption.  The
    // computer might have been renamed since the credential database was
    // created, so the credential database might have been encrypted using
    // a different computer name than the present one.  If a computer name
    // is stored in the registry, use that one rather than the present name.
    // If no name is stored in the registry, store the present one.
    //

    {
        //
        // Open the schedule agent key
        //
        HKEY hSchedKey;
        long lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0,
                                 KEY_QUERY_VALUE | KEY_SET_VALUE, &hSchedKey);
        if (lErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Get the saved computer name
        //
        WCHAR wszOldName[MAX_COMPUTERNAME_LENGTH + 2];
        DWORD dwType;
        DWORD cb = sizeof(wszOldName);
        lErr = RegQueryValueEx(hSchedKey, SCH_OLDNAME_VALUE, NULL, &dwType,
                               (LPBYTE)wszOldName, &cb);

        if (lErr != ERROR_SUCCESS || dwType != REG_SZ)
        {
            schDebugOut((DEB_ERROR, "InitSS: Couldn't read OldName: err %u, "
                                    "type %u.  Writing '%ws'\n",
                         lErr, dwType, gwszComputerName));
            //
            // Write the present computer name
            //
            lErr = RegSetValueEx(hSchedKey, SCH_OLDNAME_VALUE, NULL, REG_SZ,
                                 (LPBYTE) gwszComputerName,
                                 (gccComputerName + 1) * sizeof(WCHAR));
            if (lErr != ERROR_SUCCESS)
            {
                schDebugOut((DEB_ERROR, "InitSS: Couldn't write OldName: err %u\n",
                             lErr));
            }
        }
        else if (lstrcmpi(gwszComputerName, wszOldName) != 0)
        {
            //
            // Use the stored name instead of the present name
            //
            schDebugOut((DEB_ERROR, "InitSS: Using OldName '%ws'\n", wszOldName));
            StringCchCopy(gwszComputerName, MAX_COMPUTERNAME_LENGTH + 2, wszOldName);
            gccComputerName = (cb / sizeof(WCHAR)) - 1;
        }

        //
        // Close the key
        //
        RegCloseKey(hSchedKey);
    }


    LSA_HANDLE hPolicy;

    if (!(LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_VIEW_LOCAL_INFORMATION,
                        &hPolicy) >= 0))
    {
        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    Status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyAccountDomainInformation,
                                       (void **)&gpDomainInfo);

    LsaClose(hPolicy);

    if (!(Status >= 0))
    {
        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    MungeComputerName(gccComputerName);

    gpMachineSid  = gpDomainInfo->DomainSid;
    gcbMachineSid = GetLengthSid(gpDomainInfo->DomainSid);

    DWORD dwRet = StartupAuditing();
    return _HRESULT_FROM_WIN32(dwRet);    

ErrorExit:
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitSS
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitSS(void)
{
    ShutdownAuditing();
    
    if (gpDomainInfo != NULL)
    {
        LsaFreeMemory(gpDomainInfo);
        gpDomainInfo = NULL;
    }

    if (gpwszComputerName != NULL)
    {
        delete gpwszComputerName;
        gpwszComputerName = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MungeComputerName
//
//  Synopsis:
//
//  Arguments:  [psidUser]           --
//              [ccAccountName]      --
//              [wszAccountName]     --
//              [wszAccountNameSize] --
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC void
MungeComputerName(DWORD ccComputerName)
{
    WCHAR * pwszStart = gwszComputerName;

    while (*pwszStart) pwszStart++;

    gwszComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L'\0';

    //
    // Set the character following the computername to a '+' or '-' depending
    // on the value of ccAccountName (if the 2nd bit is set).
    //

    if ((ccComputerName - 1) & 0x00000001)
    {
        gwszComputerName[MAX_COMPUTERNAME_LENGTH] = L'+';
    }
    else
    {
        gwszComputerName[MAX_COMPUTERNAME_LENGTH] = L'-';
    }

    //
    // Fill any intermediary buffer space with space characters. Note, no
    // portion of the computername is overwritten.
    //
    // NB : The astute reader will notice the subtle difference in behavior
    //      if the computername should be of maximum length. In this case,
    //      the '+' or '-' character written above will be overwritten with
    //      a space.
    //

    WCHAR * pwszEnd = &gwszComputerName[MAX_COMPUTERNAME_LENGTH - 1];

    if (pwszEnd > pwszStart)
    {
        while (pwszEnd != pwszStart)
        {
            *pwszEnd-- = L' ';
        }
    }

    *pwszStart = L' ';
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCSPHandle
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetCSPHandle(HCRYPTPROV * phCSP)
{
#if DBG
    //
    // We must not be impersonating while calling the Crypto APIs.
    // If we are, the key data will go in the wrong hives.
    //
    HANDLE hToken;
    schAssert(!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken));
#endif

    HRESULT    hr;

    if (!CryptAcquireContext(phCSP,             // Returned CSP handle.
                             g_tszSrvcName,     // Default Key container.
                                                    // MSFT RSA Base Provider.
                             NULL,              // Default user provider.
                             PROV_RSA_FULL,     // Default provider type.
                             0))                // No special flags.
    {
        DWORD Status = GetLastError();

        if (Status == NTE_KEYSET_ENTRY_BAD || Status == NTE_BAD_KEYSET)
        {
            //
            // Delete the keyset and try again.
            // Ignore this return code.
            //

            if (!CryptAcquireContext(phCSP,
                                     g_tszSrvcName,
                                     NULL,
                                     PROV_RSA_FULL,
                                     CRYPT_DELETEKEYSET))
            {
                ERR_OUT("CryptAcquireContext(delete)", GetLastError());
            }
            else
            {
                LogServiceError(IERR_SECURITY_KEYSET_CORRUPT, 0, IDS_HELP_HINT_DBASE_CORRUPT);
            }
        }
        else
        {
            //
            // Print the error in debug builds, but otherwise ignore it.
            //
            ERR_OUT("CryptAcquireContext(open)", Status);
        }

        //
        // Assume this is the first time this code has been run on this
        // particular machine.  Must create a new keyset & key.
        //

        if (!CryptAcquireContext(phCSP,
                                 g_tszSrvcName,
                                 NULL,
                                 PROV_RSA_FULL,
                                 CRYPT_NEWKEYSET))  // New keyset.
        {
            Status = GetLastError();
            if (Status == NTE_EXISTS)
            {
                //
                // Our assumption was wrong!
                // Delete the keyset and try again.
                // Ignore this return code.
                //
                if (!CryptAcquireContext(phCSP,
                                                      g_tszSrvcName,
                                                      NULL,
                                                      PROV_RSA_FULL,
                                                      CRYPT_DELETEKEYSET))
                {
                    hr = _HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                    return(hr);
                }
                else
                {
                    LogServiceError(IERR_SECURITY_KEYSET_CORRUPT, 0, IDS_HELP_HINT_DBASE_CORRUPT);
                }
                
                //
                // Must now create a new keyset & key.
                //
                if (!CryptAcquireContext(phCSP,
                                                      g_tszSrvcName,
                                                      NULL,
                                                      PROV_RSA_FULL,
                                                      CRYPT_NEWKEYSET))  // New keyset.
                {
                    hr = _HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                    return(hr);
                }
            }
            else
            {
                hr = _HRESULT_FROM_WIN32(Status);
                CHECK_HRESULT(hr);
                return(hr);
            }
        }

        HCRYPTKEY hKey;

        //
        // The upper 16 bits of the 3rd parm to CryptGenKey specify the key
        // size in bits.  The size of the signature from CryptSignHash will
        // be equal to the size of this key.  Since we rely on the signature
        // being a specific size, we must explicitly specify the key size.
        //
        if (!CryptGenKey(*phCSP,
                         AT_SIGNATURE,      // Digital signature.
                         (HASH_DATA_SIZE * 8) << 16,    // see above
                         &hKey ))
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(hr);
        }
        CryptDestroyKey(hKey);              // No further use for
                                            // the key.
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseCSPHandle
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CloseCSPHandle(HCRYPTPROV hCSP)
{
    CryptReleaseContext(hCSP, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ComputeCredentialKey
//
//  Synopsis:
//
//  Arguments:  [hCSP]        --
//              [pRC2KeyInfo] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
ComputeCredentialKey(HCRYPTPROV hCSP, RC2_KEY_INFO * pRC2KeyInfo)
{
    BYTE       rgbHash[HASH_DATA_SIZE];
    HCRYPTHASH hHash  = NULL;
    DWORD      cbHash = 0;
    BYTE *     pbHash = NULL;
    HRESULT    hr     = S_OK;
    DWORD      i;

    //
    // Hash misc. global data.
    //
    // NB : MarshalData actually does nothing with the 3rd & 4th arguments
    //      with the Hash option.
    //

    hr = MarshalData(hCSP,
                     &hHash,
                     Hash,
                     &cbHash,
                     &pbHash,
                     2,
                     (gccComputerName & 0x00000001 ?
                        (MAX_COMPUTERNAME_LENGTH + 2) * sizeof(WCHAR) :
                            sizeof(DWORD)),
                     (gccComputerName & 0x00000001 ?
                        (BYTE *)gwszComputerName : (BYTE *)&gdwKeyElement),
                     gcbMachineSid,
                     gpMachineSid);

    //
    // Generate the key.
    //
    // NB : In place of CryptDeriveKey, statically generate the key. This
    //      is done to work around Crypto restrictions in France.
    //
    // Old:
    //
    //     CryptDeriveKey(ghCSP, CALG_RC2, hHash, 0, &hKey);
    //
    // New:
    //

    cbHash = sizeof(rgbHash);

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Clear RC2KeyInfo content.
    //
    schAssert(pRC2KeyInfo != NULL);
    SecureZeroMemory(pRC2KeyInfo, sizeof(*pRC2KeyInfo));

    //
    // Set the upper eleven bytes to 0x00 because Derive key by default
    // uses 11 bytes of 0x00 salt
    //
    SecureZeroMemory(rgbHash + 5, 11);

    //
    // Use the 5 bytes (40 bits) of the hash as a key.
    //
    RC2KeyEx(pRC2KeyInfo->rgwKeyTable, rgbHash, 16, 40);

ErrorExit:
    if (hHash != NULL) CryptDestroyHash(hHash);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   EncryptCredentials
//
//  Synopsis:
//
//  Arguments:  [RC2KeyInfo]       --
//              [pwszAccount]      --
//              [pwszDomain]       --
//              [pwszPassword]     --
//              [pSid]             --
//              [pcbEncryptedData] --
//              [ppbEncryptedData] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
EncryptCredentials(
    const RC2_KEY_INFO & RC2KeyInfo,
    LPCWSTR              pwszAccount,
    LPCWSTR              pwszDomain,
    LPCWSTR              pwszPassword,
    PSID                 pSid,
    DWORD *              pcbEncryptedData,
    BYTE **              ppbEncryptedData)
{
    BYTE    rgbBuf[RC2_BLOCKLEN];
    WCHAR * pwszPasswordLocal;
    DWORD   cbAccount;
    DWORD   cbDomain;
    DWORD   cbPassword;
    DWORD   cbData          = 0;
    DWORD   cbEncryptedData = 0;
    DWORD   cbPartial;
    DWORD   dwPadVal;
    BYTE *  pbData          = NULL;
    BYTE *  pbEncryptedData = NULL;
    HRESULT hr;

    *pcbEncryptedData = 0;
    *ppbEncryptedData = NULL;

    if (pwszAccount == NULL || pwszDomain == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    if (pwszPassword == NULL)
    {
        //
        // In the SAC, a NULL password is stored the same as a "" password.
        // (The distinction is made per-job, in the SAI.)
        //
        pwszPasswordLocal = L"";
    }
    else
    {
        pwszPasswordLocal = (WCHAR *)pwszPassword;
    }

    cbAccount  = wcslen(pwszAccount) * sizeof(WCHAR);
    cbDomain   = wcslen(pwszDomain) * sizeof(WCHAR);
    cbPassword = wcslen(pwszPasswordLocal) * sizeof(WCHAR);

    hr = MarshalData(NULL,
                     NULL,
                     Marshal,
                     &cbData,
                     &pbData,
                     6,
                     sizeof(cbAccount),
                     &cbAccount,
                     cbAccount,
                     pwszAccount,
                     sizeof(cbDomain),
                     &cbDomain,
                     cbDomain,
                     pwszDomain,
                     sizeof(cbPassword),
                     &cbPassword,
                     cbPassword,
                     pwszPasswordLocal);

    if (SUCCEEDED(hr))
    {
        //
        // NB : This code exists in place of a call to CryptEncrypt to
        //      work around France's Crypto API restrictions. Since
        //      CryptEncrypt cannot be called directly, the code from
        //      the API to accomplish cypher block encryption is duplicated
        //      here.
        //

        //
        // Calculate the number of pad bytes necessary (must be a multiple)
        // of RC2_BLOCKLEN). If already a multiple of blocklen, do a full
        // block of pad.
        //

        cbPartial = (cbData % RC2_BLOCKLEN);

        dwPadVal = RC2_BLOCKLEN - cbPartial;

        cbEncryptedData = cbData + dwPadVal;

        //
        // Allocate a buffer for the encrypted data.
        //

        pbEncryptedData = new BYTE[cbEncryptedData];

        if (pbEncryptedData == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        CopyMemory(pbEncryptedData, pbData, cbData);

        if (dwPadVal)
        {
            //
            // Fill the pad with a value equal to the length of the padding,
            // so decrypt will know the length of the original data and as
            // a simple integrity check.
            //

            memset(pbEncryptedData + cbData, (INT)dwPadVal, (size_t)dwPadVal);
        }

        //
        // Perform the encryption - cypher block.
        //

        *pcbEncryptedData = cbEncryptedData;
        *ppbEncryptedData = pbEncryptedData;

        while (cbEncryptedData)
        {
            //
            // Put the plaintext into a temporary buffer, then encrypt the
            // data back into the allocated buffer.
            //

            CopyMemory(rgbBuf, pbEncryptedData, RC2_BLOCKLEN);

            CBC(RC2,
                RC2_BLOCKLEN,
                pbEncryptedData,
                rgbBuf,
                (void *)RC2KeyInfo.rgwKeyTable,
                ENCRYPT,
                (BYTE *)RC2KeyInfo.rgbIV);

            pbEncryptedData += RC2_BLOCKLEN;
            cbEncryptedData -= RC2_BLOCKLEN;
        }
    }

    pbEncryptedData = NULL;         // For delete below.

ErrorExit:
    delete pbData;
    delete pbEncryptedData;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipDomainName
//
//  Synopsis:   Return the relative username if the username passed is in
//              distinguished form. eg: return 'Joe' from 'DogFood\Joe'.
//
//  Arguments:  [pwszUserName] -- User name.
//
//  Returns:    Pointer index to/into pwszUserName.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
LPWSTR
SkipDomainName(LPCWSTR pwszUserName)
{
    LPWSTR pwsz = (LPWSTR)pwszUserName;

    while (*pwsz && *pwsz != '\\')
    {
        pwsz++;
    }

    if (*pwsz == L'\\')
    {
        return(++pwsz);
    }

    return((LPWSTR)pwszUserName);
}

//+---------------------------------------------------------------------------
//
//  Function:   DecryptCredentials
//
//  Synopsis:
//
//  Arguments:  [RC2KeyInfo]      --
//              [cbEncryptedData] --
//              [pbEncryptedData] --
//              [pjc]             --
//              [fDecryptInPlace] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
DecryptCredentials(
    const RC2_KEY_INFO & RC2KeyInfo,
    DWORD                cbEncryptedData,
    BYTE *               pbEncryptedData,
    PJOB_CREDENTIALS     pjc,
    BOOL                 fDecryptInPlace)
{
    BYTE    rgbBuf[RC2_BLOCKLEN];
    DWORD   cbDecryptedData = cbEncryptedData;
    BYTE *  pbDecryptedData;
    DWORD   BytePos;
    DWORD   dwPadVal;
    DWORD   i;
    DWORD   cbAccount, cbDomain, cbPassword;
    BYTE *  pbAccount, * pbDomain, * pbPassword;
    BOOL    fIsPasswordNull = FALSE;
    BYTE *  pb;
    HRESULT hr = S_OK;

    //
    // The encrypted data length *must* be a multiple of RC2_BLOCKLEN.
    //

    if (cbEncryptedData % RC2_BLOCKLEN)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return(E_UNEXPECTED);
    }

    //
    // Decrypt overwrites the encrypted data with the decrypted data.
    // If fDecryptInPlace is FALSE, allocate an additional buffer for
    // the decrypted bits, so the encrypted data buffer will not be
    // overwritten.
    //

    if (!fDecryptInPlace)
    {
        pbDecryptedData = new BYTE[cbEncryptedData];

        if (pbDecryptedData == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }
        CopyMemory(pbDecryptedData, pbEncryptedData, cbEncryptedData);
    }
    else
    {
        pbDecryptedData = pbEncryptedData;
    }

    //
    // NB : This code exists in place of a call to CryptDencrypt to
    //      work around France's Crypto API restrictions. Since
    //      CryptDecrypt cannot be called directly, the code from
    //      the API to accomplish cypher block decryption is duplicated
    //      here.
    //

    for (BytePos = 0; (BytePos + RC2_BLOCKLEN) <= cbEncryptedData;
         BytePos += RC2_BLOCKLEN)
    {
        //
        // Use a temporary buffer to store the encrypted data.
        //

        CopyMemory(rgbBuf, pbDecryptedData + BytePos, RC2_BLOCKLEN);

        CBC(RC2,
            RC2_BLOCKLEN,
            pbDecryptedData + BytePos,
            rgbBuf,
            (void *)RC2KeyInfo.rgwKeyTable,
            DECRYPT,
            (BYTE *)RC2KeyInfo.rgbIV);
    }

    //
    // Verify the padding and remove the pad size from the data length.
    // NOTE: The padding is filled with a value equal to the length
    // of the padding and we are guaranteed >= 1 byte of pad.
    //
    // NB : If the pad is wrong, the user's buffer is hosed, because
    //      we've decrypted into the user's buffer -- can we re-encrypt it?
    //

    dwPadVal = (DWORD)*(pbDecryptedData + cbEncryptedData - 1);

    if (dwPadVal == 0 || dwPadVal > (DWORD) RC2_BLOCKLEN)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Make sure all the (rest of the) pad bytes are correct.
    //

    for (i = 1; i < dwPadVal; i++)
    {
        if (pbDecryptedData[cbEncryptedData - (i + 1)] != dwPadVal)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    pb = pbDecryptedData;

    //
    // Have to do the following incantation since otherwise we'd likely
    // fault on an unaligned fetch.
    //
    // Cache account name size & position.
    //

    CopyMemory(&cbAccount, pb, sizeof(cbAccount));
    pbAccount = pb + sizeof(cbAccount);
    pb = pbAccount + cbAccount;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbAccount > (MAX_USERNAME * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Cache domain name size & position.
    //

    CopyMemory(&cbDomain, pb, sizeof(cbDomain));
    pbDomain = pb + sizeof(cbDomain);
    pb = pbDomain + cbDomain;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbDomain > (MAX_DOMAINNAME * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Cache password size & position.
    //

    CopyMemory(&cbPassword, pb, sizeof(cbPassword));
    pbPassword = pb + sizeof(cbPassword);
    // In the IE 5 release of the Task Scheduler, a NULL password was denoted
    // by a size of 0xFFFFFFFF in the SAC.  The following check lets us read
    // databases created by the IE 5 TS.
    if (cbPassword == NULL_PASSWORD_SIZE)
    {
        fIsPasswordNull = TRUE;
        cbPassword = 0;
    }
    pb = pbPassword + cbPassword;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbPassword > (MAX_PASSWORD * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Finally, copy the return data.
    //

    CopyMemory(pjc->wszAccount, pbAccount, cbAccount);
    *(WCHAR *)(((BYTE *)pjc->wszAccount) + cbAccount) = L'\0';
    pjc->ccAccount = cbAccount / sizeof(WCHAR);

    CopyMemory(pjc->wszDomain, pbDomain, cbDomain);
    *(WCHAR *)(((BYTE *)pjc->wszDomain) + cbDomain) = L'\0';
    pjc->ccDomain = cbDomain / sizeof(WCHAR);

    CopyMemory(pjc->wszPassword, pbPassword, cbPassword);
    *(WCHAR *)(((BYTE *)pjc->wszPassword) + cbPassword) = L'\0';
    pjc->ccPassword = cbPassword / sizeof(WCHAR);

    pjc->fIsPasswordNull = fIsPasswordNull;

ErrorExit:
    if (!fDecryptInPlace) delete pbDecryptedData;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CredentialLookupAndAccessCheck
//
//  Synopsis:
//
//  Arguments:  [hCSP]             --
//              [pSid]             --
//              [cbSAC]            --
//              [pbSAC]            --
//              [pCredentialIndex] --
//              [rgbHashedSid]     --
//              [pcbCredential]    --
//              [ppbCredential]    --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
CredentialLookupAndAccessCheck(
    HCRYPTPROV hCSP,
    PSID       pSid,
    DWORD      cbSAC,
    BYTE *     pbSAC,
    DWORD *    pCredentialIndex,
    BYTE       rgbHashedSid[],
    DWORD *    pcbCredential,
    BYTE **    ppbCredential)
{
    HRESULT hr;

    // Either pSid or rgbHashedSid must be specified.
    //
    schAssert(rgbHashedSid != NULL && (pSid != NULL || *rgbHashedSid));

    if (pSid != NULL)
    {
        if (!IsValidSid(pSid))
        {
            CHECK_HRESULT(E_UNEXPECTED);
            return(E_UNEXPECTED);
        }

        hr = HashSid(hCSP, pSid, rgbHashedSid);

        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    // Find the credential in the SAC associated with the account sid. The
    // hashed account sid is utilized as a SAC database key.
    //

    DWORD  cbEncryptedData;
    BYTE * pbEncryptedData;

    hr = SACFindCredential(rgbHashedSid,
                           cbSAC,
                           pbSAC,
                           pCredentialIndex,
                           &cbEncryptedData,
                           &pbEncryptedData);

    if (hr == S_OK)
    {
        //
        // Found it. Does the caller have access to this credential?
        //

        BYTE * pbCredential = pbEncryptedData - HASH_DATA_SIZE;

        if (CredentialAccessCheck(hCSP, pbCredential))
        {
            // Update out ptrs.
            //
            *ppbCredential = pbCredential;
            CopyMemory(pcbCredential,
                       *ppbCredential - sizeof(*pcbCredential),
                       sizeof(*pcbCredential));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }
    }
    else if (hr == S_FALSE)
    {
        //
        // Didn't find the credential.
        //

        hr = SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CredentialAccessCheck
//
//  Synopsis:   Determine if the RPC client has access to the credential
//              indicated.
//
//  Arguments:  [hCSP]                 -- CSP provider handle (for use with
//                                        Crypto API).
//              [pbCredentialIdentity] -- Credential identity.
//
//  Returns:    TRUE  -- RPC client has permission to access this credential.
//              FALSE -- RPC client doesn't have credential access or an
//                       unexpected error occurred.
//
//  Notes:                  ** Important **
//
//              Thread impersonation is performed in this routine via
//              RpcImpersonateClient; therefore, it is assumed only RPC
//              threads enter it.
//
//----------------------------------------------------------------------------
STATIC BOOL
CredentialAccessCheck(
    HCRYPTPROV hCSP,
    BYTE *     pbCredentialIdentity)
{
    RPC_STATUS RpcStatus;

    //
    // Impersonate the caller.
    //

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        CHECK_HRESULT(RpcStatus);
        return(FALSE);
    }

    HANDLE hToken;
    BOOL   bRet;

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken))
    {
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    //
    // End impersonation, but don't close the token yet.
    // (We must not be impersonating when we call HashSid, which is
    // called by MatchThreadCallerAgainstCredential.)
    //
    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        ERR_OUT("RpcRevertToSelf", RpcStatus);
        schAssert(!"RpcRevertToSelf failed");
    }

    //
    // Does the thread caller's hashed SID match the credential identity.
    // If so, the caller's account is the same as that specified in the
    // credentials.
    //

    if (!(bRet = MatchThreadCallerAgainstCredential(hCSP,
                                                    hToken,
                                                    pbCredentialIdentity)))
    {
        //
        // Nope. Thread caller account/credential account mismatch.
        // Is the caller an administrator?
        //

        bRet = IsThreadCallerAnAdmin(hToken);
    }

    CloseHandle(hToken);

    return(bRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   MatchThreadCallerAgainstCredential
//
//  Synopsis:   Hash the user SID of the thread indicated and compare it
//              against the credential identity passed. A credential identity
//              is the hashed SID of the associated account.
//
//  Arguments:  [hCSP]                 -- CSP provider handle (for use with
//                                        Cryto API).
//              [hThreadToken]         -- Obtain the user SID from this
//                                        thread.
//              [pbCredentialIdentity] -- Matched credential identity.
//
//  Returns:    TRUE  -- Match
//              FALSE -- No match or an error occurred.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC BOOL
MatchThreadCallerAgainstCredential(
    HCRYPTPROV hCSP,
    HANDLE     hThreadToken,
    BYTE *     pbCredentialIdentity)
{
    BYTE         rgbTokenInformation[USER_TOKEN_STACK_BUFFER_SIZE];
    TOKEN_USER * pTokenUser = (TOKEN_USER *)rgbTokenInformation;
    DWORD        cbReturnLength;
    DWORD        Status     = ERROR_SUCCESS;

    if (!GetTokenInformation(hThreadToken,
                             TokenUser,
                             pTokenUser,
                             USER_TOKEN_STACK_BUFFER_SIZE,
                             &cbReturnLength))
    {
        //
        // Buffer space should have been sufficient. Check if we goofed.
        //

        schAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return(FALSE);
    }

    //
    // Hash the user's SID.
    //

    BYTE rgbHashedSid[HASH_DATA_SIZE] = { 0 };

    if (SUCCEEDED(HashSid(hCSP, pTokenUser->User.Sid, rgbHashedSid)))
    {
        if (memcmp(pbCredentialIdentity, rgbHashedSid, HASH_DATA_SIZE) == 0)
        {
            return(TRUE);
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
        }
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ScavengeSASecurityDBase
//
//  Synopsis:   Enumerate the jobs folder and remove identities in the SAI
//              for which no current jobs hash to. Note, SAC credentials
//              are also removed if the removed identity was the last to be
//              associated with it.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      Should read of any job fail, for any reason, the scavenge
//              task is abandoned. Reason is, if the removal process was
//              to continue anyway, credentials might be removed for existent
//              jobs.
//
//              The service state is checked periodically as this could
//              potentially be a lengthy routine time-wise. Bail as soon
//              as service stop or service stop pending is detected.
//
//----------------------------------------------------------------------------
void
ScavengeSASecurityDBase(void)
{
    TCHAR              tszSearchPath[MAX_PATH + 1];
    BYTE               rgbIdentity[HASH_DATA_SIZE];
    WIN32_FIND_DATA    fd;
    JOB_IDENTITY_SET * rgIdentitySet = NULL;
    HRESULT            hr            = S_OK;
    HANDLE             hFileEnum;
    DWORD              dwZero        = 0;
    DWORD              i, j;
    DWORD              iConcatenation;
    DWORD              dwRet;
    DWORD              dwSetCount    = 0;
    DWORD              dwSetSubCount;
    DWORD              cbIdentitySetArraySize;
    BYTE *             pbSet;
    BOOL               fDirty        = FALSE;

    //
    // Build the enumeration search path.
    //

    StringCchCopy(tszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    StringCchCat(tszSearchPath, MAX_PATH + 1, EXTENSION_WILDCARD TSZ_JOB);

    //
    // Initialize the enumeration.
    //

    if ((hFileEnum = FindFirstFile(tszSearchPath,
                                   &fd)) == INVALID_HANDLE_VALUE)
    {
        //
        // Either no jobs, or an error occurred.
        //

        dwRet = GetLastError();

        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            EnterCriticalSection(&gcsSSCritSection);

            //
            // No files found. Reset SAI & SAC by writing four bytes of
            // zeros into each.
            //
            hr = WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero,
                                    sizeof(dwZero), (BYTE *)&dwZero);
            CHECK_HRESULT(hr);

            LeaveCriticalSection(&gcsSSCritSection);
        }
        else
        {
            CHECK_HRESULT(_HRESULT_FROM_WIN32(dwRet));
        }

        return;
    }

    DWORD      cbSAI;
    DWORD      cbSAC;
    BYTE *     pbSAI = NULL;
    BYTE *     pbSAC = NULL;
    BYTE *     pbSAIEnd;
    BYTE *     pb;
    HCRYPTPROV hCSP = NULL;

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        return;
    }

    EnterCriticalSection(&gcsSSCritSection);

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if (cbSAI <= SAI_HEADER_SIZE)
    {
        //
        // Database empty.
        //

        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Some background first. The SAI consists of an array of arrays. The
    // first dimension represents the set of job identities per credential
    // in the SAC. SAI/SAC indices are associative in this case. The set of
    // job identities at SAI row[n] correspond to the credential at SAC
    // row[n].
    //
    // We need to construct an SAI pending deletion data structure. It will
    // consist of an array of JOB_IDENTITY_SET structures, in which each
    // structure refers to an array of pointers to job identities in the
    // SAI (literally indexing the SAI).
    //
    // Once the data structure is built and initialized, we'll enumerate the
    // jobs in the local tasks folder. For each job found, the corresponding
    // job identity pointer in the job identity set array will be set to NULL.
    // Upon completion of the enumeration, the non-NULL job identity ptr
    // entries within the job identity set array refer to non-existent jobs.
    // The job identitites these entries refer to are removed from the SAI,
    // and the associated credential in the SAC, if there are no longer
    // entries in the SAI associated with it.
    //
    // First, allocate the array.
    //

    pb = pbSAI + USN_SIZE;

    CopyMemory(&dwSetCount, pb, sizeof(dwSetCount));
    pb += sizeof(dwSetCount);

    cbIdentitySetArraySize = dwSetCount * sizeof(JOB_IDENTITY_SET);

    rgIdentitySet = (JOB_IDENTITY_SET *)LocalAlloc(LMEM_FIXED,
                                                   cbIdentitySetArraySize);

    if (rgIdentitySet == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    SecureZeroMemory(rgIdentitySet, cbIdentitySetArraySize);

    pb       = pbSAI + SAI_HEADER_SIZE;
    pbSAIEnd = pbSAI + cbSAI;

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Now allocate, intialize individual identity sets.
    //

    for (i = 0; i < dwSetCount; i++)
    {
        //
        // Check boundary.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pb += sizeof(dwSetSubCount);

        BYTE ** rgpbIdentity = (BYTE **)LocalAlloc(
                                            LMEM_FIXED,
                                            sizeof(BYTE *) * dwSetSubCount);

        if (rgpbIdentity == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        rgIdentitySet[i].pbSetStart    = pb;
        rgIdentitySet[i].dwSetSubCount = dwSetSubCount;
        rgIdentitySet[i].rgpbIdentity  = rgpbIdentity;

        for (j = 0; j < dwSetSubCount; j++)
        {
            rgpbIdentity[j] = pb;
            pb += HASH_DATA_SIZE;

            if (pb > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Enumerate job objects in the task's folder directory. Set
    // corresponding job identity ptrs in the job identity set array to
    // NULL for existent jobs.
    //

    //
    // First, obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Must concatenate the filename returned from the enumeration onto
    // the folder path.
    //

    StringCchCopy(tszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    iConcatenation = lstrlenW(g_TasksFolderInfo.ptszPath);
    tszSearchPath[iConcatenation++] = L'\\';

    for (;;)
    {
        //
        // Append the filename to the folder path.
        //

        tszSearchPath[iConcatenation] = L'\0';
        StringCchCat(tszSearchPath, MAX_PATH + 1, fd.cFileName);

        //
        // Hash the job into a unique identity.
        //

        hr = HashJobIdentity(hCSP, tszSearchPath, rgbIdentity);

        if (FAILED(hr))
        {
            //
            // Must bail if the hash fails. If this is ignored, one, or more,
            // identities may be removed for existent jobs - not good.
            //
            // TBD : Log error.
            //

            goto ErrorExit;
        }

        //
        // Does an identity exist in the SAI for this job? If so, NULL out
        // the corresponding entry in the job identity set array.
        //

        DWORD  CredentialIndex;
        BYTE * pbIdentity;

        hr = SAIFindIdentity(rgbIdentity,
                             cbSAI,
                             pbSAI,
                             &CredentialIndex,
                             NULL,
                             &pbIdentity,
                             NULL,
                             &pbSet);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        if (pbIdentity != NULL)
        {
            for (i = 0; i < dwSetCount; i++)
            {
                for (j = 0; j < rgIdentitySet[i].dwSetSubCount; j++)
                {
                    if (pbIdentity == rgIdentitySet[i].rgpbIdentity[j])
                    {
                        rgIdentitySet[i].rgpbIdentity[j] = NULL;
                        break;
                    }
                }
            }
        }

        if (!FindNextFile(hFileEnum, &fd))
        {
            dwRet = GetLastError();

            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                hr = _HRESULT_FROM_WIN32(GetLastError());
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Non-NULL entries in the identity set array refer to job identities in
    // the SAI to be removed. Mark them for removal.
    //

    for (i = 0; i < dwSetCount; i++)
    {
        if (rgIdentitySet[i].rgpbIdentity != NULL)
        {
            dwSetSubCount = rgIdentitySet[i].dwSetSubCount;

            for (j = 0; j < dwSetSubCount; j++)
            {
                if (rgIdentitySet[i].rgpbIdentity[j] != NULL)
                {
                    MARK_DELETED_ENTRY(rgIdentitySet[i].rgpbIdentity[j]);
                    rgIdentitySet[i].dwSetSubCount--;
                    fDirty = TRUE;

                    if (rgIdentitySet[i].dwSetSubCount == 0)
                    {
                        //
                        // Last identity in set. Mark associated SAC
                        // credential for removal also.
                        //

                        DWORD  cbCredential;
                        BYTE * pbCredential;

                        hr = SACIndexCredential(i,
                                                cbSAC,
                                                pbSAC,
                                                &cbCredential,
                                                &pbCredential);

                        if (hr == S_FALSE)
                        {
                            //
                            // This should *never* happen. Consider the
                            // database corrupt if so.
                            //

                            ASSERT_SECURITY_DBASE_CORRUPT();
                            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                            goto ErrorExit;
                        }
                        else if (FAILED(hr))
                        {
                            CHECK_HRESULT(hr);
                            goto ErrorExit;
                        }
                        else
                        {
                            MARK_DELETED_ENTRY(pbCredential);
                        }
                    }
                }
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Removed entries marked for deletion.
    //

    if (fDirty)
    {
        hr = SAICoalesceDeletedEntries(&cbSAI, &pbSAI);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            hr = SACCoalesceDeletedEntries(&cbSAC, &pbSAC);
            CHECK_HRESULT(hr);
        }

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        //
        // Finally, persist the changes made to the SAI & SAC.
        //
        hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
        CHECK_HRESULT(hr);
    }

ErrorExit:
    //
    // Deallocate data structures allocated above.
    //
    for (i = 0; i < dwSetCount; i++)
    {
        if (rgIdentitySet[i].rgpbIdentity != NULL)
        {
            LocalFree(rgIdentitySet[i].rgpbIdentity);
        }
    }

    if (rgIdentitySet != NULL) LocalFree(rgIdentitySet);
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);

    if (hFileEnum != INVALID_HANDLE_VALUE) FindClose(hFileEnum);

    if (hCSP != NULL) CloseCSPHandle(hCSP);
    //
    // Log an error & rest the SA security dbases SAI & SAC if corruption
    // is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //
        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                            (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);
}


//+---------------------------------------------------------------------------
//
//  Function:   SchedUPNToAccountName
//
//  Synopsis:   Converts a UPN to an Account Name
//
//  Arguments:  lpUPN - The UPN
//              ppAccountName - Pointer to the location to create/copy the account name
//
//  Returns:    NO_ERROR - Success (ppAccountName contains the converted UPN)
//              Any other Win32 error - error at some stage of conversion
//
//----------------------------------------------------------------------------

DWORD
SchedUPNToAccountName(
    IN  LPCWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    )
{
    DWORD               dwError;
    HANDLE              hDS;
    PDS_NAME_RESULT     pdsResult;

    schAssert(ppAccountName != NULL);

    schDebugOut((DEB_TRACE, "SchedUPNToAccountName: Converting \"%ws\"\n", lpUPN));

    //
    // Get a binding handle to the DS
    //
    dwError = DsBind(NULL, NULL, &hDS);

    if (dwError != NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsBind failed %d\n", dwError));
        return dwError;
    }

    dwError = DsCrackNames(hDS,                     // Handle to the DS
                           DS_NAME_NO_FLAGS,        // No parsing flags
                           DS_USER_PRINCIPAL_NAME,  // We have a UPN
                           DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                           1,                       // Number of names to crack
                           &lpUPN,                  // Array of name(s)
                           &pdsResult);             // Filled in by API

    if (dwError != NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames failed %d\n", dwError));

        DsUnBind(&hDS);
        return dwError;
    }

    schAssert(pdsResult->cItems == 1);
    schAssert(pdsResult->rItems != NULL);

    if (pdsResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
    {
        //
        // Couldn't crack the name but we got the name of
        // the domain where it is -- let's try it
        //
        DsUnBind(&hDS);

        schAssert(pdsResult->rItems[0].pDomain != NULL);

        schDebugOut((DEB_TRACE, "Retrying DsBind on domain %ws\n", pdsResult->rItems[0].pDomain));

        dwError = DsBind(NULL, pdsResult->rItems[0].pDomain, &hDS);

        //
        // Free up the structure holding the old info
        //
        DsFreeNameResult(pdsResult);

        if (dwError != NO_ERROR)
        {
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsBind #2 failed %d\n", dwError));
            return dwError;
        }

        dwError = DsCrackNames(hDS,                     // Handle to the DS
                               DS_NAME_NO_FLAGS,        // No parsing flags
                               DS_USER_PRINCIPAL_NAME,  // We have a UPN
                               DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                               1,                       // Number of names to crack
                               &lpUPN,                  // Array of name(s)
                               &pdsResult);             // Filled in by API

        if (dwError != NO_ERROR)
        {
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames #2 failed %d\n", dwError));

            DsUnBind(&hDS);
            return dwError;
        }

        schAssert(pdsResult->cItems == 1);
        schAssert(pdsResult->rItems != NULL);
    }

    if (pdsResult->rItems[0].status != DS_NAME_NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames failure (status %#x)\n", pdsResult->rItems[0].status));

        //
        // DS errors don't map to Win32 errors -- this is the best we can do
        //
        dwError = SCHED_E_ACCOUNT_NAME_NOT_FOUND;
    }
    else
    {
        schDebugOut((DEB_TRACE, "SchedUPNToAccountName: Got \"%ws\"\n",
                     pdsResult->rItems[0].pName));

        size_t cchBuff = wcslen(pdsResult->rItems[0].pName) + 1;
        *ppAccountName = new WCHAR[cchBuff];

        if (*ppAccountName != NULL)
        {
            StringCchCopy(*ppAccountName, cchBuff, pdsResult->rItems[0].pName);
        }
        else
        {
            dwError = GetLastError();
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: LocalAlloc failed %d\n", dwError));
        }
    }

    DsUnBind(&hDS);
    DsFreeNameResult(pdsResult);
    return dwError;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupAccountNameWrap
//
//  Synopsis:   BUGBUG  This is a workaround for bug 254102 - LookupAccountName
//              doesn't work when the DC can't be reached, even for the
//              currently logged-on user, and even though LookupAccountSid
//              does work.  Remove this function when that bug is fixed.
//
//  Arguments:  Same as LookupAccountName - but cbSid and cbReferencedDomainName
//              are assumed to be large enough, and peUse is ignored.
//
//  Returns:    Same as LookupAccountName.
//
//----------------------------------------------------------------------------
BOOL
LookupAccountNameWrap(
    LPCTSTR lpSystemName,  // address of string for system name
    LPCTSTR lpAccountName, // address of string for account name
    PSID    Sid,           // address of security identifier
    LPDWORD cbSid,         // address of size of security identifier
    LPTSTR  ReferencedDomainName,
                           // address of string for referenced domain
    LPDWORD cbReferencedDomainName,
                           // address of size of domain string
    PSID_NAME_USE peUse    // address of SID-type indicator
    )
{
    //
    // See if the account name matches the account name we cached
    //

    EnterCriticalSection(gUserLogonInfo.CritSection);

    if (gUserLogonInfo.DomainUserName != NULL &&
        lstrcmpi(gUserLogonInfo.DomainUserName, lpAccountName) == 0)
    {
        //
        // The names match.  Return the cached SID.
        //
        schDebugOut((DEB_TRACE, "Using cached SID for user \"%ws\"\n", lpAccountName));
        if (CopySid(*cbSid, Sid, gUserLogonInfo.Sid))
        {
            LeaveCriticalSection(gUserLogonInfo.CritSection);

            //
            // Copy the ReferencedDomainName from the account name
            //
            PCWCH pchSlash = wcschr(lpAccountName, L'\\');
            schAssert(pchSlash != NULL);
            DWORD  DomainLen = (DWORD)(pchSlash - lpAccountName);
            schAssert(DomainLen+1 <= *cbReferencedDomainName);
            wcsncpy(ReferencedDomainName, lpAccountName, DomainLen);
            ReferencedDomainName[DomainLen] = L'\0';

            return TRUE;
        }
        else
        {
            schAssert(0);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    LeaveCriticalSection(gUserLogonInfo.CritSection);

    return LookupAccountName(
                lpSystemName,
                lpAccountName,
                Sid,
                cbSid,
                ReferencedDomainName,
                cbReferencedDomainName,
                peUse
                );
}


//+----------------------------------------------------------------------------
//
//  Member:     ComputeJobSignature
//
//  Synopsis:   Creates a signature for the job file
//
//  Arguments:  [pwszFileName] - name of job file
//              [pSignature]   - block in which to store the signature.  Must
//                               be at least SIGNATURE_SIZE bytes long.
//              [dwHashMethod  - dword value indicating which hash method to use;
//                               Default if not specified is the latest method.
//
//  Returns:    HRESULT
//
//  Notes:      The job must have been saved to disk before calling this
//              function.
//
//-----------------------------------------------------------------------------
HRESULT
ComputeJobSignature(
    LPCWSTR     pwszFileName,
    LPBYTE      pbSignature,
    DWORD       dwHashMethod /* = 1 */
    )
{
    HCRYPTPROV  hCSP;

    HRESULT hr = GetCSPHandle(&hCSP);

    if (SUCCEEDED(hr))
    {
        hr = HashJobIdentity(hCSP, pwszFileName, pbSignature, dwHashMethod);
        CloseCSPHandle(hCSP);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CJob::Sign
//
//  Synopsis:   Computes and sets the job's signature
//
//  Arguments:  None
//
//  Notes:      The job must have been written to disk before calling this method
//
//-----------------------------------------------------------------------------
HRESULT
CJob::Sign(
    VOID
    )
{
    BYTE rgbSignature[SIGNATURE_SIZE];
    HRESULT hr = ComputeJobSignature(m_ptszFileName, rgbSignature);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    hr = _SetSignature(rgbSignature);

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CJob::VerifySignature
//
//  Synopsis:   Compares the job file's hash to the one stored in the file
//
//  Arguments:  None
//
//  Notes:      The job must have been written to disk before calling this method
//
//-----------------------------------------------------------------------------
BOOL
CJob::VerifySignature(
    DWORD dwHashMethod /* = 1 */
    ) const
{
    if (m_pbSignature == NULL)
    {
        CHECK_HRESULT(SCHED_E_ACCOUNT_INFORMATION_NOT_SET);
        return FALSE;
    }

    BYTE rgbSignature[SIGNATURE_SIZE];
    HRESULT hr = ComputeJobSignature(m_ptszFileName, rgbSignature, dwHashMethod);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return FALSE;
    }

    if (memcmp(m_pbSignature, rgbSignature, SIGNATURE_SIZE) != 0)
    {
        CHECK_HRESULT(E_ACCESSDENIED);
        return(FALSE);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::AddAtJobWithHash
//
//  Synopsis:   create a downlevel job
//
//  Arguments:  [At]  - reference to an AT_INFO struct
//              [pID] - returns the new ID (optional, can be NULL)
//
//  Returns:    HRESULTS
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddAtJobWithHash(const AT_INFO &At, DWORD * pID)
{
    TRACE(CSchedule, AddAtJob);
    HRESULT hr = S_OK;
    CJob *pJob;
    WCHAR wszName[MAX_PATH + 1];
    WCHAR wszID[SCH_SMBUF_LEN];

    hr = AddAtJobCommon(At, pID, &pJob, wszName, MAX_PATH + 1, wszID);

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJobWithHash: AddAtJobCommon", hr);
        return hr;
    }

    hr = AuditATJob(At, wszName);
    if (FAILED(hr))
    {
        ERR_OUT("AddAtJobWithHash: AuditATJob", hr);
    }

    //
    // Now get a signature for the job file and add it to the job object
    //
    hr = pJob->Sign();

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJobWithHash: Sign", hr);
        pJob->Release();
        return hr;
    }

    hr = pJob->SaveWithRetry(pJob->GetFileName(),
                             FALSE,
                             SAVEP_VARIABLE_LENGTH_DATA |
                             SAVEP_PRESERVE_NET_SCHEDULE);

    //
    // Free the job object.
    //
    pJob->Release();

    //
    // Return the new job's ID and increment the ID counter
    //
    if (pID != NULL)
    {
        *pID = m_dwNextID;
    }

    hr = IncrementAndSaveID();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\scvgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       scvgr.cxx
//
//  Contents:   CSAScavengerTask class implementation.
//
//  Classes:    CSAScavengerTask
//
//  Functions:  None.
//
//  History:    21-Jul-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "lsa.hxx"
#include "task.hxx"
#include "scvgr.hxx"


//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::Initialize
//
//  Synopsis:   Initialize the scavenger task by creating a wait event handle.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              CreateEvent HRESULT error code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CSAScavengerTask::Initialize(void)
{
    TRACE3(CSAScavengerTask, Initialize);

    _hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (_hWaitEvent == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::PerformTask
//
//  Synopsis:   Let ScavengeSASecurityDBase do the actual work of cleaning
//              up the scheduling agent security database.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSAScavengerTask::PerformTask(void)
{
    TRACE3(CSAScavenger, PerformTask);

    DWORD dwRet = WaitForSingleObject(_hWaitEvent, _msWaitTime);

    if (dwRet == WAIT_OBJECT_0)
    {
        //
        // The scavenger is to shutdown.
        //

        ResetEvent(_hWaitEvent);
        return;
    }
    else if (dwRet == WAIT_TIMEOUT)
    {
        ScavengeSASecurityDBase();
        ResetEvent(_hWaitEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::Shutdown
//
//  Synopsis:   Signal the scavenger to shut down by signalling its wait
//              event.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSAScavengerTask::Shutdown(void)
{
    TRACE3(CSAScavengerTask, Shutdown);
    SetEvent(_hWaitEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\task.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       task.cxx
//
//  Contents:   CTask class implementation.
//
//  Classes:    CTask
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "task.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CTask::AddRef
//
//  Synopsis:   Increment the task reference count.
//
//  Arguments:  None.
//
//  Returns:    ULONG reference count.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
ULONG
CTask::AddRef(void)
{
    ULONG ulTmp = InterlockedIncrement((LONG *)&_cReferences);

    schDebugOut((DEB_USER3,
        "CTask::AddRef(0x%x) _cReferences(%d)\n",
        this,
        ulTmp));

    return(ulTmp);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTask::Release
//
//  Synopsis:   Decrement the task reference count.
//
//  Arguments:  None.
//
//  Returns:    ULONG reference count.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
ULONG
CTask::Release(void)
{
    ULONG ulTmp = InterlockedDecrement((LONG *)&_cReferences);

    schDebugOut((DEB_USER3,
        "CTask::Release(0x%x) _cReferences(%d)\n",
        this,
        ulTmp));

    if (ulTmp == 0)
    {
        delete this;
    }
    return(ulTmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\svc_core.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       svc_core.cxx
//
//  Contents:   job scheduler service entry point and thread launcher
//
//  History:    08-Sep-95 EricB created
//              25-Jun-99 AnirudhS  Extensive fixes to close windows in
//                  MainServiceLoop algorithms.
//              03-Mar-01 JBenton  Bug 307808 - Security Subsystem critical
//                  sections deleted too early.  Scavenger task could still
//                  be running.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "..\inc\sadat.hxx"
#include "globals.hxx"
#include <netevent.h>	// EVENT_COMMAND_START_FAILED
#include <winsvcp.h>    // SC_AUTOSTART_EVENT_NAME

#define SCAVENGER_START_WAIT_TIME (1000 * 60 * 10)      // 10 minutes in ms
#define CHANGE_WAIT         300                         // 300 milliseconds
#define MAX_CHANGE_WAITS    (30000 / CHANGE_WAIT)       // 30 sec / CHANGE_WAIT
#define FAT_FUDGE_FACTOR    (4 * FILETIMES_PER_SECOND)  // 4 seconds
#define SMALL_TIME_CHANGE   (7 * FILETIMES_PER_MINUTE)  // 7 minutes
#define UNBLOCK_ALLOWANCE   (20 * FILETIMES_PER_SECOND) // 20 seconds
#define NUM_EVENTS          5

// types

typedef enum _SVC_EVENT_STATE {
    RUN_WAIT_STATE,
    DIR_CHANGE_WAIT_STATE,
    PAUSED_STATE,
    PAUSED_DIR_CHANGE_STATE,
    SLEEP_STATE
} SVC_EVENT_STATE;

typedef enum _SVC_EVENT {
    TIME_OUT_EVENT,
    DIR_CHANGE_EVENT,
    SERVICE_CONTROL_EVENT,
    ON_IDLE_EVENT,
    IDLE_LOSS_EVENT,
    WAKEUP_TIME_EVENT
} SVC_EVENT;

BOOL  g_fUserStarted;

// forward declaration; code exists in conversion.cxx
HRESULT PerformDataConversions(void);

//+----------------------------------------------------------------------------
//
//  Function:   SchedMain
//
//  Synopsis:   Primary thread of the service
//
//  Arguments:  [pVoid] - currently not used
//
//-----------------------------------------------------------------------------
HRESULT
SchedMain(LPVOID pVoid)
{
    return g_pSched->MainServiceLoop();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::MainServiceLoop
//
//  Synopsis:   The service primary thread main loop. Runs time and event
//              trigger jobs. Handles service controller and job directory
//              change notification events.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::MainServiceLoop(void)
{
    HANDLE  rgEvents[NUM_EVENTS] = {
                m_hServiceControlEvent, // must be first
                m_hOnIdleEvent,
                m_hChangeNotify,
                m_hIdleLossEvent,
                m_hSystemWakeupTimer    // may be NULL
    };
    DWORD   dwWait;
    HRESULT hr;
    DWORD   dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS : NUM_EVENTS - 1);
                                        // Number of events we'll wait for
    SVC_EVENT_STATE NextState;          // State to go into on wakeup
    SVC_EVENT_STATE CurSvcEventState;   // State we are currently in

    DWORD       dwNumChangeWaits;       // Num iterations in change wait state
    FILETIME    ftDirChangeStart;       // When dir changes started (see
                                        //    DIR_CHANGE_EVENT)

    //
    // Set the initial state.
    //
    CurSvcEventState = RUN_WAIT_STATE;
    //
    // Set the wakeup timer to the next wakeup time.
    //
    SetNextWakeupTime();
    //
    // Avoid an idle notification during service startup
    //
    ResetEvent(m_hOnIdleEvent);

    //
    // Kick up the service scavenger on service start.
    // It'll wait ~10 minutes before doing anything. Well after
    // the activity associated with service start dies down.
    // Also, it will relinquish its thread when it has completed.
    //
    RequestService(gpSAScavengerTask);

    //
    // Main waiting-to-run and event processing loop.
    //
    for (;;)
    {
        //
        // How long we wait depends on the state we are in.
        //
        switch (CurSvcEventState)
        {
        case RUN_WAIT_STATE:
            dwNumChangeWaits = 0;
            dwWait = GetNextRunWait();
            break;

        case DIR_CHANGE_WAIT_STATE:
            if (dwNumChangeWaits == 0)
            {
                // Save the time when dir changes started.  We use this only if
                // we get a time change while in the dir change wait state, as
                // a heuristic to see if the time change was small and can be
                // ignored.
                //
                ftDirChangeStart = GetLocalTimeAsFileTime();
            }
            dwNumChangeWaits++;
            dwWait = CHANGE_WAIT;
            break;

        case PAUSED_STATE:
            dwNumChangeWaits = 0;
            dwWait = INFINITE;
            break;

        case PAUSED_DIR_CHANGE_STATE:
            dwNumChangeWaits = 0;
            dwWait = CHANGE_WAIT;
            break;

        case SLEEP_STATE:
            dwNumChangeWaits = 0;
            dwWait = INFINITE;
            break;
        }

        //
        // Wait for the above time *or* a control event.
        //

        schDebugOut((DEB_ITRACE, "MainServiceLoop: in %s, waiting %lu ms %s\n",

                    CurSvcEventState == RUN_WAIT_STATE ? "RUN_WAIT_STATE" :
                    CurSvcEventState == DIR_CHANGE_WAIT_STATE ?
                                                    "DIR_CHANGE_WAIT_STATE" :
                    CurSvcEventState == PAUSED_STATE ? "PAUSED_STATE" :
                    CurSvcEventState == PAUSED_DIR_CHANGE_STATE ?
                                                    "PAUSED_DIR_CHANGE_STATE" :
                    CurSvcEventState == SLEEP_STATE ? "SLEEP_STATE" :
                                                    "??? -- UNKNOWN STATE --",
                    dwWait,
                    (dwWait == INFINITE) ? "(infinite)" : ""));

        DWORD dwEvent;
        FILETIME ftSavedBeginWaitList = m_ftBeginWaitList;

        //
        // If we're idling in the run wait state, take the opportunity to
        // advance the wait list begin time until after we're idle.  This is
        // functionally equivalent to waking up every minute to advance the
        // begin time.  It prevents most cases of jobs being run for times
        // prior to their submission.
        //
        if (CurSvcEventState == RUN_WAIT_STATE && dwWait > 0)
        {
            dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE, 0);

            if (dwEvent == WAIT_TIMEOUT)
            {
                //
                // No jobs ready, no events signaled - we're idle.
                // Do the real wait.
                //
                dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE,
                                                 dwWait);

                // Advance the wait list begin time to just before now.
                // The exception is if we get an insignificant time change, in
                // which case we will restore the original begin time.
                //
                // What this means: An 8:05:00 job will be run if:
                // (a) (if we were busy at 8:05:00) as long as it was
                //  submitted before we started running the 8:05:00 batch
                // (b) (if we weren't busy at 8:05:00) as long as we notice
                //  the dir change event by 8:05:20 (where 20 sec is
                //  UNBLOCK_ALLOWANCE).
                // But also see the file creation time check in BuildWaitList.
                //
                m_ftBeginWaitList = maxFileTime(
                    m_ftBeginWaitList,
                    FTfrom64(FTto64(GetLocalTimeAsFileTime()) - UNBLOCK_ALLOWANCE));

                schDebugOut((DEB_ITRACE, "MainServiceLoop: New list begin: %s\n",
                             CFileTimeString(m_ftBeginWaitList).sz()));
            }
        }
        else
        {
            //
            // Just do a normal wait.
            //
            dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE, dwWait);
        }

        //
        // Determine the type of the event.
        //

        SVC_EVENT   CurSvcEvent;

        switch (dwEvent)
        {
        case WAIT_TIMEOUT:
            //
            // Wait timeout event.
            //
            CurSvcEvent = TIME_OUT_EVENT;
            break;

        case WAIT_OBJECT_0:
            //
            // Service control event.
            //
            CurSvcEvent = SERVICE_CONTROL_EVENT;
            break;

        case WAIT_OBJECT_0 + 1:
            //
            // Entered the idle state.
            //
            CurSvcEvent = ON_IDLE_EVENT;
            schDebugOut((DEB_IDLE, "Noticed idle event\n"));
            break;

        case WAIT_OBJECT_0 + 2:
            //
            // Directory Change Notification went off.
            //
            CurSvcEvent = DIR_CHANGE_EVENT;
            break;

        case WAIT_OBJECT_0 + 3:
            //
            // Left the idle state.
            //
            CurSvcEvent = IDLE_LOSS_EVENT;
            schDebugOut((DEB_IDLE, "Noticed idle loss event\n"));
            break;

        case WAIT_OBJECT_0 + 4:
            //
            // The wakeup timer is signaled.  This doesn't necessarily
            // mean that the machine woke up, only that the wakeup time
            // passed.
            //
            CurSvcEvent = WAKEUP_TIME_EVENT;
            break;

        case WAIT_FAILED:
        {
            //
            // Wait failure.
            //
            ULONG ulLastError = GetLastError();
            LogServiceError(IDS_FATAL_ERROR, ulLastError, 0);
            ERR_OUT("Main loop WaitForMultipleObjects", ulLastError);
            return HRESULT_FROM_WIN32(ulLastError);
        }
        }

SwitchStart:
        schDebugOut((DEB_ITRACE, "MainServiceLoop:  got %s\n",

                    CurSvcEvent == TIME_OUT_EVENT ? "TIME_OUT_EVENT" :
                    CurSvcEvent == SERVICE_CONTROL_EVENT ?
                                                    "SERVICE_CONTROL_EVENT" :
                    CurSvcEvent == DIR_CHANGE_EVENT ? "DIR_CHANGE_EVENT" :
                    CurSvcEvent == ON_IDLE_EVENT ? "ON_IDLE_EVENT" :
                    CurSvcEvent == IDLE_LOSS_EVENT ? "IDLE_LOSS_EVENT" :
                    CurSvcEvent == WAKEUP_TIME_EVENT ? "WAKEUP_TIME_EVENT" :
                                                    "??? -- UNKNOWN EVENT --"));

        switch (CurSvcEvent)
        {
        //=================
        case TIME_OUT_EVENT:
        //=================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:

                if (GetNextRunWait() > 0)
                {
                    //
                    // There is still time to wait before the next run.
                    // This can happen if the system time is adjusted
                    // while we're in WaitForMultipleObjects and a
                    // WM_TIMECHANGE is not sent.
                    //
                    schDebugOut((DEB_ITRACE, "Time not yet elapsed, re-waiting\n"));
                    break;
                }

                //
                // Run jobs whose time has arrived.
                //
                hr = RunNextJobs();
                if (hr == S_FALSE)
                {
                    //
                    // No jobs waiting, so we must have passed the end of
                    // the wait list period.  Rebuild the wait list starting
                    // from the end of the last wait list period.
                    //
                    
                    //***************************************************************************************
                    // 05/08/2002 -- Note that the above assumption is not always the case.  While it is true
                    // that most instances of RunNextJobs returning S_FALSE will be due to passing the end of
                    // the wait list period, it is also possible for it to return S_FALSE in the case where a
                    // job has the TASK_FLAG_RUN_ONLY_IF_LOGGED_ON flag and the user isn't logged on, and
                    // possibly other cases as well. Therefore, check whether m_stEndOfWaitListPeriod has in
                    // fact already passed. If it has, then set the new begin to the old end, otherwise leave
                    // it alone, because the begin has already been set to 1 second past the last job's
                    // scheduled start time in the beginning of RunNextJobs.
                    //***************************************************************************************

                    FILETIME ftNow, ftSTNow, ftEndOfWaitListPeriod;
                    GetSystemTimeAsFileTime(&ftSTNow);
                    FileTimeToLocalFileTime(&ftSTNow, &ftNow);
                    SystemTimeToFileTime(&m_stEndOfWaitListPeriod, &ftEndOfWaitListPeriod);

                    //
                    // only make the below assignment if we *really* have passed the end of the wait list period
                    //
                    if (CompareFileTime(&ftEndOfWaitListPeriod, &ftNow) < 0)
                    {
                        m_ftBeginWaitList = ftEndOfWaitListPeriod;
                    }

                    hr = BuildWaitList(FALSE, FALSE, FALSE);
                    if (FAILED(hr))
                    {
                        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                        ERR_OUT("BuildWaitList", hr);
                        return hr;
                    }

                    //
                    // Set the wakeup timer to the next wakeup time.
                    //
                    SetNextWakeupTime();

                    //
                    // The wait has timed out and there is nothing to run.
                    // This will occur at most once a day. Take this
                    // opportunity to kick up the service scavenger to
                    // cleanup the SA security database.
                    //
                    // Note, the scavenge task will wait ~10 minutes before
                    // doing anything.
                    //
                    RequestService(gpSAScavengerTask);
                }
                break;

            case DIR_CHANGE_WAIT_STATE:
                //
                // Change notification timeout expired. Process the change.
                //
                hr = CheckDir();
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("SchedMain: CheckDir", hr);
                }

                //
                // Set the new state.
                //
                CurSvcEventState = RUN_WAIT_STATE;

                //
                // Go directly to the run wait state, in case it's time to run
                // some jobs.  Skip the wait, to avoid seeing the dir change
                // event again and losing the wait list we just built.
                //
                schDebugOut((DEB_ITRACE, "MainServiceLoop: Going to RUN_WAIT_STATE\n"));
                goto SwitchStart;
                break;

            case PAUSED_STATE:
                schAssert(!"Got TIME_OUT_EVENT while in PAUSED_STATE");
                break;

            case PAUSED_DIR_CHANGE_STATE:
                //
                // Change notification timeout expired. Process the change.
                //
                hr = CheckDir();
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("SchedMain: CheckDir", hr);
                }

                //
                // Now go to the paused state.
                //
                CurSvcEventState = PAUSED_STATE;
                break;

            case SLEEP_STATE:
                schAssert(!"Got TIME_OUT_EVENT while in SLEEP_STATE");
                break;
            }
            break;

        //===================
        case DIR_CHANGE_EVENT:
        //===================
            //
            // Directory Change Notification went off.
            //
            // Note that copy/create produce both a name change
            // notification and a write timestamp change notification
            // whereas a delete only produces a name change notification.
            // Thus, several sequential events can be produced for one
            // file change. Simarly, bulk copies or deletes will produce a
            // number of change notifications. We want the change
            // notifications to stop before processing them. So, when a
            // change is received, set the WaitForMultipleObjects
            // timeout to CHANGE_WAIT (currently 0.3 seconds), set the new
            // state to DIR_CHANGE_WAIT_STATE, and then go back into the
            // wait. The change notifications will not be processed until
            // CHANGE_WAIT has elapsed without receiving another change
            // event.
            //
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
                //
                // Directory changes have begun.
                // Wait to see if there are more.
                //
                CurSvcEventState = DIR_CHANGE_WAIT_STATE;
                //
                // fall through
                //
            case DIR_CHANGE_WAIT_STATE:
                //
                // Another directory change notification went off.
                //
                FindNextChangeNotification(m_hChangeNotify);

                // If it's time to run a task in the existing wait list, leave
                // this state now.
                // Also, limit the amount of time spent in this state, so new
                // jobs aren't delayed indefinitely.
                // Jobs would not be skipped if we didn't do these checks, but
                // they could get delayed.
                //
                if (GetNextRunWait() == 0 || dwNumChangeWaits > MAX_CHANGE_WAITS)
                {
                    CurSvcEvent = TIME_OUT_EVENT;

                    // Skip the wait, to avoid seeing the dir change event again
                    goto SwitchStart;
                }
                break;

            case PAUSED_STATE:
                FindNextChangeNotification(m_hChangeNotify);

                //
                // A dir change, wait to see if there are more.
                //
                CurSvcEventState = PAUSED_DIR_CHANGE_STATE;
                break;

            case PAUSED_DIR_CHANGE_STATE:
                //
                // Continue waiting until the dir changes stop.
                //
                FindNextChangeNotification(m_hChangeNotify);
                break;

            case SLEEP_STATE:
                //
                // We don't wait for this event in the sleep state
                //
                schAssert(!"Got DIR_CHANGE_EVENT while in SLEEP_STATE");
                break;
            }
            break;

        //========================
        case SERVICE_CONTROL_EVENT:
        //========================
            switch(HandleControl())
            {
            case SERVICE_STOP_PENDING:
                //
                // Exit the service.
                //
                return S_OK;

            case SERVICE_PAUSED:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                    //
                    // Set the new state.
                    //
                    CurSvcEventState = PAUSED_STATE;
                    //
                    // Cancel the wakeup timer.  Since we won't run any
                    // jobs while paused, there is no point waking up.
                    //
                    CancelWakeup();
                    break;

                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Set the wait and state.
                    //
                    CurSvcEventState = PAUSED_DIR_CHANGE_STATE;
                    //
                    // Cancel the wakeup timer.  Since we won't run any
                    // jobs while paused, there is no point waking up.
                    //
                    CancelWakeup();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // Already paused, do nothing.
                    //
                    break;

                case SLEEP_STATE:
                    //
                    // Set the state that we will go into when we wake.
                    //
                    if (NextState == DIR_CHANGE_WAIT_STATE)
                    {
                        NextState = PAUSED_DIR_CHANGE_STATE;
                    }
                    else
                    {
                        NextState = PAUSED_STATE;
                    }
                    break;
                }
                break;

            case SERVICE_RUNNING:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Already running, ignore.
                    //
                    break;

                case PAUSED_STATE:
                    //
                    // Resume the service. Get the next run wait and discard
                    // expired jobs.
                    //
                    DiscardExpiredJobs();
                    SetNextWakeupTime();
                    CurSvcEventState = RUN_WAIT_STATE;
                    break;

                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // Resume the service. Pop expired jobs off of the stack.
                    //
                    DiscardExpiredJobs();
                    SetNextWakeupTime();
                    //
                    // Continue waiting until the dir changes stop.
                    //
                    CurSvcEventState = DIR_CHANGE_WAIT_STATE;
                    break;

                case SLEEP_STATE:
                    //
                    // Set the state that we will go into when we wake.
                    //
                    if (NextState == PAUSED_DIR_CHANGE_STATE)
                    {
                        NextState = DIR_CHANGE_WAIT_STATE;
                    }
                    else
                    {
                        NextState = RUN_WAIT_STATE;
                    }
                    break;
                }
                break;

            case SERVICE_CONTROL_USER_LOGON:

                //
                // Get the newly logged on user's identity.
                //
                EnterCriticalSection(gUserLogonInfo.CritSection);
                GetLoggedOnUser();
                LeaveCriticalSection(gUserLogonInfo.CritSection);

                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Run logon trigger jobs.
                    //
                    RunLogonJobs();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                case SLEEP_STATE:
                    //
                    // Don't run logon trigger jobs.
                    //
                    break;
                }
                break;

            case SERVICE_CONTROL_TIME_CHANGED:

                if (CurSvcEventState == SLEEP_STATE)
                {
                    //
                    // We got a time-change message before the power-resume
                    // message.  Ignore it.  We will rebuild the wait list
                    // on power resume anyway.
                    //
                    break;
                }

                //
                // If the new time is close to the time for the next run,
                // assume the time change was just a minor clock correction,
                // and don't rebuild the wait list (otherwise the next run
                // could get skipped).  We need to resort to such a heuristic
                // because WM_TIMECHANGE doesn't tell how much the time
                // changed by.
                //
                {
                    FILETIME ftNow, ftSTNow;
                    GetSystemTimeAsFileTime(&ftSTNow);
                    FileTimeToLocalFileTime(&ftSTNow, &ftNow);

                    // Never let the last-dir-checked time be in the future -
                    // or we could miss some changes.  BUGBUG there is still
                    // a window here where runs could get missed (though it
                    // would need a highly improbable conjunction of events).
                    // The scenario is: 1. The system time is changed to
                    // something earlier than m_ftLastChecked.  2. A job file 
                    // is modified.  3. We notice the time change and execute
                    // the GetSystemTimeAsFileTime call above.  Then 
                    // m_ftLastChecked gets set to a time later than the file
                    // time, and the file change could go unnoticed.
                    // This window would be avoidable if WM_TIMECHANGE told us
                    // exactly what the system time was before and after the 
                    // change.
                    if (CompareFileTime(&ftSTNow, &m_ftLastChecked) < 0)
                    {
                        schDebugOut((DEB_TRACE, "Backing up dir check time to %s\n",
                                     CFileTimeString(ftSTNow).sz()));
                        m_ftLastChecked = ftSTNow;
                    }

                    FILETIME ftFirst = GetNextListTime();

                    if (absFileTimeDiff(ftFirst, ftNow) < SMALL_TIME_CHANGE)
                    {
                        m_ftBeginWaitList = ftSavedBeginWaitList;
                        schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near next run;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                        break;
                    }

                    if (absFileTimeDiff(ftSavedBeginWaitList, ftNow) < SMALL_TIME_CHANGE)
                    {
                        // Another time we can use as a heuristic.  Also avoids
                        // re-running jobs if the time was changed backward.
                        m_ftBeginWaitList = ftSavedBeginWaitList;
                        schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near last run;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                        break;
                    }

                    if (CurSvcEventState == DIR_CHANGE_WAIT_STATE)
                    {
                        // If we're waiting for dir changes to stop, use
                        // the time when they started.  (Strictly, we should
                        // use the time of the first file changed after
                        // m_ftLastChecked - but that will definitely be
                        // earlier.)
                        if (absFileTimeDiff(ftDirChangeStart, ftNow) < SMALL_TIME_CHANGE)
                        {
                            // Insignificant time change
                            m_ftBeginWaitList = ftSavedBeginWaitList;
                            schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near dir change start;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                            break;
                        }
                        else
                        {
                            // Significant time change
                            // Force ourselves out of the change wait state
                            dwNumChangeWaits = MAX_CHANGE_WAITS + 1;
                        }
                    }

                    // else

                    //
                    // The machine time has been changed, so discard the old
                    // wait list and rebuild it, starting from now.  We will
                    // intentionally skip runs scheduled before now and re-run
                    // runs scheduled after now.
                    // If we wanted to write a log entry about runs being 
                    // skipped or re-run (DCR 25519), the code would go here.
                    //
                    m_ftBeginWaitList = ftNow;
                }

                hr = BuildWaitList(FALSE, TRUE, FALSE);
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("BuildWaitList", hr);
                    return hr;
                }

                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Set the wakeup timer to the next wakeup time.
                    //
                    SetNextWakeupTime();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    break;
                }
                break;

            case SERVICE_CONTROL_POWER_SUSPEND:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // The computer is preparing for suspended mode.
                    // Stop running jobs.
                    // Stop waiting for all events except the service
                    // control event.
                    //
                    dwNumEvents = 1;
                    NextState = CurSvcEventState;
                    CurSvcEventState = SLEEP_STATE;
                    break;

                case SLEEP_STATE:
                    schAssert(!"Got SERVICE_CONTROL_POWER_SUSPEND while in SLEEP_STATE");
                    break;
                }
                break;

            case SERVICE_CONTROL_POWER_SUSPEND_FAILED:
                if (CurSvcEventState != SLEEP_STATE)
                {
                    schAssert(!"Got POWER_SUSPEND_FAILED without POWER_SUSPEND");
                    break;
                }

                //
                // The suspend has been canceled.  Go back into the state we
                // were in before we got the suspend message, without
                // rebuilding the wait list.
                //
                dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS :
                                                      NUM_EVENTS - 1);
                CurSvcEventState = NextState;
                break;

            case SERVICE_CONTROL_POWER_RESUME:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // We got a power-resume without a power-suspend.  We must
                    // be waking up from an emergency sleep.  Fall through to
                    // the wakeup code, making sure it returns us to this state.
                    //
                    NextState = CurSvcEventState;
                    //
                    // fall through
                    //
                case SLEEP_STATE:
                    //
                    // The machine is waking up from a sleep, so discard the
                    // old wait list and rebuild it.
                    // CODEWORK: Optimize this for the common case when all
                    // we need to do is discard some runs from the front of
                    // the existing list.

                    // Set the wait list's begin time to now, so we don't run
                    // jobs that were scheduled for when we were sleeping.
                    // If the wakeup time that we set has passed, build the
                    // wait list starting from that time, so that the runs we
                    // woke up for are included.
                    //
                    m_ftBeginWaitList =
                        minFileTime(GetLocalTimeAsFileTime(), m_ftLastWakeupSet);

                    hr = BuildWaitList(FALSE, TRUE, FALSE);
                    if (FAILED(hr))
                    {
                        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                        ERR_OUT("BuildWaitList", hr);
                        return hr;
                    }

                    //
                    // Go back into the state that we were in before sleeping.
                    // Resume waiting on the other events.
                    //
                    dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS :
                                                          NUM_EVENTS - 1);
                    CurSvcEventState = NextState;
                    switch (NextState)
                    {
                    case RUN_WAIT_STATE:
                    case DIR_CHANGE_WAIT_STATE:
                        SetNextWakeupTime();
                        SetNextIdleNotification(m_IdleList.GetFirstWait());
                        break;

                    case PAUSED_STATE:
                    case PAUSED_DIR_CHANGE_STATE:
                        break;
                    }
                    break;
                }
                break;
            }
            break;

        //================
        case ON_IDLE_EVENT:
        //================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Now in the idle state, run jobs with idle triggers.
                //
                RunIdleJobs();
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
                //
                // Do nothing.
                //
                break;

            case SLEEP_STATE:
                //
                // Got an ON_IDLE event while the machine is either going
                // to sleep or waking up from a sleep.  In either case, we
                // don't want to run idle-triggered jobs now.
                // Note, we'll request another idle notification when we
                // wake.
                //
                break;
            }
            break;

        //==================
        case IDLE_LOSS_EVENT:
        //==================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Left the idle state, note that we've started no idle jobs
                // in the current idle period.
                //
                m_IdleList.MarkNoneStarted();

                //
                // Request the next idle notification.
                //
                SetNextIdleNotification(m_IdleList.GetFirstWait());
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
            case SLEEP_STATE:
                //
                // Left the idle state, note that we've started no idle jobs
                // in the current idle period.
                // Don't request more idle notifications.
                //
                m_IdleList.MarkNoneStarted();
                break;
            }
            break;

        //====================
        case WAKEUP_TIME_EVENT:
        //====================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Set the wakeup timer to the next wakeup time.
                //
                SetNextWakeupTime();
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
                //
                // (We could get here if the timer event was signaled
                // before we canceled it.)
                // We won't run any jobs while the service is paused, so
                // don't bother setting the wakeup timer until we leave
                // the paused state.
                //
                break;

            case SLEEP_STATE:
                //
                // (When the system wakes up due to a wakeup timer, we could
                // get this event before the POWER_RESUME event)
                // Remain in the sleep state until we get the POWER_RESUME event.
                //
                break;
            }
            break;
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CheckDir
//
//  Synopsis:   Checks the jobs directory for changes.
//              Runs jobs that are marked to run now, kills jobs that are
//              marked to be killed.  If jobs have been changed since the
//              last time the directory was checked, and those jobs do not
//              have JOB_I_FLAG_NO_RUN_PROP_CHANGE set, rebuilds the wait
//              list by calling BuildWaitList().
//
//  Arguments:  None.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::CheckDir()
{
    TRACE(CSchedWorker, CheckDir);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    FILETIME ftChecked;

    WORD cJobs = 0;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {   // no job files.

            if (m_cJobs > 0)
            {
                //
                // There are no jobs now, but there were before, so kick off the scavenger
                // to clean up the SA security database and remove any dead data.  Note the
                // scavenge task will wait 10 minutes before doing anything.
                //
                RequestService(gpSAScavengerTask);
            }
        
            m_WaitList.FreeList();
            m_cJobs = 0;
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    BOOL fRebuildWaitList = FALSE;
    CJob * pJob = NULL;

    CRunList * pRunNowList = new CRunList;
    if (pRunNowList == NULL)
    {
        ERR_OUT("CheckDir run-now list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Get the current time which will be saved after all files are checked.
    //
    GetSystemTimeAsFileTime(&ftChecked);

    do
    {
        //
        // Check if the service is shutting down. We check the event rather
        // than simply checking GetCurrentServiceState because this method is
        // called by the main loop which won't be able to react to the shut
        // down event while in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("CheckDir: SetEvent", hr);
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("CheckDir: Service shutting down");
                //
                // The service is shutting down.
                // Free any job info objects for jobs not already launched.
                //
                delete pRunNowList;
                return S_OK;
            }
        }

        cJobs++;

        schDebugOut((DEB_USER2, "CheckDir: %s " FMT_TSTR "\n",
                     CFileTimeString(fd.ftLastWriteTime).sz(), fd.cFileName));

        if (CompareFileTime(&fd.ftLastWriteTime, &m_ftLastChecked) > 0)
        {
            //
            // Job file changed since last check. See if Run or Abort bits
            // are set.
            //
            hr = m_pSch->ActivateJob(fd.cFileName, &pJob, FALSE);
            if (FAILED(hr))
            {
                schDebugOut((DEB_ERROR,"CSchedWorker::CheckDir job load for "
                                    FMT_TSTR " failed, %#lx\n",
                                    fd.cFileName, hr));
                hr = S_OK;
                goto NextJob;
            }

            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW))
            {
                //
                // Add the job to the run now list.
                //
                CRun * pNewRun = new CRun(pJob->m_dwMaxRunTime,
                                          pJob->GetUserFlags(),
                                          MAX_FILETIME,
                                          FALSE);
                if (!pNewRun)
                {
                    hr = E_OUTOFMEMORY;
                    ERR_OUT("CSchedWorker::CheckDir new CRun", hr);
                    break;
                }

                // Complete job info object initialization.
                //
                hr = pNewRun->Initialize(fd.cFileName);

                if (FAILED(hr))
                {
                    delete pNewRun;
                    ERR_OUT("CSchedWorker::CheckDir, Initialize", hr);
                    break;
                }

                pRunNowList->Add(pNewRun);
            }
            else if (pJob->IsFlagSet(JOB_I_FLAG_ABORT_NOW))
            {
                //
                // Find the processor that is running this job, and kill
                // the job
                //

                CJobProcessor * pjp;
                for (pjp = gpJobProcessorMgr->GetFirstProcessor();
                            pjp != NULL; )
                {
                    pjp->KillJob(fd.cFileName);
                    CJobProcessor * pjpNext = pjp->Next();
                    pjp->Release();
                    pjp = pjpNext;
                }
            }
            else if (!pJob->IsFlagSet(JOB_I_FLAG_NO_RUN_PROP_CHANGE))
            {
                //
                // Timestamp change was due to a trigger update or by
                // setting an app name when there hadn't been one.
                // Thus, rebuild wait list.
                //
                fRebuildWaitList = TRUE;
            }
        }

NextJob:

        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwRet);
                ERR_OUT("CSchedWorker::CheckDir FindNextFile", hr);
                break;
            }
        }
    } while (TRUE);

    FindClose(hFind);

    if (pJob)
    {
        pJob->Release();
    }

    if (FAILED(hr))
    {
        delete pRunNowList;
        return hr;
    }

    //
    // Save the time now that the enum is done.
    //
    m_ftLastChecked = ftChecked;
    //
    // Account for rounding down to the nearest even second done by FAT file
    // systems.
    //
    ULARGE_INTEGER ul;
    ul.LowPart  = m_ftLastChecked.dwLowDateTime;
    ul.HighPart = m_ftLastChecked.dwHighDateTime;
    ul.QuadPart -= FAT_FUDGE_FACTOR;
    m_ftLastChecked.dwLowDateTime  = ul.LowPart;
    m_ftLastChecked.dwHighDateTime = ul.HighPart;
    schDebugOut((DEB_USER2, "CheckDir: last checked %s\n",
                 CFileTimeString(m_ftLastChecked).sz()));

    //
    // If count changed, set fRebuildWaitList to TRUE and save new count.
    //
    if (m_cJobs != cJobs)
    {
        if (cJobs < m_cJobs)
        {
            //
            // There are fewer jobs now than before, so kick off the scavenger
            // to clean up the SA security database and remove any dead data.
            // Note the scavenge task will wait 10 minutes before doing anything.
            //
            RequestService(gpSAScavengerTask);
        }

        fRebuildWaitList = TRUE;
        m_cJobs = cJobs;
    }

    //
    // If jobs to run, run them now.
    //
    if (!pRunNowList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunNowList);  // RunJobs *should* handle deleting pRunNowList, even in failure cases
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        delete pRunNowList;
    }

    //
    // If jobs have changed, rebuild the wait list.
    //
    if (fRebuildWaitList)
    {
        hr = BuildWaitList(FALSE, FALSE, FALSE);
        if (FAILED(hr))
        {
            return hr;
        }

        //
        // Set the wakeup timer to the next wakeup time.
        //
        SetNextWakeupTime();
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunJobs
//
//  Synopsis:   Run the jobs passed in the list.
//
//  Arguments:  [pJobList] - an object containing a linked list of CRun objects.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunJobs(CRunList * pJobList)
{
    TRACE(CSchedWorker, RunJobs);
    if (!pJobList)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    BOOL fNothingRan = TRUE;
    BOOL fNeedIdleLossNotify = FALSE;
    BOOL fKeptAwake = FALSE;    // Whether we called WrapSetThreadExec(TRUE)
    BOOL fLaunchSucceeded;
    DWORD dwErrMsgID;

    CRun * pCurRun = pJobList->GetFirstJob();

    //
    // I'm being paranoid here.
    //
    if (pCurRun->IsNull())
    {
        delete pJobList;
        return E_INVALIDARG;
    }

    CJob * pJob = NULL;

    //
    // Run all of the jobs in the list.
    //
    do
    {
        //
        // Check if the service is shutting down. The event is checked rather
        // than simply checking GetCurrentServiceStatus because this method is
        // called synchronously from the main event loop. Thus, the main
        // event loop would not be able to react to a shutdown event while
        // we are processing in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("RunJobs: SetEvent", hr);
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("RunJobs: Service shutting down");
                //
                // The service is shutting down.
                // Free any job info objects for jobs not already launched.
                //
                CRun * pRun;
                while (!pCurRun->IsNull())
                {
                    pRun = pCurRun;
                    pCurRun = pRun->Next();
                    pRun->UnLink();
                    delete pRun;
                }

                if (fKeptAwake)
                {
                    WrapSetThreadExecutionState(FALSE, "RunJobs - service shutdown");
                }

                return S_OK;
            }
        }

        FILETIME ftRun = GetLocalTimeAsFileTime();

        SYSTEMTIME stRun;
        FileTimeToSystemTime(&ftRun, &stRun);

        //
        // Instantiate the job to get its run properties.
        //

        hr = ActivateWithRetry(pCurRun->GetName(), &pJob, TRUE);
        if (FAILED(hr))
        {
            ERR_OUT("RunJobs Activate", hr);
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
                hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
            {
                //
                // Something other than file-not-found or sharing violation
                // represents a catastrophic error.
                //
                break;
            }
        }
        //
        // Don't attempt to run if no command or file can't be opened.
        //
        if (pJob->m_pwszApplicationName == NULL ||
            hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
            hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
            ERR_OUT("RunJobs: can't open job or app name missing", 0);
            continue;
        }

        //
        // Don't attempt to run if already running.
        //
        pJob->GetStatus(&hr);
        if (hr == SCHED_S_TASK_RUNNING)
        {
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
            ERR_OUT("RunJobs: job already running", 0);

            //
            // Clear the RUN_NOW flag on the job file - otherwise, it never
            // gets cleared, and other flags like the abort flag never get
            // noticed.
            //
            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW))
            {
                pJob->ClearFlag(JOB_I_FLAG_RUN_NOW);

                hr = pJob->SaveWithRetry(NULL, FALSE, SAVEP_PRESERVE_NET_SCHEDULE);

                if (FAILED(hr))
                {
                    ERR_OUT("RunJobs, Saving run-now", hr);
                }
            }
            continue;
        }

        //
        // pCurRun->m_dwMaxRunTime is a time period starting now.
        // Convert it to an absolute time in pRun->m_ftKill.
        //
        pCurRun->AdjustKillTimeByMaxRunTime(ftRun);

        //
        // Isolate the executable name for logging purposes.
        //

        TCHAR tszExeName[MAX_PATH + 1];

        GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

        //
        // JOB_I_FLAG_RUN_NOW tasks run regardless of the battery or idle
        // flags, so check those flags if JOB_I_FLAG_RUN_NOW is not set.
        //
        if (!pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW) &&
            pJob->IsFlagSet(TASK_FLAG_DONT_START_IF_ON_BATTERIES) &&
            g_fOnBattery)
        {
            //
            // The task is set to not run when on batteries, and we
            // are on batteries now, so log the reason for not running.
            //
            LogTaskError(pCurRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_ON_BATTERIES,
                         NULL);

            //
            // Remove the job element from the list.
            //
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;

            continue;
        }

        //
        // If the job has TASK_FLAG_SYSTEM_REQUIRED, make sure the system
        // doesn't go to sleep between the time it's launched and the time
        // we call SubmitJobs().
        //
        if (pJob->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED) && !fKeptAwake)
        {
            WrapSetThreadExecutionState(TRUE, "(RunJobs - launching task)");
            fKeptAwake = TRUE;
        }

        HRESULT hrRet;

        //
        // Launch job.
        //
        hr = RunNTJob(pJob, pCurRun, &hrRet, &dwErrMsgID);
        if (FAILED(hr))
        {
            //
            // Fatal task scheduler error, exit the loop.
            //
            break;
        }

        if (hr == S_FALSE)
        {
            //
            // Job failed to launch, but not a fatal task scheduler error.
            //
            fLaunchSucceeded = FALSE;

            //
            // An hrRet of S_FALSE indicates to skip error logging.
            //
            if (hrRet == S_FALSE)
            {
                goto WriteLog;
            }
        }
        else
        {
            fLaunchSucceeded = TRUE;
        }

        //
        // Update the job object with the current status. Updates to the
        // running instance count are guarded by the critical section here,
        // where it is incremented, and in PostJobProcessing, where it is
        // decremented.
        // We have to read the variable-length data because if the job
        // succeeds, we have to write the variable-length data (see the
        // comment on this below).
        //

        EnterCriticalSection(&m_SvcCriticalSection);

        hr = ActivateWithRetry(pCurRun->GetName(), &pJob, TRUE);
        if (FAILED(hr))
        {
            ERR_OUT("RunJobs 2nd Activate", hr);
            //
            // We are in deep stink if the job can't be activated. The only
            // workable cause would be if the job object was deleted sometime
            // between the activation at the top of this function and here.
            // If some 3rd party app opened the job object in exclusive mode,
            // then there is nothing we can do.
            //
            LeaveCriticalSection(&m_SvcCriticalSection);
            goto WriteLog;
        }

        if (fLaunchSucceeded)
        {
            pJob->ClearFlag(JOB_I_FLAG_LAST_LAUNCH_FAILED);

            pJob->SetStartError(S_OK);

            pJob->m_stMostRecentRunTime = stRun;

            if (pCurRun->IsFlagSet(RUN_STATUS_RUNNING))
            {
                pJob->m_cRunningInstances++;

                schDebugOut((DEB_ITRACE, "RunJobs: incremented running instance "
                             "count (%d after increment)\n",
                             pJob->m_cRunningInstances));

                pJob->UpdateJobState(TRUE);
            }
            else
            {
                //
                // This happens if we launched the job in a way that didn't
                // give us a handle to wait on for job completion.  We have
                // to set the job state to not running.
                //
                pJob->UpdateJobState(FALSE);
            }
        }
        else
        {
            pJob->SetFlag(JOB_I_FLAG_LAST_LAUNCH_FAILED);

            pJob->SetStartError(hrRet);
        }

        pJob->ClearFlag(JOB_I_FLAG_RUN_NOW | JOB_I_FLAG_MISSED);
        pJob->SetFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);

        //
        // Write the updated status to the job object.
        // If !fLaunchSucceeded, write flags without touching running instance
        // count.
        // We have to write the variable-length data solely to write the
        // StartError.
        //

        if (fLaunchSucceeded)
        {
            hr = pJob->SaveWithRetry(NULL,
                                     FALSE,
                                     SAVEP_PRESERVE_NET_SCHEDULE |
                                     SAVEP_VARIABLE_LENGTH_DATA  |
                                     SAVEP_RUNNING_INSTANCE_COUNT);
        }
        else
        {
            hr = pJob->SaveWithRetry(NULL,
                                     FALSE,
                                     SAVEP_PRESERVE_NET_SCHEDULE |
                                     SAVEP_VARIABLE_LENGTH_DATA);
        }

        if (FAILED(hr))
        {
            ERR_OUT("RunJobs, Saving run-state", hr);
        }

        LeaveCriticalSection(&m_SvcCriticalSection);

WriteLog:
        if (fLaunchSucceeded)
        {
            // Log job start.
            //

            LogTaskStatus(pCurRun->GetName(),
                          tszExeName,
                          pCurRun->IsFlagSet(RUN_STATUS_RUNNING) ?
                            IDS_LOG_JOB_STATUS_STARTED :
                            IDS_LOG_JOB_STATUS_STARTED_NO_STOP);

            fNothingRan = FALSE;

            if (pJob->IsFlagSet(TASK_FLAG_KILL_ON_IDLE_END))
            {
                fNeedIdleLossNotify = TRUE;
            }
        }
        else
        {
            if (hrRet != S_FALSE)
            {
                // Log start error. The failure code is recorded in the
                // scheduler log.
                //

                DWORD dwHelpHint;

                if (dwErrMsgID == IDS_LOG_JOB_ERROR_FAILED_START)
                {
                    if (hrRet == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES))
                    {
                        // Per bug
                        //    54843 : Jobs not run due to system resource
                        //            shortage give wrong error
                        //
                        dwHelpHint = IDS_HELP_HINT_CLOSE_APPS;
                    }
                    else
                    {
                        dwHelpHint = IDS_HELP_HINT_BROWSE;
                    }
                }
                else if (dwErrMsgID == IDS_FILE_ACCESS_DENIED)
                {
                    dwHelpHint = IDS_FILE_ACCESS_DENIED_HINT;
                }
                else if (dwErrMsgID != IDS_FAILED_NS_ACCOUNT_RETRIEVAL &&
                         dwErrMsgID != IDS_FAILED_ACCOUNT_RETRIEVAL    &&
                         dwErrMsgID != IDS_NS_ACCOUNT_LOGON_FAILED)
                {
                    dwHelpHint = IDS_HELP_HINT_LOGON;
                }
                else
                {
                    dwHelpHint = 0;
                }

                LogTaskError(pCurRun->GetName(),
                             tszExeName,
                             IDS_LOG_SEVERITY_ERROR,
                             dwErrMsgID,
                             NULL,
                             hrRet,
                             dwHelpHint);

               //
               // Check if this is an AT job and log it to the
               // event log to maintain NT4 compatibility
               //

               if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
               {
                  LPWSTR StringArray[2];
                  WCHAR szNumberString[24];

                  StringArray[0] = pCurRun->GetName();
                  // need space for the numeric coversion + the %% symbols
                  StringCchCopy(szNumberString, 24, L"%%");
                  _ultow(hrRet, szNumberString + 2, 10);
                  StringArray[1] = szNumberString;
                  // EVENT_COMMAND_START_FAILED -
                  //  The %1 command failed to start due to the following error: %2
                  if (! ReportEvent(g_hAtEventSource,     // handle to source
                       EVENTLOG_ERROR_TYPE,            // event type to log
                       0,                              // category
                       EVENT_COMMAND_START_FAILED,     // EventID
                       NULL,                           // User SID
                       2,                              // Number of strings
                       0,                              // raw data length
                       (LPCWSTR *)StringArray,         // Strings for substitution
                       NULL))                          // raw data pointer
                  {
                        // Not fatal, but why did we fail to report the job error?
                        ERR_OUT("Failed to report the access denied event", GetLastError());
                  }
               }
            }
        }

        //
        // Move to the next job in the list.
        //
        CRun * pRun = pCurRun;
        pCurRun = pRun->Next();

        if (!(fLaunchSucceeded && pRun->IsFlagSet(RUN_STATUS_RUNNING)))
        {
            //
            // Remove pCurRun from the list and dispose of it.
            //
            pRun->UnLink();
            delete pRun;
        }
    } while (!pCurRun->IsNull());

    if (pJob)
    {
        pJob->Release();
    }

    if (FAILED(hr))
    {
        fNothingRan = pJobList->GetFirstJob()->IsNull();
        //
        // Free any job info objects for jobs not already launched.
        //
        CRun * pRun;
        while (!pCurRun->IsNull())
        {
            pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
        }
    }
    if (fNothingRan)
    {
        delete pJobList;
        if (fKeptAwake)
        {
            WrapSetThreadExecutionState(FALSE, "(RunJobs - nothing ran)");
        }
        return hr;
    }

    CJobProcessor * pjpNext, * pjp = gpJobProcessorMgr->GetFirstProcessor();

    while (!pJobList->GetFirstJob()->IsNull() && SUCCEEDED(hr))
    {
        //
        // Construct another processor, if necessary.
        //

        if (pjp == NULL)
        {
            hr = gpJobProcessorMgr->NewProcessor(&pjp);

            if (hr == S_FALSE)
            {
                //
                // The service is stopping. Shut down the processor.
                //

                pjp->Shutdown();
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        if (!ResetEvent(m_hMiscBlockEvent))
        {
            ERR_OUT("ResetEvent", GetLastError());
        }

        hr = pjp->SubmitJobs(pJobList);

        if (hr == S_SCHED_JOBS_ACCEPTED)
        {
            //
            // Wait for the processor thread to notice the jobs and call
            // SetThreadExecutionState if necessary.  If we didn't wait here,
            // we could return and call SetThreadExecutionState(ES_CONTINUOUS)
            // and the system could go to sleep even though a SYSTEM_REQUIRED
            // task had been started.
            //
            WaitForSingleObject(m_hMiscBlockEvent, INFINITE);
        }

        if (hr == S_FALSE)
        {
            //
            // The service is stopping. Shut down the processor.
            //

            pjp->Shutdown();
            break;
        }

        pjpNext = pjp->Next();
        pjp->Release();
        pjp = pjpNext;
    }

    if (fKeptAwake)
    {
        WrapSetThreadExecutionState(FALSE, "(RunJobs - returning)");
    }

    if (pjp != NULL)
    {
        pjp->Release();
    }

    if (fNeedIdleLossNotify)
    {
        //
        // Some of the jobs started had KILL_ON_IDLE_END set, so request
        // loss-of-idle notification.
        //
        SetIdleLossNotification();
    }

    delete pJobList;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::DiscardExpiredJobs
//
//  Synopsis:   Get the next run wait and pop expired jobs off of the stack.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::DiscardExpiredJobs()
{
    TRACE(CSchedWorker, DiscardExpiredJobs);
    // CODEWORK  Make this more efficient by not calling GetNextRunWait.

    while (!m_WaitList.IsEmpty() && GetNextRunWait() == 0)
    {
        // The job at the top of the list has expired.
        //
        CRun * pRun = m_WaitList.Pop();
        if (pRun)
        {
            schDebugOut((DEB_ITRACE, "The run time for %S has elapsed!\n",
                         pRun->GetName()));
            delete pRun;
        }
    }

    // Don't back up past the present time.
    m_ftBeginWaitList = GetLocalTimeAsFileTime();
}

//+----------------------------------------------------------------------------
//
//  Function:   SchInit
//
//  Synopsis:   Initializes the schedule service
//
//  Returns:    HRESULTS/Win32 error codes
//
//-----------------------------------------------------------------------------
HRESULT
SchInit(void)
{
    HRESULT hr;
    HANDLE  hEvent;

    //
    // Initialize the folder path and name extension globals.
    //

    hr = InitGlobals();

    if (FAILED(hr))
    {
        ERR_OUT("InitGlobals", hr);
        return hr;
    }

    //
    // Allocate the Thread Local Storage slot that holds the "keep machine
    // awake" ref count for each thread
    //
    g_WakeCountSlot = TlsAlloc();
    if (g_WakeCountSlot == 0xFFFFFFFF)
    {
        ERR_OUT("TlsAlloc for WakeCountSlot", GetLastError());
        schAssert(!"TlsAlloc for WakeCountSlot failed");
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Initialize this thread's keep-awake count.
    //

    InitThreadWakeCount();

    //
    // Initialize security subsystem.
    //

    hr = InitSS();

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Perform any necessary data conversions
    //
    hr = PerformDataConversions();
    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Create & initialize scheduling agent window/desktop.
    //

    if (!InitializeSAWindow())
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    //
    // Check to see if starting at system start or if manually by a user.  If
    // the Service Controller has signalled the "autostart complete" event,
    // the service is being demand-started.  Otherwise (and on failure),
    // assume auto-started.
    //

    hEvent = OpenEvent(SYNCHRONIZE,
                       FALSE,
                       SC_AUTOSTART_EVENT_NAME);

    if (hEvent != NULL)
    {
        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        {
            //
            // Event is signalled, meaning service auto-start
            // already finished.  Therefore, the service has
            // been started by the user.
            //
            schDebugOut((DEB_ITRACE, "Service has been demand-started\n"));

            g_fUserStarted = TRUE;
        }
        else
        {
            schDebugOut((DEB_ITRACE, "Service has been auto-started\n"));
        }

        CloseHandle(hEvent);
    }
    else
    {
        ERR_OUT("OpenEvent", GetLastError());
    }

    schDebugOut((DEB_ITRACE, "g_fUserStarted = %s\n",
                 g_fUserStarted ? "TRUE" : "FALSE"));

    //
    // Create and initialize the service worker class
    //

    g_pSched = new CSchedWorker;
    if (g_pSched == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CSchedWorker", hr);
        goto CloseLogExit;
    }

    hr = g_pSched->Init();

    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init", hr);
        goto CloseLogExit;
    }

    //
    // Create the job processor manager.
    //

    gpJobProcessorMgr = new CJobProcessorMgr;
    if (gpJobProcessorMgr == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CJobProcessorMgr", hr);
        goto CloseLogExit;
    }

    //
    // Create the Worker thread manager.
    //

    gpThreadMgr = new CWorkerThreadMgr;
    if (gpThreadMgr == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CWorkerThreadMgr", hr);
        goto CloseLogExit;
    }
    
    if (!gpThreadMgr->Initialize())

    {
        hr = E_FAIL;
        ERR_OUT("Thread manager initialization", GetLastError());
        goto CloseLogExit;
    }

    //
    // Create the service scavenger task. Note, no thread associated
    // with it initially.
    //

    gpSAScavengerTask = new CSAScavengerTask(SCAVENGER_START_WAIT_TIME);
    if (gpSAScavengerTask == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CSAScavengerTask", hr);
        goto CloseLogExit;
    }

    hr = gpSAScavengerTask->Initialize();

    if (FAILED(hr))
    {
        ERR_OUT("Scavenger task initialization", hr);
        goto CloseLogExit;
    }

    return(S_OK);

CloseLogExit:
    if (g_pSched)
    {
        delete g_pSched;
        g_pSched = NULL;
    }

    if (gpJobProcessorMgr)
    {
        delete gpJobProcessorMgr;
        gpJobProcessorMgr = NULL;
    }

    if (gpThreadMgr)
    {
        delete gpThreadMgr;
        gpThreadMgr = NULL;
    }

    if (gpSAScavengerTask)
    {
        delete gpSAScavengerTask;
        gpSAScavengerTask = NULL;
    }

    CloseLogFile();

ErrorExit:
    UninitializeSAWindow();
    UninitSS();

    if (g_WakeCountSlot != 0xFFFFFFFF)
    {
        TlsFree(g_WakeCountSlot);
        g_WakeCountSlot = 0xFFFFFFFF;
    }
    
    FreeGlobals();
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   SchCleanup
//
//  Synopsis:   exit cleanup for the schedule service
//
//-----------------------------------------------------------------------------
void
SchCleanup(void)
{
    //
    // Shutdown processor & thread managers.
    //
    // NB : Placing this call first to give threads time to exit.
    //

    if (gpJobProcessorMgr != NULL)
    {
        gpJobProcessorMgr->Shutdown();
    }
    if (gpThreadMgr != NULL)
    {
        gpThreadMgr->Shutdown(FALSE);
    }

    //
    // Shut down the scavenger task thread, if it is running.
    //

    if (gpSAScavengerTask != NULL)
    {
        gpSAScavengerTask->Shutdown();
    }

    //
    // Stop the RPC server.
    //

    StopRpcServer();

    //
    // Cleanup data associated with the Net Schedule API support code.
    //

    UninitializeNetScheduleApi();

    //
    // Close scheduling agent window/desktop.
    //

    UninitializeSAWindow();

    //
    // DO NOT delete the thread manager & processor manager objects if
    // worker threads remain active. This case is *highly* unlikely.
    //

    BOOL fNoWorkerThreadsActive = TRUE;

    if (gpThreadMgr != NULL)
    {
        //
        // Invoke shutdown one last time with the wait on worker thread
        // termination option specified.
        //

        if (gpThreadMgr->GetThreadCount() != 0)
        {
            fNoWorkerThreadsActive = gpThreadMgr->Shutdown(TRUE);
        }
        else
        {
            delete gpThreadMgr;
            gpThreadMgr = NULL;
        }
    }

    //
    // free up globals and delete AFTER threads are gone,
    // otherwise a thread might try to access something
    // we've already deleted
    //
    FreeGlobals();

    if (g_pSched != NULL)
    {
        delete g_pSched;
        g_pSched = NULL;
    }


    //
    // Uninitialize security subsystem.
    //

    UninitSS();

    if (gpSAScavengerTask != NULL && fNoWorkerThreadsActive)
    {
        delete gpSAScavengerTask;
        gpSAScavengerTask = NULL;
    }

    if (gpJobProcessorMgr != NULL && fNoWorkerThreadsActive)
    {
        delete gpJobProcessorMgr;
        gpJobProcessorMgr = NULL;
    }

    g_fUserStarted = FALSE;

    if (g_WakeCountSlot != 0xFFFFFFFF) {
        TlsFree(g_WakeCountSlot);
        g_WakeCountSlot = 0xFFFFFFFF;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetExeNameFromCmdLine
//
//  Synopsis:   Copy the relative executable name from the command line into
//              a buffer.
//
//  Arguments:  [pwszCmdLine]  -- Command line.
//              [ccBufferSize] -- Size of buffer in characters
//              [szBuffer]     -- Buffer to store name.
//
//  Returns:    None.
//
//  Notes:      The command line argument string is modified & restored!
//
//----------------------------------------------------------------------------
VOID
GetExeNameFromCmdLine(LPCWSTR pwszCmdLine, DWORD ccBufferSize, TCHAR tszBuffer[])
{
    LPCWSTR pwszExeName;

    tszBuffer[0] = TEXT('\0');               // In case of error.

    if (pwszCmdLine == NULL || !*pwszCmdLine)
    {
        return;
    }

    // Isolate the relative executable filename from the command line.
    //
    // Note that the cmd line string is actually just the application
    // name - no arguments.
    //
    for (pwszExeName = pwszCmdLine + wcslen(pwszCmdLine) - 1;
            pwszExeName != pwszCmdLine; pwszExeName--)
    {
        if (*pwszExeName == L'\\' || *pwszExeName == L':')
        {
            pwszExeName++;
            break;
        }
    }

    // Copy executable name.
    //
    if (*pwszExeName)
    {
        // Make sure the buffer is large enough.  If not,
        // return the same error as WideCharToMultiByte
        //
        if (wcslen(pwszExeName) + 1 > ccBufferSize)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }
        else
        {
            StringCchCopy(tszBuffer, ccBufferSize, pwszExeName);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateSADatServiceFlags
//
//  Synopsis:   Called by the service code to update the service flag settings
//              in the file, SA.DAT, located in the local tasks folder.
//
//  Arguments:  [ptszFolderPath]  -- Tasks folder path.
//              [rgfServiceFlags] -- Flags to update.
//              [fClear]          -- TRUE, clear the flags indicated; FALSE,
//                                   set them.
//
//  Returns:    SADatGet/SetData return codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
UpdateSADatServiceFlags(
    LPTSTR ptszFolderPath,
    BYTE   rgfServiceFlags,
    BOOL   fClear)
{
    BYTE    rgbData[SA_DAT_VERSION_ONE_SIZE];
    HANDLE  hSADatFile;
    HRESULT hr;

    //
    // Update the flags in the service flags field of SA.DAT (in the Tasks
    // folder).
    //

    hr = SADatGetData(ptszFolderPath,
                      SA_DAT_VERSION_ONE_SIZE,
                      rgbData,
                      &hSADatFile);

    if (SUCCEEDED(hr))
    {
        if (fClear)
        {
            rgbData[SA_DAT_SVCFLAGS_OFFSET] &= ~rgfServiceFlags;
        }
        else
        {
            rgbData[SA_DAT_SVCFLAGS_OFFSET] |= rgfServiceFlags;
        }

        hr = SADatSetData(hSADatFile, SA_DAT_VERSION_ONE_SIZE, rgbData);

        CloseHandle(hSADatFile);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\sysprep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright(C) 2002 Microsoft Corporation
//
//  File: sysprep.cxx
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#include "security.hxx"
#include "sysprep.hxx"

static WCHAR          gwszSysprepKey[]      = L"TSSK"; // Task Scheduler Sysprep Key
static WCHAR          gwszSysprepIdentity[] = L"TSSI"; // Task Scheduler Sysprep Identity Data

// needed by ScavengeSASecurityDBase
extern  SERVICE_STATUS  g_SvcStatus;
#define SERVICE_RUNNING 0x00000004

//+---------------------------------------------------------------------------
//
//  Function:   GetUniqueSPSName
//
//  Synopsis:   calls NewWorkItem a few times trying to get a unique file name out of it
//
//  Arguments:  ITaskScheduler *pITaskScheduler, IUnknown** pITask
//              WCHAR* pwszTaskName, to receive the name that was actually
//              used in the creation of the task
//
//  Returns:    Various HRESULTs
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT GetUniqueSPSName(ITaskScheduler* pITaskScheduler, ITask** ppITask, WCHAR* pwszTaskName)
{
    HRESULT hr = E_FAIL; 
    
    // okay, so we're not distinguishing between errors, code's simpler
    // and the only expectable error is "already exists"
    for (int i = 0; (i < 16) && FAILED(hr); i++)
    {
        if (FAILED(StringCchPrintf(pwszTaskName, 20, L"$~$Sys%X$", i)))
            break;
    
        hr = pITaskScheduler->NewWorkItem(pwszTaskName,           
             CLSID_CTask,            
             IID_ITask,              
             (IUnknown**)ppITask); 
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrepSysPrepTask
//
//  Synopsis:   Creates a task to be run which will call run the sysprep
//              code in the local system account
//
//  Arguments:  Task** ppITaskToRun, to receive pointer to ITask interface
//              task is to activated by calling the Run() method
//              WCHAR* pwszTaskName, to receive the name that was actually
//              used in the creation of the task
//
//  Returns:    Various HRESULTs
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT PrepSysPrepTask(ITask** ppITaskToRun, WCHAR* pwszTaskName)
{
    HRESULT hr = E_FAIL;
    WCHAR applicationName[MAX_PATH +1];
    WCHAR argument[MAX_PATH +20];
    DWORD expandedSize;

    expandedSize = ExpandEnvironmentStrings(L"\"%SystemRoot%\\System32\\rundll32.exe\"", applicationName, MAX_PATH +1);
    if ((0 == expandedSize) || expandedSize > (MAX_PATH +1))
        return HRESULT_FROM_WIN32(GetLastError());

    expandedSize = ExpandEnvironmentStrings(L"\"%SystemRoot%\\System32\\SchedSvc.dll\",SysPrepCallback", argument, MAX_PATH +20);
    if ((0 == expandedSize) || expandedSize > (MAX_PATH +1))
        return HRESULT_FROM_WIN32(GetLastError());

    TASK_TRIGGER tigger;
    tigger.wStartHour = 10;            
    tigger.wStartMinute = 20;          
    tigger.wBeginYear = 1957;            
    tigger.wBeginMonth = 6;           
    tigger.wBeginDay = 14;             

    tigger.wEndYear = 2001;              
    tigger.wEndMonth = 10;              
    tigger.wEndDay = 8 ;               
    tigger.MinutesDuration = 0;      
    tigger.MinutesInterval = 0;      
    tigger.rgFlags = 0;              
    tigger.TriggerType = TASK_TIME_TRIGGER_ONCE;
    tigger.Reserved2 = 0;
    tigger.wRandomMinutesInterval = 0;
    tigger.cbTriggerSize = sizeof(TASK_TRIGGER);
    tigger.Reserved1 = 0;

    ITaskScheduler *pITaskScheduler = NULL;
    ITask *pITask = NULL;
    IPersistFile *pIPersistFile = NULL;
    ITaskTrigger* pTrigger = NULL;    
    WORD idontcare;

    hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pITaskScheduler);
    if (SUCCEEDED(hr) && 
        SUCCEEDED(hr = GetUniqueSPSName(pITaskScheduler, &pITask, pwszTaskName)) &&
        SUCCEEDED(hr = pITask->SetApplicationName(applicationName)) &&
        SUCCEEDED(hr = pITask->SetParameters(argument)) &&
        SUCCEEDED(hr = pITask->SetFlags(TASK_FLAG_DELETE_WHEN_DONE | TASK_FLAG_DISABLED))     &&
        SUCCEEDED(hr = pITask->SetAccountInformation(L"", NULL))     &&
        SUCCEEDED(hr = pITask->CreateTrigger(&idontcare, &pTrigger))  &&
        SUCCEEDED(hr = pTrigger->SetTrigger(&tigger))                  &&
        SUCCEEDED(hr = pITask->QueryInterface(IID_IPersistFile, (void **)&pIPersistFile)) &&
        SUCCEEDED(hr = pIPersistFile->Save(NULL, TRUE)))
    {
        // return it to the caller
        *ppITaskToRun = pITask;
    }
    else
        if (pITask)
            pITask->Release();

    if (pITaskScheduler)
        pITaskScheduler->Release();

    if (pIPersistFile)
        pIPersistFile->Release();

    if (pTrigger)
        pTrigger->Release();

    return hr;   
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveSysprepInfo
//
//  Synopsis:   Saves job identity and credential key information prior to Sysprep
//              so that it can be used to convert old data after Sysprep.
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT SaveSysprepInfo(void)
{
    //
    //  Initialize security
    //
    InitSS();
    SetMysteryDWORDValue();

    HRESULT hr = PreProcessNetScheduleJobs();
    if (FAILED(hr))
    {
        // ignore, we still need to do the other processing
    }

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //
    HCRYPTPROV hCSP = NULL;
    hr = GetCSPHandle(&hCSP);
    if (SUCCEEDED(hr))
    {
        if (hCSP)
        {
            //
            // We've got the handle, now save the important stuff
            //
            hr = SaveSysprepKeyInfo(hCSP);
            if (SUCCEEDED(hr))
            {
                hr = SaveSysprepIdentityInfo(hCSP);
            }

            CloseCSPHandle(hCSP);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    //
    // Done doing security stuff
    //
    UninitSS();

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveSysprepKeyInfo
//
//  Synopsis:   Stores the computed CredentialKey as a secret prior to sysprep so that it can be
//              retrieved and used to decrypt credentials after sysprep, so those credentials may
//              be encrypted again using the post-sysprep key.
//
//  Arguments:  hCSP - handle to the crypto service provider
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT SaveSysprepKeyInfo(HCRYPTPROV hCSP)
{
    //
    // Generate the encryption key
    //
    RC2_KEY_INFO RC2KeyInfo;
    HRESULT hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);
    if (SUCCEEDED(hr))
    {
        //
        // Write the key to LSA
        //
        hr = WriteLsaData(sizeof(gwszSysprepKey), gwszSysprepKey, sizeof(RC2KeyInfo), (BYTE*)&RC2KeyInfo);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveSysprepIdentityInfo
//
//  Synopsis:   Obtains the credential index and NULL password setting for each
//              existing job identity and stores that information along with the
//              associated filename in an LSA secret so that the identities can
//              be rehashed and stored in the identity database, postsysprep,
//              still associated with the correct credential.
//
//  Arguments:  hCSP - handle to the crypto service provider
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT SaveSysprepIdentityInfo(HCRYPTPROV hCSP)
{
    WCHAR* pwszTasksFolder = NULL;
    HANDLE hFileEnum = INVALID_HANDLE_VALUE;
    DWORD  cbSAI;
    DWORD  cbSAC;
    BYTE*  pbSAI = NULL;
    BYTE*  pbSAC = NULL;

    //
    // First, read the security database so we can do the lookups
    // 
    HRESULT hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);
    if (SUCCEEDED(hr))
    {
        if (cbSAI <= SAI_HEADER_SIZE)
        {
            //
            // Database empty, nothing to do.
            //
        }
        else
        {
            //
            // Enumerate job objects in the task's folder directory.
            //
            hr = GetTasksFolder(&pwszTasksFolder);
            if (SUCCEEDED(hr))
            {
                WCHAR wszSearchPath[MAX_PATH + 1];
                hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCat(wszSearchPath, MAX_PATH + 1, EXTENSION_WILDCARD TSZ_JOB);
                    if (SUCCEEDED(hr))
                    {
                        WIN32_FIND_DATA fd;
                        DWORD dwRet = 0;
                        if ((hFileEnum = FindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE)
                        {
                            //
                            // Either no jobs (this is OK), or an error occurred.
                            //
                            dwRet = GetLastError();
                            if (dwRet != ERROR_FILE_NOT_FOUND)
                                hr = _HRESULT_FROM_WIN32(dwRet);
                        }
                        else
                        {
                            //
                            // Must concatenate the filename returned from the enumeration onto the folder path
                            // before computing the hash.  Prepare for doing that repeatedly by taking the path,
                            // adding a slash, and remembering the next character position.
                            //
                            hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
                            if (SUCCEEDED(hr))
                            {
                                DWORD iConcatenation = lstrlenW(pwszTasksFolder);
                                wszSearchPath[iConcatenation++] = L'\\';
            
                                //
                                // Allocate buffer used to collect identity data that will be written to the LSA secret
                                //
                                BYTE  rgbIdentityData[MAX_SECRET_SIZE];
                                BYTE* pbCurrentData = (BYTE*)&rgbIdentityData;
                                DWORD cbIdentityData = 0;
            
                                //
                                // Process each found file
                                //
                                BYTE  rgbIdentity[HASH_DATA_SIZE];
                                BOOL  bIsPasswordNull;
                                DWORD dwCredentialIndex;
                                DWORD cbFileName;
            
                                while (dwRet != ERROR_NO_MORE_FILES)
                                {
                                    //
                                    // Truncate the existing name after the folder path,
                                    // then concatenate the new filename onto it.
                                    //
                                    wszSearchPath[iConcatenation] = L'\0';
                                    if (SUCCEEDED(StringCchCat(wszSearchPath, MAX_PATH + 1, fd.cFileName)))
                                    {
                                        //
                                        // Hash the job into a unique identity.
                                        //
                                        if (SUCCEEDED(HashJobIdentity(hCSP, wszSearchPath, rgbIdentity)))
                                        {
                                            //
                                            // Find the identity in the SAI for this job
                                            //
                                            hr = SAIFindIdentity(rgbIdentity,
                                                                 cbSAI,
                                                                 pbSAI,
                                                                 &dwCredentialIndex,
                                                                 &bIsPasswordNull,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL);
                                            //
                                            // S_OK means the identity was found; S_FALSE means it wasn't
                                            // Other codes are errors.  We process only the S_OKs, of course.
                                            //
                                            if (S_OK == hr)
                                            {
                                                cbFileName = (lstrlenW(fd.cFileName) + 1) * sizeof(WCHAR);
                                                
                                                if ((cbIdentityData + cbFileName + sizeof(BOOL) + sizeof(DWORD)) > MAX_SECRET_SIZE)
                                                {
                                                    // 
                                                    // this should _never_ happen, as we shouldn't be able to exceed the size
                                                    // given that we only add data for jobs that have already been found in
                                                    // the SAI, and we are collecting less data than was stored there
                                                    //
                                                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                                                    break;
                                                }
                
                                                CopyMemory(pbCurrentData, fd.cFileName, cbFileName);
                                                pbCurrentData += cbFileName;
                                                CopyMemory(pbCurrentData, &bIsPasswordNull, sizeof(BOOL));
                                                pbCurrentData += sizeof(BOOL);
                                                CopyMemory(pbCurrentData, &dwCredentialIndex, sizeof(DWORD));
                                                pbCurrentData += sizeof(DWORD);
                                                cbIdentityData += (cbFileName + sizeof(BOOL) + sizeof(DWORD));                
                                            }
                                            else
                                            {
                                                hr = S_OK;  // OK, we failed this one, go on to the next
                                            }
                                        }
                                    }
                                
                                    if (!FindNextFile(hFileEnum, &fd))
                                    {
                                        dwRet = GetLastError();
                                        if (dwRet != ERROR_NO_MORE_FILES)
                                            hr = _HRESULT_FROM_WIN32(dwRet);
                
                                        break;
                                    }
                                }
                
                                if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
                                {
                                    hr = WriteLsaData(sizeof(gwszSysprepIdentity), gwszSysprepIdentity, cbIdentityData, (BYTE*)&rgbIdentityData);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (pbSAI) LocalFree(pbSAI);
    if (pbSAC) LocalFree(pbSAC);

    if (pwszTasksFolder)
        delete [] pwszTasksFolder;

    if (hFileEnum != INVALID_HANDLE_VALUE)
        FindClose(hFileEnum);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PreProcessNetScheduleJobs
//
//  Synopsis:   Netschedule jobs (AT jobs) are signed internally with a hash so
//              that the service can validate their authenticity at run time.
//              Sysprep changes important data used by the Crypto API such that
//              the generated hash will be different and can never match the hash
//              stored in the AT job.  In order to be runnable again, the AT jobs
//              must be signed again with the new hash.
//
//              *** WARNING ***
//              This means that if someone could drop a bogus AT job into the tasks
//              folder, it would automatically get signed as a result of running sysprep.
//              In order to prevent this, check all AT jobs prior to sysprep and
//              eliminate any that are not valid.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT PreProcessNetScheduleJobs(void)
{
    HANDLE hFileEnum = INVALID_HANDLE_VALUE;

    WCHAR* pwszTasksFolder = NULL;
    HRESULT hr = GetTasksFolder(&pwszTasksFolder);
    if (SUCCEEDED(hr))
    {
        WCHAR wszSearchPath[MAX_PATH + 1];
        hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(wszSearchPath, MAX_PATH + 1, L"\\" TSZ_AT_JOB_PREFIX L"*" TSZ_DOTJOB);
            if (SUCCEEDED(hr))
            {
                WIN32_FIND_DATA fd;
                DWORD dwRet = 0;
                if ((hFileEnum = FindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE)
                {
                    //
                    // Either no jobs (this is OK), or an error occurred.
                    //
                    dwRet = GetLastError();
                    if (dwRet != ERROR_FILE_NOT_FOUND)
                        hr = _HRESULT_FROM_WIN32(dwRet);
                }
                else
                {
                    //
                    // Must concatenate the filename returned from the enumeration onto the folder path
                    // before loading the job.  Prepare for doing that repeatedly by taking the path,
                    // adding a slash, and remembering the next character position.
                    //
                    hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, pwszTasksFolder);
                    if (SUCCEEDED(hr))
                    {
                        DWORD iConcatenation = lstrlenW(pwszTasksFolder);
                        wszSearchPath[iConcatenation++] = L'\\';
                
                        //
                        // Process each found file
                        //
                        while (dwRet != ERROR_NO_MORE_FILES)
                        {
                            //
                            // Truncate the existing name after the folder path,
                            // then concatenate the new filename onto it.
                            //
                            wszSearchPath[iConcatenation] = L'\0';
                            if (SUCCEEDED(StringCchCat(wszSearchPath, MAX_PATH + 1, fd.cFileName)))
                            {
                                //
                                // Load and check signature of each job
                                //
                                CJob* pJob = CJob::Create();
                                if (!pJob)
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                                
                                if (SUCCEEDED(pJob->Load(wszSearchPath, 0)))
                                {
                                    if (!pJob->VerifySignature())
                                    {
                                        if (!DeleteFile(wszSearchPath))
                                        {
                                            dwRet = GetLastError();
                                            
                                            // go on anyway                                            
                                        }
                                    }
                                }
                    
                                pJob->Release();
                            }
                
                            if (!FindNextFile(hFileEnum, &fd))
                            {
                                dwRet = GetLastError();
                                if (dwRet != ERROR_NO_MORE_FILES)
                                    hr = _HRESULT_FROM_WIN32(dwRet);
                
                                break;
                            }
                        }
                    }
                }
            
                if (hFileEnum != INVALID_HANDLE_VALUE)
                    FindClose(hFileEnum);
            }
        }
    }

    if (pwszTasksFolder)
        delete [] pwszTasksFolder;

    return hr;
}








//+---------------------------------------------------------------------------
//
//  Function:   GetSysprepIdentityInfo
//
//  Synopsis:   Retrieves the stored job identity data so new hashes can be calculated.
//
//  Arguments:  pcbIdentityData - pointer to count of bytes in the identity data
//              ppIdentityData  - pointer to pointer to retrieved identity data
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT GetSysprepIdentityInfo(DWORD* pcbIdentityData, BYTE** ppIdentityData)
{
    *ppIdentityData = NULL;

    //
    // Retrieve job identity data from LSA, if it exists
    //
    HRESULT hr = ReadLsaData(sizeof(gwszSysprepIdentity), gwszSysprepIdentity, pcbIdentityData, ppIdentityData);
    if (FAILED(hr))
    {
        if (*ppIdentityData != NULL)
        {
            LocalFree(*ppIdentityData);
            *ppIdentityData = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSysprepKeyInfo
//
//  Synopsis:   Retrieves the stored pre-sysprep CredentialKey so that it can be used to decrypt
//              credentials after sysprep, so those credentials may be encrypted again using the
//              post-sysprep key.
//
//  Arguments:  pcbRC2KeyInfo   - pointer to count of bytes in key data
//              ppRC2KeyInfo    - pointer to pointer to retrieved key
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT GetSysprepKeyInfo(DWORD* pcbRC2KeyInfo, RC2_KEY_INFO** ppRC2KeyInfo)
{
    *ppRC2KeyInfo = NULL;

    //
    // Get the key from LSA
    //
    HRESULT hr = ReadLsaData(sizeof(gwszSysprepKey), gwszSysprepKey, pcbRC2KeyInfo, (BYTE**)ppRC2KeyInfo);
    if (SUCCEEDED(hr))
    {
        //
        // Check the size.  We know exactly how big this should be, so make sure it is.
        //
        if (*pcbRC2KeyInfo != sizeof(RC2_KEY_INFO))
        {
            *pcbRC2KeyInfo = 0;
            LocalFree(*ppRC2KeyInfo);
            *ppRC2KeyInfo = NULL;
            hr = E_FAIL;
        }
    }
    else  // failed!
    {
        if (*ppRC2KeyInfo != NULL)
        {
            LocalFree(*ppRC2KeyInfo);
            *ppRC2KeyInfo = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertSysprepInfo
//
//  Synopsis:   Converts credentials stored prior to sysprep so they may be decrypted after sysprep.
//              It does this by retrieving the pre-sysprep key, decrypting the credentials with it, and then
//              encrypting them using the new post-sysprep key.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertSysprepInfo(void)
{
    //
    // Initialize these up here so they will have values if we exit early
    // 
    HCRYPTPROV hCSP = NULL;
    
    BYTE* pbSAI = NULL;
    DWORD cbSAI = 0;
    BYTE* pbSAC = NULL;
    DWORD cbSAC = 0;

    RC2_KEY_INFO* pRC2KeyPreSysprep  = NULL;
    DWORD         cbRC2KeyPreSysprep = 0;
    RC2_KEY_INFO  RC2KeyPostSysprep;

    //
    //  Initialize security
    //
    InitSS();
    SetMysteryDWORDValue();

    //
    // Set this as it is relied on by ScavengeSASecurityDBase
    //
    g_SvcStatus.dwCurrentState = SERVICE_RUNNING;

    //
    // Get the tasks folder for use by ConvertNetScheduleJobs, ConvertIdentityData, and ScavengeSASecurityDBase
    //
    HRESULT hr = GetTasksFolder(&g_TasksFolderInfo.ptszPath);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Obtain a provider handle to the CSP (for use with Crypto API)
    //
    hr = GetCSPHandle(&hCSP);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Get the pre-sysprep key from LSA
    //
    hr = GetSysprepKeyInfo(&cbRC2KeyPreSysprep, &pRC2KeyPreSysprep);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Generate the post-sysprep key
    //
    hr = ComputeCredentialKey(hCSP, &RC2KeyPostSysprep);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // The Net Schedule conversions are independent of the rest of the logic,
    // so do them first and get them out of the way.
    //
    hr = ConvertNetScheduleJobs();
    if (FAILED(hr))
    {
        // ignore, we still can do our other conversions
        hr = S_OK;
    }

    hr = ConvertNetScheduleCredentialData(pRC2KeyPreSysprep, &RC2KeyPostSysprep);
    if (FAILED(hr))
    {
        // ignore, we still can do our other conversions
        hr = S_OK;
    }

    //
    // Read SAI & SAC databases.
    // It is not necessary to guard security db access with a critsec as elsewhere in the code,
    // as the service will not be running during MiniSetup and there will be no other threads accessing this data.
    //
    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Do some validations on the database
    //
    if (cbSAI <= SAI_HEADER_SIZE || pbSAI == NULL ||
        cbSAC <= SAC_HEADER_SIZE || pbSAC == NULL)
    {
        goto ErrorExit;
    }

    //
    // Place updated entries into SAI for all jobs
    //
    hr = ConvertIdentityData(hCSP, &cbSAI, &pbSAI, &cbSAC, &pbSAC);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Place updated entries into SAC for all credentials
    //
    hr = ConvertCredentialData(pRC2KeyPreSysprep, &RC2KeyPostSysprep, &cbSAI, &pbSAI, &cbSAC, &pbSAC);

    //
    // Clearing key content at earliest opportunity
    //
    SecureZeroMemory(&RC2KeyPostSysprep, sizeof(RC2KeyPostSysprep));
 
    if (SUCCEEDED(hr))
    {
        //
        // Update security database with new identities and converted credentials
        //
        hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
        if (SUCCEEDED(hr))
        {
            //
            // Allow scavenger cleanup to delete old identities
            //
            ScavengeSASecurityDBase();
        }
    }

ErrorExit:
    //
    // Delete the secrets
    //
    DeleteLsaData(sizeof(gwszSysprepKey), gwszSysprepKey);
    DeleteLsaData(sizeof(gwszSysprepIdentity), gwszSysprepIdentity);

    //
    // Clean up
    //
    if (g_TasksFolderInfo.ptszPath)
        delete [] g_TasksFolderInfo.ptszPath;

    if (hCSP) CloseCSPHandle(hCSP);
    
    if (pbSAI) LocalFree(pbSAI);
    if (pbSAC) LocalFree(pbSAC);
    
    if (pRC2KeyPreSysprep) LocalFree(pRC2KeyPreSysprep);

    //
    // Log an error & reset the SA security dbases SAI & SAC if corruption is detected.
    //
    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //
        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE*)&dwZero, sizeof(dwZero), (BYTE*)&dwZero);
    }

    //
    // Done doing security stuff
    //
    UninitSS();
    
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertNetScheduleJobs
//
//  Synopsis:   Netschedule jobs (AT jobs) are signed internally with a hash so
//              that the service can validate their authenticity at run time.
//              Sysprep changes important data used by the Crypto API such that
//              the generated hash will be different and can never match the hash
//              stored in the AT job.  In order to be runnable again, the AT jobs
//              must be signed again with the new hash.
//
//              *** WARNING ***
//              This means that if someone could drop a bogus AT job into the tasks
//              folder, it would automatically get signed as a result of running sysprep.
//              In order to prevent this, PreProcessNetScheduleJobs has already checked
//              all AT jobs prior to sysprep and eliminated any that were not valid.
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertNetScheduleJobs(void)
{
    HRESULT hr = S_OK;
    HANDLE hFileEnum = INVALID_HANDLE_VALUE;

    WCHAR wszSearchPath[MAX_PATH + 1];
    hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(wszSearchPath, MAX_PATH + 1, L"\\" TSZ_AT_JOB_PREFIX L"*" TSZ_DOTJOB);
        if (SUCCEEDED(hr))
        {
            WIN32_FIND_DATA fd;
            DWORD dwRet = 0;
            if ((hFileEnum = FindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE)
            {
                //
                // Either no jobs (this is OK), or an error occurred.
                //
                dwRet = GetLastError();
                if (dwRet != ERROR_FILE_NOT_FOUND)
                    hr = _HRESULT_FROM_WIN32(dwRet);
            }
            else
            {
                //
                // Must concatenate the filename returned from the enumeration onto the folder path
                // before loading the job.  Prepare for doing that repeatedly by taking the path,
                // adding a slash, and remembering the next character position.
                //
                hr = StringCchCopy(wszSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
                if (SUCCEEDED(hr))
                {
                    DWORD iConcatenation = lstrlenW(g_TasksFolderInfo.ptszPath);
                    wszSearchPath[iConcatenation++] = L'\\';
            
                    //
                    // Process each found file
                    //
                    while (dwRet != ERROR_NO_MORE_FILES)
                    {
                        //
                        // Truncate the existing name after the folder path,
                        // then concatenate the new filename onto it.
                        //
                        wszSearchPath[iConcatenation] = L'\0';
                        if (SUCCEEDED(StringCchCat(wszSearchPath, MAX_PATH + 1, fd.cFileName)))
                        {
                            //
                            // Load, sign, save, and release the job
                            //
                            CJob* pJob = CJob::Create();
                            if (!pJob)
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            
                            if (SUCCEEDED(pJob->Load(wszSearchPath, 0)))
                            {
                                if (SUCCEEDED(pJob->Sign()))
                                {
                                    pJob->SaveWithRetry(pJob->GetFileName(),
                                                        FALSE,
                                                        SAVEP_VARIABLE_LENGTH_DATA |
                                                        SAVEP_PRESERVE_NET_SCHEDULE);
                                }
                            }
                
                            pJob->Release();
                        }
            
                        if (!FindNextFile(hFileEnum, &fd))
                        {
                            dwRet = GetLastError();
                            if (dwRet != ERROR_NO_MORE_FILES)
                                hr = _HRESULT_FROM_WIN32(dwRet);
            
                            break;
                        }
                    }
                }
            }
        
            if (hFileEnum != INVALID_HANDLE_VALUE)
                FindClose(hFileEnum);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertIdentityData
//
//  Synopsis:   Create new job identity entries in SAI representing the existing
//              jobs on the system.  It does this by retrieving information stored
//              pre-sysprep associating each existing job with its credential, then
//              creating and storing a new identity to reference that credential.
//
//  Arguments:  hCSP   - handle to crypto service provider
//              pcbSAI - pointer to dword containing count of bytes in SAI
//              ppbSAI - pointer to pointer to SAI data
//              pcbSAC - pointer to dword containing count of bytes in SAC
//              ppbSAC - pointer to pointer to SAC data
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertIdentityData(HCRYPTPROV hCSP, DWORD* pcbSAI, BYTE** ppbSAI, DWORD* pcbSAC, BYTE** ppbSAC)
{
    //
    // Get the job identity data from LSA
    //
    BYTE* pbIdentityData = NULL;
    DWORD cbIdentityData = 0;

    HRESULT hr = GetSysprepIdentityInfo(&cbIdentityData, &pbIdentityData);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Insert updated hashes into SAI for pre-sysprep jobs
    //
    if (pbIdentityData)
    {
        //
        // Get the tasks folder and prepare buffer for use in producing job path
        //
        WCHAR  wszJobPath[MAX_PATH + 1];
        hr = StringCchCopy(wszJobPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
        if (SUCCEEDED(hr))
        {
            DWORD iConcatenation = lstrlenW(g_TasksFolderInfo.ptszPath);
            wszJobPath[iConcatenation++] = L'\\';
    
            //
            // Process each stored task
            //        
            BYTE*  pbCurrentData      = pbIdentityData;
            BYTE*  pbLastByte         = (BYTE*)(pbIdentityData + cbIdentityData - 1);
            WCHAR* pwszFileName       = NULL;
            BOOL   bIsPasswordNull;
            DWORD  dwCredentialIndex;
            BYTE   rgbIdentity[HASH_DATA_SIZE];
            BYTE*  pbIdentitySet      = NULL;
    
            while (pbCurrentData <= pbLastByte)
            {
                pwszFileName = (WCHAR*) pbCurrentData;
                pbCurrentData += ((lstrlenW(pwszFileName) + 1) * sizeof(WCHAR));
                CopyMemory(&bIsPasswordNull, pbCurrentData, sizeof(BOOL));
                pbCurrentData += sizeof(BOOL);
                CopyMemory(&dwCredentialIndex, pbCurrentData, sizeof(DWORD));
    
                if ((pbCurrentData + sizeof(DWORD)) > (pbLastByte + 1))
                {
                    // 
                    // the first DWORD after pbCurrentData is beyond the first BYTE after pbLastByte;
                    // this means that the DWORD pointed to by pbCurrentData is partially or wholly 
                    // beyond the end of the data -- something is corrupt
                    //
                    hr = E_FAIL;
                    goto ErrorExit;
                }
    
                //
                // Truncate the existing name after the folder path,
                // then concatenate the new filename onto it.
                //
                wszJobPath[iConcatenation] = L'\0';
                if (SUCCEEDED(StringCchCat(wszJobPath, MAX_PATH + 1, pwszFileName)))
                {
                    //
                    // Hash the job into a unique identity.
                    //
                    if (SUCCEEDED(HashJobIdentity(hCSP, (LPCWSTR)&wszJobPath, rgbIdentity)))
                    {
                        //
                        // Store a NULL password by flipping the last bit of the hash data.
                        //
                        if (bIsPasswordNull)
                        {
                            LAST_HASH_BYTE(rgbIdentity) ^= 1;
                        }
            
                        //
                        // Insert the job identity into the SAI identity set associated
                        // with this credential.
                        //
                        hr = SAIIndexIdentity(*pcbSAI,
                                              *ppbSAI,
                                              dwCredentialIndex,
                                              0,
                                              NULL,
                                              NULL,
                                              &pbIdentitySet);
                        if (hr == S_FALSE)
                        {
                            //
                            // The SAC & SAI databases are out of sync. Should *never* occur.
                            //
                            ASSERT_SECURITY_DBASE_CORRUPT();
                            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                            goto ErrorExit;
                        }
                        else if (SUCCEEDED(hr))
                        {
                            hr = SAIInsertIdentity(rgbIdentity,
                                                   pbIdentitySet,
                                                   pcbSAI,
                                                   ppbSAI);
                        }
                        else
                        {
                            hr = S_OK;  // OK, we failed this one, go on to the next
                        }
                    }
                }
                
                pbCurrentData += sizeof(DWORD);
            }
        }
    }

ErrorExit:
    if (pbIdentityData)
        LocalFree(pbIdentityData);
    
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertCredentialData
//
//  Synopsis:   Converts credentials stored prior to sysprep so they may be decrypted after sysprep.
//              It does this by retrieving the pre-sysprep key, decrypting the credentials with it, and then
//              encrypting them using the new post-sysprep key.
//
//  Arguments:  pRC2KeyPreSysprep - pointer to presysprep key
//              pRC2KeyPostSysprep - pointer to postsysprep key
//              pcbSAI - pointer to dword containing count of bytes in SAI
//              ppbSAI - pointer to pointer to SAI data
//              pcbSAC - pointer to dword containing count of bytes in SAC
//              ppbSAC - pointer to pointer to SAC data
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertCredentialData(RC2_KEY_INFO* pRC2KeyPreSysprep,
                              RC2_KEY_INFO* pRC2KeyPostSysprep,
                              DWORD* pcbSAI,
                              BYTE** ppbSAI,
                              DWORD* pcbSAC,
                              BYTE** ppbSAC)
{
    HRESULT hr    = S_OK;
    HRESULT hRes2 = S_OK; // for hresults that we don't want to affect our return code

    BYTE* pbEncryptedData = NULL;
    DWORD cbEncryptedData = 0;
    
    BYTE* pbSACEnd = *ppbSAC + *pcbSAC;
    BYTE* pbCredential = *ppbSAC + USN_SIZE;     // Advance past USN.
    DWORD cbCredential = 0;

    //
    // Read credential count
    //
    DWORD dwCredentialCount = 0;
    CopyMemory(&dwCredentialCount, pbCredential, sizeof(dwCredentialCount));
    pbCredential += sizeof(dwCredentialCount);

    //        
    // Loop through all credentials, decrypting, encrypting, and updating each one
    //
    JOB_CREDENTIALS jc;
    RC2_KEY_INFO    RC2KeyPreSysprepCopy;
    RC2_KEY_INFO    RC2KeyPostSysprepCopy;
    
    for (DWORD dwCredentialIndex = 0;
         (dwCredentialIndex < dwCredentialCount) && ((DWORD)(pbCredential - *ppbSAC) < *pcbSAC);
         dwCredentialIndex++
        )
    {
        //
        // Ensure sufficient space remains in the buffer.
        //
        if ((pbCredential + sizeof(cbCredential)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        CopyMemory(&cbCredential, pbCredential, sizeof(cbCredential));
        pbCredential += sizeof(cbCredential);

        //
        // Check remaining buffer size again
        //
        if ((pbCredential + HASH_DATA_SIZE) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        //
        // Check remaining buffer size yet again
        //
        if ((pbCredential + cbCredential) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        //
        // The start of the credential refers to the credential identity.
        // Skip over this to refer to the encrypted bits. Copy the pbCredential
        // and cbCredential for this dwCredentialIndex so that it can be
        // manipulated without altering the original buffer.
        //
        cbEncryptedData = cbCredential - HASH_DATA_SIZE;
        pbEncryptedData = new BYTE[cbEncryptedData];
        CopyMemory(pbEncryptedData, pbCredential + HASH_DATA_SIZE, cbEncryptedData);

        //
        // The decryption process (CBC call) clobbers the key, so make a fresh
        // copy from the source each time through the loop
        //
        CopyMemory(&RC2KeyPreSysprepCopy, pRC2KeyPreSysprep, sizeof(RC2_KEY_INFO));

        //
        // Decrypt credential using the pre-sysprep key
        //
        //           *** Important ***
        //
        // The encrypted credentials passed are decrypted *in-place*.
        // Therefore, buffer content has been compromised;
        // plus, the decrypted data must be zeroed immediately
        // following decryption (even in a failure case).
        //
        hRes2 = DecryptCredentials(RC2KeyPreSysprepCopy, cbEncryptedData, pbEncryptedData, &jc);

        //
        // Don't leave the plain-text password on the heap.
        //
        SecureZeroMemory(pbEncryptedData, cbEncryptedData);

        if (SUCCEEDED(hRes2))
        {
            //
            // The encryption process (CBC call) clobbers the key, so make a fresh
            // copy from the source each time through the loop
            //
            CopyMemory(&RC2KeyPostSysprepCopy, pRC2KeyPostSysprep, sizeof(RC2_KEY_INFO));
    
            //
            // Encrypt credential using the post-sysprep key
            //
            hRes2 = EncryptCredentials(RC2KeyPostSysprepCopy,
                                    jc.wszAccount,
                                    jc.wszDomain,
                                    jc.wszPassword,
                                    NULL,
                                    &cbEncryptedData,
                                    &pbEncryptedData);
            //
            // Don't leave the plain-text password on the stack
            //
            ZERO_PASSWORD(jc.wszPassword);
            jc.ccPassword = 0;
    
            if (SUCCEEDED(hRes2))
            {
                //
                // Update the old encrypted credential with the newly encrypted credential
                //
                hr = SACUpdateCredential(cbEncryptedData,
                                         pbEncryptedData,
                                         cbCredential,
                                         pbCredential,
                                         pcbSAC,
                                         ppbSAC);
                if (FAILED(hr))
                {
                    goto ErrorExit;  // a failure to update leaves the SAC data
                                      // in an unknown state, so we need to bail
                }
            }
        }
        
        //
        // Clean up
        //
        delete pbEncryptedData;
        pbEncryptedData = NULL;
        
        //
        // Advance to next credential.
        //
        pbCredential += (HASH_DATA_SIZE + cbEncryptedData);
    }

    //
    // Still more integrity checking.
    // Did we reach the end of the buffer exactly when we thought we should?
    // If not, something is wrong somewhere.
    //
    if ((dwCredentialIndex == dwCredentialCount) && ((DWORD)(pbCredential - *ppbSAC) != *pcbSAC) ||
        (dwCredentialIndex != dwCredentialCount) && ((DWORD)(pbCredential - *ppbSAC) > *pcbSAC))
    {
        //
        // The database appears to be truncated.
        //
        ASSERT_SECURITY_DBASE_CORRUPT();
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
        goto ErrorExit;
    }

ErrorExit:
    if (pbEncryptedData) LocalFree(pbEncryptedData);
    
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertNetScheduleCredentialData
//
//  Synopsis:   Converts Net Schedule credential stored prior to sysprep so it may be decrypted after sysprep.
//              It does this by using the pre-sysprep key to decrypt the credential with it, and then
//              encrypting it using the new post-sysprep key.
//
//  Arguments:  pRC2KeyPreSysprep - pointer to presysprep key
//              pRC2KeyPostSysprep - pointer to postsysprep key
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT ConvertNetScheduleCredentialData(RC2_KEY_INFO* pRC2KeyPreSysprep, RC2_KEY_INFO* pRC2KeyPostSysprep)
{
    BYTE* pbEncryptedData = NULL;
    DWORD cbEncryptedData = 0;
    
    //
    // Read the Net Schedule account from LSA
    //
    HRESULT hr = ReadLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, &cbEncryptedData, &pbEncryptedData);
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    if (hr == S_FALSE || cbEncryptedData <= sizeof(DWORD))
    {
        //
        // The information was specified previously but has been reset since.
        // NOTE:  This will be the case if the value has been reset back to LocalSystem,
        // as it merely stores a dword = 0x00000000 in that case
        //

        //
        // Do nothing -- there is no data to convert
        //
    }
    else
    {
        //
        // The decryption process (CBC call) clobbers the key, so make a copy for use
        //
        RC2_KEY_INFO RC2KeyPreSysprepCopy;
        CopyMemory(&RC2KeyPreSysprepCopy, pRC2KeyPreSysprep, sizeof(RC2_KEY_INFO));
    
        JOB_CREDENTIALS jc;
        hr = DecryptCredentials(RC2KeyPreSysprepCopy,
                                cbEncryptedData,
                                pbEncryptedData,
                                &jc);
        
        SecureZeroMemory(&RC2KeyPreSysprepCopy, sizeof(RC2_KEY_INFO));
        
        if (FAILED(hr))
        {
            goto ErrorExit;
        }
        
        //
        // Don't leave the plain-text password on the heap.
        //
        SecureZeroMemory(pbEncryptedData, cbEncryptedData);

        //
        // The encryption process (CBC call) clobbers the key, so make a copy for use
        //
        RC2_KEY_INFO RC2KeyPostSysprepCopy;
        CopyMemory(&RC2KeyPostSysprepCopy, pRC2KeyPostSysprep, sizeof(RC2_KEY_INFO));

        //
        // Encrypt credential using the post-sysprep key
        //
        hr = EncryptCredentials(RC2KeyPostSysprepCopy,
                                jc.wszAccount,
                                jc.wszDomain,
                                jc.wszPassword,
                                NULL,
                                &cbEncryptedData,
                                &pbEncryptedData);
        
        SecureZeroMemory(&RC2KeyPostSysprepCopy, sizeof(RC2_KEY_INFO));

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        //
        // Don't leave the plain-text password on the stack
        //
        ZERO_PASSWORD(jc.wszPassword);

        hr = WriteLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, cbEncryptedData, pbEncryptedData);
   }

ErrorExit:
    if (pbEncryptedData != NULL)
        LocalFree(pbEncryptedData);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\types\uuid\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       guids.cxx
//
//  Contents:   schedule service class object GUIDs
//
//  History:    05-Mar-96 EricB added CLSIDs.
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <mstask.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\svc_core\thread.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       thread.cxx
//
//  Contents:   Job scheduler thread code.
//
//  Classes:    CWorkerThread
//              CWorkerThreadMgr
//
//  Functions:  RequestService
//              WorkerThreadStart
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "queue.hxx"
#include "task.hxx"
#include "jpmgr.hxx"
#include "globals.hxx"
#include "thread.hxx"
#include "proto.hxx"

extern "C"
HRESULT WorkerThreadStart(CWorkerThread *);

//
// Thread idle time before termination.
//

#define MAX_THREAD_IDLE_TIME (1000 * 60 * 3)   // 3 minutes


//+---------------------------------------------------------------------------
//
//  Function:   WorkerThreadStart
//
//  Synopsis:   The entry point for a worker thread.
//
//  Arguments:  [pWrkThrd] -- Worker thread object to start.
//
//  Returns:    TBD
//
//  Effects:    Calls the StartWorking function for the provided worker
//
//----------------------------------------------------------------------------

extern "C"
HRESULT WorkerThreadStart(CWorkerThread * pWrkThrd)
{
    schDebugOut((DEB_USER3,
        "WorkerThreadStart pWrkThrd(0x%x)\n",
        pWrkThrd));

    HRESULT hr;

    //
    //  Call the worker thread class
    //

    hr = pWrkThrd->StartWorking();

    delete pWrkThrd;

    return(hr);
}

// Class CWorkerThread
//

//+-------------------------------------------------------------------------
//
//  Member:     CWorkerThread::~CWorkerThread
//
//  Synopsis:   Destructor
//
//  Arguments:  N/A
//
//  Returns:    N/A
//
//  Notes:      A WorkerThread should only be deleted after its associated
//              thread has been terminated. This is noted by having the
//              _hThread being == NULL.
//
//--------------------------------------------------------------------------
CWorkerThread::~CWorkerThread()
{
    TRACE3(CWorkerThread, ~CWorkerThread);

    // a race condition at shutdown may result in this dtor being called *after*
    // the thread manager has been destructed.
    if (gpThreadMgr)
        gpThreadMgr->SignalThreadTermination();

    //
    //  A precondition to destroying this thread is for the thread to
    //  have been terminated already. If this isn't the case, we are
    //  in big trouble.
    //
    //  Terminating the thread is not good, since it leaves the threads
    //  stack allocated in our address space. We also are not sure what
    //  the thread is up to. It could have resources locked. But, we
    //  also don't know what it will do next. We will have no record of it.
    //

    if (_hThread == NULL && _hWorkAvailable != NULL)
    {
        CloseHandle(_hWorkAvailable);
    }
    else
    {
        //
        // BUGBUG : Commenting out the assertion below until
        //          (ServiceStatus != STOPPING) can be added.
        //

#if 0
        schAssert(0 && (_hThread != NULL) &&
            "Destroying CWorkerThread while thread exists. Memory Leak!");
#endif // 0
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::AssignTask
//
//  Synopsis:   Assigns the task passed to this worker. A NULL task signals
//              thread termination.
//
//  Arguments:  [pTask] -- Task to be serviced.
//
//  Returns:    S_OK
//              E_FAIL -- Task already assigned.
//              TBD
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::AssignTask(CTask * pTask)
{
    schDebugOut((DEB_USER3,
        "CWorkerThread::AssignTask(0x%x) pTask(0x%x)\n",
         this,
        pTask));

    HRESULT hr;

    //
    // A must not already be assigned.
    //

    if (_pTask != NULL)
    {
        return(E_FAIL);
    }

    _pTask = pTask;

    if (_pTask != NULL)
    {
        _pTask->AddRef();
    }

    //
    // Signal the thread to process the task.
    //

    if (!SetEvent(_hWorkAvailable))
    {
        if (_pTask != NULL)
        {
             _pTask->Release();
             _pTask = NULL;
        }
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::Initialize
//
//  Synopsis:   Performs initialization unable to be performed in the
//              constructor.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              TBD
//
//  Effects:    None.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::Initialize(void)
{
    TRACE3(CWorkerThread, Initialize);

    HRESULT hr = S_OK;

    //
    // Create the event used to signal the thread to start working.
    //

    _hWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (_hWorkAvailable == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    ULONG ThreadID;
    _hThread = CreateThread(NULL,
                            WORKER_STACK_SIZE,
    (LPTHREAD_START_ROUTINE)WorkerThreadStart,
                            this,
                            0,
                            &ThreadID);

    if (_hThread != NULL)
    {
        if (!SetThreadPriority(_hThread, THREAD_PRIORITY_LOWEST))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    if (SUCCEEDED(hr))
    {
        gpThreadMgr->SignalThreadCreation();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::StartWorking
//
//  Synopsis:   The almost endless loop for a worker thread
//
//  Arguments:  None.
//
//  Returns:    TBD
//
//  Notes:      This routine will sit in a loop, and wait for tasks to
//              be assigned. When a task is assigned, it will call the
//              PerformTask method of the task. If the assigned task
//              is NULL, then the thread will kill itself.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::StartWorking(void)
{
    TRACE3(CWorkerThread, StartWorking);

    HRESULT hr = E_FAIL;
    BOOL    fTerminationSignalled = FALSE;

    while (1)
    {
        //
        // Wait on the work available semaphore for the signal that a task
        // has been assigned.
        //

        DWORD dwRet = WaitForSingleObject(_hWorkAvailable,
                                          MAX_THREAD_IDLE_TIME);

        if (dwRet == WAIT_FAILED)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            //
            // This thread has timed out - see if it can be terminated.
            // If this thread object exists in the global free thread
            // pool, it can be terminated. If it doesn't exist in the pool,
            // it means this thread is in use, therefore re-enter the wait.
            //
            // More detail on the above: It's possible another thread
            // (thread A) can take this thread (thread B) for service just
            // after thread B's wait has timed out. In absence of the thread
            // pool check, thread B would exit out from under thread A.
            //

            CWorkerThread * pWrkThrd = gpThreadMgr->RemoveThread(_hThread);

            if (pWrkThrd == NULL)
            {
                //
                // This object doesn't exist in the pool. Assume another
                // thread has taken this thread for service, re-enter the
                // wait.
                //

                continue;
            }
            else
            {
                //
                // This thread has expired.
                //
                // NB: DO NOT delete the thread object!
                //

                schAssert(pWrkThrd == this);

                break;
            }
        }

        //
        // A NULL task signals thread termination.
        //

        if (_pTask == NULL)
        {
            fTerminationSignalled = TRUE;
            break;
        }

        //
        // Perform the task.
        //

        _pTask->PerformTask();

        _pTask->UnServiced();

        //
        // Release the task.
        //

        schDebugOut((DEB_USER3, "CWorkerThread::StartWorking(0x%x) "
            "Completed and Releasing task(0x%x)\n",
            this,
            _pTask));

        _pTask->Release();
        _pTask = NULL;

        //
        // Return this thread to the global pool, if the service is not
        // in the process of stopping. If the service is stopping, this
        // thread must exit.
        //

        if (IsServiceStopping())
        {
            fTerminationSignalled = TRUE;
            break;
        }
        else
        {
            gpThreadMgr->AddThread(this);
        }
    }

    //
    // Scavenger duty. Perform global job processor pool housekeeping prior
    // to thread termination.
    //
    // Do this only if the thread timed out; not when the thread is
    // instructed to terminate.
    //

    if (!fTerminationSignalled)
    {
        gpJobProcessorMgr->GarbageCollection();
    }

    //
    // By closing the handle, we allow the system to remove all remaining
    // traces of this thread.
    //

    BOOL fTmp = CloseHandle(_hThread);
    schAssert(fTmp && "Thread handle close failed - possible memory leak");

    _hThread = NULL;

    return(hr);
}

// Class CWorkerThreadMgr
//

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::~CWorkerThreadMgr
//
//  Synopsis:   Destructor.
//
//  Arguments:  N/A
//
//  Returns:    None.
//
//  Notes:      Memory leaks can occur with this destructor. This destructor
//              must only be called with process termination.
//
//----------------------------------------------------------------------------
CWorkerThreadMgr::~CWorkerThreadMgr()
{
    TRACE3(CWorkerThreadMgr, ~CWorkerThreadMgr);

    //
    // This destructor must only be called with process termination.
    //
    // If the global thread count is non-zero, there are threads
    // remaining. In this case, DO NOT delete the critical section or
    // close the event handle! An active thread could still access it.
    //
    // This will be a memory leak on process termination if the count is
    // non-zero, but the leak is far better than an a/v.
    //
    if (!_cThreadCount)
    {
        DeleteCriticalSection(&_csThreadMgrCritSection);
        CloseHandle(_hThreadTerminationEvent);
    }
    else
    {
        schDebugOut((DEB_FORCE,
            "CWorkerThreadMgr dtor(0x%x) : Unavoidable memory leak. " \
            "Leaking one or more CWorkerThread objects since worker " \
            "thread(s) are still active.\n",
            this));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::AddThread
//
//  Synopsis:   Adds the worker thread indicated to the pool.
//
//  Arguments:  [pWrkThrd] -- Worker thread to add.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CWorkerThreadMgr::AddThread(CWorkerThread * pWrkThrd)
{
    schDebugOut((DEB_USER3,
        "CWorkerThreadMgr::AddThread(0x%x) pWrkThrd(0x%x)\n",
        this,
        pWrkThrd));

    //
    // If the service is stopping, instruct the thread to terminate; else,
    // add it to the pool. Note, this is safe since only the threads
    // themselves perform AddThread - the thread is free.
    //

    if (IsServiceStopping())
    {
        pWrkThrd->AssignTask(NULL);
        return;
    }

    EnterCriticalSection(&_csThreadMgrCritSection);

    _WorkerThreadQueue.AddElement(pWrkThrd);

    LeaveCriticalSection(&_csThreadMgrCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::Initialize
//
//  Synopsis:   Creates the private data member, _hThreadTerminationEvent.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Creation succeeded;
//              FALSE -- otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
CWorkerThreadMgr::Initialize(void)
{
    if ((_hThreadTerminationEvent = CreateEvent(NULL,
                                                TRUE,
                                                FALSE,
                                                NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CWorkerThreadMgr::Initialize(0x%x) CreateEvent failed, " \
            "status = 0x%lx\n",
            this,
            GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::Shutdown
//
//  Synopsis:   This member is called once, no wait, early on in the schedule
//              service's shutdown sequence. It relinquishes all free threads.
//              Done so by signalling the threads in the pool to terminate.
//
//              This member is called a second time, with the wait option, to
//              ensure any busy (non-free) worker threads have terminated
//              also.
//
//  Arguments:  [fWait] -- Flag instructing this method to wait indefinitely
//                         until all worker threads have terminated.
//                           ** Use only in this case of service stop **
//
//  Returns:    TRUE  -- All worker threads terminated.
//              FALSE -- One ore more worker threads still active.
//
//  Notes:      It must not be possible for worker threads to enter the
//              thread pool critical section in their termination code paths.
//              Otherwise, a nested, blocking section will result.
//
//----------------------------------------------------------------------------
BOOL
CWorkerThreadMgr::Shutdown(BOOL fWait)
{
#define THRDMGR_INITIAL_WAIT_TIME   2000    // 2 seconds.

    EnterCriticalSection(&_csThreadMgrCritSection);

    CWorkerThread * pWrkThrd;

    while ((pWrkThrd = _WorkerThreadQueue.RemoveElement()) != NULL)
    {
        pWrkThrd->AssignTask(NULL);         // NULL task signals termination.
    }

    LeaveCriticalSection(&_csThreadMgrCritSection);

    //
    // Optionally wait for outstanding worker threads to terminate before
    // returning. This is only to be done during service shutdown. All worker
    // threads have logic to terminate with service shutdown.
    //
    // To actually have to wait is a very rare. Only occurring in a rare
    // case, or if this machine is under *extreme* loads, or the absolutely
    // unexpected occurs. The rare case mentioned is a small window where
    // a job processor object is spun up immediately prior to the service
    // shutdown sequence and its initialization phase coincides with
    // CJobProcessor::Shutdown().
    //

    if (fWait)
    {
        //
        // On destruction, each thread decrements the global thread count
        // and sets the thread termination event.
        //

        DWORD dwWaitTime = THRDMGR_INITIAL_WAIT_TIME;
        DWORD dwRet;

        while (_cThreadCount)
        {
            //
            // Wait initially THRDMGR_INITIAL_WAIT_TIME amount of time.
            // If this wait times-out, re-issue a Shutdown of the global
            // processor object then wait infinitely.
            //

            if ((dwRet = WaitForSingleObject(_hThreadTerminationEvent,
                                             dwWaitTime)) == WAIT_OBJECT_0)
            {
                ResetEvent(_hThreadTerminationEvent);
            }
            else if (dwRet == WAIT_TIMEOUT)
            {
                //
                // Address the case where the job processor was spun up
                // inadvertently. This will shut it down.
                //

                gpJobProcessorMgr->Shutdown();
                dwWaitTime = INFINITE;
            }
            else
            {
                //
                // This return code will notify the service cleanup code
                // to not free up resources associated with the worker
                // threads. Otherwise, they may fault.
                //

                return(FALSE);
            }
        }
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::RemoveThread
//
//  Synopsis:   Remove & return a thread from the pool.
//
//  Arguments:  None.
//
//  Returns:    CWorkerThread * -- Returned thread.
//              NULL            -- Pool empty.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CWorkerThread *
CWorkerThreadMgr::RemoveThread(void)
{
    TRACE3(CWorkerThread, RemoveThread);

    CWorkerThread * pWrkThrd = NULL;

    EnterCriticalSection(&_csThreadMgrCritSection);

    pWrkThrd = _WorkerThreadQueue.RemoveElement();

    LeaveCriticalSection(&_csThreadMgrCritSection);

    return(pWrkThrd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::RemoveThread
//
//  Synopsis:   Remove & return the thread from the pool with the associated
//              handle.
//
//  Arguments:  [hThread] -- Target thread handle.
//
//  Returns:    CWorkerThread * -- Found it.
//              NULL            -- Worker thread not found.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CWorkerThread *
CWorkerThreadMgr::RemoveThread(HANDLE hThread)
{
    schDebugOut((DEB_USER3,
        "CWorkerThreadMgr::RemoveThread(0x%x) hThread(0x%x)\n",
        this,
        hThread));

    CWorkerThread * pWrkThrd;

    EnterCriticalSection(&_csThreadMgrCritSection);

    pWrkThrd = _WorkerThreadQueue.GetFirstElement();

    while (pWrkThrd != NULL)
    {
        if (pWrkThrd->GetHandle() == hThread)
        {
            _WorkerThreadQueue.RemoveElement(pWrkThrd);
            break;
        }

        pWrkThrd = pWrkThrd->Next();
    }

    LeaveCriticalSection(&_csThreadMgrCritSection);

    return(pWrkThrd);
}

//+---------------------------------------------------------------------------
//
//  Function:   RequestService
//
//  Synopsis:   Request a free worker thread from the global thread pool to
//              service the task indicated. If no free threads exist in the
//              pool, create a new one.
//
//  Arguments:  [pTask] -- Task to undergo service.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              TBD
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
RequestService(CTask * pTask)
{
    schDebugOut((DEB_USER3, "RequestService pTask(0x%x)\n", pTask));

    HRESULT hr = S_OK;

    //
    // Take no requests if the service is stopping.
    //

    if (IsServiceStopping())
    {
        schDebugOut((DEB_ERROR,
            "RequestService pTask(0x%x) Service stopping - request " \
            "refused\n",
            pTask));
        return(E_FAIL);
    }

    //
    // Obtain a free thread from the global thread pool.
    //

    CWorkerThread * pWrkThrd = gpThreadMgr->RemoveThread();

    if (pWrkThrd == NULL)
    {
        //
        // Create a new worker thread object if none were available.
        //

        pWrkThrd = new CWorkerThread;

        if (pWrkThrd == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            return(hr);
        }

        hr = pWrkThrd->Initialize();

        if (FAILED(hr))
        {
            delete pWrkThrd;
            return(hr);
        }
    }

    hr = pWrkThrd->AssignTask(pTask);

    if (FAILED(hr))
    {
        delete pWrkThrd;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\complete.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       complete.cxx
//
//  Contents:   Task wizard completion (final) property page implementation.
//
//  Classes:    CCompletionPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::CCompletionPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCompletionPage::CCompletionPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_COMPLETION), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CCompletionPage);

    _pParent = pParent;
    _hIcon = NULL;
    _pJob = NULL;

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::~CCompletionPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCompletionPage::~CCompletionPage()
{
    TRACE_DESTRUCTOR(CCompletionPage);

    if (_pJob)
    {
        _pJob->Release();
    }

    if (_hIcon)
    {
        VERIFY(DestroyIcon(_hIcon));
    }
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//              4-14-1998   CameronE   Added Policy Support
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CCompletionPage, _OnInitDialog);

    //
    // Policy Support - remove "open advanced" checkbox if
    // we find a registry key for that policy
    //
	
    if (RegReadPolicyKey(TS_KEYPOLICY_DISABLE_ADVANCED))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy DISABLE_ADVANCED active to remove checkbox\n"));
        EnableWindow(_hCtrl(complete_advanced_ckbox), FALSE);
        ShowWindow(_hCtrl(complete_advanced_ckbox), SW_HIDE);
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnPSNSetActive
//
//  Synopsis:   Create a task object (in-memory only) and update the
//              summary information on this page.
//
//  Arguments:  [lParam] - LPNMHDR (unused)
//
//  Returns:    TRUE
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnPSNSetActive(
    LPARAM lParam)
{
    TRACE_METHOD(CCompletionPage, _OnPSNSetActive);

    HRESULT hr = S_OK;
    LPWSTR pwszTrigger = NULL;

    do
    {
        //
        // Update the summary info to reflect the user's latest
        // choices.
        //

        CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);
        CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);

        HICON hIcon;

        hIcon = pSelProg->GetSelectedAppIcon();

        SendDlgItemMessage(Hwnd(),
                           complete_task_icon,
                           STM_SETICON,
                           (WPARAM) hIcon,
                           0L);
        if (_hIcon)
        {
            VERIFY(DestroyIcon(_hIcon));
        }
        _hIcon = hIcon;

        Static_SetText(_hCtrl(complete_taskname_lbl), pSelTrig->GetTaskName());
        Static_SetText(_hCtrl(complete_trigger_lbl), TEXT(""));

        //
        // Create the task object so we can ask it for its trigger string.
        // The object won't be persisted until the user hits the Finish
        // button.
        //

        hr = _UpdateTaskObject();

        if (FAILED(hr))
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
            break;
        }

        //
        // _pJob is now valid, so enable the finish button.
        //

        _SetWizButtons(PSWIZB_BACK | PSWIZB_FINISH);

        //
        // Put the trigger string in the ui so the user can see a
        // description of when the task will run.
        //

        hr = _pJob->GetTriggerString(0, &pwszTrigger);

        if (FAILED(hr))
        {
            DEBUG_OUT_HRESULT(hr);
            break;
        }
        Static_SetText(_hCtrl(complete_trigger_lbl), pwszTrigger);
    } while (0);

    CoTaskMemFree(pwszTrigger);
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnWizBack
//
//  Synopsis:   Set the current page to the one that should precede this.
//
//  Returns:    -1
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnWizBack()
{
    TRACE_METHOD(CCompletionPage, _OnWizBack);
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_PASSWORD);
    return -1;
}



//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnWizFinish
//
//  Synopsis:   Persist the task object.
//
//  Returns:    0
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnWizFinish()
{
    TRACE_METHOD(CCompletionPage, _OnWizFinish);

    HRESULT             hr = S_OK;
    LPCTSTR             ptszJob = NULL;
    CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);
    CPasswordPage      *pPasswdPage = GetPasswordPage(_pParent);
    BOOL                fSaveSucceeded = FALSE;

    do
    {
        if (!_pJob)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Persist the new job object.
        //

        ptszJob = pSelTrig->GetJobObjectFullPath();
        CWaitCursor HourGlass;

        if (FileExists((LPTSTR)ptszJob, MAX_PATH + 1))
        {
            if (!DeleteFile(ptszJob))
            {
                //
                // Complain but leave hr alone so we don't pop up a second
                // error
                //

                DEBUG_OUT_LASTERROR;
                SchedUIErrorDialog(Hwnd(),
                                   IDS_CANT_DELETE_EXISTING,
                                   (LPTSTR) pSelTrig->GetTaskName());
                break;
            }
        }

        hr = _pJob->Save(ptszJob, TRUE);
        BREAK_ON_FAIL_HRESULT(hr);

        fSaveSucceeded = TRUE;

        //
        // set the account information.  Caller must ensure service is running.
        //

        //
        // Translate input account prior to saving, then save it
        //
        DWORD cchAccount = MAX_USERNAME + 1;
        WCHAR wszAccount[MAX_USERNAME + 1] = L"";
        LPWSTR pwszPassword = (LPWSTR) pPasswdPage->GetPassword();
        hr = TranslateAccount(TRANSLATE_FOR_INTERNAL, pPasswdPage->GetAccountName(), wszAccount, cchAccount, &pwszPassword);
        if (SUCCEEDED(hr))
        {
            hr = _pJob->SetAccountInformation(wszAccount, pwszPassword);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->Save(NULL, FALSE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    //
    // Don't leave account name & password in memory
    //
    pPasswdPage->ZeroCredentials();

    //
    // If advanced checkbox is checked, indicate to DoTaskWizard.  Also,
    // give it a reference to the job object so it can do any terminal
    // processing necessary (e.g., displaying the property pages).
    //

    if (fSaveSucceeded)
    {
        BOOL fAdvanced = IsDlgButtonChecked(Hwnd(), complete_advanced_ckbox);

        _pParent->SetAdvancedMode(fAdvanced);

        _pJob->AddRef();
        _pParent->SetTaskObject(_pJob);

        _pParent->SetJobObjectPath(ptszJob);
    }

    //
    // Notify the user if anything went wrong.
    //

    if (FAILED(hr))
    {
        if (fSaveSucceeded)
        {
            SchedUIErrorDialog(Hwnd(), IDS_WIZFINISH_NONFATAL, hr);
        }
        else
        {
            SchedUIErrorDialog(Hwnd(), IDS_WIZFINISH_FATAL, hr);
        }
    }
    return 0;
}



//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_UpdateTaskObject
//
//  Synopsis:   Create a task object in memory that matches all the
//              settings the user made on previous pages.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If a task object already exists, it is freed and replaced
//              with a new one.
//
//              The task object is not persisted until the user hits the
//              finish button.
//
//---------------------------------------------------------------------------

HRESULT
CCompletionPage::_UpdateTaskObject()
{
    TRACE_METHOD(CCompletionPage, _CreateTaskObject);

    HRESULT             hr = S_OK;
    ITaskTrigger       *pTrigger = NULL;
    CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);
    CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);

    do
    {
        //
        // If there's already a task object, get rid of it.  This would
        // be the case if the user got to the finish page, then hit
        // the back button.
        //

        if (_pJob)
        {
            _pJob->Release();
            _pJob = NULL;
        }

        //
        // Create the task object
        //

        _pJob = CJob::Create();

        if (_pJob == NULL)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        //
        // Add default flags
        //

        DWORD dwAddFlags = TASK_FLAG_DONT_START_IF_ON_BATTERIES |
                           TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;

        hr = _pJob->SetFlags(dwAddFlags);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Fill in the trigger struct
        //

        TASK_TRIGGER Trigger;
        SecureZeroMemory(&Trigger, sizeof(Trigger));
        Trigger.cbTriggerSize = sizeof(Trigger);

        CTriggerPage *pTriggerPage = pSelTrig->GetSelectedTriggerPage();

        if (pTriggerPage)
        {
            pTriggerPage->FillInTrigger(&Trigger);
        }
        else
        {
            ULONG idTrigger = pSelTrig->GetSelectedTriggerType();

            switch (idTrigger)
            {
            case seltrig_startup_rb:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
                break;

            case seltrig_logon_rb:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
                break;

            default:
                DEBUG_ASSERT(FALSE);
                hr = E_UNEXPECTED;
                break;
            }
            BREAK_ON_FAIL_HRESULT(hr);

            SYSTEMTIME   stStart;
            GetSystemTime(&stStart);

            Trigger.wBeginYear = stStart.wYear;
            Trigger.wBeginMonth = stStart.wMonth;
            Trigger.wBeginDay = stStart.wDay;
        }

        //
        // Create a trigger object and init it with the struct
        //

        WORD iTrigger = (WORD)-1;

        hr = _pJob->CreateTrigger(&iTrigger, &pTrigger);
        BREAK_ON_FAIL_HRESULT(hr);

        DEBUG_ASSERT(iTrigger == 0);

        hr = pTrigger->SetTrigger(&Trigger);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the application name
        //

        TCHAR tszExeFullPath[MAX_PATH + 1];

        pSelProg->GetExeFullPath(tszExeFullPath, ARRAYLEN(tszExeFullPath));

        hr = _pJob->SetApplicationName(tszExeFullPath);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the arguments
        //
        hr = _pJob->SetParameters(pSelProg->GetArgs());
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the working directory
        //

        TCHAR tszWorkingDir[MAX_PATH + 1];

        pSelProg->GetExeDir(tszWorkingDir, ARRAYLEN(tszWorkingDir));

        hr = _pJob->SetWorkingDirectory(tszWorkingDir);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    if (pTrigger)
    {
        pTrigger->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\daily.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       daily.cxx
//
//  Contents:   Task wizard daily trigger property page implementation.
//
//  Classes:    CDailyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NDAYS_MIN - minimum value for daily_ndays_ud spin control
// NDAYS_MAX - maximum value for daily_ndays_ud spin control
//

#define NDAYS_MIN       1
#define NDAYS_MAX       365

#define TASK_WEEKDAYS       (TASK_MONDAY    | \
                             TASK_TUESDAY   | \
                             TASK_WEDNESDAY | \
                             TASK_THURSDAY  | \
                             TASK_FRIDAY)



//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::CDailyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDailyPage::CDailyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_DAILY,
                     IDS_DAILY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CDailyPage);
    _idSelectedRadio = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::~CDailyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDailyPage::~CDailyPage()
{
    TRACE_DESTRUCTOR(CDailyPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnCommand
//
//  Synopsis:   Handle user input
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case daily_day_rb:
        case daily_weekday_rb:
        case daily_ndays_rb:
            _idSelectedRadio = (USHORT) id;
            _EnableNDaysControls(id == daily_ndays_rb);
            break;

        default:
            lr = 1;
            break;
        }
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), daily_ndays_edit, NULL, FALSE);

        if (iNewPos < NDAYS_MIN || iNewPos > NDAYS_MAX)
        {
            HWND hUD = _hCtrl(daily_ndays_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CDailyPage, _OnInitDialog);

    _UpdateTimeFormat();
    _idSelectedRadio = daily_day_rb;
    CheckDlgButton(Hwnd(), _idSelectedRadio, BST_CHECKED);

    _EnableNDaysControls(FALSE);
    UpDown_SetRange(_hCtrl(daily_ndays_ud), NDAYS_MIN, NDAYS_MAX);
    UpDown_SetPos(_hCtrl(daily_ndays_ud), 1);
    Edit_LimitText(_hCtrl(daily_ndays_edit), 3);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnPSNSetActive
//
//  Synopsis:   Enable the back and next buttons, since this page cannot
//              have invalid data
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_EnableNDaysControls
//
//  Synopsis:   Enable or disable the 'run every n days' controls
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDailyPage::_EnableNDaysControls(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(daily_ndays_ud), fEnable);
    EnableWindow(_hCtrl(daily_ndays_edit), fEnable);
    EnableWindow(_hCtrl(daily_ndays_lbl), fEnable);
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CDailyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    switch (_idSelectedRadio)
    {
    case daily_day_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_DAILY;
        pTrigger->Type.Daily.DaysInterval = 1;
        break;

    case daily_weekday_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        pTrigger->Type.Weekly.WeeksInterval = 1;
        pTrigger->Type.Weekly.rgfDaysOfTheWeek = TASK_WEEKDAYS;
        break;

    case daily_ndays_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_DAILY;
        pTrigger->Type.Daily.DaysInterval =
            UpDown_GetPos(_hCtrl(daily_ndays_ud));
        break;

    default:
        DEBUG_ASSERT(FALSE);
        break;
    }
    FillInStartDateTime(_hCtrl(startdate_dp), _hCtrl(starttime_dp), pTrigger);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\once.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       once.cxx
//
//  Contents:   Task wizard once trigger property page implementation.
//
//  Classes:    COncePage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::COncePage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

COncePage::COncePage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_ONCE,
                     IDS_ONCE_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(COncePage);
}




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::~COncePage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

COncePage::~COncePage()
{
    TRACE_DESTRUCTOR(COncePage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
COncePage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(COncePage, _OnInitDialog);

    _UpdateTimeFormat();
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::_OnPSNSetActive
//
//  Synopsis:   Enable back and next buttons.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      (This page can never have invalid data, so Next should
//              always be enabled.)
//
//---------------------------------------------------------------------------

LRESULT
COncePage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}



//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
COncePage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    pTrigger->TriggerType = TASK_TIME_TRIGGER_ONCE;
    FillInStartDateTime(_hCtrl(startdate_dp), _hCtrl(starttime_dp), pTrigger);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\monthly.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       monthly.cxx
//
//  Contents:   Task wizard monthly trigger property page implementation.
//
//  Classes:    CMonthlyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NMONTHDAYS_MIN - minimum value for monthly_day_ud spin control
// NMONTHDAYS_MAX - maximun value for monthly_day_ud spin control
// MONTHS_WITHOUT_DAY_31 - used to ensure trigger settings will allow task
//                          to run
//

#define NMONTHDAYS_MIN              1
#define NMONTHDAYS_MAX              31

#define MONTHS_WITHOUT_DAY_31       (TASK_FEBRUARY  | \
                                     TASK_APRIL     | \
                                     TASK_JUNE      | \
                                     TASK_SEPTEMBER | \
                                     TASK_NOVEMBER)


//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::CMonthlyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CMonthlyPage::CMonthlyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_MONTHLY,
                     IDS_MONTHLY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CMonthlyPage);

    _idSelectedDayType = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::~CMonthlyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CMonthlyPage::~CMonthlyPage()
{
    TRACE_DESTRUCTOR(CMonthlyPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnCommand
//
//  Synopsis:   Handle user input
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case monthly_day_rb:
        case monthly_combo_rb:
            _idSelectedDayType = (WORD)id;
            _EnableDayCombos(id == monthly_combo_rb);
            EnableWindow(_hCtrl(monthly_day_edit), id == monthly_day_rb);
            EnableWindow(_hCtrl(monthly_day_ud), id == monthly_day_rb);
            break;
        }
        _UpdateWizButtons();
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), monthly_day_edit, NULL, FALSE);

        if (iNewPos < NMONTHDAYS_MIN || iNewPos > NMONTHDAYS_MAX)
        {
            HWND hUD = _hCtrl(monthly_day_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CMonthlyPage, _OnInitDialog);

    TCHAR tszBuff[SCH_BIGBUF_LEN];
    ULONG i;
    HWND  hCombo = _hCtrl(monthly_ordinality_combo);

    _UpdateTimeFormat();

    for (i = 0; i < ARRAYLEN(g_aWeekData); i++)
    {
        LoadStr(g_aWeekData[i].ids, tszBuff, SCH_BIGBUF_LEN);
        ComboBox_AddString(hCombo, tszBuff);
    }
    ComboBox_SetCurSel(hCombo, 0);

    hCombo = _hCtrl(monthly_day_combo);

    for (i = 0; i < ARRAYLEN(g_aDayData); i++)
    {
        LoadStr(g_aDayData[i].ids, tszBuff, SCH_BIGBUF_LEN);
        ComboBox_AddString(hCombo, tszBuff);
    }
    ComboBox_SetCurSel(hCombo, 0);

    _EnableDayCombos(FALSE);
    UpDown_SetRange(_hCtrl(monthly_day_ud), NMONTHDAYS_MIN, NMONTHDAYS_MAX);
    UpDown_SetPos(_hCtrl(monthly_day_ud), NMONTHDAYS_MIN);
    Edit_LimitText(_hCtrl(monthly_day_edit), 3);

    for (i = monthly_jan_ckbox; i <= monthly_dec_ckbox; i++)
    {
        CheckDlgButton(Hwnd(), i, BST_CHECKED);
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnPSNSetActive
//
//  Synopsis:   Enable Next button if this page's data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Some of the page verification is left to the _OnWizNext
//              routine.  This allows us to respond to invalid data by
//              displaying an explanatory message rather than simply
//              disabling the Next button.
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnWizNext
//
//  Synopsis:   Validate the selections not already checked by
//              _OnPSNSetActive and _OnCommand.
//
//  Returns:     0 - advance to next page
//              -1 - stay on this page
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnWizNext()
{
    USHORT flMonths = _ReadSelectedMonths();

    //
    // Verify at least one month is selected
    //

    if (!flMonths)
    {
        SchedUIMessageDialog(Hwnd(),
                             IERR_INVALID_MONTHLY_TASK,
                             MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                             (LPTSTR) NULL);
        return -1;
    }

    //
    // If the user specified that the trigger should fire on a specific day,
    // verify that at least one of the selected months contains that day.
    //

    if (_idSelectedDayType == monthly_day_rb)
    {
        USHORT usDay = (USHORT) UpDown_GetPos(_hCtrl(monthly_day_ud));
        ULONG  idsErrMsg = 0;

        if (usDay == 31 &&
            (flMonths & MONTHS_WITHOUT_DAY_31) &&
            !(flMonths & ~MONTHS_WITHOUT_DAY_31))
        {
            idsErrMsg = IDS_MONTHS_HAVE_LT_31_DAYS;
        }
        else if (usDay == 30 && flMonths == TASK_FEBRUARY)
        {
            idsErrMsg = IDS_MONTHS_HAVE_LT_30_DAYS;
        }

        if (idsErrMsg)
        {
            SchedUIMessageDialog(Hwnd(),
                                 idsErrMsg,
                                 MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                                 (LPTSTR) NULL);

            SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_MONTHLY);
            return -1;
        }
    }

    //
    // Trigger is valid, delegate to base to advance to the next page.
    //

    return CTriggerPage::_OnWizNext();
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next button if a preliminary analysis indicates
//              that the user's selections are valid.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      _OnWizNext does additional checking
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::_UpdateWizButtons()
{
    BOOL fEnableNext = TRUE;

    if (!_ReadSelectedMonths() || !_idSelectedDayType)
    {
        fEnableNext = FALSE;
    }

    if (fEnableNext)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    INT i;
    WORD *prgfMonths;

    if (_idSelectedDayType == monthly_day_rb)
    {
        pTrigger->TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
        USHORT usDay = (USHORT) UpDown_GetPos(_hCtrl(monthly_day_ud));

        pTrigger->Type.MonthlyDate.rgfDays = 1 << (usDay - 1);
        prgfMonths = &pTrigger->Type.MonthlyDate.rgfMonths;
    }
    else
    {
        DEBUG_ASSERT(_idSelectedDayType == monthly_combo_rb);
        pTrigger->TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;

        i = ComboBox_GetCurSel(_hCtrl(monthly_ordinality_combo));
        pTrigger->Type.MonthlyDOW.wWhichWeek = (WORD)g_aWeekData[i].week;

        i = ComboBox_GetCurSel(_hCtrl(monthly_day_combo));
        pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek = (WORD)g_aDayData[i].day;

        prgfMonths = &pTrigger->Type.MonthlyDOW.rgfMonths;
    }

    *prgfMonths = _ReadSelectedMonths();

    SYSTEMTIME st;

    GetLocalTime(&st);

    pTrigger->wBeginYear   = st.wYear;
    pTrigger->wBeginMonth  = st.wMonth;
    pTrigger->wBeginDay    = 1;

    DateTime_GetSystemtime(_hCtrl(starttime_dp), &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}




//===========================================================================
//
// CMonthlyPage methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_ReadSelectedMonths
//
//  Synopsis:   Return a bitmask representing the checked day of week buttons
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

WORD
CMonthlyPage::_ReadSelectedMonths()
{
    WORD flMonths = 0;
    INT i;

    for (i = monthly_jan_ckbox; i <= monthly_dec_ckbox; i++)
    {
        if (IsDlgButtonChecked(Hwnd(), i))
        {
            flMonths |= 1 << (i - monthly_jan_ckbox);
        }
    }
    return flMonths;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_EnableDayCombos
//
//  Synopsis:   Enable or disable the monthly DOW controls
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::_EnableDayCombos(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(monthly_ordinality_combo), fEnable);
    EnableWindow(_hCtrl(monthly_day_combo), fEnable);
    EnableWindow(_hCtrl(monthly_combo_lbl), fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\password.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       once.cxx
//
//  Contents:   Task wizard once trigger property page implementation.
//
//  Classes:    CPasswordPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// External functions
//

void
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);

// header files say '256' - help files say 127 
// testing shows 127 is the real number              
#define REAL_PWLEN          127


//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::CPasswordPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CPasswordPage::CPasswordPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        _pParent(pParent),
        CWizPage(MAKEINTRESOURCE(IDD_PASSWORD), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CPasswordPage);

    *_tszUserName = TCHAR('\0');
    *_tszPassword = TCHAR('\0');
    *_tszConfirmPassword = TCHAR('\0');

    _CreatePage(IDS_TRIGGER_HDR1, IDS_PASSWORD_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::~CPasswordPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CPasswordPage::~CPasswordPage()
{
    TRACE_DESTRUCTOR(CPasswordPage);
    ZeroCredentials();
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnCommand
//
//  Synopsis:   Update stored credential information and Next button state
//              in response to user input to the account or password edits.
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    if (codeNotify == EN_UPDATE)
    {
        switch (id)
        {
        case password_name_edit:
            Edit_GetText(hwndCtl, _tszUserName, ARRAYLEN(_tszUserName));
            StripLeadTrailSpace(_tszUserName);
            break;

        case password_password_edit:
            Edit_GetText(hwndCtl, _tszPassword, ARRAYLEN(_tszPassword));
            break;

        case password_confirm_edit:
            Edit_GetText(hwndCtl,
                         _tszConfirmPassword,
                         ARRAYLEN(_tszConfirmPassword));
            break;
        }
        _UpdateWizButtons();
    }
    else
    {
        lr = 1;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CPasswordPage, _OnInitDialog);

    Edit_LimitText(_hCtrl(password_name_edit), MAX_PATH);
    Edit_LimitText(_hCtrl(password_password_edit), REAL_PWLEN);
    Edit_LimitText(_hCtrl(password_confirm_edit), REAL_PWLEN);

    GetDefaultDomainAndUserName(_tszUserName, ARRAYLEN(_tszUserName));

    Edit_SetText(_hCtrl(password_name_edit), _tszUserName);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button iff this page's data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnWizBack
//
//  Synopsis:   Set the current page to the selected trigger page
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnWizBack()
{
    TRACE_METHOD(CPasswordPage, _OnWizBack);

    SecureZeroMemory(_tszPassword, (MAX_PATH + 1) * sizeof(WCHAR));
    SecureZeroMemory(_tszConfirmPassword, (MAX_PATH) + 1 * sizeof(WCHAR));

    ULONG iddPage = GetSelectTriggerPage(_pParent)->GetSelectedTriggerPageID();
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iddPage);
    return -1;
}




//===========================================================================
//
// CPasswordPage methods
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next button iff this page's data is valid.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CPasswordPage::_UpdateWizButtons()
{
    if (*_tszUserName                               && // name nonempty
        !lstrcmp(_tszPassword, _tszConfirmPassword))   // pwd == confirm
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\resource.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       resource.h
//
//  Contents:   Resource identifiers for create new task wizard.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

//
// Task Scheduler string ID usage:
//
// 0-6          "..\inc\resource.h"
// 32           "..\inc\resource.h"      (NORMAL_PRIORITY_CLASS)
// 64           "..\inc\resource.h"      (IDLE_PRIORITY_CLASS)    
// 100-110      "..\folderui\resource.h" 
// 128          "..\inc\resource.h"      (HIGH_PRIORITY_CLASS)     
// 151-167      "..\folderui\resource.h"  
// 256          "..\inc\resource.h"      (REALTIME_PRIORITY_CLASS)
// 300-400      "..\wizard\resource.h"
// 1034         "..\inc\resource.h"
// 1067-1177    "..\inc\resource.h"
// 2000-2999    "..\folderui\resource.h"
// 3330-3333    "..\inc\resource.h"
// 3400-3406    "..\inc\resource.h"
// 3800-3810    "..\folderui\resource.h"
// 4000         "..\folderui\resource.h"
// 4101-4152    "..\schedui\rc.h"
//
// Task Scheduler dialog ID usage:
//
// 102-104      "..\schedui\rc.h"
// 300-350      "..\wizard\resource.h"
// 401-403      "..\schedui\rc.h"
// 1771         "..\schedui\rc.h"
//


/////////////////////////////////////////////////////////////////////////////
//
// Strings
//


#define IDB_BANNER256                   300 // these are bitmaps, but put 
#define IDB_BANNER16                    301 // here because it's a safe range
#define IDB_WATERMARK16                 302
#define IDB_WATERMARK256                303
#define IDS_LARGEFONTNAME               304
#define IDS_LARGEFONTSIZE               305
#define IDC_BIGBOLDTITLE                306
#define IDC_BOLDTITLE                   307
#define IDS_SELPROG_HDR1                308
#define IDS_SELPROG_HDR2                309
#define IDS_SELTRIG_HDR1                310
#define IDS_SELTRIG_HDR2                311
#define IDS_TRIGGER_HDR1                312
#define IDS_DAILY_HDR2                  313
#define IDS_WEEKLY_HDR2                 314
#define IDS_MONTHLY_HDR2                315
#define IDS_ONCE_HDR2                   316
#define IDS_PASSWORD_HDR2               317
#define IDS_FIRSTCOLUMN                 IDS_APPLICATION
#define IDS_APPLICATION                 318
#define IDS_VERSION                     319
//#define                               320   reserved for column expansion
//#define                               321
//#define                               322
//#define                               323
//#define                               324
#define IDS_ALLUSERS_PATH               325
#define IDS_CAPTION                     326
#define IDS_BAD_FILENAME                327
#define IDS_WIZARD_FILTER               328
#define IDS_WIZARD_BROWSE_CAPTION       329
#define IDS_TASK_ALREADY_EXISTS         330
#define IDS_CANT_DELETE_EXISTING        331
#define IDS_MONTHS_HAVE_LT_31_DAYS      332
#define IDS_MONTHS_HAVE_LT_30_DAYS      333
#define IDB_SPLASH                      334
#define IDS_TEMPLATE_NAME               335
#define IDS_WIZFINISH_NONFATAL          336
#define IDS_WIZFINISH_FATAL             337    

/////////////////////////////////////////////////////////////////////////////
//
// Dialogs
//

#define IDC_STATIC                      -1


#define IDD_WELCOME                     300
#define IDD_SELECT_PROGRAM              301
#define IDD_COMPLETION                  302
#define IDD_SELECT_TRIGGER              303
#define IDD_DAILY                       304
#define IDD_WEEKLY                      305
#define IDD_MONTHLY                     306
#define IDD_ONCE                        307
#define IDD_PASSWORD                    308
#define IDD_SELMONTH                    309

#define starttime_dp                    900
#define startdate_dp                    901

#define selprog_programs_lv             1001
#define selprogs_browse_pb              1002
#define selprogs_static_text_browse     1003

#define complete_task_icon              1001
#define complete_taskname_lbl           1002
#define complete_trigger_lbl            1003
#define complete_time_lbl               1004
#define complete_advanced_ckbox         1005
#define complete_date_lbl               1006

#define seltrig_taskname_edit           1001
#define seltrig_first_rb                seltrig_daily_rb
#define seltrig_daily_rb                1002
#define seltrig_weekly_rb               1003
#define seltrig_monthly_rb              1004
#define seltrig_once_rb                 1005
#define seltrig_startup_rb              1006
#define seltrig_logon_rb                1007
#define seltrig_last_rb                 seltrig_logon_rb

#define daily_day_rb                    1001
#define daily_weekday_rb                1002
#define daily_ndays_rb                  1003
#define daily_ndays_ud                  1004
#define daily_ndays_edit                1005
#define daily_ndays_lbl                 1006

#define weekly_nweeks_rb                1003
#define weekly_nweeks_edit              1004
#define weekly_nweeks_ud                1005
#define weekly_nweeks_lbl               1006
#define weekly_monday_ckbox             1007
#define weekly_tuesday_ckbox            1008
#define weekly_wednesday_ckbox          1009
#define weekly_thursday_ckbox           1010
#define weekly_friday_ckbox             1011
#define weekly_saturday_ckbox           1012
#define weekly_sunday_ckbox             1013

#define monthly_day_rb                  1003
#define monthly_day_edit                1004
#define monthly_day_ud                  1005
#define monthly_combo_rb                1006
#define monthly_ordinality_combo        1007
#define monthly_day_combo               1008
#define monthly_combo_lbl               1009
#define monthly_day_lbl                 1010
#define monthly_jan_ckbox               1011
#define monthly_feb_ckbox               1012
#define monthly_mar_ckbox               1013
#define monthly_apr_ckbox               1014
#define monthly_may_ckbox               1015
#define monthly_jun_ckbox               1016
#define monthly_jul_ckbox               1017
#define monthly_aug_ckbox               1018
#define monthly_sep_ckbox               1019
#define monthly_oct_ckbox               1020
#define monthly_nov_ckbox               1021
#define monthly_dec_ckbox               1022

#define password_name_edit              1001
#define password_password_edit          1002
#define password_confirm_edit           1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\selprog.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selprog.cxx
//
//  Contents:   Task wizard program selection property page implementation.
//
//  Classes:    CSelectProgramPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

#include "commdlg.h"
#include "..\schedui\rc.h"
#include "..\inc\resource.h"
#include "..\folderui\jobicons.hxx"
#include "walklib.h"

//
// Types
//
// COLUMNS - indexes to the columns in the listview displaying the results
//  of walking the start menu
//


enum COLUMNS
{
    COL_APP,
    COL_VERSION,

    NUM_COLUMNS
};

//
// Forward references
//

INT
InsertSmallIcon(
    HIMAGELIST  hSmallImageList,
    LPCTSTR     tszExeName);


//
// Externals
//

extern HICON GetDefaultAppIcon(UINT nIconSize);




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::CSelectProgramPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectProgramPage::CSelectProgramPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_SELECT_PROGRAM), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CSelectProgramPage);

    _hwndLV = NULL;
    _pSelectedLinkInfo = NULL;
    _idxSelectedIcon = 0;
    _fUseBrowseSelection = FALSE;
    _tszExePath[0] = TEXT('\0');
    _tszExeName[0] = TEXT('\0');

    _CreatePage(IDS_SELPROG_HDR1, IDS_SELPROG_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::~CSelectProgramPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectProgramPage::~CSelectProgramPage()
{
    TRACE_DESTRUCTOR(CSelectProgramPage);
}



//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnCommand
//
//  Synopsis:   Handle the browse button being clicked, ignore all else.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnCommand(
    int id,
    HWND hwndCtl,
    UINT codeNotify)
{
    TRACE_METHOD(CSelectProgramPage, _OnCommand);

    LRESULT lr = 0;

    if (codeNotify == BN_CLICKED && id == selprogs_browse_pb)
    {
        _OnBrowse();
    }
    else
    {
        lr = 1; // not handled
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CSelectProgramPage, _OnInitDialog);
    HRESULT hr = S_OK;

    // Policy dictates whether we have a browse button or not
    // true means don't allow us to browse

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_BROWSE))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy DENY_BROWSE active - removing browse btn\n"));
        EnableWindow(_hCtrl(selprogs_browse_pb), FALSE);
        ShowWindow(_hCtrl(selprogs_browse_pb), SW_HIDE);
        ShowWindow(_hCtrl(selprogs_static_text_browse), SW_HIDE);
    }

    // Next not enabled till user picks app

    _SetWizButtons(PSWIZB_BACK);

    _hwndLV = _hCtrl(selprog_programs_lv);

    hr = _InitListView();

    if (SUCCEEDED(hr))
    {
        _PopulateListView();
    }
    return (HRESULT) TRUE; // wm_initdialog wants BOOL for setfocus info
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button if an item has been selected in the
//              listview.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _fUseBrowseSelection = FALSE;

    if (_pSelectedLinkInfo)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnDestroy
//
//  Synopsis:   Free all the linkinfos stored as user data in the listview.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnDestroy()
{
    DEBUG_ASSERT(IsWindow(_hwndLV));

    ULONG cItems = ListView_GetItemCount(_hwndLV);
    ULONG i;
    LV_ITEM lvi;

    SecureZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    for (i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        lvi.lParam = 0;

        BOOL fOk = ListView_GetItem(_hwndLV, &lvi);

        if (fOk)
        {
            delete (LINKINFO *) lvi.lParam;
        }
        else
        {
            DEBUG_OUT_LASTERROR;
        }
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_ProcessListViewNotifications
//
//  Synopsis:   If the user makes a selection in the listview, remember the
//              associated linkinfo and enable the next button.
//
//  Returns:    FALSE
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Ignores all other notifications.
//
//---------------------------------------------------------------------------

BOOL
CSelectProgramPage::_ProcessListViewNotifications(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT code = ((LPNMHDR)lParam)->code;

    if (((LPNMHDR)lParam)->idFrom != selprog_programs_lv)
    {
        return FALSE;
    }

    DEBUG_ASSERT(code != LVN_GETDISPINFO); // not using callbacks
    DEBUG_ASSERT(code != LVN_SETDISPINFO); // items are r/o

    if (code == LVN_ITEMCHANGED)
    {
        NM_LISTVIEW *pnmLV = (NM_LISTVIEW *) lParam;

        if ((pnmLV->uChanged & LVIF_STATE) &&
            (pnmLV->uNewState & LVIS_SELECTED))
        {
            // translate the index into a LinkInfo pointer

            LV_ITEM lvi;

            lvi.iItem = pnmLV->iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE;

            if (!ListView_GetItem(_hwndLV, &lvi))
            {
                DEBUG_OUT_LASTERROR;
                return FALSE;
            }

            _pSelectedLinkInfo = (LINKINFO *) lvi.lParam;
            _idxSelectedIcon = lvi.iImage;
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
    return FALSE;
}




//===========================================================================
//
// CSelectProgramPage members
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetDefaultDisplayName
//
//  Synopsis:   Fill [tszDisplayName] with the string to offer the user
//              as the new task object name.
//
//  Arguments:  [tszDisplayName] - buffer to receive string
//              [cchDisplayName] - size, in chars, of buffer
//
//  Modifies:   *[tszDisplayName]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetDefaultDisplayName(
    LPTSTR tszDisplayName,
    ULONG  cchDisplayName)
{
    LPTSTR ptszToCopy;

    if (_fUseBrowseSelection)
    {
        ptszToCopy = _tszExeName;
    }
    else if (*_pSelectedLinkInfo->szLnkName)
    {
        ptszToCopy = _pSelectedLinkInfo->szLnkName;
    }
    else
    {
        ptszToCopy = _pSelectedLinkInfo->szExeName;
    }

    lstrcpyn(tszDisplayName, ptszToCopy, cchDisplayName);

    //
    // Truncate at the file extension
    //

    LPTSTR ptszExt = PathFindExtension(tszDisplayName);

    if (ptszExt)
    {
        *ptszExt = TEXT('\0');
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetSelectedAppIcon
//
//  Synopsis:   Retrieve the icon associated with the selected appliation.
//
//  Returns:    The selected app's small icon, or NULL if no small icon is
//              available.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HICON
CSelectProgramPage::GetSelectedAppIcon()
{
    if (_fUseBrowseSelection)
    {
        HICON hicon = NULL;
        TCHAR tszFullPath[MAX_PATH];

        GetExeFullPath(tszFullPath, ARRAYLEN(tszFullPath));
        TS_ExtractIconEx(tszFullPath, 0, &hicon, 1, GetSystemMetrics(SM_CXSMICON));
        return hicon;
    }

    if (_idxSelectedIcon == -1)
    {
        return NULL;
    }

    HIMAGELIST hSmallImageList = ListView_GetImageList(_hwndLV, LVSIL_SMALL);

    if (!hSmallImageList)
    {
        return NULL;
    }

    return ImageList_ExtractIcon(0, hSmallImageList, _idxSelectedIcon);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_InitListView
//
//  Synopsis:   Initialize the listview's columns and image lists.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_InitListView()
{
    HRESULT     hr = S_OK;
    HIMAGELIST  himlSmall = NULL;
    INT         cxSmall = GetSystemMetrics(SM_CXSMICON);
    INT         cySmall = GetSystemMetrics(SM_CYSMICON);
    DWORD       dwFlag = ILC_MASK | ILC_COLOR32;

    do
    {
        if (!_hwndLV || !cxSmall || !cySmall)
        {
            hr = E_UNEXPECTED;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        //
        // Create the listview image list.  Only the small image list is
        // required, since this listview will be restricted to report
        // mode.
        //
        if (GetWindowLongPtr(_hwndLV, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            dwFlag |= ILC_MIRROR;
        }

        himlSmall = ImageList_Create(cxSmall, cySmall, dwFlag, 1, 1);

        if (!himlSmall)
        {
            hr = HRESULT_FROM_LASTERROR;
            DEBUG_OUT_LASTERROR;
            break;
        }

        // Add the generic icon

        HICON hiconGeneric = GetDefaultAppIcon(GetSystemMetrics(SM_CXSMICON));
        DEBUG_ASSERT(hiconGeneric);
        INT index = ImageList_AddIcon(himlSmall, hiconGeneric);
        DEBUG_ASSERT(index != -1);

        // Assign the image list to the listview

        if (!ListView_SetImageList(_hwndLV, himlSmall, LVSIL_SMALL))
        {
            himlSmall = NULL;
        }
        else
        {
            hr = HRESULT_FROM_LASTERROR;
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Create 2 listview columns.  If more are added, the column
        // width calculation needs to change.
        //

        DEBUG_ASSERT(NUM_COLUMNS == 2);

        LV_COLUMN   lvc;
        RECT        rcLV;
        TCHAR       tszColumnLabel[MAX_LVIEW_HEADER_CCH];

        VERIFY(GetClientRect(_hwndLV, &rcLV));
        rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

        SecureZeroMemory(&lvc, sizeof lvc);
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = (2 * rcLV.right) / 3;
        lvc.pszText = tszColumnLabel;

        int iCol;

        for (iCol = 0; iCol < NUM_COLUMNS; iCol++)
        {
            lvc.iSubItem = iCol;

            LoadStr(IDS_FIRSTCOLUMN + iCol,
                    tszColumnLabel,
                    ARRAYLEN(tszColumnLabel));

            //
            // Once the first column has been inserted, allocate the
            // remaining width to the second column.
            //

            if (iCol)
            {
                lvc.cx = rcLV.right - lvc.cx;
            }

            if (ListView_InsertColumn(_hwndLV, iCol, &lvc) == -1)
            {
                hr = HRESULT_FROM_LASTERROR;
                DEBUG_OUT_LASTERROR;
                break;
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    if (FAILED(hr))
    {
        if (himlSmall)
        {
            VERIFY(ImageList_Destroy(himlSmall));
        }

        if (_hwndLV)
        {
            EnableWindow(_hwndLV, FALSE);
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_PopulateListView
//
//  Synopsis:   Fill the listview from the shortcuts found under the start
//              menu directory.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Searches both under the current user and the all users
//              start menu directories.  Note the walk link code ignores
//              links to certain programs, e.g. notepad.exe.  These would
//              generally not make interesting tasks.
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_PopulateListView()
{
    TRACE_METHOD(CSelectProgramPage, _PopulateListView);

    HRESULT     hr = S_OK;
    LPLINKINFO  pLinkInfo = new LINKINFO;
    HWALK      hWalk = NULL;
    ERR         errWalk;
    LV_ITEM     lvi;
    HIMAGELIST  hSmallImageList = ListView_GetImageList(_hwndLV, LVSIL_SMALL);

    SecureZeroMemory(&lvi, sizeof lvi);

    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

    if (hSmallImageList)
    {
        lvi.mask |= LVIF_IMAGE;
    }

    CWaitCursor HourGlass;
    do
    {
        if (!pLinkInfo)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        TCHAR tszAllUsersStartMenuPath[MAX_PATH];
        TCHAR tszAllUsersStartMenuPathExpanded[MAX_PATH];

        //
        // This CSIDL is valid on NT only
        //
        hr = SHGetFolderPath(NULL,
                             CSIDL_COMMON_STARTMENU,
                             NULL,
                             0,
                             tszAllUsersStartMenuPath);

        if (FAILED(hr))
        {
            DEBUG_OUT_HRESULT(hr);
            break;
        }


        VERIFY(ExpandEnvironmentStrings(tszAllUsersStartMenuPath,
                                        tszAllUsersStartMenuPathExpanded,
                                        MAX_PATH));

        hWalk = GetFirstFileLnkInfo(pLinkInfo,
                                    INPTYPE_STARTMENU   |
                                      INPTYPE_ANYFOLDER |
                                      INPFLAG_SKIPFILES,
                                    tszAllUsersStartMenuPathExpanded,
                                    &errWalk);

        if (!hWalk || FAILED(errWalk))
        {
            DEBUG_OUT((DEB_ERROR,
                      "_PopulateListView: GetFirstFileLnkInfo %dL\n",
                      errWalk));
            hr = E_FAIL;
            break; // no links in start menu (!) or error
        }

        hr = _AddAppToListView(&lvi, hSmallImageList, pLinkInfo);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    //
    // If the first link was found, continue until no more are found
    // or an error occurs.
    //

    while (SUCCEEDED(hr))
    {
        pLinkInfo = new LINKINFO;

        if (!pLinkInfo)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        if (GetNextFileLnkInfo(hWalk, pLinkInfo) > 0)
        {
            if (!_AppAlreadyInListView(pLinkInfo))
            {
                hr = _AddAppToListView(&lvi, hSmallImageList, pLinkInfo);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                DEBUG_OUT((DEB_TRACE,
                           "Discarding duplicate link %S %S\n",
                           pLinkInfo->szLnkName,
                           pLinkInfo->szExeVersionInfo));
                delete pLinkInfo;
            }
        }
        else
        {
            break; // no more links or error
        }
    }

    delete pLinkInfo;
    CloseWalk(hWalk); // no-op on null

    //
    // If anything was added to the listview, make the first item focused
    // (but not selected).
    //

    if (ListView_GetItemCount(_hwndLV))
    {
        ListView_SetItemState(_hwndLV, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_AppAlreadyInListView
//
//  Synopsis:   Return TRUE if a link with the same name and version info
//              as [pLinkInfo] has already been inserted in the listview.
//
//  Arguments:  [pLinkInfo] - contains link name to check
//
//  Returns:    TRUE  - same link name found
//              FALSE - same link not found, or error
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      This eliminates links that have the same name, even if they
//              point to different programs, or have different arguments.
//
//---------------------------------------------------------------------------

BOOL
CSelectProgramPage::_AppAlreadyInListView(
    LPLINKINFO pLinkInfo)
{
    LV_FINDINFO lvfi;

    lvfi.flags = LVFI_STRING;
    lvfi.psz = pLinkInfo->szLnkName;

    INT iItem = ListView_FindItem(_hwndLV, -1, &lvfi);

    if (iItem == -1)
    {
        return FALSE;
    }

    LV_ITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;

    BOOL fOk = ListView_GetItem(_hwndLV, &lvi);

    if (!fOk)
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    LPLINKINFO pliInserted = (LPLINKINFO) lvi.lParam;
    DEBUG_ASSERT(pliInserted);

    return !lstrcmpi(pLinkInfo->szExeVersionInfo,
                     pliInserted->szExeVersionInfo);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_AddAppToListView
//
//  Synopsis:   Add an entry to the listview and its image list for the
//              application specified by [pLinkInfo].
//
//  Arguments:  [plvi]            - all fields valid except pszText, lParam,
//                                   and iImage.
//              [hSmallImageList] - listview's small icon imagelist
//              [pLinkInfo]       - describes app to insert info on
//
//  Returns:    HRESULT
//
//  Modifies:   pszText, lparam, and iImage fields of [plvi]; contents of
//              [hSmallImageList].
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_AddAppToListView(
    LV_ITEM *plvi,
    HIMAGELIST hSmallImageList,
    LPLINKINFO pLinkInfo)
{
    HRESULT hr = S_OK;

    plvi->pszText = pLinkInfo->szLnkName;
    plvi->lParam = (LPARAM) pLinkInfo;

    if (hSmallImageList)
    {
        TCHAR tszExeFullPath[MAX_PATH +1];

        StringCchPrintf(tszExeFullPath,
                        MAX_PATH +1,
                        TEXT("%s\\%s"),
                        pLinkInfo->szExePath,
                        pLinkInfo->szExeName);

        plvi->iImage = InsertSmallIcon(hSmallImageList, tszExeFullPath);
        
        if (plvi->iImage == -1)
        {
            plvi->iImage = 0;
        }
    }

    INT iIndex = ListView_InsertItem(_hwndLV, plvi);

    if (iIndex == -1)
    {
        hr = E_FAIL;
        DEBUG_OUT_LASTERROR;
        return hr;
    }

    ListView_SetItemText(_hwndLV,
                         iIndex,
                         COL_VERSION,
                         pLinkInfo->szExeVersionInfo);
    plvi->iItem++;

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   InsertSmallIcon
//
//  Synopsis:   Extract the small icon from [tszExeName] and add it to
//              [hSmallImageList].
//
//  Arguments:  [hSmallImageList] - handle to small icon imagelist
//              [tszExeName]      - full path to executable
//
//  Returns:    Index of new entry or -1 if [tszExeName] doesn't have a
//              small icon or an error occurred.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT
InsertSmallIcon(
    HIMAGELIST  hSmallImageList,
    LPCTSTR     tszExeName)
{
    HICON   hSmallIcon = NULL;
    UINT    uiResult;

    uiResult = TS_ExtractIconEx(tszExeName, 0, &hSmallIcon, 1, GetSystemMetrics(SM_CXSMICON));

    if (!hSmallIcon)
    {
        DEBUG_OUT((DEB_IWARN, "Can't find icon for app '%s'\n", tszExeName));
    }

    if (uiResult)
    {
        INT retVal;

        DEBUG_ASSERT(hSmallIcon);
        retVal = ImageList_AddIcon(hSmallImageList, hSmallIcon);

        if( hSmallIcon && !DestroyIcon( hSmallIcon ) )
        {
           CHECK_LASTERROR(GetLastError());
        }
        return retVal;
    }

    CHECK_LASTERROR(GetLastError());
    return -1;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetExeName
//
//  Synopsis:   Fill [tszBuf] with the name of the executable selected by
//              the user.
//
//  Arguments:  [tszBuf] - buffer to receive name
//              [cchBuf] - size, in characters, of buffer
//
//  Modifies:   *[tszBuf]
//
//  History:    10-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetExeName(
   LPTSTR tszBuf,
   ULONG cchBuf)
{
    LPTSTR ptszExeName;

    if (_fUseBrowseSelection)
    {
        ptszExeName  = _tszExeName;
    }
    else
    {
        ptszExeName  = _pSelectedLinkInfo->szExeName;
    }

    lstrcpyn(tszBuf, ptszExeName, cchBuf);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetExeFullPath
//
//  Synopsis:   Fill [tszBuf] with the full path to the executable selected
//              by the user.
//
//  Arguments:  [tszBuf] - buffer to receive path
//              [cchBuf] - size, in characters, of buffer
//
//  Modifies:   *[tszBuf]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetExeFullPath(
    LPTSTR tszBuf,
    ULONG cchBuf)
{
    LPTSTR ptszExePath;
    LPTSTR ptszExeName;

    if (_fUseBrowseSelection)
    {
        ptszExePath = _tszExePath;
        ptszExeName  = _tszExeName;
    }
    else
    {
        ptszExePath = _pSelectedLinkInfo->szExePath;
        ptszExeName  = _pSelectedLinkInfo->szExeName;
    }

    ULONG cchRequired = lstrlen(ptszExePath) +
                        1 + // backslash
                        lstrlen(ptszExeName) +
                        1;  // terminating null

    // if there's not enough room in the buffer for the whole path
    // just copy the executable name
    if (cchRequired > cchBuf)
    {
        lstrcpyn(tszBuf, ptszExeName, cchBuf);
    }
    else
    {
        StringCchCopy(tszBuf, cchBuf, ptszExePath);
        StringCchCat(tszBuf, cchBuf, TEXT("\\"));
        StringCchCat(tszBuf, cchBuf, ptszExeName);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   FixupRemoteLink
//
//  Synopsis:   determine whether a link came from another computer
//              If so, append server name
//
//  History:    5-24-2002   hhance   Created
//
//  Notes:      assumes that exePath is MAX_PATH long
//
//---------------------------------------------------------------------------
void FixupRemoteLink(LPCWSTR linkPath, LPWSTR exePath)
{
    // step one - if the exePath is already a UNC name, do nothing
    if ((exePath[0] == L'\\') &&
        (exePath[1] == L'\\'))
        return;

    WCHAR drive[4];
    StringCchCopyN(drive, 4, linkPath, 3);
    if ((drive[1] == L':') && 
        (drive[2] == L'\\') &&
        (GetDriveType(drive) == DRIVE_REMOTE))
    {
        // now we only want the drive letter
        drive[2] = L'\0';

        // we know the link file exists on a remote drive
        // therefore, the path is based on ANOTHER machine somewhere.
        WCHAR serverName[MAX_PATH];
        DWORD dLength = MAX_PATH;

        if (0 == WNetGetConnection(drive, serverName, &dLength)
            && ((wcslen(serverName) + wcslen(exePath) +1) <= MAX_PATH))
        {
            // server name will be of the form \\machine\c$
            // but all we need is "\\machine\"
            WCHAR* pChar = wcsrchr(serverName, L'\\');
            if (pChar)
            {
                *(pChar +1) = L'\0';

                WCHAR copyBuf[MAX_PATH +1];
                StringCchCopy(copyBuf, MAX_PATH +1, exePath);
                StringCchCopy(exePath, MAX_PATH +1, serverName);
                StringCchCat(exePath, MAX_PATH +1, copyBuf);

                // and make it C$ rather than C: ...
                WCHAR* pChar = wcschr(exePath, L':');
                if (pChar)
                    *pChar = L'$';
            }
        }
    }
    // maybe they've keyed in a UNC name all by their little lonesomes
    // we're expecting \\servername\somepath at this point
    else if ((linkPath[0] == L'\\') &&
             (linkPath[1] == L'\\'))
    {
        WCHAR copyBuf[MAX_PATH +1];
        StringCchCopy(copyBuf, MAX_PATH +1, linkPath);
        
        WCHAR* pChar = wcschr(&copyBuf[2],  L'\\');
        
        // Shouldn't be able to get here otherwise
        // if we did - we'll let them get what they've asked for.
        if (!pChar)
            return;

        // append exepath right behind the backwhack
        StringCchCopy(pChar +1, MAX_PATH +1 - (pChar - copyBuf), exePath);
        
        // make it C$ rather than C: ...
        pChar = wcschr(copyBuf, L':');
        if (pChar)
            *pChar = L'$';

        // and copy it into the output buffer
        StringCchCopy(exePath, MAX_PATH +1, copyBuf);
        
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnBrowse
//
//  Synopsis:   Allow the user to set the task's application via a common
//              file open dialog.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If successful, advances to the next page.
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::_OnBrowse()
{
    TRACE_METHOD(CSelectProgramPage, _OnBrowse);

    TCHAR tszDefExt[5];
    TCHAR tszFilter[MAX_PATH];
    TCHAR tszTitle[100];

    DWORD dwFlags = OFN_HIDEREADONLY    |
                    OFN_FILEMUSTEXIST   |
                    OFN_NOCHANGEDIR     |
                    OFN_NONETWORKBUTTON |
                    OFN_PATHMUSTEXIST;

    LoadStr(IDS_EXE, tszDefExt, ARRAYLEN(tszDefExt));
    LoadStr(IDS_WIZARD_BROWSE_CAPTION, tszTitle, ARRAYLEN(tszTitle));

    SecureZeroMemory(tszFilter, sizeof tszFilter);

    LoadStr(IDS_WIZARD_FILTER, tszFilter, ARRAYLEN(tszFilter));

    OPENFILENAME ofn;
    SecureZeroMemory(&ofn, sizeof(ofn));

    _tszExeName[0] = TEXT('\0');
    _tszExePath[0] = TEXT('\0');

    // Set up info for common file open dialog.
    ofn.lStructSize       = CDSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner         = Hwnd();
    ofn.lpstrFilter       = tszFilter;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = _tszExePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = _tszExeName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = TEXT("\\");
    ofn.lpstrTitle        = tszTitle;
    ofn.Flags             = dwFlags;
    ofn.lpstrDefExt       = tszDefExt;

    //
    // Invoke the dialog.  If the user makes a selection and hits OK, record
    // the name selected and go on to the trigger selection page.
    //

    if (GetOpenFileName(&ofn))
    {
        PathRemoveFileSpec(_tszExePath);

        LPTSTR ptszLastSlash = _tcsrchr(_tszExePath, TEXT('\\'));
        if (ptszLastSlash && lstrlen(ptszLastSlash) == 1)
        {
            *ptszLastSlash = TEXT('\0');
        }
	    _fUseBrowseSelection = TRUE;

	    // if the user chose a link, resolve the link
	    TCHAR tszFullPath[MAX_PATH +1];
	    GetExeFullPath(tszFullPath, ARRAYLEN(tszFullPath));

	    if (*tszFullPath != TEXT('\0'))
	    {
		    LPTSTR ptszExt = PathFindExtension(tszFullPath);
		    if (ptszExt && !_tcsicmp(ptszExt, TEXT(".LNK")))
		    {
			    TCHAR szLnkPath[MAX_PATH +1] = {TEXT('\0')};
			    TCHAR szArguments[MAX_PATH] = {TEXT('\0')};
			    WIN32_FIND_DATA wfdExeData;

			    if (ResolveLnk(tszFullPath, szLnkPath, &wfdExeData, szArguments) == 0)
			    {
				    ptszLastSlash = _tcsrchr(szLnkPath, TEXT('\\'));
				    if (ptszLastSlash)
				    {
					    lstrcpyn(_tszExeName, ptszLastSlash + 1, MAX_PATH);
					    *ptszLastSlash = TEXT('\0');
					    lstrcpyn(_tszExePath, szLnkPath, MAX_PATH);

                        // got this far.  Now need to see whether this is a remote link
                        FixupRemoteLink(tszFullPath, _tszExePath);
				    }
			    }
		    }
	    }
        
        PropSheet_PressButton(GetParent(Hwnd()), PSBTN_NEXT);
    }
    else
    {
        // user hit cancel or an error occurred

        if (CommDlgExtendedError())
        {
            DEBUG_OUT((DEB_ERROR,
                       "GetOpenFileName failed<0x%x>\n",
                       CommDlgExtendedError()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\seltrig.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selprog.cxx
//
//  Contents:   Task wizard trigger selection property page implementation.
//
//  Classes:    CSelectTriggerPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// ILLEGAL_FILENAME_CHARS - characters to reject in task name edit control
//

#define ILLEGAL_FILENAME_CHARS      TEXT("<>:/\\|")


#define ARRAY_LEN(a)    (sizeof(a)/sizeof(a[0]))


//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::CSelectTriggerPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectTriggerPage::CSelectTriggerPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        _pParent(pParent),
        CWizPage(MAKEINTRESOURCE(IDD_SELECT_TRIGGER), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CSelectTriggerPage);

    DEBUG_ASSERT(pParent);
    _tszDisplayName[0] = TCHAR('\0');
    _tszJobObjectFullPath[0] = TCHAR('\0');
    _idSelectedTrigger = 0;
    _CreatePage(IDS_SELTRIG_HDR1, IDS_SELTRIG_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::~CSelectTriggerPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectTriggerPage::~CSelectTriggerPage()
{
    TRACE_DESTRUCTOR(CSelectTriggerPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================


LRESULT
CSelectTriggerPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    TRACE_METHOD(CSelectTriggerPage, _OnCommand);

    LRESULT lr = 1;

    if (codeNotify == BN_CLICKED &&
        id >= seltrig_first_rb && id <= seltrig_last_rb)
    {
        lr = 0;

        if (!_idSelectedTrigger && *_tszDisplayName)
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
        _idSelectedTrigger = id;
    }
    else if (codeNotify == EN_UPDATE)
    {
        Edit_GetText(_hCtrl(seltrig_taskname_edit),
                     _tszDisplayName,
                     ARRAYLEN(_tszDisplayName));

        StripLeadTrailSpace(_tszDisplayName);

        if (!*_tszDisplayName)
        {
            _SetWizButtons(PSWIZB_BACK);
        }
        else if (_idSelectedTrigger)
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
    return lr;
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnInitDialog
//
//  Synopsis:   Initialize the controls on this page, only called once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CSelectTriggerPage, _OnInitDialog);

    HWND hwndEdit = _hCtrl(seltrig_taskname_edit);

    Edit_LimitText(hwndEdit,
                   ARRAYLEN(_tszDisplayName)
                   - 1                      // null terminator
                   - lstrlen(GetTaskPath()) // path to tasks folder
                   - 1                      // backslash
                   - (ARRAY_LEN(TSZ_DOTJOB) - 1));  // extension

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnPSNSetActive
//
//  Synopsis:   Init wizard buttons and other controls, called whenever
//              this page becomes the current page.
//
//  Arguments:  [lParam] - unused
//
//  Returns:    TRUE
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnPSNSetActive(
    LPARAM lParam)
{
    if (_idSelectedTrigger)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }

    if (!*_tszDisplayName)
    {
        CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);

        pSelProg->GetDefaultDisplayName(_tszDisplayName,
                                        ARRAYLEN(_tszDisplayName));
        Edit_SetText(_hCtrl(seltrig_taskname_edit), _tszDisplayName);
    }
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnWizBack
//
//  Synopsis:   Handle the user's selection of the 'Back' button.
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnWizBack()
{
    *_tszDisplayName = TEXT('\0');
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnWizNext
//
//  Synopsis:   Handle the user's selection of the 'Next' button
//
//  Returns:    -1 (DWLP_MSGRESULT contains next page number)
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnWizNext()
{
    TRACE_METHOD(CSelectTriggerPage, _OnWizNext);

    LONG lNextPage;

    do
    {
        //
        // Check the filename for invalid characters
        //

        if (_tcspbrk(_tszDisplayName, ILLEGAL_FILENAME_CHARS))
        {
            SchedUIErrorDialog(Hwnd(), IDS_BAD_FILENAME, (LPTSTR) NULL);
            lNextPage = IDD_SELECT_TRIGGER; // stay on this page
            break;
        }

        //
        // Build the full pathname to the .job object
        //

        ULONG cchPath = lstrlen(GetTaskPath());

        StringCchCopy(_tszJobObjectFullPath, MAX_PATH +1, GetTaskPath());
        lstrcpyn(&_tszJobObjectFullPath[cchPath],
                 GetTaskName(),
                 ARRAYLEN(_tszJobObjectFullPath) - (cchPath + ARRAY_LEN(TSZ_DOTJOB) - 1));
        StringCchCat(_tszJobObjectFullPath, MAX_PATH +1, TSZ_DOTJOB);
        DeleteQuotes(_tszJobObjectFullPath);

        //
        // If the name collides with an existing task, get the user's
        // confirmation before proceeding to next page
        //

        if (FileExists(_tszJobObjectFullPath, MAX_PATH))
        {
            INT iAnswer = SchedUIMessageDialog(Hwnd(),
                                               IDS_TASK_ALREADY_EXISTS,
                                               MB_APPLMODAL      |
                                                MB_SETFOREGROUND |
                                                MB_ICONQUESTION  |
                                                MB_YESNO,
                                               _tszDisplayName);
            if (iAnswer != IDYES)
            {
                lNextPage = IDD_SELECT_TRIGGER;
                break;
            }
        }

        //
        // If the selected trigger type doesn't have its own page,
        // go directly to the end
        //

        if (_idSelectedTrigger == seltrig_startup_rb ||
            _idSelectedTrigger == seltrig_logon_rb)
        {
            lNextPage = IDD_PASSWORD;
            break;
        }

        lNextPage = IDD_DAILY + (_idSelectedTrigger - seltrig_first_rb);
    } while (0);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, lNextPage);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\trigpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       trigpage.cxx
//
//  Contents:   Implementation of common trigger page class
//
//  Classes:    CTriggerPage
//
//  History:    5-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::CTriggerPage
//
//  Synopsis:   ctor
//
//  Arguments:  [iddPage]        - resource id of trigger page dialog
//              [idsHeader2]     - resource id of sub-title string
//              [ptszFolderPath] - tasks folder path
//              [phPSP]          - filled with handle returned by
//                                  CreatePropertySheetPage
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTriggerPage::CTriggerPage(
    ULONG iddPage,
    ULONG idsHeader2,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(iddPage), ptszFolderPath)
{
    _CreatePage(IDS_TRIGGER_HDR1, idsHeader2, phPSP);
}



//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_UpdateTimeFormat
//
//  Synopsis:   Update the start time datetimepicker control's time format
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CTriggerPage::_UpdateTimeFormat()
{
    ::UpdateTimeFormat(_tszTimeFormat, ARRAYLEN(_tszTimeFormat));
    DateTime_SetFormat(_hCtrl(starttime_dp), _tszTimeFormat);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWinIniChange
//
//  Synopsis:   Handle win.ini settings change
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWinIniChange(
    WPARAM wParam,
    LPARAM lParam)
{
    _UpdateTimeFormat();
    return FALSE;
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWizBack
//
//  Synopsis:   Set the current page to the select trigger page.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWizBack()
{
    TRACE_METHOD(CTriggerPage, _OnWizBack);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_SELECT_TRIGGER);
    return -1;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWizNext
//
//  Synopsis:   Advance to the next page
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWizNext()
{
    TRACE_METHOD(CTriggerPage, _OnWizNext);
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_PASSWORD);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\walklib.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"
#include <shlobjp.h>    // IShellLinkDataList
#include <shlguidp.h>   // IID_IShellLinkDataList
#include <msi.h>        // MsiQueryProductState

#include <stdlib.h>
#include <process.h>
#include <winver.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include "walklib.h"
#include "..\inc\misc.hxx"


typedef INSTALLSTATE (WINAPI* PFN_MsiQueryProductState) (LPCTSTR tszProduct);

BOOL
IsMsiApp(
    IShellLink *    psl
    );


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



HWALK GetFirstFileLnkInfo(LPLINKINFO lpLnkInfo, DWORD dwFlags,
						  LPTSTR lpszFolder, ERR *pErrRet)
{
	BOOL				bRC=TRUE;
	ERR					errVal;
	LPWALKHEADER		lpWalk;
	LPTSTR				lpszSubStr;
	TCHAR				szFullPath[MAX_PATH +1];

#ifdef _DEBUG
	lpWalk = (LPWALKHEADER) MyGlobalAlloc(FAILMEMA, sizeof(WALKHEADER));
#else
	lpWalk = (LPWALKHEADER) GlobalAlloc(GPTR, sizeof(WALKHEADER));
#endif

	if (lpWalk == NULL)
	{
		*pErrRet = ERR_NOMEMORY ;//ERR_NOMEMORY -6;
		return  NULL; // Global Alloc failed
	}

	lpWalk->lpSrchDirListHead = NULL;
	lpWalk->lpSrchDirListTail = NULL;
	lpWalk->lpszIniString = NULL;
	lpWalk->lpszNextFile = NULL;
	lpWalk->dwCurrentFlag = RESET_FLAG;
	lpWalk->dwWalkFlags = dwFlags;
	if (lpWalk->dwWalkFlags & INPTYPE_ANYFOLDER)
	{
		if (IsBadStringPtr(lpszFolder, MAX_PATH))
			lpWalk->lpszFolder = NULL;
		else		
			lpWalk->lpszFolder = lpszFolder;
	}
	else
		lpWalk->lpszFolder = NULL;


	SetLnkInfo(lpLnkInfo);
	errVal = GetFileHandle(lpLnkInfo, lpWalk, szFullPath, MAX_PATH +1);
	if (errVal == 0)
	{
		*pErrRet = ERR_SUCCESS;//ERR_NOMOREFILES 0;
		CloseWalk(lpWalk);
		return  NULL; /* No more files: Done */
	}
	else if (errVal < 0)
	{
		*pErrRet = errVal;
		CloseWalk(lpWalk);
		return NULL;
	}

	lpszSubStr = _tcsrchr(lpLnkInfo->szLnkName, TEXT('.'));
	
	if (lpszSubStr)
	{
		if ((_tcsicmp(lpszSubStr, TEXT(".LNK")) == 0) ||
			(_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0))
		{
			if (!(errVal = GetLnkInfo(lpWalk, lpLnkInfo, szFullPath)))
			{
				lpszSubStr = _tcsrchr(lpLnkInfo->szExeName, TEXT('.'));
				if (lpszSubStr)
				{
					if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                        _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
					{
                        *pErrRet = ERR_MOREFILESTOCOME;// ERR_SUCCESS but there are more files;
                        return  lpWalk;
					}
				}
			}
		}
	}
	if ((errVal == ERR_NOTANEXE) || errVal > 0)
	{
		*pErrRet = GetNextFileLnkInfo(lpWalk, lpLnkInfo);
		if ((*pErrRet != ERR_SUCCESS) && (*pErrRet != ERR_MOREFILESTOCOME))
		{
			CloseWalk(lpWalk);
			return NULL;
		}
		else
			return  lpWalk;
	}
	else
	{
		*pErrRet = errVal;	
		CloseWalk(lpWalk);
		return NULL;
	}
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetNextFileLnkInfo(HWALK hWalk, LPLINKINFO lpLnkInfo)
{	
	BOOL				bRC=TRUE;
	INT					retVal;
	LPTSTR				lpszSubStr;
	TCHAR				szFullPath[MAX_PATH +1];

	LPWALKHEADER lpWalk = (LPWALKHEADER) hWalk;

	while (1)
	{
		retVal = GetFileHandle(lpLnkInfo, lpWalk, szFullPath, MAX_PATH +1);
		if (retVal < 0)
			return retVal; /* Couldn't find next file */
		else if (retVal == 0 )  /* Done : No more files */
			return ERR_SUCCESS;

		lpszSubStr = _tcsrchr(lpLnkInfo->szLnkName, TEXT('.'));

		if (lpszSubStr)
		{
			if ((_tcsicmp(lpszSubStr, TEXT(".LNK")) == 0) ||
				(_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0))
			{
				if (!(retVal = GetLnkInfo(lpWalk, lpLnkInfo, szFullPath)))
				{
					lpszSubStr = _tcsrchr(lpLnkInfo->szExeName, TEXT('.'));
					if (lpszSubStr)
					{
						if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                            _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
						{
						    break;
						}
					}
				}
				else if (retVal != ERR_NOTANEXE)
					return retVal;
			}
		}
		continue; /* Not a Link File */
	}
	return ERR_MOREFILESTOCOME;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL InSkipList(LPTSTR lpszFileName)
{
	INT i;
	LPTSTR	lplpszToSkipFiles[] =
			{
				TEXT("write.exe"),
				TEXT("winhelp.exe"),
				TEXT("winhlp32.exe"),
				TEXT("notepad.exe"),
				TEXT("wordpad.exe"),
				TEXT("rundll32.exe"),
                TEXT("explorer.exe"),
                TEXT("control.exe")
			};

	for (i = 0; i < ARRAYLEN(lplpszToSkipFiles); i++)
	{
		if (_tcsicmp(lpszFileName, lplpszToSkipFiles[i]) == 0)
			return TRUE;
	}
	return FALSE;
}



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



INT GetFileHandle(LPLINKINFO lpLnkInfo, LPWALKHEADER lpWalk, LPTSTR lpszPath, size_t pathBufSize)
{	
	DWORD				dwAttrs;
	BOOL				bRC;
	HANDLE				hSearch;
	INT					retVal;
	TCHAR				szFolderPath[MAX_PATH +1];
	WIN32_FIND_DATA		wfdFileData;
	
	DEBUG_ASSERT(lpWalk != NULL);

	while (GetInputType(lpWalk) == FOLDER)
	{
		SetLnkInfo(lpLnkInfo);
		if (lpWalk->lpSrchDirListHead == NULL)
		{
			if (retVal = GetFolder(szFolderPath, MAX_PATH +1, lpWalk))
				return retVal;

			if (!SetCurrentDirectory(szFolderPath))
			{
				lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
				goto LoopBack;
//				return ERR_SETCURRENTDIR;
			}

			hSearch = FindFirstFile(TEXT("*"), &wfdFileData);
			if (hSearch == INVALID_HANDLE_VALUE)
			{
				lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
				goto LoopBack;
			}
			else
			{
				retVal = AddToList(hSearch, lpWalk);
				if (retVal == ERR_NOMEMORY)
					return ERR_NOMEMORY; // GlobalAlloc failed
			}
		}
		else
		{
			while (!(bRC = FindNextFile(lpWalk->lpSrchDirListTail->hDirHandle, &wfdFileData)))
			{
				if (GetLastError() == ERROR_NO_MORE_FILES)
				{
					FindClose(lpWalk->lpSrchDirListTail->hDirHandle);
					RemoveFromList(lpWalk);
					if (lpWalk->lpSrchDirListHead == NULL)
					{
						lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
						goto LoopBack;
					}
					SetCurrentDirectory(TEXT(".."));
				}
				else
					return ERR_UNKNOWN ; // should never come here
			}
		}
			
		dwAttrs = GetFileAttributes(wfdFileData.cFileName);
		while (dwAttrs & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (_tcsicmp(wfdFileData.cFileName, TEXT(".")) &&
				_tcsicmp(wfdFileData.cFileName, TEXT("..")))
			{		
				SetCurrentDirectory(wfdFileData.cFileName);			
				hSearch = FindFirstFile(TEXT("*"), &wfdFileData);
				if (hSearch == INVALID_HANDLE_VALUE)
				{
					if (lpWalk->lpSrchDirListHead == NULL)
					{
						lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
						goto LoopBack;
					}
					else
						return ERR_UNKNOWN; // Never comes here for all dirs have . and ..
				}
				retVal = AddToList(hSearch, lpWalk);
				if (retVal == ERR_NOMEMORY)
					return ERR_NOMEMORY; // GlobalAlloc failed
				dwAttrs = GetFileAttributes(wfdFileData.cFileName);
			}
			else
			{
				while (!(bRC = FindNextFile(lpWalk->lpSrchDirListTail->hDirHandle, &wfdFileData)))
				{
					if ((GetLastError() == ERROR_NO_MORE_FILES))
					{
						FindClose(lpWalk->lpSrchDirListTail->hDirHandle);
						RemoveFromList(lpWalk);
						if (lpWalk->lpSrchDirListHead == NULL)
						{
							lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
							goto LoopBack;
						}
						SetCurrentDirectory(TEXT(".."));
					}
					else
						return ERR_UNKNOWN ; //should never come here			
				}
				dwAttrs = GetFileAttributes(wfdFileData.cFileName);
			}
		}
        StringCchCopy(lpLnkInfo->szLnkName, MAX_PATH, wfdFileData.cFileName);
		
        GetCurrentDirectory(MAX_PATH, lpLnkInfo->szLnkPath);  //BUG
		
        StringCchCopy(lpLnkInfo->szExeName, MAX_PATH, lpLnkInfo->szLnkName);
		
        StringCchCopy(lpLnkInfo->szExePath, MAX_PATH, lpLnkInfo->szLnkPath);
		
        StringCchPrintf(lpszPath, pathBufSize, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);


		return ERR_MOREFILESTOCOME;
LoopBack:
		lpWalk->dwCurrentFlag = RESET_FLAG;
		continue;
	}

	DEBUG_ASSERT(GetInputType(lpWalk) != INIFILE);
	DEBUG_ASSERT(GetInputType(lpWalk) != REGISTRY);

	return ERR_SUCCESS; //This means we are done with all of them.
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetNextFileFromString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL GetFileLAD(LPLINKINFO lpLnkInfo)
{
	WIN32_FIND_DATA		wfdFileData;
	HANDLE				hSearch;
	TCHAR				szTempStr[MAX_PATH+1];
	
    StringCchCopy(szTempStr, MAX_PATH +1, lpLnkInfo->szExePath);
    StringCchCat(szTempStr, MAX_PATH +1, TEXT("\\"));
    StringCchCat(szTempStr, MAX_PATH +1, lpLnkInfo->szExeName);

	if (!_tcschr(szTempStr, '.'))
        StringCchCat(szTempStr, MAX_PATH +1, TEXT(".exe"));

	if ( NULL == szTempStr && _tcsicmp(_tcschr(szTempStr, '.'), TEXT(".exe")) != 0)
		return FALSE;
	//bugbug performance hit

	hSearch = FindFirstFile( szTempStr, &wfdFileData);
	if (hSearch == INVALID_HANDLE_VALUE)
		return FALSE;	
	else
	{
		lpLnkInfo->ftExeLAD = wfdFileData.ftLastAccessTime;
		FindClose(hSearch);
		return TRUE;
	}
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetRegistryString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetIniString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



INT GetInputType(LPWALKHEADER lpWalk)
{
	if (lpWalk->dwWalkFlags & INPTYPE_FOLDER)
	{
		return FOLDER;
	}
	if (lpWalk->dwWalkFlags & INPTYPE_INIFILE)
	{
		return INIFILE;
	}
	if (lpWalk->dwWalkFlags & INPTYPE_REGISTRY)
	{
		return REGISTRY;
	}
	return ERR_UNKNOWN; // should never come here
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetFolder(LPTSTR lpszFolder, size_t folderBufSize, LPWALKHEADER lpWalk)
{
	HKEY			hKey;
	UINT			cchFolder = MAX_PATH;
	TCHAR			szRegVal[MAX_PATH];
	DWORD			dwType;

	if (!(lpWalk->dwWalkFlags & INPTYPE_ANYFOLDER))
	{
		if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SHELLFOLDERS, 0, KEY_READ, &hKey)
						== ERROR_SUCCESS)
		{
			if (lpWalk->dwWalkFlags & INPTYPE_STARTMENU)
			{
                StringCchCopy(szRegVal, MAX_PATH, TEXT("Start Menu"));
				lpWalk->dwCurrentFlag = INPTYPE_STARTMENU;
			}
			else if (lpWalk->dwWalkFlags & INPTYPE_DESKTOP)
			{
                StringCchCopy(szRegVal, MAX_PATH, TEXT("Desktop"));
				lpWalk->dwCurrentFlag = INPTYPE_DESKTOP;
			}

			cchFolder = ARRAYLEN(szRegVal);
            LONG lr = RegQueryValueEx(hKey,
                                      szRegVal,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)lpszFolder,
                                      (ULONG *)&cchFolder);


            if (dwType == REG_EXPAND_SZ)
            {
                TCHAR tszTemp[MAX_PATH] = { 0 };

                DWORD dwSize = ExpandEnvironmentStrings(lpszFolder, tszTemp, ARRAYLEN(tszTemp));
				if (!dwSize)
				{
					return ERR_UNKNOWN;			// should never come here
				}
				if (dwSize > ARRAYLEN(tszTemp))
				{
					return ERR_BUFFERTOOSMALL;	// should not come here either; but if it does, we'll return this error
												// we could dynamically allocate a buffer large enough,
												// but since almost all storage for paths in this component
												// seem to be MAX_PATH, it would surely overflow someplace else
												// if everything weren't changed to allow larger sizes
				}

                StringCchCopy(lpszFolder, folderBufSize, tszTemp);
            }

			if (lr != ERROR_SUCCESS)
			{
                RegCloseKey(hKey);

				if (lpWalk->dwWalkFlags & INPTYPE_STARTMENU)
				{
					return ERR_NOSTARTMENU;
				}
				else
				{
					return ERR_NODESKTOP;
				}
			}
			RegCloseKey(hKey);
		}
		else
			return ERR_NOSHELLFOLDERS;
	}
	else
	{
        StringCchCopy(lpszFolder, folderBufSize, (LPTSTR) lpWalk->lpszFolder);
		lpWalk->dwCurrentFlag = INPTYPE_ANYFOLDER;
	}
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetLnkInfo(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo, LPTSTR lpszPath)
{
	WIN32_FIND_DATA wfdExeData;
	ERR				errVal = ERR_NOTANEXE;
	UINT			uiDType;
	TCHAR			szExepath[MAX_PATH +1];
	TCHAR			szDrivePath[MAX_PATH];
	LPTSTR			lpszSubStr;
	INT				iLen1, iLen2;
	BOOL			bExists;

//BUGBUG THe if thens should be such that there is repetition of code
	szExepath[0] = '\0';
    LPTSTR ptszExt = PathFindExtension(lpLnkInfo->szLnkName);

	if (ptszExt && !_tcsicmp(ptszExt, TEXT(".LNK")))
	{
 		if (!(errVal = ResolveLnk(lpszPath, szExepath, &wfdExeData, (LPTSTR)lpLnkInfo->tszArguments)))
		{
			            
            if (lpszSubStr = _tcsrchr(szExepath, TEXT('.')))
			{
				if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                    _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
				{
					if (lpszSubStr = _tcsrchr(szExepath, '\\'))
						lpszSubStr++;
					else
						lpszSubStr = szExepath;
                    StringCchCopy(lpLnkInfo->szExeName, MAX_PATH, lpszSubStr);
					iLen1 = lstrlen(szExepath);
					iLen2 = lstrlen(lpLnkInfo->szExeName);
					*(szExepath + iLen1 - iLen2 - 1) = TEXT('\0');
                    StringCchCopy(lpLnkInfo->szExePath, MAX_PATH, szExepath);
					GetFileLAD(lpLnkInfo);

                    StringCchPrintf(szExepath, MAX_PATH +1, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);

					GetDrivePath(szExepath, szDrivePath, MAX_PATH);
					uiDType = GetDriveType(szDrivePath);

					if ((lpWalk->dwWalkFlags & INPFLAG_SKIPFILES ) && (InSkipList(lpLnkInfo->szExeName)))
                    {
						errVal = ERR_NOTANEXE;
                    }
					else if (!(lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
						 (uiDType != DRIVE_FIXED))
						errVal = ERR_NOTANEXE;
					else if ((lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
						 (uiDType != DRIVE_FIXED) && (uiDType != DRIVE_REMOTE) && (uiDType != DRIVE_CDROM))
						errVal = ERR_NOTANEXE;
					else if (!(bExists = CheckFileExists(szExepath, &(lpLnkInfo->ftExeLAD))) && (uiDType == DRIVE_FIXED))
						errVal = ERR_NOTANEXE;
					else if (!(errVal = GetExeVersion(lpLnkInfo)))
					{
								errVal = ERR_SUCCESS;
					}
				}
				else
					errVal = ERR_NOTANEXE;
			}
			else
				errVal = ERR_NOTANEXE; // link resolved to a non exe

			if (errVal == ERR_SUCCESS)
				*(_tcsrchr(lpLnkInfo->szLnkName, TEXT('.'))) = '\0';
		}
		else
			errVal = ERR_NOTANEXE;
	}
	else if (ptszExt && !_tcsicmp(ptszExt, TEXT(".EXE")))
	{
        StringCchCopy(lpLnkInfo->szExeName, MAX_PATH, lpLnkInfo->szLnkName);
        StringCchPrintf(szExepath, MAX_PATH +1, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);

		GetDrivePath(szExepath, szDrivePath, MAX_PATH);
		uiDType = GetDriveType(szDrivePath);
		GetFileLAD(lpLnkInfo);
		
		if ((lpWalk->dwWalkFlags & INPFLAG_SKIPFILES) && (InSkipList(lpLnkInfo->szExeName)))
			errVal = ERR_NOTANEXE;
		else if (!(lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
			 (uiDType != DRIVE_FIXED))
			errVal = ERR_NOTANEXE;
		else if ((lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
			 (uiDType != DRIVE_FIXED) && (uiDType != DRIVE_REMOTE) && (uiDType != DRIVE_CDROM))
			errVal = ERR_NOTANEXE;
		else if (!(bExists = CheckFileExists(szExepath, &(lpLnkInfo->ftExeLAD))) && (uiDType == DRIVE_FIXED))
			errVal = ERR_NOTANEXE;
		else if (!(errVal = GetExeVersion(lpLnkInfo)))
					errVal = ERR_SUCCESS;
	}
	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

void GetDrivePath(LPTSTR lpszExePath, LPTSTR lpszDrPath, size_t drPathSize)
{
	LPTSTR lpszSubStr;
	if (s_isDriveLetter(lpszExePath[0]) && lpszExePath[1] == TEXT(':'))
	{
		lstrcpyn(lpszDrPath, lpszExePath, 3);
        StringCchCat(lpszDrPath, drPathSize, TEXT("\\"));
	}
	else if (!_tcsncmp(lpszExePath, TEXT("\\\\"), 2))
	{
		if (lpszSubStr = _tcschr(&lpszExePath[2], TEXT('\\')))
		{
			if (lpszSubStr = _tcschr(lpszSubStr+1, TEXT('\\')))
			{
				lstrcpyn(lpszDrPath, lpszExePath, (size_t)(lpszSubStr - lpszExePath + 1));
				lpszDrPath[lpszSubStr - lpszExePath + 1] = TEXT('\0');
			}
		}
	}
	else
		lpszDrPath[0] = '\0';
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR ResolveLnk(LPCTSTR pszShortcutFile, LPTSTR lpszLnkPath,
				   LPWIN32_FIND_DATA lpwfdExeData, LPTSTR tszArgs)
{
	HRESULT		hres;
	IShellLink	*psl;
	TCHAR		szGotPath[MAX_PATH +1];
	HWND		hwnd = NULL;
	ERR			errVal = ERR_RESOLVEFAIL;

    *tszArgs = TEXT('\0');
	// Get a pointer to the IShellLink interface.
	hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
					IID_IShellLink, (void **)&psl);
	if (SUCCEEDED(hres))
	{
		IPersistFile* ppf;

		// Get a pointer to the IPersistFile interface.
		hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
		if (SUCCEEDED(hres))
		{
			WCHAR wsz[MAX_PATH +1];

			lstrcpyn(wsz, pszShortcutFile, ARRAYLEN(wsz));

			// Load the shell link.
			hres = ppf->Load(wsz, STGM_READ);
			if (SUCCEEDED(hres))
			{
                DEBUG_OUT((DEB_ITRACE, "Link: %ws\n", wsz));
                //
                // If the link is to an MSI app, don't get the path to the
                // link target - use the path to the link itself instead.
                //
                if (IsMsiApp(psl))
                {
                    errVal = ERR_SUCCESS;
                    lstrcpyn(lpszLnkPath, pszShortcutFile, MAX_PATH);
                }
                else
                {
                    lstrcpyn(szGotPath, pszShortcutFile, MAX_PATH);
                 
                    // Get the path to the link target.
                    hres = psl->GetPath(szGotPath, MAX_PATH, (LPWIN32_FIND_DATA)lpwfdExeData,
                                        SLGP_SHORTPATH );
                    if (!SUCCEEDED(hres))
                    {
                        DEBUG_OUT((DEB_ITRACE, "  GetPath failed %#x\n", hres));
                        errVal = ERR_RESOLVEFAIL; /* get path failed : Link not resolved */
                    }
                    else
                    {
                        DEBUG_OUT((DEB_ITRACE, "  Path: %ws\n", szGotPath));
                        if (lstrlen(szGotPath) > 0)
                        {
                            errVal = ERR_SUCCESS;
                            lstrcpyn(lpszLnkPath, szGotPath, MAX_PATH);
                        }
                        else
                        {
                            errVal = ERR_RESOLVEFAIL;
                        }
                    }

                    hres = psl->GetArguments(tszArgs, MAX_PATH);
                    CHECK_HRESULT(hres);
                }
			}
			// Release pointer to IPersistFile interface.
			ppf->Release();
		}
		// Release pointer to IShellLink interface.
		psl->Release();
	}
	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR AddToList(HANDLE hDir, LPWALKHEADER lpWalk)
{
	LPHSEARCHDIR lpSrchDirNode;

#ifdef _DEBUG
	lpSrchDirNode = (LPHSEARCHDIR) MyGlobalAlloc(FAILMEMA, sizeof(HSEARCHDIR));
#else
	lpSrchDirNode = (LPHSEARCHDIR) GlobalAlloc(GPTR, sizeof(HSEARCHDIR));
#endif

	if (lpSrchDirNode == NULL)
	  return ERR_NOMEMORY; /* Global Alloc failed */
	
	lpSrchDirNode->hDirHandle = hDir;
	lpSrchDirNode->lpSrchDirNext = NULL;
	
	if (lpWalk->lpSrchDirListHead == NULL)
	  lpWalk->lpSrchDirListHead = lpSrchDirNode;
	else
	  lpWalk->lpSrchDirListTail->lpSrchDirNext = lpSrchDirNode;

	lpWalk->lpSrchDirListTail = lpSrchDirNode;
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR RemoveFromList(LPWALKHEADER lpWalk)
{
	LPHSEARCHDIR lpSrchDirNode;

	if (lpWalk->lpSrchDirListHead == NULL)
		return ERR_SUCCESS;

	lpSrchDirNode = lpWalk->lpSrchDirListHead;
	while (	(lpSrchDirNode->lpSrchDirNext != lpWalk->lpSrchDirListTail) &&
			(lpSrchDirNode != lpWalk->lpSrchDirListTail))
	{
		lpSrchDirNode = lpSrchDirNode->lpSrchDirNext;
	}

	if (lpSrchDirNode != lpWalk->lpSrchDirListTail)
	{
#ifdef _DEBUG
		MyGlobalFree(lpWalk->lpSrchDirListTail, FAILMEMF);
#else
		GlobalFree(lpWalk->lpSrchDirListTail);
#endif
		lpSrchDirNode->lpSrchDirNext = NULL;
		lpWalk->lpSrchDirListTail = lpSrchDirNode;
	}
	else
	{
#ifdef _DEBUG
		MyGlobalFree(lpWalk->lpSrchDirListTail, FAILMEMF);
#else
		GlobalFree(lpWalk->lpSrchDirListTail);
#endif
		lpWalk->lpSrchDirListHead = NULL;
		lpWalk->lpSrchDirListTail = NULL;
	}
		
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetExeVersion(LPLINKINFO lpLnkInfo)
{
	LPTSTR  lpVersion;
	DWORD   dwVerInfoSize;
	DWORD   dwVerHnd;
	WORD    wVersionLen;
	WORD    wRootLen;
	BOOL    bRetCode;
	const size_t GetNameLength = 100;
    TCHAR	szGetName[GetNameLength];
    
	TCHAR	szFullName[MAX_PATH];
	ERR		errVal;
	LPTSTR  lpstrVffInfo;


	// Get the file version info size
    StringCchPrintf(szFullName, MAX_PATH, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);
	dwVerInfoSize = GetFileVersionInfoSize(szFullName, &dwVerHnd);

	if (dwVerInfoSize)
	{
		// allocate memory to hold the verinfo block

#ifdef _DEBUG
		lpstrVffInfo = (LPTSTR) MyGlobalAlloc(FAILMEMA, dwVerInfoSize);
#else
		lpstrVffInfo = (LPTSTR) GlobalAlloc(GPTR, dwVerInfoSize);
#endif
		if (lpstrVffInfo == NULL)
		{
			errVal = ERR_NOMEMORY; //Global Alloc failed
			goto Exit;
		}

		bRetCode = GetFileVersionInfo(szFullName, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
		if (!bRetCode)
		{
			errVal = ERR_SUCCESS; //ERR_FILEVERSIONFAIL;
			goto Exit;
		}
		//GetFileVersionInfo failed
		// Do this the American english translation be default.
		// Keep track of the string length for easy updating.
		// 040904E4 represents the language ID and the four
		// least significant digits represent the codepage for
		// which the data is formatted.  The language ID is
		// composed of two parts: the low ten bits represent
		// the major language and the high six bits represent
		// the sub language.

		bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
						TEXT("\\"),
						(void FAR* FAR*) &lpVersion,
						(UINT FAR*)&wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lpLnkInfo->dwExeVerMS =
				((VS_FIXEDFILEINFO *)lpVersion)->dwProductVersionMS;
			lpLnkInfo->dwExeVerLS =
				((VS_FIXEDFILEINFO *)lpVersion)->dwProductVersionLS;
		}
		else
		{
			lpLnkInfo->dwExeVerMS = 0;
			lpLnkInfo->dwExeVerLS = 0;
		}
		
		bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
						TEXT("\\VarFileInfo\\Translation"),
						(void FAR* FAR*) &lpVersion,
						(UINT FAR*)&wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			DWORD	dwLangCharSet;
			WORD	wTemp1, wTemp2;
			CopyMemory(&dwLangCharSet, lpVersion, 4);
			if (!dwLangCharSet)
				dwLangCharSet = 0x04E40409; // the Words have been switched

			// Need to switch the words back since lpbuffer has them reversed
			wTemp1 = LOWORD(dwLangCharSet);
			wTemp2 = HIWORD(dwLangCharSet);
            StringCchPrintf(szGetName, GetNameLength, TEXT("\\StringFileInfo\\%04lx%04lx\\"), wTemp1, wTemp2);
		}
		else
		{
			errVal = ERR_SUCCESS;
			goto Exit;
		}

		wRootLen = (WORD)lstrlen(szGetName);

		// "Illegal string"  "CompanyName"   "FileDescription",
		// "FileVersion"     "InternalName"  "LegalCopyright"
		// "LegalTrademarks" "ProductName"   "ProductVersion

        StringCchCat(szGetName, GetNameLength, TEXT("FileVersion"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
            StringCchCopy(lpLnkInfo->szExeVersionInfo, MAX_PATH, lpVersion);
		}
		// Now let's get FileDescription

		szGetName[wRootLen] = NULL;
        StringCchCat(szGetName,   GetNameLength, TEXT("FileDescription"));

		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
            StringCchCopy(lpLnkInfo->szExeDesc, MAX_DESC, lpVersion);
		}

		szGetName[wRootLen] = NULL;
        StringCchCat(szGetName, GetNameLength, TEXT("CompanyName"));

		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
            StringCchCopy(lpLnkInfo->szExeCompName, MAX_COMPNAME, lpVersion);
		}
		
		szGetName[wRootLen] = NULL;
        StringCchCat(szGetName, GetNameLength, TEXT("ProductName"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
            StringCchCopy(lpLnkInfo->szExeProdName, MAX_PRODNAME, lpVersion);           
		}
		
		/*   else if (i == 1)
			{
			// This is an attempt to special case the multimedia
			// extensions.  I think they paid attention to the
			// original docs which suggested that they use the
			// 0409 language ID and 0 codepage which indicates
			// 7 bit ASCII.

			StringCchCopy(szGetName, GetNameLength, TEXT("\\StringFileInfo\\04090000\\"));
			i = 0;                    // be sure to reset the counter
			}*/

		// Be sure to reset to NULL so that we can concat
		errVal = ERR_SUCCESS;
		goto Exit;
	}
	else
	{
		lpLnkInfo->dwExeVerMS = 0;
		lpLnkInfo->dwExeVerLS = 0;
		return ERR_SUCCESS;
	}

Exit :
	if (errVal != ERR_NOMEMORY)
	{
#ifdef _DEBUG
		MyGlobalFree(lpstrVffInfo, FAILMEMF);
#else
		GlobalFree(lpstrVffInfo);
#endif
// Be sure to reset to NULL so that we can concat
		lpstrVffInfo = NULL;
	}

	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


void SetLnkInfo(LPLINKINFO lpLinkInfo)
{
	SecureZeroMemory((void *)lpLinkInfo, sizeof(LINKINFO));
	lpLinkInfo->iAppCompat = APPCOMPATUNKNOWN;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

DWORD ReverseDWord(DWORD dwIn)
{
	DWORD dwOut= 0;
	while (dwIn != 0)
	{
		dwOut = dwOut << 8;
		dwOut =  dwOut | (dwIn & 0x000000FF);
		dwIn = dwIn >> 8;	
	}
	return dwOut;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL CheckFileExists(LPTSTR szFullName, LPVOID ftLAD)
{
	BOOL bRC;
	HANDLE hFile;

	SetErrorMode(SEM_FAILCRITICALERRORS);
	hFile = CreateFile(
			szFullName,	// pointer to name of the file
			GENERIC_READ | GENERIC_WRITE,	// access (read-write) mode
			FILE_SHARE_READ|FILE_SHARE_WRITE,	// share mode
			NULL,	// pointer to security attributes
			OPEN_EXISTING,	// how to create
			NULL,	// file attributes
			NULL	// handle to file with attributes to copy
			);
	int i = GetLastError();
	if ((hFile == INVALID_HANDLE_VALUE) &&
		((i == ERROR_FILE_NOT_FOUND) || (i == ERROR_PATH_NOT_FOUND) ||
 		 (i == ERROR_BAD_NETPATH)))
	{
		bRC = FALSE;
	}
	else if (hFile == INVALID_HANDLE_VALUE)
		bRC = TRUE;
	else
	{
		if (ftLAD != 0)
			SetFileTime(hFile, NULL, (FILETIME *) ftLAD, NULL);

		CloseHandle(hFile);
		bRC = TRUE;
	}

	return bRC;
}



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


void CloseWalk(HWALK hWalk)
{
	LPWALKHEADER lpWalk = (LPWALKHEADER) hWalk;

	if (lpWalk != NULL)
	{
		while (lpWalk->lpSrchDirListHead != NULL)
			RemoveFromList(lpWalk);
		//BUGBUG : Must free everything in hWalk

		if (lpWalk != NULL)
		{
			if (lpWalk->lpszIniString != NULL)
			{
	#ifdef _DEBUG
				MyGlobalFree(lpWalk->lpszIniString, FAILMEMF);
	#else
				GlobalFree(lpWalk->lpszIniString);
	#endif
				lpWalk->lpszIniString = NULL;
			}
	#ifdef _DEBUG
			MyGlobalFree(lpWalk, FAILMEMF);
	#else
			GlobalFree(lpWalk);
	#endif
			lpWalk = NULL;
		}
	}
}


#ifdef _DEBUG
HGLOBAL MyGlobalFree(HGLOBAL hGlobal, BOOL FAILMEM)
{
	HGLOBAL hGbl;

	g_MemAlloced = g_MemAlloced - GlobalSize(hGlobal);
	hGbl = GlobalFree(hGlobal);
	return hGbl;
};

HGLOBAL MyGlobalAlloc(BOOL FAILMEM, DWORD dwBytes)
{
	HGLOBAL hGbl;
	if (FAILMEM)
	{
		hGbl = GlobalAlloc(GPTR, dwBytes);
		g_MemAlloced = g_MemAlloced + GlobalSize(hGbl);
		return hGbl;
	}
	else
		return NULL;
};


#endif



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


BOOL
IsMsiApp(
    IShellLink *    psl
    )
{
    //
    // Find out if this link is to an MSI app.
    // The algorithm for finding out is from ProcessDarwinAd in
    // shell\shell32\unicpp\startmnu.cpp.
    //

    IShellLinkDataList * psldl;
    HRESULT hr = psl->QueryInterface(IID_IShellLinkDataList, (void **)&psldl);
    if (FAILED(hr))
    {
        DEBUG_OUT((DEB_ITRACE, "  QI for IShellLinkDataList failed %#x\n", hr));
        return FALSE;
    }

    EXP_DARWIN_LINK * pexpDarwin;

    hr = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);

    psldl->Release();

    if (FAILED(hr))
    {
        DEBUG_OUT((DEB_ITRACE, "  CopyDataBlock failed %#x\n", hr));
        return FALSE;
    }

    DEBUG_OUT((DEB_ITRACE, "  This IS a Darwin app\n"));

    LocalFree(pexpDarwin);
    return TRUE;
}

/////////////////////////////////////////////////////////////////
///////////////////////DDDDOOOONNNNEEEE//////////////////////////
/////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       util.cxx
//
//  Contents:   Utility functions
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"



//+--------------------------------------------------------------------------
//
//  Function:   IsDialogClass
//
//  Synopsis:   Return TRUE if [hwnd]'s window class is the dialog class.
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDialogClass(
    HWND hwnd)
{
    TCHAR tszClassName[20]; // looking for "#32770"

    if (!GetClassName(hwnd, tszClassName, ARRAYLEN(tszClassName)))
    {
        DEBUG_OUT_LASTERROR;
        tszClassName[0] = TEXT('\0');
    }

    return 0 == _tcscmp(tszClassName, TEXT("#32770"));
}



//+--------------------------------------------------------------------------
//
//  Function:   LoadStr
//
//  Synopsis:   Load string with resource id [ids] into buffer [tszBuf],
//              which is of size [cchBuf] characters.
//
//  Arguments:  [ids]        - string to load
//              [tszBuf]     - buffer for string
//              [cchBuf]     - size of buffer
//              [tszDefault] - NULL or string to use if load fails
//
//  Returns:    S_OK or error from LoadString
//
//  Modifies:   *[tszBuf]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      If the load fails and no default is supplied, [tszBuf] is
//              set to an empty string.
//
//---------------------------------------------------------------------------

HRESULT
LoadStr(
    ULONG ids,
    LPTSTR tszBuf,
    ULONG cchBuf,
    LPCTSTR tszDefault)
{
    HRESULT hr = S_OK;
    ULONG cchLoaded;

    cchLoaded = LoadString(g_hInstance, ids, tszBuf, cchBuf);

    if (!cchLoaded)
    {
        DEBUG_OUT_LASTERROR;
        hr = HRESULT_FROM_LASTERROR;

        if (tszDefault)
        {
            lstrcpyn(tszBuf, tszDefault, cchBuf);
        }
        else
        {
            *tszBuf = TEXT('\0');
        }
    }
    return hr;
}




#ifdef WIZARD97

//+--------------------------------------------------------------------------
//
//  Function:   Is256ColorSupported
//
//  Synopsis:   Return TRUE if this machine supports 256 color bitmaps
//
//  History:    5-20-1997   DavidMun   Stolen from wizard97 sample code
//
//---------------------------------------------------------------------------

BOOL
Is256ColorSupported()
{
    BOOL bRetval = FALSE;

    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        if (GetDeviceCaps(hdc, BITSPIXEL) >= 8)
        {
            bRetval = TRUE;
        }
        ReleaseDC(NULL, hdc);
    }
    return bRetval;
}

#endif // WIZARD97




//+--------------------------------------------------------------------------
//
//  Function:   FillInStartDateTime
//
//  Synopsis:   Fill [pTrigger]'s starting date and time values from the
//              values in the date/time picker controls.
//
//  Arguments:  [hwndDatePick] - handle to control with start date
//              [hwndTimePick] - handle to control with start time
//              [pTrigger]     - trigger to init
//
//  Modifies:   *[pTrigger]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
FillInStartDateTime(
    HWND hwndDatePick,
    HWND hwndTimePick,
    TASK_TRIGGER *pTrigger)
{
    SYSTEMTIME st;

    DateTime_GetSystemtime(hwndDatePick, &st);

    pTrigger->wBeginYear  = st.wYear;
    pTrigger->wBeginMonth = st.wMonth;
    pTrigger->wBeginDay   = st.wDay;

    DateTime_GetSystemtime(hwndTimePick, &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}



#ifdef WIZARD95

//+--------------------------------------------------------------------------
//
//  Function:   CreateDIBPalette
//
//  Synopsis:   Create palette based on bitmap info
//
//  Arguments:  [lpbmi]        - bitmap info
//              [lpiNumColors] - number of colors in palette
//
//  Returns:    handle to created palette, or NULL on error
//
//  History:    5-22-1997   DavidMun   Taken directly from sdk sample
//
//  Notes:      Caller must DeleteObject returned palette.
//
//---------------------------------------------------------------------------

HPALETTE
CreateDIBPalette(
    LPBITMAPINFO lpbmi,
    LPINT lpiNumColors)
{
    LPBITMAPINFOHEADER  lpbi;
    LPLOGPALETTE     lpPal;
    HANDLE           hLogPal;
    HPALETTE         hPal = NULL;
    int              i;

    lpbi = (LPBITMAPINFOHEADER)lpbmi;
    if (lpbi->biBitCount <= 8)
    {
        *lpiNumColors = (1 << lpbi->biBitCount);
    }
    else
    {
        DEBUG_OUT((DEB_ITRACE, "no palette needed\n"));
        *lpiNumColors = 0;  // No palette needed for 24 BPP DIB
    }

    if (*lpiNumColors)
    {
        hLogPal = GlobalAlloc(GHND,
                              sizeof (LOGPALETTE) + sizeof (PALETTEENTRY)
                                   * (*lpiNumColors));

        if (!hLogPal)
        {
            DEBUG_OUT_HRESULT(E_OUTOFMEMORY);
            return NULL;
        }

        lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
        lpPal->palVersion    = 0x300;
        lpPal->palNumEntries = (WORD)*lpiNumColors;

        for (i = 0;  i < *lpiNumColors;  i++)
        {
            lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
            lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
            lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }

        hPal = CreatePalette (lpPal);

        if (!hPal)
        {
            DEBUG_OUT_LASTERROR;
        }
        GlobalUnlock (hLogPal);
        GlobalFree   (hLogPal);
    }

    return hPal;
}





//+--------------------------------------------------------------------------
//
//  Function:   LoadResourceBitmap
//
//  Synopsis:   Load the bitmap with resource id [idBitmap] and put its
//              palette in *[phPalette].
//
//  Arguments:  [idBitmap]  - resource id of bitmap to load
//              [phPalette] - filled with bitmap's palette
//
//  Returns:    Device dependent bitmap with palette mapped to system's,
//              or NULL on error.
//
//  Modifies:   *[phPalette]
//
//  History:    5-22-1997   DavidMun   Created from sdk sample
//
//  Notes:      Caller must DeleteObject returned bitmap and palette. On
//              error, *[phPalette] is NULL.
//
//---------------------------------------------------------------------------

HBITMAP
LoadResourceBitmap(
    ULONG      idBitmap,
    HPALETTE  *phPalette)
{
    TRACE_FUNCTION(LoadResourceBitmap);

    HRESULT hr = E_FAIL;
    HBITMAP hBitmapFinal = NULL;
    HDC hdc = NULL;

    //
    // Init out pointer for failure case
    //

    *phPalette = NULL;

    do
    {
        HRSRC hRsrc = FindResource(g_hInstance,
                                   MAKEINTRESOURCE(idBitmap),
                                   RT_BITMAP);
        if (!hRsrc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Load the resource; note win32 will automatically unload it
        //

        HGLOBAL hGlobal = LoadResource(g_hInstance, hRsrc);

        if (!hGlobal)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Convert the loaded handle into a bitmap handle.  Again, win32
        // will automatically unlock this resource.
        //

        LPBITMAPINFOHEADER pbih = (LPBITMAPINFOHEADER) LockResource(hGlobal);

        if (!pbih)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Get the screen dc to do the palette mapping with
        //

        hdc = GetDC(NULL);

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Create a palette that can be used on this computer's display and
        // which will represent the DIB's colors as accurately as possible.
        //

        int iNumColors;
        *phPalette =  CreateDIBPalette((LPBITMAPINFO)pbih, &iNumColors);

        if (!*phPalette)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        VERIFY(SelectPalette(hdc, *phPalette, FALSE));
        UINT uiMapped = RealizePalette(hdc);

        DEBUG_OUT((DEB_ITRACE,
                  "Mapped %u logical palette entries to system palette entries\n",
                  uiMapped));

        if (uiMapped == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        hBitmapFinal = CreateDIBitmap(hdc,
                                      pbih,
                                      CBM_INIT,
                                      (PBYTE) pbih + pbih->biSize + iNumColors *
                                        sizeof(RGBQUAD),
                                      (LPBITMAPINFO) pbih,
                                      DIB_RGB_COLORS);

        if (!hBitmapFinal)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // If we got here, everything succeeded
        //

        hr = S_OK;
    } while (0);

    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    if (FAILED(hr) && *phPalette)
    {
        DeleteObject(*phPalette);
        *phPalette = NULL;
    }
    return hBitmapFinal;
}

#endif // WIZARD95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\walklink.h ===
/*
 *	History
 *	Date		email id	comment
 *	26 Dec 96	neerajm		Changed the INPTYPE #DEFINEs
 *
 *
 *
 *
 *
 *
 *
 *
 */


#ifndef WALK_H
#define WALK_H

#ifdef __cplusplus
extern "C" {
#endif


/* definitions */
#define MAX_DESC					500
#define MAX_PRODNAME				500
#define MAX_COMPNAME				500
#define RESOLVEWAIT					500   //msec

#define INPTYPE_STARTMENU			0x0001		
#define INPTYPE_DESKTOP				0x0002
#define	INPTYPE_ANYFOLDER			0x0004
#define INPTYPE_WININIRUN			0x0008
//#define	INPTYPE_SYSINIRUN			0x0010
//#define INPTYPE_ANYINIRUN			0x0020
#define INPTYPE_REGRUN				0x0040
#define INPTYPE_REGRUNSERVICES		0x0080
#define INPTYPE_REGRUNONCE			0x0100
#define INPTYPE_REGRUNSERVICESONCE	0x0200
#define INPFLAG_SKIPFILES			0x80000000
#define INPFLAG_AGGRESSION			0x40000000

#define APPCOMPATIBLE				1
#define APPINCOMPATIBLE				0
#define	APPCOMPATUNKNOWN			-1

/* ERRORS */
#define ERR_WINPATH					-1
#define ERR_SETCURRENTDIR			-2
#define ERR_NOMEMORY				-6
#define ERR_UNKNOWN					-999
#define ERR_NOTANEXE				-11
#define	ERR_SUCCESS					0
#define ERR_RESOLVEFAIL				-7
#define ERR_FILEVERSIONFAIL			-12
#define ERR_LADSETFAILED			-13
#define ERR_CURRDIR					-3
#define	ERR_MOREFILESTOCOME			1
#define	ERR_NOSTARTMENU				-14
#define	ERR_NODESKTOP				-15
#define	ERR_NOSHELLFOLDERS			-16
#define	ERR_NOCURRENTVERSION		-17
#define	ERR_BADFLAG					-18
#define	ERR_FILENOTFOUND			-19
#define ERR_BUFFERTOOSMALL			-20

typedef struct 
{
		TCHAR		szLnkName[MAX_PATH];
		TCHAR		szLnkPath[MAX_PATH];
		TCHAR		szExeName[MAX_PATH];
		TCHAR		szExePath[MAX_PATH];
        TCHAR       tszArguments[MAX_PATH];
		FILETIME	ftExeLAD;
		TCHAR		szExeVersionInfo[MAX_PATH];
		DWORD		dwExeVerMS;
		DWORD		dwExeVerLS;
		TCHAR		szExeDesc[MAX_DESC];
		TCHAR		szExeProdName[MAX_PRODNAME];
		TCHAR		szExeCompName[MAX_COMPNAME];
		TCHAR		szFlags[4];
		DWORD		dwHelpId;
		INT			iAppCompat;
}	LINKINFO, *LPLINKINFO;

typedef HANDLE HWALK;

typedef INT ERR;

/* procedure definitions */

HWALK	GetFirstFileLnkInfo(LPLINKINFO lpLnkInfo, DWORD dwWalkFlags, 
							LPTSTR lpszFolder, ERR *RetErr);
ERR		GetNextFileLnkInfo(HWALK hWalk, LPLINKINFO lpLnkInfo);
void	CloseWalk(HWALK hWalk);
ERR     GetExeVersion(LPLINKINFO lpLnkInfo);
BOOL    GetFileLAD(LPLINKINFO lpLnkInfo);


#ifdef __cplusplus
}
#endif

#endif  /* !WALK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\walklib.h ===
#define REGSTR_SHELLFOLDERS			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define REGSTR_CURRENTVERSION		TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

#define RUNKEY						TEXT("Run")
#define RUNONCEKEY					TEXT("RunOnce")
#define RUNSERVICESKEY				TEXT("RunServices")
#define RUNSERVICESONCEKEY			TEXT("RunServicesOnce")

#define HELPIDSIZE					10
#define MAXRUNSTR					300
#define MAXENVPATHLEN				300

#define INPTYPE_FOLDER				0x0007
#define INPTYPE_INIFILE				0x0038
#define INPTYPE_REGISTRY			0x03C0
#define RESET_FLAG					0xFFFF

#define	FOLDER						101
#define INIFILE						102				
#define REGISTRY					103				

#define WININISTR					"WIN.INI, Run/Load="
#define REGRUNSTR					"REGISTRY: Run"
#define REGRUNSERVICESSTR			"REGISTRY: RunServices"
#define REGRUNONCESTR				"REGISTRY: RunOnce"
#define REGRUNSERVICESONCESTR		"REGISTRY: RunServicesOnce"

typedef struct tnode
{
	HANDLE hDirHandle;
	struct tnode *lpSrchDirNext;
} HSEARCHDIR, *LPHSEARCHDIR;

typedef struct 
{
	DWORD			dwWalkFlags;
	DWORD			dwCurrentFlag;
	LPHSEARCHDIR	lpSrchDirListHead; 
	LPHSEARCHDIR	lpSrchDirListTail;
	LPTSTR			lpszIniString;
	LPTSTR			lpszNextFile;
	LPTSTR			lpszFolder;
} WALKHEADER, *LPWALKHEADER;


INT		GetFileHandle(LPLINKINFO lpLnkInfo, LPWALKHEADER lpWalk, LPTSTR lpPath, size_t pathBufSize);
ERR		GetLnkInfo(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo, LPTSTR lpPath);
ERR		ResolveLnk(LPCTSTR pszShortcutFile, LPTSTR lpszLnkPath, LPWIN32_FIND_DATA lpwfdExeData, LPTSTR tszArgs);
ERR		AddToList(HANDLE hDir, LPWALKHEADER lpWalk);
ERR		RemoveFromList(LPWALKHEADER lpWalk);
ERR		GetExeVersion(LPLINKINFO lpLnkInfo);
void	SetLnkInfo(LPLINKINFO lpLinkInfo);
BOOL	CheckFileExists(LPTSTR szFullName, LPVOID ftLAD);
INT		GetInputType(LPWALKHEADER lpWalk);
ERR		GetFolder(LPTSTR lpszFolder, size_t folderBufSize, LPWALKHEADER lpWalk);
ERR		GetIniString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
ERR		GetRegistryString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
ERR		GetNextFileFromString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
BOOL	GetFileLAD(LPLINKINFO lpLnkInfo);
BOOL	InSkipList(LPTSTR lpszFileName);
void	GetDrivePath(LPTSTR lpszExePath, LPTSTR lpszDrPath, size_t drPathSize);
DWORD	ReverseDWord(DWORD dwIn);


#ifdef _DEBUG

#define FAILMEMA	TRUE
#define FAILMEMF	TRUE

HGLOBAL MyGlobalAlloc(BOOL FAILMEM, DWORD dwBytes);
HGLOBAL MyGlobalFree(HGLOBAL hGlobal, BOOL FAILMEM);
INT		g_MemAlloced = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\taskwiz.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       taskwiz.cxx
//
//  Contents:   Class which creates and invokes the 'create new task' wizard.
//
//  Classes:    CTaskWizard
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"
#include "..\folderui\jobidl.hxx"

//
// Types
//
// SFindWiz - passed to window enumeration function. BUGBUG when wizard
//  on remote machine is supported, the 'tszFocus' member should be the
//  server name.  For now, it is just the path to the tasks folder.
//

struct SFindWiz
{
    BOOL    fFound;
    LPCTSTR tszFocus;
};

//
// Globals
//
// g_msgFindWizard - private window message used to interrogate the wizard
//  dialog proc during the find operation.
//
// TEMPLATE_STR - string used to create private message, also used by
//  folderui code to identify the template icon.
//

UINT g_msgFindWizard;
extern const TCHAR TEMPLATE_STR[];

//
// External references
//

extern HRESULT
QuietStartContinueService(); // ..\folderui\schstate.cxx

extern HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);

extern HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj);


//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::CTaskWizard
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - path to tasks folder
//
//  History:    5-12-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTaskWizard::CTaskWizard(
    LPCTSTR         ptszFolderPath,
    LPITEMIDLIST    pidlFolder)
{
    TRACE_CONSTRUCTOR(CTaskWizard);

    SecureZeroMemory(_apWizPages, sizeof _apWizPages);
    _fAdvanced = FALSE;
    _tszJobObjectFullPath[0] = TEXT('\0');
    _pTask = NULL;
    lstrcpyn(_tszFolderPath, ptszFolderPath, ARRAYLEN(_tszFolderPath));
    _pidlFolder = pidlFolder;
#ifdef WIZARD97
    _fUse256ColorBmp = Is256ColorSupported();
#endif // WIZARD97
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::~CTaskWizard
//
//  Synopsis:   dtor
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTaskWizard::~CTaskWizard()
{
    TRACE_DESTRUCTOR(CTaskWizard);

    if (_pTask)
    {
        _pTask->Release();
    }

    ILFree(_pidlFolder);
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::Launch, static
//
//  Synopsis:   Run the task wizard in a separate thread.
//
//  Arguments:  [ptszFolderPath] - path to tasks folder.
//
//  Returns:    HRESULT
//
//  History:    5-19-1997   DavidMun   Created
//
//  Notes:      If an instance of the wizard is already running for the
//              target machine, makes that the foreground window and
//              returns.
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::Launch(
    LPCTSTR ptszFolderPath,
    LPCITEMIDLIST   pidlFolder)
{
    TRACE_FUNCTION(CTaskWizard::Launch);

    HRESULT      hr = S_OK;
    CTaskWizard *pNewWiz = NULL;

    do
    {
        //
        // Start the service if it isn't running, or continue it if it is
        // paused.  Since this is the wizard, do it on behalf of the user
        // without asking first.
        //
        // Continue on failure, since it is better to let the user at least
        // create the task, even if the service can't be started (user might
        // not have permission).
        //

        hr = QuietStartContinueService();
        CHECK_HRESULT(hr);

        //
        // Create a path string that CPropPage will store.  This is the
        // full path to the tasks folder, with a trailing backslash.  The
        // CPropPage will truncate at the last backslash, since most other
        // callers give it a task filename.
        //

        ULONG cchPath = lstrlen(ptszFolderPath);

        if (cchPath >= MAX_PATH - 1) // reserve space for trailing backslash
        {
            hr = E_INVALIDARG;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        TCHAR tszFolderPath[MAX_PATH + 1];

        StringCchCopy(tszFolderPath, MAX_PATH + 1, ptszFolderPath);
        tszFolderPath[cchPath] = TEXT('\\');
        tszFolderPath[cchPath + 1] = TEXT('\0');

        //
        // Look for an instance of the wizard running and focused on our
        // folder path.  If one is found, it will make itself foreground
        // window, and we can quit.
        //

        hr = _FindWizard(tszFolderPath);

        if (hr == S_OK)
        {
            break;
        }

        //
        // No wizard is up for the current focus.  Create a wizard object
        // and run it in a new thread.
        //

        LPITEMIDLIST pidlFolderCopy = ILClone(pidlFolder);

        if (!pidlFolderCopy)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        pNewWiz = new CTaskWizard(tszFolderPath, pidlFolderCopy);

        if (!pNewWiz)
        {
            ILFree(pidlFolderCopy);
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        HANDLE  hThread;
        DWORD   idThread;

        hThread = CreateThread(NULL,
                               0,
                               _WizardThreadProc,
                               (LPVOID) pNewWiz,
                               0,
                               &idThread);

        if (!hThread)
        {
            delete pNewWiz;
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        VERIFY(CloseHandle(hThread));
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_WizardThreadProc, static
//
//  Synopsis:   Displays the wizard (and optionally task property sheet)
//              using a separate thread.
//
//  Arguments:  [pvThis] - CTaskWizard pointer
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      The wizard runs in a separate thread so the explorer ui
//              isn't stalled.
//
//---------------------------------------------------------------------------

DWORD WINAPI
CTaskWizard::_WizardThreadProc(
    LPVOID pvThis)
{
    HRESULT hr = OleInitialize(NULL);

    if (FAILED(hr))
    {
        DEBUG_OUT_HRESULT(hr);
        return hr;
    }

    CTaskWizard *pThis = (CTaskWizard *)pvThis;

    __try
    {
        hr = pThis->_DoWizard();

        //
        // Once _DoWizard returns, the wizard property sheet has closed.
        //
        // If the user elected to see the new task's property sheet, then
        // _fAdvanced will be set, and the completion page should have
        // set a valid filename and interface pointer for the task.
        //
        // Open the property sheet while we're still in the thread.
        //

        if (SUCCEEDED(hr) && pThis->_fAdvanced)
        {
            DEBUG_ASSERT(pThis->_pTask);
            DEBUG_ASSERT(*pThis->_tszJobObjectFullPath);

            //
            // Since we want to see the security page if the object is on NT
            // on an NTFS partition, we'll have to call the version of
            // DisplayJobProperties that takes a data object.
            //
            // To get a data object describing the task object, we need an
            // itemid for the job, so create one.
            //

            CJobID jid;

            jid.LoadDummy(pThis->_tszJobObjectFullPath);
            LPCITEMIDLIST pidl = (LPCITEMIDLIST) &jid;

            LPDATAOBJECT pdo = NULL;
            TCHAR tszFolderPath[MAX_PATH + 1];

            StringCchCopy(tszFolderPath, MAX_PATH + 1, pThis->_tszFolderPath);
            LPTSTR ptszLastSlash = _tcsrchr(tszFolderPath, TEXT('\\'));

            if (ptszLastSlash && lstrlen(ptszLastSlash) == 1)
            {
                *ptszLastSlash = TEXT('\0');
            }

            hr = JFGetDataObject(tszFolderPath,    // path to tasks dir
                                 pThis->_pidlFolder, // itemid of tasks folder
                                 1,                // one itemid in array
                                 &pidl,            // namely, this one
                                 FALSE,            // not doing cut/paste
                                 (VOID **) &pdo);

            if (SUCCEEDED(hr))
            {
                hr = DisplayJobProperties(pdo);
                CHECK_HRESULT(hr);
            }
            else
            {
                DEBUG_OUT_HRESULT(hr);
            }
        }

        delete pThis;
    }
    __finally
    {
        OleUninitialize();
    }

    return (DWORD) hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_DoWizard
//
//  Synopsis:   Create the wizard pages and invoke the wizard.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If wizard is successfully created, doesn't return until
//              user hits Cancel or Finish.
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::_DoWizard()
{
    TRACE_METHOD(CTaskWizard, _DoWizard);

    HRESULT         hr = S_OK;
    UINT            i = 0;
    HPROPSHEETPAGE  ahpsp[NUM_TASK_WIZARD_PAGES];

    SecureZeroMemory(ahpsp, sizeof(ahpsp));

    do
    {
        //
        // Create all the wizard pages
        //

        _apWizPages[TWP_WELCOME       ] = new CWelcomePage      (this, _tszFolderPath, &ahpsp[TWP_WELCOME       ]);
        _apWizPages[TWP_SELECT_PROGRAM] = new CSelectProgramPage(this, _tszFolderPath, &ahpsp[TWP_SELECT_PROGRAM]);
        _apWizPages[TWP_SELECT_TRIGGER] = new CSelectTriggerPage(this, _tszFolderPath, &ahpsp[TWP_SELECT_TRIGGER]);
        _apWizPages[TWP_DAILY         ] = new CDailyPage        (this, _tszFolderPath, &ahpsp[TWP_DAILY         ]);
        _apWizPages[TWP_WEEKLY        ] = new CWeeklyPage       (this, _tszFolderPath, &ahpsp[TWP_WEEKLY        ]);
        _apWizPages[TWP_MONTHLY       ] = new CMonthlyPage      (this, _tszFolderPath, &ahpsp[TWP_MONTHLY       ]);
        _apWizPages[TWP_ONCE          ] = new COncePage         (this, _tszFolderPath, &ahpsp[TWP_ONCE          ]);
        _apWizPages[TWP_PASSWORD      ] = new CPasswordPage     (this, _tszFolderPath, &ahpsp[TWP_PASSWORD      ]);
        _apWizPages[TWP_COMPLETION    ] = new CCompletionPage   (this, _tszFolderPath, &ahpsp[TWP_COMPLETION    ]);

        //
        // Check that all objects and pages could be created
        //

        for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
        {
            if (!_apWizPages[i] || !ahpsp[i])
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // Manually destroy the pages if one could not be created, then exit
        //

        if (FAILED(hr))
        {
            DEBUG_OUT((DEB_ERROR, "Creation failed, destroying pages\n"));

            for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
            {
                if (ahpsp[i])
                {
                    VERIFY(DestroyPropertySheetPage(ahpsp[i]));
                }
                else if (_apWizPages[i])
                {
                    delete _apWizPages[i];
                }
            }
            break;
        }

        //
        // All pages created, display the wizard
        //

        PROPSHEETHEADER psh;

        SecureZeroMemory(&psh, sizeof(psh));

#ifdef WIZARD97
        psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
        psh.pszbmWatermark      = _fUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256)   : MAKEINTRESOURCE(IDB_WATERMARK16);
        psh.pszbmHeader         = _fUse256ColorBmp ? MAKEINTRESOURCE(IDB_BANNER256)      : MAKEINTRESOURCE(IDB_BANNER16);
#else
        psh.dwFlags             = PSH_WIZARD;
#endif // WIZARD97
        psh.dwSize              = sizeof(psh);
        psh.hInstance           = g_hInstance;
        psh.hwndParent          = NULL;
        psh.pszCaption          = NULL; // ignored for wizards; see CWelcome init
        psh.phpage              = ahpsp;
        psh.nStartPage          = 0;
        psh.nPages              = NUM_TASK_WIZARD_PAGES;

        if (PropertySheet(&psh) == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_HRESULT(hr);
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   FindWizardEnumWndProc
//
//  Synopsis:   EnumWindows callback used to search for a create new task
//              wizard opened on the specified focus.
//
//  Arguments:  [hwnd]   - top level window handle
//              [lParam] - pointer to SFindWiz struct
//
//  Returns:    TRUE - not found, continue enumeration
//              FALSE - found wizard, quit enumerating
//
//  Modifies:   SFindWiz struct pointed to by [lParam]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL CALLBACK
FindWizardEnumWndProc(
    HWND hwnd,
    LPARAM lParam)
{
    SFindWiz *pfw = (SFindWiz *) lParam;
    ULONG     pid;

    GetWindowThreadProcessId(hwnd, &pid);

    do
    {
        //
        // If the window isn't in this process (explorer.exe) then ignore
        // it.
        //

        if (pid != GetCurrentProcessId())
        {
            break;
        }

        //
        // If it isn't the dialog class, it can't be a wizard.
        //

        if (!IsDialogClass(hwnd))
        {
            break;
        }

        //
        // Found a dialog window that was created by this process.  If it's
        // a wizard, then it should return a valid window which is also of
        // dialog class.
        //

        HWND hwndPage = PropSheet_GetCurrentPageHwnd(hwnd);

        if (!IsWindow(hwndPage) || !IsDialogClass(hwndPage))
        {
            break;
        }

        //
        // Could be a wizard page.  Ask it if it's THE wizard for the
        // focus.  Note it's only possible to get away with sending a pointer
        // in the message because we've guaranteed the window belongs to this
        // process.
        //

        ULONG ulResult = (ULONG)SendMessage(hwndPage,
                                            g_msgFindWizard,
                                            0,
                                            (LPARAM) pfw->tszFocus);

        if (ulResult == g_msgFindWizard)
        {
            pfw->fFound = TRUE;
        }
    } while (0);

    return !pfw->fFound; // continue enumerating if not found
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_FindWizard
//
//  Synopsis:   Search through top level windows to find a create new task
//              wizard which is focused on [ptszFolderPath].
//
//  Arguments:  [ptszFolderPath] - wizard focus
//
//  Returns:    S_OK    - found
//              S_FALSE - not found
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      BUGBUG change ptszFolderPath to server name
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::_FindWizard(
    LPCTSTR ptszFolderPath)
{
    SFindWiz    fw = { FALSE, ptszFolderPath };

    if (!g_msgFindWizard)
    {
        g_msgFindWizard = RegisterWindowMessage(TEMPLATE_STR);
    }

    EnumWindows(FindWizardEnumWndProc, (LPARAM) &fw);

    return fw.fFound ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\weekly.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       weekly.cxx
//
//  Contents:   Task wizard weekly trigger property page implementation.
//
//  Classes:    CWeeklyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NWEEKS_MIN - minimum value for weekly_nweeks_ud spin control
// NWEEKS_MAX - maximum value for weekly_nweeks_ud spin control
//

#define NWEEKS_MIN  1
#define NWEEKS_MAX  52


//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::CWeeklyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWeeklyPage::CWeeklyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_WEEKLY,
                     IDS_WEEKLY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CWeeklyPage);

    _flDaysOfTheWeek = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::~CWeeklyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWeeklyPage::~CWeeklyPage()
{
    TRACE_DESTRUCTOR(CWeeklyPage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnCommand
//
//  Synopsis:   Update internal state to match user's control changes
//
//  Arguments:  [id]         - id of control changed
//              [hwndCtl]    - hwnd of control changed
//              [codeNotify] - what happened to control
//
//  Returns:    0 (handled) or 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case weekly_sunday_ckbox:
            _flDaysOfTheWeek ^= TASK_SUNDAY;
            break;

        case weekly_monday_ckbox:
            _flDaysOfTheWeek ^= TASK_MONDAY;
            break;

        case weekly_tuesday_ckbox:
            _flDaysOfTheWeek ^= TASK_TUESDAY;
            break;

        case weekly_wednesday_ckbox:
            _flDaysOfTheWeek ^= TASK_WEDNESDAY;
            break;

        case weekly_thursday_ckbox:
            _flDaysOfTheWeek ^= TASK_THURSDAY;
            break;

        case weekly_friday_ckbox:
            _flDaysOfTheWeek ^= TASK_FRIDAY;
            break;

        case weekly_saturday_ckbox:
            _flDaysOfTheWeek ^= TASK_SATURDAY;
            break;

        default:
            lr = 1;
            break;
        }
        _UpdateWizButtons();
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), weekly_nweeks_edit, NULL, FALSE);

        if (iNewPos < NWEEKS_MIN || iNewPos > NWEEKS_MAX)
        {
            HWND hUD = _hCtrl(weekly_nweeks_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CWeeklyPage, _OnInitDialog);

    _UpdateTimeFormat();
    UpDown_SetRange(_hCtrl(weekly_nweeks_ud), NWEEKS_MIN, NWEEKS_MAX);
    UpDown_SetPos(_hCtrl(weekly_nweeks_ud), 1);
    Edit_LimitText(_hCtrl(weekly_nweeks_edit), 2);
    Button_SetCheck(_hCtrl(_idSelectedRadio), BST_CHECKED);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button only if this page has valid data
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CWeeklyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    pTrigger->TriggerType = TASK_TIME_TRIGGER_WEEKLY;

    pTrigger->Type.Weekly.WeeksInterval =
        UpDown_GetPos(_hCtrl(weekly_nweeks_ud));
    DEBUG_ASSERT(pTrigger->Type.Weekly.WeeksInterval);

    DEBUG_ASSERT(_flDaysOfTheWeek);
    pTrigger->Type.Weekly.rgfDaysOfTheWeek = _flDaysOfTheWeek;
    SYSTEMTIME st;

    GetLocalTime(&st);

    pTrigger->wBeginYear   = st.wYear;
    pTrigger->wBeginMonth  = st.wMonth;
    pTrigger->wBeginDay    = st.wDay;

    DateTime_GetSystemtime(_hCtrl(starttime_dp), &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}


//===========================================================================
//
// New methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next control if page data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWeeklyPage::_UpdateWizButtons()
{
    //
    // Enable Next if user has selected which weeks to run on and picked
    // days of the week to run on.
    //

    if (_flDaysOfTheWeek)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\welcome.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       welcome.cxx
//
//  Contents:   Task wizard welcome (initial) property page implementation.
//
//  Classes:    CWelcomePage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::CWelcomePage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWelcomePage::CWelcomePage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_WELCOME), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CWelcomePage);

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::~CWelcomePage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWelcomePage::~CWelcomePage()
{
    TRACE_DESTRUCTOR(CWelcomePage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWelcomePage::_OnInitDialog(
    LPARAM lParam)
{
    TCHAR tszCaption[MAX_TITLE_CCH];

    LoadStr(IDS_CAPTION, tszCaption, ARRAYLEN(tszCaption));
    VERIFY(SetWindowText(GetParent(Hwnd()), tszCaption));
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::_OnPSNSetActive
//
//  Synopsis:   Disable the back button, since this is the first page.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWelcomePage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\wizard\wizpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizpage.cxx
//
//  Contents:   Implementation of wizard page class
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// CWizPage statics
//

ULONG       CWizPage::s_cInstances;
HFONT       CWizPage::s_hfBigBold;
HFONT       CWizPage::s_hfBold;
#ifdef WIZARD95
SDIBitmap   CWizPage::s_Splash;
#endif // WIZARD95

#define DEFAULT_LARGE_FONT_SIZE         14


//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::CWizPage
//
//  Synopsis:   ctor
//
//  Arguments:  [szTmplt]     - dialog resource for page
//              [ptszJobPath] - full path to task object
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizPage::CWizPage(
    LPCTSTR szTmplt,
    LPTSTR ptszJobPath):
#ifdef WIZARD95
        _fActiveWindow(FALSE),
        _fPaletteChanged(FALSE),
#endif // WIZARD95
        CPropPage(szTmplt, ptszJobPath)
{
    InterlockedIncrement((LPLONG) &s_cInstances);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::~CWizPage
//
//  Synopsis:   dtor
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizPage::~CWizPage()
{
    //
    // If no more instances of this class are active, destroy the gdi stuff
    // stored in statics.
    //

    if (!InterlockedDecrement((LPLONG) &s_cInstances))
    {
        if (s_hfBigBold)
        {
            VERIFY(DeleteObject(s_hfBigBold));
            s_hfBigBold = NULL;
        }

        if (s_hfBold)
        {
            VERIFY(DeleteObject(s_hfBold));
            s_hfBold = NULL;
        }
#ifdef WIZARD95
        _DeleteSplashBitmap();
#endif // WIZARD95
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::DlgProc
//
//  Synopsis:   Overrides the CPropPage dialog proc for special message
//              handling, delegates to it for everything else.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::DlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    LRESULT lr;

    if (uMsg == WM_INITDIALOG)
    {
        m_fInInit = TRUE;
        _BaseInit();

        //
        // Create the gdi objects stored in statics if this is the first
        // instance of the class to receive an initdialog.
        //

#ifdef WIZARD95
        if (!s_Splash.hbmp)
        {
            _CreateSplashBitmap();
        }
#endif // WIZARD95

        if(!s_hfBigBold && !s_hfBold)
        {
            _CreateHeaderFonts();
        }

        //
        // Set the fonts of header strings to bold and large bold
        //

        _InitHeaderFonts();

        //
        // Let derived class init the dialog controls
        //

        lr = _OnInitDialog(lParam);
        m_fInInit = FALSE;
    }
    else if (uMsg == g_msgFindWizard)
    {
        //
        // If this wizard is already focused on the tasks folder indicated
        // by lParam, come to the foreground and indicate to the caller
        // that another wizard would be a duplicate and shouldn't be opened.
        //

        if (!lstrcmpi((LPCTSTR) lParam, GetTaskPath()))
        {
            SetForegroundWindow(GetParent(Hwnd()));
            SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, g_msgFindWizard);
        }
        lr = TRUE; // indicate we processed message
    }
#ifdef WIZARD95
    else if (uMsg == WM_PALETTECHANGED && (HWND) wParam != Hwnd())
    {
        _fPaletteChanged = TRUE;
        InvalidateRect(Hwnd(), NULL, FALSE);
    }
    else if (uMsg == WM_ACTIVATE)
    {
        _fActiveWindow = LOWORD(wParam) != WA_INACTIVE;
        InvalidateRect(Hwnd(), NULL, FALSE);
    }
#endif // WIZARD95
    else if (uMsg == WM_PAINT)
    {
#ifdef WIZARD95
        //
        // If some other window changed the palette, restore it before
        // painting, unless we're merely a background app.
        //

        if (_fActiveWindow)
        {
            HDC hdc = GetDC(Hwnd());

            if (!SelectPalette(hdc, s_Splash.hPalette, FALSE))
            {
                DEBUG_OUT_LASTERROR;
            }

            if (RealizePalette(hdc) == GDI_ERROR)
            {
                DEBUG_OUT_LASTERROR;
            }

            _fPaletteChanged = FALSE;
            ReleaseDC(Hwnd(), hdc);
        }
#endif // WIZARD95

        //
        // Do any custom painting required (the splash bitmap on first and
        // last pages).  Returning FALSE will allow the dialog manager to
        // process the paint as well.
        //

        lr = _OnPaint((HDC) wParam);
    }
    else
    {
        //
        // The message has no special meaning for the wizard; delegate
        // to base class so it can dispatch to the appropriate member.
        //

        lr = CPropPage::DlgProc(uMsg, wParam, lParam);
    }

    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnNotify
//
//  Synopsis:   Aggregate the CPropPage WM_NOTIFY handler to provide
//              wizard-specific dispatching.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    // TRACE_METHOD(CWizPage, _OnNotify);

    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    switch (pnmhdr->code)
    {
    //
    // Delegate to base class for notification processing it provides
    // which we don't need to override.
    //

    default:
        return CPropPage::_OnNotify(uMessage, uParam, lParam);

    //
    // Support notifications unique to wizard pages
    //

    case PSN_WIZBACK:
        return _OnWizBack();

    case PSN_WIZNEXT:
        return _OnWizNext();

    case PSN_WIZFINISH:
        return _OnWizFinish();
    }

    return TRUE;
}




//===========================================================================
//
// CWizPage methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnPaint
//
//  Synopsis:   Return FALSE to let dialog manager handle painting.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnPaint(
    HDC hdc)
{
#ifdef WIZARD95
    DEBUG_ASSERT(!hdc);
    _PaintSplashBitmap();
#endif // WIZARD95

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizBack
//
//  Synopsis:   Default handling of PSN_WIZBACK
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizBack()
{
    TRACE_METHOD(CWizPage, _OnWizBack);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizNext
//
//  Synopsis:   Default handling of PSN_WIZNEXT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizNext()
{
    TRACE_METHOD(CWizPage, _OnWizNext);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizFinish
//
//  Synopsis:   Default handling of PSN_WIZFINISH
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizFinish()
{
    TRACE_METHOD(CWizPage, _OnWizFinish);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_InitHeaderFonts
//
//  Synopsis:   Set the font for controls having the BOLDTITLE identifiers.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_InitHeaderFonts()
{
	_SetControlFont(s_hfBigBold, IDC_BIGBOLDTITLE);
	_SetControlFont(s_hfBold,    IDC_BOLDTITLE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_SetControlFont
//
//  Synopsis:   Set the font of control [nId] to [hFont]
//
//  Arguments:  [hFont] - font to use
//              [nId]   - id of control to set
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Does nothing if control not found or font handle is NULL.
//
//---------------------------------------------------------------------------

VOID
CWizPage::_SetControlFont(
    HFONT    hFont,
    INT      nId)
{
    if (hFont)
    {
        HWND hwndControl = _hCtrl(nId);

        if (hwndControl)
        {
            SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreateHeaderFonts
//
//  Synopsis:   Create fonts used in header title static text controls.
//
//  History:    5-20-1997   DavidMun   Stolen from sample wizard97 code
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreateHeaderFonts()
{
    DEBUG_ASSERT(!s_hfBigBold);
    DEBUG_ASSERT(!s_hfBold);

    //
	// Create the fonts we need based on the dialog font
    //

	NONCLIENTMETRICS ncm;

    SecureZeroMemory(&ncm, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	VERIFY(SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0));

	LOGFONT lfBigBold  = ncm.lfMessageFont;
	LOGFONT lfBold     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //

    lfBigBold.lfWeight   = FW_BOLD;
	lfBold.lfWeight      = FW_BOLD;

    TCHAR tszFontSizeString[24];
    ULONG ulFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //

    BOOL fOk;

    fOk = LoadString(g_hInstance,
                     IDS_LARGEFONTNAME,
                     lfBigBold.lfFaceName,
                     LF_FACESIZE);

    if (!fOk)
    {
        DEBUG_OUT_LASTERROR;
        StringCchCopy(lfBigBold.lfFaceName, LF_FACESIZE, TEXT("MS Shell Dlg"));
    }

    fOk = LoadString(g_hInstance,
                     IDS_LARGEFONTSIZE,
                     tszFontSizeString,
                     ARRAYLEN(tszFontSizeString));

    if (fOk)
    {
        ulFontSize = _tcstoul(tszFontSizeString, NULL, 10);
    }

    if (!fOk || !ulFontSize)
    {
        DEBUG_OUT_LASTERROR;
        ulFontSize = DEFAULT_LARGE_FONT_SIZE;
    }

	HDC hdc = GetDC(Hwnd());

    if (hdc)
    {
        //
        // See KB article PSS ID Number Q74299,
        //   "Calculating The Logical Height and Point Size of a Font"
        //

        lfBigBold.lfHeight = -MulDiv((INT) ulFontSize,
                                     GetDeviceCaps(hdc, LOGPIXELSY),
                                     72);

        s_hfBigBold = CreateFontIndirect(&lfBigBold);

        if (!s_hfBigBold)
        {
            DEBUG_OUT_LASTERROR;
        }

		s_hfBold = CreateFontIndirect(&lfBold);

        if (!s_hfBold)
        {
            DEBUG_OUT_LASTERROR;
        }

        ReleaseDC(Hwnd(), hdc);
    }
    else
    {
        DEBUG_OUT_LASTERROR;
    }
}




#ifdef WIZARD95
//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreateSplashBitmap
//
//  Synopsis:   Initialize a memory dc with the bitmap used on the first
//              and last pages.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreateSplashBitmap()
{
    TRACE_METHOD(CWizPage, _CreateSplashBitmap);

    DEBUG_ASSERT(!s_Splash.hbmp);
    DEBUG_ASSERT(!s_Splash.hdcMem);
    DEBUG_ASSERT(!s_Splash.hPalette);

    HDC     hdc = NULL;
    HRESULT hr = E_FAIL;

    do
    {
        s_Splash.hbmp = LoadResourceBitmap(IDB_SPLASH, &s_Splash.hPalette);

        if (!s_Splash.hbmp)
        {
            break;
        }

        BITMAP   bm;

        if (!GetObject(s_Splash.hbmp, sizeof(bm), (LPTSTR)&bm))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.Dimensions.cx = bm.bmWidth;
        s_Splash.Dimensions.cy = bm.bmHeight;

        hdc = GetDC(Hwnd());

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.hdcMem = CreateCompatibleDC(hdc);

        if (!s_Splash.hdcMem)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (!SelectPalette(hdc, s_Splash.hPalette, FALSE))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        UINT uiResult = RealizePalette(hdc);

        if (uiResult == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (!SelectPalette(s_Splash.hdcMem, s_Splash.hPalette, FALSE))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        uiResult = RealizePalette(s_Splash.hdcMem);

        if (uiResult == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.hbmpOld = (HBITMAP) SelectObject(s_Splash.hdcMem,
                                                  s_Splash.hbmp);


        hr = S_OK;
    } while (0);

    if (hdc)
    {
        ReleaseDC(Hwnd(), hdc);
    }

    if (FAILED(hr))
    {
        _DeleteSplashBitmap();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_DeleteSplashBitmap
//
//  Synopsis:   Free all gdi objects associated with splash bitmap.
//
//  History:    5-22-1997   DavidMun   Created
//
//  Notes:      Properly destroys a partly-initialized struct.  If the
//              struct is already empty, does nothing.
//
//---------------------------------------------------------------------------

VOID
CWizPage::_DeleteSplashBitmap()
{
    TRACE_METHOD(CWizPage, _DeleteSplashBitmap);

    if (s_Splash.hdcMem)
    {
        DEBUG_ASSERT(s_Splash.hbmp);
        DEBUG_ASSERT(s_Splash.hPalette);

        if (s_Splash.hbmpOld)
        {
            HBITMAP hbmp;

            hbmp = (HBITMAP) SelectObject(s_Splash.hdcMem, s_Splash.hbmpOld);

            DEBUG_ASSERT(hbmp == s_Splash.hbmp);
            s_Splash.hbmpOld = NULL;

            VERIFY(DeleteObject(s_Splash.hbmp));
            s_Splash.hbmp = NULL;
        }

        VERIFY(DeleteDC(s_Splash.hdcMem));
        VERIFY(DeleteObject(s_Splash.hPalette));

        s_Splash.hdcMem = NULL;
        s_Splash.hPalette = NULL;
    }
    else if (s_Splash.hbmp)
    {
        DEBUG_ASSERT(s_Splash.hPalette);
        VERIFY(DeleteObject(s_Splash.hbmp));
        VERIFY(DeleteObject(s_Splash.hPalette));
        s_Splash.hbmp = NULL;
        s_Splash.hPalette = NULL;
    }
    else
    {
        DEBUG_ASSERT(!s_Splash.hbmp);
        DEBUG_ASSERT(!s_Splash.hPalette);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_PaintSplashBitmap
//
//  Synopsis:   Paint the splash bitmap onto the dialog window.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_PaintSplashBitmap()
{
    TRACE_METHOD(CWizPage, _PaintSplashBitmap);
    HDC hdc = NULL;

    do
    {
        //
        // If an error prevented us from loading & processing the bitmap,
        // there's nothing to paint.
        //

        if (!s_Splash.hdcMem)
        {
            break;
        }

        //
        // Get the device context of this page's dialog, then blast the
        // bitmap onto it.
        //

        hdc = GetDC(Hwnd());

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        BOOL fOk = BitBlt(hdc,
                          0,
                          0,
                          s_Splash.Dimensions.cx,
                          s_Splash.Dimensions.cy,
                          s_Splash.hdcMem,
                          0,
                          0,
                          SRCCOPY);

        if (!fOk)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Mark the area containing the bitmap as a valid rect, so the
        // dialog manager won't paint over it.
        //

        RECT rc =
        {
            0,
            0,
            s_Splash.Dimensions.cx,
            s_Splash.Dimensions.cy
        };

        ValidateRect(Hwnd(), &rc);
    } while (0);

    if (hdc)
    {
        ReleaseDC(Hwnd(), hdc);
    }
}
#endif // WIZARD95




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreatePage
//
//  Synopsis:   Helper function that optionally loads title and subtitle
//              strings, sets appropriate flags, then creates the page.
//
//  Arguments:  [idsHeaderTitle]    - resource id of title, or 0 for none
//              [idsHeaderSubTitle] - resource id of subtitle, or 0 for none
//              [phPSP]             - filled with handle returned by
//                                      CreatePropertySheetPage
//
//  Modifies:   *[phPSP]
//
//  History:    5-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreatePage(
    ULONG idsHeaderTitle,
    ULONG idsHeaderSubTitle,
    HPROPSHEETPAGE *phPSP)
{
    TCHAR tszHeaderTitle[MAX_TITLE_CCH];
    TCHAR tszHeaderSubTitle[MAX_TITLE_CCH];
    HRESULT hr;

#ifdef WIZARD97
    if (idsHeaderTitle)
    {
        hr = LoadStr(idsHeaderTitle, tszHeaderTitle, MAX_TITLE_CCH);

        if (SUCCEEDED(hr))
        {
            m_psp.dwFlags |= PSP_USEHEADERTITLE;
        }
    }

    if (idsHeaderSubTitle)
    {
        hr = LoadStr(idsHeaderSubTitle, tszHeaderSubTitle, MAX_TITLE_CCH);

        if (SUCCEEDED(hr))
        {
            m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
        }
    }

    m_psp.pszHeaderTitle    = tszHeaderTitle;
    m_psp.pszHeaderSubTitle = tszHeaderSubTitle;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\smdebug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              23-Feb-01   JBenton     Added code to clean up crit sections
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <strsafe.h>
#include <stdarg.h>

#include "smdebug.h"

//////////////////////////////////////////////////////////////////////////////

unsigned long SmInfoLevel = DEF_INFOLEVEL;
unsigned long SmInfoMask = 0xffffffff;
unsigned long SmAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fCritSecInit = FALSE;
BOOL fInfoLevelInit = FALSE;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4smprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4smprintf(const char *format, va_list arglist)
{
	int ret;

	EnterCriticalSection(&s_csMessageBuf);
    ret = StringCchVPrintfA(g_szMessageBuf, 500, format, arglist);
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}

//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

EXPORTIMP void APINOT
SmAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (SmAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

		_asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (SmAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (SmAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    SetSmInfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmInfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = SmInfoLevel;
    SmInfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetSmInfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmInfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = SmInfoMask;
    SmInfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetSmAssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmAssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = SmAssertLevel;
    SmAssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

EXPORTIMP int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    StringCchPrintfA(szAssertCaption, 128, "Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
						| MB_DEFAULT_DESKTOP_ONLY
						| MB_TASKMODAL
						| MB_ICONEXCLAMATION
						| MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
								| MB_SERVICE_NOTIFICATION
								| MB_TASKMODAL
								| MB_ICONEXCLAMATION
								| MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

EXPORTIMP void APINOT
smprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | SmInfoLevel) & SmInfoMask))
    {
		EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((SmInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%x.%03x> %s: ", pid, tid, pszComp);
            }

            SYSTEMTIME st;
            GetLocalTime(&st);
            w4dprintf("%02d:%02d:%02d.%03d ", st.wHour, st.wMinute,
                      st.wSecond, st.wMilliseconds);

            w4smprintf(ppszfmt, pargs);
        }

        //if (SmInfoLevel & DEB_STDOUT)
        //{
        //    if (! (ulCompMask & DEB_NOCOMPNAME))
        //    {
        //        printf("%x.%03x> %s: ", pid, tid, pszComp);
        //    }
        //    vprintf(ppszfmt, pargs);
        //}

		LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// SysMan debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define SMDEBUGKEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SmDebug"

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
EXPORTDEF void APINOT
CheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;
    if (fInfoLevelInit) return;
    if (!fCritSecInit) InitializeDebugging();
    fInfoLevelInit = TRUE;
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SMDEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
}

void APINOT InitializeDebugging(void)
{
    if (fCritSecInit) return;
	InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    fCritSecInit = TRUE;
}

void APINOT CleanUpDebugging(void)
{
    if (fCritSecInit)
	{
    	DeleteCriticalSection(&s_csMessageBuf);
        DeleteCriticalSection(&s_csDebugPrint);
        fCritSecInit = FALSE;
	}
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\smdebug\smdebug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//				following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//				 7-Oct-94   BruceFo		Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//              23-Feb-01   JBenton     Added code to clean up crit sections
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//  "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SmDebug"
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif


#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
#define EXTRNC "C"
#else
#define EXTRNC
#endif

// smprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   smprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   EXPORTDEF void          APINOT
   SmAssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   EXPORTDEF unsigned long APINOT
   SetSmInfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetSmInfoMask(
       unsigned long ulNewMask);

   EXPORTDEF unsigned long APINOT
   SetSmAssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF void APINOT
   InitializeDebugging(
	   void);

   EXPORTDEF void APINOT
   CleanUpDebugging(
	   void);

   EXPORTDEF void APINOT
   CheckInit(char * pInfoLevelString, unsigned long * InfoLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

#define Win4Assert(x)  \
        (void)((x) || (SmAssertEx(__FILE__, __LINE__, #x),0))

#define Win4Verify(x) Win4Assert(x)


//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
 #define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif


#define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


#ifdef __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel); \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

#else  // ! __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel);
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

#endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define Win4Assert(x)  NULL
#define Win4Verify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\adsiedit.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

#include "pch.h"
#include "resource.h"

#include <SnapBase.h>

#include "ADSIEdit.h"
#include "snapdata.h"
#include "editor.h"
#include "connection.h"
#include "querynode.h"
#include "IAttredt.h"
#include "editorui.h"
#include "editimpl.h"

//#include "HelpArr.h"  // context help ID's

// Version info
#include <ntverp.h>
#define IDS_SNAPIN_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPIN_PROVIDER VER_COMPANYNAME_STR


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

//////////////////////////////////////////////////////////////////////////////
// regsvr debugging

// define to enable MsgBox debugging for regsvr32
//#define _MSGBOX_ON_REG_FAIL


#ifdef _MSGBOX_ON_REG_FAIL
#define _MSGBOX(x) AfxMessageBox(x)
#else
#define _MSGBOX(x)
#endif

#ifdef _MSGBOX_ON_REG_FAIL
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes) \
  ReportFail(lpszMessage, lpszClsid, lRes)

void ReportFail(LPCWSTR lpszMessage, LPCWSTR lpszClsid, LONG lRes)
{
  if (lRes == ERROR_SUCCESS)
    return;

  CThemeContextActivator activator;
  CString sz;
  sz.Format(_T("%s %s %d"), lpszMessage,lpszClsid, lRes);
  AfxMessageBox(sz);
}

#else
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes)
#endif


//////////////////////////////////////////////////////////////////////////////
// global constants and macros

// GUIDs for snapin
// {1C5DACFA-16BA-11d2-81D0-0000F87A7AA3}
static const GUID CLSID_ADSIEditSnapin =
{ 0x1c5dacfa, 0x16ba, 0x11d2, { 0x81, 0xd0, 0x0, 0x0, 0xf8, 0x7a, 0x7a, 0xa3 } };

// {E6F27C2A-16BA-11d2-81D0-0000F87A7AA3}
static const GUID CLSID_ADSIEditAbout =
{ 0xe6f27c2a, 0x16ba, 0x11d2, { 0x81, 0xd0, 0x0, 0x0, 0xf8, 0x7a, 0x7a, 0xa3 } };


// GUIDs for node types

///////////////////////////////////////////////////////////////////////////////
// RESOURCES



// # of columns in the result pane and map for resource strings

extern RESULT_HEADERMAP _HeaderStrings[] =
{
    { L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
    { L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 90},
    { L"", IDS_HEADER_DN,   LVCFMT_LEFT, 450},
};

COLUMN_DEFINITION DefaultColumnDefinition =
{
  COLUMNSET_ID_DEFAULT,
  N_HEADER_COLS,
  _HeaderStrings
};

extern RESULT_HEADERMAP _PartitionsHeaderStrings[] =
{
    { L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
  { L"", IDS_HEADER_NCNAME, LVCFMT_LEFT, 200},
    { L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 90},
    { L"", IDS_HEADER_DN,   LVCFMT_LEFT, 450},
};

COLUMN_DEFINITION PartitionsColumnDefinition =
{
  COLUMNSET_ID_PARTITIONS,
  N_PARTITIONS_HEADER_COLS,
  _PartitionsHeaderStrings
};

extern PCOLUMN_DEFINITION ColumnDefinitions[] =
{
  &DefaultColumnDefinition,
  &PartitionsColumnDefinition,
  NULL
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditModule

HRESULT WINAPI CADSIEditModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
    static const WCHAR szIPS32[] = _T("InprocServer32");
    static const WCHAR szCLSID[] = _T("CLSID");

    HRESULT hRes = S_OK;

    LPOLESTR lpOleStrCLSIDValue;
    ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
    if (lpOleStrCLSIDValue == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CRegKey key;
    if (bRegister)
    {
        LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
        _REPORT_FAIL(L"key.Open(HKEY_CLASSES_ROOT", lpOleStrCLSIDValue, lRes);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = key.Create(key, lpOleStrCLSIDValue);
            _REPORT_FAIL(L"key.Create(key", lpOleStrCLSIDValue, lRes);
            if (lRes == ERROR_SUCCESS)
            {
                // NOTICE-NTRAID#NTBUG9-551295-2002/02/21-artm  
                // GetModuleFileName() does not guarantee null termination.
                // Therefore, we allocated + 1 to hold the NULL and zero out
                // the buffer first.  We also check for a truncation and set
                // the error code if there was one.
                WCHAR szModule[_MAX_PATH + 1];
                ZeroMemory(szModule, sizeof(WCHAR) * (_MAX_PATH + 1) );

                DWORD numCopied = ::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
                if (numCopied < _MAX_PATH)
                {
                    lRes = key.SetKeyValue(szIPS32, szModule);
                    _REPORT_FAIL(L"key.SetKeyValue(szIPS32", lpOleStrCLSIDValue, lRes);
                }
                else
                {   // The module name was too big.  Something's fishy.
                    hRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                }
            }
        }
        if (lRes != ERROR_SUCCESS)
            hRes = HRESULT_FROM_WIN32(lRes);
    }
    else
    {
        key.Attach(HKEY_CLASSES_ROOT);
        if (key.Open(key, szCLSID) == ERROR_SUCCESS)
            key.RecurseDeleteKey(lpOleStrCLSIDValue);
    }
    ::CoTaskMemFree(lpOleStrCLSIDValue);
    return hRes;
}


///////////////////////////////////////////////////////////////////////////////
// Module, Object Map and DLL entry points

CADSIEditModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ADSIEditSnapin, CADSIEditComponentDataObject)
  OBJECT_ENTRY(CLSID_ADSIEditAbout, CADSIEditAbout) 
  OBJECT_ENTRY(CLSID_DsAttributeEditor, CAttributeEditor)
END_OBJECT_MAP()


STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


static _NODE_TYPE_INFO_ENTRY _NodeTypeInfoEntryArray[] = {
    { &CADSIEditRootData::NodeTypeGUID,         _T("Root ADSI Edit Subtree")        },
    { &CADSIEditConnectionNode::NodeTypeGUID,   _T("ADSI Edit Connection Node") },
    { &CADSIEditContainerNode::NodeTypeGUID,    _T("ADSI Edit Container Node")  },
    { &CADSIEditLeafNode::NodeTypeGUID,         _T("ADSI Edit Leaf Node")           },
    { &CADSIEditQueryNode::NodeTypeGUID,        _T("ADSI Edit Query Node")          },
    { NULL, NULL }
};


////////////////////////////////////////////////////////////////////


STDAPI DllRegisterServer(void)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CThemeContextActivator activator;
    // registers all objects
    HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
    _MSGBOX(_T("_Module.RegisterServer() failed"));
        return hr;
  }

  CString szVersion, szProvider, szSnapinName, szSnapinNameEx;

  szVersion = IDS_SNAPIN_VERSION;
  szProvider = IDS_SNAPIN_PROVIDER;
  // NOTICE-2002/03/06-artm  CString can throw out of memory exception but
  // that needs to be handled at a higher level.  Also, the return value
  // is not checked but the call should _never_ fail if there is enough
  // memory (o'wise there was a serious screw up in including the resource).
  szSnapinName.LoadString(IDS_SNAPIN_NAME);

    // register the standalone ADSI Edit snapin into the console snapin list
    hr = RegisterSnapin(&CLSID_ADSIEditSnapin,
                      &CADSIEditRootData::NodeTypeGUID,
                      &CLSID_ADSIEditAbout,
                        szSnapinName, szVersion, szProvider,
            FALSE /*bExtension*/,
                        _NodeTypeInfoEntryArray);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterSnapin(&CLSID_DNSSnapin) failed"));
        return hr;
  }

    // register the snapin nodes into the console node list
    for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
            pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
    {
        hr = RegisterNodeType(pCurrEntry->m_pNodeGUID,pCurrEntry->m_lpszNodeDescription);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
    {
      _MSGBOX(_T("RegisterNodeType() failed"));
            return hr;
    }
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));

    // un register the standalone snapin
    hr = UnregisterSnapin(&CLSID_ADSIEditSnapin);
    ASSERT(SUCCEEDED(hr));

    // unregister the snapin nodes,
  // this removes also the server node, with the Services Snapin extension keys
    for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
            pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
    {
        hr = UnregisterNodeType(pCurrEntry->m_pNodeGUID);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CADSIEditSnapinApp

class CADSIEditSnapinApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CADSIEditSnapinApp theApp;

BOOL CADSIEditSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);

  // Add theming support

  SHFusionInitializeFromModuleID(m_hInstance, 2);

    HRESULT hr = ::OleInitialize(NULL);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (!CADSIEditComponentDataObject::LoadResources())
        return FALSE;
    return CWinApp::InitInstance();
}

int CADSIEditSnapinApp::ExitInstance()
{
#ifdef _DEBUG_REFCOUNT
    TRACE(_T("CADSIEditSnapinApp::ExitInstance()\n"));
    ASSERT(CComponentDataObject::m_nOustandingObjects == 0);
    ASSERT(CComponentObject::m_nOustandingObjects == 0);
    ASSERT(CDataObject::m_nOustandingObjects == 0);
#endif // _DEBUG_REFCOUNT

   // Theming support

   SHFusionUninitialize();

    _Module.Term();
    return CWinApp::ExitInstance();
}

////////////////////////////////////////////////////////////////////////
// CADSIEditComponentObject (.i.e "view")


HRESULT CADSIEditComponentObject::InitializeHeaders(CContainerNode* pContainerNode)
{
  HRESULT hr = S_OK;
  ASSERT(m_pHeader);

  CColumnSet* pColumnSet = pContainerNode->GetColumnSet();
  POSITION pos = pColumnSet->GetHeadPosition();
  while (pos != NULL)
  {
    CColumn* pColumn = pColumnSet->GetNext(pos);

        hr = m_pHeader->InsertColumn(pColumn->GetColumnNum(), 
                                  pColumn->GetHeader(),
                                                        pColumn->GetFormat(),
                                                        AUTO_WIDTH);
        if (FAILED(hr))
            return hr;

    hr = m_pHeader->SetColumnWidth(pColumn->GetColumnNum(), 
                                    pColumn->GetWidth());
    if (FAILED(hr))
      return hr;
    }
  return hr;
}

HRESULT CADSIEditComponentObject::InitializeBitmaps(CTreeNode* cookie)
{
  HRESULT hr = S_OK;

  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  bool bBmpsLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();
  
  if (bBmpsLoaded)
  {
    ASSERT(m_pImageResult != NULL);
    hr = m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
                                           reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
                                           0, 
                                           BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}


////////////////////////////////////////////////////////////////////////
// CADSIEditComponentDataObject (.i.e "document")

CADSIEditComponentDataObject::CADSIEditComponentDataObject()
{
/*
    CWatermarkInfo* pWatermarkInfo = new CWatermarkInfo;
    pWatermarkInfo->m_nIDBanner = IDB_WIZBANNER;
    pWatermarkInfo->m_nIDWatermark = IDB_WIZWATERMARK;
    SetWatermarkInfo(pWatermarkInfo);
*/
  m_pColumnSet = new CADSIEditColumnSet(COLUMNSET_ID_DEFAULT);
}



HRESULT CADSIEditComponentDataObject::OnSetImages(LPIMAGELIST lpScopeImage)
{
  HRESULT hr = S_OK;

  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  bool bBmpsLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();
  
  if (bBmpsLoaded)
  {
    ASSERT(lpScopeImage != NULL);
    hr = lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
                                         reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
                                         0, 
                                         BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}



CRootData* CADSIEditComponentDataObject::OnCreateRootData()
{
    CADSIEditRootData* pADSIEditRootNode = new CADSIEditRootData(this);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szSnapinType;
    // NOTICE-2002/02/20-artm  LoadString() can throw out of memory exception.
    // This needs to be handled at a higher level, if at all.
    szSnapinType.LoadString(IDS_SNAPIN_NAME);
    pADSIEditRootNode->SetDisplayName(szSnapinType);
    return pADSIEditRootNode;
}


BOOL CADSIEditComponentDataObject::LoadResources()
{
  BOOL bLoadColumnHeaders = TRUE;
  
  for (UINT nIdx = 0; ColumnDefinitions[nIdx]; nIdx++)
  {
    PCOLUMN_DEFINITION pColumnDef = ColumnDefinitions[nIdx];
    bLoadColumnHeaders = LoadResultHeaderResources(pColumnDef->headers, pColumnDef->dwColumnCount);
    if (!bLoadColumnHeaders)
    {
      break;
    }
  }

  return 
        LoadContextMenuResources(CADSIEditConnectMenuHolder::GetMenuMap()) &&
        LoadContextMenuResources(CADSIEditContainerMenuHolder::GetMenuMap()) &&
        LoadContextMenuResources(CADSIEditRootMenuHolder::GetMenuMap()) &&
        LoadContextMenuResources(CADSIEditLeafMenuHolder::GetMenuMap()) &&
        LoadContextMenuResources(CADSIEditQueryMenuHolder::GetMenuMap()) &&
        bLoadColumnHeaders;
}


STDMETHODIMP CADSIEditComponentDataObject::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CADSIEditComponentObject>* pObject;
    CComObject<CADSIEditComponentObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

void CADSIEditComponentDataObject::OnNodeContextHelp(CTreeNode* pNode)
{
  ASSERT(pNode != NULL);

  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"w2rksupp.chm::/topics/adsiedit.htm");



//    spHelp->ShowTopic(L"w2rksupp.chm");
/*
  CString szNode;

  if (IS_CLASS(*pNode, CDNSRootData))
  {
    szNode = _T("Root Node");
  }
  else if (IS_CLASS(*pNode, CDNSServerNode))
  {
    szNode = _T("Server Node");
  }
  else if (IS_CLASS(*pNode, CDNSForwardZonesNode))
  {
    szNode = _T("Forward Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSReverseZonesNode))
  {
    szNode = _T("Reverse Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSZoneNode))
  {
    szNode = _T("Zone Node");
  }
  else if (IS_CLASS(*pNode, CDNSDomainNode))
  {
    szNode = _T("Domain Node");
  }
  else if (IS_CLASS(*pNode, CDNSCacheNode))
  {
    szNode = _T("Domain Node");
  }
  else if (dynamic_cast<CDNSRecordNodeBase*>(pNode) != NULL)
  {
    szNode = _T("Record Node");
  }

  if (!szNode.IsEmpty())
  {
    CString szMsg = _T("Context Help on ");
    szMsg += szNode;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;
    AfxMessageBox(szMsg);
  }
*/
}


LPCWSTR g_szContextHelpFileName = L"\\help\\adsiedit.hlp";
LPCWSTR g_szHTMLHelpFileName = L"w2rksupp.chm";

LPCWSTR CADSIEditComponentDataObject::GetHTMLHelpFileName()
{
  return g_szHTMLHelpFileName;
}

void CADSIEditComponentDataObject::OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo)
{
    ULONG nContextTopic;
  // TODO
  //if (FindDialogContextTopic(nDialogID, pHelpInfo, &nContextTopic))
    //  WinHelp(g_szContextHelpFileName, HELP_CONTEXTPOPUP, nContextTopic);
}

STDMETHODIMP CADSIEditComponentDataObject::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  // FUTURE-2002/02/21-artm  Review function to make sure that all return values are
  // documented for ISnapinHelp.
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;
  LPCWSTR lpszHelpFileName = GetHTMLHelpFileName();
  if (lpszHelpFileName == NULL)
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

  // FUTURE-2002/02/21-artm  Replace string literals with named constants.
  // Will improve readability and maintenance.
  CString szResourceKitDir = _T("");
  CString szKey = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components\\5A18D5BFC37FA0A4E99D24135BABE742";

    HRESULT err = S_OK;

    CRegKey key;
    LONG lRes = key.Open(HKEY_LOCAL_MACHINE, szKey);
    _REPORT_FAIL(L"key.Open(HKEY_LOCAL_MACHINE", szKey, lRes);
    if (lRes == ERROR_SUCCESS)
    {
        DWORD dwCount = 2 * MAX_PATH;
        PTSTR ptszValue = new TCHAR[dwCount];

        DWORD byteCount = dwCount * sizeof(TCHAR);
        DWORD bytesCopied = byteCount;

        ZeroMemory(ptszValue, byteCount);

        // NOTICE-NTRAID#NTBUG9-550463-2002/02/21-artm  
        // Need to check that string read from registry null terminated.
        lRes = key.QueryValue(
            ptszValue, // Destination buffer.
            L"DC5632422F082D1189A9000CF497879A", // Value to read
            &bytesCopied);  // In: size of destination buffer; Out: number of bytes written.

        _REPORT_FAIL(L"key.QueryValue(key", L"DC5632422F082D1189A9000CF497879A", lRes);

        if (lRes == ERROR_SUCCESS &&
            // Make sure that the value read wasn't truncated.
            ptszValue[dwCount - 1] == NULL &&
            // Check that something was written.
            bytesCopied > 0)
        {
            CString szValue = ptszValue;

            // Extract the directory from the path read from the registry.
            szResourceKitDir = szValue.Left(szValue.ReverseFind(L'\\') + 1);
        }
        else
        {
            if (lRes == ERROR_SUCCESS)
            {
                // This should never happen unless someone changed the location.
                // If it breaks from that it should be caught during testing.
                ASSERT(false);
                err = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        // NOTICE-NTRAID#NTBUG9-550528-2002/02/21-artm  Memory leak if lRes != ERROR_SUCCESS.
        // Fixed by moving delete outside of if()else statement.
        delete[] ptszValue;
    }

    if (FAILED(err))
    {
        return err;
    }

  CString szHelpFilePath = szResourceKitDir + CString(lpszHelpFileName);
  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);

  // NOTICE-2002/02/21-artm  lpCompiledHelpFile strictly an out parameter
  //
  // Since lpCompiledHelpFile is an OUT parm for ISnapinHelp::GetHelpTopic(),
  // it is assumed here that no memory has been allocated to the pointer.  If
  // the caller mistakenly does allocate lpCompiledHelpFile some memory before
  // calling, this will result in leaking memory since this function does not
  // free that memory before allocating memory with CoTaskMemAlloc().
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }
  else
  {
      // NOTICE-NTRAID-NTBUG9-551264-2002/02/21-artm  Need to handle case where CoTaskMemAlloc() fails.
      // If allocation fails, should return error code, not S_OK.
      err = E_OUTOFMEMORY;
  }

  return err;
}

////////////////////////////////////////////////////////////////////////////////
// help context macros and maps

#if (FALSE)

#define BEGIN_HELP_MAP(map) static DWORD map[] = {
#define HELP_MAP_ENTRY(x)   x, (DWORD)&g_aHelpIDs_##x ,
#define END_HELP_MAP         0, 0 };


#define NEXT_HELP_MAP_ENTRY(p) ((p)+2)
#define MAP_ENTRY_DLG_ID(p) (*p)
#define MAP_ENTRY_TABLE(p) ((DWORD*)(*(p+1)))
#define IS_LAST_MAP_ENTRY(p) (MAP_ENTRY_DLG_ID(p) == 0)

#define NEXT_HELP_TABLE_ENTRY(p) ((p)+2)
#define TABLE_ENTRY_CTRL_ID(p) (*p)
#define TABLE_ENTRY_HELP_ID(p) (*(p+1))
#define IS_LAST_TABLE_ENTRY(p) (TABLE_ENTRY_CTRL_ID(p) == 0)

BEGIN_HELP_MAP(_DNSMgrContextHelpMap)
  // misc dialogs
  HELP_MAP_ENTRY(IDD_CHOOSER_CHOOSE_MACHINE)
  HELP_MAP_ENTRY(IDD_BROWSE_DIALOG)

  // misc. add dialogs
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWHOST) // TODO
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWDOMAIN)// TODO
  HELP_MAP_ENTRY(IDD_SELECT_RECORD_TYPE_DIALOG)

  // NOTE: this has several incarnations...
  HELP_MAP_ENTRY(IDD_NAME_SERVERS_PAGE)

  // server property pages
  HELP_MAP_ENTRY(IDD_SERVER_INTERFACES_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_FORWARDERS_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_ADVANCED_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_LOGGING_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_BOOTMETHOD_PAGE)
  HELP_MAP_ENTRY(IDD_SERVMON_STATISTICS_PAGE)
  HELP_MAP_ENTRY(IDD_SERVMON_TEST_PAGE)

  // zone property pages
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_NBSTAT_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_NOTIFY_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_ADVANCED) // this is a subdialog, need to hook up

  // record property pages
  HELP_MAP_ENTRY(IDD_RR_NS_EDIT)
  HELP_MAP_ENTRY(IDD_RR_SOA)
  HELP_MAP_ENTRY(IDD_RR_A)
  HELP_MAP_ENTRY(IDD_RR_CNAME)
  HELP_MAP_ENTRY(IDD_RR_MX)
  HELP_MAP_ENTRY(IDD_RR_UNK)
  HELP_MAP_ENTRY(IDD_RR_TXT)
  HELP_MAP_ENTRY(IDD_RR_X25)
  HELP_MAP_ENTRY(IDD_RR_ISDN)
  HELP_MAP_ENTRY(IDD_RR_HINFO)
  HELP_MAP_ENTRY(IDD_RR_AAAA)
  HELP_MAP_ENTRY(IDD_RR_MB)
  HELP_MAP_ENTRY(IDD_RR_MG)
  HELP_MAP_ENTRY(IDD_RR_MD)
  HELP_MAP_ENTRY(IDD_RR_MF)
  HELP_MAP_ENTRY(IDD_RR_MR)
  HELP_MAP_ENTRY(IDD_RR_MINFO)
  HELP_MAP_ENTRY(IDD_RR_RP)
  HELP_MAP_ENTRY(IDD_RR_RT)
  HELP_MAP_ENTRY(IDD_RR_AFSDB)
  HELP_MAP_ENTRY(IDD_RR_WKS)
  HELP_MAP_ENTRY(IDD_RR_PTR)
  HELP_MAP_ENTRY(IDD_RR_SRV)
  HELP_MAP_ENTRY(IDD_RR_KEY)
  HELP_MAP_ENTRY(IDD_RR_SIG)

END_HELP_MAP



BOOL CDNSComponentDataObjectBase::FindDialogContextTopic(/*IN*/UINT nDialogID,
                                              /*IN*/ HELPINFO* pHelpInfo,
                                              /*OUT*/ ULONG* pnContextTopic)
{
    ASSERT(pHelpInfo != NULL);
  *pnContextTopic = 0;
    const DWORD* pMapEntry = _DNSMgrContextHelpMap;
    while (!IS_LAST_MAP_ENTRY(pMapEntry))
    {
        if (nDialogID == MAP_ENTRY_DLG_ID(pMapEntry))
        {
            DWORD* pTable = MAP_ENTRY_TABLE(pMapEntry);
            // look inside the table
            while (!IS_LAST_TABLE_ENTRY(pTable))
            {
                if (TABLE_ENTRY_CTRL_ID(pTable) == pHelpInfo->iCtrlId)
        {
                    *pnContextTopic = TABLE_ENTRY_HELP_ID(pTable);
          return TRUE;
        }
                pTable = NEXT_HELP_TABLE_ENTRY(pTable);
            }
        }
        pMapEntry = NEXT_HELP_MAP_ENTRY(pMapEntry);
    }
    return FALSE;
}

#endif


//////////////////////////////////////////////////////////////////////////
// CADSIEditAbout

CADSIEditAbout::CADSIEditAbout()
{
  m_szProvider = IDS_SNAPIN_PROVIDER;
    m_szVersion = IDS_SNAPIN_VERSION;
    m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
    m_uIdIconImage = IDI_ADSIEDIT_SNAPIN;
    m_uIdBitmapSmallImage = IDB_ABOUT_16x16;
    m_uIdBitmapSmallImageOpen = IDB_ABOUT_16x16;
    m_uIdBitmapLargeImage = IDB_ABOUT_32x32;
    m_crImageMask = BMP_COLOR_MASK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\adsiedit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       adsiedit.h
//
//--------------------------------------------------------------------------


#ifndef _ADSIEDIT_H
#define _ADSIEDIT_H

#include <stdabout.h>

//////////////////////////////////////////////////////////////////////////////
// global constants and macros

extern const CLSID CLSID_ADSIEditSnapin;    // In-Proc server GUID
extern const CLSID CLSID_ADSIEditAbout;    // In-Proc server GUID
extern const CLSID CLSID_DsAttributeEditor;
extern const CLSID IID_IDsAttributeEditor; 

///////////////////////////////////////////////////////////////////////////////
// RESOURCES

// enumeration for image strips
enum
{
    ROOT_IMAGE = 0,

    SEPARATOR_1,
    
    // 10 (5 regular, 5 test failed) images for server
    SERVER_IMAGE_NOT_LOADED,
    SERVER_IMAGE_LOADING,
    SERVER_IMAGE_LOADED,
    SERVER_IMAGE_UNABLE_TO_LOAD,
    SERVER_IMAGE_ACCESS_DENIED,

    SERVER_IMAGE_NOT_LOADED_TEST_FAIL,
    SERVER_IMAGE_LOADING_TEST_FAIL,
    SERVER_IMAGE_LOADED_TEST_FAIL,
    SERVER_IMAGE_UNABLE_TO_LOAD_TEST_FAIL,
    SERVER_IMAGE_ACCESS_DENIED_TEST_FAIL,

    SEPARATOR_2,

    // 12 (6 primary, 6 secondary) images for zones
    ZONE_IMAGE_1,
    ZONE_IMAGE_LOADING_1,
    ZONE_IMAGE_UNABLE_TO_LOAD_1,
    ZONE_IMAGE_PAUSED_1,
    ZONE_IMAGE_EXPIRED_1,
    ZONE_IMAGE_ACCESS_DENIED_1,

    SEPARATOR_3,

    ZONE_IMAGE_2,
    ZONE_IMAGE_LOADING_2,
    ZONE_IMAGE_UNABLE_TO_LOAD_2,
    ZONE_IMAGE_PAUSED_2,
    ZONE_IMAGE_EXPIRED_2,
    ZONE_IMAGE_ACCESS_DENIED_2,
    
    SEPARATOR_4,
    
    // 4 images for domains
    DOMAIN_IMAGE,
    DOMAIN_IMAGE_UNABLE_TO_LOAD,
    DOMAIN_IMAGE_LOADING,
    DOMAIN_IMAGE_ACCESS_DENIED,
    
    SEPARATOR_5,

    // 4 images for delegated domains
    DELEGATED_DOMAIN_IMAGE,
    DELEGATED_DOMAIN_IMAGE_UNABLE_TO_LOAD,
    DELEGATED_DOMAIN_IMAGE_LOADING,
    DELEGATED_DOMAIN_IMAGE_ACCESS_DENIED,

    SEPARATOR_6,

    // 4 generic images shared by cache, fwd and rev lookup zones
    FOLDER_IMAGE,
    FOLDER_IMAGE_UNABLE_TO_LOAD,
    FOLDER_IMAGE_LOADING,
    FOLDER_IMAGE_ACCESS_DENIED,

    SEPARATOR_7,

    // 1 record image
    RECORD_IMAGE_BASE,
    
    OPEN_FOLDER, // unused
    FOLDER_WITH_HAND
};

////////////////////////////////////////////////////////////////
// aliases for images indexes that share the same icon

#define ZONE_IMAGE_NOT_LOADED_1             ZONE_IMAGE_1
#define ZONE_IMAGE_NOT_LOADED_2             ZONE_IMAGE_2
#define ZONE_IMAGE_LOADED_1                 ZONE_IMAGE_1
#define ZONE_IMAGE_LOADED_2                 ZONE_IMAGE_2

#define DOMAIN_IMAGE_NOT_LOADED             DOMAIN_IMAGE
#define DOMAIN_IMAGE_LOADED                 DOMAIN_IMAGE

#define DELEGATED_DOMAIN_IMAGE_NOT_LOADED   DELEGATED_DOMAIN_IMAGE
#define DELEGATED_DOMAIN_IMAGE_LOADED       DELEGATED_DOMAIN_IMAGE

#define FOLDER_IMAGE_NOT_LOADED             FOLDER_IMAGE
#define FOLDER_IMAGE_LOADED                 FOLDER_IMAGE

///////////////////////////////////////////////////////////////
// bitmaps and images constants

#define BMP_COLOR_MASK RGB(255,0,255) // pink


///////////////////////////////////////////////////////////////
// headers for result pane

#define N_HEADER_COLS (3)
#define N_PARTITIONS_HEADER_COLS (4)

#define COLUMNSET_ID_DEFAULT L"--ADSI Edit Column Set--"
#define COLUMNSET_ID_PARTITIONS L"--Partitions Column Set--"
#define N_HEADER_NAME   (0)
#define N_HEADER_TYPE   (1)
#define N_HEADER_DN     (2)

#define N_PARTITIONS_HEADER_NAME     (0)
#define N_PARTITIONS_HEADER_NCNAME (1)
#define N_PARTITIONS_HEADER_TYPE     (2)
#define N_PARTITIONS_HEADER_DN       (3)

typedef struct _ColumnDefinition
{
  PCWSTR            pszColumnID;
  DWORD             dwColumnCount;
  RESULT_HEADERMAP* headers;
} COLUMN_DEFINITION, *PCOLUMN_DEFINITION;

extern PCOLUMN_DEFINITION ColumnDefinitions[];
extern RESULT_HEADERMAP _HeaderStrings[];
extern RESULT_HEADERMAP _PartitionsHeaderStrings[];

///////////////////////////////////////////////////////////////
// context menus

// Identifiers for each of the commands in the context menu.
enum
{
    // items for the root node
    IDM_SNAPIN_ADVANCED_VIEW,
  IDM_SNAPIN_FILTERING,
    IDM_SNAPIN_CONNECT_TO_SERVER,

    // items for the server node
    IDM_SERVER_NEW_ZONE,
    IDM_SERVER_UPDATE_DATA_FILES,
    // items for the zone node
    IDM_ZONE_UPDATE_DATA_FILE,

    // items for the domain node
    IDM_DOMAIN_NEW_RECORD,
    IDM_DOMAIN_NEW_DOMAIN,
    IDM_DOMAIN_NEW_DELEGATION,
    IDM_DOMAIN_NEW_HOST,
    IDM_DOMAIN_NEW_ALIAS,
    IDM_DOMAIN_NEW_MX,
    IDM_DOMAIN_NEW_PTR,
    
    // common items
};


DECLARE_MENU(CADSIEditDataMenuHolder)

//////////////////////////////////////////////////////////////////////////
// CADSIEditColumnSet

class CADSIEditColumnSet : public CColumnSet
{
public :
    CADSIEditColumnSet(PCWSTR pszColumnID)
        : CColumnSet(pszColumnID)
    {
    PCOLUMN_DEFINITION pColumnDef = NULL;
    for (UINT nIdx = 0; ColumnDefinitions[nIdx]; nIdx++)
    {
      pColumnDef = ColumnDefinitions[nIdx];
      // NTRAID#NTBUG9-563093-2002/03/06-artm  Need to check that pszColumnID not NULL.
      // It is bad to pass a NULL ptr to _wcsicmp().
      if (0 == _wcsicmp(pColumnDef->pszColumnID, pszColumnID))
      {
        break;
      }
    }

    if (pColumnDef)
    {
      for (int iCol = 0; iCol < pColumnDef->dwColumnCount; iCol++)
      {
        CColumn* pNewColumn = new CColumn(pColumnDef->headers[iCol].szBuffer,
                                          pColumnDef->headers[iCol].nFormat,
                                          pColumnDef->headers[iCol].nWidth,
                                          iCol);
        AddTail(pNewColumn);
      }
    }
    else
    {
      //
      // Fall back to adding the default column directly
      // 
          for (int iCol = 0; iCol < N_HEADER_COLS; iCol++)
          {
        CColumn* pNewColumn = new CColumn(_HeaderStrings[iCol].szBuffer,
                                          _HeaderStrings[iCol].nFormat,
                                          _HeaderStrings[iCol].nWidth,
                                          iCol);
        AddTail(pNewColumn);
          }
    }
    }
};


////////////////////////////////////////////////////////////////////////
// CADSIEditComponentObject (.i.e "view")

class CADSIEditComponentObject : public CComponentObject
{
BEGIN_COM_MAP(CADSIEditComponentObject)
    COM_INTERFACE_ENTRY(IComponent) // have to have at least one static entry, so pick one
    COM_INTERFACE_ENTRY_CHAIN(CComponentObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CADSIEditComponentObject)

protected:
    virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode);
    virtual HRESULT InitializeBitmaps(CTreeNode* cookie);
  virtual HRESULT InitializeToolbar(IToolbar* pToolbar) { return E_NOTIMPL; }
};



////////////////////////////////////////////////////////////////////////
// CADSIEditComponentDataObject (.i.e "document")

class CADSIEditComponentDataObject :
        public CComponentDataObject,
        public CComCoClass<CADSIEditComponentDataObject,&CLSID_ADSIEditSnapin>
{
BEGIN_COM_MAP(CADSIEditComponentDataObject)
    COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
    COM_INTERFACE_ENTRY_CHAIN(CComponentDataObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CADSIEditComponentDataObject)

DECLARE_REGISTRY_CLSID()

public:
  CADSIEditComponentDataObject();
  virtual ~CADSIEditComponentDataObject()
  {
    if (m_pColumnSet != NULL)
      delete m_pColumnSet;
  }

    // IComponentData interface members
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);

    // IPersistStream interface members
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
    {
        // NOTICE-NTRAID#NTBUG9-549476-2002/02/20-artm  NULL pointer not checked in release build.
        // Fix might be to do check and return E_POINTER if NULL.
        ASSERT(pClassID != NULL);
        if (NULL == pClassID)
        {
            return E_POINTER;
        }

        memcpy(pClassID, (GUID*)&GetObjectCLSID(), sizeof(CLSID));
        return S_OK;
    }

public:
    static BOOL LoadResources();
private:
    static BOOL FindDialogContextTopic(/*IN*/UINT nDialogID,
                                /*IN*/ HELPINFO* pHelpInfo,
                                /*OUT*/ ULONG* pnContextTopic);

// virtual functions
protected:
    virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage);
    
    virtual CRootData* OnCreateRootData();

    // help handling
  virtual LPCWSTR GetHTMLHelpFileName();
    virtual void OnNodeContextHelp(CTreeNode* pNode);
public:
    virtual void OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo);

  // ISnapinHelp interface members
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

  CADSIEditColumnSet* GetColumnSet() { return m_pColumnSet; }

  //
  // Allow multiple selection
  //
  virtual BOOL IsMultiSelect() { return TRUE; }

private:
  CADSIEditColumnSet* m_pColumnSet;

};


//////////////////////////////////////////////////////////////////////////
// CADSIEditAbout

class CADSIEditAbout :
    public CSnapinAbout,
    public CComCoClass<CADSIEditAbout, &CLSID_ADSIEditAbout>

{
public:
DECLARE_REGISTRY_CLSID()
    CADSIEditAbout();
};

#endif _ADSIEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.h
//
//--------------------------------------------------------------------------

#ifndef _ATTR_H
#define _ATTR_H

#include "common.h"

////////////////////////////////////////////////////////////////////////
// Forward Declarations
//
class CAttrList2;

////////////////////////////////////////////////////////////////////////
// CADSIAttribute

class CADSIAttribute
{
public:
	// Constructors
	//
	CADSIAttribute(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly = TRUE);
  CADSIAttribute(PADS_ATTR_INFO pInfo);
	CADSIAttribute(const CString& attributeName);
	CADSIAttribute(CADSIAttribute* pAttr);

	// Destructor
	//
	~CADSIAttribute(); 

	// Data accessor functions
	//
	void GetProperty(CString& sProp) { sProp = m_pAttrInfo->pszAttrName; }
	DWORD GetNumValues() { return m_pAttrInfo->dwNumValues; }

  HRESULT SetValues(PADSVALUE pADsValue, DWORD dwNumValues);
	HRESULT SetValues(const CStringList& sValues); 
   HRESULT AppendValues(PADSVALUE pADsValue, DWORD dwNumValues);
	void GetValues(CStringList& psValues, DWORD dwMaxCharCount = 1024);

	BOOL GetMultivalued() { return m_bMulti; }
	void SetMultivalued(BOOL bMulti) { m_bMulti = bMulti; }

	void SetDirty(const BOOL bDirty) { m_bDirty = bDirty; }
	BOOL IsDirty() { return m_bDirty; }

  void SetMandatory(const BOOL bMandatory) { m_bMandatory = bMandatory; }
  BOOL IsMandatory() { return m_bMandatory; }

  BOOL IsValueSet() { return m_bSet; }
  void SetValueSet(const BOOL bSet) { m_bSet = bSet; }

	ADSTYPE GetADsType() { return m_pAttrInfo->dwADsType; }
	void SetADsType(ADSTYPE dwType) { m_pAttrInfo->dwADsType = dwType; }

   CString GetSyntax() { return m_szSyntax; }
   void SetSyntax(PCWSTR pszSyntax) { m_szSyntax = pszSyntax; }

	ADS_ATTR_INFO* GetAttrInfo();
  void SetAttrInfo(PADS_ATTR_INFO pAttrInfo)
  {
    if (m_pAttrInfo != NULL)
    {
      _FreeADsAttrInfo(&m_pAttrInfo, FALSE);
    }
    m_pAttrInfo = pAttrInfo;
    m_bReadOnly = TRUE;
  }
	ADSVALUE* GetADsValues() { return m_pAttrInfo->pADsValues; }

	static HRESULT SetValuesInDS(CAttrList2* ptouchAttr, IDirectoryObject* pDirObject);

private:
	// Functions
	//
	ADSVALUE* GetADSVALUE(int idx);

	static BOOL _AllocOctetString(const ADS_OCTET_STRING& rOldOctetString, ADS_OCTET_STRING& rNew);
	static void _FreeOctetString(BYTE*& lpValue);
	static BOOL _AllocString(LPCWSTR lpsz, LPWSTR* lppszNew);
	static void _FreeString(LPWSTR* lppsz);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo);
	static BOOL _AllocValues(ADSVALUE** ppValues, DWORD dwLength);
	static BOOL _CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* ppNewAttrInfo);
	static void _FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength);

	static HRESULT _SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue);

   static 
   HRESULT
   _CloneADsValue(const ADSVALUE& original, ADSVALUE& clone);

   static
   void
   _FreeADsValue(ADSVALUE& value);

   static
   bool
   _CloneBlob(const BYTE* src, DWORD srcSize, BYTE*& dest, DWORD& destSize);

   static
   void
   _FreeBlob(BYTE*& blob, DWORD& blobSize);

   static
   bool
   _CloneProviderSpecificBlob(
      const ADS_PROV_SPECIFIC& src, 
      ADS_PROV_SPECIFIC& dest);

   static
   void
   _FreeProviderSpecificBlob(ADS_PROV_SPECIFIC& blob);

   static
   bool
   _CloneNtSecurityDescriptor(
      const ADS_NT_SECURITY_DESCRIPTOR& src,
      ADS_NT_SECURITY_DESCRIPTOR& dest);

   static
   void
   _FreeNtSecurityDescriptor(ADS_NT_SECURITY_DESCRIPTOR& sd);

   static
   bool
   _CloneDNWithBinary(
      const PADS_DN_WITH_BINARY& src,
      PADS_DN_WITH_BINARY& dest);

   static
   void
   _FreeDNWithBinary(PADS_DN_WITH_BINARY& dn);

   static
   bool
   _CloneDNWithString(
      const PADS_DN_WITH_STRING& src,
      PADS_DN_WITH_STRING& dest);

   static
   void
   _FreeDNWithString(PADS_DN_WITH_STRING& dn);




	// Member data
	//
	ADS_ATTR_INFO* m_pAttrInfo;
	BOOL m_bDirty;
	BOOL m_bMulti;
	BOOL m_bReadOnly;
  BOOL m_bMandatory;
  BOOL m_bSet;
  CString m_szSyntax;
};

////////////////////////////////////////////////////////////////////////////////
//
//
typedef CList<CADSIAttribute*,CADSIAttribute*> CAttrListBase2;

class CAttrList2 : public CAttrListBase2
{
public:
  CAttrList2() : m_pMandatorySavedValues(NULL), m_pOptionalSavedValues(NULL)
  {
  }

	virtual ~CAttrList2()
	{
    if (m_pMandatorySavedValues != NULL)
    {
      FreeADsMem(m_pMandatorySavedValues);
    }
    if (m_pOptionalSavedValues != NULL)
    {
      FreeADsMem(m_pOptionalSavedValues);
    }
		RemoveAllAttr();
	}

	void RemoveAllAttr() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	POSITION FindProperty(LPCWSTR lpszAttr);
	BOOL HasProperty(LPCWSTR lpszAttr);
	void GetNextDirty(POSITION& pos, CADSIAttribute** ppAttr);
	BOOL HasDirty();
  int GetDirtyCount()
  {
    int nCount = 0;
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      if (GetNext(pos)->IsDirty())
        nCount++;
    }
    return nCount;
  }

  void SaveMandatoryValuesPointer(PADS_ATTR_INFO pAttrInfo) { m_pMandatorySavedValues = pAttrInfo; }
  void SaveOptionalValuesPointer(PADS_ATTR_INFO pAttrInfo) { m_pOptionalSavedValues = pAttrInfo; }

private:
  PADS_ATTR_INFO  m_pMandatorySavedValues;
  PADS_ATTR_INFO  m_pOptionalSavedValues;
};

#ifndef OLD_ATTRIBUTE_CLASS
typedef CAttrList2 CAttrList;
typedef CADSIAttribute CADSIAttr;
#endif 


#endif //_ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attredit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attredit.h
//
//--------------------------------------------------------------------------

#ifndef _ATTREDIT_H
#define _ATTREDIT_H

#include "common.h"

#ifdef OLD_ATTRIBUTE_CLASS
#include "attribute.h"
#else
#include "attr.h"
#endif

#include "editor.h"


// use the HIWORD for generic flags and leave the LOWORD for application specific data
#define TN_FLAG_SHOW_MULTI		(0x00010000) // shows combobox for multivalued attributes or edit box for single
#define TN_FLAG_ENABLE_ADD						(0x00020000) // shows add if set, shows set if not
#define TN_FLAG_ENABLE_REMOVE				(0x00040000) // shows remove if set, shows clear if not

////////////////////////////////////////////////////////////////////////

class CAttrEditor;

#ifdef OLD_ATTRIBUTE_CLASS
/////////////////////////////////////////////////////////////////////////
// CADSIAttrList

typedef CList<CADSIAttr*,CADSIAttr*> CAttrListBase;

class CAttrList : public CAttrListBase
{
public:
	virtual ~CAttrList()
	{
		RemoveAllAttr();
	}

	void RemoveAllAttr() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	POSITION FindProperty(LPCWSTR lpszAttr);
	BOOL HasProperty(LPCWSTR lpszAttr);
	void GetNextDirty(POSITION& pos, CADSIAttr** ppAttr);
	BOOL HasDirty();
  int GetDirtyCount()
  {
    int nCount = 0;
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      if (GetNext(pos)->IsDirty())
        nCount++;
    }
    return nCount;
  }

};
#endif

///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

class CDNSManageButtonTextHelper
{
public:
	CDNSManageButtonTextHelper(int nStates);
	~CDNSManageButtonTextHelper();

	BOOL Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray);
	void SetStateX(int nIndex);

private:
	CWnd* m_pParentWnd;
	UINT m_nID;
	WCHAR* m_lpszText;

	int m_nStates;
	LPWSTR* m_lpszArr;
};

///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

class CDNSButtonToggleTextHelper : public CDNSManageButtonTextHelper
{
public:
	CDNSButtonToggleTextHelper();

	void SetToggleState(BOOL bFirst) { SetStateX(bFirst ? 0 : 1); }
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditBox

class CADSIEditBox : public CEdit
{
public: 
	CADSIEditBox(CAttrEditor* pEditor) 
	{
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnChange();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIValueBox

class	CADSIValueBox : public CEdit
{
public:
	CADSIValueBox(CAttrEditor* pEditor) 
	{
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////////////////////////
// CADSIValueList

class	CADSIValueList: public CListBox
{
public:
	CADSIValueList(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnSelChange();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIAddButton

class	CADSIAddButton: public CButton
{
public:
	CADSIAddButton(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnAdd();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIRemoveButton

class	CADSIRemoveButton: public CButton
{
public:
	CADSIRemoveButton(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnRemove();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////////////////////////
// CAttrEditor

class CAttrEditor 
{
public:
	// Constructor
	//
	CAttrEditor();

	// Destructor
	//
	~CAttrEditor() 
  {
  }

	BOOL Initialize(CPropertyPageBase* pParentWnd, CTreeNode* pTreeNode, LPCWSTR lpszServer, 
									UINT nIDEdit, UINT nIDSyntax, 
									UINT nIDValueBox,	UINT nIDValueList, 
									UINT nIDAddButton, UINT nIDRemoveButton,
									BOOL bComplete);

	BOOL Initialize(CPropertyPageBase* pParentWnd, CConnectionData* pConnectData, LPCWSTR lpszServer, 
									UINT nIDEdit, UINT nIDSyntax, 
									UINT nIDValueBox,	UINT nIDValueList, 
									UINT nIDAddButton, UINT nIDRemoveButton,
									BOOL bComplete, CAttrList* pAttrList);
	// Message Map functions
	//
	BOOL OnApply();
	void OnEditChange();
	void OnValueSelChange();
	void OnAddValue();
	void OnRemoveValue();

	void SetAttribute(LPCWSTR lpszAttr, LPCWSTR lpszPath);

	// I return a CADSIAttr* because I check the cache to see if
	// that attribute has already been touched.  If it has, the existing
	// attribute can be used to build the ui, if not a new one is created
	// and put into the cache.  It is then returned to build the ui.
	//
	CADSIAttr* TouchAttr(LPCWSTR lpszAttr);
	CADSIAttr* TouchAttr(ADS_ATTR_INFO* pADsInfo, BOOL bMulti);

protected:
	// Helper functions
	//
	void FillWithExisting();
	void DisplayAttribute();
	void DisplayFormatError();
	void DisplayRootDSE();
	BOOL IsMultiValued(ADS_ATTR_INFO* pAttrInfo);
	BOOL IsMultiValued(LPCWSTR lpszProp);
	BOOL IsRootDSEAttrMultiValued(LPCWSTR lpszAttr);
	void GetSyntax(LPCWSTR lpszProp, CString& sSyntax);
	void GetAttrFailed();
	void SetPropertyUI(DWORD dwFlags, BOOL bAnd, BOOL bReset = FALSE); 

	// Dialog Items
	//
	CADSIEditBox m_AttrEditBox;
	CADSIEditBox m_SyntaxBox;
	CADSIValueBox m_ValueBox;
	CADSIValueList m_ValueList;
	CADSIAddButton m_AddButton;
	CADSIRemoveButton m_RemoveButton;

	CPropertyPageBase* m_pParentWnd;
	CTreeNode* m_pTreeNode;

	// Data members
	//
	CString m_sAttr;
	CString m_sPath;
	CString m_sServer;
	CString m_sNotSet;
	CAttrList* m_ptouchedAttr;

	CADSIAttr* m_pAttr;
	CConnectionData* m_pConnectData;
  BOOL m_bExisting;

	DWORD m_dwMultiFlags;

	CDNSButtonToggleTextHelper m_AddButtonHelper;
	CDNSButtonToggleTextHelper m_RemoveButtonHelper;
};


#endif _ATTREDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attredit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attredit.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "common.h"
#include "attredit.h"
#include "connection.h"
#include "attrqry.h"


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

////////////////////////////////////////////////////////////////////////////
// this is used to fill in the attributes for RootDSE
//
typedef struct tagRootDSEAttr
{
    LPCWSTR lpszAttr;
    LPCWSTR lpszSyntax;  
   BOOL     bMulti;
} SYNTAXMAP;

extern SYNTAXMAP g_ldapRootDSESyntax[];
extern LPCWSTR g_lpszGC;
extern LPCWSTR g_lpszRootDSE;

#ifdef OLD_ATTRIBUTE_CLASS
///////////////////////////////////////////////////////////////////////////
// CAttrList

// If the property is not found in the attribute list, a NULL position is
// returned.
POSITION CAttrList::FindProperty(LPCWSTR lpszAttr)
{
    CADSIAttr* pAttr;
    
    // NOTICE-NTRAID#NTBUG9-556322-2002/05/03-artm  Need to validate lpszAttr before using.
    // This should never happen, but just in case . . .
    if (!lpszAttr)
    {
        ASSERT(false);
        return NULL;
    }

    for (POSITION p = GetHeadPosition(); p != NULL; GetNext(p))
    {
        // I use GetAt here because I don't want to advance the POSITION
        // because it is returned if they are equal
        //
        pAttr = GetAt(p);
        CString sName;
        pAttr->GetProperty(sName);
        // NOTICE-2002/02/25-artm  sName should be null terminated 
        // since already in data structure.  Validation for lpszAttr
        // should be done before entering for loop.
        if (wcscmp(sName, lpszAttr) == 0)
        {
            break;
        }
    }
    return p;
}

BOOL CAttrList::HasProperty(LPCWSTR lpszAttr)
{
    POSITION pos = FindProperty(lpszAttr);
    return pos != NULL;
}


// Searches through the cache for the attribute
// ppAttr will point to the CADSIAttr if found, NULL if not
//
void CAttrList::GetNextDirty(POSITION& pos, CADSIAttr** ppAttr)
{
    *ppAttr = GetNext(pos);
    if (pos == NULL && !(*ppAttr)->IsDirty())
    {
        *ppAttr = NULL;
        return;
    }

    while (!(*ppAttr)->IsDirty() && pos != NULL)
    {
        *ppAttr = GetNext(pos);
        if (!(*ppAttr)->IsDirty() && pos == NULL)
        {
            *ppAttr = NULL;
            break;
        }
    }
}

BOOL CAttrList::HasDirty()
{
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
        CADSIAttr* pAttr = GetNext(pos);
        if (pAttr->IsDirty())
        {
            return TRUE;
        }
    }
    return FALSE;
}

#endif

///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

CDNSManageButtonTextHelper::CDNSManageButtonTextHelper(int nStates) 
{
    m_nID = 0;
    m_pParentWnd = NULL;
    m_nStates = nStates;
    m_lpszText = NULL;
    m_lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*m_nStates);
  if (m_lpszArr != NULL)
  {
      memset(m_lpszArr, 0x0, sizeof(LPWSTR*)*m_nStates);
  }
  // FUTURE-2002/02/25-artm  If memory allocation fails,
  // set the number of states to 0 or maybe even an invalid value.
  // That way the caller will be able to check to see if things 
  // were allocated correctly.
}

CDNSManageButtonTextHelper::~CDNSManageButtonTextHelper()
{
    for (int k = 0; k < m_nStates; k++)
    {
        if (m_lpszArr[k] != NULL)
            free(m_lpszArr[k]);
    }

    free(m_lpszArr);
}

void CDNSManageButtonTextHelper::SetStateX(int nIndex)
{
    CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
    ASSERT(pWnd != NULL);
    ASSERT( (nIndex >0) || (nIndex < m_nStates));
    pWnd->SetWindowText(m_lpszArr[nIndex]);
}

BOOL CDNSManageButtonTextHelper::Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray)
{
    ASSERT(m_pParentWnd == NULL);
    ASSERT(pParentWnd != NULL);
    m_pParentWnd = pParentWnd;
    m_nID = nButtonID;

    CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
    if (pWnd == NULL)
        return FALSE;

    // get the text for the window
    int nSuccessEntries;
    // Load the resource strings whose ID's are in nStrArray.
    LoadStringArrayFromResource(m_lpszArr, nStrArray, m_nStates, &nSuccessEntries);
    ASSERT(nSuccessEntries == m_nStates);
    // NTRAID#NTBUG9-554712-2002/02/25-artm  No release code backing up assert.
    // Release code should validate that the resource strings were all correctly
    // loaded.

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

CDNSButtonToggleTextHelper::CDNSButtonToggleTextHelper()
        : CDNSManageButtonTextHelper(2)
{
}

///////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditBox, CEdit)
    ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

void CADSIEditBox::OnChange()
{
    m_pEditor->OnEditChange();
}

////////////////////////////////////////////////////////////////
// CADSIValueBox
BEGIN_MESSAGE_MAP(CADSIValueBox, CEdit)
//  ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////
// CADSIValueList
BEGIN_MESSAGE_MAP(CADSIValueList, CListBox)
    ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

void CADSIValueList::OnSelChange()
{
    m_pEditor->OnValueSelChange();
}

////////////////////////////////////////////////////////////////
// CADSIAddButton
BEGIN_MESSAGE_MAP(CADSIAddButton, CButton)
    ON_CONTROL_REFLECT(BN_CLICKED, OnAdd)
END_MESSAGE_MAP()

void CADSIAddButton::OnAdd()
{
    m_pEditor->OnAddValue();
}

////////////////////////////////////////////////////////////////
// CADSIRemoveButton
BEGIN_MESSAGE_MAP(CADSIRemoveButton, CButton)
    ON_CONTROL_REFLECT(BN_CLICKED, OnRemove)
END_MESSAGE_MAP()

void CADSIRemoveButton::OnRemove()
{
    m_pEditor->OnRemoveValue();
}

////////////////////////////////////////////////////////////////
// CAttrEditor

CAttrEditor::CAttrEditor()  : m_AttrEditBox(this),
                                                            m_SyntaxBox(this),
                                                            m_ValueBox(this),
                                                            m_ValueList(this),
                                                            m_AddButton(this),
                                                            m_RemoveButton(this),
                                                            m_AddButtonHelper(),
                                                            m_RemoveButtonHelper()
{
  m_bExisting = TRUE;
  m_ptouchedAttr = NULL;
}

BOOL CAttrEditor::Initialize(CPropertyPageBase* pParentWnd, CTreeNode* pTreeNode, 
                                                         LPCWSTR lpszServer, 
                                                         UINT nIDEdit, UINT nIDSyntax, 
                                                         UINT nIDValueBox, UINT nIDValueList, 
                                                         UINT nIDAddButton, UINT nIDRemoveButton,
                                                         BOOL bComplete)
{
    ASSERT(pParentWnd != NULL);
    if (pParentWnd == NULL)
        return FALSE;
    m_pParentWnd = pParentWnd;

  m_ptouchedAttr = new CAttrList();
  ASSERT(m_ptouchedAttr != NULL);

    if (pTreeNode == NULL)
  {
        m_bExisting = FALSE;
  }
  else
  {
    m_bExisting = TRUE;
  }

    m_sServer = lpszServer;

  if (m_bExisting)
  {
      // This gets the CConnectionData from the ConnectionNode by finding a valid treenode and using its
      //   CADsObject to get the ConnectionNode and then the CConnectionData
      //
      m_pTreeNode = pTreeNode;
      CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pTreeNode);
      if (pContNode == NULL)
      {
          CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(m_pTreeNode);
          ASSERT(pLeafNode != NULL);
          m_pConnectData = pLeafNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
      }
      else
      {
          m_pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
      }
  }

    // sublclass controls
    //
    BOOL bRes = m_AttrEditBox.SubclassDlgItem(nIDEdit, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_SyntaxBox.SubclassDlgItem(nIDSyntax, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_ValueBox.SubclassDlgItem(nIDValueBox, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_ValueList.SubclassDlgItem(nIDValueList, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_AddButton.SubclassDlgItem(nIDAddButton, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;
    UINT nAddButtonTextIDs[2] = { IDS_BUTTON_TEXT_ADD, IDS_BUTTON_TEXT_SET };
    m_AddButtonHelper.Init(m_pParentWnd, 
                                  nIDAddButton, 
                                  nAddButtonTextIDs);

    bRes = m_RemoveButton.SubclassDlgItem(nIDRemoveButton, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;
    UINT nRemoveButtonTextIDs[2] = { IDS_BUTTON_TEXT_REMOVE, IDS_BUTTON_TEXT_CLEAR };
    m_RemoveButtonHelper.Init(m_pParentWnd,
                                      nIDRemoveButton,
                                      nRemoveButtonTextIDs);

    // NOTICE-2002/02/27-artm  Under low memory environment CString can
    // throw out of memory exceptions.  ADSI edit prefers to shutdown over
    // trying to handle the exception (since no other components depend on
    // the tool).
    if (!m_sNotSet.LoadString(IDS_NOT_SET))
    {
        return FALSE;
    }

    if ( bComplete)
    {
        // Show property values as single and without the ability to set or clear
        //
        SetPropertyUI(0, FALSE, TRUE);
    }
    else
    {
        m_AttrEditBox.ShowWindow(SW_HIDE);
        m_SyntaxBox.ShowWindow(SW_HIDE);
        m_ValueBox.ShowWindow(SW_HIDE);
        m_ValueList.ShowWindow(SW_HIDE);
        m_AddButton.ShowWindow(SW_HIDE);
        m_RemoveButton.ShowWindow(SW_HIDE);
    }
    return bRes;
}

BOOL CAttrEditor::Initialize(CPropertyPageBase* pParentWnd, CConnectionData* pConnectData, 
                                                         LPCWSTR lpszServer, 
                                                         UINT nIDEdit, UINT nIDSyntax, 
                                                         UINT nIDValueBox, UINT nIDValueList, 
                                                         UINT nIDAddButton, UINT nIDRemoveButton,
                                                         BOOL bComplete, CAttrList* pAttrList)
{
    ASSERT(pParentWnd != NULL);
    if (pParentWnd == NULL)
        return FALSE;
    m_pParentWnd = pParentWnd;

    m_bExisting = FALSE;
    m_sServer = lpszServer;
  m_pConnectData = pConnectData;

  ASSERT(pAttrList != NULL);
  m_ptouchedAttr = pAttrList;

    // sublclass controls
    //
    BOOL bRes = m_AttrEditBox.SubclassDlgItem(nIDEdit, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_SyntaxBox.SubclassDlgItem(nIDSyntax, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_ValueBox.SubclassDlgItem(nIDValueBox, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_ValueList.SubclassDlgItem(nIDValueList, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;

    bRes = m_AddButton.SubclassDlgItem(nIDAddButton, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;
    UINT nAddButtonTextIDs[2] = { IDS_BUTTON_TEXT_ADD, IDS_BUTTON_TEXT_SET };
    m_AddButtonHelper.Init(m_pParentWnd, 
                                  nIDAddButton, 
                                  nAddButtonTextIDs);

    bRes = m_RemoveButton.SubclassDlgItem(nIDRemoveButton, m_pParentWnd);
    ASSERT(bRes);
    if (!bRes) return FALSE;
    UINT nRemoveButtonTextIDs[2] = { IDS_BUTTON_TEXT_REMOVE, IDS_BUTTON_TEXT_CLEAR };
    m_RemoveButtonHelper.Init(m_pParentWnd,
                                      nIDRemoveButton,
                                      nRemoveButtonTextIDs);

    // NOTICE-2002/02/27-artm  Under low memory environment CString can
    // throw out of memory exceptions.  ADSI edit prefers to shutdown over
    // trying to handle the exception (since no other components depend on
    // the tool).
    if (!m_sNotSet.LoadString(IDS_NOT_SET))
    {
        return FALSE;
    }

    if ( bComplete)
    {
        // Show property values as single and without the ability to set or clear
        //
        SetPropertyUI(0, FALSE, TRUE);
    }
    else
    {
        m_AttrEditBox.ShowWindow(SW_HIDE);
        m_SyntaxBox.ShowWindow(SW_HIDE);
        m_ValueBox.ShowWindow(SW_HIDE);
        m_ValueList.ShowWindow(SW_HIDE);
        m_AddButton.ShowWindow(SW_HIDE);
        m_RemoveButton.ShowWindow(SW_HIDE);
    }
    return bRes;
}
void CAttrEditor::SetAttribute(LPCWSTR lpszAttr, LPCWSTR lpszPath)
{ 
    m_sAttr = lpszAttr; 
    m_sPath = lpszPath; 
    DisplayAttribute(); 
}


BOOL CAttrEditor::OnApply()
{
    if (m_bExisting && m_ptouchedAttr->HasDirty() && 
            !m_pConnectData->IsRootDSE() &&
            !m_pConnectData->IsGC())
    {
        CComPtr<IDirectoryObject> pDirObject;

        // bind to object with authentication
        //
        HRESULT hr, hCredResult;
        hr = OpenObjectWithCredentials(
                                                                     m_pConnectData, 
                                                                     m_pConnectData->GetCredentialObject()->UseCredentials(),
                                                                     m_sPath,
                                                                     IID_IDirectoryObject, 
                                                                     (LPVOID*) &pDirObject,
                                                                     NULL,
                                                                     hCredResult
                                                                     );

        if (FAILED(hr))
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
                m_pParentWnd->SetModified(FALSE);
            }
            // Need to change the focus or we will not be able to navigate with the keyboard
            m_AttrEditBox.SetFocus();
            return FALSE;
        }

        // Change or add values to ADSI cache that have changed
        //
        hr = CADSIAttr::SetValuesInDS(m_ptouchedAttr, pDirObject);


        if (FAILED(hr))
        {
            //Format Error message and pop up a dialog
            ADSIEditErrorMessage(hr);

            m_ptouchedAttr->RemoveAllAttr();
            DisplayAttribute();

            m_pParentWnd->SetModified(FALSE);

      // Need to change the focus or we will not be able to navigate with the keyboard
            m_AttrEditBox.SetFocus();
            return FALSE;
        }
    }
    m_pParentWnd->SetModified(FALSE);
    return TRUE;
}

void CAttrEditor::OnAddValue()
{
    ASSERT(!m_pConnectData->IsRootDSE());
    ASSERT(!m_pConnectData->IsGC()); 
    
    // NOTICE-2002/02/25-artm  Only threat here is that CString will throw out of memory.
    CString s;
    m_AttrEditBox.GetWindowText(s);

    CStringList sList; 
    m_pAttr->GetValues(sList);

    if (m_pAttr->GetMultivalued())
    {
        // if it is the first value to be added we need to get rid of the "<not set>"
        //
        CString sNotSet;
        m_ValueList.GetText(0, sNotSet);
        if (sNotSet == m_sNotSet)
        {
            m_ValueList.ResetContent();
        }

        // then add the new value
        //
        sList.AddTail(s);
    }
    else
    {
        // since it is single valued, remove the old one and add the new one
        //
        sList.RemoveAll();
        sList.AddTail(s);
    }

    HRESULT hr = m_pAttr->SetValues(sList);
    if (FAILED(hr))
    {
        DisplayFormatError();
    }
    else
    {
        if ( m_pAttr->GetMultivalued())
        {
            m_ValueList.AddString(s);
        }
        else
        {
            m_ValueBox.SetWindowText(s);
        }

        m_AttrEditBox.SetWindowText(_T(""));
        m_pAttr->SetDirty(TRUE);
        m_pParentWnd->SetModified(TRUE);

        // Make the UI reflect the new data
        //
        m_AttrEditBox.SetFocus();
        SetPropertyUI(~TN_FLAG_ENABLE_ADD, TRUE);

        // Enable the clear button if the attribute is not multivalued
        //
        if ( !m_pAttr->GetMultivalued())
        {
            SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
        }
    }
}

void CAttrEditor::DisplayFormatError()
{
    switch (m_pAttr->GetADsType())
    {
        case ADSTYPE_DN_STRING :
        case ADSTYPE_CASE_EXACT_STRING :
        case ADSTYPE_CASE_IGNORE_STRING :
        case ADSTYPE_PRINTABLE_STRING :
        case ADSTYPE_NUMERIC_STRING :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        case ADSTYPE_BOOLEAN :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_BOOLEAN, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        case ADSTYPE_INTEGER :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        case ADSTYPE_OCTET_STRING :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_OCTET, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        case ADSTYPE_UTC_TIME :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_TIME, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        case ADSTYPE_LARGE_INTEGER :
        case ADSTYPE_OBJECT_CLASS :
        case ADSTYPE_UNKNOWN :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }

        default :
        {
            ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            if (m_pAttr->GetMultivalued())
            {
                if (m_ValueList.GetCount() < 1)
                {
                    m_ValueList.AddString(m_sNotSet);
                }
            }
            break;
        }
    }
}

void CAttrEditor::OnRemoveValue()
{
    if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC()) 
    {
        CStringList sList;
        m_pAttr->GetValues(sList);

        DWORD dwNumVals = m_pAttr->GetNumValues();
        if (m_pAttr->GetMultivalued())
        {
            CString s, sVal;
            int iCount = m_ValueList.GetCurSel();
            m_ValueList.GetText(iCount, sVal);
            m_AttrEditBox.SetWindowText(sVal);
            m_ValueList.DeleteString(iCount);

            // Add "<not set>" to the UI if this is the last value being removed
            //
            if (m_ValueList.GetCount() == 0)
            {
                m_AttrEditBox.SetFocus();
                SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
                m_ValueList.AddString(m_sNotSet);
        if (!m_bExisting)
        {
          m_pAttr->SetDirty(FALSE);
        }
            }
            POSITION pos = sList.FindIndex(iCount);

            sList.RemoveAt(pos);
            HRESULT hr = m_pAttr->SetValues(sList);
            if (FAILED(hr))
            {
                ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            }
      if (m_bExisting || m_ValueList.GetCount() > 0)
      {
        m_pAttr->SetDirty(TRUE);
      }
        }
        else
        {
            // NOTICE-2002/02/25-artm  Only threat is that CString will throw
            // out of memory exception.  The input is as safe as can be, coming
            // from UI and there is no manipulation.
            CString sVal;
            m_ValueBox.GetWindowText(sVal);
            m_AttrEditBox.SetWindowText(sVal);
            m_ValueBox.SetWindowText( m_sNotSet);
            sList.RemoveAll();
            HRESULT hr = m_pAttr->SetValues(sList);
            if (FAILED(hr))
            {
                ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
            }
      if (!m_bExisting)
      {
        m_pAttr->SetDirty(FALSE);
      }
      else
      {
        m_pAttr->SetDirty(TRUE);
      }
        }
        m_AttrEditBox.SetFocus();
        SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
        dwNumVals--;
        m_pParentWnd->SetModified(TRUE);
    }
}

void CAttrEditor::OnEditChange()
{
    if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC()) 
    {
        CString s;
        // NOTICE-2002/02/25-artm  Only threat is that CString can throw
        // out of memory exceptions.
        m_AttrEditBox.GetWindowText(s);
        if (s != _T(""))
        {
            SetPropertyUI(TN_FLAG_ENABLE_ADD, FALSE);
        }
        else
        {
            SetPropertyUI(~TN_FLAG_ENABLE_ADD, TRUE);
        }
    }
}

void CAttrEditor::OnValueSelChange()
{
    if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC())
    {
        SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
    }
}

void CAttrEditor::GetAttrFailed()
{
    CString sSyntax;

    GetSyntax(m_sAttr, sSyntax);
    m_SyntaxBox.SetWindowText(sSyntax);

    m_ValueList.ResetContent();
    m_ValueList.AddString(m_sNotSet);
  m_ValueBox.SetWindowText(m_sNotSet);

    SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
}

void CAttrEditor::FillWithExisting()
{
    CString s;
    m_pAttr = m_ptouchedAttr->GetAt(m_ptouchedAttr->FindProperty(m_sAttr));
  ASSERT(m_pAttr != NULL);

    CStringList slValues;
    m_pAttr->GetValues(slValues);

    if (m_pAttr->GetMultivalued())
    {
        m_ValueList.ResetContent();

        POSITION pos;
        if (slValues.GetCount() == 0)
        {
            slValues.AddTail(m_sNotSet);
        }
        
        for (pos = slValues.GetHeadPosition(); pos != NULL; slValues.GetNext(pos) )
        {
            s = slValues.GetAt(pos);
            m_ValueList.AddString(s);
        }

        SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
    }
    else
    {
        if (slValues.GetCount() > 0)
        {
            s = slValues.GetAt(slValues.GetHeadPosition());
            m_ValueBox.SetWindowText(s);

            if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC())
            {
                SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
            }
        }
        else
        {
            m_ValueBox.SetWindowText(m_sNotSet);
            SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
        }
        SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
    }
}



void CAttrEditor::DisplayAttribute()
{
    int iCount;
    HRESULT hr, hCredResult;

    if (m_ptouchedAttr->HasProperty(m_sAttr))
    {
        FillWithExisting();
    }
    else
    {

        if (m_pConnectData->IsRootDSE())
        {
            DisplayRootDSE();
        }
    else if (!m_bExisting)
    {
            ADS_ATTR_INFO *pAttrInfo = NULL;
            GetAttrFailed();
            m_pAttr = TouchAttr(m_sAttr);
      ASSERT(m_pAttr != NULL);
      
      if (m_pAttr != NULL)
      {
              if (m_pAttr->GetMultivalued())
              {
                  SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
              }
              else
              {
                  SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
              }
      }
            return;
    }
        else
        {
            CComPtr<IDirectoryObject> pDirObject;

            hr = OpenObjectWithCredentials(
                                                     m_pConnectData, 
                                                     m_pConnectData->GetCredentialObject()->UseCredentials(),
                                                     m_sPath,
                                                     IID_IDirectoryObject, 
                                                     (LPVOID*) &pDirObject,
                                                     NULL,
                                                     hCredResult
                                                     );
            if ( FAILED(hr) )
            {
                if (SUCCEEDED(hCredResult))
                {
                    ADSIEditErrorMessage(hr);
                }
                return;
            }
      ASSERT(pDirObject != NULL);

            // Get attribute
            //
      CString szAttrName;
      szAttrName = m_sAttr + _T(";range=0-*");
      CString szFormat = m_sAttr + _T(";range=%ld-*");
            DWORD dwReturn = 0;
            DWORD dwNumAttr = 1;
            ADS_ATTR_INFO *pAttrInfo;

      const WCHAR wcSep = L'-';
      const WCHAR wcEnd = L'*';
      BOOL fMoreRemain = FALSE;

      CStringList sList;

      do
      {
        LPWSTR lpszAttrs[] = {(LPWSTR)(LPCWSTR)szAttrName};
              hr = pDirObject->GetObjectAttributes(lpszAttrs, dwNumAttr, &pAttrInfo, &dwReturn);
              if (FAILED(hr))
              {
                  ADSIEditErrorMessage(hr);
                  return;
              }

              if (pAttrInfo == NULL)
              {
                  GetAttrFailed();
                  m_pAttr = TouchAttr(m_sAttr);
          ASSERT(m_pAttr != NULL);
          
          if (m_pAttr != NULL)
          {
                    if (m_pAttr->GetMultivalued())
                    {
                        SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
                    }
                    else
                    {
                        SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
                    }
          }
                  return;
              }

        if (dwReturn > 0)
        {
                  GetStringFromADs(pAttrInfo, sList);
        }

        //
        // Check to see if there is more data. If the last char of the
        // attribute name string is an asterisk, then we have everything.
        //
        // NOTICE-2002/02/25-artm  This is trusting that AD is null 
        // terminating the name of the attribute.  The reasons why this
        // trust in service outside the component is allowable are:
        // 1) If AD is being spoofed the attacker will 'only' get us to read
        // bogus memory.  This will AV the client app.
        // 2) There is no way to validate the length of the attribute name
        // string with the current ADS_ATTR_INFO structure.
        int cchEnd = wcslen(pAttrInfo->pszAttrName);

        fMoreRemain = pAttrInfo->pszAttrName[cchEnd - 1] != wcEnd;

        if (fMoreRemain)
        {
            PWSTR pwz = wcsrchr(pAttrInfo->pszAttrName, wcSep);
            if (!pwz)
            {
                ASSERT(FALSE && pAttrInfo->pszAttrName);
                fMoreRemain = FALSE;
            }
            else
            {
                pwz++; // move past the hyphen to the range end value.

                // NOTICE-2002/02/27-artm  Assert does not require release code.
                // The assert is a sanity check that the ADSI interface did not return an
                // undocumented string format.  In other words, there should never be a time
                // when this branch is entered and the '-' is the last character in the string.
                // The release code does not need this check b/c if it does occur (and it shouldn't),
                // there's a bug in ADSI.  The tool will crash from reading past pointer and go 
                // into Dr. Watson (which can be used just as well to track down the bug). 
                ASSERT(*pwz);

                long lEnd = _wtol(pwz);
                lEnd++; // start with the next value.
                szAttrName.Format(szFormat, lEnd);
                TRACE(L"Range returned is %ws, now asking for %ws\n",
                             pAttrInfo->pszAttrName, szAttrName);
            }
        }
      } while (fMoreRemain);

            BOOL bMulti = FALSE;
      if (m_pConnectData->IsGC())
      {
        bMulti = IsMultiValued(pAttrInfo);
      }
      else
      {
        bMulti = IsMultiValued(m_sAttr);
      }

            if (pAttrInfo != NULL)
            {
                if (bMulti)
                {
                    SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);

                    m_ValueList.ResetContent();

                    POSITION pos = sList.GetHeadPosition();
                    while (pos != NULL)
                    {
                        CString sValue = sList.GetNext(pos);
                        m_ValueList.AddString(sValue);
                    }
                }
                else
                {
                    SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);

          if (sList.GetCount() > 0)
          {
            m_ValueBox.SetWindowText(sList.GetHead());
          }
                    if (!m_pConnectData->IsGC())
                    {
                        SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
                    }
                }
            }
            else
            {
                GetAttrFailed();
                CStringList sTempList;
                m_pAttr = TouchAttr(pAttrInfo, bMulti);
                if (bMulti)
                {
                    SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
                }
                else
                {
                    SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
                }
                return;
            }
            m_pAttr = TouchAttr(pAttrInfo, bMulti);
        }   
    }

    CString sSyntax;
    GetSyntax(m_sAttr, sSyntax);
    m_SyntaxBox.SetWindowText(sSyntax);
}

void CAttrEditor::DisplayRootDSE()
{
    CString s = m_sPath;

    CComPtr<IADs> pADs;
    HRESULT hr, hCredResult;
    hr = OpenObjectWithCredentials(
                                             m_pConnectData, 
                                             m_pConnectData->GetCredentialObject()->UseCredentials(),
                                             s,
                                             IID_IADs, 
                                             (LPVOID*)&pADs,
                                             NULL,
                                             hCredResult
                                             );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return;
    }

    // This is to insure that the ADSI cache is current
    //
    hr = pADs->GetInfo();

    VARIANT var;
    hr = pADs->GetEx( CComBSTR(m_sAttr) , &var );
    if ( FAILED(hr) )
    {
        GetAttrFailed();
        m_pAttr = TouchAttr(m_sAttr);
        return;
    }

    /////////////////////////////////////////
    //  Convert and populate
    ///////////////////////////////////////////
    CStringList sList;
    hr = VariantToStringList( var, sList );
    if ( FAILED(hr) )
    {
        GetAttrFailed();
        VariantClear(&var);
        CStringList sTempList;
        m_pAttr = TouchAttr(m_sAttr);
        return;
    }
    VariantClear( &var );


    if ( IsRootDSEAttrMultiValued(m_sAttr) )
    {
        SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE);

        m_ValueList.ResetContent();

        POSITION pos = sList.GetHeadPosition();
        while (pos != NULL)
        {
            CString sValue = sList.GetNext(pos);
            m_ValueList.AddString(sValue);
        }
    }
    else
    {
        SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);

        s = sList.GetHead();
        m_ValueBox.SetWindowText(s);
    }

//  m_pAttr = TouchAttr(m_sAttr);

    CString sSyntax;
    GetSyntax(m_sAttr, sSyntax);
    m_SyntaxBox.SetWindowText(sSyntax);

    // REVEIW : this is the only occurrance of "UTCTime", if there
    //          becomes more we may need to make a global string or something
    //
    if (sSyntax == _T("UTCTime"))
    {
        CString sFormatted, sRemainder;
        CString sYear, sMonth, sDay, sHour, sMinute, sSecond;
        int iCount = 0;

        sYear = s.Left(4);
        iCount = s.GetLength();
        sRemainder = s.Right(iCount - 4);

        sMonth = sRemainder.Left(2);
        iCount = sRemainder.GetLength();
        sRemainder = sRemainder.Right(iCount - 2);

        sDay = sRemainder.Left(2);
        iCount = sRemainder.GetLength();
        sRemainder = sRemainder.Right(iCount - 2);

        sHour = sRemainder.Left(2);
        iCount = sRemainder.GetLength();
        sRemainder = sRemainder.Right(iCount - 2);

        sMinute = sRemainder.Left(2);
        iCount = sRemainder.GetLength();
        sRemainder = sRemainder.Right(iCount - 2);

        sSecond = sRemainder.Left(2);

        sFormatted = sMonth + _T("/") + sDay + _T("/") + sYear + _T(" ")
                                 + sHour + _T(":") + sMinute + _T(":") + sSecond;
        m_ValueBox.SetWindowText(sFormatted);
    }
}

// Pre: lpszAttr non-NULL and must be null terminated
BOOL CAttrEditor::IsRootDSEAttrMultiValued(LPCWSTR lpszAttr)
{
    int idx=0, iCount = 0;

    // NOTICE-2002/02/26-artm  This method only called from SetAttribute()
    // and is not a public function.  If it were public we would need to be
    // careful about a NULL lpszAttr and potentially a string that is not 
    // null terminated.
    iCount = wcslen(lpszAttr);

    while( g_ldapRootDSESyntax[idx].lpszAttr) 
    {
        // NOTICE-2002/02/26-artm  Comparison well bounded by length
        // of lpszAttr.
        if ( _wcsnicmp(g_ldapRootDSESyntax[idx].lpszAttr, lpszAttr, iCount) == 0)
        {
            return g_ldapRootDSESyntax[idx].bMulti;
        }
        idx++;
    }
    return FALSE;
}

// TODO : This is extremely ugly, redo it
//
void CAttrEditor::SetPropertyUI(DWORD dwFlags, BOOL bAnd, BOOL bReset)
{
    if (bReset)
    {
        m_dwMultiFlags = dwFlags;
    }

    if (bAnd)
    {
        m_dwMultiFlags &= dwFlags;
    }
    else
    {
        m_dwMultiFlags |= dwFlags;
    }

    if (m_dwMultiFlags & TN_FLAG_SHOW_MULTI)
    {
        m_AddButtonHelper.SetToggleState(TRUE);
        m_RemoveButtonHelper.SetToggleState(TRUE);
        m_ValueList.ShowWindow(SW_SHOW);
        m_ValueBox.ShowWindow(SW_HIDE);
    }
    else
    {
        m_AddButtonHelper.SetToggleState(FALSE);
        m_RemoveButtonHelper.SetToggleState(FALSE);
        m_ValueList.ShowWindow(SW_HIDE);
        m_ValueBox.ShowWindow(SW_SHOW);
    }

    if (m_dwMultiFlags & TN_FLAG_ENABLE_REMOVE)
    {
        m_RemoveButton.EnableWindow(TRUE);
    }
    else
    {
        m_RemoveButton.EnableWindow(FALSE);
    }

    if (m_dwMultiFlags & TN_FLAG_ENABLE_ADD)
    {
        m_AddButton.EnableWindow(TRUE);
    }
    else
    {
        m_AddButton.EnableWindow(FALSE);
    }

  if (m_bExisting && (m_pConnectData->IsGC() || m_pConnectData->IsRootDSE()))
  {
    m_AttrEditBox.EnableWindow(FALSE);
  }
  else
  {
    m_AttrEditBox.EnableWindow(TRUE);
  }
}


// Pre: lpszProp non-NULL and null terminated string
void CAttrEditor::GetSyntax(LPCWSTR lpszProp, CString& sSyntax)
{
    if (m_bExisting && m_pConnectData->IsRootDSE())
    {
        int idx=0;
        
        while( g_ldapRootDSESyntax[idx].lpszAttr )
        {
            // NOTICE-2002/02/26-artm  Use of wcscmp() is ok b/c this is
            // a protected function.  If it were public we would need to
            // worry about a NULL pointer and strings that weren't null
            // terminated.
            if ( wcscmp(lpszProp, g_ldapRootDSESyntax[idx].lpszAttr) == 0 )
            {
                sSyntax = g_ldapRootDSESyntax[idx].lpszSyntax;
                return;
            }
            idx++;
        }
    }
    else
    {
        CComPtr<IADsProperty> pProp;
        HRESULT hr, hCredResult;
        CString schema;
        m_pConnectData->GetAbstractSchemaPath(schema);
        schema = schema + lpszProp;

        hr = OpenObjectWithCredentials(
                                                                     m_pConnectData, 
                                                                     m_pConnectData->GetCredentialObject()->UseCredentials(),
                                                                     schema,
                                                                     IID_IADsProperty, 
                                                                     (LPVOID*) &pProp,
                                                                     NULL,
                                                                     hCredResult
                                                                     );

        if ( FAILED(hr) )
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            return;
        }
    

        ///////////////////////////////////////////////////
        // Create a new cached attribute and populate
        //////////////////////////////////////////////////

        BSTR bstr;

        hr = pProp->get_Syntax( &bstr );
        if ( SUCCEEDED(hr) )
        {
            sSyntax = bstr;
        }
        SysFreeString(bstr);
    }
}

BOOL CAttrEditor::IsMultiValued(ADS_ATTR_INFO* pAttrInfo)
{
  return (pAttrInfo->dwNumValues > 1) ? TRUE : FALSE;
}

BOOL CAttrEditor::IsMultiValued(LPCWSTR lpszProp)
{
    CString schema;
    BOOL bResult = FALSE;

    CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pTreeNode);
    if (pContNode == NULL)
    {
        CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(m_pTreeNode);
        ASSERT(pLeafNode != NULL);
        bResult = pLeafNode->BuildSchemaPath(schema);
    }
    else
    {
        bResult = pContNode->BuildSchemaPath(schema);
    }

    if (!bResult)
    {
        return FALSE;
    }

    CADSIQueryObject schemaSearch;

    // Initialize search object with path, username and password
    //
    HRESULT hr = schemaSearch.Init(schema, m_pConnectData->GetCredentialObject());
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return FALSE;
    }

    int cCols = 1;
  LPWSTR pszAttributes[] = {L"isSingleValued"};
    LPWSTR pszDesiredAttr = L"attributeSyntax";
    ADS_SEARCH_COLUMN ColumnData;
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return FALSE;
    }

    BOOL bMulti = FALSE;

  CString csFilter;
    csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s))", lpszProp);
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  if (SUCCEEDED(hr)) 
    {
    hr = schemaSearch.GetNextRow();
    if (SUCCEEDED(hr)) 
        {
            hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData);
            if (SUCCEEDED(hr))
            {
                TRACE(_T("\t\tisSingleValued: %d\n"), 
                     ColumnData.pADsValues->Boolean);
                bMulti = !ColumnData.pADsValues->Boolean;
            }
        }
    }
    return bMulti;
}

// NOTE : this is only called for the RootDSE or if we failed to get
//              values for the attribute.  An empty ADS_ATTR_INFO object is
//              created but should not be modified.  If values are to be changed
//              or set for this object a new ADS_ATTR_INFO should be created
//              with the desired block of memory allocated for the values
//
CADSIAttr* CAttrEditor::TouchAttr(LPCWSTR lpszAttr)
{
   // NOTICE-NTRAID#NTBUG9-556322-2002/02/26-artm  Need to validate lpszAttr before using.
   // This should never happen, but just in case . . .
   if (!lpszAttr)
   {
       ASSERT(false);
       return NULL;
   }

   POSITION pos = m_ptouchedAttr->FindProperty(lpszAttr);

   if (pos == NULL)
   {
      ADS_ATTR_INFO* pADsInfo = new ADS_ATTR_INFO;
      if (!pADsInfo)
      {
         return 0;
      }
      memset(pADsInfo, 0, sizeof(ADS_ATTR_INFO));

      int iLength = wcslen(lpszAttr);
      pADsInfo->pszAttrName = new WCHAR[iLength + 1];
      wcscpy(pADsInfo->pszAttrName, lpszAttr);

      CADSIQueryObject schemaSearch;

      BOOL bResult;
      CString schema;
      CADSIEditContainerNode* pContNode = m_pConnectData->GetConnectionNode();
      bResult = pContNode->BuildSchemaPath(schema);
      if (!bResult)
      {
         return NULL;
      }

      // Initialize search object with path, username and password
      //
      HRESULT hr = schemaSearch.Init(schema, m_pConnectData->GetCredentialObject());
      if (FAILED(hr))
      {
         ADSIEditErrorMessage(hr);
         return NULL;
      }

      int cCols = 3;
      LPWSTR pszAttributes[] = {L"lDAPDisplayName", L"attributeSyntax", L"isSingleValued"};
      LPWSTR pszDesiredAttr = _T("attributeSyntax");
      ADS_SEARCH_COLUMN ColumnData;
      hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
      if (FAILED(hr))
      {
         ADSIEditErrorMessage(hr);
         return NULL;
      }

      BOOL bMulti = FALSE;
      CString szSyntax;

      CString csFilter;
      csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s))", lpszAttr);
      schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
      schemaSearch.SetAttributeList (pszAttributes, cCols);
      hr = schemaSearch.DoQuery ();
      if (SUCCEEDED(hr)) 
      {
         hr = schemaSearch.GetNextRow();
         if (SUCCEEDED(hr)) 
         {
            hr = schemaSearch.GetColumn(pszDesiredAttr,
                                  &ColumnData);
            if (SUCCEEDED(hr))
            {
               TRACE(_T("\t\tattributeSyntax: %s\n"), 
                     ColumnData.pADsValues->CaseIgnoreString);

               ADSTYPE dwType;
               dwType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
               pADsInfo->dwADsType = dwType;
            }

            hr = schemaSearch.GetColumn(pszAttributes[2], &ColumnData);
            if (SUCCEEDED(hr))
            {
               TRACE(_T("\t\tisSingleValued: %d\n"), 
                     ColumnData.pADsValues->Boolean);
               pADsInfo->dwNumValues = 0;
               bMulti = !ColumnData.pADsValues->Boolean;
                }
            }
        }

        CADSIAttr* pAttr = new CADSIAttr(pADsInfo, bMulti, szSyntax, FALSE);
        m_ptouchedAttr->AddTail(pAttr);
        return pAttr;
    }

    return m_ptouchedAttr->GetAt(pos);
}

CADSIAttr* CAttrEditor::TouchAttr(ADS_ATTR_INFO* pADsInfo, BOOL bMulti)
{
    POSITION pos = m_ptouchedAttr->FindProperty(pADsInfo->pszAttrName);

    if (pos == NULL)
    {
        CADSIAttr* pAttr = new CADSIAttr(pADsInfo, bMulti, L"");
        m_ptouchedAttr->AddTail(pAttr);
        return pAttr;
    }

    return m_ptouchedAttr->GetAt(pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "common.h"
#include "attr.h"


///////////////////////////////////////////////////////////////////////////
// CADSIAttribute

CADSIAttribute::CADSIAttribute(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly)
{
    m_pAttrInfo = pInfo;
    m_bDirty = FALSE;
    m_bMulti = bMulti;
    m_bReadOnly = bReadOnly;
  m_bSet = FALSE;
  m_bMandatory = FALSE;
  m_szSyntax = pszSyntax;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}

CADSIAttribute::CADSIAttribute(PADS_ATTR_INFO pInfo)
{
  //
  // REVIEW_JEFFJON : these need to be updated with correct values
  //
    m_pAttrInfo = pInfo;
    m_bDirty = FALSE;
    m_bMulti = FALSE;
    m_bReadOnly = FALSE;
  m_bSet = FALSE;
  m_bMandatory = FALSE;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}

// NTRAID#NTBUG9-552796-2002/02/21-artm  Constant string parm written to in constructor.
// Probably need to change the signature to reflect how the parameter is used.
CADSIAttribute::CADSIAttribute(const CString& attributeName)
{
    m_pAttrInfo = new ADS_ATTR_INFO;
    memset(m_pAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    // Find the token in the attribute name that precedes the range of attributes.
    // If we find the token, we need to truncate the attribute name at that
    // point to omit the range.

    CString name;
    int position = attributeName.Find(L';');
    if (position > -1)
    {
       name = attributeName.Left(position);
    }
    else
    {
       name = attributeName;
    }

    _AllocString(name, &(m_pAttrInfo->pszAttrName) );

    m_bMulti = FALSE;
    m_bDirty = FALSE;
    m_bReadOnly = FALSE;
  m_bSet = FALSE;
  m_bMandatory = FALSE;
}

CADSIAttribute::CADSIAttribute(CADSIAttribute* pOldAttr)
{
    m_pAttrInfo = NULL;
    ADS_ATTR_INFO* pAttrInfo = pOldAttr->GetAttrInfo();

    // These copies are done separately because there are places
    // that I need to copy only the ADsAttrInfo and not the values
    //
    _CopyADsAttrInfo(pAttrInfo, &m_pAttrInfo);
    _CopyADsValues(pAttrInfo, m_pAttrInfo );

    m_bReadOnly = FALSE;
    m_bMulti = pOldAttr->m_bMulti;
    m_bDirty = pOldAttr->m_bDirty;
   m_szSyntax = pOldAttr->m_szSyntax;
}


CADSIAttribute::~CADSIAttribute() 
{
  if (!m_bReadOnly)
  {
      _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
  }
}


ADSVALUE* CADSIAttribute::GetADSVALUE(int idx)
{
    
    return &(m_pAttrInfo->pADsValues[idx]);
}

HRESULT CADSIAttribute::SetValues(PADSVALUE pADsValue, DWORD dwNumValues)
{
    HRESULT hr = S_OK;

    ADS_ATTR_INFO* pNewAttrInfo = NULL;
    if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
    {
        return E_FAIL;
    }

    pNewAttrInfo->dwNumValues = dwNumValues;
  pNewAttrInfo->pADsValues = pADsValue;

  if (pADsValue == NULL)
  {
    pNewAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
  }
  else
  {
    pNewAttrInfo->dwADsType = pADsValue->dwType;
  }

  //
    // Free the old one and swap in the new one
    //
  if (!m_bReadOnly)
  {
      _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
  }

    m_pAttrInfo = pNewAttrInfo;
    m_bReadOnly = FALSE;
    return hr;
}

// Pre: this function only called when server returns a range of the values
// for a multivalued attribute 
//
HRESULT CADSIAttribute::AppendValues(PADSVALUE pADsValue, DWORD dwNumValues)
{
    HRESULT hr = S_OK;

    ADS_ATTR_INFO* pNewAttrInfo = NULL;
    if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
    {
        return E_OUTOFMEMORY;
    }

   DWORD newValueCount = m_pAttrInfo->dwNumValues + dwNumValues;
   pNewAttrInfo->dwNumValues = newValueCount;
   if (newValueCount == 0)
   {
      pNewAttrInfo->pADsValues = 0;
      pNewAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
   }
   else
   {
      pNewAttrInfo->pADsValues = new ADSVALUE[newValueCount];

      if (pNewAttrInfo->pADsValues == NULL)
      {
         // NOTICE-NTRAID#NTBUG9-552904-2002/02/21-artm  Leaks memory from pNewAttrInfo.
         // Memory was allocated by _CopyADsAttrInfo(), never freed following
         // this path of execution.
         // Fixed by calling _FreeADsAttrInfo().
         CADSIAttribute::_FreeADsAttrInfo(pNewAttrInfo);
         return E_OUTOFMEMORY;
      }
      else
      {
         ZeroMemory(pNewAttrInfo->pADsValues, newValueCount * sizeof(ADSVALUE));

         pNewAttrInfo->dwADsType = pADsValue->dwType;

         // NTRAID#NTBUG9-720957-2002/10/15-artm  do deep copy of ADsValues

         // Copy in the old values

         ADSVALUE* oldValues = m_pAttrInfo->pADsValues;
         ADSVALUE* copiedValues = pNewAttrInfo->pADsValues;
         const DWORD numOldValues = m_pAttrInfo->dwNumValues;

         hr = S_OK;
         for (DWORD i = 0; i < numOldValues && SUCCEEDED(hr); ++i)
         {
            hr = _CloneADsValue(oldValues[i], copiedValues[i]);
         }

         if (FAILED(hr))
         {
            // Unable to copy old values to new attribute;
            // free new attribute and leave the old one intact.
            // Since new attribute was not allocated by ADSI, always
            // pass FALSE for read only flag.
            CADSIAttribute::_FreeADsAttrInfo(&pNewAttrInfo, FALSE);
            return hr;
         }

         oldValues = NULL;              // get rid of alias

         // Copy in the new values

         // Set copiedValues to point to the next open value after all the old values.
         copiedValues = copiedValues + numOldValues;
         hr = S_OK;
         for (DWORD i = 0; i < dwNumValues && SUCCEEDED(hr); ++i)
         {
            hr = _CloneADsValue(pADsValue[i], copiedValues[i]);
         }

         if (FAILED(hr))
         {
            // Unable to copy appended values to new attribute;
            // free new attribute and leave the old one intact.
            // Since new attribute was not allocated by ADSI, always
            // pass FALSE for read only flag.
            CADSIAttribute::_FreeADsAttrInfo(&pNewAttrInfo, FALSE);
            return hr;
         }

         copiedValues = NULL;           // get rid of alias

      }
   }

   //
   // Free the old one and swap in the new one
   //

   // NOTICE-2002/10/16-artm
   // 
   // N.B. - attributes marked 'read only' just mean that the attribute information
   // pointer was allocated by ADSI (and not us).  This means that when it is 
   // freed it needs to be done with FreeADsMem().  Equally important, the pointer
   // in the attribute is actually an alias to memory contained in an array of
   // information for all the returned attributes.  The "master" list pointer is 
   // stored by the property page UI (search for SaveOptionalValuesPointer() and
   // SaveMandatoryValuesPointer() ), and it is this pointer that owns the memory.
   // Freeing the alias stored in the attribute wrapper class gives you bad karma,
   // so don't do it.

   if (!m_bReadOnly)
   {
      CADSIAttribute::_FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
   }

   // NOTICE-NTRAID#NTBUG9-552904-2002/02/22-artm  Memory leak if attribute list is marked read only.
   // This looks like a leak since the pointer is reassigned without freeing the memory.
   // Perhaps the problem lies in updating a read only attribute...
   // 
   // UPDATE: see note above; this is not a leak

   m_pAttrInfo = pNewAttrInfo;

   // m_bReadOnly is used to mark the attribute as having been allocated either by ADSI or
   // by this tool . . . the method of memory allocation differs and needs to be kept track
   // of for when it needs to be freed.  Regardless of whether or not the attribute was
   // read only at the beginning of the call, it needs to be marked FALSE now since the
   // memory for pNewAttrInfo was allocatd by the tool.
   m_bReadOnly = FALSE;

   return hr;
}

HRESULT CADSIAttribute::SetValues(const CStringList& sValues)
{
    HRESULT hr = S_OK;

    ADS_ATTR_INFO* pNewAttrInfo = NULL;
    if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
    {
        return E_FAIL;
    }

    int iCount = sValues.GetCount();
    pNewAttrInfo->dwNumValues = iCount;

    if (!_AllocValues(&pNewAttrInfo->pADsValues, iCount))
    {
        return E_FAIL;
    }
    
    int idx = 0;
    POSITION pos = sValues.GetHeadPosition();
    while (pos != NULL)
    {
        CString s = sValues.GetNext(pos);

        ADSVALUE* pADsValue = &(pNewAttrInfo->pADsValues[idx]);
        ASSERT(pADsValue != NULL);

        hr = _SetADsFromString(
                                                    s,
                                                    pNewAttrInfo->dwADsType, 
                                                    pADsValue
                                                    );
        if (FAILED(hr))
        {
            _FreeADsAttrInfo(&pNewAttrInfo, FALSE);
            return hr;
        }
        idx++;
    }

    // Free the old one and swap in the new one
    //
    _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);

    m_pAttrInfo = pNewAttrInfo;
    m_bReadOnly = FALSE;
    return hr;
}

void CADSIAttribute::GetValues(CStringList& sValues, DWORD dwMaxCharCount)
{
    GetStringFromADs(m_pAttrInfo, sValues, dwMaxCharCount);
}

ADS_ATTR_INFO* CADSIAttribute::GetAttrInfo()
{
    return m_pAttrInfo; 
}

////////////////////////////////////////////////////////////////////////
// Public Helper Functions
///////////////////////////////////////////////////////////////////////
HRESULT CADSIAttribute::SetValuesInDS(CAttrList2* ptouchedAttr, IDirectoryObject* pDirObject)
{
    DWORD dwReturn;
    DWORD dwAttrCount = 0;
    ADS_ATTR_INFO* pAttrInfo;
    pAttrInfo = new ADS_ATTR_INFO[ptouchedAttr->GetCount()];

    CADSIAttribute* pCurrentAttr;
    POSITION pos = ptouchedAttr->GetHeadPosition();
    while(pos != NULL)
    {
        ptouchedAttr->GetNextDirty(pos, &pCurrentAttr);

        if (pCurrentAttr != NULL)
        {
            ADS_ATTR_INFO* pCurrentAttrInfo = pCurrentAttr->GetAttrInfo();
            ADS_ATTR_INFO* pNewAttrInfo = &pAttrInfo[dwAttrCount];

            if (!_CopyADsAttrInfo(pCurrentAttrInfo, pNewAttrInfo))
            {
                for (DWORD itr = 0; itr < dwAttrCount; itr++)
                {
                    _FreeADsAttrInfo(&pAttrInfo[itr]);
                }
                delete[] pAttrInfo;
        pAttrInfo = NULL;
                return E_FAIL;
            }

            if (!_CopyADsValues(pCurrentAttrInfo, pNewAttrInfo))
            {
                delete[] pAttrInfo;
        pAttrInfo = NULL;
                return E_FAIL;
            }

            if (pAttrInfo[dwAttrCount].dwNumValues == 0)
            {
                pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_CLEAR;
            }
            else
            {
                pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_UPDATE;
            }

            dwAttrCount++;
        }
    }

    // Commit the changes that have been made to the ADSI cache
    //
    HRESULT hr = pDirObject->SetObjectAttributes(pAttrInfo, dwAttrCount, &dwReturn);

    for (DWORD itr = 0; itr < dwAttrCount; itr++)
    {
        _FreeADsAttrInfo(&pAttrInfo[itr]);
    }
    delete[] pAttrInfo;
  pAttrInfo = NULL;

    return hr;
}


/////////////////////////////////////////////////////////////////////////
// Private Helper Functions
////////////////////////////////////////////////////////////////////////

// NOTICE-2002/02/25-artm  _SetADsFromString() w/in trust boundary
// Pre:  lpszValue != NULL && lpszValue is a zero terminated string
HRESULT CADSIAttribute::_SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue)
{
    HRESULT hr = E_FAIL;

  if ( adsType == ADSTYPE_INVALID )
    {
        return hr;
    }

    pADsValue->dwType = adsType;

    switch( adsType ) 
    {
        case ADSTYPE_DN_STRING :
            if (!_AllocString(lpszValue, &pADsValue->DNString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_CASE_EXACT_STRING :
            if (!_AllocString(lpszValue, &pADsValue->CaseExactString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_CASE_IGNORE_STRING :
            if (!_AllocString(lpszValue, &pADsValue->CaseIgnoreString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_PRINTABLE_STRING :
            if (!_AllocString(lpszValue, &pADsValue->PrintableString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_NUMERIC_STRING :
            if (!_AllocString(lpszValue, &pADsValue->NumericString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_OBJECT_CLASS    :
            if (!_AllocString(lpszValue, &pADsValue->ClassName))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_BOOLEAN :
            // FUTURE-2002/02/22-artm  Use constants for literal strings, and use
            // a function to determine their length.  Easier to maintain, read, and
            // less error prone.  If performance is a concern, calculate the lengths
            // once and assign to length constants.

            // NOTICE-2002/02/25-artm  lpszValue must be null terminated
            // This requirement is currently met by the functions that call
            // this helper.
            if (_wcsnicmp(lpszValue, L"TRUE", 4) == 0)
            {
                (DWORD)pADsValue->Boolean = TRUE;
            }
            else if (_wcsnicmp(lpszValue, L"FALSE", 5) == 0)
            {
                (DWORD)pADsValue->Boolean = FALSE;
            }
            else 
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_INTEGER :
            int value;
            // As long as lpszValue is a valid string (even empty string is okay),
            // swscanf will convert the number from a string to an int.
            value = swscanf(lpszValue, L"%ld", &pADsValue->Integer);
            if (value > 0)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;
  
        case ADSTYPE_OCTET_STRING : 
            {
                hr = HexStringToByteArray_0x(
                    lpszValue, 
                    &( pADsValue->OctetString.lpValue ), 
                    pADsValue->OctetString.dwLength);

                // Should never happen.
                ASSERT (hr != E_POINTER);
            }
            break;
  
        case ADSTYPE_LARGE_INTEGER :
            wtoli(lpszValue, pADsValue->LargeInteger);
            hr = S_OK;
            break;
  
        case ADSTYPE_UTC_TIME :
            int iNum;
            WORD n;

            // NOTICE-2002/02/25-artm  Validates that input string by
            // checking that all 6 time fields were filled in.  Relies
            // on input string being null terminated (okay as long as
            // function contract met).
            iNum = swscanf(lpszValue, L"%02d/%02d/%04d %02d:%02d:%02d", 
                                &n, 
                                &pADsValue->UTCTime.wDay, 
                                &pADsValue->UTCTime.wYear,
                                &pADsValue->UTCTime.wHour, 
                                &pADsValue->UTCTime.wMinute, 
                                &pADsValue->UTCTime.wSecond 
                              );
            pADsValue->UTCTime.wMonth = n;

            // This strange conversion is done so that the DayOfWeek will be set in 
            // the UTCTime.  By converting it to a filetime it ignores the dayofweek but
            // converting back fills it in.
            //
            FILETIME ft;
            SystemTimeToFileTime(&pADsValue->UTCTime, &ft);
            FileTimeToSystemTime(&ft, &pADsValue->UTCTime);

            if (iNum == 6)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;

        default :
            break;
    }

    return hr;
}

// Copies the old octet string to the new octet string.  Any memory allocated
// to the new octet string will be freed first (and will be freed even if the
// copy failed).
BOOL 
CADSIAttribute::_AllocOctetString(
   const ADS_OCTET_STRING& rOldOctetString, 
   ADS_OCTET_STRING& rNew)
{
    _FreeOctetString(rNew.lpValue);

    int iLength = rOldOctetString.dwLength;
    rNew.dwLength = iLength;
    rNew.lpValue = new BYTE[iLength];
    if (rNew.lpValue == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeOctetString() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.
        _FreeOctetString(rNew.lpValue);
        return FALSE;
    }
    memcpy(rNew.lpValue, rOldOctetString.lpValue, iLength);
    return TRUE;
}

void CADSIAttribute::_FreeOctetString(BYTE*& lpValue)
{
    if (lpValue != NULL)
    {
        // NOTICE-NTRAID#NTBUG9-554582-2002/02/25-artm  Memory leak b/c lpValue allocated with [].
        // Code should be delete [] lpValue.
        delete [] lpValue;
        lpValue = NULL;
    }
}


// NOTICE-2002/02/25-artm  lpsz must be a null terminated string
BOOL CADSIAttribute::_AllocString(LPCWSTR lpsz, LPWSTR* lppszNew)
{
    _FreeString(lppszNew);

    int iLength = wcslen(lpsz);
    *lppszNew = new WCHAR[iLength + 1];  // an extra for the NULL
    if (*lppszNew == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeString() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.

        _FreeString(lppszNew);
        return FALSE;
    }

    // This is a legitimate use of wcscpy() since the destination buffer
    // is sized large enought to hold the src and terminating null.  It
    // hinges on the fact that the source string is null terminated.
    wcscpy(*lppszNew, lpsz);

    return TRUE;
}
    
void CADSIAttribute::_FreeString(LPWSTR* lppsz)
{
    if (*lppsz != NULL)
    {
        // NOTICE-NTRAID#NTBUG9-554582-2002/02/25-artm  Memory leak b/c lppsz allocated with [].
        // Code should be delete [] lppsz.
        delete [] *lppsz;
    }
    *lppsz = NULL;
}

BOOL CADSIAttribute::_AllocValues(ADSVALUE** ppValues, DWORD dwLength)
{
    _FreeADsValues(ppValues, dwLength);

    *ppValues = new ADSVALUE[dwLength];
    if (*ppValues == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeADsValues() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.

        _FreeADsValues(ppValues, dwLength);
        return FALSE;
    }
    memset(*ppValues, 0, sizeof(ADSVALUE) * dwLength);
    return TRUE;
}

BOOL CADSIAttribute::_CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
   _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);

   pNewAttrInfo->dwNumValues = pOldAttrInfo->dwNumValues;
   if (!_AllocValues(&pNewAttrInfo->pADsValues, pOldAttrInfo->dwNumValues))
   {
      _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
      return FALSE;
   }

   HRESULT hr = S_OK;
   for (DWORD itr = 0; itr < pOldAttrInfo->dwNumValues && SUCCEEDED(hr); itr++)
   {
      hr = _CloneADsValue(pOldAttrInfo->pADsValues[itr], pNewAttrInfo->pADsValues[itr]);
   }

   if (FAILED(hr))
   {
      _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
      return FALSE;
   }

   return TRUE;
}

void CADSIAttribute::_FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength)
{
   if (NULL == ppADsValues)
   {
      // Caller is making a mistake.
      ASSERT(false);
      return;
   }

   ADSVALUE* values = *ppADsValues;

   if (NULL == values)
   {
      // Don't assert, legal to free a null pointer.   
      // Logically, this means there are no values set.
      return;
   }

   for (DWORD idx = 0; idx < dwLength; idx++)
   {
      _FreeADsValue(values[idx]);
   }

   delete [] values;

   *ppADsValues = NULL;
}


// The values are not copied here.  They must be copied after the ADS_ATTR_INFO
// is copied by using _CopyADsValues()
//
BOOL CADSIAttribute::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo)
{
    _FreeADsAttrInfo(ppNewAttrInfo, FALSE);

    *ppNewAttrInfo = new ADS_ATTR_INFO;
    if (*ppNewAttrInfo == NULL)
    {
        return FALSE;
    }
    memset(*ppNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &((*ppNewAttrInfo)->pszAttrName));
    if (!bReturn)
    {
        _FreeADsAttrInfo(ppNewAttrInfo, FALSE);
        return FALSE;
    }

    (*ppNewAttrInfo)->dwADsType = pAttrInfo->dwADsType;
    (*ppNewAttrInfo)->dwControlCode = pAttrInfo->dwControlCode;
    (*ppNewAttrInfo)->dwNumValues = pAttrInfo->dwNumValues;

    return TRUE;
}

BOOL CADSIAttribute::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
    memset(pNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &pNewAttrInfo->pszAttrName);
    if (!bReturn)
    {
        return FALSE;
    }

    pNewAttrInfo->dwADsType = pAttrInfo->dwADsType;
    pNewAttrInfo->dwControlCode = pAttrInfo->dwControlCode;
    pNewAttrInfo->dwNumValues = pAttrInfo->dwNumValues;

    return TRUE;
}

void CADSIAttribute::_FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly)
{
    if (*ppAttrInfo == NULL)
    {
        return;
    }

    if (!bReadOnly)
    {
        _FreeString(&(*ppAttrInfo)->pszAttrName);
        _FreeADsValues(&(*ppAttrInfo)->pADsValues, (*ppAttrInfo)->dwNumValues);
        delete *ppAttrInfo;
    }
    else
    {
        FreeADsMem(*ppAttrInfo);
    }
    *ppAttrInfo = NULL;
}

void CADSIAttribute::_FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo)
{
    if (pAttrInfo == NULL)
    {
        return;
    }

    _FreeString(&pAttrInfo->pszAttrName);
    _FreeADsValues(&pAttrInfo->pADsValues, pAttrInfo->dwNumValues);
}


//
// _CloneADsValue():
//
// Makes a deep copy of a single ADSVALUE (allocating memory as needed).
// These cloned values should be freed using _FreeADsValue().
// 
// Returns S_OK on success, S_FALSE if atribute type not supported,
// error code otherwise.
//
HRESULT
CADSIAttribute::_CloneADsValue(const ADSVALUE& original, ADSVALUE& clone)
{
   HRESULT hr = S_OK;

   // Make sure we are copying to a clean slate (wouldn't want a mutant clone).
   ::ZeroMemory(&clone, sizeof(clone));

   // Copy the type of the value.

   clone.dwType = original.dwType;

   // Copy the data in the value.

   switch (clone.dwType) 
   {
   case ADSTYPE_INVALID :
      // Might indicate a bug . . .
      ASSERT(false);
      // . . . but the copy was successful.
      hr = S_OK;
      break;

   case ADSTYPE_DN_STRING :
      if (! _AllocString(original.DNString, &(clone.DNString)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_CASE_EXACT_STRING :
      if (! _AllocString(original.CaseExactString, &(clone.CaseExactString)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;
      
   case ADSTYPE_CASE_IGNORE_STRING :
      if (! _AllocString(original.CaseIgnoreString, &(clone.CaseIgnoreString)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_PRINTABLE_STRING :
      if (! _AllocString(original.PrintableString, &(clone.PrintableString)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_NUMERIC_STRING :
      if (! _AllocString(original.NumericString, &(clone.NumericString)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_BOOLEAN :
      clone.Boolean = original.Boolean;
      break;

   case ADSTYPE_INTEGER :
      clone.Integer = original.Integer;
      break;

   case ADSTYPE_OCTET_STRING :
      if (! _AllocOctetString(original.OctetString, clone.OctetString) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_UTC_TIME :
      clone.UTCTime = original.UTCTime;
      break;

   case ADSTYPE_LARGE_INTEGER :
      clone.LargeInteger = original.LargeInteger;
      break;

   case ADSTYPE_OBJECT_CLASS :
      if (! _AllocString(original.ClassName, &(clone.ClassName)) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_PROV_SPECIFIC :
      if ( !_CloneProviderSpecificBlob(original.ProviderSpecific, clone.ProviderSpecific) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_CASEIGNORE_LIST :
   case ADSTYPE_OCTET_LIST :
   case ADSTYPE_PATH :
   case ADSTYPE_POSTALADDRESS :
   case ADSTYPE_TIMESTAMP :
   case ADSTYPE_BACKLINK :
   case ADSTYPE_TYPEDNAME :
   case ADSTYPE_HOLD :
   case ADSTYPE_NETADDRESS :
   case ADSTYPE_REPLICAPOINTER :
   case ADSTYPE_FAXNUMBER :
   case ADSTYPE_EMAIL :
      // NDS attributes not supported in ADSI Edit
      ASSERT(false);
      hr = S_FALSE;
      break;

   case ADSTYPE_NT_SECURITY_DESCRIPTOR :
      if (! _CloneNtSecurityDescriptor(original.SecurityDescriptor, clone.SecurityDescriptor) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_UNKNOWN :
      // Can't copy data that we don't know how to interpret.
      ASSERT(false);
      hr = S_FALSE;
      break;

   case ADSTYPE_DN_WITH_BINARY :
      if (! _CloneDNWithBinary(original.pDNWithBinary, clone.pDNWithBinary) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   case ADSTYPE_DN_WITH_STRING :
      if (! _CloneDNWithString(original.pDNWithString, clone.pDNWithString) )
      {
         hr = E_OUTOFMEMORY;
      }
      break;

   default :
      // Unexpected data type.
      ASSERT(false);
      hr = E_UNEXPECTED;
      break;
   }

   if (FAILED(hr))
   {
      _FreeADsValue(clone);
   }

   return hr;
}


void
CADSIAttribute::_FreeADsValue(ADSVALUE& value)
{

   switch(value.dwType) 
   {
   case ADSTYPE_DN_STRING :
      _FreeString( &(value.DNString) );
      break;

   case ADSTYPE_CASE_EXACT_STRING :
      _FreeString( &(value.CaseExactString) );
      break;
      
   case ADSTYPE_CASE_IGNORE_STRING :
      _FreeString( &(value.CaseIgnoreString) );
      break;

   case ADSTYPE_PRINTABLE_STRING :
      _FreeString( &(value.PrintableString) );
      break;

   case ADSTYPE_NUMERIC_STRING :
      _FreeString( &(value.NumericString) );
      break;

   case ADSTYPE_INVALID :
   case ADSTYPE_BOOLEAN :
   case ADSTYPE_INTEGER :
   case ADSTYPE_UTC_TIME :
   case ADSTYPE_LARGE_INTEGER :
      // Nothing to do, done.
      break;

   case ADSTYPE_OCTET_STRING :
      _FreeOctetString( value.OctetString.lpValue );
      break;

   case ADSTYPE_OBJECT_CLASS :
      _FreeString( &(value.ClassName) );
      break;

   case ADSTYPE_PROV_SPECIFIC :
      _FreeProviderSpecificBlob(value.ProviderSpecific);
      break;

   case ADSTYPE_CASEIGNORE_LIST :
   case ADSTYPE_OCTET_LIST :
   case ADSTYPE_PATH :
   case ADSTYPE_POSTALADDRESS :
   case ADSTYPE_TIMESTAMP :
   case ADSTYPE_BACKLINK :
   case ADSTYPE_TYPEDNAME :
   case ADSTYPE_HOLD :
   case ADSTYPE_NETADDRESS :
   case ADSTYPE_REPLICAPOINTER :
   case ADSTYPE_FAXNUMBER :
   case ADSTYPE_EMAIL :
      // NDS attributes not supported in ADSI Edit
      ASSERT(false);
      break;

   case ADSTYPE_NT_SECURITY_DESCRIPTOR :
      _FreeNtSecurityDescriptor(value.SecurityDescriptor);
      break;

   case ADSTYPE_UNKNOWN :
      // Can't free it if we don't know how to interpret it.
      ASSERT(false);
      break;

   case ADSTYPE_DN_WITH_BINARY :
      _FreeDNWithBinary(value.pDNWithBinary);
      break;

   case ADSTYPE_DN_WITH_STRING :
      _FreeDNWithString(value.pDNWithString);
      break;

   default :
      // Unexpected data type.
      ASSERT(false);
      break;
   }


   // Zero out the ADS value to make it obvious if it is accidentally
   // reused.

   ::ZeroMemory(&value, sizeof(value));

}




///////////////////////////////////////////////////////////////////////////
// CAttrList2

// NOTICE-2002/02/25-artm  lpszAttr needs to be null terminated
POSITION CAttrList2::FindProperty(LPCWSTR lpszAttr)
{
    CADSIAttribute* pAttr;
    
    for (POSITION p = GetHeadPosition(); p != NULL; GetNext(p))
    {
        // I use GetAt here because I don't want to advance the POSITION
        // because it is returned if they are equal
        //
        pAttr = GetAt(p);
        CString sName;
        pAttr->GetProperty(sName);

        // NOTICE-2002/02/25-artm  Both strings should be null terminated.
        // sName is already in a data structure, so it should be null terminated
        if (wcscmp(sName, lpszAttr) == 0)
        {
            break;
        }
    }
    return p;
}

BOOL CAttrList2::HasProperty(LPCWSTR lpszAttr)
{
    POSITION pos = FindProperty(lpszAttr);
    return pos != NULL;
}


// Searches through the cache for the attribute
// ppAttr will point to the CADSIAttribute if found, NULL if not
//
void CAttrList2::GetNextDirty(POSITION& pos, CADSIAttribute** ppAttr)
{
    *ppAttr = GetNext(pos);
    if (pos == NULL && !(*ppAttr)->IsDirty())
    {
        *ppAttr = NULL;
        return;
    }

    while (!(*ppAttr)->IsDirty() && pos != NULL)
    {
        *ppAttr = GetNext(pos);
        if (!(*ppAttr)->IsDirty() && pos == NULL)
        {
            *ppAttr = NULL;
            break;
        }
    }
}

BOOL CAttrList2::HasDirty()
{
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
        CADSIAttribute* pAttr = GetNext(pos);
        if (pAttr->IsDirty())
        {
            return TRUE;
        }
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
// Implementation of helper functions.

bool
CADSIAttribute::_CloneBlob(
   const BYTE* src,
   DWORD srcSize,
   BYTE*& dest,
   DWORD& destSize)
{
   bool success = true;

   ASSERT(dest == NULL);
   _FreeBlob(dest, destSize);

   destSize = srcSize;
   if (srcSize > 0 && src != NULL)
   {
      dest = new BYTE[destSize];
      if (NULL != dest)
      {
         memcpy(dest, src, srcSize * sizeof(BYTE));
      }
      else
      {
         destSize = 0;
         success = false;
      }
   }
   else
   {
      // Both better be true, else we were called incorrectly.
      ASSERT(srcSize == 0);
      ASSERT(src == NULL);
      dest = NULL;
      destSize = 0;
   }

   return success;
}

void
CADSIAttribute::_FreeBlob(BYTE*& blob, DWORD& blobSize)
{
   if (blob != NULL)
   {
      ASSERT(blobSize > 0);
      delete [] blob;
      blob = NULL;
   }

   blobSize = 0;
}



bool
CADSIAttribute::_CloneProviderSpecificBlob(
   const ADS_PROV_SPECIFIC& src, 
   ADS_PROV_SPECIFIC& dest)
{
   bool success = true;

   success = _CloneBlob(src.lpValue, src.dwLength, dest.lpValue, dest.dwLength);

   return success;
}

void
CADSIAttribute::_FreeProviderSpecificBlob(ADS_PROV_SPECIFIC& blob)
{
   _FreeBlob(blob.lpValue, blob.dwLength);
}


bool
CADSIAttribute::_CloneNtSecurityDescriptor(
   const ADS_NT_SECURITY_DESCRIPTOR& src,
   ADS_NT_SECURITY_DESCRIPTOR& dest)
{
   bool success = true;

   success = _CloneBlob(src.lpValue, src.dwLength, dest.lpValue, dest.dwLength);

   return success;
}


void
CADSIAttribute::_FreeNtSecurityDescriptor(ADS_NT_SECURITY_DESCRIPTOR& sd)
{
   _FreeBlob(sd.lpValue, sd.dwLength);
}

bool
CADSIAttribute::_CloneDNWithBinary(
   const PADS_DN_WITH_BINARY& src,
   PADS_DN_WITH_BINARY& dest)
{
   bool success = true;

   // Validate parameters.

   ASSERT(dest == NULL);

   if (src == NULL)
   {
      dest = NULL;
      return true;
   }

   dest = new ADS_DN_WITH_BINARY;
   if (!dest)
   {
      // out of memory
      return false;
   }

   ::ZeroMemory(dest, sizeof(ADS_DN_WITH_BINARY));

   // Copy the GUID.

   success = _CloneBlob(
      src->lpBinaryValue, 
      src->dwLength,
      dest->lpBinaryValue,
      dest->dwLength);

   // Copy the distinguished name if GUID copy succeeded.

   if (success)
   {
      success = _AllocString(src->pszDNString, &(dest->pszDNString) ) != FALSE;
   }

   // If any part of copying failed, make sure we aren't leaking any memory.

   if (!success)
   {
      _FreeDNWithBinary(dest);
   }

   return success;
}

void
CADSIAttribute::_FreeDNWithBinary(PADS_DN_WITH_BINARY& dn)
{
   _FreeBlob(dn->lpBinaryValue, dn->dwLength);
   _FreeString( &(dn->pszDNString) );
   dn = NULL;
}

bool
CADSIAttribute::_CloneDNWithString(
   const PADS_DN_WITH_STRING& src,
   PADS_DN_WITH_STRING& dest)
{
   bool success = true;

   // Validate parameters.

   ASSERT(dest == NULL);

   if (src == NULL)
   {
      dest = NULL;
      return true;
   }

   dest = new ADS_DN_WITH_STRING;
   if (!dest)
   {
      // out of memory
      return false;
   }

   ::ZeroMemory(dest, sizeof(ADS_DN_WITH_BINARY));

   // Copy the associated string.

   success = _AllocString(src->pszStringValue, &(dest->pszStringValue) ) != FALSE;

   // Copy the distinguished name if associated string copy succeeded.

   if (success)
   {
      success = _AllocString(src->pszDNString, &(dest->pszDNString) ) != FALSE;
   }

   // Don't leak memory if any part of copy failed.

   if (!success)
   {
      _FreeDNWithString(dest);
   }

   return success;
}

void
CADSIAttribute::_FreeDNWithString(PADS_DN_WITH_STRING& dn)
{
   _FreeString( &(dn->pszStringValue) );
   _FreeString( &(dn->pszDNString) );
   dn = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attribute.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "common.h"
#include "attredit.h"
#include "attribute.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

///////////////////////////////////////////////////////////////////////////
// CADSIAttr

CADSIAttr::CADSIAttr(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly)
{
    m_pAttrInfo = pInfo;
    m_bDirty = FALSE;
    m_bMulti = bMulti;
    m_bReadOnly = bReadOnly;
   m_szSyntax = pszSyntax;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}


// NTRAID#NTBUG9-552796-2002/02/21-artm  Constant string parm written to in constructor.
// Probably need to change the signature to reflect how the parameter is used.
CADSIAttr::CADSIAttr(LPCWSTR lpszAttr)
{
    m_pAttrInfo = new ADS_ATTR_INFO;
    memset(m_pAttrInfo, 0, sizeof(ADS_ATTR_INFO));

  PWSTR pwz = wcsrchr(lpszAttr, L';');
  if (pwz)
  {
      // FUTURE-2002/02/22-artm  This line of code does not appear to do anything.
      // Consider removing upon review.
    pwz; // move past the hyphen to the range end value.

    // FUTURE-2002/02/22-artm  Code is unnecessarily confusing.
    // The assert is checking that the temporary pointer is not pointing
    // to the zero termination character at the end.  On the other hand, the
    // code then proceeds to set that character to NULL!  I suspect that there
    // is no need to have the ASSERT(); if there is, then this code needs to be revisited.
    ASSERT(*pwz);
    *pwz=L'\0';
  }
    _AllocString(lpszAttr, &(m_pAttrInfo->pszAttrName));

    m_bMulti = FALSE;
    m_bDirty = FALSE;
    m_bReadOnly = FALSE;
}

CADSIAttr::CADSIAttr(CADSIAttr* pOldAttr)
{
    m_pAttrInfo = NULL;
    ADS_ATTR_INFO* pAttrInfo = pOldAttr->GetAttrInfo();

    // These copies are done separately because there are places
    // that I need to copy only the ADsAttrInfo and not the values
    //
    _CopyADsAttrInfo(pAttrInfo, &m_pAttrInfo);
    _CopyADsValues(pAttrInfo, m_pAttrInfo );

    m_bReadOnly = FALSE;
    m_bMulti = pOldAttr->m_bMulti;
    m_bDirty = pOldAttr->m_bDirty;
}


CADSIAttr::~CADSIAttr() 
{
    _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
}


ADSVALUE* CADSIAttr::GetADSVALUE(int idx)
{
    
    return &(m_pAttrInfo->pADsValues[idx]);
}


HRESULT CADSIAttr::SetValues(const CStringList& sValues)
{
    HRESULT hr = S_OK;

    ADS_ATTR_INFO* pNewAttrInfo = NULL;
    if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
    {
        return E_FAIL;
    }

    int iCount = sValues.GetCount();
    pNewAttrInfo->dwNumValues = iCount;

    if (!_AllocValues(&pNewAttrInfo->pADsValues, iCount))
    {
        return E_FAIL;
    }
    
    int idx = 0;
    POSITION pos = sValues.GetHeadPosition();
    while (pos != NULL)
    {
        CString s = sValues.GetNext(pos);

        ADSVALUE* pADsValue = &(pNewAttrInfo->pADsValues[idx]);
        ASSERT(pADsValue != NULL);

        hr = _SetADsFromString(
                                                    s,
                                                    pNewAttrInfo->dwADsType, 
                                                    pADsValue
                                                    );
        if (FAILED(hr))
        {
            _FreeADsAttrInfo(&pNewAttrInfo, FALSE);
            return hr;
        }
        idx++;
    }

    // Free the old one and swap in the new one
    //
    _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);

    m_pAttrInfo = pNewAttrInfo;
    m_bReadOnly = FALSE;
    return hr;
}

void CADSIAttr::GetValues(CStringList& sValues, DWORD dwMaxCharCount)
{
    GetStringFromADs(m_pAttrInfo, sValues, dwMaxCharCount);
}

ADS_ATTR_INFO* CADSIAttr::GetAttrInfo()
{
    return m_pAttrInfo; 
}

////////////////////////////////////////////////////////////////////////
// Public Helper Functions
///////////////////////////////////////////////////////////////////////
HRESULT CADSIAttr::SetValuesInDS(CAttrList* ptouchedAttr, IDirectoryObject* pDirObject)
{
    DWORD dwReturn;
    DWORD dwAttrCount = 0;
    ADS_ATTR_INFO* pAttrInfo;
    pAttrInfo = new ADS_ATTR_INFO[ptouchedAttr->GetCount()];

    CADSIAttr* pCurrentAttr;
    POSITION pos = ptouchedAttr->GetHeadPosition();
    while(pos != NULL)
    {
        ptouchedAttr->GetNextDirty(pos, &pCurrentAttr);

        if (pCurrentAttr != NULL)
        {
            ADS_ATTR_INFO* pCurrentAttrInfo = pCurrentAttr->GetAttrInfo();
            ADS_ATTR_INFO* pNewAttrInfo = &pAttrInfo[dwAttrCount];

            if (!_CopyADsAttrInfo(pCurrentAttrInfo, pNewAttrInfo))
            {
                for (int itr = 0; itr < dwAttrCount; itr++)
                {
                    _FreeADsAttrInfo(&pAttrInfo[itr]);
                }
                delete[] pAttrInfo;

                return E_FAIL;
            }

            if (!_CopyADsValues(pCurrentAttrInfo, pNewAttrInfo))
            {
                delete[] pAttrInfo;
                return E_FAIL;
            }

            if (pAttrInfo[dwAttrCount].dwNumValues == 0)
            {
                pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_CLEAR;
            }
            else
            {
                pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_UPDATE;
            }

            dwAttrCount++;
        }
    }

    // Commit the changes that have been made to the ADSI cache
    //
    HRESULT hr = pDirObject->SetObjectAttributes(pAttrInfo, dwAttrCount, &dwReturn);

    for (int itr = 0; itr < dwAttrCount; itr++)
    {
        _FreeADsAttrInfo(&pAttrInfo[itr]);
    }
    delete[] pAttrInfo;

    return hr;
}


/////////////////////////////////////////////////////////////////////////
// Private Helper Functions
////////////////////////////////////////////////////////////////////////

// NOTICE-2002/02/25-artm  _SetADsFromString() w/in trust boundary
// Pre:  lpszValue != NULL && lpszValue is a zero terminated string
HRESULT CADSIAttr::_SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue)
{
    HRESULT hr = E_FAIL;

  if ( adsType == ADSTYPE_INVALID )
    {
        return hr;
    }

    pADsValue->dwType = adsType;

    switch( adsType ) 
    {
        case ADSTYPE_DN_STRING :
            if (!_AllocString(lpszValue, &pADsValue->DNString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_CASE_EXACT_STRING :
            if (!_AllocString(lpszValue, &pADsValue->CaseExactString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_CASE_IGNORE_STRING :
            if (!_AllocString(lpszValue, &pADsValue->CaseIgnoreString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_PRINTABLE_STRING :
            if (!_AllocString(lpszValue, &pADsValue->PrintableString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;

        case ADSTYPE_NUMERIC_STRING :
            if (!_AllocString(lpszValue, &pADsValue->NumericString))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_OBJECT_CLASS    :
            if (!_AllocString(lpszValue, &pADsValue->ClassName))
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_BOOLEAN :
            // FUTURE-2002/02/22-artm  Use constants for literal strings, and use
            // a function to determine their length.  Easier to maintain, read, and
            // less error prone.  If performance is a concern, calculate the lengths
            // once and assign to length constants.

            // NOTICE-2002/02/25-artm  lpszValue must be null terminated
            // This requirement is currently met by the functions that call
            // this helper.
            if (_wcsnicmp(lpszValue, L"TRUE", 4) == 0)
            {
                (DWORD)pADsValue->Boolean = TRUE;
            }
            else if (_wcsnicmp(lpszValue, L"FALSE", 5) == 0)
            {
                (DWORD)pADsValue->Boolean = FALSE;
            }
            else 
            {
                return E_FAIL;
            }
            hr = S_OK;
            break;
  
        case ADSTYPE_INTEGER :
            int value;
            // As long as lpszValue is a valid string (even empty string is okay),
            // swscanf will convert the number from a string to an int.
            value = swscanf(lpszValue, L"%ld", &pADsValue->Integer);
            if (value > 0)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;
  
        case ADSTYPE_OCTET_STRING : 
            {
                hr = HexStringToByteArray_0x(
                    lpszValue, 
                    &( pADsValue->OctetString.lpValue ), 
                    pADsValue->OctetString.dwLength);

                // Should never happen.
                ASSERT (hr != E_POINTER);
            }
            break;
  
        case ADSTYPE_LARGE_INTEGER :
            wtoli(lpszValue, pADsValue->LargeInteger);
            hr = S_OK;
            break;
  
        case ADSTYPE_UTC_TIME :
            int iNum;
            WORD n;

            // NOTICE-2002/02/25-artm  Validates that input string by
            // checking that all 6 time fields were filled in.  Relies
            // on input string being null terminated (okay as long as
            // function contract met).
            iNum = swscanf(lpszValue, L"%02d/%02d/%04d %02d:%02d:%02d", 
                                &n, 
                                &pADsValue->UTCTime.wDay, 
                                &pADsValue->UTCTime.wYear,
                                &pADsValue->UTCTime.wHour, 
                                &pADsValue->UTCTime.wMinute, 
                                &pADsValue->UTCTime.wSecond 
                              );
            pADsValue->UTCTime.wMonth = n;

            // This strange conversion is done so that the DayOfWeek will be set in 
            // the UTCTime.  By converting it to a filetime it ignores the dayofweek but
            // converting back fills it in.
            //
            FILETIME ft;
            SystemTimeToFileTime(&pADsValue->UTCTime, &ft);
            FileTimeToSystemTime(&ft, &pADsValue->UTCTime);

            if (iNum == 6)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;

        default :
            break;
    }

    return hr;
}

// Copies the old octet string to the new octet string.  Any memory allocated
// to the new octet string will be freed first (and will be freed even if the
// copy failed).
BOOL CADSIAttr::_AllocOctetString(ADS_OCTET_STRING& rOldOctetString, 
                                                                    ADS_OCTET_STRING& rNew)
{
    _FreeOctetString(rNew.lpValue);

    int iLength = rOldOctetString.dwLength;
    rNew.dwLength = iLength;
    rNew.lpValue = new BYTE[iLength];
    if (rNew.lpValue == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeOctetString() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.
        _FreeOctetString(rNew.lpValue);
        return FALSE;
    }
    memcpy(rNew.lpValue, rOldOctetString.lpValue, iLength);
    return TRUE;
}

void CADSIAttr::_FreeOctetString(BYTE* lpValue)
{
    if (lpValue != NULL)
    {
        // NOTICE-NTRAID#NTBUG9-554582-2002/02/25-artm  Memory leak b/c lpValue allocated with [].
        // Code should be delete [] lpValue.
        delete [] lpValue;
        lpValue = NULL;
    }
}


// NOTICE-2002/02/25-artm  lpsz must be a null terminated string
BOOL CADSIAttr::_AllocString(LPCWSTR lpsz, LPWSTR* lppszNew)
{
    _FreeString(lppszNew);

    int iLength = wcslen(lpsz);
    *lppszNew = new WCHAR[iLength + 1];  // an extra for the NULL
    if (*lppszNew == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeString() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.

        _FreeString(lppszNew);
        return FALSE;
    }

    // This is a legitimate use of wcscpy() since the destination buffer
    // is sized large enought to hold the src and terminating null.  It
    // hinges on the fact that the source string is null terminated.
    wcscpy(*lppszNew, lpsz);

    return TRUE;
}
    
void CADSIAttr::_FreeString(LPWSTR* lppsz)
{
    if (*lppsz != NULL)
    {
        // NOTICE-NTRAID#NTBUG9-554582-2002/02/25-artm  Memory leak b/c lppsz allocated with [].
        // Code should be delete [] lppsz.
        delete [] *lppsz;
    }
    *lppsz = NULL;
}

BOOL CADSIAttr::_AllocValues(ADSVALUE** ppValues, DWORD dwLength)
{
    _FreeADsValues(ppValues, dwLength);

    *ppValues = new ADSVALUE[dwLength];
    if (*ppValues == NULL)
    {
        // FUTURE-2002/02/25-artm  Unnecessary function call.
        // Calling _FreeADsValues() does nothing here since
        // we can only get to this code branch if the allocation
        // failed.

        _FreeADsValues(ppValues, dwLength);
        return FALSE;
    }
    memset(*ppValues, 0, sizeof(ADSVALUE) * dwLength);
    return TRUE;
}

BOOL CADSIAttr::_CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);

    pNewAttrInfo->dwNumValues = pOldAttrInfo->dwNumValues;
    if (!_AllocValues(&pNewAttrInfo->pADsValues, pOldAttrInfo->dwNumValues))
    {
        _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
        return FALSE;
    }

    for (int itr = 0; itr < pOldAttrInfo->dwNumValues; itr++)
    {
        pNewAttrInfo->pADsValues[itr].dwType = pOldAttrInfo->pADsValues[itr].dwType;

        switch( pNewAttrInfo->pADsValues[itr].dwType ) 
        {
            case ADSTYPE_DN_STRING :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].DNString,
                                                    &pNewAttrInfo->pADsValues[itr].DNString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;

            case ADSTYPE_CASE_EXACT_STRING :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseExactString,
                                                    &pNewAttrInfo->pADsValues[itr].CaseExactString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;
                        
            case ADSTYPE_CASE_IGNORE_STRING :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseIgnoreString,
                                                    &pNewAttrInfo->pADsValues[itr].CaseIgnoreString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;

            case ADSTYPE_PRINTABLE_STRING :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].PrintableString,
                                                    &pNewAttrInfo->pADsValues[itr].PrintableString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;

            case ADSTYPE_NUMERIC_STRING :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].NumericString,
                                                    &pNewAttrInfo->pADsValues[itr].NumericString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;
  
            case ADSTYPE_OBJECT_CLASS    :
                if (!_AllocString(pOldAttrInfo->pADsValues[itr].ClassName,
                                                    &pNewAttrInfo->pADsValues[itr].ClassName))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;
  
            case ADSTYPE_BOOLEAN :
                pNewAttrInfo->pADsValues[itr].Boolean = pOldAttrInfo->pADsValues[itr].Boolean;
                break;
  
            case ADSTYPE_INTEGER :
                pNewAttrInfo->pADsValues[itr].Integer = pOldAttrInfo->pADsValues[itr].Integer;
                break;
  
            case ADSTYPE_OCTET_STRING :
                if (!_AllocOctetString(pOldAttrInfo->pADsValues[itr].OctetString,
                                                             pNewAttrInfo->pADsValues[itr].OctetString))
                {
                    _FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
                    return FALSE;
                }
            break;
  
            case ADSTYPE_LARGE_INTEGER :
                pNewAttrInfo->pADsValues[itr].LargeInteger = pOldAttrInfo->pADsValues[itr].LargeInteger;
                break;
  
            case ADSTYPE_UTC_TIME :
                pNewAttrInfo->pADsValues[itr].UTCTime = pOldAttrInfo->pADsValues[itr].UTCTime;
                break;

            default :
                break;
        }
    }
    return TRUE;
}

void CADSIAttr::_FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength)
{
    ADSVALUE* pADsValue = *ppADsValues;

    for (int idx = 0; idx < dwLength; idx++)
    {
        if (pADsValue != NULL)
        {
            switch( pADsValue->dwType ) 
            {
                case ADSTYPE_DN_STRING :
                    _FreeString(&pADsValue->DNString);
                    break;

                case ADSTYPE_CASE_EXACT_STRING :
                    _FreeString(&pADsValue->CaseExactString);
                    break;

                case ADSTYPE_CASE_IGNORE_STRING :
                    _FreeString(&pADsValue->CaseIgnoreString);
                    break;

                case ADSTYPE_PRINTABLE_STRING :
                    _FreeString(&pADsValue->PrintableString);
                    break;

                case ADSTYPE_NUMERIC_STRING :
                    _FreeString(&pADsValue->NumericString);
                    break;
  
                case ADSTYPE_OBJECT_CLASS :
                    _FreeString(&pADsValue->ClassName);
                    break;
  
                case ADSTYPE_OCTET_STRING :
                    _FreeOctetString(pADsValue->OctetString.lpValue);
                    break;
  
                default :
                    break;
            }
            pADsValue++;
        }
    }
    // May be NULL if there are no values set
    // WARNING! : make sure that you memset the memory after
    // creating an ADS_ATTR_INFO so that it will be NULL if there
    // are no values
    //
    if (*ppADsValues != NULL)
    {
        // NOTICE-NTRAID#NTBUG9-554582-2002/02/25-artm  Memory leak b/c *ppADsValues allocated with [].
        // Code should be delete [] *ppADsValues.
        delete [] *ppADsValues;
        *ppADsValues = NULL;
    }
}


// The values are not copied here.  They must be copied after the ADS_ATTR_INFO
// is copied by using _CopyADsValues()
//
BOOL CADSIAttr::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo)
{
    _FreeADsAttrInfo(ppNewAttrInfo, FALSE);

    *ppNewAttrInfo = new ADS_ATTR_INFO;
    if (*ppNewAttrInfo == NULL)
    {
        return FALSE;
    }
    memset(*ppNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &((*ppNewAttrInfo)->pszAttrName));
    if (!bReturn)
    {
        _FreeADsAttrInfo(ppNewAttrInfo, FALSE);
        return FALSE;
    }

    (*ppNewAttrInfo)->dwADsType = pAttrInfo->dwADsType;
    (*ppNewAttrInfo)->dwControlCode = pAttrInfo->dwControlCode;
    (*ppNewAttrInfo)->dwNumValues = pAttrInfo->dwNumValues;

    return TRUE;
}

BOOL CADSIAttr::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
    memset(pNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &pNewAttrInfo->pszAttrName);
    if (!bReturn)
    {
        return FALSE;
    }

    pNewAttrInfo->dwADsType = pAttrInfo->dwADsType;
    pNewAttrInfo->dwControlCode = pAttrInfo->dwControlCode;
    pNewAttrInfo->dwNumValues = pAttrInfo->dwNumValues;

    return TRUE;
}

void CADSIAttr::_FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly)
{
    if (*ppAttrInfo == NULL)
    {
        return;
    }

    if (!bReadOnly)
    {
        _FreeString(&(*ppAttrInfo)->pszAttrName);
        _FreeADsValues(&(*ppAttrInfo)->pADsValues, (*ppAttrInfo)->dwNumValues);
        delete *ppAttrInfo;
    }
    else
    {
        FreeADsMem(*ppAttrInfo);
    }
    *ppAttrInfo = NULL;
}

void CADSIAttr::_FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo)
{
    if (pAttrInfo == NULL)
    {
        return;
    }

    _FreeString(&pAttrInfo->pszAttrName);
    _FreeADsValues(&pAttrInfo->pADsValues, pAttrInfo->dwNumValues);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attrqry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "attrqry.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

	///////////////////////////////////////////////////////////////////////////////
CADSIQueryObject2::CADSIQueryObject2()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}

CADSIQueryObject2::~CADSIQueryObject2()
{
  if (m_SearchHandle) 
  {
    m_pObj->CloseSearchHandle (m_SearchHandle);
  }
  if (aSearchPref != NULL)
  {
    delete aSearchPref;
    aSearchPref = NULL;
  }
}


HRESULT CADSIQueryObject2::Init(IDirectorySearch * pObj)
{
  HRESULT hr = S_OK;
  
  m_pObj = pObj;
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CADSIQueryObject2::SetAttributeList (LPTSTR *pszAttribs, INT cAttrs)
{

  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

const int nSearchPrefs = 4;
HRESULT CADSIQueryObject2::SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount)
{
  HRESULT hr;
	int nNumPrefs = nSearchPrefs;
	if (nMaxObjectCount == 0)
	{
		nNumPrefs--;
	}
  aSearchPref = new ADS_SEARCHPREF_INFO[nNumPrefs];

  if (m_bInitialized) 
	{
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = scope;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    aSearchPref[1].vValue.dwType = ADSTYPE_BOOLEAN;
    aSearchPref[1].vValue.Boolean = TRUE;
    aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[2].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[2].vValue.Integer = QUERY_PAGESIZE;
		
		if (nMaxObjectCount > 0)
		{
			aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
			aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
			aSearchPref[3].vValue.Integer = nMaxObjectCount;
		}
		hr = m_pObj->SetSearchPreference (aSearchPref, nNumPrefs);
    delete aSearchPref;
    aSearchPref = NULL;
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}


const int NUM_PREFS=3;
HRESULT CADSIQueryObject2::DoQuery()
{
  HRESULT hr;
  if (m_bInitialized) 
	{
     hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                 m_pszAttribs,
                                 m_nAttrs,
                                 &m_SearchHandle);
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT CADSIQueryObject2::GetNextRow()
{
  if (m_bInitialized) 
	{
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT CADSIQueryObject2::GetColumn(LPWSTR Attribute, PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) 
	{
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attribute.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.h
//
//--------------------------------------------------------------------------

#ifndef _ATTRIBUTE_H
#define _ATTRIBUTE_H

#include "common.h"

///////////////////////////////////////////////////////////////////////
class CAttrList;

////////////////////////////////////////////////////////////////////////
// CADSIAttr

class CADSIAttr
{
public:
	// Constructors
	//
	CADSIAttr(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly = TRUE);
	CADSIAttr(LPCWSTR lpszAttr);
	CADSIAttr(CADSIAttr* pAttr);

	// Destructor
	//
	~CADSIAttr(); 

	// Data accessor functions
	//
	void GetProperty(CString& sProp) { sProp = m_pAttrInfo->pszAttrName; }
	DWORD GetNumValues() { return m_pAttrInfo->dwNumValues; }

	HRESULT SetValues(const CStringList& sValues); 
	void GetValues(CStringList& psValues, DWORD dwMaxCharCount = 1024);

	BOOL GetMultivalued() { return m_bMulti; }
	void SetMultivalued(BOOL bMulti) { m_bMulti = bMulti; }

	void SetDirty(const BOOL bDirty) { m_bDirty = bDirty; }
	BOOL IsDirty() { return m_bDirty; }

	ADSTYPE GetADsType() { return m_pAttrInfo->dwADsType; }
	void SetADsType(ADSTYPE dwType) { m_pAttrInfo->dwADsType = dwType; }

   CString GetSyntax() { return m_szSyntax; }
   void SetSyntax(PCWSTR pszSyntax) { m_szSyntax = pszSyntax; }

	ADS_ATTR_INFO* GetAttrInfo();
	ADSVALUE* GetADsValues() { return m_pAttrInfo->pADsValues; }

	static HRESULT SetValuesInDS(CAttrList* ptouchAttr, IDirectoryObject* pDirObject);

private:
	// Functions
	//
	ADSVALUE* GetADSVALUE(int idx);

	static BOOL _AllocOctetString(ADS_OCTET_STRING& rOldOctetString, ADS_OCTET_STRING& rNew);
	static void _FreeOctetString(BYTE* lpValue);
	static BOOL _AllocString(LPCWSTR lpsz, LPWSTR* lppszNew);
	static void _FreeString(LPWSTR* lppsz);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo);
	static BOOL _AllocValues(ADSVALUE** ppValues, DWORD dwLength);
	static BOOL _CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* ppNewAttrInfo);
	static void _FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength);

	static HRESULT _SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue);

	// Member data
	//
	ADS_ATTR_INFO* m_pAttrInfo;
	BOOL m_bDirty;
	BOOL m_bMulti;
	BOOL m_bReadOnly;
   CString m_szSyntax;
};

#endif //_ATTRIBUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attrqry.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIQUERY_H
#define _ADSIQUERY_H

#define QUERY_PAGESIZE 256

class CConnectionData;
class CCredentialObject;

////////////////////////////////////////////////////////////////////////
// CADSIQueryObject2

class CADSIQueryObject2
{
public:
  CADSIQueryObject2();
  ~CADSIQueryObject2();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
	{
    return m_pObj->FreeColumn(pColumnData);
  };

  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount = 0);
  HRESULT SetFilterString (LPWSTR pszFilter)
	{
    m_pwszFilter = pszFilter;
    return S_OK;
  }

  //Attributes
public:
  CComPtr<IDirectorySearch> m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR            m_pwszFilter;
  LPWSTR          * m_pszAttribs;
  ULONG             m_nAttrs;
  BOOL							m_bInitialized;

	ADS_SEARCHPREF_INFO* aSearchPref;
};
        
#endif //_ADSIQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\attrres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by attredit.rc
//
#define IDC_EDIT_BUTTON                 1072
#define IDS_PROJNAME                    5000
#define IDD_ATTRIBUTE_EDITOR_DIALOG     5001
#define IDS_NOTSET                      5001
#define IDC_MANDATORY_CHECK             5002
#define IDD_STRING_EDITOR_DIALOG        5002
#define IDS_NO_EDITOR                   5002
#define IDC_OPTIONAL_CHECK              5003
#define IDD_STRING_EDITOR_MULTI_DIALOG  5003
#define IDS_NO_ATTRIBUTE_INFO           5003
#define IDC_SET_CHECK                   5004
#define IDC_ATTRIBUTE_LIST              5006
#define IDC_VALUE_EDIT                  5008
#define IDC_STRING_VALUE_EDIT           5009
#define IDC_VALUE_LIST                  5010
#define IDC_CLEAR_BUTTON                5014
#define IDD_INT_EDITOR_DIALOG           5020
#define IDD_LARGEINT_EDITOR_DIALOG      5021
#define IDD_BOOLEAN_EDITOR_DIALOG       5022
#define IDD_TIME_EDITOR_DIALOG          5023
#define IDD_OCTET_STRING_EDITOR_DIALOG  5024
#define IDS_ATTR_COL_SYNTAX             5025
#define IDD_BOOLEAN_EDITOR_MULTI_DIALOG 5026
#define IDD_TIME_EDITOR_MULTI_DIALOG    5027
#define IDD_DN_WITH_STRING_EDITOR       5028
#define IDD_DN_WITH_STRING_EDITOR_DIALOG 5028
#define IDC_ATTRIBUTE_STATIC            6000
#define IDS_ATTR_COL_ATTRIBUTE          6000
#define IDS_ATTR_COL_SETNOTSET          6001
#define IDC_TRUE_RADIO                  6002
#define IDS_ATTR_COL_VALUE              6002
#define IDC_FALSE_RADIO                 6003
#define IDS_ATTR_SET                    6003
#define IDC_NOTSET_RADIO                6004
#define IDS_ATTR_NOTSET                 6004
#define IDC_DATE_PICKER                 6005
#define IDC_TIME_PICKER                 6006
#define IDC_EDIT2                       6008
#define IDC_VIEW_TYPE_COMBO             6010
#define IDS_HEXADECIMAL                 6050
#define IDS_DECIMAL                     6051
#define IDS_BINARY                      6052
#define IDS_WCHAR                       6053
#define IDS_CHAR                        6054
#define IDS_OCTAL                       6055
#define IDS_FAILED_INITIALIZE_EDITOR    6070
#define IDS_FAILED_GET_NEW_VALUE_EDITOR 6071
#define IDC_ATTR_EDIT_BUTTON            10015
#define IDC_ATTR_ADD_BUTTON             10016
#define IDC_ATTR_REMOVE_BUTTON          10017
#define IDC_PROCESS_EDIT                10018
#define IDD_OCTET_STRING_EDITOR_MULTI_DIALOG 10025
#define IDS_FORMAT_OCTAL_ERROR          11056
#define IDS_FORMAT_HEX_ERROR            11057
#define IDS_FORMAT_DECIMAL_ERROR        11058
#define IDS_MSG_FAIL_CREATE_TEMPFILE    11100
#define IDS_MSG_FAIL_LAUNCH_PROCESS     11101
#define IDS_MSG_FAIL_RETRIEVE_SAVED_DATA 11102
#define IDS_OCTET_DISPLAY_SIZE_EXCEEDED 11103
#define IDS_MSG_FAIL_LOAD_VALUES        11104
#define IDS_ATTREDIT_DUPLICATE_VALUE    11105
#define IDS_ATTREDITOR_CAPTION          11106
#define IDS_TRUE                        11107
#define IDS_FALSE                       11108
#define IDS_ERR_MUST_BE_NUMERIC         11109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5029
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         6013
#define _APS_NEXT_SYMED_VALUE           7000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\common.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       common.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "common.h"
#include "editor.h"
#include "connection.h"
#include "credui.h"
#include "attrres.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

////////////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszRootDSE;

////////////////////////////////////////////////////////////////////////////////////////

// FUTURE-2002/03/06-artm  Comment differences b/w 2 OpenObjecctWithCredentials().
// It also wouldn't hurt to have a comment explaining why there are two
// HRESULT's for these functions.

// NTRAID#NTBUG9-563093-2002/03/06-artm  Need to validate parms before using.
// All pointers are either dereferenced or passed to ADsI w/out checking for NULL.
HRESULT OpenObjectWithCredentials(
                                                                    CConnectionData* pConnectData,
                                                                    const BOOL bUseCredentials,
                                                                    LPCWSTR lpszPath, 
                                                                    const IID& iid,
                                                                    LPVOID* ppObject,
                                                                    HWND hWnd,
                                                                    HRESULT& hResult
                                                                    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

   HRESULT hr = S_OK;
    hResult = S_OK;

  CWaitCursor cursor;
    CWnd* pCWnd = CWnd::FromHandle(hWnd);

    CCredentialObject* pCredObject = pConnectData->GetCredentialObject();

    if (bUseCredentials)
    {

        CString sUserName;
        EncryptedString password;
        WCHAR* cleartext = NULL;
        UINT uiDialogResult = IDOK;
        // NOTICE-NTRAID#NTBUG9-563071-2002/04/17-artm  Should not store pwd on stack.
        // Rewrote to use encrypted string class, which handles the memory management
        // of the clear text copies.

        while (uiDialogResult != IDCANCEL)
        {
            pCredObject->GetUsername(sUserName);
            password = pCredObject->GetPassword();

            // This shouldn't happen, but let's be paranoid.
            ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

            cleartext = password.GetClearTextCopy();

            // If we are out of memory return error code.
            if (cleartext == NULL)
            {
                // We need to clean up copy of password before returning.
                password.DestroyClearTextCopy(cleartext);
                hr = E_OUTOFMEMORY;
                return hr;
            }

            hr = AdminToolsOpenObject(lpszPath, 
                                      sUserName, 
                                      cleartext,
                                      ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
                                      iid, 
                                      ppObject);


            // NOTICE-NTRAID#NTBUG9-553646-2002/04/17-artm  Replace with SecureZeroMemory().
            // FIXED: this is a non-issue when using encrypted strings 
            // (just be sure to call DestroyClearTextCopy() regardless of whether or not
            // the copy is null)

            // Clean up the clear text copy of password.
            password.DestroyClearTextCopy(cleartext);


            // If logon fails pop up the credentials dialog box
            //
            if (HRESULT_CODE(hr) == ERROR_LOGON_FAILURE ||
                HRESULT_CODE(hr) == ERROR_NOT_AUTHENTICATED ||
                HRESULT_CODE(hr) == ERROR_INVALID_PASSWORD ||
                HRESULT_CODE(hr) == ERROR_PASSWORD_EXPIRED ||
                HRESULT_CODE(hr) == ERROR_ACCOUNT_DISABLED ||
                HRESULT_CODE(hr) == ERROR_ACCOUNT_LOCKED_OUT ||
                hr == E_ADS_BAD_PATHNAME)
            {
                CString sConnectName;

                // GetConnectionNode() is NULL when the connection is first being
                // create, but since it is the connection node we can get the name
                // directly from the CConnectionData.
                //
                ASSERT(pConnectData != NULL);
                // FUTURE-2002/03/06-artm  This ASSERT() seems to be useless here.
                if (pConnectData->GetConnectionNode() == NULL)
                {
                    pConnectData->GetName(sConnectName);
                }
                else
                {
                    sConnectName = pConnectData->GetConnectionNode()->GetDisplayName();
                }

                // NTRAID#NTBUG9-546168-2002/02/26-artm  Do not use custom rolled credential dialog.
                // Use CredManager dialog instead.
                CCredentialDialog credDialog(pCredObject, sConnectName, pCWnd);
                uiDialogResult = credDialog.DoModal();
                cursor.Restore();

                if (uiDialogResult == IDCANCEL)
                {
                    hResult = E_FAIL;
                }
                else
                {
                    hResult = S_OK;
                }
            }
            else
            {
                break;
            }
        } // end while loop
    }
    else
    {
      hr = AdminToolsOpenObject(
              lpszPath, 
              NULL, 
              NULL, 
              ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
              iid, 
              ppObject);
  }
  return hr;
}


// NTRAID#NTBUG9-563093-2002/03/06-artm  Need to validate parms before using.
// All pointers are either dereferenced or passed to ADsI w/out checking for NULL.
HRESULT OpenObjectWithCredentials(
   CCredentialObject* pCredObject,
   LPCWSTR lpszPath, 
   const IID& iid,
   LPVOID* ppObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr;

    if (pCredObject->UseCredentials())
    {

        CString sUserName;
        EncryptedString password;
        WCHAR* cleartext = NULL;
        UINT uiDialogResult = IDOK;

        // NOTICE-NTRAID#NTBUG9-563071-2002/04/17-artm  Should not store pwd on stack.
        // Rewrote to use encrypted string which manages memory of clear text copies.

        pCredObject->GetUsername(sUserName);
        password = pCredObject->GetPassword();

        // This shouldn't happen, but let's be paranoid.
        ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

        cleartext = password.GetClearTextCopy();

        if (NULL != cleartext)
        {
            hr = AdminToolsOpenObject(lpszPath, 
                                      sUserName, 
                                      cleartext,
                                      ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
                                      iid, 
                                      ppObject);

        }
        else
        {
            // We ran out of memory!  Report the error.
            hr = E_OUTOFMEMORY;
        }

        // NOTICE-NTRAID#NTBUG9-553646-2002/04/17-artm  Replace with SecureZeroMemory().
        // FIXED: this is non-issue when using encrypted strings.  Just be sure to call
        // DestroyClearTextCopy() on all clear text copies.

        password.DestroyClearTextCopy(cleartext);
    }
    else
    {
        hr = AdminToolsOpenObject(lpszPath, 
                                  NULL, 
                                  NULL, 
                                  ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
                                  iid, 
                                  ppObject);
    }
    return hr;
}

HRESULT CALLBACK BindingCallbackFunction(LPCWSTR lpszPathName,
                                         DWORD  dwReserved,
                                         REFIID riid,
                                         void FAR * FAR * ppObject,
                                         LPARAM lParam)
{
  CCredentialObject* pCredObject = reinterpret_cast<CCredentialObject*>(lParam);
  if (pCredObject == NULL)
  {
    return E_FAIL;
  }

  HRESULT hr = OpenObjectWithCredentials(pCredObject,
                                                                           lpszPathName, 
                                                                           riid,
                                                                           ppObject);
  return hr;
}

HRESULT GetRootDSEObject(CConnectionData* pConnectData,
                         IADs** ppDirObject)
{
    // Get data from connection node
    //
    CString sRootDSE, sServer, sPort, sLDAP;
    pConnectData->GetDomainServer(sServer);
    pConnectData->GetLDAP(sLDAP);
    pConnectData->GetPort(sPort);

    if (sServer != _T(""))
    {
        sRootDSE = sLDAP + sServer;
        if (sPort != _T(""))
        {
            sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
        }
        else
        {
            sRootDSE = sRootDSE + _T("/");
        }
        sRootDSE = sRootDSE + g_lpszRootDSE;
    }
    else
    {
        sRootDSE = sLDAP + g_lpszRootDSE;
    }

    HRESULT hr, hCredResult;
    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             sRootDSE,
                                             IID_IADs, 
                                             (LPVOID*) ppDirObject,
                                             NULL,
                                             hCredResult
                                            );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return hr;
    }
  return hr;
}

HRESULT GetItemFromRootDSE(LPCWSTR lpszRootDSEItem, 
                                       CString& sItem, 
                                           CConnectionData* pConnectData)
{
    // Get data from connection node
    //
    CString sRootDSE, sServer, sPort, sLDAP;
    pConnectData->GetDomainServer(sServer);
    pConnectData->GetLDAP(sLDAP);
    pConnectData->GetPort(sPort);

    if (sServer != _T(""))
    {
        sRootDSE = sLDAP + sServer;
        if (sPort != _T(""))
        {
            sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
        }
        else
        {
            sRootDSE = sRootDSE + _T("/");
        }
        sRootDSE = sRootDSE + g_lpszRootDSE;
    }
    else
    {
        sRootDSE = sLDAP + g_lpszRootDSE;
    }

    CComPtr<IADs> pADs;
    HRESULT hr, hCredResult;

    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             sRootDSE,
                                             IID_IADs, 
                                             (LPVOID*) &pADs,
                                             NULL,
                                             hCredResult
                                            );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return hr;
    }
    VARIANT var;
    VariantInit(&var);
    hr = pADs->Get( CComBSTR(lpszRootDSEItem), &var );
    if ( FAILED(hr) )
    {
        VariantClear(&var);
        return hr;
    }

    BSTR bstrItem = V_BSTR(&var);
    sItem = bstrItem;
    VariantClear(&var);

    return S_OK;
}


HRESULT  VariantToStringList(  VARIANT& refvar, CStringList& refstringlist)
{
    HRESULT hr = S_OK;
    long start, end;

  if ( !(V_VT(&refvar) &  VT_ARRAY)  )
    {
                
        if ( V_VT(&refvar) != VT_BSTR )
        {
            
            hr = VariantChangeType( &refvar, &refvar,0, VT_BSTR );

            if( FAILED(hr) )
            {
                return hr;
            }

        }

        refstringlist.AddHead( V_BSTR(&refvar) );
        return hr;
    }

    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );
        if( FAILED(hr) )
                return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
        if( FAILED(hr) )
                return hr;

    VARIANT SingleResult;
    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( long idx = start; idx <= end; idx++   ) 
    {

        hr = SafeArrayGetElement( saAttributes, &idx, &SingleResult );
        if( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&SingleResult) != VT_BSTR )
        {
            if ( V_VT(&SingleResult) == VT_NULL )
            {
                V_VT(&SingleResult ) = VT_BSTR;
                V_BSTR(&SingleResult ) = SysAllocString(L"0");
            }
            else
            {
                hr = VariantChangeType( &SingleResult, &SingleResult,0, VT_BSTR );

                if( FAILED(hr) )
                {
                    return hr;
                }
            }
        }


        //if ( V_VT(&SingleResult) != VT_BSTR )
         //               return E_UNEXPECTED;

         refstringlist.AddHead( V_BSTR(&SingleResult) );
        VariantClear( &SingleResult );
    }

    return S_OK;
} // VariantToStringList()

/////////////////////////////////////////////////////////////////////
HRESULT StringListToVariant( VARIANT& refvar, const CStringList& refstringlist)
{
    HRESULT hr = S_OK;
    int cCount = refstringlist.GetCount();

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cCount;

    SAFEARRAY* psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (NULL == psa)
        return E_OUTOFMEMORY;

    VariantClear( &refvar );
    V_VT(&refvar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(&refvar) = psa;

    VARIANT SingleResult;
    VariantInit( &SingleResult );
    V_VT(&SingleResult) = VT_BSTR;
    POSITION pos = refstringlist.GetHeadPosition();
    long i;
    for (i = 0; i < cCount, pos != NULL; i++)
    {
        V_BSTR(&SingleResult) = T2BSTR((LPCTSTR)refstringlist.GetNext(pos));
        hr = SafeArrayPutElement(psa, &i, &SingleResult);
        if( FAILED(hr) )
            return hr;
    }
    if (i != cCount || pos != NULL)
        return E_UNEXPECTED;

    return hr;
} // StringListToVariant()

///////////////////////////////////////////////////////////////////////////////////////

BOOL GetErrorMessage(HRESULT hr, CString& szErrorString, BOOL bTryADsIErrors)
{
  HRESULT hrGetLast = S_OK;
  DWORD status;
  PTSTR ptzSysMsg = NULL;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && bTryADsIErrors) 
  {
      // FUTURE-2002/02/27-artm  Replace magic '256' w/ named constant.
      // Better maintenance and readability.
    WCHAR Buf1[256], Buf2[256];
    hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
          status, Buf1, Buf2);
    if ((status != ERROR_INVALID_DATA) && (status != 0)) 
    {
      hr = status;
    }
  }

  // try the system first
  // NOTICE-2002/02/27-artm  FormatMessage() not dangerous b/c uses FORMAT_MESSAGE_ALLOCATE_BUFFER.
  int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)&ptzSysMsg, 0, NULL);

  if (nChars == 0) 
  { 
    //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
      g_adsMod = GetModuleHandle (L"activeds.dll");

    // NOTICE-2002/02/27-artm  FormatMessage() not dangerous b/c uses FORMAT_MESSAGE_ALLOCATE_BUFFER.
    nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE, g_adsMod, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
  }

  if (nChars > 0)
  {
    szErrorString = ptzSysMsg;
    ::LocalFree(ptzSysMsg);
  }
    else
    {
        szErrorString.Format(L"Error code: X%x", hr);
    }

  return (nChars > 0);
}

////////////////////////////////////////////////////////////////////////////////////
typedef struct tagSYNTAXMAP
{
    LPCWSTR     lpszAttr;
    VARTYPE     type;
    
} SYNTAXMAP;

SYNTAXMAP ldapSyntax[] = 
{
    _T("DN"), VT_BSTR,
    _T("DIRECTORYSTRING"), VT_BSTR,
    _T("IA5STRING"), VT_BSTR,
    _T("CASEIGNORESTRING"), VT_BSTR,
    _T("PRINTABLESTRING"), VT_BSTR,
    _T("NUMERICSTRING"), VT_BSTR,
    _T("UTCTIME"), VT_DATE,
    _T("ORNAME"), VT_BSTR,
    _T("OCTETSTRING"), VT_BSTR,
    _T("BOOLEAN"), VT_BOOL,
    _T("INTEGER"), VT_I4,
    _T("OID"), VT_BSTR,
    _T("INTEGER8"), VT_I8,
    _T("OBJECTSECURITYDESCRIPTOR"), VT_BSTR,
    NULL,     0,
};
#define MAX_ATTR_STRING_LENGTH 30

VARTYPE VariantTypeFromSyntax(LPCWSTR lpszProp )
{
    int idx=0;

    while( ldapSyntax[idx].lpszAttr )
    {
        if ( _wcsnicmp(lpszProp, ldapSyntax[idx].lpszAttr, MAX_ATTR_STRING_LENGTH) )
        {
            return ldapSyntax[idx].type;
        }
        idx++;
    }

    // NOTICE-2002/02/27-artm  If the syntax specified in lpszProp does
    // not match any of the expected values, stop execution in debug build (probably a bug).
    // In a release build, return string type since there is no conversion
    // involved in displaying a string.
    ASSERT(FALSE);
    return VT_BSTR;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function : GetStringFromADsValue
//
//  Formats an ADSVALUE struct into a string 
//
///////////////////////////////////////////////////////////////////////////////////////////////////
void GetStringFromADsValue(const PADSVALUE pADsValue, CString& szValue, DWORD dwMaxCharCount)
{
  szValue.Empty();

  if (!pADsValue)
  {
    ASSERT(pADsValue);
    return;
  }

  CString sTemp;
    switch( pADsValue->dwType ) 
    {
        case ADSTYPE_DN_STRING         :
            sTemp.Format(L"%s", pADsValue->DNString);
            break;

        case ADSTYPE_CASE_EXACT_STRING :
            sTemp.Format(L"%s", pADsValue->CaseExactString);
            break;

        case ADSTYPE_CASE_IGNORE_STRING:
            sTemp.Format(L"%s", pADsValue->CaseIgnoreString);
            break;

        case ADSTYPE_PRINTABLE_STRING  :
            sTemp.Format(L"%s", pADsValue->PrintableString);
            break;

        case ADSTYPE_NUMERIC_STRING    :
            sTemp.Format(L"%s", pADsValue->NumericString);
            break;
  
        case ADSTYPE_OBJECT_CLASS    :
            sTemp.Format(L"%s", pADsValue->ClassName);
            break;
  
        case ADSTYPE_BOOLEAN :
            sTemp.Format(L"%s", ((DWORD)pADsValue->Boolean) ? L"TRUE" : L"FALSE");
            break;
  
        case ADSTYPE_INTEGER           :
            sTemp.Format(L"%d", (DWORD) pADsValue->Integer);
            break;
  
        case ADSTYPE_OCTET_STRING      :
            {
                CString sOctet;
        
                BYTE  b;
                for ( DWORD idx=0; idx<pADsValue->OctetString.dwLength; idx++) 
                {
                    b = ((BYTE *)pADsValue->OctetString.lpValue)[idx];
                    sOctet.Format(L"0x%02x ", b);
                    sTemp += sOctet;

          if (dwMaxCharCount != 0 && sTemp.GetLength() > dwMaxCharCount)
          {
            break;
          }
                }
            }
            break;
  
        case ADSTYPE_LARGE_INTEGER :
            litow(pADsValue->LargeInteger, sTemp);
            break;
  
      case ADSTYPE_UTC_TIME :
         sTemp = GetStringValueFromSystemTime(&pADsValue->UTCTime);
            break;

        case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
            {
        }
            break;

        default :
            break;
    }

  szValue = sTemp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function : GetStringFromADs
//
//  Formats an ADS_ATTR_INFO structs values into strings and APPENDS them to a CStringList that is
//  passed in as a parameter.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
void GetStringFromADs(const ADS_ATTR_INFO* pInfo, CStringList& sList, DWORD dwMaxCharCount)
{
    CString sTemp;

    if ( pInfo == NULL )
    {
        return;
    }

    ADSVALUE *pValues = pInfo->pADsValues;

    for (DWORD x=0; x < pInfo->dwNumValues; x++) 
    {
    if ( pInfo->dwADsType == ADSTYPE_INVALID )
        {
            continue;
        }

        sTemp.Empty();

    GetStringFromADsValue(pValues, sTemp, dwMaxCharCount);
            
        pValues++;
        sList.AddTail( sTemp );
    }
}


//////////////////////////////////////////////////////////////////////
typedef struct tagSYNTAXTOADSMAP
{
    LPCWSTR     lpszAttr;
    ADSTYPE     type;
   UINT        nSyntaxResID;
    
} SYNTAXTOADSMAP;

SYNTAXTOADSMAP adsType[] = 
{
    L"2.5.5.0",     ADSTYPE_INVALID,                 IDS_SYNTAX_UNKNOWN,                
    L"2.5.5.1",     ADSTYPE_DN_STRING,               IDS_SYNTAX_DN,         
    L"2.5.5.2",     ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_OID,                          
    L"2.5.5.3",     ADSTYPE_CASE_EXACT_STRING,       IDS_SYNTAX_DNSTRING,                   
    L"2.5.5.4",     ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_NOCASE_STR,                     
    L"2.5.5.5",     ADSTYPE_PRINTABLE_STRING,        IDS_SYNTAX_I5_STR,                        
    L"2.5.5.6",     ADSTYPE_NUMERIC_STRING,          IDS_SYNTAX_NUMSTR,                              
    L"2.5.5.7",     ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_DN_BINARY,                         
    L"2.5.5.8",     ADSTYPE_BOOLEAN,                 IDS_SYNTAX_BOOLEAN,                            
    L"2.5.5.9",     ADSTYPE_INTEGER,                 IDS_SYNTAX_INTEGER,                         
    L"2.5.5.10",    ADSTYPE_OCTET_STRING,            IDS_SYNTAX_OCTET,                        
    L"2.5.5.11",    ADSTYPE_UTC_TIME,                IDS_SYNTAX_UTC,                      
    L"2.5.5.12",    ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_UNICODE,                                
    L"2.5.5.13",    ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_ADDRESS,                             
    L"2.5.5.14",    ADSTYPE_INVALID,                 IDS_SYNTAX_DNSTRING,                                         
    L"2.5.5.15",    ADSTYPE_NT_SECURITY_DESCRIPTOR,  IDS_SYNTAX_SEC_DESC,                                  
    L"2.5.5.16",    ADSTYPE_LARGE_INTEGER,           IDS_SYNTAX_LINT,                                
    L"2.5.5.17",    ADSTYPE_OCTET_STRING,            IDS_SYNTAX_SID,                            
    NULL,           ADSTYPE_INVALID,                 IDS_SYNTAX_UNKNOWN                           
};   


// This length should be set to be the longest number of characters
// in the adsType table.  It should include the space for the terminating
// null.
const unsigned int MAX_ADS_TYPE_STRLEN = 9;

ADSTYPE GetADsTypeFromString(LPCWSTR lps, CString& szSyntaxName)
{
    int idx=0;
    BOOL loaded = 0;
    
    // NOTICE-NTRAID#NTBUG9-559260-2002/02/28-artm  Should validate input string.
    // 1) Check that lps != NULL.
    // 2) Instead of wcscmp() use wcsncmp() since the maximum length of
    // valid strings is known (see adsType[] declared above).

    while( adsType[idx].lpszAttr && lps != NULL )
    {
        if ( wcsncmp(lps, adsType[idx].lpszAttr, MAX_ADS_TYPE_STRLEN) == 0 )
        {
            loaded = szSyntaxName.LoadString(adsType[idx].nSyntaxResID);
            ASSERT(loaded != FALSE);
            return adsType[idx].type;
        }
        idx++;
    }
    return ADSTYPE_INVALID;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function : GetStringValueFromSystemTime
//
//  Builds a locale/timezone specific display string from a SYSTEMTIME structure
//
///////////////////////////////////////////////////////////////////////////////////////////////////
CString GetStringValueFromSystemTime(const SYSTEMTIME* pTime)
{
  CString szResult;

  do
  {

     if (!pTime)
     {
        break;
     }

     // Format the string with respect to locale
     PWSTR pwszDate = NULL;
     int cchDate = 0;
     cchDate = GetDateFormat(LOCALE_USER_DEFAULT, 
                             0, 
                             const_cast<SYSTEMTIME*>(pTime), 
                             NULL, 
                             pwszDate, 
                             0);
     pwszDate = new WCHAR[cchDate];
     if (pwszDate == NULL)
     {
       break;
     }

     ZeroMemory(pwszDate, cchDate * sizeof(WCHAR));

     if (GetDateFormat(LOCALE_USER_DEFAULT, 
                       0, 
                       const_cast<SYSTEMTIME*>(pTime), 
                       NULL, 
                       pwszDate, 
                       cchDate))
     {
        szResult = pwszDate;
     }
     else
     {
       szResult = L"";
     }
     delete[] pwszDate;

     PWSTR pwszTime = NULL;

     cchDate = GetTimeFormat(LOCALE_USER_DEFAULT, 
                             0, 
                             const_cast<SYSTEMTIME*>(pTime), 
                             NULL, 
                             pwszTime, 
                             0);
     pwszTime = new WCHAR[cchDate];
     if (!pwszTime)
     {
        break;
     }

     ZeroMemory(pwszTime, cchDate * sizeof(WCHAR));

     if (GetTimeFormat(LOCALE_USER_DEFAULT, 
                       0, 
                       const_cast<SYSTEMTIME*>(pTime), 
                       NULL, 
                       pwszTime, 
                       cchDate))
     {
       szResult += _T(" ") + CString(pwszTime);
     }

     delete[] pwszTime;
  } while (false);

  return szResult;
}

////////////////////////////////////////////////////////////////
// Type conversions for LARGE_INTEGERs

void wtoli(LPCWSTR p, LARGE_INTEGER& liOut)
{
    liOut.QuadPart = 0;
    BOOL bNeg = FALSE;
    if (*p == L'-')
    {
        bNeg = TRUE;
        p++;
    }
    while (*p != L'\0')
    {
        liOut.QuadPart = 10 * liOut.QuadPart + (*p-L'0');
        p++;
    }
    if (bNeg)
    {
        liOut.QuadPart *= -1;
    }
}

void litow(LARGE_INTEGER& li, CString& sResult)
{
    LARGE_INTEGER n;
    n.QuadPart = li.QuadPart;

    if (n.QuadPart == 0)
    {
        sResult = L"0";
    }
    else
    {
        CString sNeg;
        sResult = L"";
        if (n.QuadPart < 0)
        {
            sNeg = CString(L'-');
            n.QuadPart *= -1;
        }
        while (n.QuadPart > 0)
        {
            sResult += CString(L'0' + (n.QuadPart % 10));
            n.QuadPart = n.QuadPart / 10;
        }
        sResult = sResult + sNeg;
    }
    sResult.MakeReverse();
}

void ultow(ULONG ul, CString& sResult)
{
    ULONG n;
    n = ul;

    if (n == 0)
    {
        sResult = L"0";
    }
    else
    {
        sResult = L"";
        while (n > 0)
        {
            sResult += CString(L'0' + (n % 10));
            n = n / 10;
        }
    }
    sResult.MakeReverse();
}



/////////////////////////////////////////////////////////////////////
// IO to/from Streams

HRESULT SaveStringToStream(IStream* pStm, const CString& sString)
{
    HRESULT err = S_OK;
    ULONG cbWrite;
    ULONG nLen;

    if (pStm == NULL)
    {
        return E_POINTER;
    }

    // sString cannot be null since it is passed as a reference
    nLen = sString.GetLength() + 1; // Include the NULL in length.

    // Write the length of the string to the stream.
    err = pStm->Write((void*)&nLen, sizeof(UINT), &cbWrite);
    if (FAILED(err))
    {
        ASSERT(false);
        return err;
    }
    ASSERT(cbWrite == sizeof(UINT));

    // Write the contents of the string to the stream.
    err = pStm->Write(
        (void*)static_cast<LPCWSTR>(sString),
        sizeof(WCHAR) * nLen,
        &cbWrite);

    if (SUCCEEDED(err))
    {
        ASSERT(cbWrite == sizeof(WCHAR) * nLen);
    }

    return err;
}

HRESULT SaveStringListToStream(IStream* pStm, CStringList& sList)
{
    HRESULT err = S_OK;
    // for each string in the list, write # of chars+NULL, and then the string
    ULONG cbWrite;
    ULONG nLen;
    UINT nCount;

    // write # of strings in list 
    nCount = (UINT)sList.GetCount();
    err = pStm->Write((void*)&nCount, sizeof(UINT), &cbWrite);

    // NOTICE-NTRAID#NTBUG9-559560-2002/02/28-artm  If unable to write # of strings, return an error code.
    // What is the point in returning S_OK if the first write to stream failed?
    // Worse, don't need to try to write any of the strings to the stream...

    if (FAILED(err))
    {
        ASSERT(false);
        return err;
    }
    ASSERT(cbWrite == sizeof(UINT));

    // Write the list of strings to the stream.
    CString s;
    POSITION pos = sList.GetHeadPosition();
    while ( SUCCEEDED(err) && pos != NULL )
    {
        s = sList.GetNext(pos);
        err = SaveStringToStream(pStm, s);
    }

    ASSERT( SUCCEEDED(err) );

    return err;
}

HRESULT LoadStringFromStream(IStream* pStm, CString& sString)
{
    HRESULT err = S_OK;
    ULONG nLen; // WCHAR counting NULL
    ULONG cbRead;

    if (pStm == NULL)
    {
        return E_POINTER;
    }

    // NOTICE-NTRAID#NTBUG9--2002/04/26-artm  Possible buffer overrun in stack buffer.
    // Rewrote function to first read the length of the string, and then allocate
    // a dynamically sized buffer large enough to hold the string.  

    // Read string length from stream (including null).
    err = pStm->Read((void*)&nLen, sizeof(UINT), &cbRead);
    if (FAILED(err))
    {
        ASSERT(false);
        return err;
    }
    ASSERT(cbRead == sizeof(UINT));

    //
    // Read the string from the stream.
    //

    WCHAR* szBuffer = new WCHAR[nLen];

    if (szBuffer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    err = pStm->Read((void*)szBuffer, sizeof(WCHAR)*nLen, &cbRead);
    if (SUCCEEDED(err))
    {
        ASSERT(cbRead == sizeof(WCHAR) * nLen);

        // Who knows what might have happened to the persisted data
        // between the time we wrote and now.  We'll be extra careful
        // and guarantee that our string is null terminated at the correct
        // place.
        ASSERT(szBuffer[nLen - 1] == NULL);
        szBuffer[nLen - 1] = NULL;
        sString = szBuffer;
    }
    else
    {
        ASSERT(false);
    }

    // Free temporary buffer.
    delete [] szBuffer;


    return err;
}

HRESULT LoadStringListFromStream(IStream* pStm, CStringList& sList)
{
    HRESULT err = S_OK;
    ULONG cbRead;
    UINT nCount;

    if (NULL == pStm)
    {
        return E_POINTER;
    }

    // NOTICE-NTRAID#NTBUG9-559560-2002/02/28-artm  If unable to read # of strings, return an error code.
    // What is the point in returning S_OK if the first write to stream failed?
    // Worse, don't need to try to write any of the strings to the stream...

    // Read the number of strings in the list.
    err = pStm->Read((void*)&nCount, sizeof(ULONG), &cbRead);
    if (FAILED(err))
    {
        ASSERT(false);
        return err;
    }
    ASSERT(cbRead == sizeof(ULONG));

    // Read the strings from the stream into the list.
    CString sString;
    for (UINT k = 0; k < nCount && SUCCEEDED(err); k++)
    {
        err = LoadStringFromStream(pStm, sString);
        sList.AddTail(sString);
    }

    // Double check that, if we had no errors loading strings,
    // all of the strings were correctly added to the list.
    if (SUCCEEDED(err) && sList.GetCount() != nCount)
    {
        err = E_FAIL;
    }

    return err;
}


/////////////////////////////////////////////////////////////////////
/////////////////////// Message Boxes ///////////////////////////////
/////////////////////////////////////////////////////////////////////

int ADSIEditMessageBox(LPCTSTR lpszText, UINT nType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

   return ::AfxMessageBox(lpszText, nType);
}

int ADSIEditMessageBox(UINT nIDPrompt, UINT nType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

    return ::AfxMessageBox(nIDPrompt, nType);
}

void ADSIEditErrorMessage(PCWSTR pszMessage)
{
  ADSIEditMessageBox(pszMessage, MB_OK);
}

void ADSIEditErrorMessage(HRESULT hr)
{
    CString s;
    GetErrorMessage(hr, s);
    ADSIEditMessageBox(s, MB_OK);
}

void ADSIEditErrorMessage(HRESULT hr, UINT nIDPrompt, UINT nType)
{
  CString s;
  GetErrorMessage(hr, s);

  CString szMessage;
  szMessage.Format(nIDPrompt, s);

  ADSIEditMessageBox(szMessage, MB_OK);
}

/////////////////////////////////////////////////////////////////////

BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
                                        UINT nStringID, UINT nMaxLen, UINT nMaxAddCount)
{
    pCombo->ResetContent();
    ASSERT(hInstance != NULL);
    WCHAR* szBuf = (WCHAR*)malloc(sizeof(WCHAR)*nMaxLen);
  if (!szBuf)
  {
    return FALSE;
  }

  // NOTICE-2002/02/28-artm  LoadString() used correctly.
  // nMaxLen is the length in WCHAR's of szBuf.
    if ( ::LoadString(hInstance, nStringID, szBuf, nMaxLen) == 0)
  {
    free(szBuf);
        return FALSE;
  }

    LPWSTR* lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*nMaxLen);
  if (lpszArr)
  {
      int nArrEntries = 0;
      ParseNewLineSeparatedString(szBuf,lpszArr, &nArrEntries);
      
      if (nMaxAddCount < nArrEntries) nArrEntries = nMaxAddCount;
      for (int k=0; k<nArrEntries; k++)
          pCombo->AddString(lpszArr[k]);
  }

  if (szBuf)
  {
    free(szBuf);
  }
  if (lpszArr)
  {
    free(lpszArr);
  }
    return TRUE;
}

void ParseNewLineSeparatedString(LPWSTR lpsz, 
                                 LPWSTR* lpszArr, 
                                 int* pnArrEntries)
{
    static WCHAR lpszSep[] = L"\n";
    *pnArrEntries = 0;
    int k = 0;
    lpszArr[k] = wcstok(lpsz, lpszSep);
    if (lpszArr[k] == NULL)
        return;

    while (TRUE)
    {
        WCHAR* lpszToken = wcstok(NULL, lpszSep);
        if (lpszToken != NULL)
            lpszArr[++k] = lpszToken;
        else
            break;
    }
    *pnArrEntries = k+1;
}

void LoadStringArrayFromResource(LPWSTR* lpszArr,
                                            UINT* nStringIDs,
                                            int nArrEntries,
                                            int* pnSuccessEntries)
{
    CString szTemp;
    
    *pnSuccessEntries = 0;
    for (int k = 0;k < nArrEntries; k++)
    {
        if (!szTemp.LoadString(nStringIDs[k]))
        {
            lpszArr[k] = NULL;
            continue;
        }
        
        int iLength = szTemp.GetLength() + 1;
        lpszArr[k] = (LPWSTR)malloc(sizeof(WCHAR)*iLength);
        if (lpszArr[k] != NULL)
        {
            // NOTICE-2002/02/28-artm  Using wcscpy() here relies on CString
            // always being null terminated (which it should be).
            wcscpy(lpszArr[k], (LPWSTR)(LPCWSTR)szTemp);
            (*pnSuccessEntries)++;
        }
    }
}

///////////////////////////////////////////////////////////////

void GetStringArrayFromStringList(CStringList& sList, LPWSTR** ppStrArr, UINT* nCount)
{
  *nCount = sList.GetCount();

  *ppStrArr = new LPWSTR[*nCount];

  UINT idx = 0;
  POSITION pos = sList.GetHeadPosition();
  while (pos != NULL)
  {
    CString szString = sList.GetNext(pos);
    (*ppStrArr)[idx] = new WCHAR[szString.GetLength() + 1];
    ASSERT((*ppStrArr)[idx] != NULL);

    // NTRAID#NTBUG9--2002/02/28-artm  Need to check that mem. allocation succeeded.
    // If memory allocation failed, should not call wcscpy().

    // NOTICE-2002/02/28-artm  As long as the memory allocation succeeded for
    // (*ppStrArr)[idx], the copy will succeed correctly (all CStrings are
    // null terminated).
    wcscpy((*ppStrArr)[idx], szString);
    idx++;
  }
  *nCount = idx;
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CByteArrayComboBox, CComboBox)
    ON_CONTROL_REFLECT(CBN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

BOOL CByteArrayComboBox::Initialize(CByteArrayDisplay* pDisplay, 
                                    DWORD dwDisplayFlags)
{
  ASSERT(pDisplay != NULL);
  m_pDisplay = pDisplay;

  //
  // Load the combo box based on the flags given
  //
  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_HEX)
  {
    CString szHex;
    VERIFY(szHex.LoadString(IDS_HEXADECIMAL));
    int idx = AddString(szHex);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_HEX);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_OCT)
  {
    CString szOct;
    VERIFY(szOct.LoadString(IDS_OCTAL));
    int idx = AddString(szOct);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_OCT);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_DEC)
  {
    CString szDec;
    VERIFY(szDec.LoadString(IDS_DECIMAL));
    int idx = AddString(szDec);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_DEC);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_BIN)
  {
    CString szBin;
    VERIFY(szBin.LoadString(IDS_BINARY));
    int idx = AddString(szBin);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_BIN);
    }
  }

  return TRUE;
}

DWORD CByteArrayComboBox::GetCurrentDisplay()
{
  DWORD dwRet = 0;
  int iSel = GetCurSel();
  if (iSel != CB_ERR)
  {
    dwRet = GetItemData(iSel);
  }
  return dwRet;
}
  
void CByteArrayComboBox::SetCurrentDisplay(DWORD dwSel)
{
  int iCount = GetCount();
  for (int idx = 0; idx < iCount; idx++)
  {
    DWORD dwData = GetItemData(idx);
    if (dwData == dwSel)
    {
      SetCurSel(idx);
      return;
    }
  }
}

void CByteArrayComboBox::OnSelChange()
{
  if (m_pDisplay != NULL)
  {
    int iSel = GetCurSel();
    if (iSel != CB_ERR)
    {
      DWORD dwData = GetItemData(iSel);
      m_pDisplay->OnTypeChange(dwData);
    }
  }
}

////////////////////////////////////////////////////////////////

CByteArrayEdit::CByteArrayEdit()
  : m_pData(NULL), 
    m_dwLength(0),
    CEdit()
{
}

CByteArrayEdit::~CByteArrayEdit()
{
}

BEGIN_MESSAGE_MAP(CByteArrayEdit, CEdit)
    ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

BOOL CByteArrayEdit::Initialize(CByteArrayDisplay* pDisplay)
{
  ASSERT(pDisplay != NULL);
  m_pDisplay = pDisplay;

  ConvertToFixedPitchFont(GetSafeHwnd());
  return TRUE;
}

DWORD CByteArrayEdit::GetLength()
{
  return m_dwLength;
}

BYTE* CByteArrayEdit::GetDataPtr()
{
  return m_pData;
}

//Pre:  ppData != NULL
//Post: Allocates space for a copy of the byte array at *ppData and
// copies it.  Returns the size of *ppData in bytes.  Note that
// the copied byte array can be NULL (e.g. *ppData will equal NULL).
DWORD CByteArrayEdit::GetDataCopy(BYTE** ppData)
{
  if (m_pData != NULL && m_dwLength > 0)
  {
    *ppData = new BYTE[m_dwLength];
    if (*ppData != NULL)
    {
      memcpy(*ppData, m_pData, m_dwLength);
      return m_dwLength;
    }
  }

  *ppData = NULL;
  return 0;
}

void CByteArrayEdit::SetData(BYTE* pData, DWORD dwLength)
{
  if (m_pData != NULL)
  {
    delete[] m_pData;
    m_pData = NULL;
    m_dwLength = 0;
  }

  if (dwLength > 0 && pData != NULL)
  {
    //
    // Set the new data
    //
    m_pData = new BYTE[dwLength];
    if (m_pData != NULL)
    {
      memcpy(m_pData, pData, dwLength);
      m_dwLength = dwLength;
    }
  }
}

void CByteArrayEdit::OnChangeDisplay()
{
  CString szOldDisplay;
  GetWindowText(szOldDisplay);

  if (!szOldDisplay.IsEmpty())
  {
    BYTE* pByte = NULL;
    DWORD dwLength = 0;
    switch (m_pDisplay->GetPreviousDisplay())
    {
      case BYTE_ARRAY_DISPLAY_HEX :
        dwLength = HexStringToByteArray(szOldDisplay, &pByte);
        break;
     
      case BYTE_ARRAY_DISPLAY_OCT :
        dwLength = OctalStringToByteArray(szOldDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_DEC :
        dwLength = DecimalStringToByteArray(szOldDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_BIN :
        dwLength = BinaryStringToByteArray(szOldDisplay, &pByte);
        break;

      default :
        ASSERT(FALSE);
        break;
    }

    if (pByte != NULL && dwLength != (DWORD)-1)
    {
      SetData(pByte, dwLength);
      delete[] pByte;
      pByte = 0;
    }
  }

  CString szDisplayValue;
  switch (m_pDisplay->GetCurrentDisplay())
  {
    case BYTE_ARRAY_DISPLAY_HEX :
      ByteArrayToHexString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    case BYTE_ARRAY_DISPLAY_OCT :
      ByteArrayToOctalString(GetDataPtr(), GetLength(), szDisplayValue);
      break;
     
    case BYTE_ARRAY_DISPLAY_DEC :
      ByteArrayToDecimalString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    case BYTE_ARRAY_DISPLAY_BIN :
      ByteArrayToBinaryString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    default :
      ASSERT(FALSE);
      break;
  }
  SetWindowText(szDisplayValue);
}

void CByteArrayEdit::OnChange()
{
  if (m_pDisplay != NULL)
  {
    m_pDisplay->OnEditChange();
  }
}

////////////////////////////////////////////////////////////////

BOOL CByteArrayDisplay::Initialize(UINT   nEditCtrl, 
                                   UINT   nComboCtrl, 
                                   DWORD  dwDisplayFlags,
                                   DWORD  dwDefaultDisplay,
                                   CWnd*  pParent,
                                   DWORD  dwMaxSizeLimit,
                                   UINT   nMaxSizeMessageID)
{
  //
  // Initialize the edit control
  //
  VERIFY(m_edit.SubclassDlgItem(nEditCtrl, pParent));
  VERIFY(m_edit.Initialize(this));

  //
  // Initialize the combo box
  //
  VERIFY(m_combo.SubclassDlgItem(nComboCtrl, pParent));
  VERIFY(m_combo.Initialize(this, dwDisplayFlags));

  m_dwMaxSizeBytes = dwMaxSizeLimit;
  m_nMaxSizeMessage = nMaxSizeMessageID;

  //
  // Selects the default display in the combo box and
  // populates the edit field
  //
  SetCurrentDisplay(dwDefaultDisplay);
  m_dwPreviousDisplay = dwDefaultDisplay;
  m_combo.SetCurrentDisplay(dwDefaultDisplay);
  m_edit.OnChangeDisplay();

  return TRUE;
}

void CByteArrayDisplay::OnEditChange()
{
}

void CByteArrayDisplay::OnTypeChange(DWORD dwDisplayType)
{
    SetCurrentDisplay(dwDisplayType);
  
    // NOTICE-2002/05/01-artm  ntraid#ntbug9-598051
    // Only need to change the value displayed if the underlying
    // byte array is beneath our maximum display size.  Otherwise,
    // the current message will be that the value is too large for
    // this editor (and we should keep it that way).
    if (m_edit.GetLength() <= m_dwMaxSizeBytes)
    {
        m_edit.OnChangeDisplay();
    }
}

void CByteArrayDisplay::ClearData()
{
  m_edit.SetData(NULL, 0);
  m_edit.OnChangeDisplay();
}

void CByteArrayDisplay::SetData(BYTE* pData, DWORD dwLength)
{
  if (dwLength > m_dwMaxSizeBytes)
  {
    //
    // If the data is too large to load into the edit box
    // load the provided message and set the edit box to read only
    //
    CString szMessage;
    VERIFY(szMessage.LoadString(m_nMaxSizeMessage));
    m_edit.SetWindowText(szMessage);
    m_edit.SetReadOnly();

    //
    // Still need to set the data in the edit box even though we are not going to show it
    //
    m_edit.SetData(pData, dwLength);
  }
  else
  {
    m_edit.SetReadOnly(FALSE);
    m_edit.SetData(pData, dwLength);
    m_edit.OnChangeDisplay();
  }
}

DWORD CByteArrayDisplay::GetData(BYTE** ppData)
{
  CString szDisplay;
  m_edit.GetWindowText(szDisplay);

  if (!szDisplay.IsEmpty())
  {
    BYTE* pByte = NULL;
    DWORD dwLength = 0;
    switch (GetCurrentDisplay())
    {
      case BYTE_ARRAY_DISPLAY_HEX :
        dwLength = HexStringToByteArray(szDisplay, &pByte);
        break;
     
      case BYTE_ARRAY_DISPLAY_OCT :
        dwLength = OctalStringToByteArray(szDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_DEC :
        dwLength = DecimalStringToByteArray(szDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_BIN :
        dwLength = BinaryStringToByteArray(szDisplay, &pByte);
        break;

      default :
        ASSERT(FALSE);
        break;
    }

    if (pByte != NULL && dwLength != (DWORD)-1)
    {
      m_edit.SetData(pByte, dwLength);
      delete[] pByte;
      pByte = 0;
    }
  }

  return m_edit.GetDataCopy(ppData);
}

void CByteArrayDisplay::SetCurrentDisplay(DWORD dwCurrentDisplay)
{ 
  m_dwPreviousDisplay = m_dwCurrentDisplay;
  m_dwCurrentDisplay = dwCurrentDisplay; 
}

////////////////////////////////////////////////////////////////////////////////
// String to byte array conversion routines

//
// HexStringToByteArray_0x():
//
// Conversion function for hex strings in format 0x00 to byte arrays.
//
// Return Values:
//  E_POINTER --- bad pointer passed as parameter
//  E_FAIL    --- the hex string had an invalid format, conversion failed
//  S_OK      --- conversion succeeded
//
HRESULT HexStringToByteArray_0x(PCWSTR pszHexString, BYTE** ppByte, DWORD &nCount)
{
    HRESULT hr = S_OK;
    nCount = 0;

    // Should never happen . . .
    ASSERT(ppByte);
    ASSERT(pszHexString);
    if (!pszHexString || !ppByte)
    {
        return E_POINTER;
    }

    *ppByte = NULL;
    DWORD count = 0;
    int index = 0, result = 0;
    int max = 0;
    // Flag to mark the string as having non-whitespace characters.
    bool isEmpty = true;

    // Determine the maximum number of octet sequences (0x00 format) the string
    // contains.
    for (index = 0; pszHexString[index] != NULL; ++index)
    {
        switch (pszHexString[index])
        {
        case L' ':
        case L'\t':
            // Whitespace, do nothing.
            break;
        case L'x':
            // Increase count of possible octet sequences.
            ++max;
            break;
        default:
            isEmpty = false;
            break;
        }// end switch
    }

    if (max == 0 && !isEmpty)
    {
        // Bad format for string.
        return E_FAIL;
    }


    // Convert any octet sequences to bytes.
    while (max > 0) // false loop, only executed once
    {
        *ppByte = new BYTE[max];
        if (NULL == *ppByte)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ZeroMemory(*ppByte, max);

        index = 0;

        // This is a little weird.  Originally I was using BYTE's for 
        // high and low, figuring that hex characters easily fit in a byte.
        // However, swscanf() wrote to the high and low as if they were USHORT,
        // maybe because it is the wide version of the function (and the string
        // is wide).  Consequently, swscanf() converted high, then converted low
        // with the side effect of overwriting high to be 0.  Declaring them as
        // USHORT's makes everything work as intended.
        USHORT high, low;

        do
        {
            ASSERT(count <= max);
            high = 0;
            low = 0;

            // Skip white space.
            while (pszHexString[index] == ' ' || pszHexString[index] == '\t')
            {
                ++index;
            }

            // If we're at the end of the string, we converted it w/out problem.
            if (pszHexString[index] == NULL)
            {
                hr = S_OK;
                break;
            }

            // Try to convert an octet sequence to a byte.
            // Enforce having exactly 0x00 or 0x0 format.
            result = swscanf(
                &(pszHexString[index]),
                L"0x%1x%1x",
                &high,
                &low);

            if (result == 2)
            {
                // Conversion was successful, combine high and low bits of byte.

                // Since high and low are USHORT, convert them to a BYTE.
                (*ppByte)[count] = static_cast<BYTE>((high << 4) + low);
                ++count;

                // Move past the 0x00.
                index += 4;
            }
            else if(result == 1)
            {
                // Conversion was successful, but only read single character (always in low bits).
                (*ppByte)[count] = static_cast<BYTE>(high);
                ++count;

                // Move past the 0x0.
                index += 3;
            }
            else
            {
                hr = E_FAIL;
            }

        } while (SUCCEEDED(hr));

        // Always break out of loop.
        break;
    }
    
    if (SUCCEEDED(hr))
    {
        nCount = count;
    }
    else
    {
        delete [] *ppByte;
        *ppByte = NULL;
    }

    return hr;
}

//
// HexStringToByteArray():
//
// Conversion function for hex strings in format FF BC to byte arrays.
//
DWORD HexStringToByteArray(PCWSTR pszHexString, BYTE** ppByte)
{
  CString szHexString = pszHexString;
  BYTE* pToLargeArray = new BYTE[szHexString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return (DWORD)-1;
  }
  
  UINT nByteCount = 0;
  while (!szHexString.IsEmpty())
  {
    //
    // Hex strings should always come 2 characters per byte
    //
    CString szTemp = szHexString.Left(2);

    int iTempByte = 0;
    
    // NOTICE-NTRAID#NTBUG9-560778-2002/03/01-artm  Check the return value of swscanf().
     // Function could fail if characters are in szTemp
     // that are out of range (e.g. letters > f).

    int result = swscanf(szTemp, L"%X", &iTempByte);
    if (result == 1 &&
        iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format hex error
      //
      ADSIEditMessageBox(IDS_FORMAT_HEX_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szHexString = szHexString.Right(szHexString.GetLength() - 3);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  // NOTICE-2002/03/01-artm  The size of pToLargeArray is
  // always > nByteCount; size of ppByte == nByteCount.
  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToHexString(BYTE* pByte, DWORD dwLength, CString& szHexString)
{
  szHexString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%2.2X", pByte[dwIdx]);

    if (dwIdx != 0)
    {
      szHexString += L" ";
    }
    szHexString += szTempString;
  }
}

DWORD OctalStringToByteArray(PCWSTR pszOctString, BYTE** ppByte)
{
  CString szOctString = pszOctString;
  BYTE* pToLargeArray = new BYTE[szOctString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return (DWORD)-1;
  }
  
  UINT nByteCount = 0;
  while (!szOctString.IsEmpty())
  {
    //
    // Octal strings should always come 2 characters per byte
    //
    CString szTemp = szOctString.Left(3);

    int iTempByte = 0;
     // NOTICE-NTRAID#NTBUG9-560778-2002/03/01-artm  Check the return value of swscanf().
     // Function could fail if characters are in szTemp
     // that are out of range (e.g. letters > f).

    int result = swscanf(szTemp, L"%o", &iTempByte);
    if (result == 1 &&
        iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format octal error
      //
      ADSIEditMessageBox(IDS_FORMAT_OCTAL_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szOctString = szOctString.Right(szOctString.GetLength() - 4);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  // NOTICE-2002/03/01-artm  The size of pToLargeArray is
  // always > nByteCount; size of ppByte == nByteCount.
  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToOctalString(BYTE* pByte, DWORD dwLength, CString& szOctString)
{
  szOctString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%3.3o", pByte[dwIdx]);

    if (dwIdx != 0)
    {
      szOctString += L" ";
    }
    szOctString += szTempString;
  }
}

DWORD DecimalStringToByteArray(PCWSTR pszDecString, BYTE** ppByte)
{
  CString szDecString = pszDecString;
  BYTE* pToLargeArray = new BYTE[szDecString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return 0;
  }
  
  UINT nByteCount = 0;
  while (!szDecString.IsEmpty())
  {
    //
    // Hex strings should always come 2 characters per byte
    //
    CString szTemp = szDecString.Left(3);

    int iTempByte = 0;

    // NOTICE-NTRAID#NTBUG9-560778-2002/03/01-artm  Check the return value of swscanf().
    // Function could fail if characters are in szTemp
    // that are out of range (e.g. letters > f).
    
    int result = swscanf(szTemp, L"%d", &iTempByte);
    if (result == 1 &&
        iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format decimal error
      //
      ADSIEditMessageBox(IDS_FORMAT_DECIMAL_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szDecString = szDecString.Right(szDecString.GetLength() - 4);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  // NOTICE-2002/03/01-artm  The size of pToLargeArray is
  // always > nByteCount; size of ppByte == nByteCount.
  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToDecimalString(BYTE* pByte, DWORD dwLength, CString& szDecString)
{
  szDecString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%3.3d", pByte[dwIdx]);
    if (dwIdx != 0)
    {
      szDecString += L" ";
    }
    szDecString += szTempString;
  }
}

// REVIEW-ARTM  This function (and maybe all the conversion functions) needs a rewrite.
// It makes a bunch of assumptions about the format of the string w/out checking said
// assumptions, and it does not behave the same way as editing in hex mode.
DWORD BinaryStringToByteArray(PCWSTR pszBinString, BYTE** ppByte)
{
    ASSERT(ppByte);
    *ppByte = NULL;

    CString szBinString = pszBinString;
    BYTE* pToLargeArray = new BYTE[szBinString.GetLength()];
    if (pToLargeArray == NULL)
    {
        return (DWORD)-1;
    }
  
    UINT nByteCount = 0;
    bool format_error = false;

    // Remove leading white space.
    szBinString.TrimLeft();

    while (!format_error && !szBinString.IsEmpty())
    {

        // If the string ended with a bunch of white space, it might now be
        // empty.  In that case, we don't want to return an error b/c the 
        // conversion was successful.
        if (szBinString.IsEmpty())
        {
            break;
        }
            
        //
        // Binary strings should always come 8 characters per byte
        //
        BYTE chByte = 0;
        CString szTemp = szBinString.Left(8);

        // NOTICE-NTRAID#NTBUG9-560868-2002/05/06-artm  Verify substring length of 8.
        // This ensures that we are working with 8 characters at a time, but does nothing
        // for checking that the 8 characters are either '1' or '0' (see case statement
        // below for that checking).
        if (szTemp.GetLength() != 8)
        {
            nByteCount = static_cast<DWORD>(-1);
            break;
        }

        for (int idx = 0; idx < 8 && !format_error; idx++)
        {
            switch (szTemp[idx])
            {
            case L'1':
                // NOTICE-2002/04/29-artm  fixed ntraid#ntbug9-567210
                // Before was not combining partial result with the new bit
                // to set.
                // Also, previously was shifting one place too many.
                chByte |= 0x1 << (8 - idx - 1);
                break;
            case L'0':
                // Don't need to do anything, bit set to 0 by default.
                break;
            default:
                format_error = true;
                break;
            }// end switch
        }

        if (!format_error)
        {
            pToLargeArray[nByteCount++] = chByte;

            //
            // Take off the value retrieved.
            //
            szBinString = szBinString.Right(szBinString.GetLength() - 8);

            // Remove trailing white space (now at front of string).
            szBinString.TrimLeft();
        }
        else
        {
            nByteCount = static_cast<DWORD>(-1);
        }

    }

    if (nByteCount > 0 && nByteCount != static_cast<DWORD>(-1))
    {
        *ppByte = new BYTE[nByteCount];
        if (*ppByte)
        {
            // NOTICE-2002/03/01-artm  nByteCount is size of *ppByte,
            // and pToLargeArray is roughly 8 times as big as nByteCount.
            memcpy(*ppByte, pToLargeArray, nByteCount);
        }
        else
        {
            nByteCount = static_cast<DWORD>(-1);
        }
    }

    delete[] pToLargeArray;

    return nByteCount;
}

void  ByteArrayToBinaryString(BYTE* pByte, DWORD dwLength, CString& szBinString)
{
  szBinString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    BYTE chTemp = pByte[dwIdx];
    for (size_t idx = 0; idx < sizeof(BYTE) * 8; idx++)
    {
      if ((chTemp & (0x1 << idx)) == 0)
      {
        szTempString = L'0' + szTempString;
      }
      else
      {
        szTempString = L'1' + szTempString;
      }
    }

    if (dwIdx != 0)
    {
      szBinString += L" ";
    }
    szBinString += szTempString;
  }
}


//////////////////////////////////////////////////////////////////////////////

BOOL LoadFileAsByteArray(PCWSTR pszPath, LPBYTE* ppByteArray, DWORD* pdwSize)
{
  if (ppByteArray == NULL ||
      pdwSize == NULL)
  {
    return FALSE;
  }

  CFile file;
  if (!file.Open(pszPath, CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary))
  {
    return FALSE;
  }

  *pdwSize = file.GetLength();
  *ppByteArray = new BYTE[*pdwSize];
  if (*ppByteArray == NULL)
  {
    return FALSE;
  }

  UINT uiCount = file.Read(*ppByteArray, *pdwSize);
  ASSERT(uiCount == *pdwSize);

  return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToFixedPitchFont
//
//  Synopsis:   Converts a windows font to a fixed pitch font.
//
//  Arguments:  [hwnd] -- IN window handle
//
//  Returns:    BOOL
//
//  History:    7/15/1995   RaviR   Created
//
//----------------------------------------------------------------------------

BOOL ConvertToFixedPitchFont(HWND hwnd)
{
  LOGFONT     lf;

  HFONT hFont = reinterpret_cast<HFONT>(::SendMessage(hwnd, WM_GETFONT, 0, 0));

  if (!GetObject(hFont, sizeof(LOGFONT), &lf))
  {
    return FALSE;
  }

  lf.lfQuality        = PROOF_QUALITY;
  lf.lfPitchAndFamily &= ~VARIABLE_PITCH;
  lf.lfPitchAndFamily |= FIXED_PITCH;
  lf.lfFaceName[0]    = L'\0';

  HFONT hf = CreateFontIndirect(&lf);

  if (hf == NULL)
  {
    return FALSE;
  }

  ::SendMessage(hwnd, WM_SETFONT, (WPARAM)hf, (LPARAM)TRUE); // macro in windowsx.h
  return TRUE;
}


//////////////////////////////////////////////////////////////////
// Theming support

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage(&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef _COMMON_ADSIEDIT_H
#define _COMMON_ADSIEDIT_H

#include <shfusion.h>

class CConnectionData;
class CCredentialObject;

//////////////////////////////////////////////
// TODO: use correct letter case for a variable (vs. MACRO style)
const unsigned int MAX_PASSWORD_LENGTH = 127;	// not counting NULL terminator

//////////////////////////////////////////////
// Global API

HRESULT OpenObjectWithCredentials(
											 CConnectionData* pConnectData,
											 const BOOL bUseCredentials,
											 LPCWSTR lpszPath, 
											 const IID& iid,
											 LPVOID* ppObject,
											 HWND hWnd,
											 HRESULT& hResult
											);

HRESULT OpenObjectWithCredentials(
											 CCredentialObject* pCredObject,
											 LPCWSTR lpszPath, 
											 const IID& iid,
											 LPVOID* ppObject
											);

HRESULT CALLBACK BindingCallbackFunction(LPCWSTR lpszPathName,
                                         DWORD  dwReserved,
                                         REFIID riid,
                                         void FAR * FAR * ppObject,
                                         LPARAM lParam);

//////////////////////////////////////////////////////////////////////////
// Commonly used utilities
//
inline void CopyStringList(CStringList *dest, const CStringList *src)
{
	dest->RemoveAll();
	dest->AddTail(const_cast<CStringList*>(src));
}
HRESULT  VariantToStringList(  VARIANT& refvar, CStringList& refstringlist);
HRESULT StringListToVariant( VARIANT& refvar, const CStringList& refstringlist);
VARTYPE VariantTypeFromSyntax(LPCWSTR lpszProp );
HRESULT GetItemFromRootDSE(LPCWSTR lpszRootDSEItem, CString& sItem, CConnectionData* pConnectData);
HRESULT GetRootDSEObject(CConnectionData* pConnectData, IADs** ppDirObject);

///////////////////////////////////////////////////////////////////////////
// Formats Error Messages
//
BOOL GetErrorMessage(HRESULT hr, CString& szErrorString, BOOL bTryADsIErrors = TRUE);

///////////////////////////////////////////////////////////////////////////
// Converts ADSTYPE to/from String
//
void GetStringFromADsValue(const PADSVALUE pADsValue, CString& szValue, DWORD dwMaxCharCount = 0);
void GetStringFromADs(const ADS_ATTR_INFO* pInfo, CStringList& sList, DWORD dwMaxCharCount = 0);
ADSTYPE GetADsTypeFromString(LPCWSTR lps, CString& szSyntax);

CString GetStringValueFromSystemTime(const SYSTEMTIME* pTime);

////////////////////////////////////////////////////////////////////////////
// type conversions
//
void wtoli(LPCWSTR lpsz, LARGE_INTEGER& liOut);
void litow(LARGE_INTEGER& li, CString& sResult);
void ultow(ULONG ul, CString& sResult);


///////////////////////////////////////////////////////////////////////////
// IO to/from Streams
//
HRESULT SaveStringToStream(IStream* pStm, const CString& sString);
HRESULT SaveStringListToStream(IStream* pStm, CStringList& sList);
HRESULT LoadStringFromStream(IStream* pStm, CString& sString);
HRESULT LoadStringListFromStream(IStream* pStm, CStringList& sList);

////////////////////////////////////////////////////////////////////////////
// Message Boxes
int ADSIEditMessageBox(LPCTSTR lpszText, UINT nType);
int ADSIEditMessageBox(UINT nIDPrompt, UINT nType);
void ADSIEditErrorMessage(PCWSTR pszMessage);
void ADSIEditErrorMessage(HRESULT hr);
void ADSIEditErrorMessage(HRESULT hr, UINT nIDPrompt, UINT nType);

///////////////////////////////////////////////////////////////////////////
// Other utils
BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
						   UINT nStringID, UINT nMaxLen, UINT nMaxAddCount);
void ParseNewLineSeparatedString(LPWSTR lpsz, LPWSTR* lpszArr, int* pnArrEntries);
void LoadStringArrayFromResource(LPWSTR* lpszArr,
											UINT* nStringIDs,
											int nArrEntries,
											int* pnSuccessEntries);

/////////////////////////////////////////////////////////////////////////////

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

void GetStringArrayFromStringList(CStringList& sList, LPWSTR** ppStrArr, UINT* nCount);


//////////////////////////////////////////////////////////////////////////////
// UI helper classes

// Fwd declaration
class CByteArrayDisplay;

#define BYTE_ARRAY_DISPLAY_HEX    0x00000001
#define BYTE_ARRAY_DISPLAY_DEC    0x00000002
#define BYTE_ARRAY_DISPLAY_BIN    0x00000004
#define BYTE_ARRAY_DISPLAY_OCT    0x00000008

class CByteArrayComboBox : public CComboBox
{
public:
  BOOL Initialize(CByteArrayDisplay* pDisplay, DWORD dwDisplayFlags);

  DWORD GetCurrentDisplay();
  void SetCurrentDisplay(DWORD dwCurrentDisplayFlag);

protected:
  afx_msg void OnSelChange();

private:
  CByteArrayDisplay*  m_pDisplay;

  DECLARE_MESSAGE_MAP()
};

class CByteArrayEdit : public CEdit
{
public:
  CByteArrayEdit();
  ~CByteArrayEdit();
  BOOL Initialize(CByteArrayDisplay* pDisplay);

  DWORD GetLength();
  BYTE* GetDataPtr();
  DWORD GetDataCopy(BYTE** ppData);

  void SetData(BYTE* pData, DWORD dwLength);

  void OnChangeDisplay();

  afx_msg void OnChange();

private:
  CByteArrayDisplay*  m_pDisplay;

  BYTE*               m_pData;
  DWORD               m_dwLength;

  DECLARE_MESSAGE_MAP()
};

class CByteArrayDisplay
{
public:
  CByteArrayDisplay()
    : m_dwPreviousDisplay(0),
      m_dwCurrentDisplay(0),
      m_dwMaxSizeBytes(0),
      m_nMaxSizeMessage(0)
  {}
  ~CByteArrayDisplay() {}

  BOOL Initialize(UINT  nEditCtrl, 
                  UINT  nComboCtrl, 
                  DWORD dwDisplayFlags, 
                  DWORD dwDefaultDisplay, 
                  CWnd* pParent,
                  DWORD dwMaxSizeBytes,
                  UINT  nMaxSizeMessage);

  void ClearData();
  void SetData(BYTE* pData, DWORD dwLength);
  DWORD GetData(BYTE** ppData);

  void OnEditChange();
  void OnTypeChange(DWORD dwCurrentDisplayFlag);
  DWORD GetCurrentDisplay() { return m_dwCurrentDisplay; }
  void SetCurrentDisplay(DWORD dwCurrentDisplay);
  DWORD GetPreviousDisplay() { return m_dwPreviousDisplay; }

private:
  CByteArrayEdit      m_edit;
  CByteArrayComboBox  m_combo;

  DWORD               m_dwPreviousDisplay;
  DWORD               m_dwCurrentDisplay;

  DWORD               m_dwMaxSizeBytes;     // The maximum number of bytes that will be shown in the edit box
  UINT                m_nMaxSizeMessage;    // The message that is put in the edit box when the max size is reached
};


////////////////////////////////////////////////////////////////////////////////
// String to byte array conversion routines

HRESULT HexStringToByteArray_0x(PCWSTR pszHexString, BYTE** ppByte, DWORD& nCount);

DWORD HexStringToByteArray(PCWSTR pszHexString, BYTE** ppByte);
void  ByteArrayToHexString(BYTE* pByte, DWORD dwLength, CString& szHexString);

DWORD OctalStringToByteArray(PCWSTR pszHexString, BYTE** ppByte);
void  ByteArrayToOctalString(BYTE* pByte, DWORD dwLength, CString& szHexString);

DWORD DecimalStringToByteArray(PCWSTR pszDecString, BYTE** ppByte);
void  ByteArrayToDecimalString(BYTE* pByte, DWORD dwLength, CString& szDecString);

DWORD BinaryStringToByteArray(PCWSTR pszBinString, BYTE** ppByte);
void  ByteArrayToBinaryString(BYTE* pByte, DWORD dwLength, CString& szBinString);

/////////////////////////////////////////////////////////////////////////////////

BOOL LoadFileAsByteArray(PCWSTR pszPath, LPBYTE* ppByteArray, DWORD* pdwSize);

/////////////////////////////////////////////////////////////////////////////////

BOOL ConvertToFixedPitchFont(HWND hwnd);

////////////////////////////////////////////////////////////////////////////////////
// Theme support

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

#endif _COMMON_ADSIEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\connection.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connection.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "createwiz.h"
#include "connection.h"
#include "connectionui.h"
#include "editorui.h"
#include "filterui.h"
#include "credui.h"
#include "queryui.h"


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

///////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszRootDSE;

///////////////////////////////////////////////////////////////////////////////

// {5C225203-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditConnectionNode::NodeTypeGUID = 
{ 0x5c225203, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditConnectionNode::~CADSIEditConnectionNode()
{
    RemoveAndDeleteAllQueriesFromList();
    delete m_pConnectData;
  HRESULT hr = m_SchemaCache.Destroy();
  ASSERT(SUCCEEDED(hr));
}

bool CADSIEditConnectionNode::IsClassAContainer(CCredentialObject* pCredObject,
                                                PCWSTR pszClass, 
                                                PCWSTR pszSchemaPath)
{
  bool bContainer = false;

  do // false loop
  {
    if (!pCredObject ||
        !pszClass    ||
        !pszSchemaPath)
    {
      ASSERT(pCredObject);
      ASSERT(pszClass);
      ASSERT(pszSchemaPath);
      bContainer = false;
      break;
    }

    CADSIEditClassCacheItemBase* pSchemaCacheItem = m_SchemaCache.FindClassCacheItem(pCredObject, 
                                                                                     pszClass, 
                                                                                     pszSchemaPath);
    if (pSchemaCacheItem)
    {
      bContainer = pSchemaCacheItem->IsContainer();
    }

  } while (false);

  return bContainer;
}

BOOL CADSIEditConnectionNode::OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync)
{

    CString path, basePath;
    GetADsObject()->GetPath(path);
    m_pConnectData->GetBasePath(basePath);

    CComPtr<IDirectoryObject> spDirectoryObject;
    HRESULT hr, hCredResult;
    CADsObject* pObject = new CADsObject();
  if (pObject)
  {
      if (m_pConnectData->IsRootDSE())
      {
          pObject->SetContainer(TRUE);
          pObject->SetName(g_lpszRootDSE);
          pObject->SetPath(path);
          pObject->SetClass(g_lpszRootDSE);
          pObject->SetConnectionNode(this);
          pObject->SetIntermediateNode(TRUE);
          pObject->SetComplete(TRUE);
          CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
          if (pNewContNode)
      {
        pNewContNode->SetDisplayName(g_lpszRootDSE);

            VERIFY(AddChildToList(pNewContNode));
      }
      pComponentData->SetDescriptionBarText(this);
      }
      else
      {
          hr = OpenObjectWithCredentials(
                                                   m_pConnectData, 
                                                   m_pConnectData->GetCredentialObject()->UseCredentials(),
                                                   path,
                                                   IID_IDirectoryObject, 
                                                   (LPVOID*) &spDirectoryObject,
                                                   NULL,
                                                   hCredResult
                                                   );

          if ( FAILED(hr) )
          {
              if (SUCCEEDED(hCredResult))
              {
                  ADSIEditErrorMessage(hr);
              }
        if (pObject)
        {
          delete pObject;
          pObject = 0;
        }
              return FALSE;
          }

          ADS_OBJECT_INFO* pInfo = 0;
          hr = spDirectoryObject->GetObjectInformation(&pInfo);
          if (FAILED(hr))
          {
              ADSIEditErrorMessage(hr);
        if (pObject)
        {
          delete pObject;
          pObject = 0;
        }
              return FALSE;
          }

          // Name
          pObject->SetName(basePath);
          pObject->SetDN(basePath);
          pObject->SetPath(path);

          // Make sure the prefix is uppercase
          CString sBasePath(basePath);
          int idx = sBasePath.Find(L'=');

          if (idx != -1)
          {
              CString sPrefix, sRemaining;
              sPrefix = sBasePath.Left(idx);
              sPrefix.MakeUpper();

              int iCount = sBasePath.GetLength();
              sRemaining = sBasePath.Right(iCount - idx);
              sBasePath = sPrefix + sRemaining;
          }

          // Class
          pObject->SetClass(pInfo->pszClassName);

          pObject->SetIntermediateNode(TRUE);
          pObject->SetContainer(TRUE);
          pObject->SetComplete(TRUE);
          CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
      if (pNewContNode)
      {
            CString sName;
            pNewContNode->SetDisplayName(sBasePath);

            GetConnectionData()->SetIDirectoryInterface(spDirectoryObject);
            pNewContNode->GetADsObject()->SetConnectionNode(this);
            VERIFY(AddChildToList(pNewContNode));
        pComponentData->SetDescriptionBarText(this);
            FreeADsMem(pInfo);
      }
      }

      EnumerateQueries();
  }

    return TRUE;
}

void CADSIEditConnectionNode::EnumerateQueries()
{
    POSITION pos = m_queryList.GetHeadPosition();
    while(pos != NULL)
    {
        CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);

        CADsObject* pObject = new CADsObject();
    if (pObject)
    {
        
          CString sPath, sName;
          pQueryData->GetName(sName);
          pObject->SetName(sName);

          pQueryData->GetRootPath(sPath);
          pObject->SetPath(sPath);

          pObject->SetComplete(TRUE);
          pObject->SetConnectionNode(this);
          pObject->SetContainer(TRUE);
          pObject->SetIntermediateNode(TRUE);

          CADSIEditQueryNode* pNewQuery = new CADSIEditQueryNode(pObject, pQueryData);
      if (pNewQuery)
      {

            CString sDisplayName;
            pQueryData->GetDisplayName(sDisplayName);
            pNewQuery->SetDisplayName(sDisplayName);
            VERIFY(AddChildToList(pNewQuery));
      }
    }
    }
}

BOOL CADSIEditConnectionNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                               BOOL* pbHideVerb, 
                                               CNodeList* pNodeList)
{
    *pbHideVerb = TRUE; // always hide the verb
    return FALSE;
}

BOOL CADSIEditConnectionNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
    // NOTICE-NTRAID#NTBUG9-561513-2002/03/01-artm  Validate lpszPath before using.
    if (!lpszPath)
    {
        // This should never happen.
        ASSERT(false);
        return FALSE;
    }

    CString szPath;
    GetADsObject()->GetPath(szPath);

    if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
    {
        foundNodeList.AddHead(this);
        return TRUE;
    }

    BOOL bFound = FALSE;
    POSITION pos;
    for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pNode = m_containerChildList.GetNext(pos);
        CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);

        if (pContNode != NULL)
        {
            BOOL bTemp;
            bTemp = pContNode->FindNode(lpszPath, foundNodeList);
            if (!bFound)
            {
                bFound = bTemp;
            }
        }
    }
    return bFound;
}

int CADSIEditConnectionNode::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = 0;
    switch (m_nState)
    {
    case notLoaded:
        nIndex = SERVER_IMAGE_NOT_LOADED;
        break;
    case loading:
        nIndex = SERVER_IMAGE_LOADING;
        break;
    case loaded:
        nIndex = SERVER_IMAGE_LOADED;
        break;
    case unableToLoad:
        nIndex = SERVER_IMAGE_UNABLE_TO_LOAD;
        break;
    case accessDenied:
        nIndex = SERVER_IMAGE_ACCESS_DENIED;
        break;
    default:
        ASSERT(FALSE);
    }
    return nIndex;
}

void CADSIEditConnectionNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
    switch (m_nState)
    {
    case notLoaded:
    case loaded:
    case unableToLoad:
    case accessDenied:
    {
        m_nState = loading;
        m_dwErr = 0;
    }
    break;
    case loading:
    {
        if (m_dwErr == 0)
            m_nState = loaded;
        else if (m_dwErr == ERROR_ACCESS_DENIED)
            m_nState = accessDenied;
        else 
            m_nState = unableToLoad;
    }
    break;
    default:
        ASSERT(FALSE);
    }
    VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
    VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}


BOOL CADSIEditConnectionNode::OnRefresh(CComponentDataObject* pComponentData,
                                        CNodeList* pNodeList)
{
  BOOL bRet = FALSE;

  DWORD dwCount = 0;
  if (pNodeList == NULL)
  {
    dwCount = 1;
  }
  else
  {
    dwCount = pNodeList->GetCount();
  }

  if (dwCount > 1) // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
  else if (dwCount  == 1) // single selection
  {
      if(CContainerNode::OnRefresh(pComponentData, pNodeList))
      {
          CADSIEditContainerNode * pNextNode;
          POSITION pos = m_containerChildList.GetHeadPosition();
          while (pos != NULL)
          {
              pNextNode = dynamic_cast<CADSIEditContainerNode*>(m_containerChildList.GetNext(pos));
              ASSERT(pNextNode != NULL);

        CNodeList nodeList;
        nodeList.AddTail(pNextNode);

              pNextNode->OnRefresh(pComponentData, &nodeList);
          }
          return TRUE;
      }
  }
    return FALSE;
}


HRESULT CADSIEditConnectionNode::OnCommand(long nCommandID, 
                                           DATA_OBJECT_TYPES type, 
                                                           CComponentDataObject* pComponentData,
                                           CNodeList* pNodeList)
{
  ASSERT (pNodeList->GetCount() == 1); // should only be a single selection

    switch (nCommandID)
    {
    case IDM_SETTINGS_CONNECTION : 
        OnSettings(pComponentData);
        break;
    case IDM_REMOVE_CONNECTION :
        OnRemove(pComponentData);
        break;
    case IDM_NEW_OBJECT :
        OnCreate(pComponentData);
        break;
    case IDM_FILTER :
        OnFilter(pComponentData);
        break;
  case IDM_UPDATE_SCHEMA :
    OnUpdateSchema();
    break;
    case IDM_NEW_QUERY :
        OnNewQuery(pComponentData);
        break;
  default:
            ASSERT(FALSE); // Unknown command!
            return E_FAIL;
    }
  return S_OK;
}

void CADSIEditConnectionNode::OnUpdateSchema()
{
  // Force an update of the schema cache
  CString szRootDSE;
  CConnectionData* pConnectData = GetConnectionData();

  CComPtr<IADs> spDirObject;
  HRESULT hr = GetRootDSEObject(pConnectData, &spDirObject);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

  VARIANT var;
  var.vt = VT_I4;
  var.lVal = 1;
  hr = spDirObject->Put(CComBSTR(L"updateSchemaNow"), var);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

  CString szSchema;
  pConnectData->GetAbstractSchemaPath(szSchema);
  szSchema = szSchema.Left(szSchema.GetLength()- 1);
  CComPtr<IADs> spSchemaObject;
    HRESULT hCredResult;
    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             szSchema,
                                             IID_IADs, 
                                             (LPVOID*) &spSchemaObject,
                                             NULL,
                                             hCredResult
                                            );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return;
    }

  hr = spSchemaObject->GetInfo();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
  }

  //
  // Now clear the schema cache
  //
  m_SchemaCache.Clear();

  ADSIEditMessageBox(IDS_SCHEMA_UPDATE_SUCCESSFUL, MB_OK);
}

void CADSIEditConnectionNode::OnNewQuery(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;

   CString sConnectPath;
   GetADsObject()->GetPath(sConnectPath);
   CConnectionData* pConnectData = GetConnectionData();
   CCredentialObject* pCredObject = pConnectData->GetCredentialObject();
   CString szServer;
   pConnectData->GetDomainServer(szServer);

   CADSIEditQueryDialog queryDialog(szServer, sConnectPath, pCredObject);
   if (queryDialog.DoModal() == IDOK)
   {
      BOOL bOneLevel;
      CString sQueryString, sName, sPath;
      queryDialog.GetResults(sName, sQueryString, sPath, &bOneLevel);

      CADSIEditConnectionNode* pConnectNode = GetADsObject()->GetConnectionNode();

      CADsObject* pObject = new CADsObject();
      if (pObject)
      {
         CADSIEditQueryData *pQueryData = new CADSIEditQueryData();
         if (pQueryData)
         {

            // Name
            pObject->SetName(sName);
            pQueryData->SetName(sName);

            // Set the root path of the query string
            pObject->SetPath(sPath);
            pQueryData->SetRootPath(sPath);

            // Set the query string
            pQueryData->SetFilter(sQueryString);

            pObject->SetIntermediateNode(TRUE);
            pObject->SetContainer(TRUE);
            pObject->SetComplete(TRUE);
            pObject->SetConnectionNode(pConnectNode);

            // Set the scope of the query
            ADS_SCOPEENUM scope;
            scope = (bOneLevel) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE;
            pQueryData->SetScope(scope);

            // Create the query node with imbedded objects
            CADSIEditQueryNode* pNewQueryNode = new CADSIEditQueryNode(pObject, pQueryData);
            if (pNewQueryNode)
            {

               //
               // Set the display name
               //
               CString sDisplayName;
               pQueryData->GetDisplayName(sDisplayName);
               pNewQueryNode->SetDisplayName(sDisplayName);

               //
               // Add to connection node's list of queries
               //
               pConnectNode->AddQueryToList(pQueryData);

               if (pConnectNode->IsExpanded())
               {
                  VERIFY(pConnectNode->AddChildToListAndUI(pNewQueryNode, pComponentData));
                  pComponentData->SetDescriptionBarText(this);
               }
            }
            else
            {
               delete pObject;
               pObject = 0;

               delete pQueryData;
               pQueryData = 0;
            }
         }
         else
         {
            delete pObject;
            pObject = 0;
         }
      }
   }
}

void CADSIEditConnectionNode::OnFilter(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;
    CADSIFilterDialog filterDialog(m_pConnectData);
    if (filterDialog.DoModal() == IDOK)
    {
    CNodeList nodeList;
    nodeList.AddTail(this);
        OnRefresh(pComponentData, &nodeList);
    }
}

void CADSIEditConnectionNode::OnCreate(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;
    CCreatePageHolder* pHolder = new CCreatePageHolder(GetContainer(), this, pComponentData);
    ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
    pHolder->DoModalWizard();
}

BOOL CADSIEditConnectionNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                                   BOOL* pbHideVerb, 
                                                   CNodeList* pNodeList)
{
    *pbHideVerb = TRUE; // always hid the verb
    return FALSE;
}

BOOL CADSIEditConnectionNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
                                                                                     long *pInsertionAllowed)
{
    if (IsThreadLocked() || IsSheetLocked())
    {
        pContextMenuItem->fFlags = MF_GRAYED;
        return TRUE;
    }

    if (GetConnectionData()->GetFilter()->InUse())
    {
        pContextMenuItem->fFlags = MF_CHECKED;
        return TRUE;
    }
    return TRUE;
}

HRESULT CADSIEditConnectionNode::OnRename(CComponentDataObject* pComponentData,
                                         LPWSTR lpszNewName)
{
   HRESULT hr = S_OK;
   BOOL bLocked = IsThreadLocked();
   ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
   if (bLocked)
   {
      return hr; 
   }

   if (!lpszNewName)
   {
      return E_INVALIDARG;
   }

   CString szDisplayExtra;
    m_pConnectData->GetDomainServer(szDisplayExtra);
    szDisplayExtra = L" [" + szDisplayExtra + L"]";
   
   m_pConnectData->SetName(lpszNewName);
   SetDisplayName(lpszNewName + szDisplayExtra);

   return hr;
}
 

void CADSIEditConnectionNode::OnRemove(CComponentDataObject* pComponentData)
{
    CString sLoadString, sCaption;

    // NOTICE-2002/03/01-artm  CString can throw out of memory exception,
    // but that needs to be handled at a higher level so don't worry about
    // it here.
    if (sLoadString.LoadString(IDS_MSG_REMOVE_CONNECTION))
    {
        sCaption.Format((LPWSTR)(LPCWSTR)sLoadString, GetDisplayName());
    }

    if (ADSIEditMessageBox(sCaption, MB_YESNO | MB_DEFBUTTON2) == IDYES)
    {
        if (IsSheetLocked())
        {
            if (!CanCloseSheets())
                return;
            pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
        }
        ASSERT(!IsSheetLocked());

        // now remove from the UI
        DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(GetContainer());
    pComponentData->UpdateResultPaneView(GetContainer());

        delete this; // gone
    }
}

void CADSIEditConnectionNode::OnSettings(CComponentDataObject* pComponentData)
{
  CWaitCursor cursor;
   CThemeContextActivator activator;
    CComponentDataObject* pComponentDataObject = 
            ((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
    ASSERT(pComponentDataObject != NULL);
    
    CContainerNode* pContNode = dynamic_cast<CContainerNode*>(GetContainer());
    ASSERT(pContNode != NULL);

    CADSIEditConnectDialog ConnectDialog(pContNode, 
                                                     this, 
                                                     pComponentDataObject,
                                                     m_pConnectData);
    if (ConnectDialog.DoModal() == IDOK)
    {
    cursor.Restore();
        if (HasQueries())
        {
            if (AfxMessageBox(IDS_MSG_EXISTING_QUERIES, MB_YESNO) == IDYES)
            {
                RemoveAllQueriesFromList();
            }
        }
    CNodeList nodeList;
    nodeList.AddTail(this);
        OnRefresh(pComponentData, &nodeList);
    }

}

BOOL CADSIEditConnectionNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                                    BOOL* pbHide, 
                                                    CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    *pbHide = FALSE;
    return !IsThreadLocked();
}


HRESULT CADSIEditConnectionNode::CreateFromStream(IStream* pStm, CADSIEditConnectionNode** ppConnectionNode)
{
    WCHAR szBuffer[MAX_CONNECT_NAME_LENGTH + 1];
    ULONG nLen; // WCHAR counting NULL
    ULONG cbRead;

    VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
    ASSERT(cbRead == sizeof(UINT));
    VERIFY(SUCCEEDED(pStm->Read((void*)szBuffer,sizeof(WCHAR)*nLen, &cbRead)));
    ASSERT(cbRead == sizeof(WCHAR)*nLen);

    CConnectionData* pConnect = CConnectionData::Load(pStm);
    *ppConnectionNode = new CADSIEditConnectionNode(pConnect);
    ASSERT(*ppConnectionNode != NULL);

    CString szDisplayExtra, szDisplay;
    pConnect->GetDomainServer(szDisplayExtra);
    szDisplay = CString(szBuffer) + L" [" + szDisplayExtra + L"]";
    (*ppConnectionNode)->SetDisplayName(szDisplay);
    (*ppConnectionNode)->SetConnectionNode(*ppConnectionNode);
    (*ppConnectionNode)->LoadQueryListFromStream(pStm);

    return S_OK;
}


HRESULT CADSIEditConnectionNode::SaveToStream(IStream* pStm)
{
    // for each connection name, write # of chars+NULL, and then the name
    ULONG cbWrite;
    CString szName;
    m_pConnectData->GetName(szName);
    SaveStringToStream(pStm, szName);

    m_pConnectData->Save(pStm);
    SaveQueryListToStream(pStm);

    return S_OK;
}

void CADSIEditConnectionNode::LoadQueryListFromStream(IStream* pStm)
{
    ULONG cbRead;
    int iCount;

    VERIFY(SUCCEEDED(pStm->Read((void*)&iCount,sizeof(int), &cbRead)));
    ASSERT(cbRead == sizeof(int));

    for (int idx = 0; idx < iCount; idx++)
    {
        CADSIEditQueryData* pQueryData = new CADSIEditQueryData();
        
        CString sName, sQueryString, sPath;
        // FUTURE-2002/03/01-artm  Function LoadStringFromStream() should return
        // success/error code and this function should call it.
        // Who knows what kind of stream we've been given and how it could
        // fail????
        LoadStringFromStream(pStm, sName);
        LoadStringFromStream(pStm, sQueryString);
        LoadStringFromStream(pStm, sPath);

        pQueryData->SetName(sName);
        pQueryData->SetFilter(sQueryString);
        CString sRootPath;
        BuildQueryPath(sPath, sRootPath);
        pQueryData->SetRootPath(sRootPath);

        ADS_SCOPEENUM scope;
        VERIFY(SUCCEEDED(pStm->Read((void*)&scope, sizeof(ADS_SCOPEENUM), &cbRead)));
        ASSERT(cbRead == sizeof(ADS_SCOPEENUM));

        pQueryData->SetScope(scope);

        AddQueryToList(pQueryData);
    }
}

void CADSIEditConnectionNode::BuildQueryPath(const CString& sPath, CString& sRootPath)
{
    CConnectionData* pConnectData = GetConnectionData();

    CString sServer, sLDAP, sPort, sTemp;
    pConnectData->GetDomainServer(sServer);
    pConnectData->GetLDAP(sLDAP);
    pConnectData->GetPort(sPort);

    if (sServer != _T(""))
    {
        sTemp = sLDAP + sServer;
        if (sPort != _T(""))
        {
            sTemp = sTemp + _T(":") + sPort + _T("/");
        }
        else
        {
            sTemp = sTemp + _T("/");
        }
        sRootPath = sTemp + sPath;
    }
    else
    {
        sRootPath = sLDAP + sPath;
    }

}

void CADSIEditConnectionNode::SaveQueryListToStream(IStream* pStm)
{
    ULONG cbWrite;
    int iCount = m_queryList.GetCount();
    VERIFY(SUCCEEDED(pStm->Write((void*)&iCount, sizeof(int),&cbWrite)));
    ASSERT(cbWrite == sizeof(int));
    
    POSITION pos = m_queryList.GetHeadPosition();
    while (pos != NULL)
    {
        CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);
        ASSERT(pQueryData != NULL);

        ADS_SCOPEENUM scope;
        CString sName, sQueryString, sRootPath;
        pQueryData->GetName(sName);
        pQueryData->GetFilter(sQueryString);
        pQueryData->GetDisplayPath(sRootPath);
        scope = pQueryData->GetScope();

        // save the query info to stream
        SaveStringToStream(pStm, sName);
        SaveStringToStream(pStm, sQueryString);
        SaveStringToStream(pStm, sRootPath);

        // Save the scope
        VERIFY(SUCCEEDED(pStm->Write((void*)&scope, sizeof(ADS_SCOPEENUM),&cbWrite)));
        ASSERT(cbWrite == sizeof(ADS_SCOPEENUM));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\connection.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connection.h
//
//--------------------------------------------------------------------------


#ifndef _CONNECTION_H
#define _CONNECTION_H

#include "editor.h"
#include "resource.h"
#include "snapdata.h"
#include "querynode.h"
#include "schemacache.h"

///////////////////////////////////////////////////////////////////

#define MAX_CONNECT_NAME_LENGTH 255

///////////////////////////////////////////////////////////////////
// CADSIConnectionNode

class CADSIEditConnectionNode : public CADSIEditContainerNode
{
public:

	CADSIEditConnectionNode(CConnectionData* pConnectData) 
	{
		m_pConnectData = new CConnectionData(pConnectData);
    HRESULT hr = m_SchemaCache.Initialize();
    ASSERT(SUCCEEDED(hr));
	}
	
	CADSIEditConnectionNode(LPCWSTR lpszDisplayName) 
	{ 
		SetDisplayName(lpszDisplayName); 
    HRESULT hr = m_SchemaCache.Initialize();
    ASSERT(SUCCEEDED(hr));
	}

	~CADSIEditConnectionNode();

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	void EnumerateQueries();
	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem, 
                        long *pInsertionAllowed);
	virtual void OnSettings(CComponentDataObject* pComponentData);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type,
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
   virtual HRESULT OnRename(CComponentDataObject* pComponentData, PWSTR pszNewName);
	virtual void OnRemove(CComponentDataObject* pComponentData);
	virtual void OnFilter(CComponentDataObject* pComponentData);
  virtual void OnUpdateSchema();
	virtual void OnNewQuery(CComponentDataObject* pComponentData);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual void OnCreate(CComponentDataObject* pComponentData);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                             