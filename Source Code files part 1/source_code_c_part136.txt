gs
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );

    if (i < MinLength) {

        //
        //  We know the offset of the first character which is different.
        //

        return ((NameA->Buffer[ i / 2 ] < NameB->Buffer[ i / 2 ]) ?
                 LessThan :
                 GreaterThan);
    }

    //
    //  The names match up to the length of the shorter string.
    //  The shorter string lexically appears first.
    //

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\pnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Plug and Play routines for UDFS called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Jul-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_PNP)

NTSTATUS
UdfPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonPnp)
#pragma alloc_text(PAGE, UdfPnpCancelRemove)
#pragma alloc_text(PAGE, UdfPnpQueryRemove)
#pragma alloc_text(PAGE, UdfPnpRemove)
#pragma alloc_text(PAGE, UdfPnpSurpriseRemove)
#endif


NTSTATUS
UdfCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing PnP operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN PassThrough = FALSE;
    
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT OurDeviceObject;
    PVCB Vcb;

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //
    
    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;
    
    //
    //  IO holds a handle reference on our VDO and holds the device lock, which 
    //  syncs us against mounts/verifies.  However we hold no reference on the 
    //  volume, which may already have been torn down (and the Vpb freed), for 
    //  example by a force dismount. Check for this condition. We must hold this
    //  lock until the pnp worker functions take additional locks/refs on the Vcb.
    //

    UdfAcquireUdfData( IrpContext);
    
    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.
    //
    
    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType( &OurDeviceObject->Vcb ) != UDFS_NTC_VCB) {
        
        //
        //  We were called with something we don't understand.
        //
        
        Status = STATUS_INVALID_PARAMETER;
        UdfReleaseUdfData( IrpContext);
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Force all PnP operations to be synchronous.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    Vcb = &OurDeviceObject->Vcb;
    
    //
    //  Check that the Vcb hasn't already been deleted.  If so,  just pass the
    //  request through to the driver below,  we don't need to do anything.
    //

    if (NULL == Vcb->Vpb) {

        PassThrough = TRUE;
    }
    else {

        //
        //  Case on the minor code.
        //
        
        switch ( IrpSp->MinorFunction ) {

            case IRP_MN_QUERY_REMOVE_DEVICE:
                
                Status = UdfPnpQueryRemove( IrpContext, Irp, Vcb );
                break;
            
            case IRP_MN_SURPRISE_REMOVAL:
            
                Status = UdfPnpSurpriseRemove( IrpContext, Irp, Vcb );
                break;

            case IRP_MN_REMOVE_DEVICE:

                Status = UdfPnpRemove( IrpContext, Irp, Vcb );
                break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
        
                Status = UdfPnpCancelRemove( IrpContext, Irp, Vcb );
                break;

            default:
                PassThrough = TRUE;
                break;
        }
    }

    if (PassThrough) {

        UdfReleaseUdfData( IrpContext);
    
        //
        //  Just pass the IRP on.  As we do not need to be in the
        //  way on return, ellide ourselves out of the stack.
        //
        
        IoSkipCurrentIrpStackLocation( Irp );

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);
        
        //
        //  Cleanup our Irp Context.  The driver has completed the Irp.
        //
    
        UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
     }
        
    return Status;
}


NTSTATUS
UdfPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP query remove operation.  The filesystem
    is responsible for answering whether there are any reasons it sees
    that the volume can not go away (and the device removed).  Initiation
    of the dismount begins when we answer yes to this question.
    
    Query will be followed by a Cancel or Remove.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being queried.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  Having said yes to a QUERY, any communication with the
    //  underlying storage stack is undefined (and may block)
    //  until the bounding CANCEL or REMOVE is sent.
    //
    //  Acquire the global resource so that we can try to vaporize the volume, 
    //  and the vcb resource itself.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Drop a reference on the Vcb to keep it around after we drop the locks.
    //
    
    UdfLockVcb( IrpContext, Vcb);
    Vcb->VcbReference += 1;
    UdfUnlockVcb( IrpContext, Vcb);

    UdfReleaseUdfData( IrpContext);

    Status = UdfLockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  Reacquire the global lock,  which means dropping the Vcb resource.
    //
    
    UdfReleaseVcb( IrpContext, Vcb );
    
    UdfAcquireUdfData( IrpContext );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Remove our extra reference.
    //
    
    UdfLockVcb( IrpContext, Vcb);
    Vcb->VcbReference -= 1;
    UdfUnlockVcb( IrpContext, Vcb);

    if (NT_SUCCESS( Status )) {

        //
        //  We need to pass this down before starting the dismount, which
        //  could disconnect us immediately from the stack.
        //
        
        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //
    
        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp,
                                UdfPnpCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request and wait.
        //

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

        if (Status == STATUS_PENDING) {

            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Now if no one below us failed already, initiate the dismount
        //  on this volume, make it go away.  PnP needs to see our internal
        //  streams close and drop their references to the target device.
        //
        //  Since we were able to lock the volume, we are guaranteed to
        //  move this volume into dismount state and disconnect it from
        //  the underlying storage stack.  The force on our part is actually
        //  unnecesary, though complete.
        //
        //  What is not strictly guaranteed, though, is that the closes
        //  for the metadata streams take effect synchronously underneath
        //  of this call.  This would leave references on the target device
        //  even though we are disconnected!
        //

        if (NT_SUCCESS( Status )) {
            
            VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );
    
            ASSERT( !VcbPresent || Vcb->VcbCondition == VcbDismountInProgress );
        }
        
        //
        //  Note: Normally everything will complete and the internal streams will 
        //  vaporise.  However there is some code in the system which drops additional
        //  references on file objects,  including our internal stream file objects,
        //  for tracing purposes.  If that happens to run concurrently with our
        //  teardown, our internal streams will not vaporise until those references
        //  are removed.  So it's possible that the volume still remains at this 
        //  point.  The pnp query remove will fail due references on the device.
        //  To be cleaner we will return an error here.  We could pend the pnp
        //  IRP until the volume goes away, but since we don't know when that will
        //  be, and this is a very rare case, we'll just fail the query.
        //
        //  The reason this is the case is that handles/fileobjects place a reference
        //  on the device objects they overly.  In the filesystem case, these references
        //  are on our target devices.  PnP correcly thinks that if references remain
        //  on the device objects in the stack that someone has a handle, and that this
        //  counts as a reason to not succeed the query - even though every interrogated
        //  driver thinks that it is OK.
        //
        
        if (NT_SUCCESS( Status) && VcbPresent && (Vcb->VcbReference != 0)) {
        
            Status = STATUS_DEVICE_BUSY;
        }
    }
    
    //
    //  Release the Vcb if it could still remain.
    //

    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP if neccesary.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP remove operation.  This is our notification
    that the underlying storage device for the volume we have is gone, and
    an excellent indication that the volume will never reappear. The filesystem
    is responsible for initiation or completion the dismount.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_UDFDATA;
    
    //
    //  REMOVE - a storage device is now gone.  We either got
    //  QUERY'd and said yes OR got a SURPRISE OR a storage
    //  stack failed to spin back up from a sleep/stop state
    //  (the only case in which this will be the first warning).
    //
    //  Note that it is entirely unlikely that we will be around
    //  for a REMOVE in the first two cases, as we try to intiate
    //  dismount.
    //
    
    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  The device will be going away.  Remove our lock and find
    //  out if we ever had one in the first place.
    //

    Status = UdfUnlockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  If the volume had not been locked, we must invalidate the
    //  volume to ensure it goes away properly.  The remove will
    //  succeed.
    //

    if (!NT_SUCCESS( Status )) {

        UdfLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            
            UdfSetVcbCondition( Vcb, VcbInvalid);
        }
        
        UdfUnlockVcb( IrpContext, Vcb );
        
        Status = STATUS_SUCCESS;
    }
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            UdfPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding if we were not preceeded by a QUERY.
    //
    //  PnP will take care of disconnecting this stack if we
    //  couldn't get off of it immediately.
    //

    VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );

    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP surprise remove operation.  This is another
    type of notification that the underlying storage device for the volume we
    have is gone, and is excellent indication that the volume will never reappear.
    The filesystem is responsible for initiation or completion the dismount.
    
    For the most part, only "real" drivers care about the distinction of a
    surprise remove, which is a result of our noticing that a user (usually)
    physically reached into the machine and pulled something out.
    
    Surprise will be followed by a Remove when all references have been shut down.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_UDFDATA;
    
    //
    //  SURPRISE - a device was physically yanked away without
    //  any warning.  This means external forces.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        
    //
    //  Invalidate the volume right now.
    //
    //  The intent here is to make every subsequent operation
    //  on the volume fail and grease the rails toward dismount.
    //  By definition there is no going back from a SURPRISE.
    //
        
    UdfLockVcb( IrpContext, Vcb );
    
    if (Vcb->VcbCondition != VcbDismountInProgress) {

        UdfSetVcbCondition( Vcb, VcbInvalid);
    }
    
    UdfUnlockVcb( IrpContext, Vcb );
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            UdfPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }
    
    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding since this is an out of band notification.
    //

    VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );
    
    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP cancel remove operation.  This is our
    notification that a previously proposed remove (query) was eventually
    vetoed by a component.  The filesystem is responsible for cleaning up
    and getting ready for more IO.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  CANCEL - a previous QUERY has been rescinded as a result
    //  of someone vetoing.  Since PnP cannot figure out who may
    //  have gotten the QUERY (think about it: stacked drivers),
    //  we must expect to deal with getting a CANCEL without having
    //  seen the QUERY.
    //
    //  For UDFS, this is quite easy.  In fact, we can't get a
    //  CANCEL if the underlying drivers succeeded the QUERY since
    //  we disconnect the Vpb on our dismount initiation.  This is
    //  actually pretty important because if PnP could get to us
    //  after the disconnect we'd be thoroughly unsynchronized
    //  with respect to the Vcb getting torn apart - merely referencing
    //  the volume device object is insufficient to keep us intact.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    UdfReleaseUdfData( IrpContext);
    
    //
    //  Unlock the volume.  This is benign if we never had seen
    //  a QUERY.
    //

    (VOID) UdfUnlockVolumeInternal( IrpContext, Vcb, NULL );

    UdfReleaseVcb( IrpContext, Vcb );

    //
    //  Send the request.  The underlying driver will complete the
    //  IRP.  Since we don't need to be in the way, simply ellide
    //  ourselves out of the IRP stack.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )
{
    PKEVENT Event = (PKEVENT) Contxt;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\prefxsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Udfs Prefix support routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     8-Oct-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_PREFXSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_READ)

//
//  Local support routines.
//

PLCB
UdfFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

BOOLEAN
UdfInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PLCB NameLink
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfFindNameLink)
#pragma alloc_text(PAGE, UdfFindPrefix)
#pragma alloc_text(PAGE, UdfInitializeLcbFromDirContext)
#pragma alloc_text(PAGE, UdfInsertNameLink)
#pragma alloc_text(PAGE, UdfInsertPrefix)
#pragma alloc_text(PAGE, UdfRemovePrefix)
#endif


PLCB
UdfInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN ShortNameMatch,
    IN BOOLEAN IgnoreCase,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine inserts an Lcb linking the two Fcbs together.

Arguments:

    Fcb - This is the Fcb whose name is being inserted into the tree.

    Name - This is the name for the component.
    
    ShortNameMatch - Indicates whether this name was found on an explicit 8.3 search

    IgnoreCase - Indicates if we should insert into the case-insensitive tree.

    ParentFcb - This is the ParentFcb.  The prefix tree is attached to this.

Return Value:

    PLCB - the Lcb inserted.

--*/

{
    PLCB Lcb;
    PRTL_SPLAY_LINKS *TreeRoot;
    PLIST_ENTRY ListLinks;
    ULONG Flags;

    PWCHAR NameBuffer;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    ASSERT_EXCLUSIVE_FCB( Fcb );
    ASSERT_EXCLUSIVE_FCB( ParentFcb );
    ASSERT_FCB_INDEX( ParentFcb );

    //
    //  It must be the case that an index Fcb is only referenced by a single index.  Now
    //  we walk the child's Lcb queue to insure that if any prefixes have already been
    //  inserted, they all refer to the index Fcb we are linking to.  This is the only way
    //  we can detect directory cross-linkage.
    //

    if (SafeNodeType( Fcb ) == UDFS_NTC_FCB_INDEX) {

        for (ListLinks = Fcb->ParentLcbQueue.Flink;
             ListLinks != &Fcb->ParentLcbQueue;
             ListLinks = ListLinks->Flink) {

            Lcb = CONTAINING_RECORD( ListLinks, LCB, ChildFcbLinks );

            if (Lcb->ParentFcb != ParentFcb) {

                UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }
        }
    }
    
    //
    //  Capture the separate cases.
    //

    if (IgnoreCase) {

        TreeRoot = &ParentFcb->IgnoreCaseRoot;
        Flags = LCB_FLAG_IGNORE_CASE;

    } else {

        TreeRoot = &ParentFcb->ExactCaseRoot;
        Flags = 0;
    }

    if (ShortNameMatch) {

        SetFlag( Flags, LCB_FLAG_SHORT_NAME );
    }

    //
    //  Allocate space for the Lcb.
    //

    if ( sizeof( LCB ) + Name->Length > SIZEOF_LOOKASIDE_LCB ) {
    
        Lcb = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                        sizeof( LCB ) + Name->Length,
                                        TAG_LCB );

        SetFlag( Flags, LCB_FLAG_POOL_ALLOCATED );

    } else {

        Lcb = ExAllocateFromPagedLookasideList( &UdfLcbLookasideList );
    }

    //
    //  Set the type and size.
    //

    Lcb->NodeTypeCode = UDFS_NTC_LCB;
    Lcb->NodeByteSize = sizeof( LCB ) + Name->Length;

    //
    //  Initialize the name-based file attributes.
    //
    
    Lcb->FileAttributes = 0;
    
    //
    //  Set up the filename in the Lcb.
    //

    Lcb->FileName.Length =
    Lcb->FileName.MaximumLength = Name->Length;

    Lcb->FileName.Buffer = Add2Ptr( Lcb, sizeof( LCB ), PWCHAR );

    RtlCopyMemory( Lcb->FileName.Buffer,
                   Name->Buffer,
                   Name->Length );
    
    //
    //  Insert the Lcb into the prefix tree.
    //
    
    Lcb->Flags = Flags;
    
    if (!UdfInsertNameLink( IrpContext,
                            TreeRoot,
                            Lcb )) {

        //
        //  This will very rarely occur.
        //

        UdfFreePool( &Lcb );

        Lcb = UdfFindNameLink( IrpContext,
                               TreeRoot,
                               Name );

        if (Lcb == NULL) {

            //
            //  Even worse.
            //

            UdfRaiseStatus( IrpContext, STATUS_DRIVER_INTERNAL_ERROR );
        }

        return Lcb;
    }

    //
    //  Link the Fcbs together through the Lcb.
    //

    Lcb->ParentFcb = ParentFcb;
    Lcb->ChildFcb = Fcb;

    InsertHeadList( &ParentFcb->ChildLcbQueue, &Lcb->ParentFcbLinks );
    InsertHeadList( &Fcb->ParentLcbQueue, &Lcb->ChildFcbLinks );

    //
    //  Initialize the reference count.
    //

    Lcb->Reference = 0;
    
    return Lcb;
}


VOID
UdfRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called to remove a given prefix of an Fcb.

Arguments:

    Lcb - the prefix being removed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    //
    //  Check the acquisition of the two Fcbs.
    //

    ASSERT_EXCLUSIVE_FCB_OR_VCB( Lcb->ParentFcb );
    ASSERT_EXCLUSIVE_FCB_OR_VCB( Lcb->ChildFcb );

    //
    //  Now remove the linkage and delete the Lcb.
    //
    
    RemoveEntryList( &Lcb->ParentFcbLinks );
    RemoveEntryList( &Lcb->ChildFcbLinks );

    if (FlagOn( Lcb->Flags, LCB_FLAG_IGNORE_CASE )) {

        Lcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Lcb->Links );
    
    } else {

        Lcb->ParentFcb->ExactCaseRoot = RtlDelete( &Lcb->Links );
    }

    if (FlagOn( Lcb->Flags, LCB_FLAG_POOL_ALLOCATED )) {

        ExFreePool( Lcb );

    } else {

        ExFreeToPagedLookasideList( &UdfLcbLookasideList, Lcb );
    }
    
    return;
}


PLCB
UdfFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine begins from the given CurrentFcb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Fcb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.  On entry this is the
        Fcb to examine.
        
    RemainingName - Supplies a buffer to store the exact case of the name being
        searched for.  Initially will contain the upcase name based on the
        IgnoreCase flag.

    IgnoreCase - Indicates if we are doing a case-insensitive compare.

Return Value:

    The Lcb used to find the current Fcb, NULL if we didn't find any prefix
    Fcbs.

--*/

{
    UNICODE_STRING LocalRemainingName;
    UNICODE_STRING FinalName;

    PLCB NameLink;
    PLCB CurrentLcb = NULL;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( *CurrentFcb );
    ASSERT_EXCLUSIVE_FCB( *CurrentFcb );

    //
    //  Make a local copy of the input strings.
    //

    LocalRemainingName = *RemainingName;

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        //
        //  If there are no characters left or we are not at an IndexFcb then
        //  return immediately.
        //

        if ((LocalRemainingName.Length == 0) ||
            (SafeNodeType( *CurrentFcb ) != UDFS_NTC_FCB_INDEX)) {

            return CurrentLcb;
        }

        //
        //  Split off the next component from the name.
        //

        UdfDissectName( IrpContext,
                        &LocalRemainingName,
                        &FinalName );

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (IgnoreCase) {

            NameLink = UdfFindNameLink( IrpContext,
                                        &(*CurrentFcb)->IgnoreCaseRoot,
                                        &FinalName );

        } else {

            NameLink = UdfFindNameLink( IrpContext,
                                        &(*CurrentFcb)->ExactCaseRoot,
                                        &FinalName );
        }

        //
        //  If we didn't find a match then exit.
        //

        if (NameLink == NULL) { 

            break;
        }

        CurrentLcb = NameLink;

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.Buffer,
                           NameLink->FileName.Buffer,
                           NameLink->FileName.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = LocalRemainingName;

        //
        //  Move down to the next component in the tree.  Acquire without waiting.
        //  If this fails then lock the Fcb to reference this Fcb and then drop
        //  the parent and acquire the child.
        //

        ASSERT( NameLink->ParentFcb == *CurrentFcb );

        if (!UdfAcquireFcbExclusive( IrpContext, NameLink->ChildFcb, TRUE )) {

            //
            //  If we can't wait then raise CANT_WAIT.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            UdfLockVcb( IrpContext, IrpContext->Vcb );
            NameLink->ChildFcb->FcbReference += 1;
            NameLink->Reference += 1;
            UdfUnlockVcb( IrpContext, IrpContext->Vcb );

            UdfReleaseFcb( IrpContext, *CurrentFcb );
            UdfAcquireFcbExclusive( IrpContext, NameLink->ChildFcb, FALSE );

            UdfLockVcb( IrpContext, IrpContext->Vcb );
            NameLink->ChildFcb->FcbReference -= 1;
            NameLink->Reference -= 1;
            UdfUnlockVcb( IrpContext, IrpContext->Vcb );

        } else {

            UdfReleaseFcb( IrpContext, *CurrentFcb );
        }

        *CurrentFcb = NameLink->ChildFcb;
    }

    return CurrentLcb;
}



VOID            
UdfInitializeLcbFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine performs common initialization of Lcbs from found directory
    entries.

Arguments:

    Lcb - the Lcb to initialize.
    
    DirContext - the directory enumeration context, enumerated to the FID associated
        with this Lcb.
    
Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    ASSERT( DirContext->Fid != NULL );

    //
    //  This is falling down trivial now.  Simply update the hidden flag in the Lcb.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_HIDDEN )) {

        SetFlag( Lcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
    }
}


//
//  Local support routine
//

PLCB
UdfFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PLCB - The name link found or NULL if there is no match.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PLCB Node;
    PRTL_SPLAY_LINKS Links;

    PAGED_CODE();

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, LCB, Links );

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = UdfFullCompareNames( IrpContext, &Node->FileName, Name );

        //
        //  See if they don't match
        //

        if (Comparison == GreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == LessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay( Links );

            return Node;
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}


//
//  Local support routine
//

BOOLEAN
UdfInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PLCB NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PLCB Node;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

    Node = CONTAINING_RECORD( *RootNode, LCB, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.
        //

        Comparison = UdfFullCompareNames( IrpContext, &Node->FileName, &NameLink->FileName );

        //
        //  If we found the entry, return immediately.
        //

        if (Comparison == EqualTo) { return FALSE; }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          LCB,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          LCB,
                                          Links );
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\lockctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Udfs called
    by the Fsd/Fsp dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     20-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_LOCKCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonLockControl)
#pragma alloc_text(PAGE, UdfFastLock)
#pragma alloc_text(PAGE, UdfFastUnlockAll)
#pragma alloc_text(PAGE, UdfFastUnlockAllByKey)
#pragma alloc_text(PAGE, UdfFastUnlockSingle)
#endif


NTSTATUS
UdfCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We check whether we can proceed based on the state of the file oplocks.
    //  This call might post the irp for us.
    //

    Status = FsRtlCheckOplock( &Fcb->Oplock,
                               Irp,
                               IrpContext,
                               UdfOplockComplete,
                               NULL );

    //
    //  If we don't get success then the oplock package completed the request.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Verify the Fcb.
    //

    UdfVerifyFcbOperation( IrpContext, Fcb );

    //
    //  If we don't have a file lock, then get one now.
    //

    if (Fcb->FileLock == NULL) { UdfCreateFileLock( IrpContext, Fcb, TRUE ); }

    //
    //  Now call the FsRtl routine to do the actual processing of the
    //  Lock request
    //

    Status = FsRtlProcessFileLock( Fcb->FileLock, Irp, NULL );

    //
    //  Set the flag indicating if Fast I/O is possible
    //

    UdfLockFcb( IrpContext, Fcb );
    Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Complete the request.
    //

    UdfCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


BOOLEAN
UdfFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;

    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    FsRtlEnterFileSystem();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to perform the lock request.
        //

        if (Results = FsRtlFastLock( Fcb->FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag if the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Fcb->IsFastIoPossible == FastIoIsPossible) {

                UdfLockFcb( NULL, Fcb );
                Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
                UdfUnlockFcb( NULL, Fcb );
            }
        }

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Fcb->FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Fcb->FileLock ) &&
            (Fcb->IsFastIoPossible != FastIoIsPossible)) {

            UdfLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
            UdfUnlockFcb( IrpContext, Fcb );
        }

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Fcb->FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Fcb->FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\nodetype.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code.  This code is the first CSHORT in the structure and is followed
    by a CSHORT containing the size, in bytes, of the structure.

    A single structure can fake polymorphism by using a set of node type codes.
    This is what the two FCB types do.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	20-May-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _UDFNODETYPE_
#define _UDFNODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define UDFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0901)
#define UDFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0902)
#define UDFS_NTC_FCB_INDEX              ((NODE_TYPE_CODE)0x0903)
#define UDFS_NTC_FCB_DATA               ((NODE_TYPE_CODE)0x0904)
#define UDFS_NTC_FCB_NONPAGED           ((NODE_TYPE_CODE)0x0905)
#define UDFS_NTC_CCB                    ((NODE_TYPE_CODE)0x0906)
#define UDFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0907)
#define UDFS_NTC_IRP_CONTEXT_LITE       ((NODE_TYPE_CODE)0x0908)
#define UDFS_NTC_LCB                    ((NODE_TYPE_CODE)0x0909)
#define UDFS_NTC_PCB                    ((NODE_TYPE_CODE)0x090a)
#define UDFS_NTC_VMCB                   ((NODE_TYPE_CODE)0x090b)


typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#ifndef NodeType
#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#endif
#ifndef SafeNodeType
#define SafeNodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif

//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  UDFS_BUG_CHECK_ values defined below and then use UdfBugCheck to bugcheck
//  the system.
//
//  We also will define the debug trace level masks here.  Set UdfsDebugTraceLevel
//  to include a given filemask to see debug information from that module when
//  compiled with debugging.
//

//
//  Not all of these are actually used in UDFS. Perhaps this list will be
//  optimized when UDFS is functionally complete.
//

#define UDFS_BUG_CHECK_ALLOCSUP          (0x00010000)
#define UDFS_BUG_CHECK_CACHESUP          (0x00020000)
#define UDFS_BUG_CHECK_CLEANUP           (0x00030000)
#define UDFS_BUG_CHECK_CLOSE             (0x00040000)
#define UDFS_BUG_CHECK_CREATE            (0x00050000)
#define UDFS_BUG_CHECK_DEVCTRL           (0x00060000)
#define UDFS_BUG_CHECK_DEVIOSUP          (0x00070000)
#define UDFS_BUG_CHECK_DIRCTRL           (0x00080000)
#define UDFS_BUG_CHECK_DIRSUP            (0x00090000)
#define UDFS_BUG_CHECK_FILEINFO          (0x000a0000)
#define UDFS_BUG_CHECK_FILOBSUP          (0x000b0000)
#define UDFS_BUG_CHECK_FSCTRL            (0x000c0000)
#define UDFS_BUG_CHECK_FSPDISP           (0x000d0000)
#define UDFS_BUG_CHECK_LOCKCTRL          (0x000e0000)
#define UDFS_BUG_CHECK_NAMESUP           (0x000f0000)
#define UDFS_BUG_CHECK_PREFXSUP          (0x00100000)
#define UDFS_BUG_CHECK_READ              (0x00110000)
#define UDFS_BUG_CHECK_RESRCSUP          (0x00120000)
#define UDFS_BUG_CHECK_STRUCSUP          (0x00130000)
#define UDFS_BUG_CHECK_UDFDATA           (0x00140000)
#define UDFS_BUG_CHECK_UDFINIT           (0x00150000)
#define UDFS_BUG_CHECK_VERFYSUP          (0x00160000)
#define UDFS_BUG_CHECK_VMCBSUP           (0x00170000)
#define UDFS_BUG_CHECK_VOLINFO           (0x00180000)
#define UDFS_BUG_CHECK_WORKQUE           (0x00190000)
#define UDFS_BUG_CHECK_COMMON            (0x001a0000)
#define UDFS_BUG_CHECK_WRITE             (0x001b0000)
#define UDFS_BUG_CHECK_FLUSH             (0x001c0000)

#define UDFS_DEBUG_LEVEL_ALLOCSUP        (0x00000001)
#define UDFS_DEBUG_LEVEL_CACHESUP        (0x00000002)
#define UDFS_DEBUG_LEVEL_CLEANUP         (0x00000004)
#define UDFS_DEBUG_LEVEL_CLOSE           (0x00000008)
#define UDFS_DEBUG_LEVEL_CREATE          (0x00000010)
#define UDFS_DEBUG_LEVEL_DEVCTRL         (0x00000020)
#define UDFS_DEBUG_LEVEL_DEVIOSUP        (0x00000040)
#define UDFS_DEBUG_LEVEL_DIRCTRL         (0x00000080)
#define UDFS_DEBUG_LEVEL_DIRSUP          (0x00000100)
#define UDFS_DEBUG_LEVEL_FILEINFO        (0x00000200)
#define UDFS_DEBUG_LEVEL_FILOBSUP        (0x00000400)
#define UDFS_DEBUG_LEVEL_FSCTRL          (0x00000800)
#define UDFS_DEBUG_LEVEL_FSPDISP         (0x00001000)
#define UDFS_DEBUG_LEVEL_LOCKCTRL        (0x00002000)
#define UDFS_DEBUG_LEVEL_NAMESUP         (0x00004000)
#define UDFS_DEBUG_LEVEL_PREFXSUP        (0x00008000)
#define UDFS_DEBUG_LEVEL_READ            (0x00010000)
#define UDFS_DEBUG_LEVEL_RESRCSUP        (0x00020000)
#define UDFS_DEBUG_LEVEL_STRUCSUP        (0x00040000)
#define UDFS_DEBUG_LEVEL_UDFDATA         (0x00080000)
#define UDFS_DEBUG_LEVEL_UDFINIT         (0x00100000)
#define UDFS_DEBUG_LEVEL_VERFYSUP        (0x00200000)
#define UDFS_DEBUG_LEVEL_VMCBSUP         (0x00400000)
#define UDFS_DEBUG_LEVEL_VOLINFO         (0x00800000)
#define UDFS_DEBUG_LEVEL_WORKQUE         (0x01000000)
#define UDFS_DEBUG_LEVEL_COMMON          (0x02000000)
#define UDFS_DEBUG_LEVEL_WRITE           (0x04000000)
#define UDFS_DEBUG_LEVEL_FLUSH           (0x08000000)

//
//  Use UNWIND for reports from exception handlers.
//

#define UDFS_DEBUG_LEVEL_UNWIND          (0x80000000)

#define UdfBugCheck(A,B,C) { KeBugCheckEx(UDFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#ifndef BUILDING_FSKDEXT

//
//  The following are the pool tags for UDFS memory allocations
//

#define TAG_CCB                         'xfdU'
#define TAG_CDROM_TOC                   'tfdU'
#define TAG_CRC_TABLE                   'CfdU'
#define TAG_ENUM_EXPRESSION             'efdU'
#define TAG_FCB_DATA                    'dfdU'
#define TAG_FCB_INDEX                   'ifdU'
#define TAG_FCB_NONPAGED                'FfdU'
#define TAG_FID_BUFFER                  'DfdU'
#define TAG_FILE_NAME                   'ffdU'
#define TAG_GENERIC_TABLE               'TfdU'
#define TAG_IO_BUFFER                   'bfdU'
#define TAG_IO_CONTEXT                  'IfdU'
#define TAG_IRP_CONTEXT                 'cfdU'
#define TAG_IRP_CONTEXT_LITE            'LfdU'
#define TAG_LCB                         'lfdU'
#define TAG_PCB                         'pfdU'
#define TAG_SHORT_FILE_NAME             'SfdU'
#define TAG_VPB                         'vfdU'
#define TAG_SPARING_MCB                 'sfdU'
#define TAG_IOCTL_BUFFER                'bfdU'

#define TAG_NSR_FSD                     '1fdU'
#define TAG_NSR_VSD                     '2fdU'
#define TAG_NSR_VDSD                    '3fdU'

#endif

#endif // _UDFNODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\resrcsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Udfs Resource acquisition routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	10-Jul-1996
    Tom Jolly       [tomjolly]  21-Jan-2000
    
Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_RESRCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAcquireForCache)
#pragma alloc_text(PAGE, UdfAcquireForCreateSection)
#pragma alloc_text(PAGE, UdfAcquireResource)
#pragma alloc_text(PAGE, UdfNoopAcquire)
#pragma alloc_text(PAGE, UdfNoopRelease)
#pragma alloc_text(PAGE, UdfReleaseForCreateSection)
#pragma alloc_text(PAGE, UdfReleaseFromCache)
#endif


BOOLEAN
UdfAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    )

/*++

Routine Description:

    This is the single routine used to acquire file system resources.  It
    looks at the IgnoreWait flag to determine whether to try to acquire the
    resource without waiting.  Returning TRUE/FALSE to indicate success or
    failure.  Otherwise it is driven by the WAIT flag in the IrpContext and
    will raise CANT_WAIT on a failure.

Arguments:

    Resource - This is the resource to try and acquire.

    IgnoreWait - If TRUE then this routine will not wait to acquire the
        resource and will return a boolean indicating whether the resource was
        acquired.  Otherwise we use the flag in the IrpContext and raise
        if the resource is not acquired.

    Type - Indicates how we should try to get the resource.

Return Value:

    BOOLEAN - TRUE if the resource is acquired.  FALSE if not acquired and
        IgnoreWait is specified.  Otherwise we raise CANT_WAIT.

--*/

{
    BOOLEAN Wait = FALSE;
    BOOLEAN Acquired;
    PAGED_CODE();

    //
    //  We look first at the IgnoreWait flag, next at the flag in the Irp
    //  Context to decide how to acquire this resource.
    //

    if (!IgnoreWait && FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Attempt to acquire the resource either shared or exclusively.
    //

    switch (Type) {
        case AcquireExclusive:
        
            Acquired = ExAcquireResourceExclusiveLite( Resource, Wait );
            break;

        case AcquireShared:
            
            Acquired = ExAcquireResourceSharedLite( Resource, Wait );
            break;

        case AcquireSharedStarveExclusive:
            
            Acquired = ExAcquireSharedStarveExclusive( Resource, Wait );
            break;

        default:
            ASSERT( FALSE );
            Acquired = FALSE;
    }

    //
    //  If not acquired and the user didn't specifiy IgnoreWait then
    //  raise CANT_WAIT.
    //

    if (!Acquired && !IgnoreWait) {

        UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    return Acquired;
}


BOOLEAN
UdfAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer for synchronization.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == NULL);
    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return ExAcquireResourceSharedLite( Fcb->Resource, Wait );
}


VOID
UdfReleaseFromCache (
    IN PFCB Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a virtual file.  It is subsequently called by the Lazy Writer to release
    a resource acquired above.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    IoSetTopLevelIrp( NULL );

    ExReleaseResourceLite( Fcb->Resource );
}


BOOLEAN
UdfNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    PAGED_CODE();
    return TRUE;
}


VOID
UdfNoopRelease (
    IN PVOID Fcb
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PAGED_CODE();
}


VOID
UdfAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to acquire the file exclusively.

Arguments:

    FileObject - File object for a Udffs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the Fcb resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource,
                                TRUE );

    //
    //  Take the File resource shared.  We need this later on when MM calls 
    //  QueryStandardInfo to get the file size.  
    //
    //  If we don't use StarveExclusive,  then we can get wedged behind an 
    //  exclusive waiter who is waiting on someone else holding it shared in the 
    //  read->initializecachemap path (which calls createsection) who is in turn 
    //  waiting on us to finish the create section.
    //

    ExAcquireSharedStarveExclusive( ((PFCB) FileObject->FsContext)->Resource,
                                     TRUE );
}


VOID
UdfReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to release a file acquired with
    the AcquireForCreateSection call above.

Arguments:

    FileObject - File object for a Udffs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Release the resources.
    //

    ExReleaseResourceLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource );
    ExReleaseResourceLite( ((PFCB) FileObject->FsContext)->Resource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\strucsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Udfs in-memory data structure manipulation
    routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     19-Jun-1996
    Tom Jolly       [TomJolly]  24-Jan-2000

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_STRUCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_STRUCSUP)

//
//  Define this to change the VAT search strategy to keep looking until
//  we get a read fail/invalid block,  and use the highest found.  Default
//  (undef) is to stop searching at the first valid VAT we find.
//

//#define SEARCH_FOR_HIGHEST_VALID_VAT

//
//  Local structures
//

typedef struct _FCB_TABLE_ELEMENT {

    FILE_ID FileId;
    PFCB Fcb;

} FCB_TABLE_ELEMENT, *PFCB_TABLE_ELEMENT;

//
//  Local macros
//

//
//  PFCB
//  UdfAllocateFcbData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbData (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB
//  UdfAllocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB_NONPAGED
//  UdfAllocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB_NONPAGED FcbNonpaged
//      );
//
//  PCCB
//  UdfAllocateCcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateCcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCCB Ccb
//      );
//

#define UdfAllocateFcbData(IC) \
    ExAllocateFromPagedLookasideList( &UdfFcbDataLookasideList );

#define UdfDeallocateFcbData(IC,F) \
    ExFreeToPagedLookasideList( &UdfFcbDataLookasideList, F );

#define UdfAllocateFcbIndex(IC) \
    ExAllocateFromPagedLookasideList( &UdfFcbIndexLookasideList );

#define UdfDeallocateFcbIndex(IC,F) \
    ExFreeToPagedLookasideList( &UdfFcbIndexLookasideList, F );

#define UdfAllocateFcbNonpaged(IC) \
    ExAllocateFromNPagedLookasideList( &UdfFcbNonPagedLookasideList );

#define UdfDeallocateFcbNonpaged(IC,FNP) \
    ExFreeToNPagedLookasideList( &UdfFcbNonPagedLookasideList, FNP );

#define UdfAllocateCcb(IC) \
    ExAllocateFromPagedLookasideList( &UdfCcbLookasideList );

#define UdfDeallocateCcb(IC,C) \
    ExFreeToPagedLookasideList( &UdfCcbLookasideList, C );

//
//  VOID
//  UdfInsertFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDeleteFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//


#define UdfInsertFcbTable(IC,F) {                                   \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.Fcb = (F);                                                 \
    _Key.FileId = (F)->FileId;                                      \
    RtlInsertElementGenericTable( &(F)->Vcb->FcbTable,              \
                                  &_Key,                            \
                                  sizeof( FCB_TABLE_ELEMENT ),      \
                                  NULL );                           \
}

#define UdfDeleteFcbTable(IC,F) {                                   \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileId = (F)->FileId;                                      \
    RtlDeleteElementGenericTable( &(F)->Vcb->FcbTable, &_Key );     \
}

//
//  Discovers the partition the current allocation descriptor's referred extent
//  is on, either explicitly throuigh the descriptor or implicitly through the
//  mapped view.
//

INLINE
USHORT
UdfGetPartitionOfCurrentAllocation (
    IN PALLOC_ENUM_CONTEXT AllocContext
    )
{
    if (AllocContext->AllocType == ICBTAG_F_ALLOC_LONG) {

        return ((PLONGAD) AllocContext->Alloc)->Start.Partition;
    
    } else {

        return AllocContext->IcbContext->Active.Partition;
    }
}

//
//  Builds the Mcb in an Fcb.  Use this after knowing that an Mcb is required
//  for mapping information.
//

INLINE
VOID
UdfInitializeFcbMcb (
    IN PFCB Fcb
    )
{
    //
    //  In certain rare situations, we may get called more than once.
    //  Just reset the allocations.
    //
    
    if (FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED )) {
    
        FsRtlResetLargeMcb( &Fcb->Mcb, TRUE );

    } else {
    
        FsRtlInitializeLargeMcb( &Fcb->Mcb, UdfPagedPool );
        SetFlag( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED );
    }
}

//
//  Teardown an Fcb's Mcb as required.
//

INLINE
VOID
UdfUninitializeFcbMcb (
    IN PFCB Fcb
    )
{
    if (FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED )) {
    
        FsRtlUninitializeLargeMcb( &Fcb->Mcb );
        ClearFlag( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED );
    }
}

//
//  Local support routines
//

PVOID
UdfAllocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    );

PFCB_NONPAGED
UdfCreateFcbNonPaged (
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    );

VOID
UdfDeallocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
UdfFcbTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID id1,
    IN PVOID id2
    );

VOID
UdfInitializeAllocationContext (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowSingleZeroLengthExtent
    );

BOOLEAN
UdfGetNextAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    );

BOOLEAN
UdfGetNextAllocationPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    );

VOID
UdfLookupActiveIcbInExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG Recurse,
    IN ULONG Length
    );

VOID
UdfInitializeEaContext (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG EAType,
    IN UCHAR EASubType
    );

BOOLEAN
UdfLookupEa (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAllocateTable)
#pragma alloc_text(PAGE, UdfCleanupIcbContext)
#pragma alloc_text(PAGE, UdfCleanupIrpContext)
#pragma alloc_text(PAGE, UdfCreateCcb)
#pragma alloc_text(PAGE, UdfCreateFcb)
#pragma alloc_text(PAGE, UdfCreateFcbNonPaged)
#pragma alloc_text(PAGE, UdfCreateIrpContext)
#pragma alloc_text(PAGE, UdfDeallocateTable)
#pragma alloc_text(PAGE, UdfDeleteCcb)
#pragma alloc_text(PAGE, UdfDeleteFcb)
#pragma alloc_text(PAGE, UdfDeleteFcbNonpaged)
#pragma alloc_text(PAGE, UdfDeleteVcb)
#pragma alloc_text(PAGE, UdfFcbTableCompare)
#pragma alloc_text(PAGE, UdfFindInParseTable)
#pragma alloc_text(PAGE, UdfGetNextAllocation)
#pragma alloc_text(PAGE, UdfGetNextAllocationPostProcessing)
#pragma alloc_text(PAGE, UdfGetNextFcb)
#pragma alloc_text(PAGE, UdfInitializeAllocationContext)
#pragma alloc_text(PAGE, UdfInitializeAllocations)
#pragma alloc_text(PAGE, UdfInitializeEaContext)
#pragma alloc_text(PAGE, UdfInitializeFcbFromIcbContext)
#pragma alloc_text(PAGE, UdfInitializeIcbContext)
#pragma alloc_text(PAGE, UdfInitializeStackIrpContext)
#pragma alloc_text(PAGE, UdfInitializeVcb)
#pragma alloc_text(PAGE, UdfLookupActiveIcb)
#pragma alloc_text(PAGE, UdfLookupActiveIcbInExtent)
#pragma alloc_text(PAGE, UdfLookupEa)
#pragma alloc_text(PAGE, UdfLookupFcbTable)
#pragma alloc_text(PAGE, UdfTeardownStructures)
#pragma alloc_text(PAGE, UdfUpdateTimestampsFromIcbContext)
#pragma alloc_text(PAGE, UdfUpdateVcbPhase0)
#pragma alloc_text(PAGE, UdfUpdateVcbPhase1)
#pragma alloc_text(PAGE, UdfVerifyDescriptor)
#endif ALLOC_PRAGMA


BOOLEAN
UdfInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDISK_GEOMETRY DiskGeometry,
    IN ULONG MediaChangeCount
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    MediaChangeCount - Initial media change count of the target device

Return Value:

    Boolean TRUE if the volume looks reasonable to continue mounting, FALSE
    otherwise.  This routine can raise on allocation failure.

--*/

{
    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof( VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = UDFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( VCB );

    //
    //  Initialize the DirNotify structs.  FsRtlNotifyInitializeSync can raise.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );

    //
    //  Pick up a VPB right now so we know we can pull this filesystem stack
    //  off of the storage stack on demand.  This can raise - if it does,  
    //  uninitialize the notify structures before returning.
    //
    
    try {

        Vcb->SwapVpb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                 sizeof( VPB ),
                                                 TAG_VPB );
    }
    finally {

        if (AbnormalTermination())  {

            FsRtlNotifyUninitializeSync( &Vcb->NotifySync);
        }
    }

    //
    //  Nothing beyond this point should raise.
    //

    RtlZeroMemory( Vcb->SwapVpb, sizeof( VPB ) );

    //
    //  Initialize the resource variable for the Vcb and files.
    //

    ExInitializeResourceLite( &Vcb->VcbResource );
    ExInitializeResourceLite( &Vcb->FileResource );
    ExInitializeResourceLite( &Vcb->VmcbMappingResource );
    ExInitializeFastMutex( &Vcb->VcbMutex );

    //
    //  Insert this Vcb record on the UdfData.VcbQueue.
    //

    InsertHeadList( &UdfData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the Target Device Object and Vpb fields, referencing the
    //  target device.
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the removable media flag based on the real device's
    //  characteristics
    //

    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA )) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    //
    //  Initialize the generic Fcb Table.
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               (PRTL_GENERIC_COMPARE_ROUTINE) UdfFcbTableCompare,
                               (PRTL_GENERIC_ALLOCATE_ROUTINE) UdfAllocateTable,
                               (PRTL_GENERIC_FREE_ROUTINE) UdfDeallocateTable,
                               NULL );

    //
    //  Show that we have a mount in progress.
    //

    UdfSetVcbCondition( Vcb, VcbMountInProgress);

    //
    //  Refererence the Vcb for two reasons.  The first is a reference
    //  that prevents the Vcb from going away on the last close unless
    //  dismount has already occurred.  The second is to make sure
    //  we don't go into the dismount path on any error during mount
    //  until we get to the Mount cleanup.
    //

    Vcb->VcbResidualReference = UDFS_BASE_RESIDUAL_REFERENCE;
    Vcb->VcbResidualUserReference = UDFS_BASE_RESIDUAL_USER_REFERENCE;

    Vcb->VcbReference = 1 + Vcb->VcbResidualReference;

    //
    //  Set the sector size.
    //

    Vcb->SectorSize = DiskGeometry->BytesPerSector;

    //
    //  Set the sector shift amount.
    //

    Vcb->SectorShift = UdfHighBit( DiskGeometry->BytesPerSector );

    //
    //  Set the media change count on the device
    //

    UdfSetMediaChangeCount( Vcb, MediaChangeCount);

    return TRUE;
}

VOID
UdfCreateOrResetVatAndVmcbStreams( 
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Lbn,
    IN PICBFILE VatIcb,
    IN USHORT Reference
    )
/*++

Routine Description:

    This is pretty ugly, but we have to cobble this maybe-Icb into the metadata stream
    so that initialization/use is possible (embedded data!).  Normally regular Icb searches
    would have done this for us, but since we have to go through such an amusing search
    procedure that isn't possible.  So, add it as a single sector mapping.

    Since this lives in a partition, we can just do the "lookup" in the metadata stream.
    If we did not have this guarantee, we'd need to do a bit more of this by hand.

    As this is at mount time, we are very sure we are the only person messing with the
    metadata stream.

Arguments:

    VatIcb - pointer to memory containing VAT FE that we wish to set up VAT/Vmcb streams for.

    Reference - partition ref of virtual partition.
    
Return Value:

    None.  Raise on error.

--*/
{
    LONGLONG FileId = 0;
    ICB_SEARCH_CONTEXT IcbContext;
    ULONG Vsn;
   
    if (NULL != Vcb->VatFcb) {
    
        UdfResetVmcb( &Vcb->Vmcb );

        CcPurgeCacheSection( Vcb->MetadataFcb->FileObject->SectionObjectPointer,
                             NULL,
                             0,
                             FALSE );
        
        CcPurgeCacheSection( Vcb->VatFcb->FileObject->SectionObjectPointer,
                             NULL,
                             0,
                             FALSE );
    }
    else {
        
        //
        //  This is the first pass.  Stamp out the VAT stream Fcb.
        //

        UdfLockVcb( IrpContext, Vcb );

        try {
        
            Vcb->VatFcb = UdfCreateFcb( IrpContext,
                                        *((PFILE_ID) &FileId),
                                        UDFS_NTC_FCB_INDEX,
                                        NULL );

            UdfIncrementReferenceCounts( IrpContext, Vcb->VatFcb, 1, 1 );
        }
        finally {
        
            UdfUnlockVcb( IrpContext, Vcb );
        }
                    
        //
        //  Point to the file resource and set the flag that will cause mappings
        //  to go through the Vmcb
        //

        Vcb->VatFcb->Resource = &Vcb->FileResource;
    }
    
    //
    //  Establish a mapping for the candidate Vat Icb in the metadata stream 
    //  (we're currently looking at a local buffer filled by readsectors). Note
    //  that this operation uses the presence of Vcb->VatFcb to switch of rounding
    //  of extents to page sizes - a bad thing (tm) for packet written media.
    //

    Vsn = UdfLookupMetaVsnOfExtent( IrpContext,
                                    Vcb,
                                    Reference,
                                    Lbn,
                                    BlockSize( Vcb ),
                                    TRUE );
    //
    //  Now size and try to pick up all of the allocation descriptors for this guy.
    //  We're going to need to conjure an IcbContext for this.
    //

    Vcb->VatFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb, VatIcb->InfoLength );

    Vcb->VatFcb->FileSize.QuadPart =
    Vcb->VatFcb->ValidDataLength.QuadPart = VatIcb->InfoLength;

    //
    //  Now construct the ICB search context we would have had
    //  made in the process of normal ICB discovery.  Since we
    //  were unable to do that, gotta do it by hand. NOTE that
    //  View / VatIcb is NOT a CcMapping,  but a pointer to buffer
    //  we allocated & filled with ReadSectors,  above.
    //
    
    RtlZeroMemory( &IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext.Active.View = (PVOID) VatIcb;
    IcbContext.Active.Partition = Reference;
    IcbContext.Active.Lbn = Lbn;
    IcbContext.Active.Length = UdfRawReadSize( Vcb, BlockSize( Vcb ));
    IcbContext.Active.Vsn = Vsn;                

    try {
    
        UdfInitializeAllocations( IrpContext,
                                  Vcb->VatFcb,
                                  &IcbContext,
                                  FALSE);
    }
    finally {

        UdfCleanupIcbContext( IrpContext, &IcbContext );
    }
    
    //
    //  Create or resize the stream file for the VAT as appropriate.
    //

    if (!FlagOn( Vcb->VatFcb->FcbState, FCB_STATE_INITIALIZED )) {
    
        UdfCreateInternalStream( IrpContext, Vcb, Vcb->VatFcb );
        SetFlag( Vcb->VatFcb->FcbState, FCB_STATE_INITIALIZED );

    } else {

        CcSetFileSizes( Vcb->VatFcb->FileObject, (PCC_FILE_SIZES) &Vcb->VatFcb->AllocationSize );
    }
}



VOID
UdfUpdateVcbPhase0 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform the initial spinup of the volume so that
    we can do reads into it.  Primarily, this is required since virtual partitions
    make us lift the remapping table, and the final sets of descriptors from the volume
    can be off in these virtual partitions.
    
    So, we need to get everything set up to read.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already set up and completed
        the Pcb.

Return Value:

    None

--*/

{
    LONGLONG FileId = 0;

    PICBFILE VatIcb = NULL;
    PREGID RegId;
    ULONG ThisPass;
    ULONG Psn;
    ULONG Lbn;
    ULONG SectorCount;
    USHORT Reference;

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT
    ULONG LastValidVatLbn = 0;
    ULONG LastValidVatOffset;
    ULONG LastValidVatCount;
#endif

    BOOLEAN UnlockVcb = FALSE;

    PBCB Bcb = NULL;
    LARGE_INTEGER Offset;
    PVAT_HEADER VatHeader = NULL;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfUpdateVcbPhase0, Vcb %08x\n", Vcb ));

    try {
        
        //////////////////
        //
        //  Create the Metadata Fcb and refererence it and the Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        Vcb->MetadataFcb = UdfCreateFcb( IrpContext,
                                         *((PFILE_ID) &FileId),
                                         UDFS_NTC_FCB_INDEX,
                                         NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->MetadataFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  The metadata stream is grown lazily as we reference disk structures.
        //

        Vcb->MetadataFcb->FileSize.QuadPart =
        Vcb->MetadataFcb->ValidDataLength.QuadPart = 
        Vcb->MetadataFcb->AllocationSize.QuadPart = 0;

        //
        //  Initialize the volume Vmcb
        //

        UdfLockFcb( IrpContext, Vcb->MetadataFcb );

        UdfInitializeVmcb( &Vcb->Vmcb,
                           UdfPagedPool,
                           MAXULONG,
                           SectorSize(Vcb) );

        SetFlag( Vcb->VcbState, VCB_STATE_VMCB_INIT);

        UdfUnlockFcb( IrpContext, Vcb->MetadataFcb );

        //
        //  Point to the file resource and set the flag that will cause mappings
        //  to go through the Vmcb
        //

        Vcb->MetadataFcb->Resource = &Vcb->FileResource;

        SetFlag( Vcb->MetadataFcb->FcbState, FCB_STATE_VMCB_MAPPING | FCB_STATE_INITIALIZED );

        //
        //  Create the stream file for this.
        //

        UdfCreateInternalStream( IrpContext, Vcb, Vcb->MetadataFcb );
        
        //////////////////
        //
        //  If this is a volume containing a virtual partition, set up the
        //  Virtual Allocation Table Fcb and adjust the residual reference
        //  counts comensurately.
        //
        //////////////////

        if (FlagOn( Vcb->Pcb->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

            DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, handling VAT setup\n" ));

            //
            //  Now if some dummy has stuck us in the situation of not giving us
            //  the tools to figure out where the end of the media is, tough luck.
            //

            if (!Vcb->BoundN || Vcb->BoundN < ANCHOR_SECTOR) {

                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, no end bound was discoverable!\n" ));

                UdfRaiseStatus( IrpContext, STATUS_UNRECOGNIZED_VOLUME );
            }

            //
            //  We take care of this first since the residuals must be in place
            //  if we raise while finding the VAT, else we will get horribly
            //  confused when the in-progress references are seen.  We will think
            //  that the extra real referenes are indications that the volume can't
            //  be dismounted.
            //
            
            Vcb->VcbResidualReference += UDFS_CDUDF_RESIDUAL_REFERENCE;
            Vcb->VcbResidualUserReference += UDFS_CDUDF_RESIDUAL_USER_REFERENCE;

            Vcb->VcbReference += UDFS_CDUDF_RESIDUAL_REFERENCE;

            //
            //  Now, we need to hunt about for the VAT ICB.  This is defined, on
            //  closed media (meaning that the sessions have been finalized for use
            //  in CDROM drives), to be in the very last information sector on the
            //  media.  Complicating this simple picture is that CDROMs tell us the
            //  "last sector" by telling us where the start of the leadout area is,
            //  not where the end of the informational sectors are.  This is an
            //  important distinction because any combination of the following can
            //  be used in closing a CDROM session: 2 runout sectors, and/or 150
            //  sectors (2 seconds) of postgap, or nothing.  Immediately after these
            //  "closing" writes is where the leadout begins.
            //
            //  Runout is usually found on CD-E media and corresponds to the time it
            //  will take to turn the writing laser off.  Postgap is what is used to
            //  generate audio pauses.  It is easy to see that the kind of media and
            //  kind of mastering tool/system used will affect us here.  There is no
            //  way to know either ahead of time.
            //
            //  So, finally, these are the offsets from our previously discovered
            //  bounding information where we might find the last information sector:
            //
            //          -152    runout + postgap
            //          -150    postgap
            //          -2      runout
            //          0       nothing
            //
            //  We must search these from low to high since it is extrememly expensive
            //  to guess wrong - CDROMs will sit there for tens of seconds trying to
            //  read unwritten/unreadable sectors.  Hopefully we will find the VAT
            //  ICB beforehand.
            //
            //  This should all be highly disturbing.
            //

            VatIcb = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                               UdfRawBufferSize( Vcb, BlockSize( Vcb )),
                                               TAG_NSR_VDSD);

            for (ThisPass = 0; ThisPass < 4; ThisPass++) {

                //
                //  Lift the appropriate sector.  The discerning reader will be confused that
                //  this is done in sector terms, not block.  So is the implementor.
                //
                
                Psn = Vcb->BoundN - ( ThisPass == 0? 152 :
                                    ( ThisPass == 1? 150 :
                                    ( ThisPass == 2? 2 : 0 )));

                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, looking at Psn 0x%08x\n", Psn ));

                //
                //  Now, try to figure out what physical partition this sector lives in so
                //  that we can eventually establish workable metadata mappings to it and
                //  dereference short allocation descriptors it may use.
                //

                for (Reference = 0;
                     Reference < Vcb->Pcb->Partitions;
                     Reference++) {
    
                    if (Vcb->Pcb->Partition[Reference].Type == Physical &&
                        Vcb->Pcb->Partition[Reference].Physical.Start <= Psn &&
                        Vcb->Pcb->Partition[Reference].Physical.Start +
                        Vcb->Pcb->Partition[Reference].Physical.Length > Psn) {
    
                        break;
                    }
                }
                
                //
                //  If this sector is not contained in a partition, we do not
                //  need to look at it.
                //
                
                if (Reference == Vcb->Pcb->Partitions) {
                    
                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but it isn't in a partition.\n" ));

                    continue;
                }
                
                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... in partition Ref %u.\n",  Reference ));

                //
                //  We must locate the Lbn of this Psn by figuring out the offset of it
                //  in the partition we already know that it is recorded in.
                //
                
                Lbn = BlocksFromSectors( Vcb, Psn - Vcb->Pcb->Partition[Reference].Physical.Start );

                if (!NT_SUCCESS( UdfReadSectors( IrpContext,
                                                 LlBytesFromSectors( Vcb, Psn ),
                                                 UdfRawReadSize( Vcb, BlockSize( Vcb )),
                                                 TRUE,
                                                 VatIcb,
                                                 Vcb->TargetDeviceObject ))) {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but couldn't read it.\n" ));

                    continue;
                }

                //
                //  First make sure this looks vaguely like a file entry.
                //

                if (!( (((PDESTAG) VatIcb)->Ident == DESTAG_ID_NSR_FILE) || 
                       (((PDESTAG) VatIcb)->Ident == DESTAG_ID_NSR_EXT_FILE)) 
                    ||
                    !UdfVerifyDescriptor( IrpContext,
                                          (PDESTAG) VatIcb,
                                          ((PDESTAG) VatIcb)->Ident,
                                          BlockSize( Vcb ),
                                          Lbn,
                                          TRUE )) {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but it didn't verify.\n" ));

                    continue;
                }

                //
                //  Make sure this has filetype of NOTSPEC(1.50) or VAT(2.0x).  We can also presume 
                //  that a VAT isn't linked into any directory, so it would be surprising if the link 
                //  count was nonzero.
                //
                //  4.13.01 - Relaxed the linkcount check.  If it's the right type,  and it passed
                //            CRC/Checksum in verify above,  that's good enough.
                //

                if (UdfVATIcbFileTypeExpected( Vcb) != VatIcb->Icbtag.FileType)  {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but the type 0x%x is wrong.\n", VatIcb->Icbtag.FileType));

                    continue;
                }
                
#ifdef UDF_SANITY
                if (0 != VatIcb->LinkCount)  {

                    DebugTrace(( 0, Dbg, "WARNING: VAT linkcount (%d) unexpectedly non-zero\n", VatIcb->LinkCount ));
                }
#endif
                //
                //  The VAT must be at least large enough to contain the required information and
                //  be a multiple of 4byte elements in length.  We also have defined a sanity upper
                //  bound beyond which we never expect to see a VAT go.
                //

                ASSERT( !LongOffset( UdfMinLegalVATSize( Vcb) ));
            
                if (VatIcb->InfoLength < UdfMinLegalVATSize( Vcb) ||
                    VatIcb->InfoLength > UDF_CDUDF_MAXIMUM_VAT_SIZE ||
                    LongOffset( VatIcb->InfoLength )) {
                
                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but the size (0x%X) looks pretty bogus.\n", VatIcb->InfoLength ));

                    continue;
                }

                //
                //  At this point we have to take a wild guess that this will be the guy.  Since the only
                //  way to be sure is to look at the very end of the file an look for the regid (1.50), or
                //  the beginning for the VAT header record (2.0x),  go map this thing.
                //
    
                //
                //  Zap any previous mapping and invalidate the metadata and VAT stream content.
                //
                
                UdfUnpinData( IrpContext, &Bcb );

                UdfCreateOrResetVatAndVmcbStreams( IrpContext,
                                                   Vcb,
                                                   Lbn,
                                                   VatIcb,
                                                   Reference);

                //
                //  To complete VAT discovery, we now look for the regid at the end of the stream
                //  (1.50) or a header at the beginning (2.0x) that will definitively tell us that 
                //  this is really a VAT.   We already know the stream is big enough by virtue of our
                //  preliminary sanity checks.
                //

                if (UdfVATHasHeaderRecord( Vcb))  {

                    //
                    //  UDF 2.0x style VAT.  Map the header record,  and ensure the size looks
                    //  sensible.  Store total header size (incl imp. use) in the Vcb so we know
                    //  the offset to the first VAT mapping entry.
                    //

                    Offset.QuadPart = 0;
                    
                    CcMapData( Vcb->VatFcb->FileObject,
                               &Offset,
                               sizeof(VAT_HEADER),
                               TRUE,
                               &Bcb,
                               &VatHeader );

                    if ( ( (sizeof( VAT_HEADER) + VatHeader->ImpUseLength) != VatHeader->Length) ||
                         ( VatHeader->ImpUseLength && ((VatHeader->ImpUseLength < 32) || ( VatHeader->ImpUseLength & 0x03)))
                       )  {

                        //
                        //  Header is wrong size,  or impl. use length is not dword aligned or is < 32 bytes
                        //  Oh well,  this isn't it....
                        //

                        DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Invalid VAT header L 0x%X, IUL 0x%X\n", VatHeader->Length, VatHeader->ImpUseLength));
                        continue;
                    }
                    
                    Vcb->OffsetToFirstVATEntry = VatHeader->Length;
                    Vcb->VATEntryCount = (Vcb->VatFcb->FileSize.LowPart - Vcb->OffsetToFirstVATEntry) / sizeof(ULONG);
                    
                    DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Successfully set up a 2.0x style VAT\n"));
                }
                else {
                
                    //
                    //  UDF 1.5 style VAT.  Bias from the back by the previous VAT pointer and the 
                    //  regid itself.
                    //

                    Offset.QuadPart = Vcb->VatFcb->FileSize.QuadPart - UDF_CDUDF_TRAILING_DATA_SIZE;

                    CcMapData( Vcb->VatFcb->FileObject,
                               &Offset,
                               sizeof(REGID),
                               TRUE,
                               &Bcb,
                               &RegId );

                    if (!UdfUdfIdentifierContained( RegId,
                                                    &UdfVatTableIdentifier,
                                                    UDF_VERSION_150,
                                                    UDF_VERSION_150,
                                                    OSCLASS_INVALID,
                                                    OSIDENTIFIER_INVALID )) {
                        //
                        //  Oh well, no go here.
                        //
                        
                        DebugTrace((0, Dbg, "UdfUpdateVcbPhase0() VAT Regid didn't verify\n"));                        
                        continue;
                    }
                    
                    Vcb->OffsetToFirstVATEntry = 0;
                    Vcb->VATEntryCount = (Vcb->VatFcb->FileSize.LowPart - UDF_CDUDF_TRAILING_DATA_SIZE) / sizeof(ULONG);
                    
                    DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Successfully set up a 1.50 style VAT\n"));
                }

                //
                //  Found a valid one.
                //

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT

                //
                //  But we must continue until a read fails,  and use the highest block
                //  containig a valid VAT that we find.  Otherwise we may pick up an old
                //  VAT by mistake.
                //
                
                LastValidVatLbn = Lbn;
                LastValidVatOffset = Vcb->OffsetToFirstVATEntry;
                LastValidVatCount = Vcb->VATEntryCount;
#else
                break;
#endif
            }

            //
            //  If we didn't find anything ...
            //

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT
            if ((ThisPass == 4) || (0 == LastValidVatLbn))  {
#else            
            if (ThisPass == 4)  {
#endif
                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... and so we didn't find a VAT!\n" ));

                UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT

            //
            //  Switch back to the last valid VAT,  if we tried blocks following it.
            //
            
            if (Lbn != LastValidVatLbn)  {

                DebugTrace(( 0, Dbg,"Reverting to last valid VAT @ PSN 0x%x\n", LastValidVatLbn));

                Offset.QuadPart = LlBytesFromSectors( Vcb, LastValidVatLbn + Vcb->Pcb->Partition[Reference].Physical.Start);
                
                if (!NT_SUCCESS( UdfReadSectors( IrpContext,
                                                 Offset.QuadPart,
                                                 UdfRawReadSize( Vcb, BlockSize( Vcb )),
                                                 TRUE,
                                                 VatIcb,
                                                 Vcb->TargetDeviceObject ))) {
                    
                    DebugTrace(( 0, Dbg, "Failed to re-read previous valid VAT sector\n" ));

                    UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
                }
                
                UdfUnpinData( IrpContext, &Bcb );

                UdfCreateOrResetVatAndVmcbStreams( IrpContext,
                                                   Vcb,
                                                   LastValidVatLbn,
                                                   VatIcb,
                                                   Reference);

                Vcb->OffsetToFirstVATEntry = LastValidVatOffset;
                Vcb->VATEntryCount = LastValidVatCount;
            }
#endif
            //
            //  Go find the virtual reference so we can further update the Pcb
            //  with information from the VAT.
            //

            for (Reference = 0;
                 Reference < Vcb->Pcb->Partitions;
                 Reference++) {

                if (Vcb->Pcb->Partition[Reference].Type == Virtual) {

                    break;
                }
            }

            ASSERT( Reference < Vcb->Pcb->Partitions );

            //
            //  We note the length so we can easily do bounds checking for
            //  virtual mappings.
            //
            
            Offset.QuadPart = (Vcb->VatFcb->FileSize.QuadPart -
                               UDF_CDUDF_TRAILING_DATA_SIZE) / sizeof(ULONG);

            ASSERT( Offset.HighPart == 0 );
            Vcb->Pcb->Partition[Reference].Virtual.Length = Offset.LowPart;

            DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... got it!\n" ));
        }

    } 
    finally {

        DebugUnwind( "UdfUpdateVcbPhase0" );

        UdfUnpinData( IrpContext, &Bcb );
        if (UnlockVcb) { UdfUnlockVcb( IrpContext, Vcb ); }
        if (VatIcb) { ExFreePool( VatIcb ); }
    }

    DebugTrace(( -1, Dbg, "UdfUpdateVcbPhase0 -> VOID\n" ));
}


VOID
UdfUpdateVcbPhase1 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PNSR_FSD Fsd
    )

/*++

Routine Description:

    This routine is called to perform the final initialization of a Vcb and Vpb
    from the volume descriptors on the disk.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already done phase 0.

    Fsd - The fileset descriptor for this volume.
    
Return Value:

    None

--*/

{
    ICB_SEARCH_CONTEXT IcbContext;

    LONGLONG FileId = 0;

    PFCB Fcb;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN UnlockFcb = FALSE;
    BOOLEAN CleanupIcbContext = FALSE;

    ULONG Reference;

    ULONG BoundSector = 0;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfUpdateVcbPhase1, Vcb %08x Fsd %08x\n", Vcb, Fsd ));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Do the final internal Fcb's and other Vcb fields.
        //

        //////////////////
        //
        //  Create the root index and reference it in the Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;
        
        Vcb->RootIndexFcb = UdfCreateFcb( IrpContext,
                                          *((PFILE_ID) &FileId),
                                          UDFS_NTC_FCB_INDEX,
                                          NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Create the File id by hand for this Fcb.
        //

        UdfSetFidFromLbAddr( Vcb->RootIndexFcb->FileId, Fsd->IcbRoot.Start );
        UdfSetFidDirectory( Vcb->RootIndexFcb->FileId );
        Vcb->RootIndexFcb->RootExtentLength = Fsd->IcbRoot.Length.Length;

        //
        //  Get the direct entry for the root directory and initialize
        //  the Fcb from it.
        //

        UdfInitializeIcbContextFromFcb( IrpContext,
                                        &IcbContext,
                                        Vcb->RootIndexFcb );
        CleanupIcbContext = TRUE;

        UdfLookupActiveIcb( IrpContext, 
                            &IcbContext, 
                            Vcb->RootIndexFcb->RootExtentLength );
        //
        //  Note: the vcb lock here is just to satisfy sanity checks in function.
        //
        
        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;
        
        UdfInitializeFcbFromIcbContext( IrpContext,
                                        Vcb->RootIndexFcb,
                                        &IcbContext,
                                        NULL);
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;
        
        UdfCleanupIcbContext( IrpContext, &IcbContext );
        CleanupIcbContext = FALSE;

        //
        //  Create the stream file for the root directory.
        //

        UdfCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

        //////////////////
        //
        //  Now do the volume dasd Fcb.  Create this and reference it in the
        //  Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        Vcb->VolumeDasdFcb = UdfCreateFcb( IrpContext,
                                           *((PFILE_ID) &FileId),
                                           UDFS_NTC_FCB_DATA,
                                           NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        Fcb = Vcb->VolumeDasdFcb;
        UdfLockFcb( IrpContext, Fcb );
        UnlockFcb = TRUE;

        //
        //  If we were unable to determine a last sector on the media, walk the Pcb and guess
        //  that it is probably OK to think of the last sector of the last partition as The
        //  Last Sector.  Note that we couldn't do this before since the notion of a last
        //  sector has significance at mount time, if it had been possible to find one.
        //

        for ( Reference = 0;
              Reference < Vcb->Pcb->Partitions;
              Reference++ ) {

            if (Vcb->Pcb->Partition[Reference].Type == Physical &&
                Vcb->Pcb->Partition[Reference].Physical.Start +
                Vcb->Pcb->Partition[Reference].Physical.Length > BoundSector) {

                BoundSector = Vcb->Pcb->Partition[Reference].Physical.Start +
                              Vcb->Pcb->Partition[Reference].Physical.Length;
            }
        }

        //
        //  Note that we cannot restrict the bound by the "physical" bound discovered
        //  eariler.  This is because the MSF format of the TOC request we send is only
        //  capable of representing about 2.3gb, and a lot of media we will be on that
        //  responds to TOCs will be quite a bit larger - ex: DVD.
        //
        //  This, of course, barring proper means of discovering media bounding, prohibits
        //  the possibility of having UDF virtual partitions on DVD-R.
        //

        //
        //  Build the mapping from [0, Bound).  We have to initialize the Mcb by hand since
        //  this is usually left to when we lift retrieval information from an Icb in
        //  UdfInitializeAllocations.
        //

        UdfInitializeFcbMcb( Fcb );

        FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                               (LONGLONG) 0,
                               (LONGLONG) 0,
                               (LONGLONG) BoundSector );
                               
        Fcb->FileSize.QuadPart += LlBytesFromSectors( Vcb, BoundSector );

        Fcb->AllocationSize.QuadPart =
        Fcb->ValidDataLength.QuadPart = Fcb->FileSize.QuadPart;

        UdfUnlockFcb( IrpContext, Fcb );
        UnlockFcb = FALSE;

        SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

        //
        //  Point to the file resource.
        //

        Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

        Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

    } finally {

        DebugUnwind( "UdfUpdateVcbPhase1" );

        if (CleanupIcbContext) { UdfCleanupIcbContext( IrpContext, &IcbContext ); }

        if (UnlockFcb) { UdfUnlockFcb( IrpContext, Fcb ); }
        if (UnlockVcb) { UdfUnlockVcb( IrpContext, Vcb ); }
    }

    DebugTrace(( -1, Dbg, "UdfUpdateVcbPhase1 -> VOID\n" ));

    return;
}


VOID
UdfDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to delete a Vcb which failed mount or has been
    dismounted.  The dismount code should have already removed all of the
    open Fcb's.  We do nothing here but clean up other auxilary structures.

Arguments:

    Vcb - Vcb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_EXCLUSIVE_UDFDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    //
    //  Chuck the backpocket Vpb we kept just in case.
    //

    if (Vcb->SwapVpb) {

        ExFreePool( Vcb->SwapVpb );
    }
    
    //
    //  If there is a Vpb then we must delete it ourselves.
    //

    if (Vcb->Vpb != NULL) {

        UdfFreePool( &Vcb->Vpb );
    }

    //
    //  Drop the Pcb.
    //

    if (Vcb->Pcb != NULL) {

        UdfDeletePcb( Vcb->Pcb );
    }

    //
    //  Dereference our target if we haven't already done so.
    //

    if (Vcb->TargetDeviceObject != NULL) {

        ObDereferenceObject( Vcb->TargetDeviceObject );
    }
    
    //
    //  Remove this entry from the global queue.
    //

    RemoveEntryList( &Vcb->VcbLinks );

    //
    //  Delete resources.
    //

    ExDeleteResourceLite( &Vcb->VcbResource );
    ExDeleteResourceLite( &Vcb->FileResource );
    ExDeleteResourceLite( &Vcb->VmcbMappingResource);

    //
    //  Uninitialize the notify structures.
    //

    if (Vcb->NotifySync != NULL) {

        FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
    }

    //
    //  Now delete the volume device object.
    //

    IoDeleteDevice( (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb,
                                                        VOLUME_DEVICE_OBJECT,
                                                        Vcb ));

    return;
}


PIRP_CONTEXT
UdfCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    UDFS request.  We allocate the structure and then initialize it from
    the given Irp.

Arguments:

    Irp - Irp for this request.

    Wait - TRUE if this request is synchronous, FALSE otherwise.

Return Value:

    PIRP_CONTEXT - Allocated IrpContext.

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN IsFsDo = FALSE;
    ULONG Count;

    PAGED_CODE();

    IsFsDo = UdfDeviceIsFsDo( IrpSp->DeviceObject);

    //
    //  The only operations a filesystem device object should ever receive
    //  are create/teardown of fsdo handles and operations which do not
    //  occur in the context of fileobjects (i.e., mount).
    //

    if (IsFsDo) {

        if (IrpSp->FileObject != NULL &&
            IrpSp->MajorFunction != IRP_MJ_CREATE &&
            IrpSp->MajorFunction != IRP_MJ_CLEANUP &&
            IrpSp->MajorFunction != IRP_MJ_CLOSE) {

            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        ASSERT( IrpSp->FileObject != NULL ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST &&
                 IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) ||

                IrpSp->MajorFunction == IRP_MJ_SHUTDOWN );
    }
    
    NewIrpContext = ExAllocateFromNPagedLookasideList( &UdfIrpContextLookasideList );

    RtlZeroMemory( NewIrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    NewIrpContext->NodeTypeCode = UDFS_NTC_IRP_CONTEXT;
    NewIrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Set the originating Irp field
    //

    NewIrpContext->Irp = Irp;

    //
    //  Copy RealDevice for workque algorithms.  We will update this in the Mount or
    //  Verify since they have no file objects to use here.
    //

    if (IrpSp->FileObject != NULL) {

        NewIrpContext->RealDevice = IrpSp->FileObject->DeviceObject;
    }

    //
    //  This may be one of our filesystem device objects.  In that case don't
    //  initialize the Vcb field.
    //

    if (!IsFsDo) {
        
        NewIrpContext->Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
    }

    //
    //  Major/Minor Function codes
    //

    NewIrpContext->MajorFunction = IrpSp->MajorFunction;
    NewIrpContext->MinorFunction = IrpSp->MinorFunction;

    //
    //  Set the wait parameter
    //

    if (Wait) {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    } else {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    //
    //  return and tell the caller
    //

    return NewIrpContext;
}


VOID
UdfCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    )

/*++

Routine Description:

    This routine is called to cleanup and possibly deallocate the Irp Context.
    If the request is being posted or this Irp Context is possibly on the
    stack then we only cleanup any auxilary structures.

Arguments:

    Post - TRUE if we are posting this request, FALSE if we are deleting
        or retrying this in the current thread.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If we aren't doing more processing then deallocate this as appropriate.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING)) {

        //
        //  If this context is the top level UDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            UdfRestoreThreadContext( IrpContext );
        }
        
        //
        //  Deallocate the Io context if allocated.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            UdfFreeIoContext( IrpContext->IoContext );
        }
        
        //
        //  Deallocate the IrpContext if not from the stack.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK )) {

            ExFreeToNPagedLookasideList( &UdfIrpContextLookasideList, IrpContext );
        }

    //
    //  Clear the appropriate flags.
    //

    } else if (Post) {

        //
        //  If this context is the top level UDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            UdfRestoreThreadContext( IrpContext );
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );

    } else {

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );
    }

    return;
}


VOID
UdfInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    UDFS request.  The IrpContext is on the stack and we need to initialize
    it for the current request.  The request is a close operation.

Arguments:

    IrpContext - IrpContext to initialize.

    IrpContextLite - Structure containing the details of this request.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT_LITE( IrpContextLite );

    //
    //  Zero and then initialize the structure.
    //

    RtlZeroMemory( IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    IrpContext->NodeTypeCode = UDFS_NTC_IRP_CONTEXT;
    IrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Note that this is from the stack.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK );

    //
    //  Copy RealDevice for workque algorithms.
    //

    IrpContext->RealDevice = IrpContextLite->RealDevice;

    //
    //  The Vcb is found in the Fcb.
    //

    IrpContext->Vcb = IrpContextLite->Fcb->Vcb;

    //
    //  Major/Minor Function codes
    //

    IrpContext->MajorFunction = IRP_MJ_CLOSE;

    //
    //  Set the wait parameter
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    return;
}


VOID
UdfTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    IN BOOLEAN Recursive,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is used to walk from some starting point in the Fcb tree towards
    the root.  It will remove the Fcb and continue walking up the tree until
    it finds a point where we can't remove an Fcb.

    We look at the following fields in the Fcb to determine whether we can
    remove this.

        1 - Handle count must be zero.
        2 - If directory then only the only reference can be for a stream file.
        3 - Reference count must either be zero or go to zero here.

    We return immediately if we are recursively entering this routine.

Arguments:

    StartingFcb - This is the Fcb node in the tree to begin with.  This Fcb
        must currently be acquired exclusively.
        
    Recursive - Indicates if this call is an intentional recursion.

    RemovedStartingFcb - Address to store whether we removed the starting Fcb.

Return Value:

    None

--*/

{
    PVCB Vcb = StartingFcb->Vcb;
    PFCB CurrentFcb = StartingFcb;
    BOOLEAN AcquiredCurrentFcb = FALSE;
    PFCB ParentFcb = NULL;
    PLCB Lcb;

    PLIST_ENTRY ListLinks;
    BOOLEAN Abort = FALSE;
    BOOLEAN Removed;
    
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( StartingFcb );

    *RemovedStartingFcb = FALSE;

    //
    //  If this is not an intentionally recursive call we need to check if this
    //  is a layered close and we're already in another instance of teardown.
    //

    DebugTrace(( +1, Dbg,
                 "UdfTeardownStructures, StartingFcb %08x %s\n",
                 StartingFcb,
                 ( Recursive? "Recursive" : "Flat" )));
    
    if (!Recursive) {
    
        //
        //  If this is a recursive call to TearDownStructures we return immediately
        //  doing no operation.
        //

        if (FlagOn( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN )) {

            return;
        }

        SetFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
    }

    //
    //  Use a try-finally to safely clear the top-level field.
    //

    try {

        //
        //  Loop until we find an Fcb we can't remove.
        //

        do {

            //
            //  See if there is an internal stream we should delete.
            //  Only do this if it is the last reference on the Fcb.
            //

            if ((SafeNodeType( CurrentFcb ) != UDFS_NTC_FCB_DATA) &&
                (CurrentFcb->FcbUserReference == 0) &&
                (CurrentFcb->FileObject != NULL)) {

                //
                //  Go ahead and delete the stream file object.
                //

                UdfDeleteInternalStream( IrpContext, CurrentFcb );
            }

            //
            //  If the reference count is non-zero then break.
            //

            if (CurrentFcb->FcbReference != 0) {

                break;
            }

            //
            //  It looks like we have a candidate for removal here.  We
            //  will need to walk the list of prefixes and delete them
            //  from their parents.  If it turns out that we have multiple
            //  parents of this Fcb, we are going to recursively teardown
            //  on each of these.
            //

            for ( ListLinks = CurrentFcb->ParentLcbQueue.Flink;
                  ListLinks != &CurrentFcb->ParentLcbQueue; ) {

                Lcb = CONTAINING_RECORD( ListLinks, LCB, ChildFcbLinks );

                ASSERT_LCB( Lcb );

                //
                //  We advance the pointer now because we will be toasting this guy,
                //  invalidating whatever is here.
                //

                ListLinks = ListLinks->Flink;

                //
                //  We may have multiple parents through hard links.  If the previous parent we
                //  dealt with is not the parent of this new Lcb, lets do some work.
                //
                
                if (ParentFcb != Lcb->ParentFcb) {

                    //
                    //  We need to deal with the previous parent.  It may now be the case that
                    //  we deleted the last child reference and it wants to go away at this point.
                    //
                    
                    if (ParentFcb) {

                        //
                        //  It should never be the case that we have to recurse more than one level on
                        //  any teardown since no cross-linkage of directories is possible.
                        //
                    
                        ASSERT( !Recursive );
                          
                        UdfTeardownStructures( IrpContext, ParentFcb, TRUE, &Removed );

                        if (!Removed) {

                            UdfReleaseFcb( IrpContext, ParentFcb );
                        }
                    }

                    //
                    //  Get this new parent Fcb to work on.
                    //
                    
                    ParentFcb = Lcb->ParentFcb;
                    UdfAcquireFcbExclusive( IrpContext, ParentFcb, FALSE );
                }
                
                //
                //  Lock the Vcb so we can look at references.
                //

                UdfLockVcb( IrpContext, Vcb );

                //
                //  Now check that the reference counts on the Lcb are zero.
                //

                if ( Lcb->Reference != 0 ) {

                    //
                    //  A create is interested in getting in here, so we should
                    //  stop right now.
                    //

                    UdfUnlockVcb( IrpContext, Vcb );
                    UdfReleaseFcb( IrpContext, ParentFcb );
                    Abort = TRUE;

                    break;
                }

                //
                //  Now remove this prefix and drop the references to the parent.
                //

                ASSERT( Lcb->ChildFcb == CurrentFcb );
                ASSERT( Lcb->ParentFcb == ParentFcb );
                
                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, Lcb %08x P %08x <-> C %08x Vcb %d/%d PFcb %d/%d CFcb %d/%d\n",
                             Lcb,
                             ParentFcb,
                             CurrentFcb,
                             Vcb->VcbReference,
                             Vcb->VcbUserReference,
                             ParentFcb->FcbReference,
                             ParentFcb->FcbUserReference,
                             CurrentFcb->FcbReference,
                             CurrentFcb->FcbUserReference ));

                UdfRemovePrefix( IrpContext, Lcb );
                UdfDecrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );

                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, Vcb %d/%d PFcb %d/%d\n",
                             Vcb->VcbReference,
                             Vcb->VcbUserReference,
                             ParentFcb->FcbReference,
                             ParentFcb->FcbUserReference ));

                UdfUnlockVcb( IrpContext, Vcb );
            }

            //
            //  Now really leave if we have to.
            //
            
            if (Abort) {

                break;
            }

            //
            //  Now that we have removed all of the prefixes of this Fcb we can make the final check.
            //  Lock the Vcb again so we can inspect the child's references.
            //

            UdfLockVcb( IrpContext, Vcb );

            if (CurrentFcb->FcbReference != 0) {

                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, saving Fcb %08x %d/%d\n",
                             CurrentFcb,
                             CurrentFcb->FcbReference,
                             CurrentFcb->FcbUserReference ));
                
                //
                //  Nope, nothing more to do.  Stop right now.
                //
                
                UdfUnlockVcb( IrpContext, Vcb );

                if (ParentFcb != NULL) {

                    UdfReleaseFcb( IrpContext, ParentFcb );
                }

                break;
            }

            //
            //  This Fcb is toast.  Remove it from the Fcb Table as appropriate and delete.
            //

            if (FlagOn( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                UdfDeleteFcbTable( IrpContext, CurrentFcb );
                ClearFlag( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            }

            //
            //  Unlock the Vcb but hold the parent in order to walk up
            //  the tree.
            //

            DebugTrace(( +0, Dbg,
                         "UdfTeardownStructures, toasting Fcb %08x %d/%d\n",
                         CurrentFcb,
                         CurrentFcb->FcbReference,
                         CurrentFcb->FcbUserReference ));

            UdfUnlockVcb( IrpContext, Vcb );
            UdfDeleteFcb( IrpContext, CurrentFcb );

            //
            //  Move to the parent Fcb.
            //

            CurrentFcb = ParentFcb;
            ParentFcb = NULL;
            AcquiredCurrentFcb = TRUE;

        } while (CurrentFcb != NULL);

    } finally {

        //
        //  Release the current Fcb if we have acquired it.
        //

        if (AcquiredCurrentFcb && (CurrentFcb != NULL)) {

            UdfReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Clear the teardown flag.
        //

        if (!Recursive) {
        
            ClearFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
        }
    }

    *RemovedStartingFcb = (CurrentFcb != StartingFcb);

    DebugTrace(( -1, Dbg,
                 "UdfTeardownStructures, RemovedStartingFcb -> %c\n",
                 ( *RemovedStartingFcb? 'T' : 'F' )));

    return;
}


PFCB
UdfLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    )

/*++

Routine Description:

    This routine will look through the Fcb table looking for a matching
    entry.

Arguments:

    Vcb - Vcb for this volume.

    FileId - This is the key value to use for the search.

Return Value:

    PFCB - A pointer to the matching entry or NULL otherwise.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Hit;
    PFCB ReturnFcb = NULL;

    PAGED_CODE();

    Key.FileId = FileId;

    Hit = (PFCB_TABLE_ELEMENT) RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

    if (Hit != NULL) {

        ReturnFcb = Hit->Fcb;
    }

    return ReturnFcb;

    UNREFERENCED_PARAMETER( IrpContext );
}


PFCB
UdfGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the Fcb's in the Fcb table.

Arguments:

    Vcb - Vcb for this volume.

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


PFCB
UdfCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the Fcb for the given FileId.  We will
    look this up first in the Fcb table and if not found we will create
    an Fcb.  We don't initialize it or insert it into the FcbTable in this
    routine.

    This routine is called while the Vcb is locked.

Arguments:

    FileId - This is the Id for the target Fcb.

    NodeTypeCode - Node type for this Fcb if we need to create.

    FcbExisted - If specified, we store whether the Fcb existed.

Return Value:

    PFCB - The Fcb found in the table or created if needed.

--*/

{
    PFCB NewFcb;
    BOOLEAN LocalFcbExisted;

    PAGED_CODE();

    //
    //  Use the local boolean if one was not passed in.
    //

    if (!ARGUMENT_PRESENT( FcbExisted )) {

        FcbExisted = &LocalFcbExisted;
    }

    //
    //  Maybe this is already in the table.
    //

    NewFcb = UdfLookupFcbTable( IrpContext, IrpContext->Vcb, FileId );

    //
    //  If not then create the Fcb is requested by our caller.
    //

    if (NewFcb == NULL) {

        //
        //  Use a try-finally for cleanup
        //

        try {

            //
            //  Allocate and initialize the structure depending on the
            //  type code.
            //
    
            switch (NodeTypeCode) {
    
            case UDFS_NTC_FCB_INDEX:
    
                NewFcb = UdfAllocateFcbIndex( IrpContext );
    
                RtlZeroMemory( NewFcb, SIZEOF_FCB_INDEX );
    
                NewFcb->NodeByteSize = SIZEOF_FCB_INDEX;
    
                break;
    
            case UDFS_NTC_FCB_DATA :
    
                NewFcb = UdfAllocateFcbData( IrpContext );
    
                RtlZeroMemory( NewFcb, SIZEOF_FCB_DATA );
    
                NewFcb->NodeByteSize = SIZEOF_FCB_DATA;
    
                break;
    
            default:
    
                UdfBugCheck( 0, 0, 0 );
            }
    
            //
            //  Now do the common initialization.
            //
    
            NewFcb->NodeTypeCode = NodeTypeCode;
    
            NewFcb->Vcb = IrpContext->Vcb;
            NewFcb->FileId = FileId;
    
            InitializeListHead( &NewFcb->ParentLcbQueue );
            InitializeListHead( &NewFcb->ChildLcbQueue );
    
            //
            //  Now create the non-paged section object.
            //
    
            NewFcb->FcbNonpaged = UdfCreateFcbNonPaged( IrpContext );
    
            //
            //  Initialize Advanced FCB Header fields
            //

            ExInitializeFastMutex( &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
            FsRtlSetupAdvancedHeader( &NewFcb->Header, 
                                      &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );

            *FcbExisted = FALSE;

        } finally {

            DebugUnwind( "UdfCreateFcb" );
   
            if (AbnormalTermination()) {

                UdfFreePool( &NewFcb );
            }
        }

    } else {

        *FcbExisted = TRUE;
    }

    return NewFcb;
}


VOID
UdfDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate an Fcb.  We know there
    are no references remaining.  We cleanup any auxilary structures and
    deallocate this Fcb.

Arguments:

    Fcb - This is the Fcb to deallcoate.

Return Value:

    None

--*/

{
    PVCB Vcb = NULL;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Sanity check the counts and Lcb lists.
    //

    ASSERT( Fcb->FcbCleanup == 0 );
    ASSERT( Fcb->FcbReference == 0 );

    ASSERT( IsListEmpty( &Fcb->ChildLcbQueue ));
    ASSERT( IsListEmpty( &Fcb->ParentLcbQueue ));

    //
    //  Release any Filter Context structures associated with this FCB
    //

    FsRtlTeardownPerStreamContexts( &Fcb->Header );

    //
    //  Start with the common structures.
    //

    UdfUninitializeFcbMcb( Fcb );
    
    UdfDeleteFcbNonpaged( IrpContext, Fcb->FcbNonpaged );

    //
    //  Now do the type specific structures.
    //

    switch (Fcb->NodeTypeCode) {

    case UDFS_NTC_FCB_INDEX:

        ASSERT( Fcb->FileObject == NULL );

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            Vcb = Fcb->Vcb;
            Vcb->RootIndexFcb = NULL;
        
        } else if (Fcb == Fcb->Vcb->MetadataFcb) {

            Vcb = Fcb->Vcb;
            Vcb->MetadataFcb = NULL;

            if (FlagOn( Vcb->VcbState, VCB_STATE_VMCB_INIT))  {

                UdfUninitializeVmcb( &Vcb->Vmcb );
            }
        
        } else if (Fcb == Fcb->Vcb->VatFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VatFcb = NULL;
        }

        UdfDeallocateFcbIndex( IrpContext, Fcb );
        break;

    case UDFS_NTC_FCB_DATA :

        if (Fcb->FileLock != NULL) {

            FsRtlFreeFileLock( Fcb->FileLock );
        }

        FsRtlUninitializeOplock( &Fcb->Oplock );

        if (Fcb == Fcb->Vcb->VolumeDasdFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VolumeDasdFcb = NULL;
        }

        UdfDeallocateFcbData( IrpContext, Fcb );
        break;
    }

    //
    //  Decrement the Vcb reference count if this is a system
    //  Fcb.
    //

    if (Vcb != NULL) {

        InterlockedDecrement( &Vcb->VcbReference );
        InterlockedDecrement( &Vcb->VcbUserReference );
    }

    return;
}


VOID
UdfInitializeFcbFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB ParentFcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb from a direct ICB.  It should
    only be called once in the lifetime of an Fcb and will fill in the Mcb
    from the chained allocation descriptors of the ICB.

Arguments:

    Fcb - The Fcb being initialized

    IcbOontext - An search context containing the active direct ICB for the object

Return Value:

    None.

--*/

{
    EA_SEARCH_CONTEXT EaContext;
    PICBFILE Icb;

    PVCB Vcb;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT( IcbContext->Active.View);

    //
    //  Vcb should be locked,  since we insert into the fcb table.  Note we 
    //  manipulate fcb fields with no lock here,  since it's during the init. path.
    //
    
    ASSERT_LOCKED_VCB( Fcb->Vcb);

    //
    //  Directly reference for convenience
    //

    Icb = IcbContext->Active.View;
    Vcb = Fcb->Vcb;

    ASSERT(IcbContext->IcbType == DESTAG_ID_NSR_FILE);
    ASSERT((Icb->Destag.Ident == DESTAG_ID_NSR_FILE) || ((Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE) && UdfExtendedFEAllowed( IrpContext->Vcb)));
    
    //
    //  Check that the full indicated size of the direct entry is sane and
    //  that the length of the EA segment is correctly aligned.  A direct
    //  entry is less than a single logical block in size.
    //
    
    if (LongOffset( FeEALength( Icb)) ||
        ((FeEAsFieldOffset( Icb) + FeEALength( Icb) + FeAllocLength( Icb)) > BlockSize( IcbContext->Vcb ))
       )  {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Verify that the types mesh and set state flags.
    //

    if (Fcb->NodeTypeCode == UDFS_NTC_FCB_INDEX && Icb->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {

        SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
    
    } else if (!( Fcb->NodeTypeCode == UDFS_NTC_FCB_DATA && 
                  ((ICBTAG_FILE_T_FILE == Icb->Icbtag.FileType) || (ICBTAG_FILE_T_REALTIME == Icb->Icbtag.FileType)))
              ) {

        //
        //  We don't allow access to anything except files or directores (no symlinks, devices...)
        //  Currently we treat realtime files as normal files.
        //
        
        UdfRaiseStatus( IrpContext, STATUS_ACCESS_DENIED );
    }

    SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
    //
    //  Store away the on disc UDF file type,  this may be useful later for symlinks etc.
    //
    
    Fcb->UdfIcbFileType = Icb->Icbtag.FileType;
    
    //
    //  Initialize the common header in the Fcb.
    //

    Fcb->Resource = &Fcb->Vcb->FileResource;

    //
    //  Size and lookup all allocations for this object.
    //

    Fcb->AllocationSize.QuadPart = LlBlockAlign( Vcb, Icb->InfoLength );

    Fcb->FileSize.QuadPart =
    Fcb->ValidDataLength.QuadPart = Icb->InfoLength;

    UdfInitializeAllocations( IrpContext,
                              Fcb,
                              IcbContext,
                              (ParentFcb && FlagOn( ParentFcb->FcbState, FCB_STATE_ALLOW_ONEGIG_WORKAROUND))
                                  ? TRUE : FALSE);
    //
    //  Re-reference (may have been unmapped/remapped)
    //
    
    Icb = IcbContext->Active.View;

    //
    //  Lift all of the timestamps for this guy.
    //

    try {
    
        UdfUpdateTimestampsFromIcbContext( IrpContext,
                                           IcbContext,
                                           &Fcb->Timestamps );
    }
    except (UdfQueryDirExceptionFilter( GetExceptionInformation()))  {

        //
        //  In the interest of allowing users maximum data access on dodgy media,
        //  we will ignore corruption within the Eas,  and just use a dummy
        //  timestamp for the create time.  This may change if we being using
        //  Eas for anything critical.
        //

        IrpContext->ExceptionStatus = STATUS_SUCCESS;
        
        Fcb->Timestamps.CreationTime = UdfCorruptFileTime;
    }

    //
    //  Pick up the link count.
    //

    Fcb->LinkCount = Icb->LinkCount;

    //
    //  Link into the Fcb table.  Someone else is responsible for the name linkage, which is
    //  all that remains.  We also note that the Fcb is fully initialized at this point.
    //

    UdfInsertFcbTable( IrpContext, Fcb );
    SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE | FCB_STATE_INITIALIZED );
}


PCCB
UdfCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the Ccb structure.

Arguments:

    Fcb - This is the Fcb for the file being opened.
    
    Lcb - This is the Lcb the Fcb is opened by.

    Flags - User flags to set in this Ccb.

Return Value:

    PCCB - Pointer to the created Ccb.

--*/

{
    PCCB NewCcb;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_OPTIONAL_LCB( Lcb );

    //
    //  Allocate and initialize the structure.
    //

    NewCcb = UdfAllocateCcb( IrpContext );

    //
    //  Set the proper node type code and node byte size
    //

    NewCcb->NodeTypeCode = UDFS_NTC_CCB;
    NewCcb->NodeByteSize = sizeof( CCB );

    //
    //  Set the initial value for the flags and Fcb/Lcb
    //

    NewCcb->Flags = Flags;
    NewCcb->Fcb = Fcb;
    NewCcb->Lcb = Lcb;

    //
    //  Initialize the directory enumeration context
    //
    
    NewCcb->CurrentFileIndex = 0;
    NewCcb->HighestReturnableFileIndex = 0;
    
    NewCcb->SearchExpression.Length = 
    NewCcb->SearchExpression.MaximumLength = 0;
    NewCcb->SearchExpression.Buffer = NULL;

    return NewCcb;
}


VOID
UdfDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate a Ccb structure.

Arguments:

    Ccb - This is the Ccb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );

    if (Ccb->SearchExpression.Buffer != NULL) {

        UdfFreePool( &Ccb->SearchExpression.Buffer );
    }

    UdfDeallocateCcb( IrpContext, Ccb );
    return;
}


ULONG
UdfFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    )

/*++

Routine Description:

    This routine walks a table of string key/value information for a match of the
    input Id.  MaxIdLen can be set to get a prefix match.

Arguments:

    Table - This is the table being searched.

    Id - Key value.

    MaxIdLen - Maximum possible length of Id.

Return Value:

    Value of matching entry, or the terminating (NULL) entry's value.

--*/

{
    PAGED_CODE();

    while (ParseTable->Key != NULL) {

        if (RtlEqualMemory(ParseTable->Key, Id, MaxIdLen)) {

            break;
        }

        ParseTable++;
    }

    return ParseTable->Value;
}


#ifdef UDF_SANITY

//
//  Enumerate the reasons why a descriptor might be bad.
//

typedef enum _VERIFY_FAILURE {
    
    Nothing,
    BadLbn,
    BadTag,
    BadChecksum,
    BadCrcLength,
    BadCrc,
    BadDestagVersion

} VERIFY_FAILURE;

#endif

BOOLEAN
UdfVerifyDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PDESTAG Descriptor,
    IN USHORT Tag,
    IN ULONG Size,
    IN ULONG Lbn,
    IN BOOLEAN ReturnError
    )

/*++

Routine Description:

    This routine verifies that a descriptor using a Descriptor tag (3/7.2) is 
    consistent with itself and the descriptor data.

Arguments:

    Descriptor - This is the pointer to the descriptor tag, which is always
        at the front of a descriptor

    Tag - The Tag Identifier this descriptor should have

    Size - Size of this descriptor

    Lbn - The logical block number this descriptor should claim it is recorded at

    ReturnError - Whether this routine should return an error or raise

Return Value:

    Boolean TRUE if the descriptor is consistent, FALSE or a raised status of
    STATUS_DISK_CORRUPT_ERROR otherwise.

--*/

{
    UCHAR Checksum = 0;
    PCHAR CheckPtr;
    USHORT Crc;

#ifdef UDF_SANITY
    
    VERIFY_FAILURE FailReason = Nothing;

#endif
    
    //
    //  Check our inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

#ifdef UDF_SANITY

    if (UdfNoisyVerifyDescriptor) {

        goto BeNoisy;
    }

    RegularEntry:

#endif

    //
    //  The version of the Descriptor Tag specified in ISO 13346 and used in
    //  UDF is a particular value; presumeably, previous versions were used
    //  in some older revision of the standard.
    //

    if ( (DESTAG_VER_NSR02 == Descriptor->Version) || 
         ((DESTAG_VER_NSR03 == Descriptor->Version) && UdfExtendedFEAllowed(IrpContext->Vcb))  
       )  {

        //
        //  A descriptor is stamped in four ways. First, the Lbn of the sector
        //  containing the descriptor is written here. (3/7.2.8)
        //
        
        if (Descriptor->Lbn == Lbn)  {
        
            //
            //  Next, the descriptor tag itself has an identifier which should match
            //  the type we expect to find here (3/7.2.1)
            //
            
            if (Descriptor->Ident == Tag) {
        
                //
                //  Next, the descriptor tag itself is checksumed, minus the byte
                //  used to store the checksum. (3/7.2.3)
                //
            
                for (CheckPtr = (PCHAR) Descriptor;
                     CheckPtr < (PCHAR) Descriptor + FIELD_OFFSET( DESTAG, Checksum );
                     CheckPtr++) {
            
                    Checksum += *CheckPtr;
                }
        
                for (CheckPtr = (PCHAR) Descriptor + FIELD_OFFSET( DESTAG, Checksum ) + sizeof(UCHAR);
                     CheckPtr < (PCHAR) Descriptor + sizeof(DESTAG);
                     CheckPtr++) {
            
                    Checksum += *CheckPtr;
                }
        
                if (Descriptor->Checksum == Checksum) {
            
                    //
                    //  Now we check that the CRC in the Descriptor tag is sized sanely
                    //  and matches the Descriptor data. (3/7.2.6)
                    //
                    
                    if (Descriptor->CRCLen &&
                        Descriptor->CRCLen <= Size - sizeof(DESTAG))  {
    
                        Crc = UdfComputeCrc16( (PCHAR) Descriptor + sizeof(DESTAG),
                                               Descriptor->CRCLen );
                        
                        if (Descriptor->CRC == Crc)  {
                            
                            //
                            //  This descriptor checks out.
                            //
#ifdef UDF_SANITY
                            if (UdfNoisyVerifyDescriptor) {
                            
                                DebugTrace(( -1, Dbg, "UdfVerifyDescriptor -> TRUE\n" ));
                            }
#endif
                            return TRUE;
                    
                        } else {
#ifdef UDF_SANITY
                            FailReason = BadCrc;
                            goto ReportFailure;
#endif
                        }
    
                    } else {
#ifdef UDF_SANITY
                        FailReason = BadCrcLength;
                        goto ReportFailure;
#endif
                    }
            
                } else {
#ifdef UDF_SANITY
                    FailReason = BadChecksum;
                    goto ReportFailure;
#endif
                }
            
            } else {
#ifdef UDF_SANITY
                FailReason = BadTag;
                goto ReportFailure;
#endif
            }
        
        } else {
#ifdef UDF_SANITY
            FailReason = BadLbn;
            goto ReportFailure;
#endif
        }
    
    } else {
#ifdef UDF_SANITY
        FailReason = BadDestagVersion;
        goto ReportFailure;
#endif
    }

#ifdef UDF_SANITY

    BeNoisy:
    
    DebugTrace(( +1, Dbg,
                 "UdfVerifyDescriptor, Destag %08x, Tag %x, Size %x, Lbn %x\n",
                 Descriptor,
                 Tag,
                 Size,
                 Lbn ));

    if (FailReason == Nothing) {

        goto RegularEntry;
    
    } else if (!UdfNoisyVerifyDescriptor) {

        goto ReallyReportFailure;
    }

    ReportFailure:

    if (!UdfNoisyVerifyDescriptor) {

        goto BeNoisy;
    }

    ReallyReportFailure:

    switch (FailReason) {
        case BadLbn:
            DebugTrace(( 0, Dbg, 
                         "Lbn mismatch - Lbn %x != expected %x\n",
                         Descriptor->Lbn,
                         Lbn ));
            break;

        case BadTag:
            DebugTrace(( 0, Dbg,
                         "Tag mismatch - Ident %x != expected %x\n",
                         Descriptor->Ident,
                         Tag ));
            break;

        case BadChecksum:
            DebugTrace(( 0, Dbg,
                         "Checksum mismatch - Checksum %x != descriptor's %x\n",
                         Checksum,
                         Descriptor->Checksum ));
            break;

        case BadCrcLength:
            DebugTrace(( 0, Dbg,
                         "CRC'd size bad - CrcLen %x is 0 or > max %x\n",
                         Descriptor->CRCLen,
                         Size - sizeof(DESTAG) ));
            break;

        case BadCrc:
            DebugTrace(( 0, Dbg,
                         "CRC mismatch - Crc %x != descriptor's %x\n",
                         Crc,
                         Descriptor->CRC ));
            break;

        case BadDestagVersion:
            DebugTrace(( 0, Dbg,
                         "Bad Destag Verion %x - (Vcb->NsrVersion => max of %x)\n", Descriptor->Version, UdfExtendedFEAllowed( IrpContext->Vcb) ? 3 : 2));
            break;

        default:
            ASSERT( FALSE );
    }
    
    DebugTrace(( -1, Dbg, "UdfVerifyDescriptor -> FALSE\n" ));

#endif
    
    if (!ReturnError) {

        UdfRaiseStatus( IrpContext, STATUS_CRC_ERROR );
    }

    return FALSE;
}


VOID
UdfInitializeIcbContextFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize a context to search the Icb hierarchy
    associated with an Fcb.

Arguments:

    Fcb - Fcb associated with the hierarchy to search.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT( IrpContext->Vcb);

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext->Vcb = Fcb->Vcb;
    IcbContext->IcbType = DESTAG_ID_NSR_FILE;

    //
    //  Map the first extent into the current slot.
    //

    UdfMapMetadataView( IrpContext,
                        &IcbContext->Current,
                        IcbContext->Vcb,
                        UdfGetFidPartition( Fcb->FileId ),
                        UdfGetFidLbn( Fcb->FileId ),
                        BlockSize( IcbContext->Vcb ),
                        METAMAPOP_INIT_AND_MAP);    

    //
    //  It is possible that we don't have an idea what the length of the root extent is.
    //  This will commonly happen in the OpenById case.
    //
    
    if (Fcb->RootExtentLength == 0) {

        PICBFILE Icb = IcbContext->Current.View;
        
        //
        //  We can only accomplish the guess if we have a descriptor which contains an ICB
        //  Tag, which contains a field that can tell us what we need to know.
        //
        
        if (Icb->Destag.Ident == DESTAG_ID_NSR_ICBIND ||
            Icb->Destag.Ident == DESTAG_ID_NSR_ICBTRM ||
            Icb->Destag.Ident == DESTAG_ID_NSR_FILE ||
            (UdfExtendedFEAllowed( IrpContext->Vcb) && (Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE)) ||
            Icb->Destag.Ident == DESTAG_ID_NSR_UASE ||
            Icb->Destag.Ident == DESTAG_ID_NSR_PINTEG
           )  {
                
            UdfVerifyDescriptor( IrpContext,
                                 &Icb->Destag,
                                 Icb->Destag.Ident,
                                 BlockSize( IcbContext->Vcb ),
                                 UdfGetFidLbn( Fcb->FileId ),
                                 FALSE );
        } else {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Now the MaxEntries (4/14.6.4) field of the Icb Tag should tell us how big the extent
        //  should be.  The tail of this could be unrecorded.  We could even have landed in the middle
        //  of an extent.  This is only a guess.  For whatever reason we are having to guess this
        //  information, any results are expected to be coming with few guarantees.
        //

        Fcb->RootExtentLength = Icb->Icbtag.MaxEntries * BlockSize( IcbContext->Vcb );
    }
}


VOID
UdfInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PVCB Vcb,
    IN USHORT IcbType,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to initialize a context to search an Icb hierarchy.

Arguments:

    Vcb - Vcb for the volume.
    
    IcbType - Type of direct entry we expect to find (DESTAG_ID...)
    
    Partition - partition of the hierarchy.
    
    Lbn - lbn of the hierarchy.
    
    Length - length of the root extent of the hierarchy.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext->Vcb = Vcb;
    IcbContext->IcbType = IcbType;
    IcbContext->Active.Vsn = IcbContext->Current.Vsn = UDF_INVALID_VSN;
    
    //
    //  Map the first extent into the current slot.
    //

    UdfMapMetadataView( IrpContext,
                        &IcbContext->Current,
                        Vcb,
                        Partition,
                        Lbn,
                        Length,
                        METAMAPOP_INIT_AND_MAP);
    return;

}


VOID
UdfLookupActiveIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG IcbExtentLength
    )

/*++

Routine Description:

    This routine is called to cause the active Icb for an Icb hierarchy to be mapped.
    A context initialized by UdfInitializeIcbContext() is required.

Arguments:

    IcbContext - Context which has been initialized to point into an Icb hierarchy
                 (i.e. first block of current extent mapped in the Current entry).

Return Value:

    None.
    
    Raised status if the Icb hierarchy is invalid.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Travel the Icb hierarchy.  Due to the design of ISO 13346, it is convenient to
    //  recursively descend the hierarchy.  Place a limit on this recursion which will
    //  allow traversal of most reasonable hierarchies (this will tail recurse off of
    //  the end of extents).
    //

    UdfLookupActiveIcbInExtent( IrpContext,
                                IcbContext,
                                UDF_ICB_RECURSION_LIMIT,
                                IcbExtentLength);

    //
    //  We must have found an active ICB.  We don't need to unmap/remap
    //  if the currently mapped Icb is the active one,  as it will be 99.99%
    //  of the time.  Other case should only occur on WORM.
    //

    if ((IcbContext->Current.Lbn == IcbContext->Active.Lbn)  &&
        (NULL != IcbContext->Current.View)) {

        //
        //  Just copy the mapping information over from current to active.
        //

        RtlCopyMemory( &IcbContext->Active,
                       &IcbContext->Current,
                       sizeof( MAPPED_PVIEW));

        RtlZeroMemory( &IcbContext->Current,
                       sizeof( MAPPED_PVIEW));

        IcbContext->Current.Vsn = UDF_INVALID_VSN;
    }
    else {

        //
        //  Drop the last mapped part of the enumeration at this point,  and release 
        //  the vmcb mapping resource before attempting to map the active icb.
        //
        
        UdfUnpinView( IrpContext, &IcbContext->Current );

        //
        //  Actually map in the active ICB.  ...LookupActiveIcb..() will have already 
        //  initialised the view record with the Icb location so we specify 'remap'.
        //
        
        UdfMapMetadataView( IrpContext,
                            &IcbContext->Active,
                            IrpContext->Vcb,
                            0,
                            0,
                            BlockSize( IrpContext->Vcb ),
                            METAMAPOP_REMAP_VIEW);
    }
    
    if (IcbContext->Active.View == NULL) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


VOID
UdfCleanupIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    )

/*++

Routine Description:

    This routine cleans an Icb search context for reuse/deletion.

Arguments:

    IcbContext - context to clean

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Check we didn't map both active and current simultaneously (...vmcb purge
    //  limitations).
    //
    
    ASSERT( (NULL == IcbContext->Active.Bcb) || (NULL == IcbContext->Current.Bcb));
    
    UdfUnpinView( IrpContext, &IcbContext->Active );
    UdfUnpinView( IrpContext, &IcbContext->Current );

    ASSERT_NOT_HELD_VMCB( IrpContext->Vcb);

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));
}


VOID
UdfInitializeEaContext (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG EAType,
    IN UCHAR EASubType
    )

/*++

Routine Description:

    This routine initializes a walk through the EA space of an Icb which has been
    previously discovered.
    
    Note: only the embedded EA space is supported now.

Arguments:

    EaContext - EA context to fill in
    
    IcbContext - Elaborated ICB search structure 

Return Value:

--*/

{
    PICBFILE Icb;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT( IcbContext->Active.Bcb && IcbContext->Active.View );

    Icb = IcbContext->Active.View;

    EaContext->IcbContext = IcbContext;

    //
    //  Initialize to point at the first EA to return.
    //

    EaContext->Ea = FeEAs( Icb);
    EaContext->Remaining = FeEALength( Icb);

    EaContext->EAType = EAType;
    EaContext->EASubType = EASubType;
}


BOOLEAN
UdfLookupEa (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext
    )

/*++

Routine Description:

    This routine finds an EA in the EA space of an ICB.

Arguments:

    EaContext - an initialized EA search context containing an elaborated
        ICB search context and a description of the EA to find.

Return Value:

    BOOLEAN True if such an EA was found and returned, False otherwise.

--*/
{
    PICBFILE Icb;
    PNSR_EA_GENERIC GenericEa;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Quickly terminate if the EA space is empty or not capable of containing
    //  the header descriptor.  A null EA space is perfectly legal.
    //

    if (EaContext->Remaining == 0) {

        return FALSE;
    
    } else if (EaContext->Remaining < sizeof( NSR_EAH )) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Verify the integrity of the EA header.  This has a side effect of making
    //  very sure that we really have an EA sequence underneath us.
    //

    Icb = EaContext->IcbContext->Active.View;

    UdfVerifyDescriptor( IrpContext,
                         &((PNSR_EAH) EaContext->Ea)->Destag,
                         DESTAG_ID_NSR_EA,
                         sizeof( NSR_EAH ),
                         Icb->Destag.Lbn,
                         FALSE );
    
    //
    //  Push forward the start of the EA space and loop while we have more EAs to inspect.
    //  Since we only scan for ISO EA's right now, we don't need to open the EA header to
    //  jump forward to the Implementation Use or Application Use segments.
    //

    EaContext->Ea = Add2Ptr( EaContext->Ea, sizeof( NSR_EAH ), PVOID );
    EaContext->Remaining -= sizeof( NSR_EAH );
    
    while (EaContext->Remaining) {

        GenericEa = EaContext->Ea;

        //
        //  The EAs must appear on 4byte aligned boundaries, there must be room to find
        //  the generic EA preamble and the claimed length of the EA must fit in the
        //  remaining space.
        //
        
        if (LongOffsetPtr( EaContext->Ea ) ||
            EaContext->Remaining < FIELD_OFFSET( NSR_EA_GENERIC, EAData ) ||
            EaContext->Remaining < GenericEa->EALength ) {
        
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        if (GenericEa->EAType == EaContext->EAType && GenericEa->EASubType == EaContext->EASubType) {

            return TRUE;
        }

        EaContext->Ea = Add2Ptr( EaContext->Ea, GenericEa->EALength, PVOID );
        EaContext->Remaining -= GenericEa->EALength;
    }

    //
    //  If we failed to find the EA, we should have stopped at the precise end of the EA space.
    //
    
    if (EaContext->Remaining) {
        
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    return FALSE;
}


VOID
UdfInitializeAllocations (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowOneGigWorkaround
    )

/*++

Routine Description:

    This routine fills in the data retrieval information for an Fcb.

Arguments:

    Fcb - Fcb to add retrieval information to.
    
    IcbContext - Elaborated ICB search context corresponding to this Fcb.

Return Value:

    None.

--*/

{
    PICBFILE Icb = IcbContext->Active.View;
    PAD_GENERIC GenericAd;
    
    ALLOC_ENUM_CONTEXT AllocContext;

    LONGLONG RunningOffset;
    ULONG Psn;

    PVCB Vcb = Fcb->Vcb;

    BOOLEAN Result;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Immediately return for objects with zero information space.  Note that
    //  passing this test does not indicate that the file has any recorded space.
    //

    if (Fcb->FileSize.QuadPart == 0) {

        return;
    }

    //
    //  Init the allocation search context.  Note that in the non-immediate
    //  data case this can cause the active view (icb) to be unmapped
    //

    UdfInitializeAllocationContext( IrpContext,
                                    &AllocContext,
                                    IcbContext,
                                    AllowOneGigWorkaround);
    //
    //  Handle the case of embedded data.
    //

    if (AllocContext.AllocType == ICBTAG_F_ALLOC_IMMEDIATE) {

        //
        //  Teardown any existing mcb.
        //

        UdfUninitializeFcbMcb( Fcb );
        
        //
        //  Establish a single block mapping to the Icb itself and mark the Fcb as
        //  having embedded data.  Mapping will occur through the Metadata stream.
        //  Note that by virtue of having an Icb here we know it has already had
        //  a mapping established in the Metadata stream, so just retrieve that 
        //

        SetFlag( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA );

        Fcb->EmbeddedVsn = IcbContext->Active.Vsn;

        ASSERT( UDF_INVALID_VSN != Fcb->EmbeddedVsn );
        
        //
        //  Note the offset of the data in the Icb.
        //

        Fcb->EmbeddedOffset = FeEAsFieldOffset( Icb) + FeEALength( Icb);

        //
        //  Check that the information length agrees.
        //

        if (FeAllocLength(Icb) != Fcb->FileSize.LowPart)  {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations, embedded alloc %08x != filesize %08x\n",
                         FeAllocLength( Icb),
                         Fcb->FileSize.LowPart ));

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        return;
    }

    //
    //  Now initialize the mapping structure for this Fcb.
    //

    UdfInitializeFcbMcb( Fcb );

    //
    //  Now walk the chain of allocation descriptors for the object, adding them into the
    //  mapping.
    //

    RunningOffset = 0;

    do {
        
        //
        //  Check to see if we've read all of the extents for the file body yet.  
        //  We could do file tail consistency checking (4/12.1),  however as a read only
        //  implementation we don't care about the file tail,  and since there is no easy way
        //  of detecting loops in the tail,  we'll just ignore it for the sake of simplicity.
        //
        
        if (RunningOffset >= Fcb->FileSize.QuadPart) {

            break;
        }
        
        //
        //  It is impermissible for an interior body extent of an object to not be
        //  an integral multiple of a logical block in size (note that the last
        //  will tend not to be).  Also check that the body didn't overshoot the 
        //  information length (this check will also catch looped AD extents)
        //
        
        GenericAd = AllocContext.Alloc;

        if (BlockOffset( Vcb, RunningOffset ) || (Fcb->FileSize.QuadPart < RunningOffset))  {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations, bad alloc\n"));
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
            
        //
        //  Based on the descriptor type, pull it apart and add the mapping.
        //

        if (GenericAd->Length.Type == NSRLENGTH_TYPE_RECORDED) {

            //
            //  Grab the Psn this extent starts at and add the allocation.
            //

            Psn = UdfLookupPsnOfExtent( IrpContext,
                                        Vcb,
                                        UdfGetPartitionOfCurrentAllocation( &AllocContext ),
                                        GenericAd->Start,
                                        GenericAd->Length.Length );

            Result = FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                                            LlSectorsFromBytes( Vcb, RunningOffset ),
                                            Psn,
                                            SectorsFromBytes( Vcb, SectorAlign( Vcb, GenericAd->Length.Length ) ));

            ASSERT( Result );
        }

        RunningOffset += GenericAd->Length.Length;
    
    } 
    while ( UdfGetNextAllocation( IrpContext, &AllocContext ));

    //
    //  If the running offset doesn't match the expected file size,  then
    //  see if this file is a candidate for the ">1Gb in single AD mastering
    //  error" workaround.  Sigh...
    //

    if ((Fcb->FileSize.QuadPart != RunningOffset) &&
        (Fcb->Header.NodeTypeCode == UDFS_NTC_FCB_DATA) &&
        AllowOneGigWorkaround &&
        ((Fcb->FileSize.QuadPart & 0x3fffffff) == RunningOffset) &&
        (NULL != AllocContext.IcbContext->Active.View))  {

        PSHORTAD Ad;

        Icb = AllocContext.IcbContext->Active.View;
        Ad = Add2Ptr( FeEAs( Icb), FeEALength( Icb), PVOID );

        //
        //  Plausable.  So now verify that there is only a single AD and it contains
        //  precisely the expected (wrong) value.  We've already checked that the 
        //  original FE is still mapped.  
        //
        
        if (((Icb->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_SHORT) &&
            (FeAllocLength(Icb) == sizeof( SHORTAD)) &&
            (*((PULONG)(&Ad->Length)) == Fcb->FileSize.QuadPart))  {

            //
            //  Lookup the PSN for this extent.  This will also validate that our
            //  guestimated extent fits within partition bounds.
            //
            
            Psn = UdfLookupPsnOfExtent( IrpContext,
                                        Vcb,
                                        UdfGetPartitionOfCurrentAllocation( &AllocContext ),
                                        Ad->Start,
                                        Fcb->FileSize.LowPart );
            //
            //  So fix up the Mcb to represent this estimated extent
            //
                                       
            FsRtlTruncateLargeMcb( &Fcb->Mcb, 0);

            (void)FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                                         0,
                                         Psn,
                                         SectorsFromBytes( Vcb, SectorAlign( Vcb, Fcb->FileSize.LowPart ) ));

            RunningOffset = Fcb->FileSize.QuadPart;

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations -> 1 GIG AD workaround performed on Fcb 0x%p\n", Fcb));
        }
    }

    //
    //  Restore the ICB mapping if we unmapped it to traverse non embedded
    //  extent blocks.  Note that we key on Active->View here (rather than Bcb),  
    //  because during UdfInit...VcbPhase0 we are called with a phoney IcbContext 
    //  where View is a pointer to a buffer,  hence there was no bcb,  and 
    //  we don't want to create a mapping now.  Because the unmap operations 
    //  only act if NULL!=Bcb,  (not true in this case) view will still be 
    //  non-null here even after walking more allocation extents,  and we do nothing.
    //

    UdfUnpinView( IrpContext, &IcbContext->Current);
    
    if ( NULL == IcbContext->Active.View)  {
        
        UdfMapMetadataView( IrpContext, 
                            &IcbContext->Active,  
                            IrpContext->Vcb, 
                            0, 0, 0, 
                            METAMAPOP_REMAP_VIEW);
    }
    
    //
    //  We must have had body allocation descriptors for exactly the entire file
    //  information length.
    //

    if (Fcb->FileSize.QuadPart != RunningOffset) {

        DebugTrace(( 0, Dbg, "UdfInitializeAllocations, total descriptors != filesize\n" ));
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


VOID
UdfUpdateTimestampsFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PTIMESTAMP_BUNDLE Timestamps
    )

/*++

Routine Description:

    This routine converts the set of timestamps associated with a given ICB into
    an NT native form.

Arguments:

    IcbOontext - An search context containing the active direct ICB for the object
    
    Timestamps - the bundle of timestamps to receive the converted times.

Return Value:

    None.

--*/

{
    EA_SEARCH_CONTEXT EaContext;
    PICBFILE Icb = IcbContext->Active.View;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    // *TEJ - following should probably be a permanent runtime check? (ext fe + nsr03)?
    
    ASSERT( (Icb->Destag.Ident == DESTAG_ID_NSR_FILE) || ((Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE) && UdfExtendedFEAllowed( IrpContext->Vcb)));

    //
    //  Initialize the timestamps for this object.  Due to ISO 13346,
    //  we must gather EAs and figure out which of several timestamps is most valid.
    //  Pull the access & modification times from the ICB
    //

    UdfConvertUdfTimeToNtTime( IrpContext,
                               PFeModifyTime( Icb),
                               (PLARGE_INTEGER) &Timestamps->ModificationTime );

    UdfConvertUdfTimeToNtTime( IrpContext,
                               PFeAccessTime( Icb),
                               (PLARGE_INTEGER) &Timestamps->AccessTime );

    if (UdfFEIsExtended( Icb))  {
    
        //
        //  Creation time field is new in Extended FEs
        //
        
        UdfConvertUdfTimeToNtTime( IrpContext,
                                   PFeCreationTime( Icb),
                                   (PLARGE_INTEGER) &Timestamps->CreationTime );
    }
    else {

        //
        //  For a basic FileEntry,  look and see if a FileTimes EA has been recorded
        //  which contains a creation time.
        //
    
        UdfInitializeEaContext( IrpContext,
                                &EaContext,
                                IcbContext,
                                EA_TYPE_FILETIMES,
                                EA_SUBTYPE_BASE );

        if (UdfLookupEa( IrpContext, &EaContext )) {

            PNSR_EA_FILETIMES FileTimes = EaContext.Ea;
        
            if (FlagOn(FileTimes->Existence, EA_FILETIMES_E_CREATION)) {

                UdfConvertUdfTimeToNtTime( IrpContext,
                                           &FileTimes->Stamps[0],
                                           (PLARGE_INTEGER) &Timestamps->CreationTime );
            }
        }
        else {

            //
            //  No Timestamps EA recorded.  So we'll just use last mod time as creation
            //
            
            Timestamps->CreationTime = Timestamps->ModificationTime;
        }
    }
}


BOOLEAN
UdfCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called when we want to attach a file lock structure to the
    given Fcb.  It is possible the file lock is already attached.

    This routine is sometimes called from the fast path and sometimes in the
    Irp-based path.  We don't want to raise in the fast path, just return FALSE.

Arguments:

    Fcb - This is the Fcb to create the file lock for.

    RaiseOnError - If TRUE, we will raise on an allocation failure.  Otherwise we
        return FALSE on an allocation failure.

Return Value:

    BOOLEAN - TRUE if the Fcb has a filelock, FALSE otherwise.

--*/

{
    BOOLEAN Result = TRUE;
    PFILE_LOCK FileLock;

    PAGED_CODE();

    //
    //  Lock the Fcb and check if there is really any work to do.
    //

    UdfLockFcb( IrpContext, Fcb );

    if (Fcb->FileLock != NULL) {

        UdfUnlockFcb( IrpContext, Fcb );
        return TRUE;
    }

    Fcb->FileLock = FileLock =
        FsRtlAllocateFileLock( NULL, NULL );

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Return or raise as appropriate.
    //

    if (FileLock == NULL) {
         
        if (RaiseOnError) {

            ASSERT( ARGUMENT_PRESENT( IrpContext ));

            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        Result = FALSE;
    }

    return Result;
}


//
//  Local support routine
//

VOID
UdfLookupActiveIcbInExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG Recurse,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to traverse a single Icb hierarchy extent to discover
    an active Icb.  This is a recursive operation on indirect Icbs that may be
    found in the sequence.
    
Arguments:

    IcbContext - Context which has been initialized to point into an Icb hierarchy.
    
    Recurse - Recursion limit. 

    Length - Length of the extent currently described in IcbContext->Current (since
             we only map a block at a time the length in there will be 1 block...)

Return Value:

    None.
    
    Raised status if the Icb hierarchy is invalid.

--*/

{
    PVCB Vcb = IcbContext->Vcb;
    PFCB Fcb = Vcb->MetadataFcb;

    ULONG Lbn;
    USHORT Partition;

    ULONG Vsn;

    PICBIND Icb;

    PAGED_CODE();

    //
    //  Should only ever have a single view mapped.  We're using Current,  so...
    //
    
    ASSERT( NULL == IcbContext->Active.Bcb );
    ASSERT( NULL != IcbContext->Current.View );
    
    //
    //  Don't expect to see extended FE as search type (we just use basic FE and
    //  treat as potentially either).
    //
    
    ASSERT( DESTAG_ID_NSR_EXT_FILE != IcbContext->IcbType);
    
    //
    //  Decrement our recursion allowance.
    //
    
    Recurse--;

    //
    //  Grab our starting point
    //

    Partition = IcbContext->Current.Partition;
    Lbn = IcbContext->Current.Lbn;

    Icb = IcbContext->Current.View;

    //
    //  Walk across the extent
    //

    do {
        
        switch (Icb->Destag.Ident) {
                        
            case DESTAG_ID_NSR_ICBIND:

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     DESTAG_ID_NSR_ICBIND,
                                     sizeof( ICBIND ),
                                     Lbn,
                                     FALSE );

                //
                //  Go to the next extent if this indirect Icb actually points to something.
                //

                if (Icb->Icb.Length.Type == NSRLENGTH_TYPE_RECORDED) {

                    //
                    //  If we are in the last entry of the Icb extent, we may tail recurse. This
                    //  is very important for strategy 4096, which is a linked list of extents
                    //  of depth equal to the number of times the direct Icb had to be re-recorded.

                    //
                    //  We only expect to see an indirect block at the end of an  Icb
                    //  extent (4096),  so this should be the last block in the current
                    //  extent.  Anything else is corruption as far as we're concerned.
                    //
                    
                    if ((Length != BlockSize( Vcb)) || 
                        (Partition != Icb->Icb.Start.Partition))  {

                        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    }

                    //
                    //  Update our pointers.  The next extent will be mapped further down
                    //  before the next pass of the loop.
                    //
                    
                    Lbn = Icb->Icb.Start.Lbn - 1,
                    Length = Icb->Icb.Length.Length + BlockSize( Vcb);
                }

                break;

            case DESTAG_ID_NSR_ICBTRM:

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     DESTAG_ID_NSR_ICBTRM,
                                     sizeof( ICBTRM ),
                                     Lbn,
                                     FALSE );

                //
                //  Terminate the current extent.
                //

                return;
                break;

            case DESTAG_ID_NOTSPEC:

                //
                //  Perhaps this is an unrecorded sector.  Treat this as terminating
                //  the current extent.
                //

                return;
                break;

            default:

                //
                //  This is a data-full Icb.  It must be of the expected type.  We will
                //  accept EXT FEs here iff the search type was FE and the volume conforms to
                //  NSR03.
                //
                
                if ( (Icb->Destag.Ident != IcbContext->IcbType) && 
                     ( (DESTAG_ID_NSR_FILE != IcbContext->IcbType) || 
                       (!UdfExtendedFEAllowed( IrpContext->Vcb)) ||
                       (DESTAG_ID_NSR_EXT_FILE != Icb->Destag.Ident)
                     )
                   )  {
                    
                    UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                //
                //  Since direct entries are of variable size, we must allow up to
                //  a block's worth of data.
                //

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     Icb->Destag.Ident,
                                     BlockSize( Vcb ),
                                     Lbn,
                                     FALSE );
                //
                //  We perform an in-order traversal of the hierarchy.  This is important since
                //  it means no tricks are neccesary to figure out the rightmost direct Icb -
                //  always stash the last one we see.
                //
                //  Map this logical block into the active slot.  We know that a direct entry
                //  must fit in a single logical block.
                //
                //  Note that we don't actually do the mapping operation here,  just store
                //  the Icb location (we don't want two active mappings in the same thread
                //  because it complicates the vmcb purge synchronisation logic).  
                //  Also more effecient.
                //

                UdfMapMetadataView( IrpContext,
                                    &IcbContext->Active,
                                    Vcb,
                                    Partition,
                                    Lbn,
                                    BlockSize( Vcb ),
                                    METAMAPOP_INIT_VIEW_ONLY );
        }

        //
        //  Advance our pointer set.
        //

        Lbn++;
        Length -= BlockSize( Vcb );

        //
        //  If neccessary,  map the next block in this extent (strat 4096).
        //
        
        if (0 != Length)  {

            UdfMapMetadataView( IrpContext,
                                &IcbContext->Current,
                                Vcb,
                                Partition,
                                Lbn,
                                BlockSize( Vcb),
                                METAMAPOP_INIT_AND_MAP);

            Icb = IcbContext->Current.View;
        }
    } 
    while (Length);
}


//
//  Local support routine
//

VOID
UdfInitializeAllocationContext (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowSingleZeroLengthExtent
    )

/*++

Routine Description:

    Initializes a walk of the allocation descriptors for an ICB which has already
    been found.  The first allocation descriptor will be avaliable after the call.

    Can potentially exit with the AllocContext->IcbContext->Active view unmapped if
    there are no descriptors embedded in the Icb (so current will now be mapped to the
    next block of extents),  or the data is immediate.

Arguments:

    AllocContext - Allocation enumeration context to use
    
    IcbContext - Elaborated ICB search context for the ICB to enumerate

Return Value:

    None.

--*/

{
    PICBFILE Icb;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT( IcbContext->Active.View );

    AllocContext->IcbContext = IcbContext;

    //
    //  Figure out what kind of descriptors will be here.
    //

    Icb = IcbContext->Active.View;
    AllocContext->AllocType = FlagOn( Icb->Icbtag.Flags, ICBTAG_F_ALLOC_MASK );

    //
    //  We are done if this is actually immediate data.
    //
    
    if (AllocContext->AllocType == ICBTAG_F_ALLOC_IMMEDIATE) {

        return;
    }
    
    //
    //  The initial chunk of allocation descriptors is inline with the ICB and
    //  does not contain an Allocation Extent Descriptor.
    //

    AllocContext->Alloc = Add2Ptr( FeEAs( Icb), FeEALength( Icb), PVOID );
    AllocContext->Remaining = FeAllocLength( Icb);

    ASSERT( LongOffsetPtr( AllocContext->Alloc ) == 0 );

    //
    //  Check that the specified amount of ADs/embedded data can actually fit 
    //  within the block.
    //
    
    if (AllocContext->Remaining > 
        (BlockSize( IrpContext->Vcb) - (FeEAsFieldOffset( Icb) + FeEALength( Icb))))  {

        DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext(), AD_Len 0x%x for Icb > (Blocksize - (FE+EAs))\n", 
                    AllocContext->Remaining));
                    
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
    
    //
    //  Check that an integral number of the appropriate allocation descriptors fit in
    //  this extent and that the extent is not composed of extended allocation descriptors,
    //  which are illegal on UDF.  
    //
    //  If the common post-processing fails, we probably did not find any allocation
    //  descriptors (case of nothing but continuation).  This is likewise bad.
    //

    if (AllocContext->Remaining == 0 ||
        AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType ) ||
        AllocContext->AllocType == ICBTAG_F_ALLOC_EXTENDED ||
        !UdfGetNextAllocationPostProcessing( IrpContext, AllocContext )) {

        //
        //  Do some final verification/traversal of continuation extents.  We need to
        //  allow zero length extents here if we're allowing the 1Gb corrupt AD workaround,
        //  since a 1Gb extent will be encoded as type 1,  length 0...  Note that if someone
        //  has managed to record a 4Gb-1block extent,  the postprocess function above
        //  will raise (will see a continuation extent > 1 block).  We'll just hope that 
        //  noone's been that stupid.
        //
        //  This case is deliberately extremely specific.
        //

        if (!(AllowSingleZeroLengthExtent && 
             (AllocContext->AllocType == ICBTAG_F_ALLOC_SHORT) && 
             (AllocContext->Remaining == sizeof( SHORTAD)) &&
             (((PSHORTAD)AllocContext->Alloc)->Length.Length == 0) &&
             (((PSHORTAD)AllocContext->Alloc)->Length.Type != 0)))  {
            
            DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext:  Failing - Rem %x Rem%%size %x Type %x\n", 
                        AllocContext->Remaining, 
                        AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType ), 
                        AllocContext->AllocType));
                        
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
        else {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext:  Ignoring zero length initial AD due to 1Gb workaround\n"));
        }
    }
}


//
//  Local support routine
//

BOOLEAN
UdfGetNextAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    )

/*++

Routine Description:

    This routine retrieves the next logical allocation descriptor given an enumeration
    context.

    Any ACTIVE view in the AllocContext->IcbContext will be unmapped.

Arguments:

    AllocContext - Context to advance to the next descriptor

Return Value:

    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.
    
    This routine will raise if malformation is discovered.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    AllocContext->Remaining -= ISOAllocationDescriptorSize( AllocContext->AllocType );
    AllocContext->Alloc = Add2Ptr( AllocContext->Alloc, ISOAllocationDescriptorSize( AllocContext->AllocType ), PVOID );

    return UdfGetNextAllocationPostProcessing( IrpContext, AllocContext );
}
    

BOOLEAN
UdfGetNextAllocationPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    )

/*++

Routine Description:

    This routine retrieves the next logical allocation descriptor given an enumeration
    context.

Arguments:

    AllocContext - Context to advance to the next descriptor

Return Value:

    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.
    
    This routine will raise if malformation is discovered.

--*/

{
    PAD_GENERIC GenericAd;
    PNSR_ALLOC AllocDesc;
    ULONG Start;
    USHORT Partition;
    

    PVCB Vcb = AllocContext->IcbContext->Vcb;

    //
    //  There are three ways to reach the end of the current block of allocation
    //  descriptors, per ISO 13346 4/12:
    //
    //      reach the end of the field (kept track of in the Remaining bytes)
    //      reach an allocation descriptor with an extent length of zero
    //      reach a continuation extent descriptor
    //
    
    //
    //  We are done in the first two cases.
    //

    if (AllocContext->Remaining < ISOAllocationDescriptorSize( AllocContext->AllocType )) {
        
        return FALSE;
    }

    while (TRUE) {
        
        GenericAd = AllocContext->Alloc;
    
        if (GenericAd->Length.Length == 0) {
    
            return FALSE;
        }
        
        //
        //  Check if this descriptor is a pointer to another extent of descriptors.
        //
    
        if (GenericAd->Length.Type != NSRLENGTH_TYPE_CONTINUATION) {
            
            break;
        }
    
        //
        //  UDF allocation extents are restricted to a single logical block.
        //

        if (GenericAd->Length.Length > BlockSize( Vcb )) {
            
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Extract required values from the current block of extents,  which
        //  may be the active ICB mapping which we're about to throw away...
        //

        Start = GenericAd->Start;
        Partition = UdfGetPartitionOfCurrentAllocation( AllocContext );
        
        //
        //  Ensure that any active view is unmapped at this point,  and destroy
        //  pointers into it
        //
        
        UdfUnpinView( IrpContext, &AllocContext->IcbContext->Active);
        GenericAd = NULL;

        //
        //  Map the next block of extents
        //
        
        UdfMapMetadataView( IrpContext,
                            &AllocContext->IcbContext->Current,
                            Vcb,
                            Partition,
                            Start,
                            BlockSize( Vcb ),
                            METAMAPOP_INIT_AND_MAP);
        
        //
        //  Now check that the allocation descriptor is valid.
        //

        AllocDesc = (PNSR_ALLOC) AllocContext->IcbContext->Current.View;

        UdfVerifyDescriptor( IrpContext,
                             &AllocDesc->Destag,
                             DESTAG_ID_NSR_ALLOC,
                             BlockSize( Vcb ),
                             AllocContext->IcbContext->Current.Lbn,
                             FALSE );

        //
        //  Note that a full logical block is mapped, but only the claimed number of
        //  bytes are valid.
        //

        AllocContext->Remaining = AllocDesc->AllocLen;
        AllocContext->Alloc = Add2Ptr( AllocContext->IcbContext->Current.View, sizeof( NSR_ALLOC ), PVOID );

        //
        //  Check that the size is sane and that an integral number of the appropriate
        //  allocation descriptors fit in this extent.
        //

        if (AllocContext->Remaining == 0 ||
            AllocContext->Remaining > BlockSize( Vcb ) - sizeof( NSR_ALLOC ) ||
            AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType )) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
    }
    
    return TRUE;
}


//
//  Local support routine
//

PFCB_NONPAGED
UdfCreateFcbNonPaged (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to create and initialize the non-paged portion
    of an Fcb.

Arguments:

Return Value:

    PFCB_NONPAGED - Pointer to the created nonpaged Fcb.  NULL if not created.

--*/

{
    PFCB_NONPAGED FcbNonpaged;

    PAGED_CODE();

    //
    //  Allocate the non-paged pool and initialize the various
    //  synchronization objects.
    //

    FcbNonpaged = UdfAllocateFcbNonpaged( IrpContext );

    RtlZeroMemory( FcbNonpaged, sizeof( FCB_NONPAGED ));

    FcbNonpaged->NodeTypeCode = UDFS_NTC_FCB_NONPAGED;
    FcbNonpaged->NodeByteSize = sizeof( FCB_NONPAGED );

    ExInitializeResourceLite( &FcbNonpaged->FcbResource );
    ExInitializeFastMutex( &FcbNonpaged->FcbMutex );

    return FcbNonpaged;
}


//
//  Local support routine
//

VOID
UdfDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    )

/*++

Routine Description:

    This routine is called to cleanup the non-paged portion of an Fcb.

Arguments:

    FcbNonpaged - Structure to clean up.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &FcbNonpaged->FcbResource );

    UdfDeallocateFcbNonpaged( IrpContext, FcbNonpaged );

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
UdfFcbTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID id1,
    IN PVOID id2
    )

/*++

Routine Description:

    This routine is the Udfs compare routine called by the generic table package.
    If will compare the two File Id values and return a comparison result.

Arguments:

    Table - This is the table being searched.

    id1 - First key value.

    id2 - Second key value.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_ID Id1, Id2;
    PAGED_CODE();

    Id1 = *((FILE_ID UNALIGNED *) id1);
    Id2 = *((FILE_ID UNALIGNED *) id2);

    if (Id1.QuadPart < Id2.QuadPart) {

        return GenericLessThan;

    } else if (Id1.QuadPart > Id2.QuadPart) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }

    UNREFERENCED_PARAMETER( Table );
}


//
//  Local support routine
//

PVOID
UdfAllocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return( FsRtlAllocatePoolWithTag( UdfPagedPool, ByteSize, TAG_GENERIC_TABLE ));
}


//
//  Local support routine
//

VOID
UdfDeallocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( Buffer );

    return;
    UNREFERENCED_PARAMETER( Table );
}
    

BOOLEAN
UdfDomainIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Domain,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax
    )
/*++

Routine Description:

    A Domain Identifier RegID is considered to be contained if the
    text string identifier matches and the revision is less than or
    equal.  This is the convenient way to check that a Domain ID
    indicates a set of structures will be intelligible to a given
    implementation level.

Arguments:

    RegID  - Registered ID structure to verify
    
    Domain - Domain to look for

    RevisionMin, RevisionMax - Revision range to accept.

Return Value:

    None.

--*/
{
    PUDF_SUFFIX_DOMAIN DomainSuffix = (PUDF_SUFFIX_DOMAIN) RegID->Suffix;
    BOOLEAN Contained;

    Contained = ((DomainSuffix->UdfRevision <= RevisionMax && DomainSuffix->UdfRevision >= RevisionMin) &&
                UdfEqualEntityId( RegID, Domain, NULL ));

#ifdef UDF_SANITY
    if (!Contained)  {
    
        UCHAR Want[24], Got[24];

        strncpy( Want, Domain->Buffer, Domain->Length);
        Want[Domain->Length] = '\0';
        
        strncpy( Got, RegID->Identifier, Domain->Length);
        Got[Domain->Length] = '\0';
    
        DebugTrace((0, Dbg, "UdfDomainIdentifierContained() FAILED - Expected %X<>%X '%s',  Found %X '%s'\n", RevisionMin, RevisionMax, Want, DomainSuffix->UdfRevision, Got));
    }
#endif

    return Contained;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\read.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     22-Sep-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_READ)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_READ)

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonRead)
#endif


NTSTATUS
UdfCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common entry point for NtReadFile calls.  For synchronous requests,
    CommonRead will complete the request in the current thread.  If not
    synchronous the request will be passed to the Fsp if there is a need to
    block.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;
    PVCB Vcb;

    BOOLEAN Wait;
    ULONG PagingIo;
    ULONG SynchronousIo;
    ULONG NonCachedIo;

    LONGLONG StartingOffset;
    LONGLONG ByteRange;
    ULONG ByteCount;
    ULONG ReadByteCount;
    ULONG OriginalByteCount;

    PVOID SystemBuffer, UserBuffer;

    BOOLEAN ReleaseFile = TRUE;
    BOOLEAN ReleaseVmcbMap = FALSE;

    PFILE_OBJECT MappingFileObject;

    UDF_IO_CONTEXT LocalIoContext;

    PAGED_CODE();

    //
    //  If this is a zero length read then return SUCCESS immediately.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object and verify we support read on this.  It
    //  must be a user file, stream file or volume file (for a data disk).
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if ((TypeOfOpen == UnopenedFileObject) || (TypeOfOpen == UserDirectoryOpen)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    Vcb = Fcb->Vcb;

    //
    //  Examine our input parameters to determine if this is noncached and/or
    //  a paging io operation.
    //

    Wait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    PagingIo = FlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = FlagOn( Irp->Flags, IRP_NOCACHE );
    SynchronousIo = FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );

    //
    //  Extract the range of the Io.
    //

    StartingOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    OriginalByteCount = ByteCount = IrpSp->Parameters.Read.Length;

    ByteRange = StartingOffset + ByteCount;

    //
    //  Make sure that Dasd access is always non-cached.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    //
    //  Acquire the file shared to perform the read.  If we are doing paging IO,
    //  it may be the case that we would have a deadlock imminent because we may
    //  block on shared access, so starve out any exclusive waiters.  This requires
    //  a degree of caution - we believe that any paging IO bursts will recede and
    //  allow the exclusive waiter in.
    //

    if (PagingIo) {

        UdfAcquireFileSharedStarveExclusive( IrpContext, Fcb );
    
    } else {
        
        UdfAcquireFileShared( IrpContext, Fcb );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb. Allow reads if this is a DASD handle that is 
        //  dismounting the volume.
        //
        
        if ((TypeOfOpen != UserVolumeOpen) || (NULL == Ccb) ||
            !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {

            UdfVerifyFcbOperation( IrpContext, Fcb );
        }

        //
        //  If this is a user request then verify the oplock and filelock state.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  We check whether we can proceed
            //  based on the state of the file oplocks.
            //

            Status = FsRtlCheckOplock( &Fcb->Oplock,
                                       Irp,
                                       IrpContext,
                                       UdfOplockComplete,
                                       UdfPrePostIrp );

            //
            //  If the result is not STATUS_SUCCESS then the Irp was completed
            //  elsewhere.
            //

            if (Status != STATUS_SUCCESS) {

                Irp = NULL;
                IrpContext = NULL;

                try_leave( Status );
            }

            if (!PagingIo &&
                (Fcb->FileLock != NULL) &&
                !FsRtlCheckLockForReadAccess( Fcb->FileLock, Irp )) {

                try_leave( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }



        if ((TypeOfOpen != UserVolumeOpen) || !FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

            //
            //  Complete the request if it begins beyond the end of file.
            //

            if (StartingOffset >= Fcb->FileSize.QuadPart) {

                try_leave( Status = STATUS_END_OF_FILE );
            }

            //
            //  Truncate the read if it extends beyond the end of the file.
            //

            if (ByteRange > Fcb->FileSize.QuadPart) {

                ASSERT( Fcb != Vcb->MetadataFcb);
                
                ByteCount = (ULONG) (Fcb->FileSize.QuadPart - StartingOffset);
                ByteRange = Fcb->FileSize.QuadPart;
            }

        }

        //
        //  Now if the data is embedded in the ICB, map through the metadata
        //  stream to retrieve the bytes.
        //
            
        if (FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA )) {

            //
            //  The metadata stream better be here by now.
            //

            ASSERT( Vcb->MetadataFcb->FileObject != NULL );

            //
            //  Bias our starting offset by the offset of the ICB in the metadata
            //  stream plus the offset of the data bytes in that ICB.  Obviously,
            //  we aren't doing non-cached IO here.
            //

            StartingOffset += (LlBytesFromSectors( Vcb, Fcb->EmbeddedVsn ) + Fcb->EmbeddedOffset);
            MappingFileObject = Vcb->MetadataFcb->FileObject;
            NonCachedIo = FALSE;

            //
            //  Ensure that we're mapping within the range of the metadata stream
            //

            ASSERT( (StartingOffset + ByteCount) <= Vcb->MetadataFcb->FileSize.QuadPart);
 
        } else {

            //
            //  We are mapping through the caller's fileobject
            //
            
            MappingFileObject = IrpSp->FileObject;
        }
        
        //
        //  Handle the non-cached read first.
        //

        if (NonCachedIo) {

            //
            //  If we have an unaligned transfer then post this request if
            //  we can't wait.  Unaligned means that the starting offset
            //  is not on a sector boundary or the read is not integral
            //  sectors.
            //

            ReadByteCount = SectorAlign( Vcb, ByteCount );

            if (SectorOffset( Vcb,  StartingOffset ) ||
                (ReadByteCount > OriginalByteCount)) {

                if (!Wait) {

                    UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                //
                //  Make sure we don't overwrite the buffer.
                //

                ReadByteCount = ByteCount;
            }

            //
            //  Initialize the IoContext for the read.
            //  If there is a context pointer, we need to make sure it was
            //  allocated and not a stale stack pointer.
            //

            if (IrpContext->IoContext == NULL ||
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

                //
                //  If we can wait, use the context on the stack.  Otherwise
                //  we need to allocate one.
                //

                if (Wait) {

                    IrpContext->IoContext = &LocalIoContext;
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

                } else {

                    IrpContext->IoContext = UdfAllocateIoContext();
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                }
            }

            RtlZeroMemory( IrpContext->IoContext, sizeof( UDF_IO_CONTEXT ));
    
            //
            //  Store whether we allocated this context structure in the structure
            //  itself.
            //
    
            IrpContext->IoContext->AllocatedContext =
                BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            if (Wait) {

                KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                                   NotificationEvent,
                                   FALSE );

            } else {

                IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
                IrpContext->IoContext->Resource = Fcb->Resource;
                IrpContext->IoContext->RequestedByteCount = ByteCount;
            }
    
            Irp->IoStatus.Information = ReadByteCount;

            //
            //  Call the NonCacheIo routine to perform the actual read.
            //

            Status = UdfNonCachedRead( IrpContext, Fcb, Ccb, StartingOffset, ReadByteCount );

            //
            //  Don't complete this request now if STATUS_PENDING was returned.
            //

            if (Status == STATUS_PENDING) {

                Irp = NULL;
                ReleaseFile = FALSE;

            //
            //  Test is we should zero part of the buffer or update the
            //  synchronous file position.
            //

            } else {

                //
                //  Convert any unknown error code to IO_ERROR.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Set the information field to zero.
                    //

                    Irp->IoStatus.Information = 0;

                    //
                    //  Raise if this is a user induced error.
                    //

                    if (IoIsErrorUserInduced( Status )) {

                        UdfRaiseStatus( IrpContext, Status );
                    }

                    Status = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Check if there is any portion of the user's buffer to zero.
                //

                } else if (ReadByteCount != ByteCount) {

                    UdfMapUserBuffer( IrpContext, &UserBuffer );
                    
                    SafeZeroMemory( IrpContext,
                                    Add2Ptr( UserBuffer,
                                             ByteCount,
                                             PVOID ),
                                    ReadByteCount - ByteCount );

                    Irp->IoStatus.Information = ByteCount;
                }

                //
                //  Update the file position if this is a synchronous request.
                //

                if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

                    IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
                }
            }

            try_leave( NOTHING );
        }

        //
        //  Handle the cached case.  Start by initializing the private
        //  cache map.
        //

        if (MappingFileObject->PrivateCacheMap == NULL) {

            //
            //  The metadata Fcb stream was fired up before any data read.  We should never
            //  see it here.
            //

            ASSERT( MappingFileObject != Vcb->MetadataFcb->FileObject );
            
            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( IrpSp->FileObject,
                                  (PCC_FILE_SIZES) &Fcb->AllocationSize,
                                  FALSE,
                                  &UdfData.CacheManagerCallbacks,
                                  Fcb );

            CcSetReadAheadGranularity( IrpSp->FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Read from the cache if this is not an Mdl read.
        //

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            UdfMapUserBuffer( IrpContext, &SystemBuffer);

            //
            // Now try to do the copy.
            //
            
            if (MappingFileObject == Vcb->MetadataFcb->FileObject)  {
            
                UdfAcquireVmcbForCcMap( IrpContext, Vcb);
                ReleaseVmcbMap = TRUE;
            }
            
            if (!CcCopyRead( MappingFileObject,
                             (PLARGE_INTEGER) &StartingOffset,
                             ByteCount,
                             Wait,
                             SystemBuffer,
                             &Irp->IoStatus )) {

                try_leave( Status = STATUS_CANT_WAIT );
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                UdfNormalizeAndRaiseStatus( IrpContext, Irp->IoStatus.Status );
            }

            Status = Irp->IoStatus.Status;

        //
        //  Otherwise perform the MdlRead operation.
        //

        } else {

            CcMdlRead( MappingFileObject,
                       (PLARGE_INTEGER) &StartingOffset,
                       ByteCount,
                       &Irp->MdlAddress,
                       &Irp->IoStatus );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Update the current file position in the user file object.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
        }

    } finally {

        DebugUnwind( "UdfCommonRead" );

        //
        //  Release the Fcb / Vmcb mapping resource
        //

        if (ReleaseFile)        {   UdfReleaseFile( IrpContext, Fcb );  }

        if (ReleaseVmcbMap)     {   UdfReleaseVmcb( IrpContext, Vcb);   }
    }

    //
    //  Post the request if we got CANT_WAIT.
    //

    if (Status == STATUS_CANT_WAIT) {

        Status = UdfFsdPostRequest( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udf.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    Udf.h

Abstract:

    This module contains all definitions specified by the OSTA UDF standard which
    are not defined in ISO 13346 and associated errta.  UDF is a subset of ISO 13346
    which restricts many facets of the ISO standard and is currently standardized
    by the Optical Storage Technology Association (http://www.osta.org).  Some
    aspects of the structures we read may seem illogical unless viewed in this light.

    Unless otherwise specified, section references will be to ISO 13346.

    Also unless otherwise specified, all descriptors mentioned will be sector aligned 

    A UDF volume is recognized by searching the Volume Recognition Area (2/8.3) for a
    Volume Structure Descriptor (2/9.1) which advertises itself as NSR02, the filesystem
    format specified by ISO 13346 section 4.  This is aligned to match ISO 9660, and the
    first descriptor may in fact be a 9660 PVD.  ISO 13346 descriptors are bounded by
    a Begin Extended Area descriptor (2/9.2) and a Terminate Extended Area descriptor
    (2/9.3).

    +-------+-------+     +-------+     +-------+
    |       |       |     |       |     |       |
    | CD001 | BEA01 | ... | NSR02 | ... | TEA01 |
    |       |       |     |       |     |       |
    +-------+-------+     +-------+     +-------+

    A UDF volume is then discovered by looking for an Anchor Volume Descriptor (3/10.2),
    which reveals the location of a pair of extents of the physical volume that contain
    copies of the Volume Descriptor Sequence.  Both of these copies are defined to be
    equivalent (duplication is intended for diasaster recovery).

    +-------+              +------------------------------------+
    |       | -----------> |                                    |
    |  AVD  |              |   Main Volume Descriptor Sequence  |
    |       | ----+        |                                    |
    +-------+     |        +------------------------------------+
                  |         
                  |        +------------------------------------+
                  |        |                                    | 
                  +------> | Reserve Volume Descriptor Sequence |
                           |                                    |
                           +------------------------------------+

    An ISO 13346 logical (mountable) volume is composed of a number Np of physical partitions
    spread across a number Nd of physical volumes (media), all of which may be multiply
    referenced to create a numbed Nv of logical volumes.  While ISO 13346 allows this level of
    complexity, UDF restricts as follows: Nv = 1 and Np = Nd except if Nd = 1 then perhaps
    Np = 2 and one partition is read/write while the other is readonly.  There are three levels
    of conforming implementations which are defined by ISO 1336 in 3/11 which progress from 1,
    a restricted Nd = 1, to 3 where Nd > 1.  This is a readonly level 2 implementation, which
    is an unrestricted single physical media implementation - other than those imposed by UDF.

    A Volume Descriptor Sequence is composed of a number of descriptors which collectively nail
    down a volume:

        Primary Volume Descriptor           (PVD)  Identification of the physical media and its
        (3/10.1)                                     relation to a volume set.

        Volume Descriptor Pointer           (VSD)  Identification of a continuing extent of the Volume
        (3/10.3)                                    Descriptor Sequence (the VDS need not be a single
                                                    extent).
                                                
        Implementation Use Volume Desciptor (IUVD) Exactly that.
        (3/10.4)

        Partition Descriptor                (PD)   Identification of a linear extent of sectors
        (3/10.5)                                    on a physical media (type 1) or an implementation
                                                    defined object (type 2).

        Logical Volume Descriptor           (LVD)  Identification of a mountable volume by
        (3/10.6)                                    referring to partition(s) and a location for
                                                    a File Set Descriptor.
                                                
        Unallocated Space Descriptor        (USD)  Identification of an unallocated extents of the
        (3/10.8)                                    media which could be added to existing partitions
                                                    or allocated through new partitions.

        Terminating Descriptor              (TD)   A method of terminating the Volume Descriptor
        (3/10.9)                                    Sequence.  A VDS may also be terminated by an
                                                    unrecorded sector or running to the end of an
                                                    extent.

    An ISO 13346 volume set is a grouping of physical media, identified collectively by examining
    the PVD of each unit. A Volume Descriptor Sequence is recorded on each constituent of the volume
    set, but only the volume with the highest Volume Sequence Number may contain LVD.  An LVD may
    refer to any PD on any member of the volume set.

    Each descriptor contains a Volume Sequence Number which allows an otherwise identification
    equivalent descriptor (i.e., specifies the same Partition Number (for PD), same Logical
    Volume Identifier (for LVD), etc. (3/8.4.3)) to override one of lower VSN.
    
    So, a picture of what a Volume Descriptor Sequence could look like is
    
    +------+------+------+------+------+
    |      |      |      |      |      |
    | PVD  | LVD  |  PD  |  PD  |  VDP |
    |      |      |      |      |      |
    +------+------+------+------+------+
                                    |
                                    |  +------+------+------+------+
                                    |  |      |      |      |      |
                                    +->| USD  | IUVD | IUVD |  TD  |
                                       |      |      |      |      |
                                       +------+------+------+------+
                                       
    The LVD points to a File Set Descriptor (4/14.1), which finally points to a root directory.
    
// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   10-Jul-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#ifndef _UDF_
#define _UDF_

#include <iso13346.h>

//
//  This is the version of UDF that we recognize, per the Domain Identifier
//  specification in UDF 2.1.5.3.
//
//  The values below indicate we understand UDF 2.01.  We will also define
//  specific revisions so that we can assert correctness for some structures
//  that we know appeared for the first time in certain specifications.
//
//

#define UDF_VERSION_100         0x0100
#define UDF_VERSION_101         0x0101
#define UDF_VERSION_102         0x0102
#define UDF_VERSION_150         0x0150
#define UDF_VERSION_200         0x0200
#define UDF_VERSION_201         0x0201

#define UDF_VERSION_RECOGNIZED  UDF_VERSION_201

#define UDF_VERSION_MINIMUM     UDF_VERSION_100


//
//  Method 2 Fixup.
//
//  This really isn't UDF, but for lack of a better place ... and since we are doing
//  the work for UDF only.  In the filesystem.  Sigh.
//
//  Various bad CD-ROM units, when reading fixed-packet CD-RW media, fail to map out
//  the runin/out  blocks that follow each packet of 32 sectors on the media.  As a
//  result, we have to fixup all of the byte offsets to read the image.
//
//  Note: fixed packet. Variable packet discs do have the runin/out exposed, but
//  imaging software will have realized this and numbered sectors right.
//
//  Normally we would refuse to deal with this garbage, but Adaptec made the decision
//  for us by having their reader handle these drives.  So that we don't have to deal
//  with endless "but it works with Adaptec", we've got to do it here.
//
//  This is really depressing.
//

#define CDRW_PACKET_LENGTH              32
#define CDRW_RUNOUT_LENGTH              7

//
//  LONGLONG UdfMethod2TransformByteOffset (
//      PVCB Vcb,
//      LONGLONG ByteOffset
//      )
//
//  Takes a normal byteoffset and adds in the differential implied by the number
//  of runout areas it spans.
//

#define UdfMethod2TransformByteOffset(V, BO)                                \
    ((BO) + LlBytesFromSectors((V), ((LlSectorsFromBytes((V), BO) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)))

#define UdfMethod2TransformSector(V, S)                                     \
    ((S) + ((S) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)

//
//  ULONG UdfMethod2NextRunoutInSectors (
//      PVCB Vcb,
//      LONGLONG ByteOffset
//      )
//
//  Takes a normal byteoffset and figures out how many sectors remain until the next
//  (forward) runout area.
//

#define UdfMethod2NextRunoutInSectors(V, BO)                                \
    (CDRW_PACKET_LENGTH - (LlSectorsFromBytes((V), (BO)) % CDRW_PACKET_LENGTH))


//
//  Generic constants
//

#define BYTE_COUNT_8_DOT_3                          (24)

//
//  Constants for the name transform algorithm.  Names greater than MAXLEN will be
//  rendered.  MAX_PATH comes from user-side includes that we don't get here.
//
//  UDF specifies rules for converting names from illegal->legal forms for a given OS.
//  The rest of the constants/macros are used to convert the clipped code for these
//  algorithims into a form we can directly use.
//
//  The NativeCharLength question is really not answerable for the non-8.3 case, since
//  NT internally is completely ignorant of the eventual destination of the name.
//

#define MAX_PATH            260

#define MAX_LEN             (MAX_PATH - 5)
#define EXT_LEN             5
#define CRC_LEN             5

#define DOS_NAME_LEN        8
#define DOS_EXT_LEN         3
#define DOS_CRC_LEN         4

#define IsFileNameCharLegal(c)      UdfIsCharacterLegal(c)
#define IsDeviceName(s, n)          FALSE
#define NativeCharLength(c)         1
#define UnicodeToUpper(c)           (c)

#define INT16 SHORT
#define UINT16 USHORT
#define UNICODE_CHAR WCHAR

#define PERIOD              (L'.')
#define SPACE               (L' ')
#define CRC_MARK            (L'#')
#define ILLEGAL_CHAR_MARK   (L'_')

//
//  Place a non-tail recursable depth limit on ICB hierarchies.  We cannot read
//  ICB hierarchies that are deeper than this.
//

#define UDF_ICB_RECURSION_LIMIT 10


//
//  Entity ID (REGID) Suffixes are used in UDF to encode extra information away from
//  the string data in the Identifier.  See UDF 2.1.4.2.
//

//
//  A Domain Suffix is encoded for the Logical Volume Descriptor and File Set Descriptor
//

typedef struct _UDF_SUFFIX_DOMAIN {

    USHORT UdfRevision;
    UCHAR Flags;
    UCHAR Reserved[5];

} UDF_SUFFIX_DOMAIN, *PUDF_SUFFIX_DOMAIN;

#define UDF_SUFFIX_DOMAIN_FLAG_HARD_WRITEPROTECT 0x01
#define UDF_SUFFIX_DOMAIN_FLAG_SOFT_WRITEPROTECT 0x02

//
//  A UDF Suffix is encoded for extended attributes, Implementation Use Volume
//  Descriptors and VATs (among others).
//

typedef struct _UDF_SUFFIX_UDF {

    USHORT UdfRevision;
    UCHAR OSClass;
    UCHAR OSIdentifier;
    UCHAR Reserved[4];

} UDF_SUFFIX_UDF, *PUDF_SUFFIX_UDF;

//
//  An Implementation Suffix is encoded for almost every other structure containing
//  an Entity ID.
//

typedef struct _UDF_SUFFIX_IMPLEMENTATION {

    UCHAR OSClass;
    UCHAR OSIdentifier;
    UCHAR ImplementationUse[6];

} UDF_SUFFIX_IMPLEMENTATION, *PUDF_SUFFIX_IMPLEMENTATION;

//
//  OS Classes and Identifiers are defined by OSTA as of UDF 1.50
//
//  We also take the minor liberty of defining an invalid set for
//  the purposes of hinting internally that we don't care about them.
//  It is unlikely that UDF will ever hit 255, even though these are
//  technically avaliable for allocation.
//

#define OSCLASS_INVALID             255
#define OSIDENTIFIER_INVALID        255


#define OSCLASS_UNDEFINED           0
#define OSCLASS_DOS                 1
#define OSCLASS_OS2                 2
#define OSCLASS_MACOS               3
#define OSCLASS_UNIX                4
#define OSCLASS_WIN9X               5
#define OSCLASS_WINNT               6

#define OSIDENTIFIER_DOS_DOS        0

#define OSIDENTIFIER_OS2_OS2        0

#define OSIDENTIFIER_MACOS_MACOS7   0

#define OSIDENTIFIER_UNIX_GENERIC   0
#define OSIDENTIFIER_UNIX_AIX       1
#define OSIDENTIFIER_UNIX_SOLARIS   2
#define OSIDENTIFIER_UNIX_HPUX      3
#define OSIDENTIFIER_UNIX_IRIX      4
#define OSIDENTIFIER_UNIX_LINUX     5
#define OSIDENTIFIER_UNIX_MKLINUX   6
#define OSIDENTIFIER_UNIX_FREEBSD   7

#define OSIDENTIFIER_WIN9X_WIN95    0

#define OSIDENTIFIED_WINNT_WINNT    0


//
//  Character Set Lists are actually just a 32bit word where each bit N on/off specifies
//  that Character Set N is used on the volume.  Per UDF, the only character set we
//  recognize is CS0, so construct a bitmask Character Set List for that. (1/7.2.11)
//

#define UDF_CHARSETLIST 0x00000001


//
//  Generic partition map for UDF.  This allows partition maps to be typed and the
//  UDF entity identifier for the various type 2 maps to be inspected.
//

typedef struct _PARTMAP_UDF_GENERIC {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
    UCHAR       Reserved24[28];         //  Reserved Padding

} PARTMAP_UDF_GENERIC, *PPARTMAP_UDF_GENERIC;

//
//  UDF 1.50 CD UDF Partition Types
//

//////////
//  UDF Virtual Partitions are identified via a type 2 partition map of the following form.
//////////

typedef struct _PARTMAP_VIRTUAL {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
                                        //   == UdfVirtualPartitionDomainIdentifier
    USHORT      VolSetSeq;              //  Volume Set Sequence
    USHORT      Partition;              //  Related Partition
    UCHAR       Reserved40[24];         //  Reserved Padding

} PARTMAP_VIRTUAL, *PPARTMAP_VIRTUAL;


//
//  UDF 2.00 CD UDF VAT Header
//
//  Note that values in this record supedcede those in the LDV or LVID
//

typedef struct _VAT_HEADER {

    USHORT      Length;                 //  Header length = 152 + ImpUseLength
    USHORT      ImpUseLength;
    
    UCHAR       VolumeID[128];
    
    ULONG       PreviousVatIcbLbn;
    
    ULONG       FileFidCount;
    ULONG       NonParentDirFidCount;
    
    USHORT      MinUdfReadRevision;
    USHORT      MinUdfWriteRevision;
    USHORT      MaxUdfWriteRevision;
    USHORT      Reserved;

    UCHAR       ImpUse[0];
    
    //  VAT entries immediately follow impuse data.
    //
    //  UINT32  Lba of virtual sector 0
    //  UINT32  Lba of virtual sector 1
    //  ...    

} VAT_HEADER, *PVAT_HEADER;


//
//  A UDF 1.50 VAT minimally contains a mapping for a single block, the REGID identifying
//  the VAT, and the identification of a previous VAT ICB location.  
//
//  A UDF 2.0x VAT minimally contains a VAT header,  and a mapping for a single block.
//
//  We also identify
//  an arbitrary sanity limit that the VAT isn't bigger than 8mb since it is extremely
//  difficult to imagine such a VAT existing in practice since each sector describes
//  (on most of our media) 2048/4 = 512 entries ... meaning at 8mb the VAT would
//  describe ~2^21 blocks.  4/12/01 Increased for DVD-R.
//

#define UDF_CDUDF_TRAILING_DATA_SIZE    (sizeof(REGID) + sizeof(ULONG))

#define UDF_CDUDF_MINIMUM_150_VAT_SIZE  (sizeof(ULONG) + UDF_CDUDF_TRAILING_DATA_SIZE)
#define UDF_CDUDF_MINIMUM_20x_VAT_SIZE  (sizeof(ULONG) + sizeof( VAT_HEADER))

#define UDF_CDUDF_MAXIMUM_VAT_SIZE      (16 * 1024 * 1024)

//////////
//  UDF Sparable Partitions are identified via a type 2 partition map of the following form.
//////////

typedef struct _PARTMAP_SPARABLE {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
                                        //   == UdfSparablePartitionDomainIdentifier
    USHORT      VolSetSeq;              //  Volume Set Sequence
    USHORT      Partition;              //  Related Partition
    USHORT      PacketLength;           //  Packet Length == 32 (number of data blocks
                                        //   per packet)
    UCHAR       NumSparingTables;       //  Number of pparing tables on the media
    UCHAR       Reserved43;             //  Reserved Padding
    ULONG       TableSize;              //  Size of sparing tables
    ULONG       TableLocation[4];       //  Location of each sparing table (each
                                        //   sparing table should be in a distinct packet)

} PARTMAP_SPARABLE, *PPARTMAP_SPARABLE;

//
//  Sparing tables lead off with this header structure.
//

typedef struct _SPARING_TABLE_HEADER {

    DESTAG      Destag;                 //  Ident = 0
    REGID       RegID;                  //  == UdfSparingTableIdentifier
    USHORT      TableEntries;           //  Number of entries in the table
    USHORT      Reserved50;             //  Reserved Padding
    ULONG       Sequence;               //  Sequence Number (incremented on rewrite of table)

} *PSPARING_TABLE_HEADER, SPARING_TABLE_HEADER;

//
//  Sparing table map entries.
//

typedef struct _SPARING_TABLE_ENTRY {

    ULONG Original;                     //  Original LBN
    ULONG Mapped;                       //  Mapped PSN

} *PSPARING_TABLE_ENTRY, SPARING_TABLE_ENTRY;

//
//  Fixed values for original sectors, indicating that either the
//  mapped packet is avaliable for sparing use or is defective.
//

#define UDF_SPARING_AVALIABLE           0xffffffff
#define UDF_SPARING_DEFECTIVE           0xfffffff0
 
//
//  The unit of media in each sparing packet is fixed at 32 physical sectors.
//

#define UDF_SPARING_PACKET_LENGTH_CDRW       CDRW_PACKET_LENGTH
#define UDF_SPARING_PACKET_LENGTH_DVDRW      16

//
//  Additional Values defined in UDF,   over and above those in ISO13346.h
//

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_VAT       248     // VAT (new format - UDF 2.00 and later)
#define ICBTAG_FILE_T_REALTIME  249     // Real Time File (UDF 2.01, 2.3.5.2.1)


#endif // _UDF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udfinit.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    UdfInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Udfs

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	24-May-1996
    Tom Jolly       [tomjolly]  21-Jan-2000
    
Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_UDFINIT)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_UDFINIT)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UdfInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *FileSystemDeviceObjects
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, UdfInitializeGlobalData)
#endif


//
//  Local support routine
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the UDF file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT UdfsFileSystemDeviceObjects[NUMBER_OF_FS_OBJECTS];
    PDEVICE_OBJECT UdfsDiskFileSystemDeviceObject;

    //
    //  Create the device objects for both device "types".  Since
    //  UDF is a legitimate filesystem for media underlying device
    //  drivers claiming both DVD/CDROMs and disks, we must register
    //  this filesystem twice.
    //

    ASSERT( NUMBER_OF_FS_OBJECTS >= 2 );
    RtlZeroMemory( UdfsFileSystemDeviceObjects, sizeof(PDEVICE_OBJECT) * NUMBER_OF_FS_OBJECTS );
    
    RtlInitUnicodeString( &UnicodeString, L"\\UdfsCdRom" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &UdfsFileSystemDeviceObjects[0] );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }
    
    RtlInitUnicodeString( &UnicodeString, L"\\UdfsDisk" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &UdfsFileSystemDeviceObjects[1] );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( UdfsFileSystemDeviceObjects[0] );
        return Status;
    }
        
    try {

        Status = STATUS_SUCCESS;

        //
        //  Initialize the global data structures
        //

        UdfInitializeGlobalData( DriverObject, UdfsFileSystemDeviceObjects );

        //
        //  Note that because of the way data caching is done, we set neither
        //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
        //  data is not in the cache, or the request is not buffered, we may,
        //  set up for Direct I/O by hand.
        //

        //
        //  Initialize the driver object with this driver's entry points.
        //
        //  NOTE - Each entry in the dispatch table must have an entry in
        //  the Fsp/Fsd dispatch switch statements.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
        DriverObject->MajorFunction[IRP_MJ_CLOSE]                   =
        DriverObject->MajorFunction[IRP_MJ_READ]                    =
        DriverObject->MajorFunction[IRP_MJ_WRITE]                   =
        DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       =
        DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         =
        DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]=
        DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]       =
        DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]     =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          =
        DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]            =
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 =
        DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH) UdfFsdDispatch;

        DriverObject->FastIoDispatch = &UdfFastIoDispatch;
        
        //
        //  Register the file system with the I/O system
        //

        IoRegisterFileSystem( UdfsFileSystemDeviceObjects[0] );
        IoRegisterFileSystem( UdfsFileSystemDeviceObjects[1] );

    }
    except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        ObDereferenceObject( UdfsFileSystemDeviceObjects[0] );
        ObDereferenceObject( UdfsFileSystemDeviceObjects[1] );

        Status = GetExceptionCode();
    }
    
    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

#define NPagedInit(L,S,T) { ExInitializeNPagedLookasideList( (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, 0); }
#define PagedInit(L,S,T)  { ExInitializePagedLookasideList(  (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, 0); }

VOID
UdfInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *UdfsFileSystemDeviceObjects
    )

/*++

Routine Description:

    This routine initializes the global Udfs data structures.

Arguments:

    DriverObject - Supplies the driver object for UDFS.

    FileSystemDeviceObjects - Supplies a vector of device objects for UDFS.

Return Value:

    None.

--*/

{
    TIMESTAMP UdfTime;

    //
    //  Initialize the CRC table. Per UDF 1.01, we use the seed 10041 octal (4129 dec).
    //  We do this first because it can raise (allocates memory)
    //

    UdfInitializeCrc16( 4129 );

    //
    //  Start by initializing the FastIoDispatch Table.
    //

    RtlZeroMemory( &UdfFastIoDispatch, sizeof( FAST_IO_DISPATCH ));

    UdfFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);

    UdfFastIoDispatch.AcquireFileForNtCreateSection =   UdfAcquireForCreateSection;
    UdfFastIoDispatch.ReleaseFileForNtCreateSection =   UdfReleaseForCreateSection;
    UdfFastIoDispatch.FastIoCheckIfPossible =           UdfFastIoCheckIfPossible;   //  CheckForFastIo
    UdfFastIoDispatch.FastIoRead =                      FsRtlCopyRead;              //  Read
    
    UdfFastIoDispatch.FastIoQueryBasicInfo =            NULL;                       //  QueryBasicInfo
    UdfFastIoDispatch.FastIoQueryStandardInfo =         NULL;                       //  QueryStandardInfo
    UdfFastIoDispatch.FastIoLock =                      NULL;                       //  Lock
    UdfFastIoDispatch.FastIoUnlockSingle =              NULL;                       //  UnlockSingle
    UdfFastIoDispatch.FastIoUnlockAll =                 NULL;                       //  UnlockAll
    UdfFastIoDispatch.FastIoUnlockAllByKey =            NULL;                       //  UnlockAllByKey
    UdfFastIoDispatch.FastIoQueryNetworkOpenInfo =      NULL;                       //  QueryNetworkInfo

    UdfFastIoDispatch.MdlRead = FsRtlMdlReadDev;
    UdfFastIoDispatch.MdlReadComplete = FsRtlMdlReadCompleteDev;
    UdfFastIoDispatch.PrepareMdlWrite = FsRtlPrepareMdlWriteDev;
    UdfFastIoDispatch.MdlWriteComplete = FsRtlMdlWriteCompleteDev;

    //
    //  Initialize the UdfData structure.
    //

    RtlZeroMemory( &UdfData, sizeof( UDF_DATA ));

    UdfData.NodeTypeCode = UDFS_NTC_DATA_HEADER;
    UdfData.NodeByteSize = sizeof( UDF_DATA );

    UdfData.DriverObject = DriverObject;
    RtlCopyMemory( &UdfData.FileSystemDeviceObjects,
                   UdfsFileSystemDeviceObjects,
                   sizeof(PDEVICE_OBJECT) * NUMBER_OF_FS_OBJECTS );

    InitializeListHead( &UdfData.VcbQueue );

    ExInitializeResourceLite( &UdfData.DataResource );

#ifdef UDF_CAPTURE_BACKTRACES

    //
    //  Initialize debugging stack backtrace support.
    //

    UdfData.A.BufferPage = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                     PAGE_SIZE,
                                                     TAG_CDROM_TOC);

    UdfData.B.BufferPage = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                     PAGE_SIZE,
                                                     TAG_CDROM_TOC);

    ExInitializeFastMutex( &UdfData.ExceptionInfoMutex);

#endif

    //
    //  Initialize the cache manager callback routines
    //

    UdfData.CacheManagerCallbacks.AcquireForLazyWrite  = &UdfAcquireForCache;
    UdfData.CacheManagerCallbacks.ReleaseFromLazyWrite = &UdfReleaseFromCache;
    UdfData.CacheManagerCallbacks.AcquireForReadAhead  = &UdfAcquireForCache;
    UdfData.CacheManagerCallbacks.ReleaseFromReadAhead = &UdfReleaseFromCache;

    UdfData.CacheManagerVolumeCallbacks.AcquireForLazyWrite  = &UdfNoopAcquire;
    UdfData.CacheManagerVolumeCallbacks.ReleaseFromLazyWrite = &UdfNoopRelease;
    UdfData.CacheManagerVolumeCallbacks.AcquireForReadAhead  = &UdfNoopAcquire;
    UdfData.CacheManagerVolumeCallbacks.ReleaseFromReadAhead = &UdfNoopRelease;

    //
    //  Initialize the lock mutex and the async and delay close queues.
    //

    ExInitializeFastMutex( &UdfData.UdfDataMutex );
    InitializeListHead( &UdfData.AsyncCloseQueue );
    InitializeListHead( &UdfData.DelayedCloseQueue );

    ExInitializeWorkItem( &UdfData.CloseItem,
                          (PWORKER_THREAD_ROUTINE) UdfFspClose,
                          NULL );

    //
    //  Do the initialization based on the system size.
    //

    switch (MmQuerySystemSize()) {

    case MmSmallSystem:
        
        UdfData.MaxDelayedCloseCount = 10;
        UdfData.MinDelayedCloseCount = 2;
        break;

    case MmLargeSystem:

        UdfData.MaxDelayedCloseCount = 72;
        UdfData.MinDelayedCloseCount = 18;
        break;

    default:
    case MmMediumSystem:
    
        UdfData.MaxDelayedCloseCount = 32;
        UdfData.MinDelayedCloseCount = 8;
        break;
    
    }

    NPagedInit( &UdfIrpContextLookasideList, sizeof( IRP_CONTEXT ), TAG_IRP_CONTEXT);
    NPagedInit( &UdfFcbNonPagedLookasideList, sizeof( FCB_NONPAGED ), TAG_FCB_NONPAGED);

    PagedInit( &UdfCcbLookasideList, sizeof( CCB ), TAG_CCB );
    PagedInit( &UdfFcbIndexLookasideList, SIZEOF_FCB_INDEX, TAG_FCB_INDEX );
    PagedInit( &UdfFcbDataLookasideList, SIZEOF_FCB_DATA, TAG_FCB_DATA );
    PagedInit( &UdfLcbLookasideList, SIZEOF_LOOKASIDE_LCB, TAG_LCB);

    //
    //  Initialize our default time which we use when enumerating FIDs whose
    //  associated FEs are toast.
    //

    RtlZeroMemory( &UdfTime, sizeof( TIMESTAMP));
    
    UdfTime.Day = 25;
    UdfTime.Month = 7;
    UdfTime.Year = 1974;
    
    UdfConvertUdfTimeToNtTime( NULL, 
                               &UdfTime, 
                               &UdfCorruptFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udfdata.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfData.h

Abstract:

    This module declares the global data used by the Udfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   20-May-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#ifndef _UDFDATA_
#define _UDFDATA_

//
//  Global data structures
//

extern UDF_DATA UdfData;
extern FAST_IO_DISPATCH UdfFastIoDispatch;

//
//  Global constants
//

//
//  These are the number of times a mounted Vcb will be referenced on behalf
//  of the system.  The counts include the following references.
//
//      1 reference - shows the volume is mounted
//      1 reference - 1 for VolumeDasdFcb.
//      2 references - 1 for RootIndexFcb, 1 for internal stream.
//      2 references - 1 for MetadataFcb, 1 for internal stream.
//
//  AND THEN, IF THIS IS CD-UDF
//
//      2 references - 1 for the VatFcb, 1 for the internal stream.
//
//  For user references we add one for the reference in each of the internal
//  Fcbs.
//

#define UDFS_BASE_RESIDUAL_REFERENCE                (6)
#define UDFS_BASE_RESIDUAL_USER_REFERENCE           (3)

#define UDFS_CDUDF_RESIDUAL_REFERENCE               (2)
#define UDFS_CDUDF_RESIDUAL_USER_REFERENCE          (1)

//
//  The UDFS signature for thread contexts
//

#define UDFS_SIGNATURE                              0x53464455 

//
//  Reserved directory strings
//

#define SELF_ENTRY   0
#define PARENT_ENTRY 1

extern WCHAR UdfUnicodeSelfArray[];
extern WCHAR UdfUnicodeParentArray[];

extern LARGE_INTEGER UdfCorruptFileTime;

extern UNICODE_STRING UdfUnicodeDirectoryNames[];

//
//  Static Identifier strings
//

extern STRING UdfCS0Identifier;
extern STRING UdfDomainIdentifier;
extern STRING UdfVirtualPartitionDomainIdentifier;
extern STRING UdfVatTableIdentifier;
extern STRING UdfSparablePartitionDomainIdentifier;
extern STRING UdfSparingTableIdentifier;
extern STRING UdfNSR02Identifier;
extern STRING UdfNSR03Identifier;

//
//  Lookup tables for rudimentary parsing of strings we will
//  discover in on-disk structures
//

extern PARSE_KEYVALUE VsdIdentParseTable[];
extern PARSE_KEYVALUE NsrPartContIdParseTable[];

//
//  Lookaside lists
//

extern NPAGED_LOOKASIDE_LIST UdfFcbNonPagedLookasideList;
extern NPAGED_LOOKASIDE_LIST UdfIrpContextLookasideList;

extern PAGED_LOOKASIDE_LIST UdfCcbLookasideList;
extern PAGED_LOOKASIDE_LIST UdfFcbIndexLookasideList;
extern PAGED_LOOKASIDE_LIST UdfFcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST UdfLcbLookasideList;

//
//  16bit CRC table
//

extern PUSHORT UdfCrcTable;

//
//  Turn on pseudo-asserts if UDFS_FREE_ASSERTS is defined.
//

#if (!DBG && defined( UDFS_FREE_ASSERTS )) || defined( UDFSDBG )
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)                                             \
    ((exp) ? TRUE :                                             \
             (DbgPrint( "%s:%d %s\n",__FILE__,__LINE__,#exp ),  \
              DbgBreakPoint(),                                  \
              TRUE))
#define ASSERTMSG(msg,exp)                                              \
    ((exp) ? TRUE :                                                     \
             (DbgPrint( "%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp ),   \
              DbgBreakPoint(),                                          \
              TRUE))
#endif


//
//  McDebugging Stuff
//

//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_STRUCT( IN PVOID Struct, IN CSHORT NodeType );
//      ASSERT_OPTIONAL_STRUCT( IN PVOID Struct OPTIONAL, IN CSHORT NodeType );
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_LCB( IN PLCB Lcb );
//      ASSERT_OPTIONAL_LCB( IN PLCB Lcb OPTIONAL );
//
//      ASSERT_PCB( IN PFCB Pcb );
//      ASSERT_OPTIONAL_PCB( IN PPCB Pcb OPTIONAL );
//
//      ASSERT_FCB_NONPAGED( IN PFCB_NONPAGED FcbNonpaged );
//      ASSERT_OPTIONAL_FCB( IN PFCB_NONPAGED FcbNonpaged OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_CDDATA
//
//      ASSERT_EXCLUSIVE_VCB( IN PVCB Vcb );
//
//      ASSERT_SHARED_VCB( IN PVCB Vcb );
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_FILE( IN PFCB Fcb );
//
//      ASSERT_SHARED_FILE( IN PFCB Fcb );
//
//      ASSERT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_NOT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_LOCKED_FCB( IN PFCB Fcb );
//
//      ASSERT_NOT_LOCKED_FCB( IN PFCB Fcb );
//

#ifdef UDF_SANITY

extern LONG UdfDebugTraceLevel;
extern LONG UdfDebugTraceIndent;
extern BOOLEAN UdfNoisyVerifyDescriptor;
extern BOOLEAN UdfTestRaisedStatus;

BOOLEAN
UdfDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    );

#define DebugTrace(x) UdfDebugTrace x

#define DebugUnwind(X) {                                                            \
    if (AbnormalTermination()) {                                                    \
        DebugTrace(( -1, UDFS_DEBUG_LEVEL_UNWIND, #X ", Abnormal termination.\n" )); \
    }                                                                               \
}

#define DebugBreakOnStatus(S) {                                                         \
    if (UdfTestRaisedStatus) {                                                          \
        if ((S) == STATUS_DISK_CORRUPT_ERROR ||                                         \
            (S) == STATUS_FILE_CORRUPT_ERROR ||                                         \
            (S) == STATUS_CRC_ERROR) {                                                  \
            DbgPrint( "UDFS: Breaking on possible media corruption (S = %08x)\n", (S)); \
            DbgPrint( "UDFS: Contact UDFS.SYS component owner for triage.\n");          \
            DbgPrint( "UDFS: 'eb %p 0' to disable this alert\n",&UdfTestRaisedStatus ); \
            DbgBreakPoint();                                                            \
        }                                                                               \
    }                                                                                   \
}    

#define ASSERT_STRUCT(S,T)                       ASSERT( SafeNodeType( S ) == (T) )
#define ASSERT_OPTIONAL_STRUCT(S,T)              ASSERT( ((S) == NULL) ||  (SafeNodeType( S ) == (T)) )

#define ASSERT_VCB(V)                            ASSERT_STRUCT( (V), UDFS_NTC_VCB )
#define ASSERT_OPTIONAL_VCB(V)                   ASSERT_OPTIONAL_STRUCT( (V), UDFS_NTC_VCB )

#define ASSERT_FCB(F)                                           \
    ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_OPTIONAL_FCB(F)                                  \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_FCB_DATA(F)                       ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) )

#define ASSERT_OPTIONAL_FCB_DATA(F)                             \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) )

#define ASSERT_FCB_INDEX(F)                      ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_OPTIONAL_FCB_INDEX(F)                            \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_FCB_NONPAGED(FN)                  ASSERT_STRUCT( (FN), UDFS_NTC_FCB_NONPAGED )
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)         ASSERT_OPTIONAL_STRUCT( (FN), UDFS_NTC_FCB_NONPAGED )

#define ASSERT_CCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_CCB )
#define ASSERT_OPTIONAL_CCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_CCB )

#define ASSERT_PCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_PCB )
#define ASSERT_OPTIONAL_PCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_PCB )

#define ASSERT_LCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_LCB )
#define ASSERT_OPTIONAL_LCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_LCB )

#define ASSERT_IRP_CONTEXT(IC)                   ASSERT_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT )
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)          ASSERT_OPTIONAL_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT )

#define ASSERT_IRP_CONTEXT_LITE(IC)              ASSERT_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT_LITE )
#define ASSERT_OPTIONAL_IRP_CONTEXT_LITE(IC)     ASSERT_OPTIONAL_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT_LITE )

#define ASSERT_IRP(I)                            ASSERT_STRUCT( (I), IO_TYPE_IRP )
#define ASSERT_OPTIONAL_IRP(I)                   ASSERT_OPTIONAL_STRUCT( (I), IO_TYPE_IRP )

#define ASSERT_FILE_OBJECT(FO)                   ASSERT_STRUCT( (FO), IO_TYPE_FILE )
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)          ASSERT_OPTIONAL_STRUCT( (FO), IO_TYPE_FILE )

#define ASSERT_EXCLUSIVE_RESOURCE(R)             ASSERT( ExIsResourceAcquiredExclusiveLite( R ))

#define ASSERT_SHARED_RESOURCE(R)                ASSERT( ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_RESOURCE_NOT_MINE(R)              ASSERT( !ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_EXCLUSIVE_UDFDATA                 ASSERT( ExIsResourceAcquiredExclusiveLite( &UdfData.DataResource ))
#define ASSERT_EXCLUSIVE_VCB(V)                  ASSERT( ExIsResourceAcquiredExclusiveLite( &(V)->VcbResource ))
#define ASSERT_SHARED_VCB(V)                     ASSERT( ExIsResourceAcquiredSharedLite( &(V)->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB_OR_VCB(F)           ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ) || \
                                                         ExIsResourceAcquiredExclusiveLite( &(F)->Vcb->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB(F)                  ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ))
#define ASSERT_SHARED_FCB(F)                     ASSERT( ExIsResourceAcquiredSharedLite( &(F)->FcbNonpaged->FcbResource ))

#define ASSERT_EXCLUSIVE_FILE(F)                 ASSERT( ExIsResourceAcquiredExclusiveLite( (F)->Resource ))
#define ASSERT_SHARED_FILE(F)                    ASSERT( ExIsResourceAcquiredSharedLite( (F)->Resource ))

#define ASSERT_LOCKED_VCB(V)                     ASSERT( (V)->VcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_VCB(V)                 ASSERT( (V)->VcbLockThread != PsGetCurrentThread() )

#define ASSERT_LOCKED_FCB(F)                     ASSERT( (F)->FcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_FCB(F)                 ASSERT( (F)->FcbLockThread != PsGetCurrentThread() )

#define ASSERT_NOT_HELD_VMCB(V)                  ASSERT( !ExIsResourceAcquiredSharedLite(&(V)->VmcbMappingResource) && \
                                                         !ExIsResourceAcquiredExclusiveLite(&(V)->VmcbMappingResource) )
#else

#define DebugTrace(X)                            TRUE
#define DebugUnwind(X)                           { NOTHING; }
#define DebugBreakOnStatus(S)                    { NOTHING; }

#define ASSERT_NOT_HELD_VMCB(V)                  { NOTHING; }
#define ASSERT_STRUCT(S,T)                       { NOTHING; }
#define ASSERT_OPTIONAL_STRUCT(S,T)              { NOTHING; }
#define ASSERT_VCB(V)                            { NOTHING; }
#define ASSERT_OPTIONAL_VCB(V)                   { NOTHING; }
#define ASSERT_FCB(F)                            { NOTHING; }
#define ASSERT_OPTIONAL_FCB(F)                   { NOTHING; }
#define ASSERT_FCB_DATA                          { NOTHING; }
#define ASSERT_OPTIONAL_FCB_DATA(F)              { NOTHING; }
#define ASSERT_FCB_INDEX(F)                      { NOTHING; }
#define ASSERT_OPTIONAL_FCB_INDEX(F)             { NOTHING; }
#define ASSERT_FCB_NONPAGED(FN)                  { NOTHING; }
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)         { NOTHING; }
#define ASSERT_CCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_CCB(C)                   { NOTHING; }
#define ASSERT_PCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_PCB(C)                   { NOTHING; }
#define ASSERT_LCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_LCB(C)                   { NOTHING; }
#define ASSERT_IRP_CONTEXT(IC)                   { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)          { NOTHING; }
#define ASSERT_IRP_CONTEXT_LITE(IC)              { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT_LITE(IC)     { NOTHING; }
#define ASSERT_IRP(I)                            { NOTHING; }
#define ASSERT_OPTIONAL_IRP(I)                   { NOTHING; }
#define ASSERT_FILE_OBJECT(FO)                   { NOTHING; }
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)          { NOTHING; }
#define ASSERT_EXCLUSIVE_RESOURCE(R)             { NOTHING; }
#define ASSERT_SHARED_RESOURCE(R)                { NOTHING; }
#define ASSERT_RESOURCE_NOT_MINE(R)              { NOTHING; }
#define ASSERT_EXCLUSIVE_UDFDATA                 { NOTHING; }
#define ASSERT_EXCLUSIVE_VCB(V)                  { NOTHING; }
#define ASSERT_SHARED_VCB(V)                     { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB_OR_VCB(F)           { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB(F)                  { NOTHING; }
#define ASSERT_SHARED_FCB(F)                     { NOTHING; }
#define ASSERT_EXCLUSIVE_FILE(F)                 { NOTHING; }
#define ASSERT_SHARED_FILE(F)                    { NOTHING; }
#define ASSERT_LOCKED_VCB(V)                     { NOTHING; }
#define ASSERT_NOT_LOCKED_VCB(V)                 { NOTHING; }
#define ASSERT_LOCKED_FCB(F)                     { NOTHING; }
#define ASSERT_NOT_LOCKED_FCB(F)                 { NOTHING; }

#endif

#endif // _UDFDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udfdata.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfData.c

Abstract:

    This module declares the global data used by the Udfs file system.

    This module also handles the dispath routines in the Fsd threads as well as
    handling the IrpContext and Irp through the exception path.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   24-May-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_UDFDATA)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_UDFDATA)

//
//  Global data structures
//

UDF_DATA UdfData;
FAST_IO_DISPATCH UdfFastIoDispatch;

//
//  Debug trace levels
//

#ifdef UDF_SANITY

//
//  For UdfDebugTrace (only live in checked builds) to be able to swing
//  variable argument lists and varargs printfs.
//

#include <stdarg.h>
#include <stdio.h>

BOOLEAN UdfTestTopLevel = TRUE;
BOOLEAN UdfTestRaisedStatus = TRUE;
BOOLEAN UdfBreakOnAnyRaise = FALSE;
BOOLEAN UdfTraceRaises = FALSE;

NTSTATUS UdfInterestingExceptionCodes[] = { STATUS_DISK_CORRUPT_ERROR, 
                                            STATUS_FILE_CORRUPT_ERROR,
                                            0, 0, 0, 0, 0, 0, 0, 0 };
LONG UdfDebugTraceLevel = 0;

//
//  Control whether UdfVerifyDescriptor will only emit info on failure (FALSE) or
//  all of the time (TRUE).
//

BOOLEAN UdfNoisyVerifyDescriptor = FALSE;

#endif

//
//  This is the time reported for any files whose FE is corrupt during
//  directory enumeration.
//

LARGE_INTEGER UdfCorruptFileTime;

//
//  Reserved directory strings.
//

WCHAR UdfUnicodeSelfArray[] = { L'.' };
WCHAR UdfUnicodeParentArray[] = { L'.', L'.' };

UNICODE_STRING UdfUnicodeDirectoryNames[] = {
    { sizeof(UdfUnicodeSelfArray), sizeof(UdfUnicodeSelfArray), UdfUnicodeSelfArray},
    { sizeof(UdfUnicodeParentArray), sizeof(UdfUnicodeParentArray), UdfUnicodeParentArray}
    };

//
//  Identifier strings defined by UDF.
//

CHAR UdfCS0IdentifierArray[] = { 'O', 'S', 'T', 'A', ' ',
                                 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'e', 'd', ' ',
                                 'U', 'n', 'i', 'c', 'o', 'd', 'e' };

STRING UdfCS0Identifier = {
    sizeof(UdfCS0IdentifierArray),
    sizeof(UdfCS0IdentifierArray),
    UdfCS0IdentifierArray
    };

CHAR UdfDomainIdentifierArray[] = { '*', 'O', 'S', 'T', 'A', ' ',
                                    'U', 'D', 'F', ' ',
                                    'C', 'o', 'm', 'p', 'l', 'i', 'a', 'n', 't' };

STRING UdfDomainIdentifier = {
    sizeof(UdfDomainIdentifierArray),
    sizeof(UdfDomainIdentifierArray),
    UdfDomainIdentifierArray
    };

CHAR UdfVirtualPartitionDomainIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                                    'V', 'i', 'r', 't', 'u', 'a', 'l', ' ',
                                                    'P', 'a', 'r', 't', 'i', 't', 'i', 'o', 'n' };

STRING UdfVirtualPartitionDomainIdentifier = {
    sizeof(UdfVirtualPartitionDomainIdentifierArray),
    sizeof(UdfVirtualPartitionDomainIdentifierArray),
    UdfVirtualPartitionDomainIdentifierArray 
    };

CHAR UdfVatTableIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                      'V', 'i', 'r', 't', 'u', 'a', 'l', ' ',
                                      'A', 'l', 'l', 'o', 'c', ' ',
                                      'T', 'b', 'l' };

STRING UdfVatTableIdentifier = {
    sizeof(UdfVatTableIdentifierArray),
    sizeof(UdfVatTableIdentifierArray),
    UdfVatTableIdentifierArray
    };
                                    
CHAR UdfSparablePartitionDomainIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                                     'S', 'p', 'a', 'r', 'a', 'b', 'l', 'e', ' ',
                                                     'P', 'a', 'r', 't', 'i', 't', 'i', 'o', 'n' };

STRING UdfSparablePartitionDomainIdentifier = {
    sizeof(UdfSparablePartitionDomainIdentifierArray),
    sizeof(UdfSparablePartitionDomainIdentifierArray),
    UdfSparablePartitionDomainIdentifierArray
    };

CHAR UdfSparingTableIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                          'S', 'p', 'a', 'r', 'i', 'n', 'g', ' ',
                                          'T', 'a', 'b', 'l', 'e' };

STRING UdfSparingTableIdentifier = {
    sizeof(UdfSparingTableIdentifierArray),
    sizeof(UdfSparingTableIdentifierArray),
    UdfSparingTableIdentifierArray
    };

CHAR UdfNSR02IdentifierArray[] = NSR_PART_CONTID_NSR02;

STRING UdfNSR02Identifier = {
    sizeof(UdfNSR02IdentifierArray),
    sizeof(UdfNSR02IdentifierArray),
    UdfNSR02IdentifierArray
    };
    
CHAR UdfNSR03IdentifierArray[] = NSR_PART_CONTID_NSR03;

STRING UdfNSR03Identifier = {
    sizeof(UdfNSR03IdentifierArray),
    sizeof(UdfNSR03IdentifierArray),
    UdfNSR03IdentifierArray
    };

//
//  Tables of tokens we have to parse up from mount-time on-disk structures
//

PARSE_KEYVALUE VsdIdentParseTable[] = {
    { VSD_IDENT_BEA01, VsdIdentBEA01 },
    { VSD_IDENT_TEA01, VsdIdentTEA01 },
    { VSD_IDENT_CDROM, VsdIdentCDROM },
    { VSD_IDENT_CD001, VsdIdentCD001 },
    { VSD_IDENT_CDW01, VsdIdentCDW01 },
    { VSD_IDENT_CDW02, VsdIdentCDW02 },
    { VSD_IDENT_NSR01, VsdIdentNSR01 },
    { VSD_IDENT_NSR02, VsdIdentNSR02 },
    { VSD_IDENT_BOOT2, VsdIdentBOOT2 },
    { VSD_IDENT_NSR03, VsdIdentNSR03 },
    { NULL,            VsdIdentBad }
    };

PARSE_KEYVALUE NsrPartContIdParseTable[] = {
    { NSR_PART_CONTID_FDC01, NsrPartContIdFDC01 },
    { NSR_PART_CONTID_CD001, NsrPartContIdCD001 },
    { NSR_PART_CONTID_CDW01, NsrPartContIdCDW01 },
    { NSR_PART_CONTID_CDW02, NsrPartContIdCDW02 },
    { NSR_PART_CONTID_NSR01, NsrPartContIdNSR01 },
    { NSR_PART_CONTID_NSR02, NsrPartContIdNSR02 },
    { NSR_PART_CONTID_NSR03, NsrPartContIdNSR03 },
    { NULL,                  NsrPartContIdBad }
    };

//
//  Lookaside allocation lists for various volatile structures
//

NPAGED_LOOKASIDE_LIST UdfFcbNonPagedLookasideList;
NPAGED_LOOKASIDE_LIST UdfIrpContextLookasideList;

PAGED_LOOKASIDE_LIST UdfCcbLookasideList;
PAGED_LOOKASIDE_LIST UdfFcbIndexLookasideList;
PAGED_LOOKASIDE_LIST UdfFcbDataLookasideList;
PAGED_LOOKASIDE_LIST UdfLcbLookasideList;

//
//  16bit CRC table
//

PUSHORT UdfCrcTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfComputeCrc16)
#pragma alloc_text(PAGE, UdfComputeCrc16Uni)
#ifdef UDF_SANITY
#pragma alloc_text(PAGE, UdfDebugTrace)
#endif
#pragma alloc_text(PAGE, UdfFastIoCheckIfPossible)
#pragma alloc_text(PAGE, UdfHighBit)
#pragma alloc_text(PAGE, UdfInitializeCrc16)
#pragma alloc_text(PAGE, UdfSerial32)
#endif


NTSTATUS
UdfFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry to all of the Fsd dispatch points.

    Conceptually the Io routine will call this routine on all requests
    to the file system.  We case on the type of request and invoke the
    correct handler for this type of request.  There is an exception filter
    to catch any exceptions in the UDFS code as well as the UDFS process
    exception routine.

    This routine allocates and initializes the IrpContext for this request as
    well as updating the top-level thread context as necessary.  We may loop
    in this routine if we need to retry the request for any reason.  The
    status code STATUS_CANT_WAIT is used to indicate this.  Suppose the disk
    in the drive has changed.  An Fsd request will proceed normally until it
    recognizes this condition.  STATUS_VERIFY_REQUIRED is raised at that point
    and the exception code will handle the verify and either return
    STATUS_CANT_WAIT or STATUS_PENDING depending on whether the request was
    posted.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    THREAD_CONTEXT ThreadContext;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN Wait;

#ifdef UDF_SANITY
    PVOID PreviousTopLevel;
#endif

    NTSTATUS Status;

    KIRQL SaveIrql = KeGetCurrentIrql();

    ASSERT_OPTIONAL_IRP( Irp );

    FsRtlEnterFileSystem();

#ifdef UDF_SANITY
    PreviousTopLevel = IoGetTopLevelIrp();
#endif

    //
    //  Loop until this request has been completed or posted.
    //

    do {

        //
        //  Use a try-except to handle the exception cases.
        //

        try {

            //
            //  If the IrpContext is NULL then this is the first pass through
            //  this loop.
            //

            if (IrpContext == NULL) {

                //
                //  Decide if this request is waitable an allocate the IrpContext.
                //  If the file object in the stack location is NULL then this
                //  is a mount which is always waitable.  Otherwise we look at
                //  the file object flags.
                //

                if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

                    Wait = TRUE;

                } else {

                    Wait = CanFsdWait( Irp );
                }

                IrpContext = UdfCreateIrpContext( Irp, Wait );

                //
                //  Update the thread context information.
                //

                UdfSetThreadContext( IrpContext, &ThreadContext );

#ifdef UDF_SANITY
                ASSERT( !UdfTestTopLevel ||
                        SafeNodeType( IrpContext->TopLevel ) == UDFS_NTC_IRP_CONTEXT );
#endif
            //
            //  Otherwise cleanup the IrpContext for the retry.
            //

            } else {

                //
                //  Set the MORE_PROCESSING flag to make sure the IrpContext
                //  isn't inadvertently deleted here.  Then cleanup the
                //  IrpContext to perform the retry.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
                UdfCleanupIrpContext( IrpContext, FALSE );
            }

            //
            //  Case on the major irp code.
            //

            switch (IrpContext->MajorFunction) {

                case IRP_MJ_CLEANUP :
                    
                    Status = UdfCommonCleanup( IrpContext, Irp );
                    break;
    
                case IRP_MJ_CLOSE :

                    Status = UdfCommonClose( IrpContext, Irp );
                    break;

                case IRP_MJ_CREATE :
                    
                    Status = UdfCommonCreate( IrpContext, Irp );
                    break;
    
                case IRP_MJ_DEVICE_CONTROL :
    
                    Status = UdfCommonDevControl( IrpContext, Irp );
                    break;
    
                case IRP_MJ_DIRECTORY_CONTROL :

                    Status = UdfCommonDirControl( IrpContext, Irp );
                    break;

                case IRP_MJ_FILE_SYSTEM_CONTROL :
    
                    Status = UdfCommonFsControl( IrpContext, Irp );
                    break;

                case IRP_MJ_LOCK_CONTROL :

                    Status = UdfCommonLockControl( IrpContext, Irp );
                    break;

                case IRP_MJ_PNP :

                    Status = UdfCommonPnp( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION :

                    Status = UdfCommonQueryInfo( IrpContext, Irp );
                    break;
                
                case IRP_MJ_QUERY_VOLUME_INFORMATION :

                    Status = UdfCommonQueryVolInfo( IrpContext, Irp );
                    break;
                
                case IRP_MJ_READ :
    
                    //
                    //  If this is an Mdl complete request, don't go through
                    //  common read.
                    //
    
                    if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {
    
                        Status = UdfCompleteMdl( IrpContext, Irp );
    
                    } else {
    
                        Status = UdfCommonRead( IrpContext, Irp );
                    }
    
                    break;
                    
                case IRP_MJ_WRITE :
                
                    Status = UdfCommonWrite( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_INFORMATION :

                    Status = UdfCommonSetInfo( IrpContext, Irp );
                    break;
                
                default :
                            
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    UdfCompleteRequest( IrpContext, Irp, Status );
            }

        } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT);

#ifdef UDF_SANITY
    ASSERT( !UdfTestTopLevel ||
            (PreviousTopLevel == IoGetTopLevelIrp()) );
#endif

    FsRtlExitFileSystem();

    ASSERT( SaveIrql == KeGetCurrentIrql( ));

    return Status;
}


#ifdef UDF_SANITY

VOID
UdfRaiseStatusEx(
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN NormalizeStatus,
    IN OPTIONAL ULONG FileId,
    IN OPTIONAL ULONG Line
    )
{
    BOOLEAN BreakIn = FALSE;
    
    if (UdfTraceRaises)  {

        DbgPrint( "%p CdRaiseStatusEx %x @ F 0x%x, L %d\n", PsGetCurrentThread(), Status, FileId, Line);
    }

    if (UdfTestRaisedStatus && !UdfBreakOnAnyRaise)  {

        ULONG Index;

        for (Index = 0; 
             Index < (sizeof( UdfInterestingExceptionCodes) / sizeof( UdfInterestingExceptionCodes[0]));
             Index++)  {

            if ((STATUS_SUCCESS != UdfInterestingExceptionCodes[Index]) &&
                (UdfInterestingExceptionCodes[Index] == Status))  {

                BreakIn = TRUE;
                break;
            }
        }
    }

    if (BreakIn || UdfBreakOnAnyRaise)  {
        
        DbgPrint( "UDFS: Breaking on raised status %08x  (BI=%d,BA=%d)\n", Status, BreakIn, UdfBreakOnAnyRaise);
        DbgPrint( "UDFS: (FILEID 0x%x LINE %d)\n", FileId, Line);
        DbgPrint( "UDFS: Contact UDFS.SYS component owner for triage.\n");
        DbgPrint( "UDFS: 'eb %p 0;eb %p 0' to disable this alert.\n", &UdfTestRaisedStatus, &UdfBreakOnAnyRaise);

        DbgBreakPoint();
    }
    
    if (NormalizeStatus)  {

        IrpContext->ExceptionStatus = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR);
    }
    else {

        IrpContext->ExceptionStatus = Status;
    }

    IrpContext->RaisedAtFileLine = (FileId << 16) | Line;

    ExRaiseStatus( IrpContext->ExceptionStatus);
}

#endif


LONG
UdfExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    status.  If UDFS explicitly raised an error then this status is already
    in the IrpContext.  We choose which is the correct status code and
    either indicate that we will handle the exception or bug-check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;
    BOOLEAN TestStatus = TRUE;

#ifdef UDF_CAPTURE_BACKTRACES
    PSTACK_SNAP Snap;
    ULONG_PTR Low, High;
    ULONG_PTR CurrEbp;
    ULONG ByteCount;
    PULONG_PTR CurrPtr;
    ULONG_PTR Ceiling;
#endif

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    DebugTrace(( 0, Dbg,
                 "UdfExceptionFilter: %08x (exr %08x cxr %08x)\n",
                 ExceptionCode,
                 ExceptionPointer->ExceptionRecord,
                 ExceptionPointer->ContextRecord ));


    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    //
    //  If there is an Irp context then check which status code to use.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        if (IrpContext->ExceptionStatus == STATUS_SUCCESS) {

            //
            //  Store the real status into the IrpContext.
            //

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            //
            //  No need to test the status code if we raised it ourselves.
            //

            TestStatus = FALSE;
        }

#ifdef UDF_CAPTURE_BACKTRACES

        //
        //  Capture a stack backtrace.
        //

        //
        //  Always captures from exception filter up - skips frames of exception
        //  stack... no use.
        //
        //  RtlCaptureStackBackTrace( 0, 
        //                            UDF_IRPCONTEXT_BACKTRACE_DEPTH, 
        //                            &IrpContext->ExceptionStackBacktrace[0], 
        //                            &Ignore );

        ExAcquireFastMutex( &UdfData.ExceptionInfoMutex);

        Snap = (UdfData.CurrentSnapIsA) ? &UdfData.A : &UdfData.B;
        
        Snap->ExceptionCode = IrpContext->ExceptionStatus;
        Snap->Mj = IrpContext->MajorFunction;
        Snap->Mn = IrpContext->MinorFunction;

        IoGetStackLimits( &Low, &High);

        _asm {
        
            mov CurrEbp, esp
        }

        ByteCount = Min( PAGE_SIZE, (High - CurrEbp));
        Ceiling = ByteCount + CurrEbp;
        
        RtlCopyMemory( Snap->BufferPage, (PVOID)CurrEbp, ByteCount);

        UdfData.CurrentSnapIsA ^= 1;

        //
        //  Rebase any stack pointers within the captured page
        //

        for (CurrPtr = Snap->BufferPage; 
             CurrPtr < Add2Ptr( Snap->BufferPage, ByteCount, PULONG_PTR);
             CurrPtr += 1)  {

            if ((*CurrPtr >= CurrEbp) && (*CurrPtr < Ceiling))  {

                *CurrPtr = Add2Ptr( Snap->BufferPage, (*CurrPtr - CurrEbp), ULONG_PTR);
            }
        }

        Snap->StackLow = Low;
        Snap->StackHigh = High;
        Snap->Thread = PsGetCurrentThread();

        ExReleaseFastMutex( &UdfData.ExceptionInfoMutex);
#endif
    }

    //
    //  Bug check if this status is not supported.
    //

    if (TestStatus && !FsRtlIsNtstatusExpected( ExceptionCode )) {

        UdfBugCheck( (ULONG_PTR) ExceptionPointer->ExceptionRecord,
                     (ULONG_PTR) ExceptionPointer->ContextRecord,
                     (ULONG_PTR) ExceptionPointer->ExceptionRecord->ExceptionAddress );

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


LONG
UdfQueryDirExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    while opening FES during directory traversal.
    
Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or EXCEPTION_CONTINUE_SEARCH

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    if ((ExceptionCode == STATUS_FILE_CORRUPT_ERROR) ||
        (ExceptionCode == STATUS_CRC_ERROR))  {

        return EXCEPTION_EXECUTE_HANDLER;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}



NTSTATUS
UdfProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the exception status in the IrpContext, sends this off to the Fsp
    workque or causes it to be retried in the current thread if a verification
    is needed.

    If the volume needs to be verified (STATUS_VERIFY_REQUIRED) and we can
    do the work in the current thread we will translate the status code
    to STATUS_CANT_WAIT to indicate that we need to retry the request.

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PDEVICE_OBJECT Device;
    PVPB Vpb;
    PETHREAD Thread;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If there is not an irp context, then complete the request with the
    //  current status code.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        UdfCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the IrpContext.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  If we are not a top level request then we just complete the request
    //  with the current status code.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL )) {

        UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

        return ExceptionCode;
    }

    //
    //  Check if we are posting this request.  One of the following must be true
    //  if we are to post a request.
    //
    //      - Status code is STATUS_CANT_WAIT and the request is asynchronous
    //          or we are forcing this to be posted.
    //
    //      - Status code is STATUS_VERIFY_REQUIRED and we are at APC level
    //          or higher.  Can't wait for IO in the verify path in this case.
    //
    //  Set the MORE_PROCESSING flag in the IrpContext to keep if from being
    //  deleted if this is a retryable condition.
    //
    //  Note:  Children of UdfFsdPostRequest() can raise.
    //

    try {
    
        if (ExceptionCode == STATUS_CANT_WAIT) {

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                ExceptionCode = UdfFsdPostRequest( IrpContext, Irp );
            }

        } else if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            if (KeGetCurrentIrql() >= APC_LEVEL) {

                ExceptionCode = UdfFsdPostRequest( IrpContext, Irp );
            }
        }
    }
    except (UdfExceptionFilter( IrpContext, GetExceptionInformation()))  {
    
        ExceptionCode = GetExceptionCode(); 
    }

    //
    //  If we posted the request or our caller will retry then just return here.
    //

    if ((ExceptionCode == STATUS_PENDING) ||
        (ExceptionCode == STATUS_CANT_WAIT)) {

        return ExceptionCode;
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );

    //
    //  Store this error into the Irp for posting back to the Io system.
    //

    Irp->IoStatus.Status = ExceptionCode;

    if (IoIsErrorUserInduced( ExceptionCode )) {

        //
        //  Check for the various error conditions that can be caused by,
        //  and possibly resolved my the user.
        //

        if (ExceptionCode == STATUS_VERIFY_REQUIRED) {
                
                //
                //  Now we are at the top level file system entry point.
                //
                //  If we have already posted this request then the device to
                //  verify is in the original thread.  Find this via the Irp.
                //

                Device = IoGetDeviceToVerify( Irp->Tail.Overlay.Thread );
                IoSetDeviceToVerify( Irp->Tail.Overlay.Thread, NULL );

                //
                //  If there is no device in that location then check in the
                //  current thread.
                //

                if (Device == NULL) {

                    Device = IoGetDeviceToVerify( PsGetCurrentThread() );
                    IoSetDeviceToVerify( PsGetCurrentThread(), NULL );

                    ASSERT( Device != NULL );

                    //
                    //  Let's not BugCheck just because the driver is messed up.
                    //

                    if (Device == NULL) {

                        ExceptionCode = STATUS_DRIVER_INTERNAL_ERROR;

                        UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

                        return ExceptionCode;
                    }
                }

            //
            //  CdPerformVerify() will do the right thing with the Irp.
            //  If we return STATUS_CANT_WAIT then the current thread
            //  can retry the request.
            //

            return UdfPerformVerify( IrpContext, Irp, Device );
        }

        //
        //  The other user induced conditions generate an error unless
        //  they have been disabled for this request.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS )) {

            UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

            return ExceptionCode;

        } 
        //
        //  Generate a pop-up.
        //
        else {

            if (IoGetCurrentIrpStackLocation( Irp )->FileObject != NULL) {

                Vpb = IoGetCurrentIrpStackLocation( Irp )->FileObject->Vpb;

            } else {

                Vpb = NULL;
            }

            //
            //  The device to verify is either in my thread local storage
            //  or that of the thread that owns the Irp.
            //

            Thread = Irp->Tail.Overlay.Thread;
            Device = IoGetDeviceToVerify( Thread );

            if (Device == NULL) {

                Thread = PsGetCurrentThread();
                Device = IoGetDeviceToVerify( Thread );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver is messed up.
                //

                if (Device == NULL) {

                    UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  This routine actually causes the pop-up.  It usually
            //  does this by queuing an APC to the callers thread,
            //  but in some cases it will complete the request immediately,
            //  so it is very important to IoMarkIrpPending() first.
            //

            DebugTrace(( 0, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP, 
                         "Raising hard error on exception %x\n", ExceptionCode));

            IoMarkIrpPending( Irp );
            IoRaiseHardError( Irp, Vpb, Device );

            //
            //  We will be handing control back to the caller here, so
            //  reset the saved device object.
            //

            IoSetDeviceToVerify( Thread, NULL );

            //
            //  The Irp will be completed by Io or resubmitted.  In either
            //  case we must clean up the IrpContext here.
            //

            UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            return STATUS_PENDING;
        }
    }
    
    //
    //  If we were in the process of mount,  then we need to morph any
    //  corruption errors to STATUS_UNRECOGNIZED_VOLUME,  so that Io continues
    //  the mount process and RAW will get the volume.  Otherwise we keep
    //  getting remount requests when we try to reformat a corrupt volume
    //  (or do anything with the drive).
    //
    
#if 0
    //  Not sure about this.  Format should do a 'raw allowed' open,  so....
    
    if ((IRP_MJ_FILE_SYSTEM_CONTROL == IrpContext->MajorFunction) &&
        (IRP_MN_MOUNT_VOLUME == IrpContext->MinorFunction))  {

        ExceptionCode = STATUS_UNRECOGNIZED_VOLUME;
    }
#endif

    //
    //  This is just a run of the mill error.
    //

    UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

    return ExceptionCode;
}


VOID
UdfCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes a Irp and cleans up the IrpContext.  Either or
    both of these may not be specified.

Arguments:

    Irp - Supplies the Irp being processed.

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  Cleanup the IrpContext if passed in here.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        UdfCleanupIrpContext( IrpContext, FALSE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        //
        //  Clear the information field in case we have used this Irp
        //  internally.
        //

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
    }

    return;
}


VOID
UdfSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    )

/*++

Routine Description:

    This routine is called at each Fsd/Fsp entry point set up the IrpContext
    and thread local storage to track top level requests.  If there is
    not a Udfs context in the thread local storage then we use the input one.
    Otherwise we use the one already there.  This routine also updates the
    IrpContext based on the state of the top-level context.

    If the TOP_LEVEL flag in the IrpContext is already set when we are called
    then we force this request to appear top level.

Arguments:

    ThreadContext - Address on stack for local storage if not already present.

    ForceTopLevel - We force this request to appear top level regardless of
        any previous stack value.

Return Value:

    None

--*/

{
    PTHREAD_CONTEXT CurrentThreadContext;
    ULONG_PTR StackTop;
    ULONG_PTR StackBottom;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Get the current top-level irp out of the thread storage.
    //  If NULL then this is the top-level request.
    //

    CurrentThreadContext = (PTHREAD_CONTEXT) IoGetTopLevelIrp();

    if (CurrentThreadContext == NULL) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL );
    }

    //
    //  Initialize the input context unless we are using the current
    //  thread context block.  We use the new block if our caller
    //  specified this or the existing block is invalid.
    //
    //  The following must be true for the current to be a valid Udfs context.
    //
    //      Structure must lie within current stack.
    //      Address must be ULONG aligned.
    //      Udfs signature must be present.
    //
    //  If this is not a valid Udfs context then use the input thread
    //  context and store it in the top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL ) ||
        (((ULONG_PTR) CurrentThreadContext > StackBottom - sizeof( THREAD_CONTEXT )) ||
         ((ULONG_PTR) CurrentThreadContext <= StackTop) ||
         LongOffsetPtr( CurrentThreadContext ) ||
         (CurrentThreadContext->Udfs != UDFS_SIGNATURE))) {

        ThreadContext->Udfs = UDFS_SIGNATURE;
        ThreadContext->SavedTopLevelIrp = (PIRP) CurrentThreadContext;
        ThreadContext->TopLevelIrpContext = IrpContext;
        IoSetTopLevelIrp( (PIRP) ThreadContext );

        IrpContext->TopLevel = IrpContext;
        IrpContext->ThreadContext = ThreadContext;

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS );

    //
    //  Otherwise use the IrpContext in the thread context.
    //

    } else {

        IrpContext->TopLevel = CurrentThreadContext->TopLevelIrpContext;
    }

    return;
}


BOOLEAN
UdfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PAGED_CODE();

    return TRUE;
}


ULONG
UdfSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine is called to generate a 32 bit serial number.  This is
    done by doing four separate checksums into an array of bytes and
    then treating the bytes as a ULONG.

Arguments:

    Buffer - Pointer to the buffer to generate the ID for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    ULONG - The 32 bit serial number.

--*/

{
    union {
        UCHAR   Bytes[4];
        ULONG   SerialId;
    } Checksum;

    PAGED_CODE();

    //
    //  Initialize the serial number.
    //

    Checksum.SerialId = 0;

    //
    //  Continue while there are more bytes to use.
    //

    while (ByteCount--) {

        //
        //  Increment this sub-checksum.
        //

        Checksum.Bytes[ByteCount & 0x3] += *(Buffer++);
    }

    //
    //  Return the checksums as a ULONG.
    //

    return Checksum.SerialId;
}


VOID
UdfInitializeCrc16 (
    ULONG Polynomial
    )

/*++

Routine Description:

    This routine generates the 16bit CRC Table to be used in CRC calculation.

Arguments:

    Polynomial - Starting seed for the generation

Return Value:

    None

--*/

{
    ULONG n, i, Crc;

    //
    //  All CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
    //  and Ned W. Rhodes of Software Systems Group.  It has been published in
    //  "Design and Validation of Computer Protocols", Prentice Hall, Englewood
    //  Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
    //
    //  Copyright is held by AT&T.
    //
    //  AT&T gives permission for the free use of the source code.
    //

    UdfCrcTable = (PUSHORT) FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                      256 * sizeof(USHORT),
                                                      TAG_CRC_TABLE );

    for (n = 0; n < 256; n++) {

        Crc = n << 8;

        for (i = 0; i < 8; i++) {

            if(Crc & 0x8000) {

                Crc = (Crc << 1) ^ Polynomial;

            } else {

                Crc <<= 1;
            }

            Crc &= 0xffff;
        }

        UdfCrcTable[n] = (USHORT) Crc;
    }
}



USHORT
UdfComputeCrc16 (
	PUCHAR Buffer,
	ULONG ByteCount
    )

/*++

Routine Description:

    This routine generates a 16 bit CRC of the input buffer in accordance
    with the precomputed CRC table.

Arguments:

    Buffer - Pointer to the buffer to generate the CRC for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    USHORT - The 16bit CRC

--*/

{
	USHORT Crc = 0;

    //
    //  All CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
    //  and Ned W. Rhodes of Software Systems Group.  It has been published in
    //  "Design and Validation of Computer Protocols", Prentice Hall, Englewood
    //  Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
    //
    //  Copyright is held by AT&T.
    //
    //  AT&T gives permission for the free use of the source code.
    //

    while (ByteCount-- > 0) {

        Crc = UdfCrcTable[((Crc >> 8) ^ *Buffer++) & 0xff] ^ (Crc << 8);
    }

	return Crc;
}


USHORT
UdfComputeCrc16Uni (
    PWCHAR Buffer,
    ULONG CharCount
    )

/*++

Routine Description:

    This routine generates a 16 bit CRC of the input buffer in accordance
    with the precomputed CRC table.
    
    It performs a byte-order independent crc (hi then lo). This is a bit
    suspect, but is called for in the specification. 

Arguments:

    Buffer - Pointer to the buffer to generate the CRC for.

    ShortCount - Number of wide characters in the buffer.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    USHORT Crc = 0;

    //
    //  Byte order independent CRC, hi byte to low byte per character.
    //

    while (CharCount-- > 0) {

        Crc = UdfCrcTable[((Crc >> 8) ^ (*Buffer >> 8)) & 0xff] ^ (Crc << 8);
        Crc = UdfCrcTable[((Crc >> 8) ^ (*Buffer++ & 0xff)) & 0xff] ^ (Crc << 8);
    }

    return Crc;
}


ULONG
UdfHighBit (
    ULONG Word
    )

/*++

Routine Description:

    This routine discovers the highest set bit of the input word.  It is
    equivalent to the integer logarithim base 2.

Arguments:

    Word - word to check

Return Value:

    Bit offset of highest set bit. If no bit is set, return is zero.

--*/

{
    ULONG Offset = 31;
    ULONG Mask = (ULONG)(1 << 31);

    if (Word == 0) {

        return 0;
    }

    while ((Word & Mask) == 0) {

        Offset--;
        Mask >>= 1;
    }

    return Offset;
}


#ifdef UDF_SANITY
BOOLEAN
UdfDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine is a simple debug info printer that returns a constant boolean value.  This
    makes it possible to splice it into the middle of boolean expressions to discover which
    elements are firing.
    
    We will use this as our general debug printer.  See udfdata.h for how we use the DebugTrace
    macro to accomplish the effect.
    
Arguments:

    IndentIncrement - amount to change the indentation by.
    
    TraceMask - specification of what debug trace level this call should be noisy at.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    va_list Arglist;
    LONG i;
    UCHAR Buffer[256];
    int Bytes;
    int ThreadIdChars;

    if (TraceMask == 0 || (UdfDebugTraceLevel & TraceMask) != 0) {

        //
        //  Print out the current thread,  otherwise all this trace is completely
        //  useless in the face of multi threaded issues.
        //
        
        ThreadIdChars = sprintf(Buffer, "%p ", PsGetCurrentThread());
        // DbgPrint( Buffer );

        //
        //  The indent stuff doesn't work too well across multi thread output.
        //
#if 0        
        //
        //  Build the indent in big chunks since calling DbgPrint repeatedly is expensive.
        //
        
        for (i = UdfDebugTraceIndent; i > 0; i -= (sizeof(Buffer) - 1)) {

            RtlFillMemory( Buffer, Min( i, (sizeof(Buffer) - 1 )), ' ');
            *(Buffer + Min( i, (sizeof(Buffer) - 1 ))) = '\0';
            
            DbgPrint( Buffer );
        }
#endif
        //
        // Format the output into a buffer and then print it.
        //

        va_start( Arglist, Format );
        Bytes = _vsnprintf( Buffer + ThreadIdChars, sizeof(Buffer) - ThreadIdChars, Format, Arglist );
        va_end( Arglist );

        //
        // detect buffer overflow
        //

        if (Bytes == -1) {

            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DbgPrint( Buffer );
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udfprocs.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfProcs.h

Abstract:

    This module defines all of the globally used procedures in the Udfs
    file system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	29-May-1996
    
Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#ifndef _UDFPROCS_
#define _UDFPROCS_

#include <ntifs.h>

#include <ntddscsi.h>
#include <scsi.h>
#include <ntddmmc.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>
#include <ntddstor.h>

#ifndef INLINE
#define INLINE __inline
#endif

//
//  Compile in experimental code for mounting 'open' CD-R / DVD-R media.
//

// #define EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

//
//  Turn on the sanity checks if this is DBG or UDF_FREE_ASSERTS
//

#if DBG || UDF_FREE_ASSERTS
#undef UDF_SANITY
#define UDF_SANITY
#ifdef _X86_
#define UDF_CAPTURE_BACKTRACES
#endif
#endif

#include "nodetype.h"
#include "Udf.h"
#include "UdfStruc.h"
#include "UdfData.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_STRUCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_STRUCSUP)


//
//  Miscellaneous support routines/macros
//

//
//  Yet another declaration of Min/Max
//

#ifndef Min
#define Min(a, b)   ((a) < (b) ? (a) : (b))
#endif

#ifndef Max
#define Max(a, b)   ((a) > (b) ? (a) : (b))
#endif

//
//  Yet another declaration of the basic bit fiddlers
//

#ifndef FlagMask
#define FlagMask(F,SF) (                \
    ((F) & (SF))                        \
)
#endif

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (           \
//    (BOOLEAN)(FlagOn(F, SF) != 0)       \
//)
//#endif

#ifndef BooleanFlagOff
#define BooleanFlagOff(F,SF) (          \
    (BOOLEAN)(FlagOn(F, SF)) == 0)      \
)
#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) (     \
//    (Flags) |= (SingleFlag)             \
//)
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) (   \
//    (Flags) &= ~(SingleFlag)            \
//)
//#endif

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((ULONG_PTR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG)(OFFSET) - (ULONG)(BASE)))

//
//  Generic truncation/align/offset/remainder macros for power-of-two units.
//
//  The offset and remainder functions range from zero to (unit - 1).  The
//  re-offset in the remainder performs this work.
//

#define GenericTruncate(B, U) (                                             \
    (B) & ~((U) - 1)                                                        \
)

#define GenericAlign(B, U) (                                                \
    GenericTruncate((B) + (U) - 1, U)                                       \
)

#define GenericOffset(B, U) (                                               \
    (B) & ((U) - 1)                                                         \
)

#define GenericRemainder(B, U) (                                            \
    GenericOffset( (U) - GenericOffset((B), (U)), (U) )                     \
)


#define GenericTruncatePtr(B, U) (                                          \
    (PVOID)(((ULONG_PTR)(B)) & ~((U) - 1))                                  \
)

#define GenericAlignPtr(B, U) (                                             \
    GenericTruncatePtr((B) + (U) - 1, (U))                                  \
)

#define GenericOffsetPtr(B, U) (                                            \
    (ULONG)(((ULONG_PTR)(B)) & ((U) - 1))                                   \
)

#define GenericRemainderPtr(B, U) (                                         \
    (ULONG)GenericOffset( (U) - GenericOffsetPtr((B), (U)), (U) )           \
)

//
//  Useful compositions of the defaults for common types.
//

#define WordAlign(B) GenericAlign((B), 2)

#define LongAlign(B) GenericAlign((B), 4)

#define QuadAlign(B) GenericAlign((B), 8)


#define WordOffset(B) GenericOffset((B), 2)

#define LongOffset(B) GenericOffset((B), 4)

#define QuadOffset(B) GenericOffset((B), 8)


#define WordAlignPtr(P) GenericAlignPtr((P), 2)

#define LongAlignPtr(P) GenericAlignPtr((P), 4)

#define QuadAlignPtr(P) GenericAlignPtr((P), 8)


#define WordOffsetPtr(P) GenericOffsetPtr((P), 2)

#define LongOffsetPtr(P) GenericOffsetPtr((P), 4)

#define QuadOffsetPtr(P) GenericOffsetPtr((P), 8)


//
//  Macros to round up and down on sector and logical block boundaries.  Although
//  UDF 1.01 specifies that a physical sector is the logical block size we will
//  be general and treat sectors and logical blocks as distinct.  Since UDF may
//  at some point relax the restriction, these definitions will be the only
//  acknowledgement outside of the mount path (which merely checks the volume's
//  conformance).
//

//
//  Use INLINEd functions here to catch misuse (ULONGLONG into ULONG etc).
//

//
//  Sector
//

INLINE
ULONG
SectorAlignN( 
    ULONG SectorSize, 
    ULONG Length
) {

    return (Length + (SectorSize - 1)) & ~(SectorSize - 1);
}

INLINE
ULONG
SectorAlign( 
    PVCB Vcb, 
    ULONG Length
) {

    return (Length + (Vcb->SectorSize - 1)) & ~(Vcb->SectorSize - 1);
}

INLINE
ULONGLONG
LlSectorAlign( 
    PVCB Vcb, 
    ULONGLONG Length
) {

    return (Length + (Vcb->SectorSize - 1)) & ~(ULONGLONG)(Vcb->SectorSize - 1);
}

INLINE
ULONG
SectorTruncate( 
    PVCB Vcb, 
    ULONG Length
) {

    return (Length & ~(Vcb->SectorSize - 1));
}

#define LlSectorTruncate(V, L) (                                                \
    ((LONGLONG)(L)) & ~(((LONGLONG)(V)->SectorSize) - 1)                        \
)

INLINE
ULONG
BytesFromSectors( 
    PVCB Vcb, 
    ULONG Sectors
) {
    //
    // Test for 32 bit overflow in the result
    //

    ASSERT( (Sectors & ~(0xffffffff >> Vcb->SectorShift)) == 0);
    return (ULONG)(Sectors << Vcb->SectorShift);
}

INLINE
ULONG
SectorsFromBytes( 
    PVCB Vcb, 
    ULONG Bytes
) {

    return (Bytes >> Vcb->SectorShift);
}

INLINE
ULONG
SectorsFromLlBytes( 
    PVCB Vcb, 
    ULONGLONG Bytes
) {

    return (ULONG)(Bytes >> Vcb->SectorShift);
}
    
#define LlBytesFromSectors(V, L) (                                              \
    Int64ShllMod32( (ULONGLONG)(L), ((V)->SectorShift) )                        \
)

#define LlSectorsFromBytes(V, L) (                                              \
    Int64ShrlMod32( (ULONGLONG)(L), ((V)->SectorShift) )                        \
)

#define SectorsFromBlocks(V, B) (B)

#define SectorSize(V) ((V)->SectorSize)

INLINE 
ULONG
SectorOffset(
    IN PVCB Vcb,
    IN ULONGLONG Length
    )
{
    return (ULONG)(Length & (Vcb->SectorSize - 1));
}

//
//  Logical Block
//

#define BlockAlignN(BLOCKSIZE, L) (                                             \
    SectorAlighN((BLOCKSIZE), (L))                                              \
)

#define BlockAlign(V, L) (                                                      \
    SectorAlign((V), (L))                                                       \
)

#define LlBlockAlign(V, L) (                                                    \
    LlSectorAlign((V), (L))                                                     \
)

#define BlockTruncate(V, L) (                                                   \
    SectorTruncate((V), (L))                                                    \
)

#define LlBlockTruncate(V, L) (                                                 \
    LlSectorTruncate((V), (L))                                                  \
)

#define BytesFromBlocks(V, L) (                                                 \
    BytesFromSectors((V), (L))                                                  \
)

#define BlocksFromBytes(V, L) (                                                 \
    SectorsFromBytes((V), (L))                                                  \
)

#define LlBytesFromBlocks(V, L) (                                               \
    LlBytesFromSectors((V), (L))                                                \
)

#define LlBlocksFromBytes(V, L) (                                               \
    LlSectorsFromBytes((V), (L))                                                \
)

#define BlocksFromSectors(V, S) (S)

#define BlockSize(V) (SectorSize(V))

#define BlockOffset(V, L) (                                                     \
    SectorOffset((V), (L))                                                      \
)

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in various structures.
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                           \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));  \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                           \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));  \
    }
    
//
//  This macro copies an unaligned src word to a dst word,
//  performing an little/big endian swap.
//

#define SwapCopyUchar2(Dst,Src) {                                       \
    *((UNALIGNED UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src) + 1);    \
    *((UNALIGNED UCHAR1 *)(Dst) + 1) = *((UNALIGNED UCHAR1 *)(Src));    \
}

//
//  This macro copies an unaligned src longword to an aligned dst longword
//

#define CopyUchar4(Dst,Src) {                           \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to a dst longword,
//  performing an little/big endian swap.
//

#define SwapCopyUchar4(Dst,Src) {                                        \
    *((UNALIGNED UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src) + 3);     \
    *((UNALIGNED UCHAR1 *)(Dst) + 1) = *((UNALIGNED UCHAR1 *)(Src) + 2); \
    *((UNALIGNED UCHAR1 *)(Dst) + 2) = *((UNALIGNED UCHAR1 *)(Src) + 1); \
    *((UNALIGNED UCHAR1 *)(Dst) + 3) = *((UNALIGNED UCHAR1 *)(Src));     \
}

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                          \
    *((USHORT2 *)(Dst)) = *((UNALIGNED USHORT2 *)(Src));\
    }

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(I)   IoIsOperationSynchronous(I)

//
//  The following macro is used to set the fast i/o possible bits in the
//  FsRtl header.
//
//      FastIoIsNotPossible - If the Fcb is bad or there are oplocks on the file.
//
//      FastIoIsQuestionable - If there are file locks.
//
//      FastIoIsPossible - In all other cases.
//
//

#define UdfIsFastIoPossible(F) ((BOOLEAN)                                           \
    ((((F)->Vcb->VcbCondition != VcbMounted ) ||                                    \
      !FsRtlOplockIsFastIoPossible( &(F)->Oplock )) ?                               \
                                                                                    \
     FastIoIsNotPossible :                                                          \
                                                                                    \
     ((((F)->FileLock != NULL) && FsRtlAreThereCurrentFileLocks( (F)->FileLock )) ? \
                                                                                    \
        FastIoIsQuestionable :                                                      \
                                                                                    \
        FastIoIsPossible))                                                          \
)

//
//  The following macros encapsulate the common work of raising exceptions while storing
//  the exception in the IrpContext.
//

#ifdef UDF_SANITY

DECLSPEC_NORETURN
VOID
UdfRaiseStatusEx (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN Normalize,
    IN ULONG FileId,
    IN ULONG Line
    );

#else

INLINE
DECLSPEC_NORETURN
VOID
UdfRaiseStatusEx (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN Normalize,
    IN ULONG FileId,
    IN ULONG Line
    )
{
    if (Normalize)  {

        IrpContext->ExceptionStatus = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR);
    }
    else {
        
        IrpContext->ExceptionStatus = Status;
    }

    IrpContext->RaisedAtFileLine = (FileId << 16) | Line;
    
    ExRaiseStatus( IrpContext->ExceptionStatus );
}

#endif

#define UdfRaiseStatus( IC, S)              UdfRaiseStatusEx((IC),(S),FALSE,BugCheckFileId,__LINE__)
#define UdfNormalizeAndRaiseStatus( IC, S)  UdfRaiseStatusEx((IC),(S),TRUE,BugCheckFileId,__LINE__)

//
//  The following is a convenience macro to execute a little code before making
//  a shortcircuit out of a surrounding try-finally clause.  This is usually to
//  set a status value.
//
//  Note that our compilers support the leave keyword now and we don't have to
//  use the old try_exit: labels and goto.
//

#define try_leave(S) { S; leave; }

//
//  For debugging purposes we sometimes want to allocate our structures from nonpaged
//  pool so that in the kernel debugger we can walk all the structures.
//

#define UdfPagedPool                 PagedPool
#define UdfNonPagedPool              NonPagedPool
#define UdfNonPagedPoolCacheAligned  NonPagedPoolCacheAligned

//
//  Encapsulate safe pool freeing
//

INLINE
VOID
UdfFreePool(
    IN PVOID *Pool
    )
{
    if (*Pool != NULL) {

        ExFreePool(*Pool);
        *Pool = NULL;
    }
}

//
//  Encapsulate counted string compares with uncounted fields.  Thanks to a
//  very smart compiler, we have to carefully tell it that no matter what it
//  thinks, it *cannot* do anything other than a bytewise compare.
//

INLINE
BOOLEAN
UdfEqualCountedString(
    IN PSTRING String,
    IN PCHAR Field
    )
{
    return (RtlEqualMemory( (CHAR UNALIGNED *)String->Buffer,
                            (CHAR UNALIGNED *)Field,
                            String->Length )                    != 0);
}


//
//  Type of opens.  FilObSup.c depends on this order.
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 0,
    StreamFileOpen,
    UserVolumeOpen,
    UserDirectoryOpen,
    UserFileOpen,
    BeyondValidType

} TYPE_OF_OPEN, *PTYPE_OF_OPEN;


//
//  Following routines handle entry in and out of the filesystem.  They are
//  contained in UdfData.c.  We also get some very generic utility functions
//  here that aren't associated with any particular datastructure.
//

NTSTATUS
UdfFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

LONG
UdfExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

LONG
UdfQueryDirExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

NTSTATUS
UdfProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

VOID
UdfCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  Following are the routines to handle the top level thread logic.
//

VOID
UdfSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    );

INLINE
VOID
UdfRestoreThreadContext (
     IN PIRP_CONTEXT IrpContext
     )
{
    IrpContext->ThreadContext->Udfs = 0;
    IoSetTopLevelIrp( IrpContext->ThreadContext->SavedTopLevelIrp );
    IrpContext->ThreadContext = NULL;
}

//
//  Following are some generic utility functions we have to carry along for the ride
//

INLINE
BOOLEAN
UdfDeviceIsFsDo(
    IN PDEVICE_OBJECT Device
    )
{
#if (NUMBER_OF_FS_OBJECTS != 2)
#error "Size of fsdo array changed - fixme!"
#endif

    return (Device == UdfData.FileSystemDeviceObjects[0]) || 
           (Device == UdfData.FileSystemDeviceObjects[1]);
}

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(IC,AT,BYTE_COUNT) {                  \
    try {                                                   \
        RtlZeroMemory( (AT), (BYTE_COUNT) );                \
    } except( EXCEPTION_EXECUTE_HANDLER ) {                 \
         UdfRaiseStatus( IC, STATUS_INVALID_USER_BUFFER );   \
    }                                                       \
}


ULONG
UdfSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    );

VOID
UdfInitializeCrc16 (
    ULONG Polynomial
    );

USHORT
UdfComputeCrc16 (
	IN PUCHAR Buffer,
	IN ULONG ByteCount
    );

USHORT
UdfComputeCrc16Uni (
    PWCHAR Buffer,
    ULONG CharCount
    );

ULONG
UdfHighBit (
    ULONG Word
    );

//
//  Following are the fast entry points.
//

BOOLEAN
UdfFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


//
//  File access check routine, implemented in AcChkSup.c
//

INLINE
BOOLEAN
UdfIllegalFcbAccess (
    IN PIRP_CONTEXT IrpContext,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine simply asserts that the access is legal for a readonly filesystem.
    
Arguments:

    TypeOfOpen - type of open for the Fcb in question.
    
    DesiredAccess - mask of access the caller is trying for.

Return Value:

    BOOLEAN True if illegal access, false otherwise.

--*/

{
    return BooleanFlagOn( DesiredAccess,
                          (TypeOfOpen != UserVolumeOpen ?
                           (FILE_WRITE_ATTRIBUTES           |
                            FILE_WRITE_DATA                 |
                            FILE_WRITE_EA                   |
                            FILE_ADD_FILE                   |                     
                            FILE_ADD_SUBDIRECTORY           |
                            FILE_APPEND_DATA) : 0)          |
                          FILE_DELETE_CHILD                 |
                          DELETE                            |
                          WRITE_DAC );
}


//
//  Sector lookup routines, implemented in AllocSup.c
//

BOOLEAN
UdfLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    );

VOID
UdfDeletePcb (
    IN PPCB Pcb
    );

NTSTATUS
UdfInitializePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PPCB *Pcb,
    IN PNSR_LVOL LVD
    );

VOID
UdfAddToPcb (
    IN PPCB Pcb,
    IN PNSR_PART PartitionDescriptor
);

NTSTATUS
UdfCompletePcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PPCB Pcb );

BOOLEAN
UdfEquivalentPcb (
    IN PIRP_CONTEXT IrpContext,
    IN PPCB Pcb1,
    IN PPCB Pcb2
    );

ULONG
UdfLookupPsnOfExtent (
    IN PIRP_CONTEXT IrpContext,    
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len
    );

ULONG
UdfLookupMetaVsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len,
    IN BOOLEAN ExactEnd
    );


//
//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

VOID
UdfCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
UdfDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );


NTSTATUS
UdfCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

typedef enum {
    METAMAPOP_INIT_VIEW_ONLY = 0,
    METAMAPOP_REMAP_VIEW,
    METAMAPOP_INIT_AND_MAP
} MAPMETAOP;

VOID
UdfMapMetadataView (
    IN PIRP_CONTEXT IrpContext,
    IN PMAPPED_PVIEW View,
    IN PVCB Vcb,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length,
    IN MAPMETAOP Operation
    );

NTSTATUS
UdfPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    );

//  VOID
//  UdfUnpinView (
//      IN PIRP_CONTEXT IrpContext,
//      IN PMAPPED_VIEW View
//      );
//
//
//  Also releases the Vcb->VmcbMappingResource if the view was actually CcMapped.

#define UdfUnpinView(IC,V)                                                          \
            if (((V)->Bcb) != NULL)  {                                              \
                CcUnpinData( ((V)->Bcb) );                                          \
                UdfReleaseVmcb( (IC), (IC)->Vcb);                                   \
                ((V)->Bcb) = NULL;                                                  \
                ((V)->View) = NULL;                                                 \
                ((V)->Vsn) = UDF_INVALID_VSN;                                       \
            }

//  VOID
//  UdfUnpinData (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//

#define UdfUnpinData(IC,B)   \
    if (*(B) != NULL) { CcUnpinData( *(B) ); *(B) = NULL; }


//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device reads and other communcation.
//  They do not affect any data structures.
//

#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

NTSTATUS
UdfSendSptCdb(
    IN PDEVICE_OBJECT Device,
    IN PCDB Cdb,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferSize,
    IN BOOLEAN InputOperation,
    IN ULONG TimeOut,
    IN OPTIONAL PVOID TempBuffer,
    IN OPTIONAL ULONG TempBufferSize,
    OUT PULONG SenseKeyCodeQualifier,
    OUT PUSHORT ProgressIndication
    );

#endif

NTSTATUS
UdfPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    );

NTSTATUS
UdfReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
UdfNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

NTSTATUS
UdfCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError,
    IN ULONG Operation
    );

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

//
//  VOID
//  UdfMapUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      OUT PVOID Buffer
//      );
//
//  Will raise on failure.
//
//  VOID
//  UdfLockUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      IN ULONG BufferLength
//      );
//

#define UdfMapUserBuffer(IC,UB) {                                                   \
            *(UB) = ((PVOID) (((IC)->Irp->MdlAddress == NULL) ?                     \
                             (IC)->Irp->UserBuffer :                                \
                             MmGetSystemAddressForMdlSafe( (IC)->Irp->MdlAddress, NormalPagePriority )));   \
            if (NULL == *(UB))  {                                                    \
                UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES);         \
            }                                                                       \
        }
        
#define UdfLockUserBuffer(IC,BL,OP) {                       \
    if ((IC)->Irp->MdlAddress == NULL) {                    \
        (VOID) UdfCreateUserMdl( (IC), (BL), TRUE, (OP) );  \
    }                                                       \
}

//
//  Udf*RawBufferSize and Udf*RawReadSize calculate how big a buffer must be
//  to do a direct read of a given sector aligned structure (UdfReadSectors)
//  and how much data the read must recover.  Reads must write into whole-page
//  sized buffers and be in whole-sector units.
//
//  Note that although all descriptors are constrained to fit in one logical
//  block, it is not always going to be neccesary to read the entire logical
//  block to get the descriptor.  The underlying restriction is the physical
//  sector.
//

INLINE
ULONG
UdfRawBufferSize (
    IN PVCB Vcb,
    IN ULONG StructureSize
    )
{
    return (ULONG)ROUND_TO_PAGES( SectorAlign( Vcb, StructureSize ));
}

INLINE
ULONG
UdfRawReadSize (
    IN PVCB Vcb,
    IN ULONG StructureSize
    )
{
    return SectorAlign( Vcb, StructureSize );
}

INLINE
ULONG
UdfRawBufferSizeN (
    IN ULONG SectorSize,
    IN ULONG StructureSize
    )
{
    return (ULONG)ROUND_TO_PAGES( SectorAlignN( SectorSize, StructureSize ));
}

INLINE
ULONG
UdfRawReadSizeN (
    IN ULONG SectorSize,
    IN ULONG StructureSize
    )
{
    return SectorAlignN( SectorSize, StructureSize );
}


//
//  The following routines are used to read on-disk directory structures, implemented
//  in DirSup.c
//

VOID
UdfInitializeDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    );

VOID
UdfCleanupDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    );

BOOLEAN
UdfLookupInitialDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN PLONGLONG InitialOffset OPTIONAL
    );

BOOLEAN
UdfLookupNextDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext
    );

VOID
UdfUpdateDirNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
UdfFindDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortName,
    IN PDIR_ENUM_CONTEXT DirContext
    );


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

VOID
UdfSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    );

TYPE_OF_OPEN
UdfDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    );

TYPE_OF_OPEN
UdfFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    );


//
//  FSCTL request support routines. Contained in FsCtrl.c
//

VOID
UdfStoreVolumeDescriptorIfPrevailing (
    IN OUT PNSR_VD_GENERIC *StoredVD,
    IN OUT PNSR_VD_GENERIC NewVD
    );


//
//  Name mangling routines.  Implemented in Namesup.c
//

VOID
UdfDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    );

BOOLEAN
UdfIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    );

BOOLEAN
UdfCandidateShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    );

VOID
UdfGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING ShortFileName
    );

VOID
UdfConvertCS0DstringToUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUCHAR Dstring,
    IN UCHAR Length OPTIONAL,
    IN UCHAR FieldLength OPTIONAL,
    IN OUT PUNICODE_STRING Name
    );

BOOLEAN
UdfCheckLegalCS0Dstring (
    PIRP_CONTEXT IrpContext,
    PUCHAR Dstring,
    UCHAR Length OPTIONAL,
    UCHAR FieldLength OPTIONAL,
    BOOLEAN ReturnOnError
    );

VOID
UdfRenderNameToLegalUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING RenderedName
    );

BOOLEAN
UdfIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING CurrentName,
    IN PUNICODE_STRING SearchExpression,
    IN BOOLEAN Wild
    );

FSRTL_COMPARISON_RESULT
UdfFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    );

INLINE
VOID
UdfUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN OUT PUNICODE_STRING UpcaseName
    )

/*++

Routine Description:

    This routine upcases a name with an assertion of success.
    
Arguments:

    Name - an name to upcase
    
    Length - a place to put the upcased name (can be the same as Name)
    
Return Value:

    None.
    
--*/

{
    NTSTATUS Status;

    //
    //  Upcase the string using the correct upcase routine.
    //

    Status = RtlUpcaseUnicodeString( UpcaseName,
                                     Name,
                                     FALSE );

    //
    //  This should never fail.
    //

    ASSERT( Status == STATUS_SUCCESS );

    return;
}

INLINE
USHORT
UdfCS0DstringUnicodeSize (
    PIRP_CONTEXT IrpContext,
    PCHAR Dstring,
    UCHAR Length
    )

/*++

Routine Description:

    This routine computes the number of bytes required for the UNICODE representation
    of a CS0 Dstring (1/7.2.12)
    
Arguments:

    Dstring - a dstring
    
    Length - length of the dstring
    
Return Value:

    ULONG number of bytes.
    
--*/

{
    return (16 / *Dstring) * (Length - 1);
}

INLINE
BOOLEAN
UdfIsCharacterLegal (
    IN WCHAR Character
    )

/*++

Routine Description:

    This routine checks that a given UNICODE character is legal.
    
Arguments:

    Character - a character to check
    
Return Value:

    BOOLEAN True if a legal character, False otherwise.
    
--*/

{
    if (Character < 0xff && !FsRtlIsAnsiCharacterLegalHpfs( Character, FALSE )) {

        return FALSE;
    }

    return TRUE;
}


INLINE
BOOLEAN
UdfCS0DstringIsLegalFileName(
    IN PCHAR Dstring,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine inspects a CS0 dstring for illegal characters,  and illegal
    trailing characters.  

    NOTE: The assumption is made that the string is legal CS0.
    
Arguments:

    Name - a name to check

    Length - length of dstring (i.e. incl. leading char set specifier byte) in *bytes* 
    
Return Value:

    BOOLEAN True if legal characters are found, False otherwise.
    
--*/

{
    ULONG Step;
    WCHAR Char;
    PCHAR Bound = Dstring + Length;

    ASSERT( Length > 1);
    
    //
    //  Determine how big a step we take in the string according to the
    //  "compression" applied.
    //
    
    if (*Dstring == 16) {

        Step = sizeof( WCHAR );
    
    } else {

        Step = sizeof( CHAR );
    }

    ASSERT( Length >= (1 + Step));
 
    //
    //  Advance past the compression marker and loop over the string.
    //
    
    for (Dstring++; Dstring < Bound; Dstring += Step) {

        if ( sizeof(WCHAR) == Step)  {
        
            //
            //  Perform the endianess swapcopy to convert from UDF bigendian CS0 to our
            //  little endian wide characters.
            //
            
            SwapCopyUchar2( &Char, Dstring );  
        }
        else {
        
            Char = *Dstring;
        }

        if (!UdfIsCharacterLegal( Char )) {

            DebugTrace(( 0, Dbg, "UdfCS0DstringIsLegalFileName, Char %04x @ %08x\n", (WCHAR) Char, Dstring ));

            return FALSE;
        }
    }

    //
    //  Now check for illegal trailing characters (' ' or '.')  We know that Char
    //  will be the last character in the string.
    //

    if ((PERIOD == Char) || (SPACE == Char))  {
    
        DebugTrace(( 0, Dbg, "UdfCS0DstringIsLegalFileName, has trailing space or period\n"));
        
        return FALSE;
    }

    return TRUE;
}


//
//  Filesystem control operations.  Implemented in Fsctrl.c
//

NTSTATUS
UdfLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTSTATUS
UdfUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );


//
//  Routines to handle the prefix trees attached to directories, used to quickly travel common
//  bits of the hierarchy.  Implemented in PrefxSup.c
//

PLCB
UdfFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    );

VOID            
UdfInitializeLcbFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PDIR_ENUM_CONTEXT DirContext
    );

PLCB
UdfInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN ShortNameMatch,
    IN BOOLEAN IgnoreCase,
    IN PFCB ParentFcb
    );

VOID
UdfRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb
    );


//
//  Synchronization routines.  Implemented in Resrcsup.c
//
//  The following routines/macros are used to synchronize the in-memory structures.
//
//      Routine/Macro               Synchronizes                            Subsequent
//
//      UdfAcquireUdfData           Volume Mounts/Dismounts,Vcb Queue       UdfReleaseUdfData
//      UdfAcquireVcbExclusive      Vcb for open/close                      UdfReleaseVcb
//      UdfAcquireVcbShared         Vcb for open/close                      UdfReleaseVcb
//      UdfAcquireAllFiles          Locks out operations to all files       UdfReleaseAllFiles
//      UdfAcquireFileExclusive     Locks out file operations               UdfReleaseFile
//      UdfAcquireFileShared        Files for file operations               UdfReleaseFile
//      UdfAcquireFcbExclusive      Fcb for open/close                      UdfReleaseFcb
//      UdfAcquireFcbShared         Fcb for open/close                      UdfReleaseFcb
//      UdfLockUdfData              Fields in UdfData                       UdfUnlockUdfData
//      UdfLockVcb                  Vcb fields, FcbReference, FcbTable      UdfUnlockVcb
//      UdfLockFcb                  Fcb fields, prefix table, Mcb           UdfUnlockFcb
//

typedef enum _TYPE_OF_ACQUIRE {
    
    AcquireExclusive,
    AcquireShared,
    AcquireSharedStarveExclusive

} TYPE_OF_ACQUIRE, *PTYPE_OF_ACQUIRE;

BOOLEAN
UdfAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    );

//
//  BOOLEAN
//  UdfAcquireUdfData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfReleaseUdfData (
//      IN PIRP_CONTEXT IrpContext
//    );
//
//  BOOLEAN
//  UdfAcquireVcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfAcquireVcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  VOID
//  UdfReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfAcquireAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfReleaseAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfAcquireFileExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      );
//
//  VOID
//  UdfAcquireFileShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfReleaseFile (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//    );
//
//  BOOLEAN
//  UdfAcquireFcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfAcquireFcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfReleaseFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfLockUdfData (
//      );
//
//  VOID
//  UdfUnlockUdfData (
//      );
//
//  VOID
//  UdfLockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfUnlockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define UdfAcquireUdfData(IC)                                                           \
    ExAcquireResourceExclusiveLite( &UdfData.DataResource, TRUE )

#define UdfReleaseUdfData(IC)                                                           \
    ExReleaseResourceLite( &UdfData.DataResource )

#define UdfAcquireVcbExclusive(IC,V,I)                                                  \
    UdfAcquireResource( (IC), &(V)->VcbResource, (I), AcquireExclusive )

#define UdfAcquireVcbShared(IC,V,I)                                                     \
    UdfAcquireResource( (IC), &(V)->VcbResource, (I), AcquireShared )

#define UdfReleaseVcb(IC,V)                                                             \
    ExReleaseResourceLite( &(V)->VcbResource )

#define UdfAcquireAllFiles(IC,V)                                                        \
    UdfAcquireResource( (IC), &(V)->FileResource, FALSE, AcquireExclusive )

#define UdfReleaseAllFiles(IC,V)                                                        \
    ExReleaseResourceLite( &(V)->FileResource )

#define UdfAcquireFileExclusive(IC,F)                                                   \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireExclusive )

#define UdfAcquireFileShared(IC,F)                                                      \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireShared )

#define UdfAcquireFileSharedStarveExclusive(IC,F)                                       \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireSharedStarveExclusive )

#define UdfReleaseFile(IC,F)                                                            \
    ExReleaseResourceLite( (F)->Resource )

#define UdfAcquireVmcbForCcMap(IC,V)                                                   \
        UdfAcquireResource( (IC), &(V)->VmcbMappingResource, FALSE, AcquireShared)
    
#define UdfAcquireVmcbForCcPurge(IC,V)                                                 \
        UdfAcquireResource( (IC), &(V)->VmcbMappingResource, FALSE, AcquireExclusive)

#define UdfReleaseVmcb( IC, V)                                                         \
        ExReleaseResourceLite( &(V)->VmcbMappingResource)

#define UdfAcquireFcbExclusive(IC,F,I)                                                  \
    UdfAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireExclusive )

#define UdfAcquireFcbShared(IC,F,I)                                                     \
    UdfAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireShared )

#define UdfReleaseFcb(IC,F)                                                             \
    ExReleaseResourceLite( &(F)->FcbNonpaged->FcbResource )

#define UdfLockUdfData()                                                                \
    ExAcquireFastMutex( &UdfData.UdfDataMutex );                                        \
    UdfData.UdfDataLockThread = PsGetCurrentThread()

#define UdfUnlockUdfData()                                                              \
    UdfData.UdfDataLockThread = NULL;                                                   \
    ExReleaseFastMutex( &UdfData.UdfDataMutex )

#define UdfLockVcb(IC,V)                                                                \
    ASSERT(KeAreApcsDisabled());                                                        \
    ExAcquireFastMutexUnsafe( &(V)->VcbMutex );                                         \
    (V)->VcbLockThread = PsGetCurrentThread()

#define UdfUnlockVcb(IC,V)                                                              \
    (V)->VcbLockThread = NULL;                                                          \
    ExReleaseFastMutexUnsafe( &(V)->VcbMutex )

#define UdfLockFcb(IC,F) {                                                              \
    PVOID _CurrentThread = PsGetCurrentThread();                                        \
    if (_CurrentThread != (F)->FcbLockThread) {                                         \
        ASSERT(KeAreApcsDisabled());                                                    \
        ExAcquireFastMutexUnsafe( &(F)->FcbNonpaged->FcbMutex );                        \
        ASSERT( (F)->FcbLockCount == 0 );                                               \
        (F)->FcbLockThread = _CurrentThread;                                            \
    }                                                                                   \
    (F)->FcbLockCount += 1;                                                             \
}

#define UdfUnlockFcb(IC,F) {                                                            \
    ASSERT( PsGetCurrentThread() == (F)->FcbLockThread);                                \
    (F)->FcbLockCount -= 1;                                                             \
    if ((F)->FcbLockCount == 0) {                                                       \
        (F)->FcbLockThread = NULL;                                                      \
        ExReleaseFastMutexUnsafe( &(F)->FcbNonpaged->FcbMutex );                              \
    }                                                                                   \
}

BOOLEAN
UdfNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
UdfNoopRelease (
    IN PVOID Fcb
    );

BOOLEAN
UdfAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    );

VOID
UdfReleaseFromCache (
    IN PFCB Fcb
    );

VOID
UdfAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
UdfReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


//
//  Structure support routines, implemented in StrucSup.c
//
//  These routines perform in-memory structure manipulations. They do *not* operate
//  on disk structures.
//

//
//  Encapsulate manipulation of the Vcb condition for tracing purposes.
//

#ifndef UDF_SANITY

#define UdfSetVcbCondition( V, C)       (V)->VcbCondition = (C)
#define UdfSetMediaChangeCount( V, C)   (V)->MediaChangeCount = (C)

#else

#define UdfSetVcbCondition( V, C)  { \
            DebugTrace(( 0, UDFS_DEBUG_LEVEL_VERFYSUP, "VcbCondition %p transitioning %d -> %d (%s : %d)\n", \
                         (V), (V)->VcbCondition, (C), __FILE__, __LINE__));                                  \
            (V)->VcbCondition = (C);                                                                         \
        }

#define UdfSetMediaChangeCount( V, C) { \
            DebugTrace(( 0, UDFS_DEBUG_LEVEL_VERFYSUP, "Vcb MCT %p transitioning %d -> %d (%s : %d)\n", \
                         (V), (V)->MediaChangeCount, (C), __FILE__, __LINE__));                         \
            (V)->MediaChangeCount = (C);                                                                \
        }
#endif

BOOLEAN
UdfInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDISK_GEOMETRY DiskGeometry,
    IN ULONG MediaChangeCount
    );

VOID
UdfUpdateVcbPhase0 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

VOID
UdfUpdateVcbPhase1 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PNSR_FSD Fsd
    );

VOID
UdfDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

PIRP_CONTEXT
UdfCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
UdfCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    );

VOID
UdfInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    );

//
//  PIRP_CONTEXT_LITE
//  UdfCreateIrpContextLite (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfFreeIrpContextLite (
//      IN PIRP_CONTEXT_LITE IrpContextLite
//      );
//

#define UdfCreateIrpContextLite(IC)  \
    ExAllocatePoolWithTag( UdfNonPagedPool, sizeof( IRP_CONTEXT_LITE ), TAG_IRP_CONTEXT_LITE )

#define UdfFreeIrpContextLite(ICL)  \
    ExFreePool( ICL )

//
//  PUDF_IO_CONTEXT
//  UdfAllocateIoContext (
//      );
//
//  VOID
//  UdfFreeIoContext (
//      PUDF_IO_CONTEXT IoContext
//      );
//

#define UdfAllocateIoContext()                           \
    FsRtlAllocatePoolWithTag( UdfNonPagedPool,           \
                              sizeof( UDF_IO_CONTEXT ),  \
                              TAG_IO_CONTEXT )

#define UdfFreeIoContext(IO)     ExFreePool( IO )

//
//  VOID
//  UdfIncrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDecrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfIncrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  UdfDecrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  UdfIncrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDecrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define UdfIncrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup += 1;                       \
    (F)->Vcb->VcbCleanup += 1;                  \
}

#define UdfDecrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup -= 1;                       \
    (F)->Vcb->VcbCleanup -= 1;                  \
}

#define UdfIncrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference += (C);                   \
    (F)->FcbUserReference += (UC);              \
    (F)->Vcb->VcbReference += (C);              \
    (F)->Vcb->VcbUserReference += (UC);         \
}

#define UdfDecrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference -= (C);                   \
    (F)->FcbUserReference -= (UC);              \
    (F)->Vcb->VcbReference -= (C);              \
    (F)->Vcb->VcbUserReference -= (UC);         \
}

VOID
UdfTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    IN BOOLEAN Recursive,
    OUT PBOOLEAN RemovedStartingFcb
    );

PFCB
UdfLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    );

PFCB
UdfGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

PFCB
UdfCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    );

VOID
UdfDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
UdfInitializeFcbFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB ParentFcb OPTIONAL
    );

PCCB
UdfCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG Flags
    );

VOID
UdfDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

ULONG
UdfFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    );

BOOLEAN
UdfVerifyDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PDESTAG Descriptor,
    IN USHORT Tag,
    IN ULONG Size,
    IN ULONG Lbn,
    IN BOOLEAN ReturnError
    );

VOID
UdfInitializeIcbContextFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB Fcb
    );

VOID
UdfInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PVCB Vcb,
    IN USHORT IcbType,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length
    );

INLINE
VOID
UdfFastInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    )
{

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));
}

VOID
UdfLookupActiveIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG IcbExtentLength
    );


VOID
UdfCleanupIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    );

VOID
UdfInitializeAllocations (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowOneGigWorkaround
    );

VOID
UdfUpdateTimestampsFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PTIMESTAMP_BUNDLE Timestamps
    );

BOOLEAN
UdfCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    );

//
//  The following macro converts from UDF time to NT time.
//

INLINE
VOID
UdfConvertUdfTimeToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN PTIMESTAMP UdfTime,
    OUT PLARGE_INTEGER NtTime
    )
{
    TIME_FIELDS TimeField;
    
    TimeField.Year = UdfTime->Year;
    TimeField.Month = UdfTime->Month;
    TimeField.Day = UdfTime->Day;
    TimeField.Hour = UdfTime->Hour;
    TimeField.Minute = UdfTime->Minute;
    TimeField.Second = UdfTime->Second;
    
    //
    //  This is where it gets hairy.  For some unholy reason, ISO 13346 timestamps
    //  carve the right of the decimal point up into three fields of precision
    //  10-2, 10-4, and 10-6, each ranging from 0-99. Lawdy.
    //
    //  To make it easier, since they cannot cause a wrap into the next second,
    //  just save it all up and add it in after the conversion.
    //
    
    TimeField.Milliseconds = 0; 
    
    if (UdfTime->Type <= 1 &&
        ((UdfTime->Zone >= TIMESTAMP_Z_MIN && UdfTime->Zone <= TIMESTAMP_Z_MAX) ||
         UdfTime->Zone == TIMESTAMP_Z_NONE) &&
        RtlTimeFieldsToTime( &TimeField, NtTime )) {

        //
        //  Now fold in the remaining sub-second "precision".  Read as coversions
        //  through the 10-3 units, then into our 10-7 base. (centi->milli->micro,
        //  etc).
        //
    
        NtTime->QuadPart += ((UdfTime->CentiSecond * (10 * 1000)) +
                             (UdfTime->Usec100 * 100) +
                             UdfTime->Usec) * 10;

        //
        //  Perform TZ normalization if this is a local time with
        //  specified timezone.
        //

        if (UdfTime->Type == 1 && UdfTime->Zone != TIMESTAMP_Z_NONE) {
            
            NtTime->QuadPart += Int32x32To64( -UdfTime->Zone, (60 * 10 * 1000 * 1000) );
        }
    
    } else {

        //
        //  Epoch.  Malformed timestamp.
        //

        NtTime->QuadPart = 0;
    }
}

//
//  An equivalence test for Entity IDs.
//

INLINE
BOOLEAN
UdfEqualEntityId (
    IN PREGID RegID,
    IN PSTRING Id,
    IN OPTIONAL PSTRING Suffix
    )
{

    return (UdfEqualCountedString( Id, RegID->Identifier ) &&

#ifndef UDF_SUPPORT_NONSTANDARD_ENTITY_STRINGTERM
            
            //
            //  Allow disabling of the check that the identifier
            //  seems to be padded with zero.
            //
            //  Reason: a couple samples that are otherwise useful
            //      padded some identifiers with junk.
            //

            ((Id->Length == sizeof(RegID->Identifier) ||
              RegID->Identifier[Id->Length] == '\0') ||
             
             !DebugTrace(( 0, Dbg,
                           "UdfEqualEntityId, RegID seems to be terminated with junk!\n" ))) &&
#endif

            ((Suffix == NULL) || UdfEqualCountedString( Suffix, RegID->Suffix )));
}

BOOLEAN
UdfDomainIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Domain,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax
    );

//
//  In like fashion, we define containment for a UDF Identifier RegID.
//

INLINE
BOOLEAN
UdfUdfIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Type,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax,
    IN UCHAR OSClass,
    IN UCHAR OSIdentifier
    )
{
    PUDF_SUFFIX_UDF UdfSuffix = (PUDF_SUFFIX_UDF) RegID->Suffix;

    return ((UdfSuffix->UdfRevision <= RevisionMax && UdfSuffix->UdfRevision >= RevisionMin) &&
            (OSClass == OSCLASS_INVALID || UdfSuffix->OSClass == OSClass) &&
            (OSIdentifier == OSIDENTIFIER_INVALID || UdfSuffix->OSIdentifier == OSIdentifier) &&
            UdfEqualEntityId( RegID, Type, NULL ));
}


//
//  Verification support routines.  Contained in verfysup.c
//

BOOLEAN
UdfCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    );

BOOLEAN
UdfDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
UdfVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
UdfVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    );

//
//  BOOLEAN
//  UdfIsRawDevice (
//      IN PIRP_CONTEXT IrpContext,
//      IN NTSTATUS Status
//      );
//

#define UdfIsRawDevice(IC,S) (           \
    ((S) == STATUS_DEVICE_NOT_READY) ||  \
    ((S) == STATUS_NO_MEDIA_IN_DEVICE)   \
)


//
//  Volume Mapped Control Blocks routines, implemented in VmcbSup.c
//

VOID
UdfInitializeVmcb (
    IN PVMCB Vmcb,
    IN POOL_TYPE PoolType,
    IN ULONG MaximumLbn,
    IN ULONG LbSize
    );

VOID
UdfUninitializeVmcb (
    IN PVMCB Vmcb
    );

VOID
UdfResetVmcb (
    IN PVMCB Vmcb
    );

VOID
UdfSetMaximumLbnVmcb (
    IN PVMCB Vmcb,
    IN ULONG MaximumLbn
    );

BOOLEAN
UdfVmcbVbnToLbn (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL
    );

BOOLEAN
UdfVmcbLbnToVbn (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    OUT PVBN Vbn,
    OUT PULONG SectorCount OPTIONAL
    );

BOOLEAN
UdfAddVmcbMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount,
    IN BOOLEAN ExactEnd,
    OUT PVBN Vbn,
    OUT PULONG AlignedSectorCount
    );

VOID
UdfRemoveVmcbMapping (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount
    );


//
//  Routines to verify the correspondance of the underlying media, implemented in
//  verfysup.c
//

NTSTATUS
UdfPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    );


INLINE
BOOLEAN
UdfOperationIsDasdOpen(
    IN PIRP_CONTEXT IrpContext
    )
//
//  Return TRUE if this is a DASD open request.
//
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);
    
    return ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->FileName.Length == 0) &&
            (IrpSp->FileObject->RelatedFileObject == NULL));
}


//
//  Some macros for hiding/tracing the device object verify flag.
//

#ifndef UDF_SANITY

#define UdfMarkRealDevForVerify( DO)  SetFlag( (DO)->Flags, DO_VERIFY_VOLUME)
#define UdfMarkRealDevVerifyOk( DO)   ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME)
 
#else

#define UdfMarkRealDevForVerify( DO)  {                                                 \
            DebugTrace((0,UDFS_DEBUG_LEVEL_VERFYSUP,"Mark for verify %p (at %s %d)\n",  \
                        (DO), __FILE__, __LINE__));                                     \
            SetFlag( (DO)->Flags, DO_VERIFY_VOLUME);                                    \
        }

#define UdfMarkRealDevVerifyOk( DO)   {                                                 \
            DebugTrace((0,UDFS_DEBUG_LEVEL_VERFYSUP,"Clear verify %p (at %s %d)\n",     \
                        (DO), __FILE__, __LINE__));                                     \
            ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME);                                  \
        }
#endif

#define UdfRealDevNeedsVerify( DO)   BooleanFlagOn( (DO)->Flags, DO_VERIFY_VOLUME)

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

NTSTATUS
UdfFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  Charspecs are small containers that specify a CS<N> type and a text
//  string specifying a version, etc.  This is a convenient way of bottling
//  up equivalence checks of a charspec.
//

INLINE
BOOLEAN
UdfEqualCharspec (
    IN PCHARSPEC Charspec,
    IN PSTRING Identifier,
    IN UCHAR Type
    )
{
    return ((Charspec->Type == Type) && UdfEqualCountedString( Identifier, Charspec->Info));
}


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
UdfFspDispatch (                            //  implemented in FspDisp.c
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfFspClose (                               //  Implemented in Close.c
    IN PVCB Vcb OPTIONAL
    );

//
//  The following routines are the entry points for the different operations
//  based on the IrpSp major functions.
//

NTSTATUS
UdfCommonCleanup (                          //  Implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonClose (                            //  Implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonCreate (                           //  Implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in DevCtrl.c
UdfCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in DirCtrl.c
UdfCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonFsControl (                        //  Implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in LockCtrl.c
UdfCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in Pnp.c
UdfCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in FileInfo.c
UdfCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in VolInfo.c
UdfCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in Read.c
UdfCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );
    
NTSTATUS
UdfCommonWrite (
    IN PIRP_CONTEXT IrpContext,             //  write.c
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in FileInfo.c
UdfCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfHijackIrpAndFlushDevice (                // flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    );


//  BOOLEAN
//  UdfExtendedFEAllowed(
//      PVCB Vcb
//  )
//
//  Decides,  based on the NSR revision encountered on the volume,  whether or not the 
//  extended FE is legal and expected on this volume

#define UdfExtendedFEAllowed( V)    (VsdIdentNSR03 == (V)->NsrVersion)


//  BOOLEAN
//  UdfMinLegalVATSize(
//      PVCB Vcb
//  )
//
//  Decides based on the NSR revision encountered on the volume

#define UdfMinLegalVATSize( V)  ((VsdIdentNSR03 == (V)->NsrVersion) ? UDF_CDUDF_MINIMUM_20x_VAT_SIZE : UDF_CDUDF_MINIMUM_150_VAT_SIZE)


//  BOOLEAN
//  UdfVATIcbFileTypeExpected(
//      PVCB Vcb
//  )
//
//  Decides, based on the NSR revision encountered on the volume, what value we
//  expect the FileType field in the VAT Icb to have

#define UdfVATIcbFileTypeExpected( V)  ((VsdIdentNSR03 == (V)->NsrVersion) ? ICBTAG_FILE_T_VAT : ICBTAG_FILE_T_NOTSPEC)


//  BOOLEAN
//  UdfVATHasHeaderRecord(
//      PVCB Vcb
//  )
//
//  Decides, based on the NSR revision encountered on the volume, if the VAT should have
//  the header (2.00) record,  or the 1.5 style trailing regid.

#define UdfVATHasHeaderRecord( V)   (VsdIdentNSR03 == (V)->NsrVersion)


//
//  Clean up our internal-to-the-header definitions so they do not leak out.
//

#undef BugCheckFileId
#undef Dbg


#endif // _UDFPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\udfstruc.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    parts of the Udfs file system.

    In-Memory structures:

        The global data structures with the UdfDataRecord.  It contains a pointer
        to a File System Device object and a queue of Vcb's.  There is a Vcb for
        every currently or previously mounted volumes.  We may be in the process
        of tearing down the Vcb's which have been dismounted.  The Vcb's are
        allocated as an extension to a volume device object.

            +---------+
            | UdfData |     +--------+
            |         | --> |FilSysDo|
            |         |     |        |
            |         | <+  +--------+
            +---------+  |
                         |
                         |  +--------+     +--------+
                         |  |VolDo   |     |VolDo   |
                         |  |        |     |        |
                         |  +--------+     +--------+
                         +> |Vcb     | <-> |Vcb     | <-> ...
                            |        |     |        |
                            +--------+     +--------+


        Each Vcb contains a table of all the Fcbs for the volume indexed by
        their FileId.  Each Vcb contains a pointer to the root directory of
        the volume.  Each directory Fcb contains a queue of child Lcb's for
        its children.  Each Lcb is queued onto both its parent and child Fcb.
        There can also be detached subtrees due to open operations by Id where
        the Fcb's are not connected to the root.

        The following diagram shows the root structure.

            +--------+     +--------+
            |  Vcb   |---->| Fcb    |-------------------------------------------------------------------+
            |        |     |  Table |----------------------------------------------------------------+  |
            |        |--+  |        |-------------------------------------------------------------+  |  |
            +--------+  |  +--------+                                                             |  |  |
                        |    |  |  |                                                              |  |  |
                        |    |  |  +---------------------------------------------+                |  |  |
                        |    V  +-----------------------+                        |                |  |  |
                        |  +--------+                   |                        |                |  |  |
                        |  |RootFcb |                   V                        V                |  |  |
                        +->|        |    +-----+    +--------+               +--------+           |  |  |
                           |        |<-->| Lcb |<-->|Child   |    +-----+    |Child   |           |  |  |
                           +--------+    +-----+    | Fcb    |<-->| Lcb |<-->| Fcb    |<--> ...   |  |  |
                                                    |        |    +-----+    |        |           |  |  |
                                                    +--------+               +--------+           |  |  |
                                                                                                  |  |  |
                          (Freestanding sub-tree)                                                 |  |  |
                          +--------+                                                              |  |  |
                          |OpenById|<-------------------------------------------------------------+  |  |
                          | Dir    |    +--------+                                                   |  |
                          |        |--->|OpenById|<--------------------------------------------------+  |
                          +--------+    | Child  |    +--------+                                        |
                                        |  Dir   |--->|OpenById|<---------------------------------------+
                                        +--------+    | Child  |
                                                      |  File  |
                                                      +--------+

        Attached to each Directory Fcb is an prefix table containing the
        Lcbs pointing to children of this directory for which there is an Fcb.

            +--------+      +--------+
            |  Dir   |      | Prefix |
            |   Fcb  |----->|  Table |--------------------+
            |        |      |        |-------+            |
            +--------+      +--------+       |            |
                ^              |             |            |
                |              |             |            |
                |              V             V            V
                |           +--------+    +--------+    +--------+
                |           |  Lcb   |    |  Lcb   |    |  Lcb   |
                +---------->|        |<-->|        |<-->|        |
                            +--------+    +--------+    +--------+

        Each file object open on a UDF volume contains two context pointers.  The
        first will point back to the Fcb for the file object.  The second, if present,
        points to a Ccb (ContextControlBlock) which contains the per-handle information.
        This includes the state of any directory enumeration and the Lcb used to open
        this file object.

          +--------+       +--------+    +--------+
          |  Fcb   |<------| File   |    |  Ccb   |
          |        |       |  Object|--->|        |
          |        |       |        |    |        |
          +--------+       +--------+    +--------+
            ^    ^
            |    |         +--------+    +--------+
            |    |         | File   |    |  Ccb   |
            |    +---------|  Object|--->|        |
            |              |        |    |        |
            |              +--------+    +--------+
            |
            |              +--------+
            |              |Stream  |
            +--------------| File   |
                           |  Object|
                           +--------+


    Synchronization:

        1. A resource in the UdfData synchronizes access to the Vcb queue.  This
            is used during mount/verify/dismount operations.

        2. A resource in the Vcb is used to synchronize access to Vcb for
            open/close operations.  Typically acquired shared, it
            is acquired exclusively to lock out these operations.

        3. A second resource in the Vcb is used to synchronize all file operations.
            Typically acquired shared, it is acquired exclusively to lock
            out all file operations.  Acquiring both Vcb resources will lock
            the entire volume.

        4. A resource in the nonpaged Fcb will synchronize open/close operations
            on an Fcb.

        5. A fast mutex in the Vcb will protect access to the Fcb table and
            the open counts in the Vcb.  It is also used to modify the reference
            counts in all Fcbs/Lcbs.  This mutex cannot be acquired
            exclusely and is an end resource.

        6. A fast mutex in the Fcb will synchronize access to all Fcb fields
            which aren't synchronized in some other way.  A thread may acquire
            mutexes for multiple Fcb's as long as it works it way toward the
            root of the tree.  This mutex can also be acquired recursively.

        7. Normal locking order is UdfData/Vcb/Fcb starting at any point in this
            chain.  The Vcb is required prior to acquiring resources for multiple
            files.  Shared ownership of the Vcb is sufficient in this case.

        8. Normal locking order when acquiring multiple Fcb's is from some
            starting Fcb and walking towards the root of tree.  Create typically
            walks down the tree.  In this case we will attempt to acquire the
            next node optimistically and if that fails we will reference
            the current node in the tree, release it and acquire the next node.
            At that point it will be safe to reacquire the parent node.

        9. Locking order for the Fcb (via the fast mutex) will be from leaf of
            tree back towards the root.  No other resource may be acquired
            after locking the Vcb (other than in-page reads).

       10. Cleanup operations only lock the Vcb and Fcb long enough to change the
            critical counts and share access fields.  No reason to synchronize
            otherwise.  None of the structures can go away from beneath us
            in this case.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     31-May-1996
    
Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#ifndef _UDFSTRUC_
#define _UDFSTRUC_

typedef PVOID PBCB;


//
//  The following structure is used to encapsulate the converted timestamps for
//  straightforward referencing.
//

typedef struct _TIMESTAMP_BUNDLE {

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   AccessTime;
    LARGE_INTEGER   ModificationTime;

} TIMESTAMP_BUNDLE, *PTIMESTAMP_BUNDLE;


//
//  Stack snapshot stuff.
//

typedef struct _STACK_SNAP {

    PVOID BufferPage;
    ULONG Mj;
    ULONG Mn;
    NTSTATUS ExceptionCode;
    ULONG_PTR StackLow;
    ULONG_PTR StackHigh;
    PETHREAD Thread;
    
} STACK_SNAP, *PSTACK_SNAP;

#define UDF_IRPCONTEXT_BACKTRACE_DEPTH 32


//
//  The UDF_DATA record is the top record in the UDF file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

#define NUMBER_OF_FS_OBJECTS    2

typedef struct _UDF_DATA {

    //
    //  The type and size of this record (must be UDFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Vcb queue.
    //

    LIST_ENTRY VcbQueue;

    //
    //  The following fields are used to allocate IRP context structures
    //  using a lookaside list, and other fixed sized structures from a
    //  small cache.  We use the CdData mutex to protext these structures.
    //

    ULONG IrpContextDepth;
    ULONG IrpContextMaxDepth;
    SINGLE_LIST_ENTRY IrpContextList;

    //
    //  Filesystem device objects for UDFS.
    //

    PDEVICE_OBJECT FileSystemDeviceObjects[NUMBER_OF_FS_OBJECTS];

    //
    //  Following are used to manage the async and delayed close queue.
    //
    //  FspCloseActive - Indicates whether there is a thread processing the
    //      two close queues.
    //  ReduceDelayedClose - Indicates that we have hit the upper threshold
    //      for the delayed close queue and need to reduce it to lower threshold.
    //
    //  AsyncCloseQueue - Queue of IrpContext waiting for async close operation.
    //  AsyncCloseCount - Number of entries on the async close queue.
    //
    //  DelayedCloseQueue - Queue of IrpContextLite waiting for delayed close
    //      operation.
    //  MaxDelayedCloseCount - Trigger delay close work at this threshold.
    //  MinDelayedCloseCount - Turn off delay close work at this threshold.
    //  DelayedCloseCount - Number of entries on the delayted close queue.
    //
    //  CloseItem - Workqueue item used to start FspClose thread.
    //

    LIST_ENTRY AsyncCloseQueue;
    ULONG AsyncCloseCount;
    BOOLEAN FspCloseActive;
    BOOLEAN ReduceDelayedClose;
    USHORT PadUshort;

    //
    //  The following fields describe the deferred close file objects.
    //

    LIST_ENTRY DelayedCloseQueue;
    ULONG DelayedCloseCount;
    ULONG MaxDelayedCloseCount;
    ULONG MinDelayedCloseCount;

    //
    //  Fast mutex used to lock the fields of this structure.
    //

    PVOID UdfDataLockThread;
    FAST_MUTEX UdfDataMutex;

    //
    //  A resource variable to control access to the global UDFS data record
    //

    ERESOURCE DataResource;

    //
    //  Cache manager call back structure, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM CloseItem;

#ifdef UDF_CAPTURE_BACKTRACES

    //
    //  Information captured from the 2 most recent exceptions filtered.
    //

    STACK_SNAP A;
    STACK_SNAP B;

    BOOLEAN CurrentSnapIsA;
    
    FAST_MUTEX ExceptionInfoMutex;

#endif

} UDF_DATA, *PUDF_DATA;


//
//  A PARTITION will record the VSN/LSN -> PSN retrieval information for a
//  partition reference.  Since we do not support multi-volume 13346/UDF,
//  we will omit noting the volume sequence number that would tell us which
//  piece of media contained the partition.
//
//  There are currently three types of partitions used during operation: physical,
//  sparable and virtual.  However, since sparing merely adds another last layer
//  of quick indirection, we consider them as a minor extension of a physical
//  partition.
//

typedef enum _PARTITION_TYPE {
    Uninitialized,
    Physical,
    Virtual
} PARTITION_TYPE, *PPARTITION_TYPE;

//
//  A Physical partition corresponds to a single extent of the volume.
//

typedef struct _PARTITION_PHYSICAL {

    //
    //  Starting Psn and length in sectors
    //

    ULONG Start;
    ULONG Length;

    //
    //  The partition number is specified by the LVD, and refers to
    //  a specific partition descriptor on the media.  We use this
    //  in the second pass of partition discovery.
    //

    ULONG PartitionNumber;
    PNSR_PART PartitionDescriptor;

    //
    //  Spared partition map, saved temporarily between
    //  logical volume descriptor analysis and partition
    //  descriptor discover/pcb completion.
    //

    PPARTMAP_SPARABLE SparingMap;

} PARTITION_PHYSICAL, *PPARTITION_PHYSICAL;

//
//  A Virtual partition is a remapping from VSN to LSN on a given Physical
//  partition.  The remapping is done through the VAT FCB.
//

typedef struct _PARTITION_VIRTUAL{

    //
    //  The maximum Vbn in the virtual partition.
    //

    ULONG Length;
    
    //
    //  A virtual partition refers to its "host" physical partition by partition
    //  number, which we translate to a partition reference during the second pass
    //  of partition discovery.
    //
    //  Example: if the virtual partition is reference 1, hosted on partition 156
    //  (which is reference 0 for this logical volume), then NSRLBA 100/1 would
    //  refer to the block on partition ref 0 as mapped in the VAT at entry 100.
    //

    USHORT RelatedReference;

} PARTITION_VIRTUAL, *PPARTITION_VIRTUAL;
        
//
//  There is exactly one PARTITION per partition.  It is responsible for mapping
//  from some form of logical sector to a physical sector.
//

typedef struct _UDF_PARTITION {

    //
    //  This is the type of partition.
    //

    PARTITION_TYPE Type;

    union {

        PARTITION_PHYSICAL Physical;
        PARTITION_VIRTUAL Virtual;
    };

} UDF_PARTITION, *PUDF_PARTITION;

//
//  The Pcb (Partition control block) record corresponds to the partitions
//  which collectively form the mounted volume.  Exactly one of these is
//  linked off of the Vcb.
//

typedef struct _PCB {

    //
    //  The type and size of this record (must be UDFS_NTC_PCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This is the number of partitions in the map
    //

    USHORT Partitions;

    //
    //  A bitmask of flags.
    //

    USHORT Flags;

    //
    //  Sparing Mcb, if this volume has sparing.
    //

    PLARGE_MCB SparingMcb;

    //
    //  This is the mapping table.  A PCB will be dynamically sized
    //  according to the number of partitions forming the volume.
    //

    UDF_PARTITION Partition[0];

} PCB, *PPCB;

//
//  Indicate what kinds of partitions are contained for quick checks.
//

#define PCB_FLAG_PHYSICAL_PARTITION     0x0001
#define PCB_FLAG_VIRTUAL_PARTITION      0x0002
#define PCB_FLAG_SPARABLE_PARTITION     0x0004


//
//  The Vmcb structure is a double mapped structure for mapping
//  between VBNs and LBNs using the MCB structures.  The whole structure
//  is also protected by a private mutex.  This record must be allocated
//  from non-paged pool.
//

//
//  We use an #if to snip out historical code in the Vmcb package that
//  dealt with write issues, leaving it for the future.
//

#define VMCB_WRITE_SUPPORT 0

typedef struct _VMCB {

    //
    //  The type and size of this record (must be UDFS_NTC_VMCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    ERESOURCE Resource;

    MCB VbnIndexed;     // maps VBNs to LBNs
    MCB LbnIndexed;     // maps LBNs to VBNs

    ULONG MaximumLbn;

    ULONG SectorSize;

} VMCB, *PVMCB;

#define UDF_INVALID_VSN -1

//
//  The Vcb (Volume control block) record corresponds to every
//  volume mounted by the file system.  They are ordered in a queue off
//  of UdfData.VcbQueue.
//
//  The Vcb will be in several conditions during its lifespan.
//
//      NotMounted - Disk is not currently mounted (i.e. removed
//          from system) but cleanup and close operations are
//          supported.
//
//      MountInProgress - State of the Vcb from the time it is
//          created until it is successfully mounted or the mount
//          fails.
//
//      Mounted - Volume is currently in the mounted state.
//
//      Invalid - User has invalidated the volume.  Only legal operations
//          are cleanup and close.
//
//      DismountInProgress - We have begun the process of tearing down the
//          Vcb.  It can be deleted when all the references to it
//          have gone away.
//

typedef enum _VCB_CONDITION {

    VcbNotMounted = 0,
    VcbMountInProgress,
    VcbMounted,
    VcbInvalid,
    VcbDismountInProgress

} VCB_CONDITION;

typedef struct _VCB {

    //
    //  The type and size of this record (must be UDFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Vpb for this volume.
    //

    PVPB Vpb;

    //
    //  Pcb for this volume.
    //

    PPCB Pcb;

    //
    //  Device object for the driver below us.
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  Link into queue of Vcb's in the UdfData structure.  We will create a union with
    //  a LONGLONG to force the Vcb to be quad-aligned.
    //

    union {

        LIST_ENTRY VcbLinks;
        LONGLONG Alignment;
    };

    //
    //  State flags and condition for the Vcb.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  File object used to lock the volume.
    //

    PFILE_OBJECT VolumeLockFileObject;

    //
    //  Media change count from device driver for bulletproof detection
    //  of media movement
    //

    ULONG MediaChangeCount;

    //
    //  Logical block size for this volume.
    //

    ULONG SectorSize;

    //
    //  Associated shift size
    //

    ULONG SectorShift;

    //
    //  LSN of the bounds that CD-UDF defines.
    //
    //  S - start of the session that contains the AVD @ +256
    //  N - end of the disc, another chance to find AVD @ -256,
    //      and discovery of the VAT ICB.
    //
    //  N may be unset until late in the mount sequence for a volume, since
    //  the device may not respond to CD-style TOC requests, and only then
    //  be a guess based on the partitons we find. S will be zero except in
    //  the case of CD-UDF.  In a mounted system, S will correspond to where
    //  we started finding the volume descriptors that let us proceed.
    //

    ULONG BoundS;
    ULONG BoundN;

    //
    //  Various counts for this Vcb.
    //
    //      VcbCleanup - Open handles left on this system.
    //      VcbReference - Number of reasons this Vcb is still present.
    //      VcbUserReference - Number of user file objects still present.
    //

    ULONG VcbCleanup;
    ULONG VcbReference;
    ULONG VcbUserReference;

    //
    //  These are the number of times a mounted Vcb will be referenced on behalf
    //  of the system.  See commentary in udfdata.h.
    //

    ULONG VcbResidualReference;
    ULONG VcbResidualUserReference;

    //
    //  Fcb for the Volume Dasd file, root directory and the Vmcb-mapped Metadata stream.
    //  The VAT Fcb is only created on CD UDF media, for the Virtual Allocation Table.
    //

    struct _FCB *VolumeDasdFcb;
    struct _FCB *RootIndexFcb;
    struct _FCB *MetadataFcb;
    struct _FCB *VatFcb;

    //
    //  Offset from the beginning of the VAT stream to the first entry (UDF 2.0x has a header
    //  at the beginning of the VAT),  and number of entries in the VAT.
    //
    
    ULONG OffsetToFirstVATEntry;
    ULONG VATEntryCount;
    
    //
    //  Vmcb for the metadata stream
    //

    VMCB Vmcb;
    
    //
    //  Vmcb resource.  This is used to synchronize mapping/purge operations on
    //  the vmcb stream.  Must be acquired shared around any map/unpin or ccread 
    //  on the vmcb,  and exclusive for ccpurge.  All mappings made in the current
    //  thread must be dropped before attempting to acquire exclusive.
    //

    ERESOURCE VmcbMappingResource;
    
    //
    //  Vcb resource.  This is used to synchronize open/cleanup/close operations.
    //

    ERESOURCE VcbResource;

    //
    //  File resource.  This is used to synchronize all file operations except
    //  open/cleanup/close.
    //

    ERESOURCE FileResource;

    //
    //  Vcb fast mutex.  This is used to synchronize the fields in the Vcb
    //  when modified when the Vcb is not held exclusively.  Included here
    //  are the count fields and Fcb table.
    //
    //  We also use this to synchronize changes to the Fcb reference field.
    //

    FAST_MUTEX VcbMutex;
    PVOID VcbLockThread;

    //
    //  The following is used to synchronize the dir notify package.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  Fcb table.  Synchronized with the Vcb fast mutex.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  Preallocated VPB for swapout, so we are not forced to consider
    //  must succeed pool.
    //

    PVPB SwapVpb;

    //
    //  Information telling us what version of UDF we expect this disc to
    //  conform to.  NsrVersion will be one of VsdIdentNSR02 or VsdIdentNSR03
    //  UdfXXXRead will be one of UDF_VERSION_XXX.
    //
    
    USHORT  NsrVersion;
    USHORT  UdfRevision;

} VCB, *PVCB;

#define VCB_STATE_LOCKED                            (0x00000001)
#define VCB_STATE_REMOVABLE_MEDIA                   (0x00000002)
#define VCB_STATE_NOTIFY_REMOUNT                    (0x00000004)
#define VCB_STATE_METHOD_2_FIXUP                    (0x00000008)
#define VCB_STATE_VMCB_INIT                         (0x00000010)
#define VCB_STATE_VPB_NOT_ON_DEVICE                 (0x00000020)

#define UDF_NSR_NO_VRS_FOUND 0xffff

//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT, *PVOLUME_DEVICE_OBJECT;


//
//  Udfs file id is a large integer. This corresponds to the FileInternalInformation
//  query type and is used for internal FCB indexing.
//

typedef LARGE_INTEGER                   FILE_ID, *PFILE_ID;


//
//  Lcb (Link Control Block), which corresponds to a link from a directory (or in
//  the future, other container objects) to a file (UDF File Identifier).  There is
//  one of these for each name tuple in a prefix table.
//

typedef struct _LCB {

    //
    //  Type and size of this record (must be UDFS_NTC_LCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Pointer to the Parent Fcb for this entry and queue for Parent to
    //  find all referencing Lcbs.  Corresponds to Fcb->ChildLcbQueue.
    //

    LIST_ENTRY ParentFcbLinks;
    struct _FCB *ParentFcb;

    //
    //  Pointer to Child (referenced) Fcb for this entry and queue for Child
    //  to find all referencing Lcbs.  Corresponds to Fcb->ParentLcbQueue.
    //

    LIST_ENTRY ChildFcbLinks;
    struct _FCB *ChildFcb;

    //
    //  Number of extra realtime references made to this Lcb.
    //

    ULONG Reference;

    //
    //  Flags indicating the state of this Lcb.
    //

    ULONG Flags;

    //
    //  File attributes to be merged with the child Fcb.  UDF seperates interesting
    //  information into the FID and FE so, properly, the name link (corresponding to
    //  a FID) must record some extra information.
    //

    ULONG FileAttributes;

    //
    //  Splay links in the prefix tree.
    //
    
    RTL_SPLAY_LINKS Links;

    //
    //  The name of this link.
    //

    UNICODE_STRING FileName;

} LCB, *PLCB;

#define LCB_FLAG_IGNORE_CASE        0x00000001
#define LCB_FLAG_SHORT_NAME         0x00000002
#define LCB_FLAG_POOL_ALLOCATED     0x00000004

//
//  We build a lookaside of Lcb capable of holding a reasonably sized name.
//

#define SIZEOF_LOOKASIDE_LCB        ( sizeof( LCB ) + ( sizeof( WCHAR ) * 16 ))


//
//  The following two structures are the separate union structures for
//  data and index Fcb's.
//

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

typedef struct _FCB_NONPAGED {

    //
    //  Type and size of this record must be UDFS_NTC_FCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  This is the resource structure for this Fcb.
    //

    ERESOURCE FcbResource;

    //
    //  This is the FastMutex for this Fcb.
    //

    FAST_MUTEX FcbMutex;

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} FCB_NONPAGED;
typedef FCB_NONPAGED *PFCB_NONPAGED;

typedef struct _FCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //  A file lock is allocated as needed.
    //

    PFILE_LOCK FileLock;

} FCB_DATA, *PFCB_DATA;

typedef struct _FCB_INDEX {

    //
    //  Internal stream file for the directory.
    //

    PFILE_OBJECT FileObject;

    //
    //  Root of splay trees for exact and ignore case prefix trees.
    //

    PRTL_SPLAY_LINKS ExactCaseRoot;
    PRTL_SPLAY_LINKS IgnoreCaseRoot;

} FCB_INDEX, *PFCB_INDEX;

//
//  The Fcb/Dcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//

typedef struct _FCB_CORE {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //
    //  Node type codes for the Fcb must be one of the following.
    //
    //      UDFS_NTC_FCB_INDEX
    //      UDFS_NTC_FCB_DATA
    //

    //
    //  Common Fsrtl Header.  The named header is for the fieldoff.c output.  We
    //  use the unnamed header internally.
    //

    union {

        FSRTL_ADVANCED_FCB_HEADER Header;
        FSRTL_ADVANCED_FCB_HEADER;
    };

    //
    //  Vcb for this Fcb.
    //

    PVCB Vcb;

    //
    //  Queues of Lcbs that are on this Fcb: Parent - edges that lead in
    //                                       Child  - edges that lead out
    //
    //  We anticipate supporting the streaming extension to UDF 2.0, so we
    //  leave the ChildLcbQueue here which in the case of a stream-rich file
    //  will contain a solitary Lcb leading to the stream directory.
    //

    LIST_ENTRY ParentLcbQueue;
    LIST_ENTRY ChildLcbQueue;

    //
    //  Length of Root ICB Extent for this object.  Coupled with the information
    //  in the FileId, this will allow discovery of the active File Entry for this
    //  Fcb at any time.
    //

    ULONG RootExtentLength;

    //
    //  FileId for this file.
    //

    FILE_ID FileId;

    //
    //  Counts on this Fcb.  Cleanup count represents the number of open handles
    //  on this Fcb.  Reference count represents the number of reasons this Fcb
    //  is still present.  It includes file objects, children Fcb and anyone
    //  who wants to prevent this Fcb from going away.  Cleanup count is synchronized
    //  with the FcbResource.  The reference count is synchronized with the
    //  VcbMutex.
    //

    ULONG FcbCleanup;
    ULONG FcbReference;
    ULONG FcbUserReference;

    //
    //  State flags for this Fcb.
    //

    ULONG FcbState;

    //
    //  NT style attributes for the Fcb.
    //

    ULONG FileAttributes;

    //
    //  This is the thread and count for the thread which has locked this
    //  Fcb.
    //

    PVOID FcbLockThread;
    ULONG FcbLockCount;

    //
    //  Information for Lsn->Psn mapping.  If the file data is embedded, we have a
    //  lookup into the metadata stream for the single logical block and an offset
    //  of the data within that block.  If the file data is is external, we have a
    //  regular Mapping Control Block.
    //
    //  Metadata structures are mapped through the volume-level Metadata Fcb which
    //  uses the volume's VMCB.
    //

    union {
        
        LARGE_MCB Mcb;

        struct EMBEDDED_MAPPING {
            
            ULONG EmbeddedVsn;
            ULONG EmbeddedOffset;
        };
    };

    //
    //  This is the nonpaged data for the Fcb
    //

    PFCB_NONPAGED FcbNonpaged;

    //
    //  Share access structure.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  We cache a few fields from the FE so that various operations do not have to
    //  hit the disk (query, etc.).
    //
    
    //
    //  Time stamps for this file.
    //

    TIMESTAMP_BUNDLE Timestamps;

    //
    //  Link count on this file.
    //

    USHORT LinkCount;

    //
    //  Icb.Icbtag.Filetype
    //

    UCHAR UdfIcbFileType;
} FCB_CORE, *PFCB_CORE;


//
//  Split the Fcb into Core / Type specific structures,  for the benefit of debugger
//  extensions. which try and read the largest possible size of a union...
//

typedef struct _FCB  {

    FCB_CORE;

    union {

        ULONG FcbType;
        FCB_INDEX;
        FCB_DATA;
    };

} FCB, *PFCB;


#define FCB_STATE_INITIALIZED                   (0x00000001)
#define FCB_STATE_IN_FCB_TABLE                  (0x00000002)
#define FCB_STATE_VMCB_MAPPING                  (0x00000004)
#define FCB_STATE_EMBEDDED_DATA                 (0x00000008)
#define FCB_STATE_MCB_INITIALIZED               (0x00000010)
#define FCB_STATE_ALLOW_ONEGIG_WORKAROUND       (0x00000020)

#define SIZEOF_FCB_DATA              \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_DATA ))

#define SIZEOF_FCB_INDEX             \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_INDEX ))


//
//  The Ccb record is allocated for every user file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be UDFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Flags.  Indicates flags to apply for the current open.
    //

    ULONG Flags;

    //
    //  Fcb for the file being opened.
    //

    PFCB Fcb;

    //
    //  Lcb for the file being opened.
    //

    PLCB Lcb;

    //
    //  We store state information in the Ccb for a directory
    //  enumeration on this handle.
    //

    //
    //  Offset in the virtual directory stream to base the next enumeration.
    //
    //  A small number (in fact, possibly one) of file indices are reserved for
    //  synthesized directory entries (like '.'). Past that point, CurrentFileIndex -
    //  UDF_MAX_SYNTHESIZED_FILEINDEX is a byte offset in the stream.
    //

    LONGLONG CurrentFileIndex;
    UNICODE_STRING SearchExpression;

    //
    //  Highest ULONG-representable FileIndex so far found in the directory stream.
    //  This corresponds to the highest FileIndex returnable in a query structure.
    //

    ULONG HighestReturnableFileIndex;

} CCB, *PCCB;

#define CCB_FLAG_OPEN_BY_ID                     (0x00000001)
#define CCB_FLAG_OPEN_RELATIVE_BY_ID            (0x00000002)
#define CCB_FLAG_IGNORE_CASE                    (0x00000004)
#define CCB_FLAG_DISMOUNT_ON_CLOSE              (0x00000008)
#define CCB_FLAG_ALLOW_EXTENDED_DASD_IO         (0x00000010)

//
//  Following flags refer to index enumeration.
//

#define CCB_FLAG_ENUM_NAME_EXP_HAS_WILD         (0x00010000)
#define CCB_FLAG_ENUM_MATCH_ALL                 (0x00020000)
#define CCB_FLAG_ENUM_RETURN_NEXT               (0x00040000)
#define CCB_FLAG_ENUM_INITIALIZED               (0x00080000)
#define CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY    (0x00100000)

//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the UdfComplete
//  request routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Originating Irp for the request.
    //

    PIRP Irp;

    //
    //  Vcb for this operation.  When this is NULL it means we were called
    //  with our filesystem device object instead of a volume device object.
    //  (Mount will fill this in once the Vcb is created)
    //

    PVCB Vcb;

    //
    //  Exception encountered during the request.  Any error raised explicitly by
    //  the file system will be stored here.  Any other error raised by the system
    //  is stored here after normalizing it.
    //

    NTSTATUS ExceptionStatus;
    ULONG RaisedAtFileLine;

    //
    //  Flags for this request.
    //

    ULONG Flags;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Io context for a read request.
    //  Address of Fcb for teardown oplock in create case.
    //

    union {

        struct _UDF_IO_CONTEXT *IoContext;
        PFCB *TeardownFcb;
    };

    //
    //  Top level irp context for this thread.
    //

    struct _IRP_CONTEXT *TopLevel;

    //
    //  Major and minor function codes.
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Pointer to the top-level context if this IrpContext is responsible
    //  for cleaning it up.
    //

    struct _THREAD_CONTEXT *ThreadContext;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

} IRP_CONTEXT, *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_ON_STACK               (0x00000001)
#define IRP_CONTEXT_FLAG_MORE_PROCESSING        (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT                   (0x00000004)
#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000008)
#define IRP_CONTEXT_FLAG_TOP_LEVEL              (0x00000010)
#define IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS         (0x00000020)
#define IRP_CONTEXT_FLAG_IN_FSP                 (0x00000040)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN            (0x00000080)
#define IRP_CONTEXT_FLAG_ALLOC_IO               (0x00000100)
#define IRP_CONTEXT_FLAG_DISABLE_POPUPS         (0x00000200)
#define IRP_CONTEXT_FLAG_FORCE_VERIFY           (0x00000400)

//
//  Flags used for create.
//

#define IRP_CONTEXT_FLAG_FULL_NAME              (0x10000000)
#define IRP_CONTEXT_FLAG_TRAIL_BACKSLASH        (0x20000000)

//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST (   \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_FORCE_POST         |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP             |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY (  \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags are set each time through the Fsp loop.
//

#define IRP_CONTEXT_FSP_FLAGS (             \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP                 \
)


//
//  Following structure is used to queue a request to the delayed close queue.
//  This structure should be the minimum block allocation size.
//

typedef struct _IRP_CONTEXT_LITE {

    //
    //  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT_LITE)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Fcb for the file object being closed.
    //

    PFCB Fcb;

    //
    //  List entry to attach to delayed close queue.
    //

    LIST_ENTRY DelayedCloseLinks;

    //
    //  User reference count for the file object being closed.
    //

    ULONG UserReference;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

} IRP_CONTEXT_LITE, *PIRP_CONTEXT_LITE;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the ReadMultiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _UDF_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    NTSTATUS Status;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;
        };

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;
    };

} UDF_IO_CONTEXT, *PUDF_IO_CONTEXT;


//
//  Following structure is used to track the top level request.  Each Udfs
//  Fsd and Fsp entry point will examine the top level irp location in the
//  thread local storage to determine if this request is top level and/or
//  top level Udfs.  The top level Udfs request will remember the previous
//  value and update that location with a stack location.  This location
//  can be accessed by recursive Udfs entry points.
//

typedef struct _THREAD_CONTEXT {

    //
    //  UDFS signature.  Used to confirm structure on stack is valid.
    //

    ULONG Udfs;

    //
    //  Previous value in top-level thread location.  We restore this
    //  when done.
    //

    PIRP SavedTopLevelIrp;

    //
    //  Top level Udfs IrpContext.  Initial Udfs entry point on stack
    //  will store the IrpContext for the request in this stack location.
    //

    PIRP_CONTEXT TopLevelIrpContext;

} THREAD_CONTEXT, *PTHREAD_CONTEXT;


//
//  Following structure is used to build up static data for parse tables
//

typedef struct _PARSE_KEYVALUE {
    PCHAR Key;
    ULONG Value;
} PARSE_KEYVALUE, *PPARSE_KEYVALUE;


//
//  Some macros for supporting the use of a Generic Table
//  containing all the FCB and indexed by their FileId.
//
//  The ISO 13346 lb_addr of the ICB hierarchy of the object
//
//      { ULONG BlockNo; USHORT PartitionId }
//
//  is encoded in the LowPart (BlockNo) and low 16 bits of the
//  HighPart (PartitionId). The top 16 bits are reserved and are
//  currently used to indicate the type of the object being referenced
//  (file or directory).
//
//  NOTE: this FileId prevents us from being able crack the name of
//  object since an ICB hierarchy's contained direct File Entrys do
//  not (and cannot) contain backpointers to the containing directory.
//  In order to be able to crack paths, we need to be able to do a
//  directory/dirent offset, which cannot fit in 64bits of FileId.
//  A FileId must be 64bits since we export this in the FileInternalInforation
//  query.
//
//  Also, even through we are restricted to a single partition in this
//  implementation, getting those "spare" 16bits isn't good enough to let us
//  point directly into a directory's File Identifier. Files and by extension
//  directories can exceed 2^32 bytes/entries.  Once we have pointed at the
//  parent dir, we are out of bits.
//
//  The Id field is a LARGE_INTEGER where the High and Low parts can be
//  accessed separately.
//
//  The following macros are used to access the Fid fields.
//
//      CdQueryFidDirentOffset      - Accesses the Dirent offset field
//      CdQueryFidPathTableNumber   - Accesses the PathTable offset field
//      CdSetFidDirentOffset        - Sets the Dirent offset field
//      CdSetFidPathTableNumber     - Sets the PathTable ordinal field
//      CdFidIsDirectory            - Queries if directory bit is set
//      CdFidSetDirectory           - Sets directory bit
//

#define FID_DIR_MASK  0x80000000        // high order bit means directory.

#define UdfSetFidFromLbAddr(I, LBA)     { (I).LowPart = (LBA).Lbn; \
                                          (I).HighPart = (ULONG) (LBA).Partition; }

#define UdfGetFidLbn(I)                 ((I).LowPart)
#define UdfGetFidPartition(I)           ((USHORT) (((I).HighPart & ~FID_DIR_MASK) & MAXUSHORT))
#define UdfGetFidReservedZero(I)        ((I).HighPart & ~(FID_DIR_MASK|MAXUSHORT))

#define UdfSetFidFile(I)                ClearFlag( (I).HighPart, FID_DIR_MASK )
#define UdfSetFidDirectory(I)           SetFlag( (I).HighPart, FID_DIR_MASK )

#define UdfIsFidFile(I)                 BooleanFlagOff( (I).HighPart, FID_DIR_MASK )
#define UdfIsFidDirectory(I)            BooleanFlagOn( (I).HighPart, FID_DIR_MASK )

#define UdfSetFidFromFidAndFe(I, FID, FE ) {                                                    \
        UdfSetFidFromLbAddr((I), (FID)->Icb.Start);                                             \
        if ((FE) && ((FE)->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY)) {                       \
            UdfSetFidDirectory((I));                                                            \
        }                                                                                       \
}


//
//  Context structures for browsing through structures
//

//
//  A mapped view is a useful bundle to hold information about a physical
//  view of the disk.
//

typedef struct _MAPPED_PVIEW {

    //
    //  A mapped extent and CC control block
    //

    PVOID View;
    PBCB Bcb;

    //
    //  Extent location
    //

    USHORT Partition;
    ULONG Lbn;
    ULONG Length;

    // 
    //  In the case of mappings through the metadata stream,  store the Vsn currently
    //  mapped to the Lbn
    //

    ULONG Vsn; 
    
} MAPPED_PVIEW, *PMAPPED_PVIEW;


//
//  Enumeration contexts for various operations.
//

//
//  The following is used for crawling ICB hierarchies searching
//  for some notion of an active entry.
//

typedef struct _ICB_SEARCH_CONTEXT {

    //
    //  Vcb the search is occuring on.
    //

    PVCB Vcb;

    //
    //  Type of Icb being searched for.
    //

    USHORT IcbType;

    //
    //  The Active is most prevailing ICB so far found.
    //

    MAPPED_PVIEW Active;
    
    //
    //  The current logical block extent being read from the disk.
    //

    MAPPED_PVIEW Current;

} ICB_SEARCH_CONTEXT, *PICB_SEARCH_CONTEXT;

//
//  The following is used for crawling Extended Attributes extending off of
//  a direct ICB
//

typedef enum _EA_SEARCH_TYPE {

    EaEnumBad = 0,
    EaEnumISO,
    EaEnumImplementation,
    EaEnumApplication

} EA_SEARCH_TYPE, *PEA_SEARCH_TYPE;

typedef struct _EA_SEARCH_CONTEXT {

    //
    //  Reference to an elaborated ICB_SEARCH_CONTEXT which gives us a handle
    //  onto a direct ICB to crawl.
    //

    PICB_SEARCH_CONTEXT IcbContext;

    //
    //  The current Ea being looked at.
    //

    PVOID Ea;

    //
    //  Bytes remaining in the EA view
    //

    ULONG Remaining;

    //
    //  EA being searched for.  We only support looking for ISO at this time.
    //

    ULONG EAType;
    USHORT EASubType;

} EA_SEARCH_CONTEXT, *PEA_SEARCH_CONTEXT;

//
//  The following is used to crawl the list of allocation extent descriptors attached
//  to an ICB.
//

typedef struct _ALLOC_ENUM_CONTEXT {

    //
    //  Reference to an elaborated ICB_ENUM_CONTEXT which gives us a handle
    //  onto a direct ICB to crawl.
    //

    PICB_SEARCH_CONTEXT IcbContext;

    //
    //  The current allocation descriptor being looked at.
    //

    PVOID Alloc;

    //
    //  Type of allocation descriptors in this enumeration
    //

    ULONG AllocType;

    //
    //  Bytes remaining in this view.
    //

    ULONG Remaining;

} ALLOC_ENUM_CONTEXT, *PALLOC_ENUM_CONTEXT;

//
//  The following is used to crawl a logical directory.
//

typedef struct _DIR_ENUM_CONTEXT {

    //
    //  The current view in the enumeration.
    //

    PVOID View;
    PBCB Bcb;

    //
    //  Offset of the view from the beginning of the directory.
    //
    
    LARGE_INTEGER BaseOffset;

    //
    //  Length of the view which is valid and the current
    //  offset in it.
    //

    ULONG ViewLength;
    ULONG ViewOffset;

    //
    //  Pointer to the current FID.
    //

    PNSR_FID Fid;

    //
    //  Offset to the next fid from the beginning of the view.
    //
    
    ULONG NextFidOffset;

    //
    //  Flags indicating the state of the enumeration.
    //

    ULONG Flags;

    //
    //  Converted names from the FID. Case name is "case appropriate" for
    //  the operation.
    //

    UNICODE_STRING ObjectName;
    UNICODE_STRING CaseObjectName;

    //
    //  Real object name in pure form (not rendered to NT legal form)
    //

    UNICODE_STRING PureObjectName;

    //
    //  Short name for the object.
    //

    UNICODE_STRING ShortObjectName;

    //
    //  Currently allocated space for the name.  The previous strings are
    //  carved out of this single buffer.
    //

    PVOID NameBuffer;

    //
    //  Size of currently allocated name buffer for the lfn names.
    //

    USHORT AllocLength;

} DIR_ENUM_CONTEXT, *PDIR_ENUM_CONTEXT;

//
//  Flags for noting where in the enumeration we are.
//

#define DIR_CONTEXT_FLAG_SEEN_NONCONSTANT       0x0001
#define DIR_CONTEXT_FLAG_SEEN_PARENT            0x0002

//
//  Flag indicating current Fid was buffered into pool.
//

#define DIR_CONTEXT_FLAG_FID_BUFFERED           0x0004

#endif // _CDSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\verfysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Udfs Verification routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     18-July-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VERFYSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VERFYSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfVerifyFcbOperation)
#pragma alloc_text(PAGE, UdfVerifyVcb)
#endif


NTSTATUS
UdfPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  If the verify is successful then we send the originating
    Irp off to an Ex Worker Thread.  This routine is called from the exception handler.

    No file system resources are held when this routine is called.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        ((IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
         (IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME))) {

        return UdfFsdPostRequest( IrpContext, Irp );
    }

    //
    //  Extract a pointer to the Vcb from the VolumeDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vcb = &CONTAINING_RECORD( IrpSp->DeviceObject,
                              VOLUME_DEVICE_OBJECT,
                              DeviceObject )->Vcb;

    //
    //  Check if the volume still thinks it needs to be verified,
    //  if it doesn't then we can skip doing a verify because someone
    //  else beat us to it. If this is a 'forced' verify then we 
    //  always go through the motions for mount sync. purposes.
    //

    try {

        //
        //  Send down the verify FSCTL.  Note that this is sent to the
        //  currently mounted volume,  which may not be this one.
        //
        //  We will allow Raw to mount this volume if we were doing a
        //  an absolute DASD open.
        //

        Status = IoVerifyVolume( DeviceToVerify, UdfOperationIsDasdOpen(IrpContext));

        //
        //  Acquire the Vcb so we're working with a stable VcbCondition.
        //
        
        UdfAcquireVcbShared( IrpContext, Vcb, FALSE);

        //
        //  If the verify operation completed it will return
        //  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.
        //
        //  If UdfVerifyVolume encountered an error during
        //  processing, it will return that error.  If we got
        //  STATUS_WRONG_VOLUME from the verify, and our volume
        //  is now mounted, commute the status to STATUS_SUCCESS.
        //

        if ((Status == STATUS_WRONG_VOLUME) &&
            (Vcb->VcbCondition == VcbMounted)) {

            Status = STATUS_SUCCESS;
        }
        else if ((STATUS_SUCCESS == Status) && (Vcb->VcbCondition != VcbMounted))  {

            //
            //  If the verify succeeded,  but our volume is not mounted,
            //  then some other volume is on the device. 
            //

            Status = STATUS_WRONG_VOLUME;
        } 

        //
        //  Do a quick unprotected check here.  The routine will do
        //  a safe check.  After here we can release the resource.
        //  Note that if the volume really went away, we will be taking
        //  the Reparse path.
        //

        //
        //  If the device might need to go away then call our dismount routine.
        //

        if (((Vcb->VcbCondition == VcbNotMounted) ||
             (Vcb->VcbCondition == VcbInvalid) ||
             (Vcb->VcbCondition == VcbDismountInProgress)) &&
            (Vcb->VcbReference <= Vcb->VcbResidualReference)) {

            UdfReleaseVcb( IrpContext, Vcb);
            
            UdfAcquireUdfData( IrpContext );
            UdfCheckForDismount( IrpContext, Vcb, FALSE );
            UdfReleaseUdfData( IrpContext );
        }
        else {

            UdfReleaseVcb( IrpContext, Vcb);
        }

        //
        //  If this is a create and the verify succeeded then complete the
        //  request with a REPARSE status.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->RelatedFileObject == NULL) &&
            ((Status == STATUS_SUCCESS) || (Status == STATUS_WRONG_VOLUME))) {

            Irp->IoStatus.Information = IO_REMOUNT;

            UdfCompleteRequest( IrpContext, Irp, STATUS_REPARSE );
            Status = STATUS_REPARSE;
            Irp = NULL;
            IrpContext = NULL;

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Reparsing create irp.\n"));

        //
        //  If there is still an error to process then call the Io system
        //  for a popup.
        //

        } else if ((Irp != NULL) && !NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Raising error %x (Op %x)\n", Status, 
                         IrpContext->MajorFunction));
            //
            //  Fill in the device object if required.
            //

            if (IoIsErrorUserInduced( Status ) ) {

                IoSetHardErrorOrVerifyDevice( Irp, DeviceToVerify );
            }

            //
            //  We should not be receiving this status from verify
            //  volume - we'll end up recursing out of stack.
            //
            
            ASSERT( STATUS_VERIFY_REQUIRED != Status);
           
            UdfNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if (IrpContext != NULL) {

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Posting IRP (Op %x)\n", IrpContext->MajorFunction));

            Status = UdfFsdPostRequest( IrpContext, Irp );
        }

    } except(UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    return Status;
}


BOOLEAN
UdfCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    )

/*++

Routine Description:

    This routine is called to check if a volume is ready for dismount.  This
    occurs when only file system references are left on the volume.

    If the dismount is not currently underway and the user reference count
    has gone to zero then we can begin the dismount.

    If the dismount is in progress and there are no references left on the
    volume (we check the Vpb for outstanding references as well to catch
    any create calls dispatched to the file system) then we can delete
    the Vcb.

Arguments:

    Vcb - Vcb for the volume to try to dismount.
    
    Force - Whether we will force this volume to be dismounted.

Return Value:

    BOOLEAN - True if the Vcb was not gone by the time this function finished,
        False if it was deleted.
        
    This is only a trustworthy indication to the caller if it had the vcb
    exclusive itself.

--*/

{
    BOOLEAN UnlockVcb = TRUE;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  Acquire and lock this Vcb to check the dismount state.
    //

    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Lets get rid of any pending closes for this volume.
    //

    UdfFspClose( Vcb );

    UdfLockVcb( IrpContext, Vcb );

    //
    //  If the dismount is not already underway then check if the
    //  user reference count has gone to zero or we are being forced
    //  to disconnect.  If so start the teardown on the Vcb.
    //

    if (Vcb->VcbCondition != VcbDismountInProgress) {

        if (Vcb->VcbUserReference <= Vcb->VcbResidualUserReference || Force) {

            UdfUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            VcbPresent = UdfDismountVcb( IrpContext, Vcb );
        }

    //
    //  If the teardown is underway and there are absolutely no references
    //  remaining then delete the Vcb.  References here include the
    //  references in the Vcb and Vpb.
    //

    } else if (Vcb->VcbReference == 0) {

        IoAcquireVpbSpinLock( &SavedIrql );

        //
        //  If there are no file objects and no reference counts in the
        //  Vpb we can delete the Vcb.  Don't forget that we have the
        //  last reference in the Vpb.
        //

        if (Vcb->Vpb->ReferenceCount == 1) {

            IoReleaseVpbSpinLock( SavedIrql );
            UdfUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            UdfDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;

        } else {

            IoReleaseVpbSpinLock( SavedIrql );
        }
    }

    //
    //  Unlock the Vcb if still held.
    //

    if (UnlockVcb) {

        UdfUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Release any resources still acquired.
    //

    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    return VcbPresent;
}


BOOLEAN
UdfDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when all of the user references to a volume are
    gone.  We will initiate all of the teardown any system resources.

    If all of the references to this volume are gone at the end of this routine
    then we will complete the teardown of this Vcb and mark the current Vpb
    as not mounted.  Otherwise we will allocated a new Vpb for this device
    and keep the current Vpb attached to the Vcb.

Arguments:

    Vcb - Vcb for the volume to dismount.

Return Value:

    BOOLEAN - TRUE if we didn't delete the Vcb, FALSE otherwise.

--*/

{
    PVPB OldVpb;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    BOOLEAN FinalReference;

    ASSERT_EXCLUSIVE_UDFDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    UdfLockVcb( IrpContext, Vcb );

    //
    //  We should only take this path once.
    //

    ASSERT( Vcb->VcbCondition != VcbDismountInProgress );

    //
    //  Mark the Vcb as DismountInProgress.
    //

    UdfSetVcbCondition( Vcb, VcbDismountInProgress);

    //
    //  Remove our reference to the internal Fcb's.  The Fcb's will then
    //  be removed in the purge path below.
    //

    if (Vcb->RootIndexFcb != NULL) {

        Vcb->RootIndexFcb->FcbReference -= 1;
        Vcb->RootIndexFcb->FcbUserReference -= 1;
    }

    if (Vcb->MetadataFcb != NULL) {

        Vcb->MetadataFcb->FcbReference -= 1;
        Vcb->MetadataFcb->FcbUserReference -= 1;
    }

    if (Vcb->VatFcb != NULL) {

        Vcb->VatFcb->FcbReference -= 1;
        Vcb->VatFcb->FcbUserReference -= 1;
    }

    if (Vcb->VolumeDasdFcb != NULL) {

        Vcb->VolumeDasdFcb->FcbReference -= 1;
        Vcb->VolumeDasdFcb->FcbUserReference -= 1;
    }

    UdfUnlockVcb( IrpContext, Vcb );

    //
    //  Purge the volume.
    //

    UdfPurgeVolume( IrpContext, Vcb, TRUE );

    //
    //  Empty the delayed and async close queues.
    //

    UdfFspClose( Vcb );

    OldVpb = Vcb->Vpb;

    //
    //  Remove the mount volume reference.
    //

    UdfLockVcb( IrpContext, Vcb );
    Vcb->VcbReference -= 1;

    //
    //  Acquire the Vpb spinlock to check for Vpb references.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    //
    //  Remember if this is the last reference on this Vcb.  We incremented
    //  the count on the Vpb earlier so we get one last crack it.  If our
    //  reference has gone to zero but the vpb reference count is greater
    //  than zero then the Io system will be responsible for deleting the
    //  Vpb.
    //

    FinalReference = (BOOLEAN) ((Vcb->VcbReference == 0) &&
                                (OldVpb->ReferenceCount == 1));

    //
    //  There is a reference count in the Vpb and in the Vcb.  We have
    //  incremented the reference count in the Vpb to make sure that
    //  we have last crack at it.  If this is a failed mount then we
    //  want to return the Vpb to the IO system to use for the next
    //  mount request.
    //

    if (OldVpb->RealDevice->Vpb == OldVpb) {

        //
        //  If not the final reference then swap out the Vpb.  We must
        //  preserve the REMOVE_PENDING flag so that the device is
        //  not remounted in the middle of a PnP remove operation.
        //

        if (!FinalReference) {

            ASSERT( Vcb->SwapVpb != NULL );

            Vcb->SwapVpb->Type = IO_TYPE_VPB;
            Vcb->SwapVpb->Size = sizeof( VPB );
            Vcb->SwapVpb->RealDevice = OldVpb->RealDevice;

            Vcb->SwapVpb->RealDevice->Vpb = Vcb->SwapVpb;

            Vcb->SwapVpb->Flags = FlagOn( OldVpb->Flags, VPB_REMOVE_PENDING );
            
            IoReleaseVpbSpinLock( SavedIrql );

            //
            //  Indicate we used up the swap.
            //

            Vcb->SwapVpb = NULL;

            UdfUnlockVcb( IrpContext, Vcb );

        //
        //  We want to leave the Vpb for the IO system.  Mark it
        //  as being not mounted.  Go ahead and delete the Vcb as
        //  well.
        //

        } else {

            //
            //  Make sure to remove the last reference on the Vpb.
            //

            OldVpb->ReferenceCount -= 1;

            OldVpb->DeviceObject = NULL;
            ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

            //
            //  Clear the Vpb flag so we know not to delete it.
            //

            Vcb->Vpb = NULL;

            IoReleaseVpbSpinLock( SavedIrql );
            UdfUnlockVcb( IrpContext, Vcb );
            UdfDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;
        }

    //
    //  Someone has already swapped in a new Vpb.  If this is the final reference
    //  then the file system is responsible for deleting the Vpb.
    //

    } else if (FinalReference) {

        //
        //  Make sure to remove the last reference on the Vpb.
        //

        OldVpb->ReferenceCount -= 1;

        IoReleaseVpbSpinLock( SavedIrql );
        UdfUnlockVcb( IrpContext, Vcb );
        UdfDeleteVcb( IrpContext, Vcb );
        VcbPresent = FALSE;

    //
    //  The current Vpb is no longer the Vpb for the device (the IO system
    //  has already allocated a new one).  We leave our reference in the
    //  Vpb and will be responsible for deleting it at a later time.
    //

    } else {

        IoReleaseVpbSpinLock( SavedIrql );
        UdfUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Let our caller know whether the Vcb is still present.
    //

    return VcbPresent;
}


BOOLEAN
UdfMarkDevForVerifyIfVcbMounted(
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks to see if the specified Vcb is currently mounted on
    the device or not.  If it is,  it sets the verify flag on the device, if
    not then the state is noted in the Vcb.

Arguments:

    Vcb - This is the volume to check.

Return Value:

    TRUE if the device has been marked for verify here,  FALSE otherwise.

--*/
{
    BOOLEAN Marked = FALSE;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql );
    
    if (Vcb->Vpb->RealDevice->Vpb == Vcb->Vpb)  {

        UdfMarkRealDevForVerify( Vcb->Vpb->RealDevice);
        Marked = TRUE;
    }
    else {

        //
        //  Flag this to avoid the VPB spinlock in future passes.
        //
        
        SetFlag( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);
    }
    
    IoReleaseVpbSpinLock( SavedIrql );

    return Marked;
}


VOID
UdfVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks that the current Vcb is valid and currently mounted
    on the device.  It will raise on an error condition.

    We check whether the volume needs verification and the current state
    of the Vcb.

Arguments:

    Vcb - This is the volume to verify.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    ULONG MediaChangeCount = 0;
    BOOLEAN ForceVerify = FALSE;
    BOOLEAN DevMarkedForVerify;
    KIRQL SavedIrql;

    PAGED_CODE();

    DebugTrace((0, Dbg, "UdfVerifyVcb %x (condition %d)\n", IrpContext->MajorFunction, 
                Vcb->VcbCondition));

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        ((Vcb->VcbCondition == VcbDismountInProgress) && 
         (IrpContext->MajorFunction != IRP_MJ_CREATE))) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ))  {
        
        //
        //  Capture the real device verify state.
        //
        
        DevMarkedForVerify = UdfRealDevNeedsVerify( Vcb->Vpb->RealDevice);
        
        //
        //  If the verify volume flag in the device object is not set then we 
        //  want to ping the device to see if it needs to be verified.
        //

        if (Vcb->VcbCondition != VcbMountInProgress) {

            Status = UdfPerformDevIoCtrl( IrpContext,
                                          ( Vcb->Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                            IOCTL_CDROM_CHECK_VERIFY :
                                            IOCTL_DISK_CHECK_VERIFY ),
                                          Vcb->TargetDeviceObject,
                                          NULL,
                                          0,
                                          &MediaChangeCount,
                                          sizeof(ULONG),
                                          FALSE,
                                          FALSE,
                                          &Iosb );

            if (Iosb.Information != sizeof(ULONG)) {
        
                //
                //  Be safe about the count in case the driver didn't fill it in
                //
        
                MediaChangeCount = 0;
            }

            //
            //  There are four cases when we want to do a verify.  These are the
            //  first three.
            //
            //  1. We are mounted,  and the device has become empty
            //  2. The device has returned verify required (=> DO_VERIFY_VOL flag is
            //     set, but could be due to hardware condition)
            //  3. Media change count doesn't match the one in the Vcb
            //

            if (((Vcb->VcbCondition == VcbMounted) &&
                  UdfIsRawDevice( IrpContext, Status ))
                ||
                (Status == STATUS_VERIFY_REQUIRED) 
                ||
                (NT_SUCCESS(Status) &&
                 (Vcb->MediaChangeCount != MediaChangeCount))) {

                //
                //  If we are currently the volume on the device then it is our
                //  responsibility to set the verify flag.  If we're not on the device,
                //  then we shouldn't touch the flag.   
                //

                if (!FlagOn( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE) &&
                    !DevMarkedForVerify)  {

                    DevMarkedForVerify = UdfMarkDevForVerifyIfVcbMounted( Vcb);
                }

                ForceVerify = TRUE;

                DebugTrace((0, Dbg, "Force verify due to dev state.  CV %x Vcb->Mc %d Device->Mc %d\n", 
                            Status, Vcb->MediaChangeCount, MediaChangeCount));

                //
                //  Note that we no longer update the media change count here. We
                //  do so only when we've actually completed a verify at a 
                //  particular change count value.
                //
            } 
        }

        //
        //  This is the 4th verify case.
        //
        //  We ALWAYS force CREATE requests on unmounted volumes through the 
        //  verify path.  These requests could have been in limbo between
        //  IoCheckMountedVpb and us when a verify/mount took place and caused
        //  a completely different fs/volume to be mounted.  In this case the
        //  checks above may not have caught the condition,  since we may already
        //  have verified (wrong volume) and decided that we have nothing to do.
        //  We want the requests to be re routed to the currently mounted volume,
        //  since they were directed at the 'drive',  not our volume.
        //

        if (NT_SUCCESS( Status) && !ForceVerify && 
            (IrpContext->MajorFunction == IRP_MJ_CREATE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);

            ForceVerify = (IrpSp->FileObject->RelatedFileObject == NULL) &&
                          ((Vcb->VcbCondition == VcbDismountInProgress) ||
                           (Vcb->VcbCondition == VcbNotMounted));

            //
            //  Note that we don't touch the device verify flag here.  It required
            //  it would have been caught and set by the first set of checks.
            //
            
            if (ForceVerify)  {
                
                DebugTrace((0, Dbg, "Forcing verify on Create request\n"));                 
            }
        }

        //
        //  Raise any verify / error if neccessary.
        //
        
        if (ForceVerify || !NT_SUCCESS( Status)) {
            
            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          Vcb->Vpb->RealDevice );

            UdfRaiseStatus( IrpContext, ForceVerify ? STATUS_VERIFY_REQUIRED : Status );
        }
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //
    
    switch (Vcb->VcbCondition) {

    case VcbNotMounted:

        IoSetHardErrorOrVerifyDevice( IrpContext->Irp, Vcb->Vpb->RealDevice );
        
        UdfRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        break;

    case VcbInvalid:
    case VcbDismountInProgress :

        UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        break;
    }
}


BOOLEAN
UdfVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to verify that the state of the Fcb is valid
    to allow the current operation to continue.  We use the state of the
    Vcb, target device and type of operation to determine this.

Arguments:

    IrpContext - IrpContext for the request.  If not present then we
        were called from the fast IO path.

    Fcb - Fcb to perform the request on.

Return Value:

    BOOLEAN - TRUE if the request can continue, FALSE otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb = Fcb->Vcb;
    PDEVICE_OBJECT RealDevice = Vcb->Vpb->RealDevice;
    PIRP Irp;

    PAGED_CODE();
    
    //
    //  Check that the fileobject has not been cleaned up.
    //
    
    if ( ARGUMENT_PRESENT( IrpContext ))  {

        PFILE_OBJECT FileObject;

        Irp = IrpContext->Irp;
        FileObject = IoGetCurrentIrpStackLocation( Irp)->FileObject;
        
        if ( FileObject && FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Following FAT,  we allow certain operations even on cleaned up
            //  file objects.  Everything else,  we fail.
            //
            
            if ( (FlagOn(Irp->Flags, IRP_PAGING_IO)) ||
                 (IrpSp->MajorFunction == IRP_MJ_CLOSE ) ||
                 (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                 ( (IrpSp->MajorFunction == IRP_MJ_READ) &&
                   FlagOn(IrpSp->MinorFunction, IRP_MN_COMPLETE) ) ) {

                NOTHING;

            } else {

                UdfRaiseStatus( IrpContext, STATUS_FILE_CLOSED );
            }
        }
    }

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        (Vcb->VcbCondition == VcbDismountInProgress)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        return FALSE;
    }

    //
    //  Always fail if the volume needs to be verified.
    //

    if (UdfRealDevNeedsVerify( RealDevice)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          RealDevice );

            UdfRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED );
        }

        return FALSE;

    //
    //  All operations are allowed on mounted volumes.
    //

    } else if ((Vcb->VcbCondition == VcbMounted) ||
               (Vcb->VcbCondition == VcbMountInProgress)) {

        return TRUE;

    //
    //  Fail all requests for fast Io on other Vcb conditions.
    //

    } else if (!ARGUMENT_PRESENT( IrpContext )) {

        return FALSE;

    //
    //  The remaining case is VcbNotMounted - raise WRONG_VOLUME.
    //

    } else if (Vcb->VcbCondition == VcbNotMounted) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp, RealDevice );
            UdfRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        }

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\vmcbsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VmcbSup.c

Abstract:

    Historical note: this package was originally written for HPFS (pinball)
    and is now resurrected for UDFS.  Since UDFS is readonly in initial
    versions we will snip by #ifdef the write support, leaving it visible
    for the future - this code has not been changed (nearly) whatsoever and
    is left named as Pb (pinball) code.

    The VMCB routines provide support for maintaining a mapping between
    LBNs and VBNs for a virtual volume file.  The volume file is all
    of the sectors that make up the on-disk structures.  A file system
    uses this package to map LBNs for on-disk structure to VBNs in a volume
    file.  This when used in conjunction with Memory Management and the
    Cache Manager will treat the volume file as a simple mapped file.  A
    variable of type VMCB is used to store the mapping information and one
    is needed for every mounted volume.

    The main idea behind this package is to allow the user to dynamically
    read in new disk structure sectors (e.g., File Entries).  The user assigns
    the new sector a VBN in the Volume file and has memory management fault
    the page containing the sector into memory.  To do this Memory management
    will call back into the file system to read the page from the volume file
    passing in the appropriate VBN.  Now the file system takes the VBN and
    maps it back to its LBN and does the read.

    The granularity of mapping is one a per page basis.  That is if
    a mapping for LBN 8 is added to the VMCB structure and the page size
    is 8 sectors then the VMCB routines will actually assign a mapping for
    LBNS 8 through 15, and they will be assigned to a page aligned set of
    VBNS.  This function is needed to allow us to work efficiently with
    memory management.  This means that some sectors in some pages might
    actually contain regular file data and not volume information, and so
    when writing the page out we must only write the sectors that are really
    in use by the volume file.  To help with this we provide a set
    of routines to keep track of dirty volume file sectors.
    That way, when the file system is called to write a page to the volume
    file, it will only write the sectors that are dirty.

    Concurrent access the VMCB structure is control by this package.

    The functions provided in this package are as follows:

      o  UdfInitializeVmcb - Initialize a new VMCB structure.

      o  UdfUninitializeVmcb - Uninitialize an existing VMCB structure.

      o  UdfSetMaximumLbnVmcb - Sets/Resets the maximum allowed LBN
         for the specified VMCB structure.

      o  UdfAddVmcbMapping - This routine takes an LBN and assigns to it
         a VBN.  If the LBN already was assigned to an VBN it simply returns
         the old VBN and does not do a new assignemnt.

      o  UdfRemoveVmcbMapping - This routine takes an LBN and removes its
         mapping from the VMCB structure.

      o  UdfVmcbVbnToLbn - This routine takes a VBN and returns the
         LBN it maps to.

      o  UdfVmcbLbnToVbn - This routine takes an LBN and returns the
         VBN its maps to.

Authors:

    Gary Kimura     [GaryKi]    4-Apr-1990
    Dan Lovinger    [DanLo]     10-Sep-1996

Revision History:

    Tom Jolly       [tomjolly]  21-Jan-2000     CcPurge and extend at end of stream
    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VMCBSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VMCBSUP)

//
//  The following macro is used to calculate the number of pages (in terms of
//  sectors) needed to contain a given sector count.  For example (assuming 
//  1kb sector size,  8kb page size)
//
//      PadSectorCountToPage( 0 Sectors ) = 0 Pages = 0 Sectors
//      PadSectorCountToPage( 1 Sectors ) = 1 Page  = 8 Sectors
//      PadSectorCountToPage( 2 Sectors ) = 1 Page  = 8 Sectors
//      PadSectorCountToPage( 8 ..      ) = 2 Pages = 16 sectors
//
//  Evaluates to the number of 
//

#define PadSectorCountToPage(V, L) ( ( ((L)+((PAGE_SIZE/(V)->SectorSize)-1)) / (PAGE_SIZE/(V)->SectorSize) ) * (PAGE_SIZE/(V)->SectorSize) )

//
//  Evaluates to first page aligned LBN <= Supplied LBN
//

#define AlignToPageBase( V, L) ((L) & ~((PAGE_SIZE / (V)->SectorSize)-1))

//
//  Evaluates to TRUE if the LBN is page aligned,  FALSE otherwise
//

#define IsPageAligned( V, L)   (0 == ((L) & ((PAGE_SIZE / (V)->SectorSize)-1)) )

//
//  Macros for VMCB synchronisation
//

#define VmcbLockForRead( V)  (VOID)ExAcquireResourceSharedLite( &((V)->Resource), TRUE )

#define VmcbLockForModify( V)  (VOID)ExAcquireResourceExclusiveLite( &((V)->Resource), TRUE )

#define VmcbRelease( V)  ExReleaseResourceLite( &((V)->Resource))

//
//  Local Routines.
//

BOOLEAN
UdfVmcbLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAddVmcbMapping)
#pragma alloc_text(PAGE, UdfInitializeVmcb)
#pragma alloc_text(PAGE, UdfRemoveVmcbMapping)
#pragma alloc_text(PAGE, UdfResetVmcb)
#pragma alloc_text(PAGE, UdfSetMaximumLbnVmcb)
#pragma alloc_text(PAGE, UdfUninitializeVmcb)
#pragma alloc_text(PAGE, UdfVmcbLbnToVbn)
#pragma alloc_text(PAGE, UdfVmcbLookupMcbEntry)
#pragma alloc_text(PAGE, UdfVmcbVbnToLbn)
#endif


VOID
UdfInitializeVmcb (
    IN PVMCB Vmcb,
    IN POOL_TYPE PoolType,
    IN ULONG MaximumLbn,
    IN ULONG SectorSize
    )

/*++

Routine Description:

    This routine initializes a new Vmcb Structure.  The caller must
    supply the memory for the structure.  This must precede all other calls
    that set/query the volume file mapping.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    Vmcb - Supplies a pointer to the volume file structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal structures.

    MaximumLbn - Supplies the maximum Lbn value that is valid for this
        volume.

    LbSize - Size of a sector on this volume

Return Value:

    None

--*/

{
    BOOLEAN VbnInitialized;
    BOOLEAN LbnInitialized;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfInitializeVmcb, Vmcb = %08x\n", Vmcb ));

    VbnInitialized = FALSE;
    LbnInitialized = FALSE;

    try {

        //
        //  Initialize the fields in the vmcb structure
        //
        
        FsRtlInitializeMcb( &Vmcb->VbnIndexed, PoolType );
        VbnInitialized = TRUE;

        FsRtlInitializeMcb( &Vmcb->LbnIndexed, PoolType );
        LbnInitialized = TRUE;

        Vmcb->MaximumLbn = MaximumLbn;

        Vmcb->SectorSize = SectorSize;

        Vmcb->NodeTypeCode = UDFS_NTC_VMCB;
        Vmcb->NodeByteSize = sizeof( VMCB);

        ExInitializeResourceLite( &Vmcb->Resource );

    } finally {

        //
        //  If this is an abnormal termination then check if we need to
        //  uninitialize the mcb structures
        //

        if (AbnormalTermination()) {
            
            if (VbnInitialized) { FsRtlUninitializeMcb( &Vmcb->VbnIndexed ); }
            if (LbnInitialized) { FsRtlUninitializeMcb( &Vmcb->LbnIndexed ); }
        }

        DebugUnwind("UdfInitializeVmcb");
        DebugTrace(( -1, Dbg, "UdfInitializeVmcb -> VOID\n" ));
    }
}


VOID
UdfUninitializeVmcb (
    IN PVMCB Vmcb
    )

/*++

Routine Description:

    This routine uninitializes an existing VMCB structure.  After calling
    this routine the input VMCB structure must be re-initialized before
    being used again.

Arguments:

    Vmcb - Supplies a pointer to the VMCB structure to uninitialize.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfUninitializeVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Unitialize the fields in the Vmcb structure
    //

    FsRtlUninitializeMcb( &Vmcb->VbnIndexed );
    FsRtlUninitializeMcb( &Vmcb->LbnIndexed );

    ExDeleteResourceLite( &Vmcb->Resource);

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfUninitializeVmcb -> VOID\n" ));

    return;
}


VOID
UdfResetVmcb (
    IN PVMCB Vmcb
    )

/*++

Routine Description:

    This routine resets the mappings in an existing VMCB structure.

Arguments:

    Vmcb - Supplies a pointer to the VMCB structure to reset.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfResetVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Unitialize the fields in the Vmcb structure
    //

    FsRtlResetLargeMcb( (PLARGE_MCB) &Vmcb->VbnIndexed, TRUE );
    FsRtlResetLargeMcb( (PLARGE_MCB) &Vmcb->LbnIndexed, TRUE );

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfResetVmcb -> VOID\n" ));

    return;
}


VOID
UdfSetMaximumLbnVmcb (
    IN PVMCB Vmcb,
    IN ULONG MaximumLbn
    )

/*++

Routine Description:

    This routine sets/resets the maximum allowed LBN for the specified
    Vmcb structure.  The Vmcb structure must already have been initialized
    by calling UdfInitializeVmcb.

Arguments:

    Vmcb - Supplies a pointer to the volume file structure to initialize.

    MaximumLbn - Supplies the maximum Lbn value that is valid for this
        volume.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfSetMaximumLbnVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Set the field
    //

    Vmcb->MaximumLbn = MaximumLbn;

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfSetMaximumLbnVmcb -> VOID\n" ));

    return;
}


BOOLEAN
UdfVmcbVbnToLbn (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    IN PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL
    )

/*++

Routine Description:

    This routine translates a VBN to an LBN.

Arguments:

    Vmcb - Supplies the VMCB structure being queried.

    Vbn - Supplies the VBN to translate from.

    Lbn - Receives the LBN mapped by the input Vbn.  This value is only valid
        if the function result is TRUE.

    SectorCount - Optionally receives the number of sectors corresponding
        to the run.

Return Value:

    BOOLEAN - TRUE if he Vbn has a valid mapping and FALSE otherwise.

--*/

{
    BOOLEAN Result;

    DebugTrace(( +1, Dbg, "UdfVmcbVbnToLbn, Vbn = %08x\n", Vbn ));

    //
    //  Now grab the resource
    //

    VmcbLockForRead( Vmcb);
    
    try {

        Result = UdfVmcbLookupMcbEntry( &Vmcb->VbnIndexed,
                                        Vbn,
                                        Lbn,
                                        SectorCount,
                                        NULL );

        DebugTrace(( 0, Dbg, "*Lbn = %08x\n", *Lbn ));

        //
        //  If the returned Lbn is greater than the maximum allowed Lbn
        //  then return FALSE
        //

        if (Result && (*Lbn > Vmcb->MaximumLbn)) {

            try_leave( Result = FALSE );
        }

        //
        //  If the last returned Lbn is greater than the maximum allowed Lbn
        //  then bring in the sector count
        //

        if (Result &&
            ARGUMENT_PRESENT(SectorCount) &&
            (*Lbn+*SectorCount-1 > Vmcb->MaximumLbn)) {

            *SectorCount = (Vmcb->MaximumLbn - *Lbn + 1);
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind("UdfVmcbVbnToLbn");
        DebugTrace(( -1, Dbg, "UdfVmcbVbnToLbn -> Result = %08x\n", Result ));
    }


    return Result;
}


BOOLEAN
UdfVmcbLbnToVbn (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    OUT PVBN Vbn,
    OUT PULONG SectorCount OPTIONAL
    )

/*++

Routine Description:

    This routine translates an LBN to a VBN.

Arguments:

    Vmcb - Supplies the VMCB structure being queried.

    Lbn - Supplies the LBN to translate from.

    Vbn - Recieves the VBN mapped by the input LBN.  This value is
        only valid if the function result is TRUE.

    SectorCount - Optionally receives the number of sectors corresponding
        to the run.

Return Value:

    BOOLEAN - TRUE if the mapping is valid and FALSE otherwise.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfVmcbLbnToVbn, Lbn = %08x\n", Lbn ));

    //
    //  If the requested Lbn is greater than the maximum allowed Lbn
    //  then the result is FALSE
    //

    if (Lbn > Vmcb->MaximumLbn) {

        DebugTrace(( -1, Dbg, "Lbn too large, UdfVmcbLbnToVbn -> FALSE\n" ));

        return FALSE;
    }

    //
    //  Now grab the resource
    //

    VmcbLockForRead( Vmcb);
    
    try {

        Result = UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                        Lbn,
                                        Vbn,
                                        SectorCount,
                                        NULL );

        if (Result)  {
        
            DebugTrace(( 0, Dbg, "*Vbn = %08x\n", *Vbn ));
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind("UdfVmcbLbnToVbn");
        DebugTrace(( -1, Dbg, "UdfVmcbLbnToVbn -> Result = %08x\n", Result ));
    }

    return Result;
}


BOOLEAN
UdfAddVmcbMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount,
    IN BOOLEAN ExactEnd,
    OUT PVBN Vbn,
    OUT PULONG AlignedSectorCount
    )

/*++

Routine Description:

    This routine adds a new LBN to VBN mapping to the VMCB structure.  When
    a new LBN is added to the structure it does it only on page aligned
    boundaries.

    If pool is not available to store the information this routine will
    raise a status value indicating insufficient resources.

    May acquire Vcb->VmcbMappingResource EXCLUSIVE if an existing mapping can
    be extended (and hence a purge is necessary),  released before return.  
    
    Caller must have NO active mappings through Vmcb stream before calling this 
    function.

Arguments:

    Vmcb - Supplies the VMCB being updated.

    Lbn - Supplies the starting LBN to add to VMCB.

    SectorCount - Supplies the number of Sectors in the run.  We're only currently expecting 
                  single sector mappings.
    
    ExactEnd - Indicates that instead of aligning to map sectors beyond
        the end of the request, use a hole.  Implies trying to look at 
        these sectors could be undesireable.

    Vbn - Receives the assigned VBN
    
    AlignedSectorCount - Receives the actual sector count created in the
        Vmcb for page alignment purposes. Vbn+AlignedSectorCount-1 == LastVbn.

Return Value:

    BOOLEAN - TRUE if this is a new mapping and FALSE if the mapping
        for the LBN already exists.  If it already exists then the
        sector count for this new addition must already be in the
        VMCB structure

--*/

{

    BOOLEAN Result = FALSE;

    BOOLEAN VbnMcbAdded = FALSE;
    BOOLEAN LbnMcbAdded = FALSE;
    BOOLEAN AllowRoundToPage;

    LBN LocalLbn;
    VBN LocalVbn;
    ULONG LocalCount;
    LARGE_INTEGER Offset;
    PVCB Vcb;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfAddVmcbMapping, Lbn = %08x\n", Lbn ));
    DebugTrace(( 0, Dbg, " SectorCount = %08x\n", SectorCount ));

    ASSERT( SectorCount == 1 );
    ASSERT_IRP_CONTEXT( IrpContext);

    Vcb = IrpContext->Vcb;
    
    //
    //  Now grab the resource exclusive
    //

    VmcbLockForModify( Vmcb);

    try {

        //
        //  Check if the Lbn is already mapped, which means we find an entry
        //  with a non zero mapping Vbn value.
        //

        if (UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                   Lbn,
                                   Vbn,
                                   &LocalCount,
                                   NULL )) {

            //
            //  It is already mapped so now the sector count must not exceed
            //  the count already in the run
            //

            if (SectorCount <= LocalCount) {

                DebugTrace(( 0, Dbg, "Already mapped (Vbn == 0x%08x)\n", *Vbn));
                
                *AlignedSectorCount = LocalCount;
                try_leave( Result = FALSE );
            }
            
            //
            //  Trying to add overlapping extents indicates overlapping structures...
            //
            
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR);
        }

        //
        //  If there is a VAT in use,  then we treat the media as CDR style, and don't
        //  round/align extents to page boundries, since this could include (unreadable) 
        //  packet leadin/out sectors.
        //
        
        AllowRoundToPage = (NULL == Vcb->VatFcb);

#if 0
        //
        //  We only accept single block mapping requests, so knocking this out
        //  of the build for now.
        //
        
        //
        //  At this point, we did not find a full existing mapping for the
        //  Lbn and count.  But there might be some overlapping runs that we'll
        //  need to now remove from the vmcb structure.  So for each Lbn in
        //  the range we're after, check to see if it is mapped and remove the
        //  mapping.  We only need to do this test if the sector count is less
        //  than or equal to a page size.  Because those are the only
        //  structures that we know we'll try an remove/overwrite.
        //

        if (SectorCount <= PadSectorCountToPage(Vmcb, 1)) {

            if (UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                       Lbn,
                                       Vbn,
                                       &LocalCount,
                                       NULL )) {

                UdfRemoveVmcbMapping( Vmcb, *Vbn, PadSectorCountToPage(Vmcb, 1) );
            }            
        }
#endif
        //
        //  We need to add this new run at the end of the Vbns
        //

        if (!FsRtlLookupLastMcbEntry( &Vmcb->VbnIndexed, &LocalVbn, &LocalLbn ))  {

            //
            //  Vmcb is currently empty.
            //
            
            LocalVbn = -1;
        }

        if (!AllowRoundToPage)  {

            //
            //  So this volume may have unreadable sectors on it (eg CDR packet written) 
            //  and so we extend the vmcb one sector at a time,  only including sectors
            //  which we're specifically asked for,  and hence know that we should be 
            //  able to read.  
            //
            //  We simply use the next available VSN,  purging the last vmcb page if 
            //  neccessary (we're adding sectors to it),  and don't page align the lbn
            //  or sectorcount.
            //

            ASSERT( 1 == SectorCount);
            
            LocalVbn += 1;
            LocalLbn = Lbn;
            LocalCount = SectorCount;

            if (!IsPageAligned( Vmcb, LocalVbn))  {
            
                //
                //  The next VSN is not at the beginning of a page (ie: the last page 
                //  in the vmcb has space in it for more sectors),  so purge this
                //  page in the metadata stream before updating the mapping information.
                //
                
                ASSERT( Vcb && Vcb->MetadataFcb );

                Offset.QuadPart = (ULONGLONG) BytesFromSectors( IrpContext->Vcb,  AlignToPageBase( Vmcb, LocalVbn) );

                //
                //  Block until all mappings through the vmcb stream have been dropped
                //  before attempting the purge
                //
                
                UdfAcquireVmcbForCcPurge( IrpContext, IrpContext->Vcb);

                CcPurgeCacheSection( IrpContext->Vcb->MetadataFcb->FileObject->SectionObjectPointer,
                                     &Offset,
                                     PAGE_SIZE,
                                     FALSE );
                
                UdfReleaseVmcb( IrpContext, IrpContext->Vcb);
            }
        }
        else {
        
            //
            //  All sectors on this volume should be readable,  so we always extend the 
            //  vmcb a page at a time,  hoping that metadata will be packed sensibly. 
            //  Because we always extend in page chunks,  LocalVbn will be the last VSN 
            //  in a page aligned block,  so +1 lands on the next page (aligned VSN) in 
            //  the VMCB stream.
            //

            LocalVbn += 1;
            LocalLbn = AlignToPageBase( Vmcb, Lbn);
            LocalCount = PadSectorCountToPage( Vmcb, SectorCount + (Lbn - LocalLbn));

            ASSERT( IsPageAligned( Vmcb, LocalVbn));
            ASSERT( IsPageAligned( Vmcb, LocalLbn));            
            ASSERT( IsPageAligned( Vmcb, LocalCount));
        }

        //
        //  Add the double mapping
        //
        
        if (!FsRtlAddMcbEntry( &Vmcb->VbnIndexed,
                               LocalVbn,
                               LocalLbn,
                               LocalCount ))  {

            UdfRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR);
        }

        VbnMcbAdded = TRUE;

        if (!FsRtlAddMcbEntry( &Vmcb->LbnIndexed,
                               LocalLbn,
                               LocalVbn,
                               LocalCount ))  {

            UdfRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR);
        }
        
        LbnMcbAdded = TRUE;

        *Vbn = LocalVbn + (Lbn - LocalLbn);
        *AlignedSectorCount = LocalCount - (Lbn - LocalLbn);

        Result = TRUE;

    } finally {

        //
        //  If this is an abnormal termination then clean up any mcb's that we
        //  might have modified.
        //

        if (AbnormalTermination()) {

            if (VbnMcbAdded) { FsRtlRemoveMcbEntry( &Vmcb->VbnIndexed, LocalVbn, LocalCount ); }
            if (LbnMcbAdded) { FsRtlRemoveMcbEntry( &Vmcb->LbnIndexed, LocalLbn, LocalCount ); }
        }

        VmcbRelease( Vmcb);

        DebugUnwind("UdfAddVmcbMapping");

        if (Result)  {
        
            DebugTrace(( 0, Dbg, " LocalVbn   = %08x\n", LocalVbn ));
            DebugTrace(( 0, Dbg, " LocalLbn   = %08x\n", LocalLbn ));
            DebugTrace(( 0, Dbg, " LocalCount = %08x\n", LocalCount ));
            DebugTrace(( 0, Dbg, " *Vbn                = %08x\n", *Vbn ));
            DebugTrace(( 0, Dbg, " *AlignedSectorCount = %08x\n", *AlignedSectorCount ));
        }
        
        DebugTrace((-1, Dbg, "UdfAddVmcbMapping -> %08x\n", Result ));
    }

    return Result;
}


VOID
UdfRemoveVmcbMapping (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    )

/*++

Routine Description:

    This routine removes a Vmcb mapping.

    If pool is not available to store the information this routine will
    raise a status value indicating insufficient resources.

Arguments:

    Vmcb - Supplies the Vmcb being updated.

    Vbn - Supplies the VBN to remove

    SectorCount - Supplies the number of sectors to remove.

Return Value:

    None.

--*/

{
    LBN Lbn;
    ULONG LocalCount;
    ULONG i;

    PAGED_CODE();

    DebugTrace((+1, Dbg, "UdfRemoveVmcbMapping, Vbn = %08x\n", Vbn ));
    DebugTrace(( 0, Dbg, " SectorCount = %08x\n", SectorCount ));

    //
    //  Now grab the resource exclusive
    //

    VmcbLockForModify( Vmcb);

    try {

        for (i = 0; i < SectorCount; i += 1) {

            //
            //  Lookup the Vbn so we can get its current Lbn mapping
            //

            if (!UdfVmcbLookupMcbEntry( &Vmcb->VbnIndexed,
                                        Vbn + i,
                                        &Lbn,
                                        &LocalCount,
                                        NULL )) {

                UdfBugCheck( 0, 0, 0 );
            }

            FsRtlRemoveMcbEntry( &Vmcb->VbnIndexed,
                                 Vbn + i,
                                 1 );

            FsRtlRemoveMcbEntry( &Vmcb->LbnIndexed,
                                 Lbn,
                                 1 );
        }

        {
            DebugTrace(( 0, Dbg, "VbnIndex:\n", 0 ));
            DebugTrace(( 0, Dbg, "LbnIndex:\n", 0 ));
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind( "UdfRemoveVmcbMapping" );
        DebugTrace(( -1, Dbg, "UdfRemoveVmcbMapping -> VOID\n" ));
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
UdfVmcbLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.
    
    The only difference betweent this and the regular FsRtlLookupMcbEntry
    is that we undo the behavior of returning TRUE in holes in the allocation.
    This is because we don't want to avoid mapping at Lbn 0, which is how the
    emulated behavior of the small Mcb package tells callers that there is no
    mapping at that location in a hole.  We have holes all over our Vbn space
    in the VbnIndexed map.
    
    The small Mcb package was able to get away with this because Lbn 0 was the
    boot sector (or similar magic location) on the disc.  In our metadata stream,
    we wish to use Vbn 0 (remember this is a double map).

Arguments:

    Mcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (not if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return FALSE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    BOOLEAN Results;
    LONGLONG LiLbn = 0;
    LONGLONG LiSectorCount = 0;

    Results = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    if ((ULONG)LiLbn == -1) {

        *Lbn = 0;
        Results = FALSE;
    
    } else {

        *Lbn = (ULONG)LiLbn;
    }

    if (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\write.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Write called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Tom Jolly       [tomjolly]  8-Aug-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_WRITE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_WRITE)



NTSTATUS
UdfCommonWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;
    
    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN SynchronousIo;
    BOOLEAN WriteToEof;

    LONGLONG StartingOffset;
    LONGLONG ByteCount;

    NTSTATUS Status = STATUS_SUCCESS;

    UDF_IO_CONTEXT LocalIoContext;

    //
    // Get current Irp stack location and file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DebugTrace((+1, Dbg, "UdfCommonWrite\n"));
    DebugTrace(( 0, Dbg, "Irp                 = %8lx\n", Irp));
    DebugTrace(( 0, Dbg, "ByteCount           = %8lx\n", IrpSp->Parameters.Write.Length));
    DebugTrace(( 0, Dbg, "ByteOffset.LowPart  = %8lx\n", IrpSp->Parameters.Write.ByteOffset.LowPart));
    DebugTrace(( 0, Dbg, "ByteOffset.HighPart = %8lx\n", IrpSp->Parameters.Write.ByteOffset.HighPart));
    
    //
    //  Extract the nature of the write from the file object, and case on it
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb);

    //
    //  We only support write to the volume file
    //

    if (TypeOfOpen != UserVolumeOpen) {

        Irp->IoStatus.Information = 0;
        UdfCompleteRequest( IrpContext, Irp, STATUS_NOT_IMPLEMENTED );
        return STATUS_NOT_IMPLEMENTED;    
    }

    ASSERT( Fcb == IrpContext->Vcb->VolumeDasdFcb);
    ASSERT( Ccb != NULL);
    
    //
    // Initialize the appropriate local variables.
    //

    Wait          = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);
    SynchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO);

    //
    //  Extract the bytecount and starting offset
    //

    ByteCount = IrpSp->Parameters.Write.Length;
    StartingOffset = IrpSp->Parameters.Write.ByteOffset.QuadPart;
    WriteToEof = (StartingOffset == -1);

    Irp->IoStatus.Information = 0;

    //
    //  If there is nothing to write, return immediately
    //

    if (ByteCount == 0) {
    
        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Watch for overflow
    //
    
    if ((MAXLONGLONG - StartingOffset) < ByteCount)  {
    
        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Not sure what we're synchronising against,  but....
    //
    
    UdfAcquireFileShared( IrpContext, Fcb );

    try {
    
        //
        //  Verify the Fcb.  Allow writes if this handle is dismounting
        //  the volume.
        //

        if ((NULL == Ccb) || !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {
        
            UdfVerifyFcbOperation( IrpContext, Fcb );
        }

        if ((NULL == Ccb) || !FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

            //
            //  Clamp to volume size
            //

            if ( StartingOffset >= Fcb->FileSize.QuadPart) {
            
                try_leave( NOTHING);
            }
            
            if ( ByteCount > (Fcb->FileSize.QuadPart - StartingOffset))  {
            
                ByteCount = Fcb->FileSize.QuadPart - StartingOffset;
                
                if (0 == ByteCount)  {
                
                    try_leave( NOTHING);
                }
            }
        }
        else {
        
            //
            //  This has a peculiar interpretation, but just adjust the starting
            //  byte to the end of the visible volume.
            //

            if (WriteToEof)  {
            
                StartingOffset = Fcb->FileSize.QuadPart;
            }
        }

        //
        //  Initialize the IoContext for the write.
        //  If there is a context pointer, we need to make sure it was
        //  allocated and not a stale stack pointer.
        //

        if (IrpContext->IoContext == NULL ||
            !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            //
            //  If we can wait, use the context on the stack.  Otherwise
            //  we need to allocate one.
            //

            if (Wait) {

                IrpContext->IoContext = &LocalIoContext;
                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            } else {

                IrpContext->IoContext = UdfAllocateIoContext();
                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
            }
        }

        RtlZeroMemory( IrpContext->IoContext, sizeof( UDF_IO_CONTEXT ));

        //
        //  Store whether we allocated this context structure in the structure
        //  itself.
        //

        IrpContext->IoContext->AllocatedContext =
            BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

        if (Wait) {

            KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
            IrpContext->IoContext->Resource = Fcb->Resource;
            IrpContext->IoContext->RequestedByteCount = (ULONG)ByteCount;
        }

        //
        // For DASD we have to probe and lock the user's buffer
        //

        UdfLockUserBuffer( IrpContext, (ULONG)ByteCount, IoReadAccess );

        //
        //  Set the FO_MODIFIED flag here to trigger a verify when this
        //  handle is closed.  Note that we can err on the conservative
        //  side with no problem, i.e. if we accidently do an extra
        //  verify there is no problem.
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

        //
        //  Write the data and wait for the results
        //
        
        Irp->IoStatus.Information = (ULONG)ByteCount;

        UdfSingleAsync( IrpContext,
                        StartingOffset,
                        (ULONG)ByteCount);

        if (!Wait) {

            //
            //  We, nor anybody else, need the IrpContext any more.
            //

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO);

            UdfCleanupIrpContext( IrpContext, TRUE);

            DebugTrace((-1, Dbg, "UdfCommonWrite -> STATUS_PENDING\n"));
            
            try_leave( Status = STATUS_PENDING);
        }

        UdfWaitSync( IrpContext );

        //
        //  If the call didn't succeed, raise the error status
        //

        Status = Irp->IoStatus.Status;
        
        if (!NT_SUCCESS( Status)) {

            UdfNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  Update the current file position.  We assume that
        //  open/create zeros out the CurrentByteOffset field.
        //

        if (SynchronousIo && !PagingIo) {
            FileObject->CurrentByteOffset.QuadPart =
                StartingOffset + Irp->IoStatus.Information;
        }
    }
    finally {

        UdfReleaseFile( IrpContext, Fcb);
        
        DebugTrace((-1, Dbg, "UdfCommonWrite -> %08lx\n", Status ));
    }

    if (STATUS_PENDING != Status)  {

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\aclconv\aclconv.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    aclconv.cxx

Abstract:

    This module contains function definitions for the ACLCONV class,
    which implements conversion of Lanman 2.x ACLs into NT ACLs.

Author:

    Bill McJohn (billmc) 29-Jan-1992

Revision History:


Environment:

        ULIB, User Mode

--*/


#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "aclconv.hxx"
#include "file.hxx"
#include "filestrm.hxx"

#include "logfile.hxx"


BOOLEAN
QueryFileSystemName(
    IN  PCWSTRING   RootName,
    OUT PDSTRING    FileSystemName
    )
/*++

Routine Description:

    Determines the name of the file system on the specified volume.

Arguments:

    RootName        --  Supplies the name of the volume's root directory.
    FileSystemName  --  Receives the file system name.

Return Value:

    TRUE upon successful completion.

--*/
{
    WCHAR NameBuffer[8];

    if( !GetVolumeInformation( RootName->GetWSTR(),
                               NULL,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               NameBuffer,
                               8 ) ) {

        return FALSE;
    }

    return( FileSystemName->Initialize( NameBuffer ) );
}


BOOLEAN
EnablePrivilege(
    PWSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        DebugPrint( "OpenProcessToken failed" );
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        DebugPrintTrace(( "LookupPrivilegeValue failed, Error = %#d \n", GetLastError() ));
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        DebugPrintTrace(( "AdjustTokenPrivileges failed, Error = %#x \n", GetLastError() ));
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}


INT __cdecl
main(
    )
/*++

Routine Description:

    Entry point for the ACL conversion utility.

Arguments:

    None.

Return Value:

    An error level--0 indicates success.

--*/
{
    INT ExitCode = 0;

    if( !DEFINE_CLASS_DESCRIPTOR( ACLCONV ) ||
        !DEFINE_CLASS_DESCRIPTOR( SID_CACHE ) ||
        !DEFINE_CLASS_DESCRIPTOR( ACL_CONVERT_NODE ) ) {

        return 1;
    }

    {
        ACLCONV Aclconv;

        if( Aclconv.Initialize( &ExitCode ) ) {

            if( Aclconv.IsInListMode() ) {

                ExitCode = Aclconv.ListLogFile();

            } else {

                ExitCode = Aclconv.ConvertAcls();
            }
        }
    }

    return ExitCode;
}


DEFINE_CONSTRUCTOR( ACLCONV, PROGRAM );

ACLCONV::~ACLCONV(
    )
{
    Destroy();
}

VOID
ACLCONV::Construct(
    )
/*++

Routine Description:

    Helper method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataFileRevision = DataFileRevisionUnknown;

    _DataFile = NULL;
    _DataFileStream = NULL;
    _LogFile = NULL;
    _LogFileStream = NULL;

    _AclWorkFile = NULL;
    _AclWorkStream = NULL;

    _NewDrive = NULL;

    _RootNode = NULL;
    _DriveName = NULL;
    _DomainName = NULL;
    _SidLookupTableName = NULL;

}

VOID
ACLCONV::Destroy(
    )
/*++

Routine Description:

    Helper function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataFileRevision = DataFileRevisionUnknown;
    _NextReadOffset = 0;
    _BytesRemainingInCurrentGroup = 0;

    DELETE( _DataFile );
    DELETE( _DataFileStream );
    DELETE( _LogFile );
    DELETE( _LogFileStream );

    DELETE( _AclWorkFile );
    DELETE( _AclWorkStream );
    DELETE( _NewDrive );
    DELETE( _RootNode );
    DELETE( _DriveName );
    DELETE( _DomainName );
    DELETE( _SidLookupTableName );
}



BOOLEAN
ACLCONV::Initialize(
    OUT PINT ExitCode
    )
/*++

Routine Description:

    Initialize the ACLCONV object.

Arguments:

    ExitCode    --  Receives an error level if this method fails.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if( !PROGRAM::Initialize( ) ) {

        Destroy();
        *ExitCode = 1;
        return FALSE;
    }

    return ParseArguments( ExitCode );
}


INT
ACLCONV::ListLogFile(
    )
/*++

Routine Description:

    This method reads a log file produced by a previous run of
    ACLCONV and displays the errors logged to that file.

Arguments:

    None.

Return Value:

    An error level--zero indicates success.

--*/
{
    LM_ACCESS_LIST AccessEntries[ MAX_ACCESS_ENTRIES ];
    ULONG AceConversionCodes[ MAX_ACCESS_ENTRIES ];

    ACLCONV_LOGFILE_HEADER LogFileHeader;
    DSTRING ResourceName;
    ULONG AccessEntryCount, BytesRead, ConversionCode, i;
    INT ExitCode = 0;
    USHORT AuditInfo;

    // Open the log file and reset the seek pointer to the beginning
    // of the file.
    //
    if( (_LogFile = SYSTEM::QueryFile( &_LogFilePath )) == NULL ||
        (_LogFileStream = _LogFile->QueryStream( READ_ACCESS )) == NULL ) {

        // Cannot create log file.

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _LogFilePath.GetPathString() );
        return 1;
    }

    // Check the log file signature:
    //
    if( !_LogFileStream->MovePointerPosition( 0, STREAM_BEGINNING ) ||
        !_LogFileStream->Read( (PBYTE)&LogFileHeader,
                               sizeof( ACLCONV_LOGFILE_HEADER ),
                               &BytesRead ) ||
        BytesRead != sizeof( ACLCONV_LOGFILE_HEADER ) ||
        LogFileHeader.Signature != AclconvLogFileSignature ) {

        DisplayMessage( MSG_ACLCONV_INVALID_LOG_FILE,
                        ERROR_MESSAGE );

        return 1;
    }

    _NextReadOffset = sizeof( ACLCONV_LOGFILE_HEADER );

    while( ReadNextLogRecord( &ExitCode,
                              &ResourceName,
                              &ConversionCode,
                              &AuditInfo,
                              MAX_ACCESS_ENTRIES,
                              &AccessEntryCount,
                              AccessEntries,
                              AceConversionCodes ) ) {

        // Scan to see if there are any entries to display
        //
        if( AccessEntryCount != 0 ) {

            DisplayMessage( MSG_ACLCONV_RESOURCE_NAME,
                            NORMAL_MESSAGE,
                            "%W",
                            &ResourceName );

            for( i = 0; i < AccessEntryCount; i++ ) {

                DisplayAce( (ACL_CONVERT_CODE)ConversionCode,
                            (ACE_CONVERT_CODE)AceConversionCodes[i],
                            AccessEntries + i );
            }
        }
    }

    if( ExitCode ) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_READ_ERROR, ERROR_MESSAGE );
    }

    return ExitCode;
}



NONVIRTUAL
BOOLEAN
ACLCONV::DisplayAce(
    IN ACL_CONVERT_CODE AclConvertCode,
    IN ACE_CONVERT_CODE AceConvertCode,
    IN PLM_ACCESS_LIST  Ace
    )
/*++

Routine Description:

    This method displays the conversion result for a single ACE.

Arguments:

    AclConvertCode  --  Supplies the overall conversion code for
                        the resource to which this ACE is attached.
    AceConvertCode  --  Supplies the conversion result for this
                        particular ACE.  Note that if the AclConvertCode
                        is not ACL_CONVERT_SUCCESS, it takes priority
                        over AceConvertCode.
    Ace             --  Supplies the ACE in question.

Return Value:

    TRUE upon successful completion.

--*/
{
    WCHAR WideNameBuffer[ UNLEN + 1 ];
    DSTRING Temp;
    DSTRING Name;

    memset( WideNameBuffer, 0, sizeof( WideNameBuffer ) );

    // Display the user's name.  If it's a group, prepend an
    // asterisk.
    //
    if( !MultiByteToWideChar( _SourceCodepage,
                              0,
                              Ace->acl_ugname,
                              strlen( Ace->acl_ugname ),
                              WideNameBuffer,
                              UNLEN + 1 ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return FALSE;
    }

    if( !Temp.Initialize( WideNameBuffer ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return FALSE;
    }

    if( Ace->acl_access & LM_ACCESS_GROUP ) {

        if( !Name.Initialize( "*" ) ||
            !Name.Strcat( &Temp ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return FALSE;
        }

    } else {

        if( !Name.Initialize( &Temp ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return FALSE;
        }
    }

    DisplayMessage( MSG_ACLCONV_USERNAME, NORMAL_MESSAGE, "%W", &Name );


    // Display the permissions:
    //
    if( (Ace->acl_access & ~LM_ACCESS_GROUP) == 0 ) {

        // This is a no-access ACE.
        //
        DisplayMessage( MSG_ACLCONV_NONE_PERM );

    } else {

        // This ACE grants some sort of access--check each type
        // of access in turn, displaying all we find.
        //
        if( Ace->acl_access & LM_ACCESS_READ ) {

            DisplayMessage( MSG_ACLCONV_READ_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_WRITE ) {

            DisplayMessage( MSG_ACLCONV_WRITE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_CREATE ) {

            DisplayMessage( MSG_ACLCONV_CREATE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_EXEC ) {

            DisplayMessage( MSG_ACLCONV_EXECUTE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_DELETE ) {

            DisplayMessage( MSG_ACLCONV_DELETE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_ATRIB ) {

            DisplayMessage( MSG_ACLCONV_ATTR_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_PERM ) {

            DisplayMessage( MSG_ACLCONV_PERM_PERM );
        }
    }


    // Display the cause of failure:
    //
    if( AclConvertCode != ACL_CONVERT_SUCCESS ) {

        // The failure is associated with the resource.
        //
        switch( AclConvertCode ) {

        case ACL_CONVERT_RESOURCE_NOT_FOUND :
            DisplayMessage( MSG_ACLCONV_FILE_NOT_FOUND );
            break;

        case ACL_CONVERT_ERROR :
        default :
            DisplayMessage( MSG_ACLCONV_ERROR_IN_CONVERSION );
            break;
        }

    } else {

        // Display the ACE conversion result.
        //
        switch( AceConvertCode ) {

        case ACL_CONVERT_SUCCESS :
            DisplayMessage( MSG_ACLCONV_ACE_CONVERTED );
            break;

        case ACE_CONVERT_DROPPED :
            DisplayMessage( MSG_ACLCONV_ACE_DROPPED );
            break;

        case ACE_CONVERT_SID_NOT_FOUND :
            DisplayMessage( MSG_ACLCONV_SID_NOT_FOUND );
            break;

        case ACE_CONVERT_ERROR :
        default:
            DisplayMessage( MSG_ACLCONV_ERROR_IN_CONVERSION );
            break;
        }
    }


    return TRUE;
}


NONVIRTUAL
BOOLEAN
ACLCONV::ReadNextLogRecord(
    OUT PINT            ExitCode,
    OUT PWSTRING        ResourceString,
    OUT PULONG          ConversionCode,
    OUT PUSHORT         AuditInfo,
    IN  ULONG           MaxEntries,
    OUT PULONG          AccessEntryCount,
    OUT PLM_ACCESS_LIST AccessEntries,
    OUT PULONG          AceConversionCodes
    )
/*++

Routine Description:

    This method reads the next log entry from the log file.

Arguments:

    ExitCode            --  receives an exit code if an error occurs.
    ResourceString      --  receives the name of the resource
    ConversionCode      --  receives the conversion result for this resource.
    AuditInfo           --  receives the audit information for this resource.
    MaxEntries          --  supplies the maximum number of ACE's that can
                            be written to the output buffers.
    AccessEntryCount    --  receives the number of ACE's written to
                            the output buffers.
    AccessEntries       --  receives the logged ACE's
    AceConversionCodes  --  receives the conversion results for the
                            individual ACE's.

Return Value:

    TRUE upon successful completion (in which case ExitCode may
    be ignored).  FALSE if there are no more entries (in which
    case ExitCode is zero) or if an error occurs (in which case
    ExitCode is non-zero).

--*/
{
    ACLCONV_LOG_RECORD_HEADER Header;
    ULONG BytesRead;

    if( _LogFileStream->IsAtEnd() ) {

        // No more entries to read.

        *ExitCode = 0;
        return FALSE;
    }

    // Read the log record header
    //
    if( !_LogFileStream->Read( (PBYTE)&Header,
                               sizeof( ACLCONV_LOG_RECORD_HEADER ),
                               &BytesRead ) ||
        BytesRead != sizeof( ACLCONV_LOG_RECORD_HEADER ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    *ConversionCode = Header.ConversionResult;
    *AuditInfo = Header.LmAuditMask;
    *AccessEntryCount = Header.AccessEntryCount;

    // Make sure that the name is not longer than the maximum
    // name length (plus room for trailing NULL) and then read
    // it into the name workspace and use it to initialize the
    // client's resource name string.
    //
    if( Header.ResourceNameLength > MAX_RESOURCE_NAME_LENGTH + 1 ||
        !_LogFileStream->Read( (PBYTE)_NameBuffer,
                               Header.ResourceNameLength * sizeof( WCHAR ),
                               &BytesRead ) ||
        BytesRead != Header.ResourceNameLength * sizeof( WCHAR ) ||
        !ResourceString->Initialize( _NameBuffer ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    // Make sure the ACE's and their associated convert codes will
    // fit in the supplied buffers:
    //
    if( Header.AccessEntryCount > MaxEntries ) {

        *ExitCode = 1;
        return FALSE;
    }

    // Read the ACE conversion codes and the ACE's themselves:
    //
    if( Header.AccessEntryCount != 0 &&
        ( !_LogFileStream->Read( (PBYTE)AceConversionCodes,
                                 Header.AccessEntryCount * sizeof( ULONG ),
                                 &BytesRead ) ||
          BytesRead != Header.AccessEntryCount * sizeof( ULONG ) ) ||

        ( !_LogFileStream->Read( (PBYTE)AccessEntries,
                                 Header.AccessEntryCount *
                                        sizeof( LM_ACCESS_LIST ),
                                 &BytesRead ) ||
          BytesRead != Header.AccessEntryCount * sizeof( LM_ACCESS_LIST ) ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    return TRUE;
}



INT
ACLCONV::ConvertAcls(
    )
/*++

Routine Description:

    This method reads the ACL's from the data file into a tree
    of ACL Convert Nodes, and then converts the ACL's to NT
    security descriptors and applies them to the files and
    directories in question.

Arguments:

    None.

Return Value:

    An error level--zero indicates success.

--*/
{

    LM_ACCESS_LIST AccessEntries[MAX_ACCESS_ENTRIES];
    INHERITANCE_BUFFER Inheritance;

    FSTRING NtfsString;
    DSTRING FsName;
    DSTRING CurrentResource;
    PATH    CurrentResourcePath;

    ACLCONV_LOGFILE_HEADER LogfileHeader;

    PARRAY Components = NULL;
    PARRAY_ITERATOR ComponentIterator = NULL;
    PACL_CONVERT_NODE CurrentNode, NextNode;
    PWSTRING CurrentComponent;

    ULONG AccessEntryCount, BytesWritten;
    USHORT LmAuditInfo;

    INT ExitCode = 0;

    DSTRING AclWorkString;

    // Open aclwork.dat and read the contents into a special
    // sid cache.

    if (!AclWorkString.Initialize(L"aclwork.dat")) {
        return 1;
    }
    if (!_AclWorkPath.Initialize(&AclWorkString)) {
        return 1;
    }

    if (NULL == (_AclWorkFile = SYSTEM::QueryFile(&_AclWorkPath))) {

        // try to open aclwork.dat in the same directory as the
        // data file.

        if (!_AclWorkPath.Initialize(&_DataFilePath)) {
            return 1;
        }
        if (!_AclWorkPath.SetName(&AclWorkString)) {
            return 1;
        }

        _AclWorkFile = SYSTEM::QueryFile(&_AclWorkPath);
    }
    if (NULL != _AclWorkFile &&
        NULL != (_AclWorkStream = _AclWorkFile->QueryStream(READ_ACCESS))) {

        // DisplayMessage( MSG_ACLCONV_USING_ACLWORK, NORMAL_MESSAGE );

        if (!ReadAclWorkSids()) {
            return 1;
        }
    }

    // Open the data file and determine its format (ie. what
    // revision of BackAcc produced it).

    if( (_DataFile = SYSTEM::QueryFile( &_DataFilePath )) == NULL ||
        (_DataFileStream = _DataFile->QueryStream( READ_ACCESS )) == NULL ) {

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _DataFilePath.GetPathString() );
        return 1;
    }

    // Note that DetermineDataFileRevision sets _DataFileRevision.

    if( !DetermineDataFileRevision( ) ||
        _DataFileRevision == DataFileRevisionUnknown ) {

        DisplayMessage( MSG_ACLCONV_DATAFILE_BAD_FORMAT,
                        ERROR_MESSAGE,
                        "%W",
                        _DataFilePath.GetPathString() );
        return 1;
    }


    // Create the log file.

    LogfileHeader.Signature = AclconvLogFileSignature;

    if( (_LogFile = SYSTEM::MakeFile( &_LogFilePath )) == NULL ||
        (_LogFileStream = _LogFile->QueryStream( WRITE_ACCESS )) == NULL ||
        !_LogFileStream->Write( (PBYTE)&LogfileHeader,
                                sizeof( ACLCONV_LOGFILE_HEADER ),
                                &BytesWritten ) ||
        BytesWritten != sizeof( ACLCONV_LOGFILE_HEADER ) ) {

        // Cannot create log file.

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _LogFilePath.GetPathString() );
        return 1;
    }


    while( ReadNextAcl( &ExitCode,
                        &CurrentResource,
                        MAX_ACCESS_ENTRIES,
                        &AccessEntryCount,
                        (PVOID)AccessEntries,
                        &LmAuditInfo ) ) {

        if( CurrentResource.QueryChCount() == 0 ) {

            // This resource has no name; ignore it.
            //
            continue;
        }

        if( !CurrentResourcePath.Initialize( &CurrentResource ) ) {

            DisplayMessage( MSG_ACLCONV_DATAFILE_ERROR, ERROR_MESSAGE );
            return 1;
        }

        // If the user specified a substitute drive, use it.
        //
        if( _NewDrive != NULL &&
            !CurrentResourcePath.SetDevice( _NewDrive ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }

        if( _RootNode == NULL ) {

            // This is the first ACL--create the root of the tree
            // and determine the name of the drive.

            if( !(_DriveName = CurrentResourcePath.QueryRoot()) ||
                !(_RootNode = NEW ACL_CONVERT_NODE) ||
                !_RootNode->Initialize( _DriveName ) ) {

                DELETE( _RootNode );
                DELETE( _DriveName );

                DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                return 1;
            }
        }

        // Fetch the component array for this resource.

        DELETE( ComponentIterator );

        if( Components != NULL ) {

            Components->DeleteAllMembers();
        }

        DELETE( Components );

        if( !(Components = CurrentResourcePath.QueryComponentArray()) ||
            !(ComponentIterator = (PARRAY_ITERATOR)
                                  Components->QueryIterator()) ) {

            DELETE( ComponentIterator );

            if( Components != NULL ) {

                Components->DeleteAllMembers();
            }

            DELETE( Components );

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }

        CurrentNode = _RootNode;

        ComponentIterator->Reset();

        // The first component is the drive & root directory, which
        // isn't interesting.

        CurrentComponent = (PWSTRING)ComponentIterator->GetNext();

        // Traverse the tree down to the end of the path, creating
        // new nodes as needed.

        while( (CurrentComponent = (PWSTRING)ComponentIterator->GetNext())
                    != NULL ) {

            if( !(NextNode = CurrentNode->GetChild( CurrentComponent )) &&
                !(NextNode = CurrentNode->AddChild( CurrentComponent )) ) {

                DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                return 1;
            }

            CurrentNode = NextNode;
        }

        // Add the Lanman ACL to the node which represents the end of
        // the path.

        if( !CurrentNode->AddLanmanAcl( AccessEntryCount,
                                        AccessEntries,
                                        LmAuditInfo ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }
    }


    if( ExitCode != 0 ) {

        DisplayMessage( MSG_ACLCONV_DATAFILE_ERROR, ERROR_MESSAGE );
        return 1;
    }

    // Traverse the tree and convert all the ACE's, propagating
    // as we go.
    //

    // Adjust this process' privileges so that it can twiddle
    // System ACL's.
    //
    if( !EnablePrivilege( (LPWSTR)SE_SECURITY_NAME ) ) {

        DisplayMessage( MSG_ACLCONV_CONVERSION_ERROR, ERROR_MESSAGE );
        ExitCode = 1;
    }

    if( ExitCode == 0 &&
        _RootNode != NULL ) {

        // Make sure the target drive is NTFS.
        //
        if( !NtfsString.Initialize( (PWSTR)L"NTFS" ) ||
            !QueryFileSystemName( _RootNode->GetName(), &FsName ) ) {

            DisplayMessage( MSG_ACLCONV_CANT_DETERMINE_FILESYSTEM, ERROR_MESSAGE );
            ExitCode = 1;

        } else if( FsName.Stricmp( &NtfsString ) != 0 ) {

            DisplayMessage( MSG_ACLCONV_TARGET_NOT_NTFS, ERROR_MESSAGE );
            ExitCode = 1;

        } else {

            // Set up an empty inheritance buffer to pass
            // to the root.
            //
            Inheritance.RecessiveDeniedAces = NULL;
            Inheritance.RecessiveAllowedAces = NULL;
            Inheritance.DominantDeniedAces = NULL;
            Inheritance.DominantAllowedAces = NULL;

            Inheritance.RecessiveDeniedMaxLength = 0;
            Inheritance.RecessiveAllowedMaxLength = 0;
            Inheritance.DominantDeniedMaxLength = 0;
            Inheritance.DominantAllowedMaxLength = 0;

            Inheritance.RecessiveDeniedLength = 0;
            Inheritance.RecessiveAllowedLength = 0;
            Inheritance.DominantDeniedLength = 0;
            Inheritance.DominantAllowedLength = 0;

            if( !_RootNode->Convert( NULL,
                                     &Inheritance,
                                     this ) ) {

                DisplayMessage( MSG_ACLCONV_CONVERSION_ERROR, ERROR_MESSAGE );
                ExitCode = 1;
            }
        }
    }


    if( ExitCode == 0 ) {

        DisplayMessage( MSG_ACLCONV_CONVERT_COMPLETE );
    }

    return ExitCode;
}


BOOLEAN
ACLCONV::LogConversion(
    IN PPATH            Resource,
    IN ULONG            ConversionCode,
    IN ULONG            LmAuditInfo,
    IN ULONG            AccessEntryCount,
    IN PCULONG          AceConversionCodes,
    IN PCLM_ACCESS_LIST AccessEntries
    )
/*+

Routine Description:

    This method writes information about the conversion of a resource
    to the log file.

Arguments:

    Resource            --  Supplies the path to the resource
    ConversionCode      --  Supplies the conversion result for the
                            resource.
    LmAuditInfo         --  Supplies the Lanman 2.x audit information
                            associated with the resource.
    AccessEntryCount    --  Supplies the number of Lanman 2.x access
                            entries associated with the resource.
    AceConversionCodes  --  Supplies the conversion results of the
                            individual ACE's
    AccessEntries       --  Supplies the Lanman 2.x access control
                            entries.

Return Value:

    TRUE upon successful completion.

--*/
{
    ACLCONV_LOG_RECORD_HEADER Header;
    PCWSTRING PathString;

    ULONG NameLength, BytesWritten;

    DebugPtrAssert( Resource );
    DebugPtrAssert( _LogFileStream );

    if( (PathString = Resource->GetPathString()) == NULL ||
        (NameLength = PathString->QueryChCount()) > MAX_RESOURCE_NAME_LENGTH ||
        !PathString->QueryWSTR( 0,
                                TO_END,
                                _NameBuffer,
                                MAX_RESOURCE_NAME_LENGTH + 1 ) ){

        return FALSE;
    }

    Header.ResourceNameLength = NameLength + 1;
    Header.ConversionResult = ConversionCode;
    Header.LmAuditMask = (USHORT)LmAuditInfo;
    Header.AccessEntryCount = (USHORT)AccessEntryCount;

    if(!_LogFileStream->Write( (PBYTE)&Header,
                               sizeof( ACLCONV_LOG_RECORD_HEADER ),
                               &BytesWritten )                      ||
       BytesWritten != sizeof( ACLCONV_LOG_RECORD_HEADER )          ||
       !_LogFileStream->Write( (PBYTE)_NameBuffer,
                                (NameLength + 1) * sizeof( WCHAR ),
                                &BytesWritten )                     ||
        BytesWritten != (NameLength + 1) * sizeof( WCHAR )) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_ERROR, ERROR_MESSAGE );
        return FALSE;
    }

    if( AccessEntryCount != 0 &&
        ( !_LogFileStream->Write( (PBYTE)AceConversionCodes,
                                  AccessEntryCount * sizeof(ULONG),
                                  &BytesWritten )                   ||
          BytesWritten != AccessEntryCount * sizeof(ULONG)          ||
          !_LogFileStream->Write( (PBYTE)AccessEntries,
                                  AccessEntryCount * sizeof( LM_ACCESS_LIST ),
                                  &BytesWritten )                   ||
          BytesWritten != AccessEntryCount * sizeof( LM_ACCESS_LIST ) ) ) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_ERROR, ERROR_MESSAGE );
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
ACLCONV::ParseArguments(
    OUT PINT ExitCode
    )
/*++

Routine Description:

    This method parses the arguments given to ACLCONV and sets the
    state of the object appropriately.

    The accepted syntax is:

        ACLCONV [/?] [/V] /DATA:datafile /LOG:logfile

Arguments:

    ExitCode    --  Receives an exit code if the method fails.

Return Value:

    TRUE upon successful completion.

    Note that this method will fail, but return an exit-code
    of zero (success) if the user specifies the /? argument.

--*/
{
    ARRAY               ArgArray;               //  Array of arguments
    ARRAY               LexArray;               //  Array of lexemes
    ARGUMENT_LEXEMIZER  ArgLex;                 //  Argument Lexemizer
    STRING_ARGUMENT     ProgramNameArgument;    //  Program name argument
    PATH_ARGUMENT       DataFileArgument;       //  Path to data file
    PATH_ARGUMENT       LogFileArgument;        //  Path to log file
    PATH_ARGUMENT       DriveArgument;          //  New drive to use
    FLAG_ARGUMENT       ListArgument;           //  List flag argument
    FLAG_ARGUMENT       HelpArgument;           //  Help flag argument
    STRING_ARGUMENT     DomainArgument;         //  Domain name argument
    LONG_ARGUMENT       CodepageArgument;       //  Source Codepage argument
    STRING_ARGUMENT     SidLookupArgument;      //  Filename of lookup table
    PWSTRING            InvalidArg;             //  Invalid argument catcher
    DSTRING             Backslash;              //  Backslash
    DSTRING             RootDir;                //  Root directory of the new drive
    UINT                DriveType;


    DebugPtrAssert( ExitCode );

        //
        //      Initialize all the argument parsing machinery.
        //
    if( !ArgArray.Initialize( 5, 1 )                ||
        !LexArray.Initialize( 5, 1 )                ||
        !ArgLex.Initialize( &LexArray )             ||
        !HelpArgument.Initialize( "/?" )            ||
        !ListArgument.Initialize( "/LIST" )         ||
        !ProgramNameArgument.Initialize( "*" )      ||
        !DataFileArgument.Initialize( "/DATA:*" )   ||
        !LogFileArgument.Initialize( "/LOG:*" )     ||
        !DriveArgument.Initialize( "/NEWDRIVE:*" )  ||
        !DomainArgument.Initialize( "/DOMAIN:*" )   ||
        !CodepageArgument.Initialize( "/CODEPAGE:*" ) ||
        !SidLookupArgument.Initialize( "/SIDLOOKUP:*" ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //  The ACL conversion utility is case-insensitive
    //
    ArgLex.SetCaseSensitive( FALSE );

    //  Put the arguments into the argument array

    if( !ArgArray.Put( &HelpArgument )          ||
        !ArgArray.Put( &ListArgument )          ||
        !ArgArray.Put( &DataFileArgument )      ||
        !ArgArray.Put( &LogFileArgument )       ||
        !ArgArray.Put( &DriveArgument )         ||
        !ArgArray.Put( &DomainArgument )        ||
        !ArgArray.Put( &CodepageArgument )      ||
        !ArgArray.Put( &ProgramNameArgument ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //  Lexemize the command line.
    //
    if ( !ArgLex.PrepareToParse() ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //      Parse the arguments.
    //
    if( !ArgLex.DoParsing( &ArgArray ) ) {


        DisplayMessage( MSG_CONV_INVALID_PARAMETER, ERROR_MESSAGE, "%W", InvalidArg = ArgLex.QueryInvalidArgument() );
        DELETE( InvalidArg );

        *ExitCode = 1;
        return FALSE;
    }


    //
    //      If the user requested help, give it.
    //
    if( HelpArgument.QueryFlag() ) {

        DisplayMessage( MSG_ACLCONV_USAGE );

        *ExitCode = 0;
        return FALSE;
    }

    //  The log file must be specified, and either the data
    //  file or the list argument (but not both) must be
    //  provided.
    //
    if( !LogFileArgument.IsValueSet()           ||
        ( !DataFileArgument.IsValueSet() &&
          !ListArgument.IsValueSet() )          ||
        ( DataFileArgument.IsValueSet() &&
          ListArgument.IsValueSet() ) ) {

        DisplayMessage( MSG_ACLCONV_USAGE );

        *ExitCode = 1;
        return FALSE;
    }

    // If the drive argument has been supplied, record it:
    //
    if( DriveArgument.IsValueSet() ) {

        _NewDrive = DriveArgument.GetPath()->QueryDevice();

        if( _NewDrive == NULL ) {

            DisplayMessage( MSG_INVALID_PARAMETER,
                            ERROR_MESSAGE,
                            "%W",
                            DriveArgument.GetPath()->GetPathString() );
            *ExitCode = 1;
            return FALSE;
        }

        // Validate the drive.
        //
        if( !RootDir.Initialize( _NewDrive ) ||
            !Backslash.Initialize( "\\" ) ||
            !RootDir.Strcat( &Backslash ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }

        DriveType = GetDriveTypeW( RootDir.GetWSTR() );

        switch ( DriveType ) {

        case DRIVE_FIXED:
        case DRIVE_REMOVABLE:

            // The drive type is acceptable.
            //
            break;

        case 0:
        case 1:
        case DRIVE_CDROM:
        case DRIVE_REMOTE:
        case DRIVE_RAMDISK:
        default:

            // The drive type is invalid.
            //
            DisplayMessage( MSG_ACLCONV_INVALID_DRIVE, ERROR_MESSAGE, "%W", _NewDrive );
            *ExitCode = 1;
            return FALSE;
        }
    }

    // If a domain name has been specified, remember it:
    //
    if( DomainArgument.IsValueSet() ) {

        if( (_DomainName = NEW DSTRING) == NULL ||
            !_DomainName->Initialize( DomainArgument.GetString() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }

    // If a source codepage has been specified, use it; otherwise,
    // use CP_OEMCP as default.
    //
    if( !CodepageArgument.IsValueSet() ) {

        _SourceCodepage = CP_OEMCP;

    } else {

        _SourceCodepage = CodepageArgument.QueryLong();

        if( !IsValidCodePage( _SourceCodepage ) ) {

            DisplayMessage( MSG_ACLCONV_BAD_CODEPAGE, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }

    if( SidLookupArgument.IsValueSet() ) {

        _SidLookupTableName = SidLookupArgument.GetString()->QueryWSTR();
    }

    _IsInListMode = ListArgument.IsValueSet();

    if( _IsInListMode ) {

        // In list mode, only the Log File path need be present.
        //
        if( !_LogFilePath.Initialize( LogFileArgument.GetPath() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    } else {

        // The object is not in list mode, so both the Data File
        // and Log File paths must be present.
        //
        if( !_DataFilePath.Initialize( DataFileArgument.GetPath() ) ||
            !_LogFilePath.Initialize( LogFileArgument.GetPath() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }


    if( !_SidCache.Initialize( 100 ) ) {

        return FALSE;
    }

    if (!_AclWorkSids.Initialize(1)) {

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
ACLCONV::DetermineDataFileRevision(
    )
/*++

Routine Description:

    This method examines the data file to determine what revision
    of the Lanman BackAcc utility produced it.  It sets the private
    member variable _DataFileRevision.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.  _DataFileRevision is set
    appropriately.

--*/
{
    CHAR Buffer[RecognitionSize];
    ULONG BytesRead;

    // If the first four bytes of the file are the LM2.0 backacc signature,
    // assume the data file was produced by LM2.0 backacc.  LM2.1 backacc
    // data files are recognizable by the string "LM210 BACKACC" at
    // byte offset 4.


    _DataFileRevision = DataFileRevisionUnknown;

    if( _DataFileStream == NULL ||
        !_DataFileStream->ReadAt( (PBYTE)Buffer,
                                  RecognitionSize,
                                  0,
                                  STREAM_BEGINNING,
                                  &BytesRead ) ||
        BytesRead != RecognitionSize ) {

        return FALSE;
    }


    if( strncmp( Buffer, (PCHAR)&Lm20BackaccSignature, 4) == 0 ) {

        _DataFileRevision = DataFileRevisionLanman20;
        return TRUE;
    }

    if( strncmp( Buffer+Lm21BackaccSignatureOffset,
                 Lm21BackaccSignature,
                 Lm21BackaccSignatureLength ) == 0 ) {

        _DataFileRevision = DataFileRevisionLanman21;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
ACLCONV::UpdateAndQueryCurrentLM21Name(
    IN  ULONG       DirectoryLevel,
    IN  PCSTR       NewComponent,
    OUT PWSTRING    CurrentName
    )
/*++

Routine Description:

    This function updates the current resource name while
    traversing the LM21 BackAcc data file.

Arguments:

    DirectoryLevel  --  Supplies the directory level of the
                        most-recently-encountered component.
                        (0 is the drive, 1 is the root directory,
                        2 is an element in the root directory, and
                        so forth.)
    NewComponent    --  Supplies the name of the most-recently-
                        encountered component.
    CurrentName     --  Receives the updated current resource name.

Return Value:

    TRUE upon successful completion.

--*/
{
    STATIC PDSTRING Components[256];
    STATIC PDSTRING BackSlash;
    STATIC ULONG CurrentLevel = 0;

    WCHAR ComponentBuffer[ MAX_RESOURCE_NAME_LENGTH ];
    ULONG i;

    // If BackSlash hasn't been initialized yet,
    // initialize it.
    //
    if( BackSlash == NULL ) {

        if( (BackSlash = NEW DSTRING) == NULL ||
            !BackSlash->Initialize( "\\" ) ) {

            return FALSE;
        }
    }

    if( DirectoryLevel == 0 ) {

        return( CurrentName->Initialize( "" ) );
    }

    while( CurrentLevel >= DirectoryLevel ) {

        // Trim off the last component of the path.
        //
        CurrentLevel--;
        DELETE( Components[CurrentLevel] );
    }


    // Now we're ready to add a new component to the end of the
    // current path.
    //
    if( DirectoryLevel != CurrentLevel + 1 ) {

        DebugPrint( "ACLCONV: skipped a level in name tree.\n" );
        return FALSE;
    }

    memset( ComponentBuffer, 0, sizeof( ComponentBuffer ) );

    if( (Components[CurrentLevel] = NEW DSTRING) == NULL ||
        !MultiByteToWideChar( _SourceCodepage,
                              0,
                              NewComponent,
                              strlen( NewComponent ),
                              ComponentBuffer,
                              MAX_RESOURCE_NAME_LENGTH ) ||
        !Components[CurrentLevel]->Initialize( ComponentBuffer ) ) {

        return FALSE;
    }

    CurrentLevel++;

    // Now copy the current path to the output string.
    //
    if( !CurrentName->Initialize( "" ) ) {

        return FALSE;
    }

    for( i = 0; i < CurrentLevel; i++ ) {

        // There's no backslash before the first component (the drive);
        // if the prefix ends in a backslash, don't add one.  Otherwise,
        // add a backslash.
        //
        if( i > 0 &&
            CurrentName->QueryChAt( CurrentName->QueryChCount() - 1 ) != '\\' &&
            !CurrentName->Strcat( BackSlash ) ) {

            return FALSE;
        }

        // Add the next component
        //
        if( !CurrentName->Strcat( Components[i] ) ) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
ACLCONV::ReadNextAcl(
    OUT PINT        ExitCode,
    OUT PWSTRING    ResourceString,
    IN  ULONG       MaxEntries,
    OUT PULONG      AccessEntryCount,
    OUT PVOID       AccessEntries,
    OUT PUSHORT     AuditInfo
    )
/*++

Routine Description:

    This method reads the next ACL record from the data file.  The
    ACL record describes the resource and its associated Access Control
    Entries.

Arguments:

    ExitCode                --  Receives an error level if an error occurs.
    ResourceString          --  Receives the name of the resource.
    MaxEntries              --  Supplies the maximum number of entries
                                that will fit in the supplied buffer.
    AccessEntryCount        --  Receives the number of access entries read.
    AccessEntries           --  Receives the access entries.
    AuditInfo               --  Receives the Lanman 2.x audit information
                                for the resource.



Return Value:

    TRUE upon successful completion.  If the end of the file is
    reached without error, this method returns FALSE, with *ExitCode
    equal to zero.

--*/
{
    CHAR ResourceName[ MAX_RESOURCE_NAME_LENGTH ];
    WCHAR WideResourceName[ MAX_RESOURCE_NAME_LENGTH ];

    lm20_resource_info ResourceInfo;
    lm21_aclhdr Lm21Header;
    lm21_aclrec Lm21AclRec;
    ULONG BytesRead, TotalBytesRead;

    if( _DataFileStream == NULL ) {

        DebugAbort( "Data stream not set up.\n" );
        return FALSE;
    }


    switch( _DataFileRevision ) {

    case DataFileRevisionUnknown :

        DebugAbort( "Trying to read from unknown data file revision.\n" );
        *ExitCode = 1;
        return FALSE;

    case DataFileRevisionLanman20 :

        if( _NextReadOffset == 0 ) {

            // This is the first read, so we skip over the header
            // information.

            _NextReadOffset = LM20_BACKACC_HEADER_SIZE +
                                LM20_INDEX_SIZE * LM20_NINDEX;

        }

        if( !_DataFileStream->MovePointerPosition( _NextReadOffset,
                                                   STREAM_BEGINNING ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        if( _DataFileStream->IsAtEnd() ) {

            // No more entries to read.

            *ExitCode = 0;
            return FALSE;
        }

        // Read the resource header information.

        if( !_DataFileStream->Read( (PBYTE)&ResourceInfo,
                                    LM20_RESOURCE_INFO_HEADER_SIZE,
                                    &BytesRead ) ||
            BytesRead != LM20_RESOURCE_INFO_HEADER_SIZE ) {

            *ExitCode = 1;
            return FALSE;
        }


        // Read the name and initialize ResourceString
        //
        memset( WideResourceName, 0, sizeof( WideResourceName ) );

        if( ResourceInfo.namelen > MAX_RESOURCE_NAME_LENGTH ||
            !_DataFileStream->Read( (PBYTE)ResourceName,
                                    ResourceInfo.namelen,
                                    &BytesRead ) ||
            BytesRead != ResourceInfo.namelen ||
            !MultiByteToWideChar( _SourceCodepage,
                                  0,
                                  ResourceName,
                                  strlen( ResourceName ),
                                  WideResourceName,
                                  MAX_RESOURCE_NAME_LENGTH ) ||
            !ResourceString->Initialize( WideResourceName ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        // Read the access entries

        if( (ULONG)ResourceInfo.acc1_count > MaxEntries ||
            !_DataFileStream->Read( (PBYTE)AccessEntries,
                                    ResourceInfo.acc1_count *
                                        LM_ACCESS_LIST_SIZE,
                                    &BytesRead ) ||
            BytesRead != (ULONG)( ResourceInfo.acc1_count * LM_ACCESS_LIST_SIZE ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        *AccessEntryCount = ResourceInfo.acc1_count;
        *AuditInfo = ResourceInfo.acc1_attr;

        _NextReadOffset += LM20_RESOURCE_INFO_HEADER_SIZE +
                            ResourceInfo.namelen +
                            ResourceInfo.acc1_count * LM_ACCESS_LIST_SIZE;

        return TRUE;

    case DataFileRevisionLanman21 :

        while( _NextReadOffset == 0 || _BytesRemainingInCurrentGroup == 0 ) {

            // The current offset is at the beginning of a group.  If
            // this also the end of the file, there are no more records
            // to read; otherwise, read the header of this group.

            if( !_DataFileStream->MovePointerPosition( _NextReadOffset,
                                                       STREAM_BEGINNING ) ) {

                *ExitCode = 1;
                return FALSE;
            }

            if( _DataFileStream->IsAtEnd() ) {

                // No more entries to read.

                *ExitCode = 0;
                return FALSE;
            }

            if( !_DataFileStream->Read( (PBYTE)&Lm21Header,
                                        LM21_ACLHDR_SIZE,
                                        &BytesRead ) ||
                BytesRead != LM21_ACLHDR_SIZE ) {

                *ExitCode = 1;
                return FALSE;
            }

            _NextReadOffset += LM21_ACLHDR_SIZE;
            _BytesRemainingInCurrentGroup = Lm21Header.NxtHdr -
                                            _NextReadOffset;
        }

        // Read the ACL Record

        if( !_DataFileStream->Read( (PBYTE)&Lm21AclRec,
                                    LM21_ACLREC_SIZE,
                                    &BytesRead ) ||
            BytesRead != LM21_ACLREC_SIZE ) {

            *ExitCode = 1;
            return FALSE;
        }

        TotalBytesRead = BytesRead;

        // Read the name and initialize ResourceString

        if( Lm21AclRec.NameBytes > MAX_RESOURCE_NAME_LENGTH ||
            !_DataFileStream->Read( (PBYTE)ResourceName,
                                    Lm21AclRec.NameBytes,
                                    &BytesRead ) ||
            BytesRead != (ULONG)Lm21AclRec.NameBytes ) {

            *ExitCode = 1;
            return FALSE;
        }

        if( !UpdateAndQueryCurrentLM21Name( Lm21AclRec.DirLvl,
                                            ResourceName,
                                            ResourceString ) ) {

            *ExitCode = 1;
            return FALSE;
        }


        TotalBytesRead += BytesRead;

        // Read the access entries:
        //
        if( Lm21AclRec.AclCnt == -1 ) {

            *AccessEntryCount = 0;
            *AuditInfo = 0;

        } else {

            if( (ULONG)Lm21AclRec.AclCnt > MaxEntries ||
                !_DataFileStream->Read( (PBYTE)AccessEntries,
                                         Lm21AclRec.AclCnt *
                                            LM_ACCESS_LIST_SIZE,
                                        &BytesRead ) ||
                BytesRead != (ULONG)( Lm21AclRec.AclCnt * LM_ACCESS_LIST_SIZE ) ) {

                *ExitCode = 1;
                return FALSE;
            }

            TotalBytesRead += BytesRead;

            *AccessEntryCount = Lm21AclRec.AclCnt;
            *AuditInfo = Lm21AclRec.AuditAttrib;
        }


        // Check that this read didn't overflow the current group--if
        // it did, the file format is not as expected.

        if( TotalBytesRead > _BytesRemainingInCurrentGroup )  {

            *ExitCode = 1;
            return FALSE;
        }

        _NextReadOffset += TotalBytesRead;
        _BytesRemainingInCurrentGroup -= TotalBytesRead;


        return TRUE;

    default:

        *ExitCode = 1;
        return FALSE;

    }
}

BOOLEAN
ACLCONV::ReadAclWorkSids(
    )
{
    WORD n_entries;
    ULONG n_read;
    ULONG i;
    USHORT name_len;
    WCHAR name[64];
    DSTRING Name;
    PSID pSid;
    ULONG sid_len;

    DSTRING Domain;

    if (!Domain.Initialize("UserConv")) {
        DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return FALSE;
    }

    if (!_AclWorkStream->Read((PUCHAR)&n_entries, sizeof(WORD), &n_read) ||
        n_read != sizeof(WORD)) {
        DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
            "%W", _AclWorkPath.GetPathString());
        return FALSE;
    }

    if (!_AclWorkSids.Initialize(n_entries)) {
        DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return FALSE;
    }

    //
    // Read each entry from the aclwork.dat file and add it to this
    // sid cache.
    //

    for (i = 0; i < n_entries; ++i) {

        // read the length of the name

        if (!_AclWorkStream->Read((PUCHAR)&name_len, sizeof(name_len),
            &n_read) || n_read != sizeof(name_len)) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        // read the name

        if (!_AclWorkStream->Read((PUCHAR)name, name_len, &n_read) ||
            n_read != name_len) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }
        name[name_len / sizeof(WCHAR)] = UNICODE_NULL;

        if (!Name.Initialize(name)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            return FALSE;
        }

        if (!_AclWorkStream->Read((PUCHAR)&sid_len, sizeof(sid_len), &n_read) ||
            n_read != sizeof(sid_len)) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        pSid = (PSID)MALLOC(sid_len);
        if (NULL == pSid) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);

            return FALSE;
        }

        if (!_AclWorkStream->Read((PUCHAR)pSid, sid_len, &n_read) ||
            n_read != sid_len) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        DebugAssert(RtlValidSid(pSid));

        if (!_AclWorkSids.CacheSid( &Domain, &Name, pSid, sid_len)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            return FALSE;
        }

        FREE(pSid);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asrsfgen\asrsfgen.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asrsfgen.cpp

Abstract:

    Utility program to generate an ASR state-file (asr.sif)

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include "critdrv.h"
#include "log.h"


BOOL
pAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    if (!bResult) {
        AsrpPrintDbgMsg(s_Warning, "AdjustTokenPrivileges for %ws failed (%lu)", 
            szPrivilegeName, 
            GetLastError()
            );
     }


    CloseHandle(hToken);
    return bResult;
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )

/*++

Routine Description:
    
    Entry point to asrsfgen.exe.  Generates an asr.sif file using the ASR API.

    Takes an optional command-line parameter to specify the location where the
    asr.sif is to be generated.  The default location is 
    %systemroot%\repair\asr.sif.

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/

{

    DWORD_PTR asrContext = 0;
    
    LPWSTR szCriticalVolumes = NULL;
    
    BOOL bResult = FALSE;

    int iReturn = 0;

    AsrpInitialiseLogFiles();

    AsrpPrintDbgMsg(s_Info, "Creating ASR state file at %ws",
        (argc > 1 ? argv[1] : L"default location (%systemroot%\\repair\\asr.sif)")
        );

    //
    // We need to acquire the backup privileges to create asr.sif
    //
    if (!pAcquirePrivilege(SE_BACKUP_NAME)) {
        AsrpPrintDbgMsg(s_Error, "Could not get backup privilege (%lu)", GetLastError());
        return ERROR_PRIVILEGE_NOT_HELD;
    }
    

    //
    // Get the critical volume list
    //
    szCriticalVolumes = pFindCriticalVolumes();

    if (!szCriticalVolumes) {
        AsrpPrintDbgMsg(s_Warning, "Critical Volume List is NULL");
    }

    //
    // Create the state file
    //
    bResult = AsrCreateStateFile(
        (argc > 1 ? argv[1] : NULL),    // sif path
        L"ASR Sif Generation Test Application v 0.1",    // Provider name
        TRUE,                           // auto-extend
        szCriticalVolumes,              // list of critical volumes
        &asrContext
        );

    if (!bResult) {
        AsrpPrintDbgMsg(s_Error, "Could not create state file (%lu == 0x%x)", GetLastError(), GetLastError());
        iReturn = 1;
    }
    else {
        AsrpPrintDbgMsg(s_Info, "ASR state file successfully created");
    }


    //
    // We're done with these, clean them up
    //
    if (szCriticalVolumes) {
      delete szCriticalVolumes;
      szCriticalVolumes = NULL;
    }
 
    AsrFreeContext(&asrContext);
    AsrpCloseLogFiles();

   return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asrsfgen\critdrv.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    critdrv.cpp

Abstract:
    
    This module contains routines create a list of the critical volumes on a 
    system.  This is lifted directly from base\fs\utils\ntback50\ui.

Author:

    Brian Berkowitz   (brianb)    10-Mar-2000

Environment:

    User-mode only.

Revision History:

    10-Mar-2000 brianb
        Initial creation

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <objbase.h>
#include <initguid.h>
#include <frsapip.h>
#include <critdrv.h>



// FRS iteration class.  Used to iterate through replica sets to
// determine the paths for these replica sets
// constructor
CFRSIter::CFRSIter() :
    m_fInitialized(FALSE),
    m_hLib(NULL),
    m_pfnFrsInitBuRest(NULL),
    m_pfnFrsEndBuRest(NULL),
    m_pfnFrsGetSets(NULL),
    m_pfnFrsEnumSets(NULL),
    m_pfnFrsIsSetSysVol(NULL),
    m_pfnFrsGetPath(NULL),
    m_pfnFrsGetOtherPaths(NULL),
    m_stateIteration(x_IterNotStarted)
    {
    }

// destructor
CFRSIter::~CFRSIter()
    {
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    if (m_hLib)
        FreeLibrary(m_hLib);
    }

// initialize entry points and load library
void CFRSIter::Init()
    {
    if (m_fInitialized)
        return;

    // load library
    m_hLib = LoadLibrary(L"ntfrsapi.dll");
    if (m_hLib)
        {
        // assign etntry points
        m_pfnFrsInitBuRest = (PF_FRS_INIT) GetProcAddress(m_hLib, "NtFrsApiInitializeBackupRestore");
        m_pfnFrsEndBuRest = (PF_FRS_DESTROY) GetProcAddress(m_hLib, "NtFrsApiDestroyBackupRestore");
        m_pfnFrsGetSets = (PF_FRS_GET_SETS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSets");
        m_pfnFrsEnumSets = (PF_FRS_ENUM_SETS) GetProcAddress(m_hLib, "NtFrsApiEnumBackupRestoreSets");
        m_pfnFrsIsSetSysVol = (PF_FRS_IS_SYSVOL) GetProcAddress(m_hLib, "NtFrsApiIsBackupRestoreSetASysvol");
        m_pfnFrsGetPath = (PF_FRS_GET_PATH) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetDirectory");
        m_pfnFrsGetOtherPaths = (PF_FRS_GET_OTHER_PATHS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetPaths");
        if (m_pfnFrsInitBuRest == NULL ||
            m_pfnFrsEndBuRest == NULL ||
            m_pfnFrsGetSets == NULL ||
            m_pfnFrsEnumSets == NULL ||
            m_pfnFrsIsSetSysVol == NULL ||
            m_pfnFrsGetOtherPaths == NULL ||
            m_pfnFrsGetPath == NULL)
            {
            // if we can't get to any entry point, free library and
            // fail operation
            FreeLibrary(m_hLib);
            m_hLib = NULL;
            }
        }

    // indicate that operation is successful
    m_fInitialized = TRUE;
    }


// initialize the iterator.  Return FALSE if iterator is known to be empty
//
BOOL CFRSIter::BeginIteration()
    {
    ASSERT(m_stateIteration == x_IterNotStarted);
    DWORD status;
    if (m_hLib == NULL)
        {
        // if we are not initialized, then there is nothing to iterate
        // over
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // initialize FRS backup restore apis
    status = m_pfnFrsInitBuRest
                    (
                    NULL,
                    NTFRSAPI_BUR_FLAGS_NORMAL|NTFRSAPI_BUR_FLAGS_BACKUP,
                    &m_frs_context
                    );

    if (status != ERROR_SUCCESS)
        {
        // if this fails then we are done
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // indicate that we started the iteration
    m_stateIteration = x_IterStarted;
    status = m_pfnFrsGetSets(m_frs_context);
    if (status != ERROR_SUCCESS)
        {
        // if there are no sets, then indicate we are done
        CleanupIteration();
        return FALSE;
        }

    // start at first set
    m_iset = 0;
    return TRUE;
    }

// cleanup iteration after scanning the last element
void CFRSIter::CleanupIteration()
    {
    m_pfnFrsEndBuRest(&m_frs_context, NTFRSAPI_BUR_FLAGS_NONE, NULL, NULL, NULL);
    m_stateIteration = x_IterComplete;
    }


// get next iteration set returning the path to the set
// NULL indicates end of iteration
// If fSkipToSysVol is TRUE then ignore non SysVol replication sets
LPWSTR CFRSIter::GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths)
    {
    ASSERT(pwszPaths);
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterComplete)
        // if iteration is complete, then we are done
        return NULL;

    PVOID frs_set;

    while(TRUE)
        {
        // get a set
        DWORD status = m_pfnFrsEnumSets(m_frs_context, m_iset, &frs_set);
        if (status != ERROR_SUCCESS)
            {
            // if this fails, then we are done
            CleanupIteration();
            return NULL;
            }

        if (fSkipToSysVol)
            {
            // we are looking for system volumes
            BOOL fSysVol;

            // test whether this is a system volume
            status = m_pfnFrsIsSetSysVol(m_frs_context, frs_set, &fSysVol);
            if (status != ERROR_SUCCESS)
                {
                // if this operation fails, terminate iteration
                CleanupIteration();
                return NULL;
                }

            if (!fSysVol)
                {
                // if not a system volume, then skip to the next
                // replica set
                m_iset++;
                continue;
                }
            }


        // scratch pad for path
        WCHAR wsz[MAX_PATH];
        DWORD cbPath = MAX_PATH * sizeof(WCHAR);

        // get path to root of the replica set
        status = m_pfnFrsGetPath
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz
            );

        WCHAR *wszNew = NULL;
        // allocate memory for root
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            wszNew = new WCHAR[cbPath/sizeof(WCHAR)];

            // if allocation fails, then throw OOM
            if (wszNew == NULL)
                throw E_OUTOFMEMORY;

            if (status == ERROR_SUCCESS)
                // if the operation was successful, then copy
                // path into memory
                memcpy(wszNew, wsz, cbPath);
            else
                {
                // otherwise redo the operation
                status = m_pfnFrsGetPath
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew
                    );

                if (status != ERROR_SUCCESS)
                    {
                    // if operation failed then second time, then
                    // delete allocated memory and terminate iteration
                    delete wszNew;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if operation failed due to any error other than
            // insufficient buffer, then terminate the iteration
            CleanupIteration();
            return NULL;
            }


        // scratch pad for filters
        WCHAR wszFilter[MAX_PATH];
        DWORD cbFilter = MAX_PATH * sizeof(WCHAR);

        // length of scratch pad for paths
        cbPath = MAX_PATH * sizeof(WCHAR);

        // obtain other paths
        status = m_pfnFrsGetOtherPaths
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz,
            &cbFilter,
            wszFilter
            );

        WCHAR *wszNewPaths = NULL;
        WCHAR *wszNewFilter = NULL;
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            // allocate space for paths
            wszNewPaths = new WCHAR[cbPath/sizeof(WCHAR)];

            // allocate space for filters
            wszNewFilter = new WCHAR[cbFilter/sizeof(WCHAR)];
            if (wszNew == NULL || wszFilter == NULL)
                {
                // if any allocation fails, then throw OOM
                delete wszNew;
                throw E_OUTOFMEMORY;
                }

            if (status == ERROR_SUCCESS)
                {
                // if operation was successful, then copy
                // in allocated paths
                memcpy(wszNewPaths, wsz, cbPath);
                memcpy(wszNewFilter, wszFilter, cbFilter);
                }
            else
                {
                status = m_pfnFrsGetOtherPaths
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew,
                    &cbFilter,
                    wszNewFilter
                    );

                if (status != ERROR_SUCCESS)
                    {
                    delete wszNew;
                    delete wszNewFilter;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if any error other than success or INSUFFICENT_BUFFER
            // then terminate iteration
            CleanupIteration();
            return NULL;
            }

        // delete allocated filter
        delete wszNewFilter;

        // set iteration to next set
        m_iset++;

        // return pointer to paths
        *pwszPaths = wszNewPaths;

        // return path of root of replicated set
        return wszNew;
        }
    }


// terminate iteration, cleaning up anything that needs to be
// cleaned up
//
void CFRSIter::EndIteration()
    {
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    // indicate that iteration is no longer in progress
    m_stateIteration = x_IterNotStarted;
    }

// constructor for string data structure
CWStringData::CWStringData()
    {
    m_psdlFirst = NULL;
    m_psdlCur = NULL;
    }

// destructor
CWStringData::~CWStringData()
    {
    while(m_psdlFirst)
        {
        WSTRING_DATA_LINK *psdl = m_psdlFirst;
        m_psdlFirst = m_psdlFirst->m_psdlNext;
        delete psdl;
        }
    }

// allocate a new link
void CWStringData::AllocateNewLink()
    {
    WSTRING_DATA_LINK *psdl = new WSTRING_DATA_LINK;
    if (psdl == NULL)
        throw E_OUTOFMEMORY;

    psdl->m_psdlNext = NULL;
    if (m_psdlCur)
        {
        ASSERT(m_psdlFirst);
        m_psdlCur->m_psdlNext = psdl;
        m_psdlCur = psdl;
        }
    else
        {
        ASSERT(m_psdlFirst == NULL);
        m_psdlFirst = m_psdlCur = psdl;
        }

    m_ulNextString = 0;
    }

// allocate a string
LPWSTR CWStringData::AllocateString(unsigned cwc)
    {
    ASSERT(cwc <= sizeof(m_psdlCur->rgwc));

    if (m_psdlCur == NULL)
        AllocateNewLink();

    if (sizeof(m_psdlCur->rgwc) <= (cwc + 1 + m_ulNextString) * sizeof(WCHAR))
        AllocateNewLink();

    unsigned ulOff = m_ulNextString;
    m_ulNextString += cwc + 1;
    return m_psdlCur->rgwc + ulOff;
    }

// copy a string
LPWSTR CWStringData::CopyString(LPCWSTR wsz)
    {
    unsigned cwc = (wsz == NULL) ? 0 : wcslen(wsz);
    LPWSTR wszNew = AllocateString(cwc);
    memcpy(wszNew, wsz, cwc * sizeof(WCHAR));
    wszNew[cwc] = '\0';
    return wszNew;
    }


// constructor for volume list
CVolumeList::CVolumeList() :
    m_rgwszVolumes(NULL),       // array of volumes
    m_cwszVolumes(0),           // # of volumes in array
    m_cwszVolumesMax(0),        // size of array
    m_rgwszPaths(NULL),         // array of paths
    m_cwszPaths(0),             // # of paths in array
    m_cwszPathsMax(0)           // size of array
    {
    }

// destructor
CVolumeList::~CVolumeList()
    {
    delete m_rgwszPaths;        // delete paths array
    delete m_rgwszVolumes;      // delete volumes array
    }

// add a path to the list if it is not already there
// return TRUE if it is a new path
// return FALSE if path is already in list
//
BOOL CVolumeList::AddPathToList(LPWSTR wszPath)
    {
    // look for path in list.  If found, then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszPaths; iwsz++)
        {
        if (_wcsicmp(wszPath, m_rgwszPaths[iwsz]) == 0)
            return FALSE;
        }

    // grow pat array if needed
    if (m_cwszPaths == m_cwszPathsMax)
        {
        // grow path array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszPaths + x_cwszPathsInc];

        // throw OOM if memory allocation fails
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszPaths, m_cwszPaths * sizeof(LPCWSTR));
        delete m_rgwszPaths;
        m_rgwszPaths = rgwsz;
        m_cwszPathsMax += x_cwszPathsInc;
        }

    // add path to array
    m_rgwszPaths[m_cwszPaths++] = m_sd.CopyString(wszPath);
    return TRUE;
    }

// add a volume to the list if it is not already there
// return TRUE if it is added
// return FALSE if it is already on the list
//
BOOL CVolumeList::AddVolumeToList(LPCWSTR wszVolume)
    {
    // look for volume in array.  If found then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        if (_wcsicmp(wszVolume, m_rgwszVolumes[iwsz]) == 0)
            return FALSE;
        }

    // grow volume array if necessary
    if (m_cwszVolumes == m_cwszVolumesMax)
        {
        // grow volume array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszVolumes + x_cwszVolumesInc];
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszVolumes, m_cwszVolumes * sizeof(LPCWSTR));
        delete m_rgwszVolumes;
        m_rgwszVolumes = rgwsz;
        m_cwszVolumesMax += x_cwszVolumesInc;
        }

    // add volume name to array
    m_rgwszVolumes[m_cwszVolumes++] = m_sd.CopyString(wszVolume);
    return TRUE;
    }


const WCHAR x_wszVolumeRootName[] = L"\\\\?\\GlobalRoot\\Device\\";
const unsigned x_cwcVolumeRootName = sizeof(x_wszVolumeRootName)/sizeof(WCHAR) - 1;

// add a path to our tracking list.  If the path is new add it to the
// paths list.  If it is a mount point or the root of a volume, then
// determine the volume and add the volume to the list of volumes
//
// can throw E_OUTOFMEMORY
//
void CVolumeList::AddPath(LPWSTR wszTop)
    {
    // if path is known about then return
    if (!AddPathToList(wszTop))
        return;

    // length of path
    unsigned cwc = wcslen(wszTop);

    // copy path so that we can add backslash to the end of the path
    LPWSTR wszCopy = new WCHAR[cwc + 2];

    // if fails, then throw OOM
    if (wszCopy == NULL)
        throw E_OUTOFMEMORY;

    // copyh in original path
    memcpy(wszCopy, wszTop, cwc * sizeof(WCHAR));

    // append backslash
    wszCopy[cwc] = L'\\';
    wszCopy[cwc + 1] = L'\0';
    while(TRUE)
        {
        // check for a device root
        unsigned cwc = wcslen(wszCopy);
        if ((cwc == 3 && wszCopy[1] == ':') ||
            (cwc > x_cwcVolumeRootName &&
             memcmp(wszCopy, x_wszVolumeRootName, x_cwcVolumeRootName * sizeof(WCHAR)) == 0))
            {
            // call TryAddVolume with TRUE indicating this is a volume root
            TryAddVolumeToList(wszCopy, TRUE);
            break;
            }

        // call TryAddVolume indicating this is not a known device root
        if (TryAddVolumeToList(wszCopy, FALSE))
            break;

        // move back to previous backslash
        WCHAR *pch = wszCopy + cwc - 2;
        while(--pch > wszTop)
            {
            if (pch[1] == L'\\')
                {
                pch[2] = L'\0';
                break;
                }
            }

        if (pch == wszTop)
            break;

        // if path is known about then return
        if (!AddPathToList(wszCopy))
            break;
        }
    }



// determine if a path is a volume.  If so then add it to the volume
// list and return TRUE.  If not, then return FALSE.  fVolumeRoot indicates
// that the path is of the form x:\.  Otherwise the path is potentially
// an mount point.  Validate that it is a reparse point and then try
// finding its volume guid.  If this fails, then assume that it is not
// a volume root.  If it succeeds, then add the volume guid to the volumes
// list and return TRUE.
//
BOOL CVolumeList::TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot)
    {
    WCHAR wszVolume[256];

    if (fVolumeRoot)
        {
        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            // might be the EFI system partition, just pass in the path as the volume string.
            wcscpy( wszVolume, wszPath );            
            //throw E_UNEXPECTED;
        }
    else
        {
        DWORD dw = GetFileAttributes(wszPath);
        if (dw == -1)
            return FALSE;

        if ((dw & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
            return FALSE;

        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            return FALSE;
        }

    AddVolumeToList(wszVolume);
    return TRUE;
    }


// add a file to the volume list.  Simply finds the parent path and adds it
//
void CVolumeList::AddFile(LPWSTR wsz)
    {
    unsigned cwc = wcslen(wsz);
    WCHAR *pwc = wsz + cwc - 1;
    while(pwc[1] != L'\\' && pwc != wsz)
        continue;

    pwc[1] = '\0';
    AddPath(wsz);
    }

// obtain list of volumes as a MULTI_SZ,  caller is responsible for freeing
// the string
//
LPWSTR CVolumeList::GetVolumeList()
    {
    unsigned cwc = 1;

    // compute length of volume list it is length of each string +
    // null character + null charactor for last double NULL
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        cwc += wcslen(m_rgwszVolumes[iwsz]) + 1;

    // allocate string
    LPWSTR wsz = new WCHAR[cwc];

    // throw OOM if memory allocation failed
    if (wsz == NULL)
        throw E_OUTOFMEMORY;

    // copy in strings
    WCHAR *pwc = wsz;
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        cwc = wcslen(m_rgwszVolumes[iwsz]) + 1;
        memcpy(pwc, m_rgwszVolumes[iwsz], cwc * sizeof(WCHAR));
		/* replace \\?\ with \??\ */
		memcpy(pwc, L"\\??", sizeof(WCHAR) * 3);

		// delete trailing backslash if it exists
		if (pwc[cwc - 2] == L'\\')
			{
			pwc[cwc-2] = L'\0';
			cwc--;
			}

        pwc += cwc;
        }

    // last null termination
    *pwc = L'\0';

    return wsz;
    }


// path to volume of boot device is
// HKEY_LOCAL_MACHINE\System\Setup
//with Value of SystemPartition parametr
LPCWSTR x_SetupRoot = L"System\\Setup";

// magic perfix for volume devices
WCHAR x_wszWin32VolumePrefix[] = L"\\\\?\\GlobalRoot";
const unsigned x_cwcWin32VolumePrefix = sizeof(x_wszWin32VolumePrefix)/sizeof(WCHAR) - 1;

// structure representing a path from
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
// and a value to look up
typedef struct _SVCPARM
    {
    LPCWSTR wszPath;
    LPCWSTR wszValue;
    } SVCPARM;


const SVCPARM x_rgdbparms[] =
    {
        {L"CertSvc\\Configuration", L"DBDirectory"},
        {L"CertSvc\\Configuration", L"DBLogDirectory"},
        {L"CertSvc\\Configuration", L"DBSystemDirectory"},
        {L"CertSvc\\Configuration", L"DBTempDirectory"},
        {L"DHCPServer\\Parameters", L"DatabasePath"},
        {L"DHCPServer\\Parameters", L"DatabaseName"},
        {L"DHCPServer\\Parameters", L"BackupDatabasePath"},
        {L"NTDS\\Parameters", L"Database backup path"},
        {L"NTDS\\Parameters", L"Databases log files path"},
        {L"Ntfrs\\Parameters\\Replica Sets", L"Database Directory"}
    };

const unsigned x_cdbparms = sizeof(x_rgdbparms)/sizeof(SVCPARM);

LPCWSTR x_wszSvcRoot = L"System\\CurrentControlSet\\Services";

// add roots for various services
BOOL AddServiceRoots(CVolumeList &vl)
    {
    HKEY hkeyRoot;
    // open HKLM\System\CurrentControlSet\Services
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_wszSvcRoot, &hkeyRoot) != ERROR_SUCCESS)
        return FALSE;

    // loop through individual paths
    for(unsigned i = 0; i < x_cdbparms; i++)
        {
        WCHAR wsz[MAX_PATH*4];
        LPCWSTR wszPath = x_rgdbparms[i].wszPath;
        LPCWSTR wszValue = x_rgdbparms[i].wszValue;

        HKEY hkey;
        DWORD cb = sizeof(wsz);
        DWORD type;

        // open path, skip if open fails
        if (RegOpenKey(hkeyRoot, wszPath, &hkey) != ERROR_SUCCESS)
            continue;

        // add path to volume list if query succeeds
        if (RegQueryValueEx
                (
                hkey,
                wszValue,
                NULL,
                &type,
                (BYTE *) wsz,
                &cb
                ) == ERROR_SUCCESS)
            vl.AddPath(wsz);

        // close key
        RegCloseKey(hkey);
        }

    // close root key
    RegCloseKey(hkeyRoot);
    return TRUE;
    }


// add volume root of SystemDrive (drive wee boot off of
BOOL AddSystemPartitionRoot(CVolumeList &vl)
    {
    HKEY hkeySetup;
    WCHAR wsz[MAX_PATH];

    // open HKLM\System\Setup
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_SetupRoot, &hkeySetup) != ERROR_SUCCESS)
        return FALSE;

    DWORD cb = sizeof(wsz);
    DWORD type;

    // query SystemPartition value
    if (RegQueryValueEx
            (
            hkeySetup,
            L"SystemPartition",
            NULL,
            &type,
            (BYTE *) wsz,
            &cb
            ) != ERROR_SUCCESS)
        {
        // if fails, return FALSE
        RegCloseKey(hkeySetup);
        return FALSE;
        }

    // compute size of needed buffer
    unsigned cwc = wcslen(wsz);
    unsigned cwcNew = x_cwcWin32VolumePrefix + cwc + 1;
    LPWSTR wszNew = new WCHAR[cwcNew];

    // return failure if memory allocation fials
    if (wszNew == NULL)
        return FALSE;

    // append \\?\GlobalRoot\ to device name
    memcpy(wszNew, x_wszWin32VolumePrefix, x_cwcWin32VolumePrefix * sizeof(WCHAR));
    memcpy(wszNew + x_cwcWin32VolumePrefix, wsz, cwc * sizeof(WCHAR));
    RegCloseKey(hkeySetup);
    wszNew[cwcNew-1] = L'\0';
    try {        
        // add path based on device root
        vl.AddPath(wszNew);
    } catch(...)
        {
        delete wszNew;
        return FALSE;
        }

    // delete allocated memory
    delete wszNew;
    return TRUE;
    }

// find critical volumes.  Return multistring of volume names
// using guid naming convention
LPWSTR pFindCriticalVolumes()
    {
    WCHAR wsz[MAX_PATH * 4];

    // find location of system root
    if (!ExpandEnvironmentStrings(L"%systemroot%", wsz, sizeof(wsz)/sizeof(WCHAR)))
        {
        wprintf(L"ExpandEnvironmentStrings failed for reason %d", GetLastError());
        return NULL;
        }

    CVolumeList vl;
    LPWSTR wszPathsT = NULL;
    LPWSTR wszT = NULL;

    try
        {
        // add boot drive
        if (!AddSystemPartitionRoot(vl))
            return NULL;

        // add roots for various services
        if (!AddServiceRoots(vl))
            return NULL;

        // add systemroot drive
        vl.AddPath(wsz);

            {
            // add roots for SYSVOL
            CFRSIter fiter;
            fiter.Init();
            fiter.BeginIteration();
            while(TRUE)
                {
                wszT = fiter.GetNextSet(TRUE, &wszPathsT);
                if (wszT == NULL)
                    break;

                vl.AddPath(wszT);
                LPWSTR wszPathT = wszPathsT;
                while(*wszPathT != NULL)
                    {
                    vl.AddPath(wszPathT);
                    wszPathT += wcslen(wszPathT);
                    }

                delete wszT;
                delete wszPathsT;
                wszT = NULL;
                wszPathsT = NULL;
                }

            fiter.EndIteration();
            }
        }
    catch(...)
        {
        delete wszT;
        delete wszPathsT;
        }

    // return volume list
    return vl.GetVolumeList();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\volinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Udfs called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     20-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VOLINFO)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VOLINFO)

//
//  Local support routines
//

NTSTATUS
UdfQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonQueryVolInfo)
#pragma alloc_text(PAGE, UdfQueryFsAttributeInfo)
#pragma alloc_text(PAGE, UdfQueryFsDeviceInfo)
#pragma alloc_text(PAGE, UdfQueryFsSizeInfo)
#pragma alloc_text(PAGE, UdfQueryFsVolumeInfo)
#endif


NTSTATUS
UdfCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;

    //
    //  Decode the file object and fail if this an unopened file object.
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen == UnopenedFileObject) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Vcb for this volume.
    //

    UdfAcquireVcbShared( IrpContext, Fcb->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsSizeInformation:

            Status = UdfQueryFsSizeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsVolumeInformation:

            Status = UdfQueryFsVolumeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = UdfQueryFsDeviceInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = UdfQueryFsAttributeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Fcb->Vcb );
    }

    //
    //  Complete the request if we didn't raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill in the data from the Vcb.
    //

    Buffer->VolumeCreationTime = Vcb->VolumeDasdFcb->Timestamps.CreationTime;
    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );

    //
    //  Check if the buffer we're given is long enough
    //

    if (*Length >= (ULONG) Vcb->Vpb->VolumeLabelLength) {

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       &Vcb->Vpb->VolumeLabel[0],
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Fill in the output buffer.
    //

    Buffer->TotalAllocationUnits.QuadPart = LlBlocksFromBytes( Vcb, Vcb->VolumeDasdFcb->AllocationSize.QuadPart );

    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = SectorsFromBytes( Vcb, BlockSize( Vcb ));
    Buffer->BytesPerSector = SectorSize( Vcb );

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Update the output buffer.
    //

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;
    Buffer->DeviceType = FILE_DEVICE_CD_ROM;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill out the fixed portion of the buffer.
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
                                   FILE_UNICODE_ON_DISK |
                                   FILE_READ_ONLY_VOLUME;

    Buffer->MaximumComponentNameLength = 255;

    *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName );

    //
    //  Make sure we can copy full unicode characters.
    //

    ClearFlag( *Length, 1 );

    //
    //  Determine how much of the file system name will fit.
    //

    if (*Length >= 6) {

        BytesToCopy = 6;

    } else {

        BytesToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    *Length -= BytesToCopy;

    //
    //  Do the file system name.  We explicitly share this designation with all
    //  Microsoft implementations of the UDF filesystem - DO NOT CHANGE!
    //

    Buffer->FileSystemNameLength = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"UDF", BytesToCopy );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\workque.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Udfs File
    system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_WORKQUE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_WORKQUE)

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

//
//  Local support routines
//

VOID
UdfAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfFsdPostRequest)
#pragma alloc_text(PAGE, UdfOplockComplete)
#pragma alloc_text(PAGE, UdfPrePostIrp)
#endif


NTSTATUS
UdfFsdPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp.

    Irp - I/O Request Packet.

Return Value:

    STATUS_PENDING

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Posting is a three step operation.  First lock down any buffers
    //  in the Irp.  Next cleanup the IrpContext for the post and finally
    //  add this to a workque.
    //

    UdfPrePostIrp( IrpContext, Irp );

    UdfAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}


VOID
UdfPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Case on the type of the operation.
    //

    switch (IrpContext->MajorFunction) {

    case IRP_MJ_CREATE :

        //
        //  If called from the oplock package then there is an
        //  Fcb to possibly teardown.  We will call the teardown
        //  routine and release the Fcb if still present.  The cleanup
        //  code in create will know not to release this Fcb because
        //  we will clear the pointer.
        //

        if ((IrpContext->TeardownFcb != NULL) &&
            *(IrpContext->TeardownFcb) != NULL) {

            UdfTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), FALSE, &RemovedFcb );

            if (!RemovedFcb) {

                UdfReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
            }

            *(IrpContext->TeardownFcb) = NULL;
            IrpContext->TeardownFcb = NULL;
        }

        break;

    //
    //  We need to lock the user's buffer, unless this is an MDL-read,
    //  in which case there is no user buffer.
    //

    case IRP_MJ_READ :

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            UdfLockUserBuffer( IrpContext, IrpSp->Parameters.Read.Length, IoWriteAccess );
        }

        break;
        
    case IRP_MJ_WRITE :

        UdfLockUserBuffer( IrpContext, IrpSp->Parameters.Write.Length, IoReadAccess );
        break;

    //
    //  We also need to check whether this is a query file operation.
    //
    
    case IRP_MJ_DIRECTORY_CONTROL :

        if (IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

            UdfLockUserBuffer( IrpContext, IrpSp->Parameters.QueryDirectory.Length, IoWriteAccess );
        }

        break;
    }
    //
    //  Cleanup the IrpContext for the post.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    UdfCleanupIrpContext( IrpContext, TRUE );

    //
    //  Mark the Irp to show that we've already returned pending to the user.
    //

    IoMarkIrpPending( Irp );

    return;
}


VOID
UdfOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

    If we are completing due to an error then check if there is any
    cleanup to do.

Arguments:

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check on the return value in the Irp.  If success then we
    //  are to post this request.
    //

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Check if there is any cleanup work to do.
        //

        switch (IrpContext->MajorFunction) {

        case IRP_MJ_CREATE :

            //
            //  If called from the oplock package then there is an
            //  Fcb to possibly teardown.  We will call the teardown
            //  routine and release the Fcb if still present.  The cleanup
            //  code in create will know not to release this Fcb because
            //  we will clear the pointer.
            //

            if (IrpContext->TeardownFcb != NULL) {

                UdfTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), FALSE, &RemovedFcb );

                if (!RemovedFcb) {

                    UdfReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
                }

                *(IrpContext->TeardownFcb) = NULL;
                IrpContext->TeardownFcb = NULL;
            }

            break;
        }
        //
        //  Insert the Irp context in the workqueue.
        //

        UdfAddToWorkque( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        UdfCompleteRequest( IrpContext, Irp, Irp->IoStatus.Status );
    }

    return;
}


//
//  Local support routine
//

VOID
UdfAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //

    if (IrpSp->FileObject != NULL) {


        Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                 VOLUME_DEVICE_OBJECT,
                                 DeviceObject );

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

        if (Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InsertTailList( &Vdo->OverflowQueue,
                            &IrpContext->WorkQueueItem.List );

            Vdo->OverflowQueueCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            //
            //  We are going to send this Irp to an ex worker thread so up
            //  the count.
            //

            Vdo->PostedRequestCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          UdfFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asrsfgen\critdrv.h ===
//-------------------------------------------------------------------
//
// critical drivers suppot
//

typedef struct _WSTRING_DATA_LINK
	{
	struct _WSTRING_DATA_LINK *m_psdlNext;
	WCHAR rgwc[2040];
	} WSTRING_DATA_LINK;


// class string data
class CWStringData
	{
public:
	// @cmember constructor
	CWStringData();

	// @cmember destructor
	~CWStringData();

	// @cmember allocate a string
	LPWSTR AllocateString(unsigned cwc);

	// @cmember copy a string
	LPWSTR CopyString(LPCWSTR wsz);

private:
	// @cmember allocate a new string data link
	void AllocateNewLink();

	// @cmember	current link
	WSTRING_DATA_LINK *m_psdlCur;

	// @cmember offset in current link for next string
	unsigned m_ulNextString;

	// @cmember first link
	WSTRING_DATA_LINK *m_psdlFirst;
	};



// list of critical volumes
class CVolumeList
	{
public:
	// constructor
	CVolumeList();

	// destructor
	~CVolumeList();

	// add a path to the volume list
	void AddPath(LPWSTR wszPath);

	// @cmember add a file to the volume list
	void AddFile(LPWSTR wszFile);

	// @cmember obtain list of volumes
	LPWSTR GetVolumeList();

private:
	enum
		{
		// amount to grow paths array by
		x_cwszPathsInc = 8,

		// amount to grow volumes array by
		x_cwszVolumesInc = 4
		};

	// determine if a path is a volume
	BOOL TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot);

	// determine if path is in the list; if not add it to list
	BOOL AddPathToList(LPWSTR wszPath);

	// @cmember determine if a volume is in the list; if not add it to the list
	BOOL AddVolumeToList(LPCWSTR wszVolume);

	// @cmember get volume from the path
	void GetVolumeFromPath(LPCWSTR wsz, LPWSTR wszVolumeName);

	// @cmember cached strings
	CWStringData m_sd;

	// volumes encountered so far
	LPCWSTR *m_rgwszVolumes;

	// # of volumes allocate
	unsigned m_cwszVolumes;

	// max # of volumes in array
	unsigned m_cwszVolumesMax;

	// paths encountered so far
	LPCWSTR *m_rgwszPaths;

	// # of paths encountered so far
	unsigned m_cwszPaths;

	// @cmember max # of paths in array
	unsigned m_cwszPathsMax;
	};


// FRS entry points
typedef DWORD ( WINAPI *PF_FRS_ERR_CALLBACK )( CHAR *, DWORD );
typedef DWORD ( WINAPI *PF_FRS_INIT )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_DESTROY )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
typedef DWORD ( WINAPI *PF_FRS_GET_SETS )( PVOID );
typedef DWORD ( WINAPI *PF_FRS_ENUM_SETS )( PVOID, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_IS_SYSVOL )( PVOID, PVOID, BOOL * );
typedef DWORD ( WINAPI *PF_FRS_GET_PATH )( PVOID, PVOID, DWORD *, WCHAR * ) ;
typedef DWORD ( WINAPI *PF_FRS_GET_OTHER_PATHS)(PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR *);

// iterate over frs drives
class CFRSIter
	{
public:
	// constructor
	CFRSIter();

	// destructor
	~CFRSIter();

	// initialization routine
	void Init();

	// initialize iterator
	BOOL BeginIteration();

	// end iteration
	void EndIteration();

	// obtain path to next replication set
	LPWSTR GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths);

private:
	// cleanup frs backup restore context
	void CleanupIteration();

	enum
		{
		x_IterNotStarted,
		x_IterStarted,
		x_IterComplete
		};

	// is this initialized
	BOOL m_fInitialized;
	HINSTANCE  m_hLib;
	DWORD ( WINAPI *m_pfnFrsInitBuRest )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsEndBuRest )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
	DWORD ( WINAPI *m_pfnFrsGetSets )( PVOID );
	DWORD ( WINAPI *m_pfnFrsEnumSets )( PVOID, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsIsSetSysVol )( PVOID, PVOID, BOOL * );
	DWORD ( WINAPI *m_pfnFrsGetPath )( PVOID, PVOID, DWORD *, WCHAR * ) ;
	DWORD ( WINAPI *m_pfnFrsGetOtherPaths) ( PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR * );

	// has iteration been started
	int m_stateIteration;

	// current set iterated
	unsigned m_iset;

	// context for iteration
	PVOID m_frs_context;
	};



LPWSTR pFindCriticalVolumes();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asrsfgen\log.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.cpp

Abstract:
    
    This module contains routines to log errors, warnings and info in the asr 
    log file at %systemroot%\repair\asr.log

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/

#include <stdio.h>
#include <windows.h>
#include <assert.h>
#include "log.h"

#define ASRSFGEN_ASR_ERROR_FILE_PATH  L"%SystemRoot%\\repair\\asr.err"
#define ASRSFGEN_ASR_LOG_FILE_PATH    L"%SystemRoot%\\repair\\asr.log"


//
// ----
// Data global to this module
// ----
//
BOOL Gbl_IsAsrEnabled = FALSE;
PWSTR Gbl_AsrErrorFilePath = NULL;
HANDLE Gbl_AsrLogFileHandle = NULL;


//
// ----
// Function implementations
// ----
//
VOID
AsrpLogMessage(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR Message
    ) 

/*++

Routine Description:
    
    Logs the message to the asr log file, and the asr error file if needed. 

    Note that AsrpInitialiseLogFile must have been called once before this 
    routine is used.

Arguments:

    Level - An enum specifying the level of the message being logged.  If 
            Level is set to s_Warning or s_Error, the Message is logged to the
            asr error file in addition to the asr log file.

    Message - The Message being logged.  This routine will add in the time-
            stamp at the beginning of each message.

Return Values:

    None.  If the log file couldn't be found, the message isn't logged.

--*/

{
    SYSTEMTIME Time;
    DWORD bytesWritten = 0;
    char buffer[4196];
    GetLocalTime(&Time);

    //
    // This needs to be fixed by the year 2100.
    //
    sprintf(buffer, "[%02hu%02hu%02hu %02hu%02hu%02hu sfgen] %s%s\r\n",
        Time.wYear % 2000, Time.wMonth, Time.wDay, 
        Time.wHour, Time.wMinute, Time.wSecond,
        ((s_Error == Level) ? "(ERROR) " :
            (s_Warning == Level ? "(warning) " : "")),
        Message
        );

    OutputDebugStringA(buffer);

    if (Gbl_AsrLogFileHandle) {
        WriteFile(Gbl_AsrLogFileHandle,
            buffer,
            (strlen(buffer) * sizeof(char)),
            &bytesWritten,
            NULL
            );
    }

    //
    // If this is a fatal error, we need to add to the error log.
    //
    if (((s_Error == Level) || (s_Warning == Level)) && 
        (Gbl_AsrErrorFilePath)
        ) {

        WCHAR buffer2[4196];

        HANDLE hFile = NULL;

        //
        // Open the error log
        //
        hFile = CreateFileW(
            Gbl_AsrErrorFilePath,           // lpFileName
            GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_ALWAYS,                  // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );
        if ((!hFile) || (INVALID_HANDLE_VALUE == hFile)) {
            return;
        }

        wsprintf(buffer2, L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu AsrSFGen] %ws%S\r\n",
            Time.wYear, Time.wMonth, Time.wDay, 
            Time.wHour, Time.wMinute, Time.wSecond,
            ((s_Error == Level) ? L"(ERROR) " :
                (s_Warning == Level ? L"(warning) " : L"")),
            Message
            );
        //
        // Move to the end of file
        //
        SetFilePointer(hFile, 0L, NULL, FILE_END);

        //
        // Add our error string
        //
        WriteFile(hFile,
            buffer2,
            (wcslen(buffer2) * sizeof(WCHAR)),
            &bytesWritten,
            NULL
            );

        //
        // And we're done
        // 
        CloseHandle(hFile);
    }
}


VOID
AsrpPrintDbgMsg(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR FormatString,
    ...
    )

/*++

Description:

    This prints a debug message AND makes the appropriate entries in the log 
    and error files.

Arguments:

    Level - Message Level (info, warning or error)

    FormatString - Formatted Message String to be printed.  The expanded 
            string should fit in a buffer of 4096 characters (including the
            terminating null character).

Return Values:
    
    None

--*/

{
    char str[4096];     // the message better fit in this
    va_list arglist;

    va_start(arglist, FormatString);
    wvsprintfA(str, FormatString, arglist);
    va_end(arglist);

    AsrpLogMessage(Level, str);
}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )

/*++

Routine Description:

    Expands any environment variables in the original string, replacing them
    with their defined values, and returns a pointer to a buffer containing 
    the result.

Arguments:

    OriginalString - Pointer to a null-terminated string that contains 
            environment variables of the form %variableName%.  For each such 
            reference, the %variableName% portion is replaced with the current
            value of that environment variable.  
            
            The replacement rules are the same as those used by the command 
            interpreter.  Case is ignored when looking up the environment-
            variable name.  If the name is not found, the %variableName% 
            portion is left undisturbed. 

Return Values:

    If this routine succeeds, the return value is a pointer to a buffer 
            containing a copy of OriginalString after all environment-variable
            name substitutions have been performed.  The caller is responsible
            for de-allocating this memory using HeapFree(GetProcessHeap(),...)
            when it is no longer needed.

    If the function fails, the return value is NULL. To get extended error 
            information, call GetLastError. 

--*/

{
    BOOL result = FALSE;

    UINT cchRequiredSize = 0,
        cchSize = MAX_PATH + 1;    // start with a reasonable default

    PWSTR expandedString = NULL;
    
    DWORD status = ERROR_SUCCESS;
    
    HANDLE hHeap = GetProcessHeap();

    //
    // Allocate some memory for the destination string
    // 
    expandedString = (PWSTR) HeapAlloc(
        hHeap, 
        HEAP_ZERO_MEMORY, 
        (cchSize * sizeof(WCHAR))
        );
    ErrExitCode(!expandedString, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try expanding.  If the buffer isn't big enough, we'll re-allocate.
    //
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(hHeap, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(
            hHeap, 
            HEAP_ZERO_MEMORY, 
            (cchSize * sizeof(WCHAR))
            );
        ErrExitCode(!expandedString, status, ERROR_NOT_ENOUGH_MEMORY);

        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );

        if (cchRequiredSize > cchSize) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
        }

    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try.  
        //
        if (expandedString) {
            HeapFree(hHeap, 0L, expandedString);
            expandedString = NULL;
        }
    }

EXIT:

    return expandedString;
}


VOID
AsrpInitialiseErrorFile(
    VOID
    ) 

/*++

Description:

    Creates an empty ASR error file at %systemroot%\repair\asr.err, and 
    initialises Gbl_AsrErrorFilePath with the full path to asr.err.  This 
    routine must be called once before AsrPrintDbgMsg is used.

Arguments:

    None

Return Values:
    
    None

--*/

{
    HANDLE errorFileHandle = NULL;

    //
    // Get full path to the error file.
    //
    Gbl_AsrErrorFilePath = AsrpExpandEnvStrings(ASRSFGEN_ASR_ERROR_FILE_PATH);
    if (!Gbl_AsrErrorFilePath) {
        return;
    }

    //
    // Create an empty file (append to it if it already exists), and close it
    // immediately
    //
    errorFileHandle = CreateFileW(
        Gbl_AsrErrorFilePath,           // lpFileName
        GENERIC_WRITE,                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );
    if ((errorFileHandle) && (INVALID_HANDLE_VALUE != errorFileHandle)) {
        CloseHandle(errorFileHandle);
    }
}


VOID
AsrpInitialiseLogFiles(
    VOID
    )

/*++

Description:

    This creates an ASR log file at %systemroot%\repair\asr.log, and 
    initialises Gbl_AsrLogFileHandle.  It also initialises the ASR error file 
    by calling AsrInitialiseErrorFile().
    
    This routine must be called once before AsrPrintDbgMsg is used.

Arguments:

    None

Return Values:
    
    None

--*/

{
    PWSTR asrLogFilePath = NULL;
    HANDLE hHeap = GetProcessHeap();
    DWORD bytesWritten;

    AsrpInitialiseErrorFile();

    Gbl_AsrLogFileHandle = NULL;
    //
    // Get full path to the error file.
    //
    asrLogFilePath = AsrpExpandEnvStrings(ASRSFGEN_ASR_LOG_FILE_PATH);
    if (!asrLogFilePath) {
        return;
    }

    //
    // Create an empty file (over-write it if it already exists).
    //
    Gbl_AsrLogFileHandle = CreateFileW(
        asrLogFilePath,           // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode: nobody else should write to the log file while we are
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                    // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes: write through so we flush
        NULL                            // hTemplateFile
        );

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        //
        // Move to the end of file
        //
        SetFilePointer(Gbl_AsrLogFileHandle, 0L, NULL, FILE_END);
        WriteFile(Gbl_AsrLogFileHandle, "\r\n",
            (strlen("\r\n") * sizeof(char)), &bytesWritten,NULL);
        AsrpPrintDbgMsg(s_Info, "****** Entering asrsfgen.exe.  ASR log at %ws", asrLogFilePath);
    }
    else {
        AsrpPrintDbgMsg(s_Error, 
            "******* Unable to create/open ASR log file at %ws (0x%x)",
            asrLogFilePath, GetLastError()
           );
    }

    if (asrLogFilePath) {
        HeapFree(hHeap, 0L, asrLogFilePath);
        asrLogFilePath = NULL;
    }
}


VOID
AsrpCloseLogFiles(
    VOID
    ) 

/*++

Description:

    This closes the ASR error and log file at %systemroot%\repair\, and 
    frees the global variables associated with them.  

    This must be called during clean-up.  AsrpPrintDbgMesg() will have no 
    effect after this routine is called.


Arguments:

    None

Return Values:
    
    None

--*/

{
    AsrpPrintDbgMsg(s_Info, "****** Exiting asrsfgen.exe.");

    //
    // Clean up global values
    // 
    if (Gbl_AsrErrorFilePath) {
        HeapFree(GetProcessHeap(), 0L, Gbl_AsrErrorFilePath);
        Gbl_AsrErrorFilePath = NULL;
    }

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        CloseHandle(Gbl_AsrLogFileHandle);
        Gbl_AsrLogFileHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\confdisk\critdrv.h ===
//-------------------------------------------------------------------
//
// critical drivers suppot
//

typedef struct _WSTRING_DATA_LINK
	{
	struct _WSTRING_DATA_LINK *m_psdlNext;
	WCHAR rgwc[2040];
	} WSTRING_DATA_LINK;


// class string data
class CWStringData
	{
public:
	// @cmember constructor
	CWStringData();

	// @cmember destructor
	~CWStringData();

	// @cmember allocate a string
	LPWSTR AllocateString(unsigned cwc);

	// @cmember copy a string
	LPWSTR CopyString(LPCWSTR wsz);

private:
	// @cmember allocate a new string data link
	void AllocateNewLink();

	// @cmember	current link
	WSTRING_DATA_LINK *m_psdlCur;

	// @cmember offset in current link for next string
	unsigned m_ulNextString;

	// @cmember first link
	WSTRING_DATA_LINK *m_psdlFirst;
	};



// list of critical volumes
class CVolumeList
	{
public:
	// constructor
	CVolumeList();

	// destructor
	~CVolumeList();

	// add a path to the volume list
	void AddPath(LPWSTR wszPath);

	// @cmember add a file to the volume list
	void AddFile(LPWSTR wszFile);

	// @cmember obtain list of volumes
	LPWSTR GetVolumeList();

private:
	enum
		{
		// amount to grow paths array by
		x_cwszPathsInc = 8,

		// amount to grow volumes array by
		x_cwszVolumesInc = 4
		};

	// determine if a path is a volume
	BOOL TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot);

	// determine if path is in the list; if not add it to list
	BOOL AddPathToList(LPWSTR wszPath);

	// @cmember determine if a volume is in the list; if not add it to the list
	BOOL AddVolumeToList(LPCWSTR wszVolume);

	// @cmember get volume from the path
	void GetVolumeFromPath(LPCWSTR wsz, LPWSTR wszVolumeName);

	// @cmember cached strings
	CWStringData m_sd;

	// volumes encountered so far
	LPCWSTR *m_rgwszVolumes;

	// # of volumes allocate
	unsigned m_cwszVolumes;

	// max # of volumes in array
	unsigned m_cwszVolumesMax;

	// paths encountered so far
	LPCWSTR *m_rgwszPaths;

	// # of paths encountered so far
	unsigned m_cwszPaths;

	// @cmember max # of paths in array
	unsigned m_cwszPathsMax;
	};


// FRS entry points
typedef DWORD ( WINAPI *PF_FRS_ERR_CALLBACK )( CHAR *, DWORD );
typedef DWORD ( WINAPI *PF_FRS_INIT )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_DESTROY )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
typedef DWORD ( WINAPI *PF_FRS_GET_SETS )( PVOID );
typedef DWORD ( WINAPI *PF_FRS_ENUM_SETS )( PVOID, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_IS_SYSVOL )( PVOID, PVOID, BOOL * );
typedef DWORD ( WINAPI *PF_FRS_GET_PATH )( PVOID, PVOID, DWORD *, WCHAR * ) ;
typedef DWORD ( WINAPI *PF_FRS_GET_OTHER_PATHS)(PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR *);

// iterate over frs drives
class CFRSIter
	{
public:
	// constructor
	CFRSIter();

	// destructor
	~CFRSIter();

	// initialization routine
	void Init();

	// initialize iterator
	BOOL BeginIteration();

	// end iteration
	void EndIteration();

	// obtain path to next replication set
	LPWSTR GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths);

private:
	// cleanup frs backup restore context
	void CleanupIteration();

	enum
		{
		x_IterNotStarted,
		x_IterStarted,
		x_IterComplete
		};

	// is this initialized
	BOOL m_fInitialized;
	HINSTANCE  m_hLib;
	DWORD ( WINAPI *m_pfnFrsInitBuRest )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsEndBuRest )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
	DWORD ( WINAPI *m_pfnFrsGetSets )( PVOID );
	DWORD ( WINAPI *m_pfnFrsEnumSets )( PVOID, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsIsSetSysVol )( PVOID, PVOID, BOOL * );
	DWORD ( WINAPI *m_pfnFrsGetPath )( PVOID, PVOID, DWORD *, WCHAR * ) ;
	DWORD ( WINAPI *m_pfnFrsGetOtherPaths) ( PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR * );

	// has iteration been started
	int m_stateIteration;

	// current set iterated
	unsigned m_iset;

	// context for iteration
	PVOID m_frs_context;
	};



LPWSTR pFindCriticalVolumes();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asr_app\asr_app.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_app.c

Abstract:

    Sample third party ASR recovery application.

Authors:

    Guhan Suriyanarayanan   (guhans)    07-Oct-1999

Revision History:

    07-Oct-2000 guhans      
      Initial creation

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include <setupapi.h>

//
//  Macro Description:
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Expression to be tested
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // ErrorCode 
//
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Error %lu (0x%x), line %lu", ErrorCode, ErrorCode, __LINE__);    \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


//
// Constants local to this module
//
const WCHAR BACKUP_OPTION[]     = L"/backup";
const WCHAR RESTORE_OPTION[]    = L"/restore";
const WCHAR REGISTER_OPTION[]    = L"/register";

const WCHAR SIF_PATH_FORMAT[]   = L"/sifpath=%ws";
const WCHAR ERROR_FILE_PATH[]   = L"%systemroot%\\repair\\asr.err";

const WCHAR MY_SIF_SECTION[]        = L"[ASR_APP.APPDATA]";
const WCHAR MY_SIF_SECTION_NAME[]   = L"ASR_APP.APPDATA";


const WCHAR GENERIC_ERROR_MESSAGE[] = L"asr_app could not complete successfully (error %lu 0x%x)\n\nusage: asr_app {/backup | /restore /sifpath=<path to asr.sif> | /register <path to asr_app>}";
const WCHAR GENERIC_ERROR_TITLE[] = L"asr_app error";

#ifdef _IA64_
const WCHAR CONTEXT_FORMAT[]       = L"/context=%I64u";
#else
const WCHAR CONTEXT_FORMAT[]       = L"/context=%lu";
#endif


#define ASR_REG_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands"
#define MY_REG_KEY_VALUE_NAME   L"ASR Sample Application"

typedef enum _AsrAppOption {
    AsrAppNone = 0,
    AsrAppRegister,
    AsrAppBackup,
    AsrAppRestore
} AsrAppOption;

HANDLE Gbl_hErrorFile = NULL;


PWSTR   // must be freed by caller
ExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    DWORD status = ERROR_SUCCESS;
    HANDLE heapHandle = GetProcessHeap();

    expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
    if (!expandedString) {
        return NULL;
    }
        
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(heapHandle, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
        if (!expandedString) {
            return NULL;
        }
        
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        HeapFree(heapHandle, 0L, expandedString);
        expandedString = NULL;
    }

    return expandedString;
}


VOID
OpenErrorFile() 
{
    PWSTR szErrorFilePath = NULL;

    //
    // Get full path to the error file  (%systemroot%\repair\asr.err)
    //
    szErrorFilePath = ExpandEnvStrings(ERROR_FILE_PATH);
    if (!szErrorFilePath) {
        return;
    }

    //
    // Open the error file
    //
    Gbl_hErrorFile = CreateFileW(
        szErrorFilePath,            // lpFileName
        GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_ALWAYS,                // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );

    HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
    szErrorFilePath = NULL;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Move to the end of file
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);
}


VOID
CloseErrorFile(
    VOID
    ) 
{

    if ((Gbl_hErrorFile) && (INVALID_HANDLE_VALUE != Gbl_hErrorFile)) {
        CloseHandle(Gbl_hErrorFile);
        Gbl_hErrorFile = NULL;
    }
}


VOID
LogErrorMessage(
    IN CONST PCWSTR Message
    ) 
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    WCHAR buffer[4196];

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        //
        // We haven't been initialised, or the error file couldn't be
        // created for some reason.
        //
        return;
    }

    //
    // In case someone else wrote to this file since our last write
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

    //
    // Create our string, and write it out
    //
    GetLocalTime(&currentTime);
    swprintf(buffer,
        L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu ASR_APP] (ERROR) %s\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        Message
        );

    WriteFile(Gbl_hErrorFile,
        buffer,
        (wcslen(buffer) * sizeof(WCHAR)),
        &bytesWritten,
        NULL
        );
}


BOOL
BackupState(
    IN CONST DWORD_PTR AsrContext
    )
{
    //
    // Gather our state to backup
    //
    HMODULE hSyssetup = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = FALSE;

    //     
    // BOOL
    // AsrAddSifEntryW(
    //     IN  DWORD_PTR   AsrContext,
    //     IN  PCWSTR      lpSectionName,
    //     IN  PCWSTR      lpSifEntry
    //     );
    // 
    BOOL (*pfnAddSifEntry)(DWORD_PTR, PCWSTR, PCWSTR);

    // 
    // Load syssetup.dll
    //
    hSyssetup = LoadLibraryW(L"syssetup.dll");
    pErrExitCode(
        (!hSyssetup || INVALID_HANDLE_VALUE == hSyssetup),
        dwStatus, 
        GetLastError()
        );

    // 
    // Get the RestoreNonCriticalDisksW API exported by syssetup.dll
    //
    pfnAddSifEntry = (BOOL (*)(DWORD_PTR, PCWSTR, PCWSTR))
        GetProcAddress(hSyssetup, "AsrAddSifEntryW");
    pErrExitCode((!pfnAddSifEntry), dwStatus,  GetLastError());


    //
    // Add the state to asr.sif
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        MY_SIF_SECTION,
        L"1=\"asr_app sample application data\",100,200,300"
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Also add to the commands and installfiles section, so that we get
    // called during the ASR recovery.
    //

    // 
    // INSTALLFILES section entry format:
    // system-key,source-media-label,source-device,
    //    source-file-path,destination-file-path,vendor-name
    // system-key must be 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_INSTALLFILES,
        L"1,\"ASR Sample App Disk 1\",\"%FLOPPY%\",\"i386\\asr_app.exe\",\"%temp%\\asr_app.exe\",\"ASR Sample App Company\""
        //L"1,\"Application Disk 1\",\"\\device\\cdrom0\",\"application.exe\",\"%TEMP%\\application.exe\",\"Company Name\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

//    CString cmd =L"1,\"ASRDisk1\",\"\\Device\\Floppy0\\edmbackup.exe\",\"%TEMP%\\edmbackup.exe\",\"EMC\"";

/*    bResult = pfnAddSifEntry(AsrContext, 
        ASR_SIF_SECTION_INSTALLFILES, 
        (LPCTSTR) L"1,\"ASRDisk1\",\"\\Device\\Floppy0\\edmbackup.exe\",\"%TEMP%\\edmbackup.exe\",\"EMC\"" );
    pErrExitCode(!bResult, dwStatus, GetLastError());
*/


    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_COMMANDS,
        L"1,3500,1,\"%temp%\\asr_app.exe\",\"/restore\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (hSyssetup) {
        FreeLibrary(hSyssetup);
        hSyssetup = NULL;
    }
    
    return (ERROR_SUCCESS == dwStatus);
}


BOOL
RestoreState(
    IN CONST PCWSTR szAsrSifPath
    )
{
    HINF hSif = NULL;
    INFCONTEXT infContext;
    BOOL bResult = FALSE;

    WCHAR szErrorString[1024];

    int iValue1 = 0, 
        iValue2 = 0, 
        iValue3 = 0;

    WCHAR szBuffer[1024];

    //
    // Open the asr.sif
    //
    hSif = SetupOpenInfFile(szAsrSifPath, NULL, INF_STYLE_WIN4, NULL);
    if ((!hSif) || (INVALID_HANDLE_VALUE == hSif)) {

        wsprintf(szErrorString, L"Unable to open the ASR state file at %ws (0x%x)",
            szAsrSifPath,
            GetLastError()
            );
        LogErrorMessage(szErrorString);

        return FALSE;
    }

    //
    // Find the section
    //
    bResult = SetupFindFirstLineW(hSif, MY_SIF_SECTION_NAME, NULL, &infContext);
    if (bResult) {

        //
        // Read in the information.  We had one string followed by three numbers.
        //
        bResult = SetupGetStringField(&infContext, 1, szBuffer, 1024, NULL)
            && SetupGetIntField(&infContext, 2, &iValue1)
            && SetupGetIntField(&infContext, 3, &iValue2)
            && SetupGetIntField(&infContext, 4, &iValue3);

        if (bResult) {
            //
            // Now restore our state.  Let's just pretend we're doing something.
            //
            wprintf(L"Values read:  %ws  %lu %lu %lu\n\n", szBuffer, iValue1, iValue2, iValue3);
            wprintf(L"Restoring sample system state, please wait ... ");

            Sleep(5000);
            wprintf(L"done\n");

        }
        else {

            wsprintf(szErrorString, 
                L"Some values in the asr_app section of the ASR state file %ws could not be read (0x%x).  "
                L"This may indicate a corrupt or an incompatible version of the ASR state file",
                szAsrSifPath,
                GetLastError()
                );
            LogErrorMessage(szErrorString);
        }
    }
    else {

        wsprintf(szErrorString, 
            L"Unable to locate asr_app section in ASR state file %ws (0x%x).  "
            L"This may indicate a corrupt or an incompatible version of the ASR state file",
            szAsrSifPath,
            GetLastError()
            );
        LogErrorMessage(szErrorString);
    }

    SetupCloseInfFile(hSif);
    return bResult;
}


DWORD
RegisterForAsrBackup(
    IN CONST PCWSTR szApplicationName
    ) 
{

    DWORD dwResult = ERROR_SUCCESS;
    HKEY hKeyAsr = NULL;

    WCHAR szData[1024];

    if (wcslen(szApplicationName) > 1000) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    wsprintf(szData, L"%ws %ws", szApplicationName, BACKUP_OPTION);

    // 
    // Open the registry key
    //
    dwResult = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,     // hKey
        ASR_REG_KEY,  // lpSubKey
        0,                      // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,        // samDesired
        &hKeyAsr              // phkbResult    
        );
    if (ERROR_SUCCESS != dwResult) {
        return dwResult;
    }

    dwResult = RegSetValueExW(
        hKeyAsr,                                // hKey
        MY_REG_KEY_VALUE_NAME,                  // lpValueName
        0,                                      // dwReserved, must be 0
        REG_SZ,                                  // dwType
        (LPBYTE)szData,  // lpData
        ((wcslen(szData) + 1)* (sizeof(WCHAR))) // cbData
        );

    return dwResult;
}


int 
__cdecl     // var arg
wmain (
    int     argc,
    wchar_t *argv[],
    wchar_t *envp[]
    ) 
{

    AsrAppOption    option  = AsrAppNone;
    DWORD           dwStatus = ERROR_SUCCESS;

    if (argc >= 3) {
        if (!_wcsicmp(argv[1], BACKUP_OPTION)) {
            //
            // asr_app /backup /context=nnn
            //
            option = AsrAppBackup;
        } 
        else if (!_wcsicmp(argv[1], RESTORE_OPTION)) {
            //
            // asr_app /restore /sifpath="c:\winnt\repair\asr.sif"
            //
            option = AsrAppRestore;
        }
        else if (!_wcsicmp(argv[1], REGISTER_OPTION)) {
            //
            // asr_app /register "c:\apps\asr_app\asr_app.exe"
            //
            option = AsrAppRegister;
        }
    }

    switch (option) {

    case AsrAppRegister: {                   // This App is being installed

        dwStatus = RegisterForAsrBackup(argv[2]);
        
        break;

    }

    case AsrAppBackup: {                    // An ASR Backup is in progress
        DWORD_PTR  AsrContext = 0;

        //
        // Extract the asr context from the commandline
        //
        swscanf(argv[2], CONTEXT_FORMAT, &AsrContext);

        //
        // Create our spooge and write to the asr.sif
        //
        if (!BackupState(AsrContext)) {
            dwStatus = GetLastError();
        }
//        AsrFreeContext(&AsrContext);

        //
        // And we're done
        //
        break;
    }

    case AsrAppRestore: {                   // An ASR Restore is in progress
        WCHAR   szAsrFilePath[MAX_PATH +1];

        //
        // Get the path to the asr.sif
        //
        swscanf(argv[2], SIF_PATH_FORMAT, szAsrFilePath);
        OpenErrorFile();
        
        //
        // Read our spooge from asr.sif, and recreate the state.  Be sure to 
        // write out the error to %systemroot%\repair\asr.err in case of
        // error.
        //
        if (!RestoreState(szAsrFilePath)) {
            dwStatus = GetLastError();
        }
        CloseErrorFile();

        //
        // And we're done
        //
        break;
    }

    case AsrAppNone:
    default: {

        // 
        // Command-line parameters were incorrect, display usage message
        //
        dwStatus = ERROR_INVALID_PARAMETER;
        break;
    }
    }
    
    if (ERROR_SUCCESS != dwStatus) {
        //
        // We hit an error
        //
        WCHAR szErrorMessage[1024];

        swprintf(szErrorMessage, GENERIC_ERROR_MESSAGE, dwStatus, dwStatus);
        MessageBoxW(NULL, szErrorMessage, GENERIC_ERROR_TITLE, MB_OK | MB_ICONSTOP);
    }

    SetLastError(dwStatus);
    return (int) dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\confdisk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by confdisk.rc
//
#define IDS_GENERIC_ERROR               1
#define IDS_ERROR_USAGE                 2
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\confdisk\critdrv.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    critdrv.cpp

Abstract:
    
    This module contains routines create a list of the critical volumes on a 
    system.  This is lifted directly from base\fs\utils\ntback50\ui.

Author:

    Brian Berkowitz   (brianb)    10-Mar-2000

Environment:

    User-mode only.

Revision History:

    10-Mar-2000 brianb
        Initial creation

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <objbase.h>
#include <initguid.h>
#include <frsapip.h>
#include <critdrv.h>



// FRS iteration class.  Used to iterate through replica sets to
// determine the paths for these replica sets
// constructor
CFRSIter::CFRSIter() :
    m_fInitialized(FALSE),
    m_hLib(NULL),
    m_pfnFrsInitBuRest(NULL),
    m_pfnFrsEndBuRest(NULL),
    m_pfnFrsGetSets(NULL),
    m_pfnFrsEnumSets(NULL),
    m_pfnFrsIsSetSysVol(NULL),
    m_pfnFrsGetPath(NULL),
    m_pfnFrsGetOtherPaths(NULL),
    m_stateIteration(x_IterNotStarted)
    {
    }

// destructor
CFRSIter::~CFRSIter()
    {
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    if (m_hLib)
        FreeLibrary(m_hLib);
    }

// initialize entry points and load library
void CFRSIter::Init()
    {
    if (m_fInitialized)
        return;

    // load library
    m_hLib = LoadLibrary(L"ntfrsapi.dll");
    if (m_hLib)
        {
        // assign etntry points
        m_pfnFrsInitBuRest = (PF_FRS_INIT) GetProcAddress(m_hLib, "NtFrsApiInitializeBackupRestore");
        m_pfnFrsEndBuRest = (PF_FRS_DESTROY) GetProcAddress(m_hLib, "NtFrsApiDestroyBackupRestore");
        m_pfnFrsGetSets = (PF_FRS_GET_SETS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSets");
        m_pfnFrsEnumSets = (PF_FRS_ENUM_SETS) GetProcAddress(m_hLib, "NtFrsApiEnumBackupRestoreSets");
        m_pfnFrsIsSetSysVol = (PF_FRS_IS_SYSVOL) GetProcAddress(m_hLib, "NtFrsApiIsBackupRestoreSetASysvol");
        m_pfnFrsGetPath = (PF_FRS_GET_PATH) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetDirectory");
        m_pfnFrsGetOtherPaths = (PF_FRS_GET_OTHER_PATHS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetPaths");
        if (m_pfnFrsInitBuRest == NULL ||
            m_pfnFrsEndBuRest == NULL ||
            m_pfnFrsGetSets == NULL ||
            m_pfnFrsEnumSets == NULL ||
            m_pfnFrsIsSetSysVol == NULL ||
            m_pfnFrsGetOtherPaths == NULL ||
            m_pfnFrsGetPath == NULL)
            {
            // if we can't get to any entry point, free library and
            // fail operation
            FreeLibrary(m_hLib);
            m_hLib = NULL;
            }
        }

    // indicate that operation is successful
    m_fInitialized = TRUE;
    }


// initialize the iterator.  Return FALSE if iterator is known to be empty
//
BOOL CFRSIter::BeginIteration()
    {
    ASSERT(m_stateIteration == x_IterNotStarted);
    DWORD status;
    if (m_hLib == NULL)
        {
        // if we are not initialized, then there is nothing to iterate
        // over
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // initialize FRS backup restore apis
    status = m_pfnFrsInitBuRest
                    (
                    NULL,
                    NTFRSAPI_BUR_FLAGS_NORMAL|NTFRSAPI_BUR_FLAGS_BACKUP,
                    &m_frs_context
                    );

    if (status != ERROR_SUCCESS)
        {
        // if this fails then we are done
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // indicate that we started the iteration
    m_stateIteration = x_IterStarted;
    status = m_pfnFrsGetSets(m_frs_context);
    if (status != ERROR_SUCCESS)
        {
        // if there are no sets, then indicate we are done
        CleanupIteration();
        return FALSE;
        }

    // start at first set
    m_iset = 0;
    return TRUE;
    }

// cleanup iteration after scanning the last element
void CFRSIter::CleanupIteration()
    {
    m_pfnFrsEndBuRest(&m_frs_context, NTFRSAPI_BUR_FLAGS_NONE, NULL, NULL, NULL);
    m_stateIteration = x_IterComplete;
    }


// get next iteration set returning the path to the set
// NULL indicates end of iteration
// If fSkipToSysVol is TRUE then ignore non SysVol replication sets
LPWSTR CFRSIter::GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths)
    {
    ASSERT(pwszPaths);
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterComplete)
        // if iteration is complete, then we are done
        return NULL;

    PVOID frs_set;

    while(TRUE)
        {
        // get a set
        DWORD status = m_pfnFrsEnumSets(m_frs_context, m_iset, &frs_set);
        if (status != ERROR_SUCCESS)
            {
            // if this fails, then we are done
            CleanupIteration();
            return NULL;
            }

        if (fSkipToSysVol)
            {
            // we are looking for system volumes
            BOOL fSysVol;

            // test whether this is a system volume
            status = m_pfnFrsIsSetSysVol(m_frs_context, frs_set, &fSysVol);
            if (status != ERROR_SUCCESS)
                {
                // if this operation fails, terminate iteration
                CleanupIteration();
                return NULL;
                }

            if (!fSysVol)
                {
                // if not a system volume, then skip to the next
                // replica set
                m_iset++;
                continue;
                }
            }


        // scratch pad for path
        WCHAR wsz[MAX_PATH];
        DWORD cbPath = MAX_PATH * sizeof(WCHAR);

        // get path to root of the replica set
        status = m_pfnFrsGetPath
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz
            );

        WCHAR *wszNew = NULL;
        // allocate memory for root
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            wszNew = new WCHAR[cbPath/sizeof(WCHAR)];

            // if allocation fails, then throw OOM
            if (wszNew == NULL)
                throw E_OUTOFMEMORY;

            if (status == ERROR_SUCCESS)
                // if the operation was successful, then copy
                // path into memory
                memcpy(wszNew, wsz, cbPath);
            else
                {
                // otherwise redo the operation
                status = m_pfnFrsGetPath
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew
                    );

                if (status != ERROR_SUCCESS)
                    {
                    // if operation failed then second time, then
                    // delete allocated memory and terminate iteration
                    delete [] wszNew;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if operation failed due to any error other than
            // insufficient buffer, then terminate the iteration
            CleanupIteration();
            return NULL;
            }


        // scratch pad for filters
        WCHAR wszFilter[MAX_PATH];
        DWORD cbFilter = MAX_PATH * sizeof(WCHAR);

        // length of scratch pad for paths
        cbPath = MAX_PATH * sizeof(WCHAR);

        // obtain other paths
        status = m_pfnFrsGetOtherPaths
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz,
            &cbFilter,
            wszFilter
            );

        WCHAR *wszNewPaths = NULL;
        WCHAR *wszNewFilter = NULL;
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            // allocate space for paths
            wszNewPaths = new WCHAR[cbPath/sizeof(WCHAR)];

            // allocate space for filters
            wszNewFilter = new WCHAR[cbFilter/sizeof(WCHAR)];
            if (wszNewPaths == NULL || wszNewFilter == NULL)
                {
                // if any allocation fails, then throw OOM
                delete [] wszNewPaths;
                delete [] wszNewFilter;
                throw E_OUTOFMEMORY;
                }

            if (status == ERROR_SUCCESS)
                {
                // if operation was successful, then copy
                // in allocated paths
                memcpy(wszNewPaths, wsz, cbPath);
                memcpy(wszNewFilter, wszFilter, cbFilter);
                }
            else
                {
                status = m_pfnFrsGetOtherPaths
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew,
                    &cbFilter,
                    wszNewFilter
                    );

                if (status != ERROR_SUCCESS)
                    {
                    delete [] wszNew;
                    delete [] wszNewFilter;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if any error other than success or INSUFFICENT_BUFFER
            // then terminate iteration
            CleanupIteration();
            return NULL;
            }

        // delete allocated filter
        delete [] wszNewFilter;

        // set iteration to next set
        m_iset++;

        // return pointer to paths
        *pwszPaths = wszNewPaths;

        // return path of root of replicated set
        return wszNew;
        }
    }


// terminate iteration, cleaning up anything that needs to be
// cleaned up
//
void CFRSIter::EndIteration()
    {
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    // indicate that iteration is no longer in progress
    m_stateIteration = x_IterNotStarted;
    }

// constructor for string data structure
CWStringData::CWStringData()
    {
    m_psdlFirst = NULL;
    m_psdlCur = NULL;
    }

// destructor
CWStringData::~CWStringData()
    {
    while(m_psdlFirst)
        {
        WSTRING_DATA_LINK *psdl = m_psdlFirst;
        m_psdlFirst = m_psdlFirst->m_psdlNext;
        delete psdl;
        }
    }

// allocate a new link
void CWStringData::AllocateNewLink()
    {
    WSTRING_DATA_LINK *psdl = new WSTRING_DATA_LINK;
    if (psdl == NULL)
        throw E_OUTOFMEMORY;

    psdl->m_psdlNext = NULL;
    if (m_psdlCur)
        {
        ASSERT(m_psdlFirst);
        m_psdlCur->m_psdlNext = psdl;
        m_psdlCur = psdl;
        }
    else
        {
        ASSERT(m_psdlFirst == NULL);
        m_psdlFirst = m_psdlCur = psdl;
        }

    m_ulNextString = 0;
    }

// allocate a string
LPWSTR CWStringData::AllocateString(unsigned cwc)
    {
    ASSERT(cwc <= sizeof(m_psdlCur->rgwc));

    if (m_psdlCur == NULL)
        AllocateNewLink();

    if (sizeof(m_psdlCur->rgwc) <= (cwc + 1 + m_ulNextString) * sizeof(WCHAR))
        AllocateNewLink();

    unsigned ulOff = m_ulNextString;
    m_ulNextString += cwc + 1;
    return m_psdlCur->rgwc + ulOff;
    }

// copy a string
LPWSTR CWStringData::CopyString(LPCWSTR wsz)
    {
    unsigned cwc = (wsz == NULL) ? 0 : wcslen(wsz);
    LPWSTR wszNew = AllocateString(cwc);
    memcpy(wszNew, wsz, cwc * sizeof(WCHAR));
    wszNew[cwc] = '\0';
    return wszNew;
    }


// constructor for volume list
CVolumeList::CVolumeList() :
    m_rgwszVolumes(NULL),       // array of volumes
    m_cwszVolumes(0),           // # of volumes in array
    m_cwszVolumesMax(0),        // size of array
    m_rgwszPaths(NULL),         // array of paths
    m_cwszPaths(0),             // # of paths in array
    m_cwszPathsMax(0)           // size of array
    {
    }

// destructor
CVolumeList::~CVolumeList()
    {
    delete m_rgwszPaths;        // delete paths array
    delete m_rgwszVolumes;      // delete volumes array
    }

// add a path to the list if it is not already there
// return TRUE if it is a new path
// return FALSE if path is already in list
//
BOOL CVolumeList::AddPathToList(LPWSTR wszPath)
    {
    // look for path in list.  If found, then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszPaths; iwsz++)
        {
        if (_wcsicmp(wszPath, m_rgwszPaths[iwsz]) == 0)
            return FALSE;
        }

    // grow pat array if needed
    if (m_cwszPaths == m_cwszPathsMax)
        {
        // grow path array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszPaths + x_cwszPathsInc];

        // throw OOM if memory allocation fails
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszPaths, m_cwszPaths * sizeof(LPCWSTR));
        delete m_rgwszPaths;
        m_rgwszPaths = rgwsz;
        m_cwszPathsMax += x_cwszPathsInc;
        }

    // add path to array
    m_rgwszPaths[m_cwszPaths++] = m_sd.CopyString(wszPath);
    return TRUE;
    }

// add a volume to the list if it is not already there
// return TRUE if it is added
// return FALSE if it is already on the list
//
BOOL CVolumeList::AddVolumeToList(LPCWSTR wszVolume)
    {
    // look for volume in array.  If found then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        if (_wcsicmp(wszVolume, m_rgwszVolumes[iwsz]) == 0)
            return FALSE;
        }

    // grow volume array if necessary
    if (m_cwszVolumes == m_cwszVolumesMax)
        {
        // grow volume array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszVolumes + x_cwszVolumesInc];
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszVolumes, m_cwszVolumes * sizeof(LPCWSTR));
        delete m_rgwszVolumes;
        m_rgwszVolumes = rgwsz;
        m_cwszVolumesMax += x_cwszVolumesInc;
        }

    // add volume name to array
    m_rgwszVolumes[m_cwszVolumes++] = m_sd.CopyString(wszVolume);
    return TRUE;
    }


const WCHAR x_wszVolumeRootName[] = L"\\\\?\\GlobalRoot\\Device\\";
const unsigned x_cwcVolumeRootName = sizeof(x_wszVolumeRootName)/sizeof(WCHAR) - 1;

// add a path to our tracking list.  If the path is new add it to the
// paths list.  If it is a mount point or the root of a volume, then
// determine the volume and add the volume to the list of volumes
//
// can throw E_OUTOFMEMORY
//
void CVolumeList::AddPath(LPWSTR wszTop)
    {
    // if path is known about then return
    if (!AddPathToList(wszTop))
        return;

    // length of path
    unsigned cwc = wcslen(wszTop);

    // copy path so that we can add backslash to the end of the path
    LPWSTR wszCopy = new WCHAR[cwc + 2];

    // if fails, then throw OOM
    if (wszCopy == NULL)
        throw E_OUTOFMEMORY;

    // copyh in original path
    memcpy(wszCopy, wszTop, cwc * sizeof(WCHAR));

    // append backslash
    wszCopy[cwc] = L'\\';
    wszCopy[cwc + 1] = L'\0';
    while(TRUE)
        {
        // check for a device root
        cwc = wcslen(wszCopy);
        if ((cwc == 3 && wszCopy[1] == ':') ||
            (cwc > x_cwcVolumeRootName &&
             memcmp(wszCopy, x_wszVolumeRootName, x_cwcVolumeRootName * sizeof(WCHAR)) == 0))
            {
            // call TryAddVolume with TRUE indicating this is a volume root
            TryAddVolumeToList(wszCopy, TRUE);
            break;
            }

        // call TryAddVolume indicating this is not a known device root
        if (TryAddVolumeToList(wszCopy, FALSE))
            break;

        // move back to previous backslash
        WCHAR *pch = wszCopy + cwc - 2;
        while(--pch > wszTop)
            {
            if (pch[1] == L'\\')
                {
                pch[2] = L'\0';
                break;
                }
            }

        if (pch == wszTop)
            break;

        // if path is known about then return
        if (!AddPathToList(wszCopy))
            break;
        }
    }



// determine if a path is a volume.  If so then add it to the volume
// list and return TRUE.  If not, then return FALSE.  fVolumeRoot indicates
// that the path is of the form x:\.  Otherwise the path is potentially
// an mount point.  Validate that it is a reparse point and then try
// finding its volume guid.  If this fails, then assume that it is not
// a volume root.  If it succeeds, then add the volume guid to the volumes
// list and return TRUE.
//
BOOL CVolumeList::TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot)
    {
    WCHAR wszVolume[256];

    if (fVolumeRoot)
        {
        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            // might be the EFI system partition, just pass in the path as the volume string.
            wcscpy( wszVolume, wszPath );            
            //throw E_UNEXPECTED;
        }
    else
        {
        DWORD dw = GetFileAttributes(wszPath);
        if (dw == -1)
            return FALSE;

        if ((dw & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
            return FALSE;

        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            return FALSE;
        }

    AddVolumeToList(wszVolume);
    return TRUE;
    }


// add a file to the volume list.  Simply finds the parent path and adds it
//
void CVolumeList::AddFile(LPWSTR wsz)
    {
    unsigned cwc = wcslen(wsz);
    WCHAR *pwc = wsz + cwc - 1;
    while(pwc[1] != L'\\' && pwc != wsz)
        continue;

    pwc[1] = '\0';
    AddPath(wsz);
    }

// obtain list of volumes as a MULTI_SZ,  caller is responsible for freeing
// the string
//
LPWSTR CVolumeList::GetVolumeList()
    {
    unsigned cwc = 1;

    // compute length of volume list it is length of each string +
    // null character + null charactor for last double NULL
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        cwc += wcslen(m_rgwszVolumes[iwsz]) + 1;

    // allocate string
    LPWSTR wsz = new WCHAR[cwc];

    // throw OOM if memory allocation failed
    if (wsz == NULL)
        throw E_OUTOFMEMORY;

    // copy in strings
    WCHAR *pwc = wsz;
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        cwc = wcslen(m_rgwszVolumes[iwsz]) + 1;
        memcpy(pwc, m_rgwszVolumes[iwsz], cwc * sizeof(WCHAR));
		/* replace \\?\ with \??\ */
		memcpy(pwc, L"\\??", sizeof(WCHAR) * 3);

		// delete trailing backslash if it exists
		if (pwc[cwc - 2] == L'\\')
			{
			pwc[cwc-2] = L'\0';
			cwc--;
			}

        pwc += cwc;
        }

    // last null termination
    *pwc = L'\0';

    return wsz;
    }


// path to volume of boot device is
// HKEY_LOCAL_MACHINE\System\Setup
//with Value of SystemPartition parametr
LPCWSTR x_SetupRoot = L"System\\Setup";

// magic perfix for volume devices
WCHAR x_wszWin32VolumePrefix[] = L"\\\\?\\GlobalRoot";
const unsigned x_cwcWin32VolumePrefix = sizeof(x_wszWin32VolumePrefix)/sizeof(WCHAR) - 1;

// structure representing a path from
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
// and a value to look up
typedef struct _SVCPARM
    {
    LPCWSTR wszPath;
    LPCWSTR wszValue;
    } SVCPARM;


const SVCPARM x_rgdbparms[] =
    {
        {L"CertSvc\\Configuration", L"DBDirectory"},
        {L"CertSvc\\Configuration", L"DBLogDirectory"},
        {L"CertSvc\\Configuration", L"DBSystemDirectory"},
        {L"CertSvc\\Configuration", L"DBTempDirectory"},
        {L"DHCPServer\\Parameters", L"DatabasePath"},
        {L"DHCPServer\\Parameters", L"DatabaseName"},
        {L"DHCPServer\\Parameters", L"BackupDatabasePath"},
        {L"NTDS\\Parameters", L"Database backup path"},
        {L"NTDS\\Parameters", L"Databases log files path"},
        {L"Ntfrs\\Parameters\\Replica Sets", L"Database Directory"}
    };

const unsigned x_cdbparms = sizeof(x_rgdbparms)/sizeof(SVCPARM);

LPCWSTR x_wszSvcRoot = L"System\\CurrentControlSet\\Services";

// add roots for various services
BOOL AddServiceRoots(CVolumeList &vl)
    {
    HKEY hkeyRoot;
    // open HKLM\System\CurrentControlSet\Services
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_wszSvcRoot, &hkeyRoot) != ERROR_SUCCESS)
        return FALSE;

    // loop through individual paths
    for(unsigned i = 0; i < x_cdbparms; i++)
        {
        WCHAR wsz[MAX_PATH*4];
        LPCWSTR wszPath = x_rgdbparms[i].wszPath;
        LPCWSTR wszValue = x_rgdbparms[i].wszValue;

        HKEY hkey;
        DWORD cb = sizeof(wsz);
        DWORD type;

        // open path, skip if open fails
        if (RegOpenKey(hkeyRoot, wszPath, &hkey) != ERROR_SUCCESS)
            continue;

        // add path to volume list if query succeeds
        if (RegQueryValueEx
                (
                hkey,
                wszValue,
                NULL,
                &type,
                (BYTE *) wsz,
                &cb
                ) == ERROR_SUCCESS)
            vl.AddPath(wsz);

        // close key
        RegCloseKey(hkey);
        }

    // close root key
    RegCloseKey(hkeyRoot);
    return TRUE;
    }


// add volume root of SystemDrive (drive wee boot off of
BOOL AddSystemPartitionRoot(CVolumeList &vl)
    {
    HKEY hkeySetup;
    WCHAR wsz[MAX_PATH];

    // open HKLM\System\Setup
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_SetupRoot, &hkeySetup) != ERROR_SUCCESS)
        return FALSE;

    DWORD cb = sizeof(wsz);
    DWORD type;

    // query SystemPartition value
    if (RegQueryValueEx
            (
            hkeySetup,
            L"SystemPartition",
            NULL,
            &type,
            (BYTE *) wsz,
            &cb
            ) != ERROR_SUCCESS)
        {
        // if fails, return FALSE
        RegCloseKey(hkeySetup);
        return FALSE;
        }

    // compute size of needed buffer
    unsigned cwc = wcslen(wsz);
    unsigned cwcNew = x_cwcWin32VolumePrefix + cwc + 1;
    LPWSTR wszNew = new WCHAR[cwcNew];

    // return failure if memory allocation fials
    if (wszNew == NULL)
        return FALSE;

    // append \\?\GlobalRoot\ to device name
    memcpy(wszNew, x_wszWin32VolumePrefix, x_cwcWin32VolumePrefix * sizeof(WCHAR));
    memcpy(wszNew + x_cwcWin32VolumePrefix, wsz, cwc * sizeof(WCHAR));
    RegCloseKey(hkeySetup);
    wszNew[cwcNew-1] = L'\0';
    try {        
        // add path based on device root
        vl.AddPath(wszNew);
    } catch(...)
        {
        delete [] wszNew;
        return FALSE;
        }

    // delete allocated memory
    delete [] wszNew;
    return TRUE;
    }

// find critical volumes.  Return multistring of volume names
// using guid naming convention
LPWSTR pFindCriticalVolumes()
    {
    WCHAR wsz[MAX_PATH * 4];

    // find location of system root
    if (!ExpandEnvironmentStrings(L"%systemroot%", wsz, sizeof(wsz)/sizeof(WCHAR)))
        {
        wprintf(L"ExpandEnvironmentStrings failed for reason %d", GetLastError());
        return NULL;
        }

    CVolumeList vl;
    LPWSTR wszPathsT = NULL;
    LPWSTR wszT = NULL;

    try
        {
        // add boot drive
        if (!AddSystemPartitionRoot(vl))
            return NULL;

        // add roots for various services
        if (!AddServiceRoots(vl))
            return NULL;

        // add systemroot drive
        vl.AddPath(wsz);

            {
            // add roots for SYSVOL
            CFRSIter fiter;
            fiter.Init();
            fiter.BeginIteration();
            while(TRUE)
                {
                wszT = fiter.GetNextSet(TRUE, &wszPathsT);
                if (wszT == NULL)
                    break;

                vl.AddPath(wszT);
                LPWSTR wszPathT = wszPathsT;
                while(*wszPathT != NULL)
                    {
                    vl.AddPath(wszPathT);
                    wszPathT += wcslen(wszPathT);
                    }

                delete wszT;
                delete wszPathsT;
                wszT = NULL;
                wszPathsT = NULL;
                }

            fiter.EndIteration();
            }
        }
    catch(...)
        {
        delete wszT;
        delete wszPathsT;
        }

    // return volume list
    return vl.GetVolumeList();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\confdisk\confdisk.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confdisk.cpp

Abstract:

    Utility program to create an ASR state-file (asr.sif), or restore 
    non-critical disk layout based on a previously created asr.sif.

Author:

    Guhan Suriyanarayanan   (guhans)    15-April-2001

Environment:

    User-mode only.

Revision History:

    15-Apr-2001 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <winasr.h>

#include "resource.h"
#include "critdrv.h"
#include "confdisk.h"


//
// --------
// global variables used in this module
// --------
//
WCHAR   g_szTempBuffer[BUFFER_LENGTH];
HMODULE g_hModule = NULL;
HANDLE  g_hHeap = NULL;
BOOL    g_fErrorMessageDone = FALSE;


//
// --------
// function implementations
// --------
//
VOID
AsrpPrintError(
    IN CONST DWORD dwLineNumber,
    IN CONST DWORD dwErrorCode
    )
/*++

Routine Description:

    Loads an error message based on dwErrorCode from the resources, and 
    prints it out to screen.  There are some error codes that are of 
    particular interest (that have specific error messages), others 
    get a generic error message.

Arguments:

    dwLineNumber - The line at which the error occured, pass in __LINE__

    dwErrorCode - The win-32 error that occured.

Return Value:
    
    None.

--*/
{

    //
    // Handle the error codes we know and care about
    //

    switch (dwErrorCode) {


    case 0:
        break;

    default:
        //
        // Unexpected error, print out generic error message
        //
        LoadString(g_hModule, IDS_GENERIC_ERROR, g_szTempBuffer, BUFFER_LENGTH);
        wprintf(g_szTempBuffer, dwErrorCode, dwLineNumber);

        if ((ERROR_SUCCESS != dwErrorCode) &&
            (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 
            NULL,
            dwErrorCode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
            g_szTempBuffer,
            BUFFER_LENGTH,
            NULL
            ))) {
        
            wprintf(L" %ws", g_szTempBuffer);
        }
        wprintf(L"\n");

    }

}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR lpOriginalString
    )
/*++

Routine Description:

    Allocates and returns a pointer to a new string containing a copy of the
    original string in which environment-variables replaced by their defined
    values.

    Uses the Win-32 API ExpandEnvironmentStrings.

    The caller must free the returned string using HeapFree(LocalProcessHeap).

Arguments:

    lpOriginalString - Pointer to a null-terminated string that contains 
            environment-variable strings of the form: %variableName%. For 
            each such reference, the %variableName% portion is replaced 
            with the current value of that environment variable. 

            The replacement rules are the same as those used by the command 
            interpreter. Case is ignored when looking up the environment-
            variable name. If the name is not found, the %variableName% 
            portion is left undisturbed. 

Return Value:
    
    If the function succeeds, the return value is a pointer to the destination 
        string containing the result of the expansion.  The caller must free 
        this memory using HeapFree for the current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

--*/
{
    PWSTR lpszResult = NULL;
    
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;

    BOOL bResult = FALSE;

    Alloc(lpszResult, PWSTR, cchSize * sizeof(WCHAR));
    if (!lpszResult) {
        return NULL;
    }

    cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
        lpszResult, cchSize);

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        Free(lpszResult);
        cchSize = cchRequiredSize + 1;

        Alloc(lpszResult, PWSTR, cchSize * sizeof(WCHAR));
        if (!lpszResult) {
            return NULL;
        }

        cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
            lpszResult, cchSize);
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        Free(lpszResult);   // sets it to NULL
    }

    return lpszResult;
}


DWORD
AsrpPrintUsage()
/*++

Routine Description:
    
    Loads and prints the incorrect-usage error string.

Arguments:

    None

Return Values:

    None

--*/
{
    wcscpy(g_szTempBuffer, L"");

    LoadString(g_hModule, IDS_ERROR_USAGE, g_szTempBuffer, BUFFER_LENGTH);

    wprintf(g_szTempBuffer, L"confdisk /save   ", L"confdisk /restore",  L"confdisk /save c:\\asr.sif");    

    return ERROR_INVALID_PARAMETER;
}


//
// --------
// functions used by /save
// --------
//
BOOL
AsrpAcquirePrivilege(
    IN CONST PCWSTR lpPrivilegeName
    )
/*++

Routine Description:

    Acquires the requested privilege (such as the backup privilege).

Arguments:

    lpPrivilegeName - The required privilege (such as SE_BACKUP_NAME)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/
{

    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;
    DWORD dwStatus = ERROR_SUCCESS;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hToken);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    bResult = LookupPrivilegeValue(NULL, lpPrivilegeName, &luid);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );
    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    ErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    _AsrpCloseHandle(hToken);

    SetLastError(dwStatus);
    return bResult;
}


DWORD
AsrpCreateSif(
    IN CONST PCWSTR lpSifPath   OPTIONAL
    )
/*++

Routine Description:

    Creates an ASR state file (asr.sif) at the requested location, using the
    ASR API from syssetup.dll.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be created.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

            This parameter can be NULL.  If it is NULL, the ASR state-file is 
            created at the default location (%systemroot%\repair\asr.sif). 

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    HMODULE hDll = NULL;
    BOOL bResult = FALSE;
    DWORD_PTR asrContext = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    PWSTR lpProvider = NULL,
        lpCriticalVolumes = NULL;

    BOOL (*pfnCreateSif)(PCWSTR, PCWSTR, CONST BOOL, PCWSTR, DWORD_PTR*);
    BOOL (*pfnFreeContext)(DWORD_PTR* );

    pfnCreateSif = NULL;
    pfnFreeContext = NULL;

    //
    // We need to acquire the backup privileges to create asr.sif
    //
    bResult = AsrpAcquirePrivilege(SE_BACKUP_NAME);
    ErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    bResult = AsrpAcquirePrivilege(SE_RESTORE_NAME);
    ErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    //
    // Get the critical volume list
    //
    lpCriticalVolumes = pFindCriticalVolumes();
    ErrExitCode(!lpCriticalVolumes, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    //
    // Load syssetup, and find the routines to call
    //
    hDll = LoadLibraryW(L"syssetup.dll");
    ErrExitCode(!hDll, dwStatus, GetLastError());

    pfnCreateSif = (BOOL (*)(PCWSTR, PCWSTR, CONST BOOL, PCWSTR, DWORD_PTR*)) 
        GetProcAddress(hDll, "AsrCreateStateFileW");
    ErrExitCode(!pfnCreateSif, dwStatus, GetLastError());


    pfnFreeContext = (BOOL (*)(DWORD_PTR *)) 
        GetProcAddress(hDll, "AsrFreeContext");
    ErrExitCode(!pfnFreeContext, dwStatus, GetLastError());

    //
    // Finally, call the routine to create the state file:
    //
    bResult = pfnCreateSif(lpSifPath,   // lpFilePath,
        lpProvider,                     // lpProviderName
        TRUE,                           // bEnableAutoExtend
        lpCriticalVolumes,              // mszCriticalVolumes
        &asrContext                     // lpAsrContext
        );
    ErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (lpCriticalVolumes) {
      delete lpCriticalVolumes;
      lpCriticalVolumes = NULL;
    }
 
    if (pfnFreeContext && asrContext) {
        pfnFreeContext(&asrContext);
    }

    if (hDll) {
        FreeLibrary(hDll);
        hDll = NULL;
    }

   return dwStatus;
}


//
// --------
// functions used by /restore
// --------
//
PWSTR
AsrpReadField(
    PINFCONTEXT pInfContext,
    DWORD dwFieldIndex
   )
/*++

Routine Description:

    Reads and returns a pointer to string at the specified index from a sif.

    The caller must free the returned string using HeapFree(LocalProcessHeap).

Arguments:

    pInfContext - The Inf Context to use to read the value, obtained from
            SetupGetLineByIndexW.

    dwFieldIndex - The 1 based field index of the string value to read.

Return Value:
    
    If the function succeeds, the return value is a pointer to the destination 
        string.  The caller must free this memory using HeapFree for the 
        current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

--*/
{
    DWORD cchReqdSize = 0;
    BOOL bResult = FALSE;
    PWSTR lpszData = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Allocate memory and read the data
    //
    Alloc(lpszData, PWSTR, MAX_PATH * sizeof(WCHAR));
    ErrExitCode(!lpszData, dwStatus, GetLastError());

    bResult = SetupGetStringFieldW(pInfContext, dwFieldIndex, lpszData,
        MAX_PATH, &cchReqdSize);

    if (!bResult) {
        dwStatus = GetLastError();

        //
        // If our buffer was too small, allocate a larger buffer
        // and try again
        //
        if (ERROR_INSUFFICIENT_BUFFER == dwStatus) {
            dwStatus = ERROR_SUCCESS;

            Free(lpszData);
            Alloc(lpszData, PWSTR, (cchReqdSize * sizeof(WCHAR)));
            ErrExitCode(!lpszData, dwStatus, GetLastError());

            bResult = SetupGetStringFieldW(pInfContext, dwFieldIndex,
                lpszData, cchReqdSize, NULL);
        }
    }

    if (!bResult) {
        Free(lpszData);
    }

EXIT:
    return lpszData;
}


VOID
AsrpInsertNodeToList(
    IN OUT PASR_RECOVERY_APP_LIST pList,
    IN OUT PASR_RECOVERY_APP_NODE pNode 
   )
/*++

Routine Description:

    Does an insertion sort using the SequenceNumber as the key, to insert a 
    Node to a List.

Arguments:

    pList - The List in which to insert the node.

    pNode - The Node to insert.

Return Value:

    None

--*/
{

    PASR_RECOVERY_APP_NODE pPrev = NULL,
        pCurr = NULL;

    if (pList->AppCount == 0) {
        //
        // First node being added
        //
        pNode->Next = NULL;
        pList->First = pNode;

    } 
    else {
        //
        // Find the slot to insert this in, based on the SequenceNumber
        //
        pCurr = pList->First;
        pPrev = NULL;

        while ((pCurr) && (pCurr->SequenceNumber < pNode->SequenceNumber)) {
            pPrev = pCurr;
            pCurr = pCurr->Next;
        }

        if (pPrev) {
            pPrev->Next = pNode;
        }
        else {
            pList->First = pNode;            // Head of the list
        }

        pNode->Next = pCurr;
    }

    pList->AppCount += 1;
}


PASR_RECOVERY_APP_NODE
AsrpGetNextRecoveryApp(
    IN OUT PASR_RECOVERY_APP_LIST pList
    )
/*++

Routine Description:

    Removes and returns the first Node in a List.

Arguments:

    pList - The List from which to remove

Return Value:

    A pointer to the first Node in the List.  Note that this Node is removed
            from the list.  

    NULL if the List is empty.

--*/
{
    PASR_RECOVERY_APP_NODE pNode = NULL;

    if (pList->AppCount > 0) {
        pNode = pList->First;
        pList->First = pNode->Next;
        pList->AppCount -= 1;
    }

    return pNode;
}


DWORD 
AsrpBuildRecoveryAppList(
    IN  CONST PCWSTR lpSifPath,
    OUT PASR_RECOVERY_APP_LIST pList
    )
/*++

Routine Description:

    Parses the COMMANDS section of asr.sif, and builds a list of recovery 
    apps (that have SequenceNumber < 4000) to be launched.  It skips apps
    with SequenceNumbers >= 4000 so that we don't launch the actual 
    backup-and-restore (supposed to use sequence numbers >= 4000) listed.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
    pList - Pointer to a struct that will receive the list recovery apps to 
            be launched.

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    INFCONTEXT inf;
    HINF hSif = NULL;
    LONG line = 0,
        lLineCount = 0;
    BOOL bResult = FALSE;
    INT iSequenceNumber = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    PASR_RECOVERY_APP_NODE pNode = NULL;

    //
    // Open asr.sif and build the list of commands to be launched.
    //
    hSif = SetupOpenInfFileW(lpSifPath, NULL, INF_STYLE_WIN4, NULL);
    ErrExitCode((!hSif || (INVALID_HANDLE_VALUE == hSif)), 
        dwStatus, GetLastError());

    //
    // Read the COMMANDS section, and add each command to our list
    //
    lLineCount = SetupGetLineCountW(hSif, L"COMMANDS");
    for (line = 0; line < lLineCount; line++) {
        //
        //  Get the inf context for the line in asr.sif.  This will be used
        //  to read the fields on that line
        //
        bResult = SetupGetLineByIndexW(hSif, L"COMMANDS", line, &inf);
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        //
        // Read in the int fields.  First, check the SequenceNumber, and skip
        // this record if the SequenceNumber is >= 4000
        //
        bResult = SetupGetIntField(&inf, SequenceNumber, &iSequenceNumber);
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        if (iSequenceNumber >= 4000) {
            continue;
        }

        //
        // Create a new node
        //
        Alloc(pNode, PASR_RECOVERY_APP_NODE, sizeof(ASR_RECOVERY_APP_NODE));
        ErrExitCode(!pNode, dwStatus, GetLastError());
        
        pNode->SequenceNumber = iSequenceNumber;

        bResult = SetupGetIntField(&inf, SystemKey, &(pNode->SystemKey));
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        bResult = SetupGetIntField(&inf, CriticalApp, &(pNode->CriticalApp));
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        //
        // Read in the string fields
        //
        pNode->RecoveryAppCommand = AsrpReadField(&inf, CmdString);
        ErrExitCode((!pNode->RecoveryAppCommand), dwStatus, ERROR_INVALID_DATA);

        pNode->RecoveryAppParams = AsrpReadField(&inf, CmdParams);
        // null okay

        //
        // Add this node to our list, and move on to next
        //
        AsrpInsertNodeToList(pList, pNode);     
    }

EXIT:
    if (hSif && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
    }

    return dwStatus;
}


PWSTR
AsrpBuildInvocationString(
    IN PASR_RECOVERY_APP_NODE pNode,
    IN CONST PCWSTR lpSifPath
   )
/*

Routine Description:

    Builds the invocation string, as the name suggests.  It expands out the 
    environment variables in the recovery app path, and adds in 
    /sifpath=<path to the sif file> at the end of the command.  So for an 
    entry in the COMMANDS section of the form:
    4=1,3500,0,"%TEMP%\app.exe","/param1 /param2"

    the invocation string would be of the form:
    c:\temp\app.exe /param1 /param2 /sifpath=c:\windows\repair\asr.sif

Arguments:

    pNode - The node from which to build the invocation string.

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

Return Value:

    If the function succeeds, the return value is a pointer to the destination 
        string containing the result of the expansion.  The caller must free 
        this memory using HeapFree for the current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

*/
{
    PWSTR lpszApp   = pNode->RecoveryAppCommand,
        lpszArgs    = pNode->RecoveryAppParams,
        lpszCmd     = NULL,
        lpszFullcmd = NULL;
    DWORD dwSize    = 0;

    //
    // Build an command line that looks like...
    //
    //      "%TEMP%\ntbackup recover /1 /sifpath=%systemroot%\repair\asr.sif"
    //
    // The /sifpath parameter is added to all apps being launched
    //

    //
    //  Allocate memory for the cmd line
    //
    dwSize = sizeof(WCHAR) * (
        wcslen(lpszApp) +                   // app name     %TEMP%\ntbackup
        (lpszArgs ? wcslen(lpszArgs) : 0) + // arguments    recover /1
        wcslen(lpSifPath) +         // path to sif  c:\windows\repair\asr.sif
        25                          // spaces, null, "/sifpath=", etc
        );
    Alloc(lpszCmd, PWSTR, dwSize); 
    if (lpszCmd) {

        //
        // Build the string
        //
        swprintf(lpszCmd, L"%ws %ws /sifpath=%ws", lpszApp, 
            (lpszArgs? lpszArgs: L""), lpSifPath);

        //
        // Expand the %% stuff, to build the full path
        //
        lpszFullcmd = AsrpExpandEnvStrings(lpszCmd);
        
        Free(lpszCmd);
    }
    return lpszFullcmd;
}


VOID
AsrpSetEnvironmentVariables()
/*++

Routine Description:

    Set some environment variables of interest.

Arguments:

    None

Return Value:

    None

--*/
{
    PWSTR TempPath = AsrpExpandEnvStrings(L"%systemdrive%\\TEMP");

    //
    // Set the TEMP and TMP variables to the same as GUI-mode recovery
    //
    SetEnvironmentVariableW(L"TEMP", TempPath);
    SetEnvironmentVariableW(L"TMP", TempPath);
    Free(TempPath);

    //
    // Clear this variable (it shouldn't exist anyway), since this is
    // meant to be set only if this is a full GUI-mode ASR
    //
    SetEnvironmentVariableW(L"ASR_C_CONTEXT", NULL);

}


DWORD
AsrpRestoreSif(
    IN CONST PCWSTR lpSifPath
    )
/*++

Routine Description:

    Restores the disk layout specified in the ASR state file (asr.sif), using 
    the ASR API in syssetup.dll.  Then launches the recovery apps specified
    in the COMMANDS section of asr.sif, with sequence numbers less than 4000.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    BOOL bResult = TRUE;
    HMODULE hDll = NULL;
    STARTUPINFOW startUpInfo;
    PWSTR lpFullSifPath = NULL,
          lpszAppCmdLine = NULL;
    ASR_RECOVERY_APP_LIST AppList;
    DWORD dwStatus = ERROR_SUCCESS;
    PROCESS_INFORMATION processInfo;
    PASR_RECOVERY_APP_NODE pNode = NULL;

    BOOL (*pfnRestoreDisks)(PCWSTR, BOOL);

    pfnRestoreDisks = NULL;
    ZeroMemory(&AppList, sizeof(ASR_RECOVERY_APP_LIST));
    ZeroMemory(&startUpInfo, sizeof(STARTUPINFOW));
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    lpFullSifPath = AsrpExpandEnvStrings(lpSifPath);
    ErrExitCode(!lpFullSifPath, dwStatus, GetLastError());

    //
    // To restore the disks, load syssetup and get the routine of interest
    //
    hDll = LoadLibraryW(L"syssetup.dll");
    ErrExitCode(!hDll, dwStatus, GetLastError());

    pfnRestoreDisks = (BOOL (*)(PCWSTR, BOOL)) 
        GetProcAddress(hDll, "AsrpRestoreNonCriticalDisksW");
    ErrExitCode(!pfnRestoreDisks, dwStatus, GetLastError());

    AsrpSetEnvironmentVariables();

    //
    // Recreate the disks.  We don't need the AllOrNothing granularity--it's 
    // okay if some disks come back but others don't,
    //
    bResult = pfnRestoreDisks(lpFullSifPath, FALSE); 
    ErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Now, we need to launch the recovery apps in the COMMANDS section.
    // Note that we'll only launch apps with a sequence number below 4000,
    // so that we don't launch the actual backup-and-restore app listed.
    // Backup-and-restore apps are supposed to use sequence numbers >= 4000.
    //

    //
    // Parse the sif to obtain list of apps to run
    //
    dwStatus = AsrpBuildRecoveryAppList(lpFullSifPath, &AppList);
    ErrExitCode((ERROR_SUCCESS != dwStatus), dwStatus, dwStatus);

    //
    // And launch them synchronously.  
    //
    pNode = AsrpGetNextRecoveryApp(&AppList);
    while (pNode) {

        lpszAppCmdLine = AsrpBuildInvocationString(pNode, lpFullSifPath);
        //
        // We don't need pNode any more
        //
        Free(pNode->RecoveryAppParams);
        Free(pNode->RecoveryAppCommand);
        Free(pNode);

        if (!lpszAppCmdLine) {
            //
            // Silently fail   !TODO: May need error message
            //
            continue;
        }

        // !TODO: May need status message
        wprintf(L"[%ws]\n", lpszAppCmdLine);
        
        bResult = CreateProcessW(
            NULL,           // lpApplicationName
            lpszAppCmdLine, // lpCommandLine
            NULL,           // lpProcessAttributes
            NULL,           // lpThreadAttributes
            FALSE,          // bInheritHandles
            0,              // dwCreationFlags
            NULL,           // pEnvironment 
            NULL,           // lpCurrentDirectory (null=current dir)
            &startUpInfo,   // statup information
            &processInfo    // process information
            );
        
        if (bResult) {
            WaitForSingleObject(processInfo.hProcess, INFINITE);
        }
        // else silently fail   !TODO: May need error message

        Free(lpszAppCmdLine);
        pNode = AsrpGetNextRecoveryApp(&AppList);
    }


EXIT:
    if (hDll && (INVALID_HANDLE_VALUE != hDll)) {
        FreeLibrary(hDll);
        hDll = NULL;
    }

    return dwStatus;
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )
/*++

Routine Description:
    
    Entry point to the application.

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings.  See the top
            of this module for the list of valid parameters.

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Initialise globals
    //
    g_hModule = GetModuleHandle(NULL);
    g_hHeap = GetProcessHeap();
    g_fErrorMessageDone = FALSE;

    //
    // Check and switch on the basis of the command line arguments
    //
    if ((argc >= 2) && (
        !_wcsicmp(argv[1], L"/save") ||
        !_wcsicmp(argv[1], L"-save") ||
        !_wcsicmp(argv[1], L"save")
        )) {
        //
        // confdisk /save [c:\windows\asr.sif]
        //
        dwStatus = AsrpCreateSif(argv[2]);
    }
    else if ((argc >= 3) && (
        !_wcsicmp(argv[1], L"/restore") ||
        !_wcsicmp(argv[1], L"-restore") ||
        !_wcsicmp(argv[1], L"restore")
        )) {
        //
        // confdisk /restore c:\windows\repair\asr.sif
        //
        dwStatus = AsrpRestoreSif(argv[2]);
    }
    else {
        //
        // Unknown parameter
        //
        dwStatus = AsrpPrintUsage();
    }

    //
    // We're all done.  Return the error-code, for interested parties.
    // 
    return (int) dwStatus;

    UNREFERENCED_PARAMETER(envp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asrsfgen\log.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.h

Abstract:
    
    Header file for routines to log errors, warnings and info in the asr 
    log file at %systemroot%\repair\asr.log

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/

#ifndef _INC_ASR_SF_GEN__LOG_H_
#define _INC_ASR_SF_GEN__LOG_H_

typedef enum __MesgLevel {
    s_Info = 0,
    s_Warning,
    s_Error
} _MesgLevel;


//
// Functions for logging error messages
//

VOID
AsrpInitialiseLogFiles(
    VOID
    );

VOID
AsrpCloseLogFiles(
    VOID
    );

VOID
AsrpPrintDbgMsg(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR FormatString,
    ...
    );


//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define ErrExitCode(ErrorCondition, LocalStatus, ErrorCode) {           \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        if ((BOOL) ErrorCode) {                                         \
            AsrpPrintDbgMsg(s_Error, "%S(%lu): ErrorCode: %lu, GetLastError:%lu\n", \
                __FILE__, __LINE__, ErrorCode, GetLastError());         \
        }                                                               \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


#endif // _INC_ASR_SF_GEN__LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\wipedisk\wipedisk.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wipedisk.cpp

Abstract:

    Utility program to zero out the partition-tables and first/last
    few sectors of disks

Author:

    Guhan Suriyanarayanan   (guhans)    30-Sep-2000

Environment:

    User-mode only.

Revision History:

    30-Sep-2000 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ntdddisk.h>

BOOL g_bPrompt = TRUE;

//
// write in 64K chunks.
//
#define BUFFER_SIZE_BYTES (64 * 1024)


BOOL
pSetSignature(
    IN CONST ULONG ulDiskNumber,
    IN CONST DWORD dwNewSignature
    )
{
    DWORD dwStatus = ERROR_SUCCESS,
        dwBytesReturned = 0,
        dwBufferSize = 0;

    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutEx;

    int i = 0, loopTimes = 0;

    BOOL bResult = FALSE;

    HANDLE hDisk = NULL,
        hHeap = NULL;

    WCHAR szFriendlyName[100];  // For display  "Disk 2"
    WCHAR szDiskPath[100];      // For CreateFile   "\\.\PhysicalDrive2"

    wsprintf(szFriendlyName, L"Disk %lu", ulDiskNumber);
    wsprintf(szDiskPath, L"\\\\.\\PhysicalDrive%lu", ulDiskNumber);
    hHeap = GetProcessHeap();

    hDisk = CreateFile(
        szDiskPath,                     // lpFileName
        GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_EXISTING,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,          // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((INVALID_HANDLE_VALUE == hDisk) || (NULL == hDisk)) {
        //
        // Couldn't open a handle.
        //
        wprintf(L"Unable to open a handle to %ws (%lu)\n", szDiskPath, GetLastError());
        return FALSE;
    }

    dwBufferSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 
        (sizeof(PARTITION_INFORMATION_EX) * 3);

    driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        dwBufferSize
        );
    if (!driveLayoutEx) {
        wprintf(L"Could not allocate memory\n");
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT;
    }

    bResult = FALSE;
    while (!bResult) {

        bResult = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            driveLayoutEx,
            dwBufferSize,
            &dwBytesReturned,
            NULL
            );

        if (!bResult) {
            dwStatus = GetLastError();
            HeapFree(hHeap, 0L, driveLayoutEx);
            driveLayoutEx = NULL;

            // 
            // If the buffer is of insufficient size, resize the buffer.  
            // Note that get-drive-layout-ex could return error-insufficient-
            // buffer (instead of? in addition to? error-more-data)
            //
            if ((ERROR_MORE_DATA == dwStatus) || 
                (ERROR_INSUFFICIENT_BUFFER == dwStatus)
                ) {
                dwStatus = ERROR_SUCCESS;
                dwBufferSize += sizeof(PARTITION_INFORMATION_EX) * 4;

                driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    dwBufferSize
                    );
                if (!driveLayoutEx) {
                    wprintf(L"Could not allocate memory\n");
                    dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto EXIT;
                }
            }
            else {
                // 
                // some other error occurred, EXIT, and go to the next drive.
                //
                wprintf(L"Could not get the drive layout for %ws (%lu)\n", szDiskPath, dwStatus);
                goto EXIT;
            }
        }
    }


    //
    // Now modify the signature, and set the layout again
    //
    driveLayoutEx->Mbr.Signature = dwNewSignature;

    bResult = DeviceIoControl(
        hDisk,
        IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
        driveLayoutEx,
        dwBufferSize,
        NULL,
        0L,
        &dwBytesReturned,
        NULL
        );

    if (!bResult) {
        //
        // SET_DRIVE_LAYOUT failed
        //
        dwStatus = GetLastError();
        wprintf(L"Could not SET the drive layout for %ws (%lu)\n", szDiskPath, dwStatus);
        goto EXIT;
    }


EXIT:

    if (driveLayoutEx) {
        HeapFree(hHeap, 0L, driveLayoutEx);
        driveLayoutEx = NULL;
    }

    if ((hDisk)  && (INVALID_HANDLE_VALUE != hDisk)) {
        CloseHandle(hDisk);
        hDisk = NULL;
    }

    SetLastError(dwStatus);
    return bResult;
}

BOOL
pConfirmWipe(
    IN CONST PCWSTR szDiskDisplayName
    )
{

    WCHAR   szInput[10];

    wprintf(L"\nWARNING.  This will delete all partitions from %ws\n", szDiskDisplayName);
    wprintf(L"Are you sure you want to continue [y/n]? ");
    wscanf(L"%ws", szInput);

    wprintf(L"\n");
    return ((L'Y' == szInput[0]) || (L'y' == szInput[0]));
}


BOOL
pWipeDisk(
    IN CONST ULONG ulDiskNumber,
    IN CONST ULONG ulFirstMB,
    IN CONST ULONG ulLastMB
    )

/*++

Routine Description:

    Deletes the drive layout for disk, and writes 0's at the start and end of the disk.

Arguments:

    ulDiskNumber - DiskNumber to wipe

    ulFirstMB - Number of MB to erase at the beginning of the disk

    ulLastMB - Number of MB to erase at the end of the disk

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD dwStatus = ERROR_SUCCESS,
        dwBytes = 0;

    BYTE Buffer[BUFFER_SIZE_BYTES];
    int i = 0, loopTimes = 0;

    BOOL bResult = FALSE;

    HANDLE hDisk = NULL;
    WCHAR szFriendlyName[100];  // For display  "Disk 2"
    WCHAR szDiskPath[100];      // For CreateFile   "\\.\PhysicalDrive2"

    PARTITION_INFORMATION_EX ptnInfo;
    
    wsprintf(szFriendlyName, L"Disk %lu", ulDiskNumber);
    wsprintf(szDiskPath, L"\\\\.\\PhysicalDrive%lu", ulDiskNumber);

    ZeroMemory(Buffer, BUFFER_SIZE_BYTES);


    if (g_bPrompt && !pConfirmWipe(szFriendlyName)) {
        //
        // User didn't want to continue
        //
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    //
    // Set the signature to something random.  We need to do this before
    // deleting the layout for the boot disk.
    //
    pSetSignature(ulDiskNumber, 0);


    hDisk = CreateFile(
        szDiskPath,                     // lpFileName
        GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_EXISTING,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,          // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((INVALID_HANDLE_VALUE == hDisk) || (NULL == hDisk)) {
        //
        // Couldn't open a handle.
        //
        wprintf(L"Unable to open a handle to %ws (%lu)\n", szDiskPath, GetLastError());
        return FALSE;
    }

    //
    // Zero out the first two sectors of each partition?
    //



    //
    // Delete the drive layout
    //
    wprintf(L"Deleting partitions on %ws ...\n", szFriendlyName);
    bResult = DeviceIoControl(
        hDisk,
        IOCTL_DISK_DELETE_DRIVE_LAYOUT,
        NULL,
        0L,
        NULL,
        0L,
        &dwBytes,
        NULL
        );

    bResult = TRUE;
    if (!bResult) {
        wprintf(L"Unable to delete partitions on %ws (%lu)\n", szDiskPath, GetLastError());

        CloseHandle(hDisk);
        return FALSE;
    }


    //
    // Erase MB at the start of the disk
    //
    if (ulFirstMB > 0) {

        wprintf(L"Erasing first %lu MB on %ws ...\n", ulFirstMB, szFriendlyName);
        
        //
        // Write 0's to disk in BUFFER_SIZE chunks
        //
        loopTimes = (ulFirstMB * 1024 * 1024 / BUFFER_SIZE_BYTES);
        for (i = 0; i < loopTimes; i++) {
            bResult = WriteFile(
                hDisk,
                &Buffer,
                BUFFER_SIZE_BYTES,
                &dwBytes,
                NULL
                );

            if (!bResult) {
                wprintf(L"Error while writing to %ws (%d, %lu)\n", szDiskPath, i, GetLastError());
                break;
            }        
        }
        if (!bResult) {
            CloseHandle(hDisk);
            return FALSE;
        }
    }


    //
    // Erase MB at the end of the disk
    //
    if (ulLastMB > 0) {

        wprintf(L"Erasing last %lu MB on %ws ...\n", ulLastMB, szFriendlyName);

        //
        // Find the end of the disk
        //
        bResult = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO_EX,
            NULL,
            0,
            &ptnInfo,
            sizeof(PARTITION_INFORMATION_EX),
            &dwBytes,
            NULL
            );
        if (!bResult) {
           wprintf(L"Could not find size of disk %ws (%lu)\n", szDiskPath, GetLastError());
           CloseHandle(hDisk);
           return FALSE;
        }

        // 
        // Find offset we'd like to start zero-ing out from
        // (end of disk - bytes to zero out)
        //
        ptnInfo.PartitionLength.QuadPart -= (ulLastMB * 1024 * 1024);

        dwBytes = SetFilePointer(hDisk, (ptnInfo.PartitionLength.LowPart), &(ptnInfo.PartitionLength.HighPart), FILE_BEGIN);
        if ((INVALID_SET_FILE_POINTER == dwBytes) && (NO_ERROR != GetLastError())) {
            wprintf(L"Could not move to end of disk for %ws (%lu)\n", szDiskPath, GetLastError());
        }

        //
        // Write 0's to disk in BUFFER_SIZE chunks
        //
        loopTimes = (ulLastMB * 1024 * 1024 / BUFFER_SIZE_BYTES);
        for (i = 0; i < loopTimes; i++) {
            bResult = WriteFile(
                hDisk,
                &Buffer,
                BUFFER_SIZE_BYTES,
                &dwBytes,
                NULL
                );

            if (!bResult) {
                wprintf(L"Error while writing to %ws (%d, %lu)\n", szDiskPath, i, GetLastError());
                break;
            }        
        }
        if (!bResult) {
            CloseHandle(hDisk);
            return FALSE;
        }
    }

    CloseHandle(hDisk);
    return TRUE;
}



VOID
pPrintUsage(
    IN CONST PCWSTR szArgV0
    ) {

    wprintf(L"usage:  %ws [/f] disk-number [mb-at-start [mb-at-end]]\n"
            L"        %ws /s new-signature disk-number\n"
            L"\n"
            L"  /f:            Suppress the prompt to confirm action\n"
            L"\n"
            L"  disk-number:   The NT disk-number of the disk that\n"
            L"                 the operation is to be performed\n"
            L"\n"
            L"  mb-at-start:   The number of MB to zero-out at\n"
            L"                 the start of the disk.  Default is 1\n"
            L"\n"
            L"  mb-at-end:     The number of MB to zero-out at\n"
            L"                 the end of the disk.  Default is 4\n"
            L"\n",
            L"  /s:            Set the signature of disk\n"
            L"\n"
            L"  new-signature: Value to set the disk signature to.\n"
            L"                 Specify 0 to use a randomly generated\n"
            L"                 value\n"
            L"\n",
            szArgV0,
            szArgV0
            );
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )

/*++

Routine Description:
    
    Entry point to wipedisk.exe.  

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings.  
            argv[1] (required) is expected to be the disk number
            argv[2] (optional) is the initial MB to erase, default 1
            argv[3] (optional) is the last MB to erase, default 4

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/

{
    BOOL bResult = TRUE,
        bSetSignature = FALSE;

    ULONG ulDiskNumber = 0,
        ulInitialMB = 1,
        ulFinalMB = 4;

    DWORD dwNewSignature = 0L;

    int shift = 0;

    SetLastError(ERROR_CAN_NOT_COMPLETE);   // for unexpected failures

    if (argc >= 2) {
        if ((L'-' == argv[1][0]) || (L'/' == argv[1][0])) {
            //
            // Parse the options
            //

            switch (argv[1][1]) {
            case L'f':
            case L'F': {

                g_bPrompt = FALSE;
                shift = 1;  // account for /f
                break;
            }

            case L's':
            case L'S': {

                bSetSignature = TRUE;
                shift = 2;  // account for /s <New Signature>
                break;
            }
            }
        }
    }

    if (argc >= shift + 2) {
        swscanf(argv[shift + 1], L"%lu", &ulDiskNumber);
    }
    else {
        //
        // We need at least one argument--the disk number
        //
        pPrintUsage(argv[0]);
        return ERROR_INVALID_PARAMETER;
    }

    if (bSetSignature) {

        //
        // Set the signature of the disk to a new value
        //
        swscanf(argv[shift], L"%lu", &dwNewSignature);
        bResult = pSetSignature(ulDiskNumber, dwNewSignature);

    }
    else {
        //
        // Wipe the disk.  Get the amount to zero-out at the start
        // and end of disk
        //
        if (argc >= shift + 3) {
            swscanf(argv[shift + 2], L"%lu", &ulInitialMB);

            if (argc >= shift + 4) {
                swscanf(argv[shift + 3], L"%lu", &ulFinalMB);
            }
        }


        bResult = pWipeDisk(ulDiskNumber, ulInitialMB, ulFinalMB);
    }

    if (bResult) {
        wprintf(L"Done.\n");
    }

    return (bResult ? 0 : GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\confdisk\confdisk.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confdisk.h

Abstract:

    Utility program to create an ASR state-file (asr.sif), or restore 
    non-critical disk layout based on a previously created asr.sif.

Author:

    Guhan Suriyanarayanan   (guhans)    15-April-2001

Environment:

    User-mode only.

Revision History:

    15-Apr-2001 guhans
        Initial creation

--*/

//
// --------
// typedefs and constants 
// --------
//
#define BUFFER_LENGTH 1024

//
// Indices for fields in the [COMMANDS] section.  This is from 
// base\ntsetup\syssetup\setupasr.c.
//
typedef enum _SIF_COMMANDS_FIELD_INDEX {
    CmdKey = 0,
    SystemKey,            // Must always be "1"
    SequenceNumber,
    CriticalApp,
    CmdString,
    CmdParams,         // May be NULL
    CmdNumFields       // Must always be last
} SIF_SYSTEM_FIELD_INDEX;


//
// One ASR_RECOVERY_APP_NODE struct is created for each entry
// in the [COMMANDS] section of asr.sif.
//
typedef struct _ASR_RECOVERY_APP_NODE {
    struct _ASR_RECOVERY_APP_NODE *Next;

    //
    // Expect this to always be 1
    //
    INT SystemKey;

    //
    // The sequence number according to which the apps are run.  If
    // two apps have the same sequence number, the app that appears 
    // first in the sif file is run.
    //
    INT SequenceNumber;

    //
    // The "actionOnCompletion" field for the app.  If CriticalApp is
    // non-zero, and the app returns an non-zero exit-code, we shall
    // consider it a fatal failure and quit out of ASR.
    //
    INT CriticalApp;

    //
    // The app to be launched
    //
    PWSTR RecoveryAppCommand;

    //
    // The paramaters for the app.  This is just concatenated to the
    // string above.  May be NULL.
    //
    PWSTR RecoveryAppParams;

} ASR_RECOVERY_APP_NODE, *PASR_RECOVERY_APP_NODE;


//
// This contains our list of entries in the COMMANDS section,
// sorted in order of sequence numbers.
//
typedef struct _ASR_RECOVERY_APP_LIST {
    PASR_RECOVERY_APP_NODE  First;      // Head
    PASR_RECOVERY_APP_NODE  Last;       // Tail
    LONG AppCount;                      // NumEntries
} ASR_RECOVERY_APP_LIST, *PASR_RECOVERY_APP_LIST;




//
// --------
// function declarations
// --------
//
VOID
AsrpPrintError(
    IN CONST DWORD dwLineNumber,
    IN CONST DWORD dwErrorCode
    );


//
// --------
// macro declarations
// --------
//

/*++

Macro Description:

    This macro wraps calls that are expected to return ERROR_SUCCESS.
    If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
    passed in, calls SetLastError() to set the Last Error to ErrorCode,
    and jumps to the EXIT label in the calling function

Arguments:

    ErrorCondition - Expression to be tested

    LocalStatus - Status variable in the calling function

    ErrorCode - Win 32 error code

--*/
#define ErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {        \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        if (!g_fErrorMessageDone) {                                     \
                                                                        \
            AsrpPrintError(__LINE__, ErrorCode);                        \
                                                                        \
            g_fErrorMessageDone = TRUE;                                 \
                                                                        \
        }                                                               \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}



// 
// Simple macro to allocate and set memory to zero
// 
#define Alloc( p, t, cb ) \
    p = (t) HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY,  cb)


// 
// Simple macro to check a pointer, free it if non-NULL, and set it to NULL.
// 
#define Free( p )                               \
    if ( p ) {                                  \
        HeapFree(g_hHeap, 0L, p);               \
        p = NULL;                               \
    }


//
// Simple macro to check if a handle is valid and close it
//
#define _AsrpCloseHandle( h )                   \
    if ((h) && (INVALID_HANDLE_VALUE != h)) {   \
        CloseHandle(h);                         \
        h = NULL;                               \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asrtools\asr_pfu\asr_pfu.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_pfu.c

Abstract:

    Application to deal with the recovery of certain special system files 
    that the normal backup/recovery applications are unable to deal with.

    The special file list below has the list of these files.  This is for
    RAID bug 612411.

Author:

    Guhan Suriyanarayanan   (guhans)    01-May-2002

Revision History:

    01-May-2002 guhans      
      Initial creation.  File list contains ntdll.dll and smss.exe.

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include <setupapi.h>

//
//  Macro Description:
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Expression to be tested
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // ErrorCode 
//
#ifdef PRERELEASE
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Error %lu (0x%x), line %lu\r\n", ErrorCode, ErrorCode, __LINE__);    \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}
#else
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}

#endif


//
// This is the hard-coded global list of files that are special
//
const DWORD PFU_NUM_SPECIAL_FILES = 2;

const WCHAR *PFU_SPECIAL_FILE_SOURCES[] = {
    L"%systemroot%\\system32\\ntdll.dll",
    L"%systemroot%\\system32\\smss.exe"
};

const WCHAR *PFU_SPECIAL_FILE_DESTINATIONS[] = {
    L"%systemroot%\\repair\\ntdll.ASR",
    L"%systemroot%\\repair\\smss.ASR"
};

const WCHAR *PFU_SPECIAL_FILE_TEMPFILES[] = {
    L"%systemroot%\\system32\\ntdll.TMP",
    L"%systemroot%\\system32\\smss.TMP"
};


//
// Copy 1MB chunks
//
#define CB_COPY_BUFFER (1024 * 1024)

//
// Constants local to this module
//
const WCHAR PFU_BACKUP_OPTION[]     = L"/backup";
const WCHAR PFU_RESTORE_OPTION[]    = L"/restore";
const WCHAR PFU_REGISTER_OPTION[]   = L"/register";

const WCHAR PFU_ERROR_FILE_PATH[]   = L"%systemroot%\\repair\\asr.err";

const WCHAR PFU_ASR_REGISTER_KEY[]  = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands";
const WCHAR PFU_ASR_REGISTER_NAME[] = L"ASR protected file utility";

#ifdef _IA64_
const WCHAR PFU_CONTEXT_FORMAT[]       = L"/context=%I64u";
#else
const WCHAR PFU_CONTEXT_FORMAT[]       = L"/context=%lu";
#endif


BOOL
PfuAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    CloseHandle(hToken);
    return bResult;
}




PWSTR
PfuExpandEnvStrings(
    IN CONST PCWSTR lpOriginalString
    )
/*++

Routine Description:

    Expands the environment-variable strings and replaces them with their 
    defined values. 

Arguments:

    lpOriginalString - Supplies a null-terminated string that contains 
            environment-variable strings of the form: %variableName%.  For each 
            such reference, the %variableName% portion is replaced with the 
            current value of that environment variable. 

            The replacement rules are the same as those used by the command 
            interpreter.  Case is ignored when looking up the 
            environment-variable name. If the name is not found, the 
            %variableName% portion is left undisturbed. 
        
Return Values:
   
    Pointer to memory containing a null-terminated string with the
            environment-variable strings in lpOriginalString replaced with 
            their defined values.  It is the caller's responsibility to free 
            this string using HeapFree(GetProcessHeap(),...).

    NULL on failure.
    
--*/
{
    PWSTR lpExpandedString = NULL;
    
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;

    HANDLE hHeap = GetProcessHeap();

    lpExpandedString = (PWSTR) HeapAlloc(hHeap, 
        HEAP_ZERO_MEMORY, 
        (cchSize * sizeof(WCHAR))
        );
    
    if (lpExpandedString) {
        //
        // Expand the variables using the relevant system call.
        //
        cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
            lpExpandedString,
            cchSize 
            );

        if (cchRequiredSize > cchSize) {
            //
            // Buffer wasn't big enough; free and re-allocate as needed
            //
            HeapFree(hHeap, 0L, lpExpandedString);
            cchSize = cchRequiredSize + 1;

            lpExpandedString = (PWSTR) HeapAlloc(hHeap, 
                HEAP_ZERO_MEMORY, 
                (cchSize * sizeof(WCHAR))
                );
            
            if (lpExpandedString) {
                cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
                    lpExpandedString, 
                    cchSize 
                    );
            }
        }

        if ((lpExpandedString) &&
            ((0 == cchRequiredSize) || (cchRequiredSize > cchSize))) {
            //
            // Either the function failed, or the buffer wasn't big enough 
            // even on the second try
            //
            HeapFree(hHeap, 0L, lpExpandedString);
            lpExpandedString = NULL;
        }
    }

    return lpExpandedString;
}


HANDLE
PfuOpenErrorFile(
    VOID
    ) 
/*++

Routine Description:

    Opens the well-known ASR error file for read/write access, moves the file 
    pointer to the end of the file.
    
Arguments:

    None.

Return Values:

    A handle to the well-defined ASR error file.  The caller is responsible for
            closing this handle with CloseHandle() when he is done.

    INVALID_HANDLE_VALUE on errors.

    
--*/
{
    PWSTR szErrorFilePath = NULL;
    HANDLE hErrorFile = INVALID_HANDLE_VALUE;

    //
    // Get full path to the error file.
    //
    szErrorFilePath = PfuExpandEnvStrings(PFU_ERROR_FILE_PATH);

    //
    // Open the error file
    //
    if (szErrorFilePath) {
        
        hErrorFile = CreateFileW(
            szErrorFilePath,            // lpFileName
            GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                       // lpSecurityAttributes
            OPEN_ALWAYS,                // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
            NULL                        // hTemplateFile
            );

        //
        // Free memory once we're done with it
        //
        HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
        szErrorFilePath = NULL;

        if (INVALID_HANDLE_VALUE != hErrorFile) {
            //
            // Move to the end of file
            //
            SetFilePointer(hErrorFile, 0L, NULL, FILE_END);
        }
    }

    return hErrorFile;
}


BOOL
PfuLogErrorMessage(
    IN CONST PCWSTR lpErrorMessage
    ) 
/*++

Routine Description:

    Logs an error message to the well-known ASR error file.
    
Arguments:

    lpErrorMessage - Supplies a null-terminated string to be logged to the
            ASR error file.

            This argument must be non-NULL.

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    DWORD dwBytes = 0;
    WCHAR szBuffer[1024];
    BOOL bResult = FALSE;
    SYSTEMTIME currentTime;
    HANDLE hErrorFile = INVALID_HANDLE_VALUE;

    hErrorFile = PfuOpenErrorFile();
    
    if (INVALID_HANDLE_VALUE != hErrorFile) {
        //
        // Create our string, and write it out
        //
        GetLocalTime(&currentTime);
        
        swprintf(szBuffer,
            L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu ASR_PFU] (ERROR) ",
            currentTime.wYear,
            currentTime.wMonth,
            currentTime.wDay,
            currentTime.wHour,
            currentTime.wMinute,
            currentTime.wSecond
            );
        wcsncat(szBuffer, lpErrorMessage, 964);
        szBuffer[1023] = L'\0';

        bResult = WriteFile(hErrorFile,
            szBuffer,
            (wcslen(szBuffer) * sizeof(WCHAR)),
            &dwBytes,
            NULL
            );

    }

    if (INVALID_HANDLE_VALUE != hErrorFile) {
        CloseHandle(hErrorFile);
    }

    return bResult;
}


BOOL 
PfuCopyFilesDuringBackup(
    VOID
    )
/*++

Routine Description:

    Copies the special protected files to the special location that we'll
    expect to find them during the restore.
    
Arguments:

    None.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE,
        bDone = FALSE;

    DWORD dwCount = 0,
        cbRead = 0,
        cbWritten = 0;

    DWORD dwStatus = ERROR_SUCCESS;

    PWSTR lpSource = NULL,
        lpDestination = NULL;

    HANDLE hSource = INVALID_HANDLE_VALUE,
        hDestination = INVALID_HANDLE_VALUE;

    LPBYTE lpBuffer = NULL;

    LPVOID pvReadContext = NULL,
        pvWriteContext = NULL;

    HANDLE hHeap = GetProcessHeap();

    lpBuffer = (LPBYTE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, CB_COPY_BUFFER);
    pErrExitCode((NULL == lpBuffer), dwStatus, GetLastError());

    for (dwCount = 0; dwCount < PFU_NUM_SPECIAL_FILES; dwCount++) {
        //
        // Get the full source and destination strings
        //
        lpSource = PfuExpandEnvStrings(PFU_SPECIAL_FILE_SOURCES[dwCount]);
        pErrExitCode(!lpSource, dwStatus, GetLastError());

        lpDestination = PfuExpandEnvStrings(PFU_SPECIAL_FILE_DESTINATIONS[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());


        //
        // We can't just use CopyFile since it doesn't seem to be able to write
        // to the repair folder, despite the backup and restore privileges 
        // being enabled.  So we get the pleasure of using BackupRead and 
        // BackupWrite instead.
        //

        //
        // Open handles to the source and destination files
        //
        hSource = CreateFile(lpSource, 
            GENERIC_READ, 
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            INVALID_HANDLE_VALUE
            );
        pErrExitCode((INVALID_HANDLE_VALUE == hSource), dwStatus, GetLastError());

        hDestination = CreateFile(lpDestination,         
            GENERIC_WRITE | WRITE_DAC | WRITE_OWNER, 
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            INVALID_HANDLE_VALUE
            );
        pErrExitCode((INVALID_HANDLE_VALUE == hDestination), dwStatus, GetLastError());

        bDone = FALSE;
        pvReadContext = NULL;
        pvWriteContext = NULL;

        while (!bDone) {
            
            bResult = BackupRead(
                hSource,                // hFile
                lpBuffer,               // lpBuffer
                CB_COPY_BUFFER,         // nNumberOfBytesToWrite
                &cbRead,                // lpNumberOfBytesWritten
                FALSE,                  // bAbort
                TRUE,                   // bProcessSecurity
                &pvReadContext          // lpContext
                );
            pErrExitCode((!bResult), dwStatus, GetLastError());
            
            if (cbRead > 0) {
                //
                // Write to the destination file
                //
                bResult = BackupWrite(
                    hDestination,       // hFile
                    lpBuffer,           // lpBuffer
                    cbRead,             // nNumberOfBytesToWrite
                    &cbWritten,         // lpNumberOfBytesWritten
                    FALSE,              // bAbort
                    TRUE,               // bProcessSecurity
                    &pvWriteContext     // *lpContext
                    );
                pErrExitCode((!bResult), dwStatus, GetLastError());
            }
            else {
                // 
                // We're done with this file
                //
                bResult = BackupRead(
                    hSource,              
                    lpBuffer,             
                    CB_COPY_BUFFER,       
                    &cbRead,              
                    TRUE,               // bAbort
                    TRUE,                 
                    &pvReadContext      // lpContext
                    );

                pvReadContext = NULL;
                
                bResult = BackupWrite(
                    hDestination,       
                    lpBuffer,           
                    cbRead,             
                    &cbWritten,         
                    TRUE,               // bAbort
                    TRUE,               
                    &pvWriteContext     // lpContext
                    );

                pvWriteContext = NULL;

                bDone = TRUE;
            }
                
        }


        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;

        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

EXIT:
    if (lpBuffer) {
        HeapFree(hHeap, 0L, lpBuffer);
        lpBuffer = NULL;
    }
        
    if (lpSource) {
        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;
    }

    if (lpDestination) {
        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuBackupState(
    IN CONST DWORD_PTR AsrContext
    )
/*++

Routine Description:

    Does the special handling necessary during an ASR backup.  This essentially
    involves two steps: copying the special protected files we care about
    to a special location, and adding an entry in asr.sif to allow us to 
    be called during the recovery.
    
Arguments:

    AsrContext - Supplies a AsrContext that is to be passed to the ASR API
            for adding entries to the ASR state file.

            This argument must be non-NULL.

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE;
    HMODULE hSyssetup = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL (*pfnAddSifEntry)(DWORD_PTR, PCWSTR, PCWSTR);

    bResult = PfuAcquirePrivilege(SE_BACKUP_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);
    
    bResult = PfuAcquirePrivilege(SE_RESTORE_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    // 
    // Load syssetup.dll for the AsrAddSifEntry call
    //
    hSyssetup = LoadLibraryW(L"syssetup.dll");
    pErrExitCode((NULL == hSyssetup), dwStatus, GetLastError());

    // 
    // Get the AsrAddSifEntryW API exported by syssetup.dll
    //
    
    //     
    // BOOL
    // AsrAddSifEntryW(
    //     IN  DWORD_PTR   AsrContext,
    //     IN  PCWSTR      lpSectionName,
    //     IN  PCWSTR      lpSifEntry
    //     );
    // 
    pfnAddSifEntry = (BOOL (*) (DWORD_PTR, PCWSTR, PCWSTR)) GetProcAddress(
        hSyssetup, 
        "AsrAddSifEntryW"
        );
    pErrExitCode((!pfnAddSifEntry), dwStatus,  GetLastError());

    //
    // Copy the special protected files of interest.
    //
    bResult = PfuCopyFilesDuringBackup();
    pErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Add an entry to the commands section, so that we get called during the 
    // ASR recovery.
    //
    
    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_COMMANDS,
        L"1,4990,1,\"%SystemRoot%\\system32\\asr_pfu.exe\",\"/restore\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (NULL != hSyssetup) {
        FreeLibrary(hSyssetup);
        hSyssetup = NULL;
    }

    SetLastError(dwStatus);
    
    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuRestoreState(
    VOID
    )
/*++

Routine Description:

    Does the special handling necessary during an ASR restore.  This essentially
    involves copying the special protected files we care about back from the 
    special location (that we copied them to while doing the backup).
    
Arguments:

    None.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE;

    DWORD dwCount = 0;

    DWORD dwStatus = ERROR_SUCCESS;

    PWSTR lpSource = NULL,
        lpDestination = NULL,
        lpTempFile = NULL;

    HANDLE hHeap = GetProcessHeap();
    
    bResult = PfuAcquirePrivilege(SE_BACKUP_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);
    
    bResult = PfuAcquirePrivilege(SE_RESTORE_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);


    for (dwCount = 0; dwCount < PFU_NUM_SPECIAL_FILES; dwCount++) {
        //
        // Get the full source and destination strings--they are reversed
        // at the time of the restore!
        //
        lpSource = PfuExpandEnvStrings(PFU_SPECIAL_FILE_DESTINATIONS[dwCount]);
        pErrExitCode(!lpSource, dwStatus, GetLastError());

        lpDestination = PfuExpandEnvStrings(PFU_SPECIAL_FILE_SOURCES[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());

        lpTempFile = PfuExpandEnvStrings(PFU_SPECIAL_FILE_TEMPFILES[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());

        //
        // Rename the destination if it already exists, and copy the file back
        //
        bResult = MoveFileEx(lpDestination, lpTempFile, MOVEFILE_REPLACE_EXISTING);

        bResult = CopyFile(lpSource, lpDestination, FALSE);
        pErrExitCode(!bResult, dwStatus, GetLastError());

        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;

        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
        
        HeapFree(hHeap, 0L, lpTempFile);
        lpTempFile = NULL;
    }

EXIT:    
    if (lpSource) {
        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;
    }

    if (lpDestination) {
        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

    if (lpTempFile) {
        HeapFree(hHeap, 0L, lpTempFile);
        lpTempFile = NULL;
    }

    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuRegisterApp(
    IN CONST PCWSTR lpApplicationName
    ) 
/*++

Routine Description:

    Adds the registry keys necessary to let ASR know that we wish to be
    run at ASR backup time.
    
Arguments:

    lpApplicationName - Supplies a null-terminated string representing the 
            full path to the application being registered.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    WCHAR szData[1024];
    HKEY hKeyAsr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if (wcslen(lpApplicationName) > 1000) {
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
    }

    // 
    // Open the registry key
    //
    if (ERROR_SUCCESS == dwStatus) {
        
        dwStatus = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,         // hKey
            PFU_ASR_REGISTER_KEY,       // lpSubKey
            0,                          // ulOptions--Reserved, must be 0
            MAXIMUM_ALLOWED,            // samDesired
            &hKeyAsr                    // phkbResult    
            );
    }

    //
    // And set the value
    //
    if (ERROR_SUCCESS == dwStatus) {
        
        wsprintf(szData, L"%ws %ws", lpApplicationName, PFU_BACKUP_OPTION);
        
        dwStatus = RegSetValueExW(
            hKeyAsr,                    // hKey
            PFU_ASR_REGISTER_NAME,      // lpValueName
            0,                          // dwReserved, must be 0
            REG_EXPAND_SZ,              // dwType
            (LPBYTE)szData,             // lpData
            ((wcslen(szData) + 1)* (sizeof(WCHAR))) // cbData
            );
    }

    SetLastError(dwStatus);
    return (ERROR_SUCCESS == dwStatus);
}


int 
__cdecl     // var arg
wmain (
    int     argc,
    wchar_t *argv[],
    wchar_t *envp[]
    ) 
{
    BOOL bResult = FALSE;
    
    DWORD dwStatus = ERROR_INVALID_PARAMETER;
    SetLastError(ERROR_INVALID_PARAMETER);

    if (argc >= 3) {
        
        if (!_wcsicmp(argv[1], PFU_BACKUP_OPTION)) {
            //
            // asr_pfu /backup /context=nnn
            //
            DWORD_PTR  AsrContext = 0;

            //
            // Extract the asr context from the commandline
            //
            int i = swscanf(argv[2], PFU_CONTEXT_FORMAT, &AsrContext);

            if (EOF != i) {
                //
                // Create our spooge and write to the asr.sif
                //
                bResult = PfuBackupState(AsrContext);
            }

            
        } 
        else if (!_wcsicmp(argv[1], PFU_RESTORE_OPTION)) {
            //
            // asr_pfu /restore /sifpath="c:\winnt\repair\asr.sif"
            //
            bResult = PfuRestoreState();
            
        }
        else if (!_wcsicmp(argv[1], PFU_REGISTER_OPTION)) {
            //
            // asr_pfu /register "c:\windows\system32\asr_pfu.exe"
            //
            bResult = PfuRegisterApp(argv[2]);
        }

        if (bResult) {
            dwStatus = ERROR_SUCCESS;
        }
        else {
            dwStatus = GetLastError();
        }
    }

    if (!bResult) {
        //
        // ?
        //
    }

    SetLastError(dwStatus);
    return (int) dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
#define AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\asr_fmt.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_fmt.cpp

Abstract:

    Main entry point for asr_fmt.  

Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Minor clean up.

--*/

#include "stdafx.h"
#include "asr_fmt.h"
#include "asr_dlg.h"


/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp

BEGIN_MESSAGE_MAP(CAsr_fmtApp, CWinApp)
     //{{AFX_MSG_MAP(CAsr_fmtApp)
     //}}AFX_MSG
     ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp construction

CAsr_fmtApp::CAsr_fmtApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CAsr_fmtApp object

CAsr_fmtApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp initialization

BOOL CAsr_fmtApp::InitInstance()
{
    int returnValue = ERROR_SUCCESS;
     AfxEnableControlContainer();

     // Standard initialization

#ifdef _AFXDLL
     Enable3dControls();               // Call this when using MFC in a shared DLL
#else
     Enable3dControlsStatic();     // Call this when linking to MFC statically
#endif

     CAsr_fmtDlg dlg;
     m_pMainWnd = &dlg;
     returnValue = (int) dlg.DoModal();

     // for now never fail
     exit((BOOL) returnValue);

     return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CProgress

CProgress::CProgress()
{
}

CProgress::~CProgress()
{
}


BEGIN_MESSAGE_MAP(CProgress, CProgressCtrl)
	//{{AFX_MSG_MAP(CProgress)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgress message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\format.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    format.cpp

Abstract:

    Routines to format volumes, using file-system information passed
    in.  Uses undocumented fmifs calls.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include <winioctl.h>
#include "fmifs.h"
#include "asr_fmt.h"
#include "asr_dlg.h"

BOOL g_bFormatInProgress = FALSE;
BOOL g_bFormatSuccessful = FALSE;
INT  g_iFormatPercentComplete = 0;

HINSTANCE g_hIfsDll = NULL;

INT FormatVolumeThread(PASRFMT_VOLUME_INFO pVolume);

PFMIFS_FORMATEX_ROUTINE g_FormatRoutineEx = NULL;


BOOL
FormatInitialise() {
    //
    // Loadlib if needed
    //
    if (!g_hIfsDll) {
        g_hIfsDll = LoadLibrary(L"fmifs.dll");
        if (!g_hIfsDll) {
            //
            // FMIFS not available
            //
            return FALSE;
        }

        g_FormatRoutineEx = (PFMIFS_FORMATEX_ROUTINE)GetProcAddress(g_hIfsDll, "FormatEx");
        if (!g_FormatRoutineEx) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
IsFsTypeOkay(
    IN PASRFMT_VOLUME_INFO pVolume,
    OUT PBOOL pIsLabelIntact
    )
{
    WCHAR currentFSName[ASRFMT_CCH_FS_NAME];
    WCHAR szVolumeGuid[ASRFMT_CCH_VOLUME_GUID];
    WCHAR currentLabel[ASRFMT_CCH_VOLUME_LABEL];

    DWORD cchGuid = 0;
    BOOL fsOkay = TRUE, 
        result = TRUE;
    
    ASSERT(pIsLabelIntact);

    ZeroMemory(currentFSName, sizeof(WCHAR) * ASRFMT_CCH_FS_NAME);
    *pIsLabelIntact = TRUE;

    if (wcslen(pVolume->szGuid) >= ASRFMT_CCH_VOLUME_GUID) {
        return TRUE;   // something's wrong with this GUID
    }

    if ((wcslen(pVolume->szFsName) <= 0)) {
        return TRUE;    // no check for RAW volumes
    }

    //
    // We don't want the "please insert floppy in drive A" messages ...
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // GetVolumeInformation needs the volume guid in the dos-name-space, while the
    // the sif file has the volume guid in the nt-name-space.  Convert
    // the name by changing the \??\ at the beginning to \\?\, and adding 
    // a back-slash at the end.
    //
    cchGuid = wcslen(pVolume->szGuid);
    wcsncpy(szVolumeGuid, pVolume->szGuid, cchGuid);
    szVolumeGuid[1] = L'\\';
    szVolumeGuid[cchGuid] = L'\\';    // Trailing back-slash
    szVolumeGuid[cchGuid+1] = L'\0';

    fsOkay = TRUE;
    //
    // Call GetVolumeInfo to see if the FS is the same
    //
    result = GetVolumeInformation(szVolumeGuid,
        currentLabel,   // lpVolumeNameBuffer
        ASRFMT_CCH_VOLUME_LABEL,      // nVolumeNameSize
        NULL,   // lpVolumeSerialNumber
        NULL,   // lpMaximumComponentLength
        NULL,   // lpFileSystemFlags
        currentFSName,
        ASRFMT_CCH_FS_NAME
        );

    if ((!result) || 
        wcscmp(currentFSName, pVolume->szFsName)
        ) {
        fsOkay = FALSE;
        *pIsLabelIntact = FALSE;
    }

    if (wcscmp(currentLabel, pVolume->szLabel)) {
        *pIsLabelIntact = FALSE;
    }


/*    if (fsOkay) {
        //
        //
        // Call FindFirst in root to see if drive is readable.  
        // guhans: If drive is empty but formatted, this will still 
        // say fsOkay = FALSE;
        //
        hFindData = FindFirstFile(szPath, &win32FindData);

        if (!hFindData || (INVALID_HANDLE_VALUE == hFindData)) {
            fsOkay = FALSE;
        }
    }
*/

    return fsOkay;

}


BOOL
IsVolumeIntact(
    IN PASRFMT_VOLUME_INFO pVolume
    ){


    //
    // Call autochk to see if the FS is intact
    //


    return TRUE;
}



///
// Asynchronous function to launch the format routine.  
//
BOOL
FormatVolume(
    IN PASRFMT_VOLUME_INFO pVolume
    )
{
    HANDLE hThread = NULL;

    //
    // Set the global flags
    //
    g_bFormatInProgress = TRUE;
    g_bFormatSuccessful = TRUE;
    g_iFormatPercentComplete = 0;

    //
    // Loadlib if needed
    //
    if (!g_hIfsDll && !FormatInitialise()) {
        g_bFormatSuccessful = FALSE;
        g_bFormatInProgress = FALSE;
        return FALSE;
    }

    hThread = CreateThread(
        NULL,
        0, 
        (LPTHREAD_START_ROUTINE) FormatVolumeThread, 
        pVolume,
        0,
        NULL
    );
    if (!hThread || (INVALID_HANDLE_VALUE == hThread)) {
        g_bFormatSuccessful = FALSE;
        g_bFormatInProgress = FALSE;
        return FALSE;
    }

    return TRUE;
}


BOOL
FormatCleanup() {

    if (g_hIfsDll) {
        FreeLibrary(g_hIfsDll);
        g_hIfsDll = NULL;
        g_FormatRoutineEx = NULL;
    }

    return TRUE;
}


FmIfsCallback(
    IN FMIFS_PACKET_TYPE PacketType,
    IN DWORD PacketLength,
    IN PVOID PacketData
    )
{

    switch (PacketType) {
    case FmIfsPercentCompleted:
        g_iFormatPercentComplete = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted ;
        break;

    case FmIfsFormattingDestination:
    case FmIfsInsertDisk:
    case FmIfsFormatReport:
    case FmIfsHiddenStatus:
    default:
         break;

    case FmIfsFinished:
         g_bFormatSuccessful = g_bFormatSuccessful &&
             ((PFMIFS_FINISHED_INFORMATION) PacketData)->Success;
         g_iFormatPercentComplete = 101;
         g_bFormatInProgress = FALSE;
         break;

    case FmIfsIncompatibleFileSystem:
    case FmIfsIncompatibleMedia:
    case FmIfsAccessDenied:
    case FmIfsMediaWriteProtected:
    case FmIfsCantLock:
    case FmIfsBadLabel:
    case FmIfsCantQuickFormat:
    case FmIfsIoError:
    case FmIfsVolumeTooSmall:
    case FmIfsVolumeTooBig:
    case FmIfsClusterSizeTooSmall:
    case FmIfsClusterSizeTooBig:
         g_bFormatSuccessful = FALSE;
        break;
    }
    return TRUE;
}



INT FormatVolumeThread(PASRFMT_VOLUME_INFO pVolume) 
{
    WCHAR  szPath[ASRFMT_CCH_DEVICE_PATH + 1];

    swprintf(szPath, TEXT("\\\\?%s"), pVolume->szGuid+3);

    (g_FormatRoutineEx)(szPath,
        FmMediaUnknown,
        pVolume->szFsName,
        pVolume->szLabel,
#if 0
        TRUE,       // Quick Format for testing
#else
        g_bQuickFormat,      
#endif
        pVolume->dwClusterSize,
        (FMIFS_CALLBACK) &FmIfsCallback
        );

     return TRUE;
}


VOID
MountFileSystem(
    IN PASRFMT_VOLUME_INFO pVolume
    )
/*++

  (based on code in base\fs\utils\hsm\wsb\wsbfmt.cpp)

Routine Description:


  Ensures a filesystem  is mounted at the given root:
  a) Opens the mount point and closes it.
  b) Does a FindFirstFile on the mount point
 
  The latter may sound redundant but is not because if we create the first
  FAT32 filesystem then just opening and closing is not enough
 

Arguments:


Return Value:
        
    none

--*/
{
    WCHAR  szPath[ASRFMT_CCH_DEVICE_PATH + 1];
    HANDLE handle = NULL;
    WIN32_FIND_DATA win32FindData;

    if (!pVolume) {
        ASSERT(0 && L"pVolume is NULL");
        return;
    }

    if (!memcmp(pVolume->szDosPath, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)) {
        swprintf(szPath, L"\\\\?\\%ws", pVolume->szDosPath + wcslen(ASRFMT_WSZ_DOS_DEVICES_PREFIX));
    }
    else {
        swprintf(szPath, L"\\\\%ws", pVolume->szDosPath + 2);
    }
    handle = CreateFile(
        szPath, 
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0, 
        OPEN_EXISTING, 
        0, 
        0
        );
    if ((handle) && (INVALID_HANDLE_VALUE != handle)) {
        CloseHandle(handle);
    }

    //
    // Try to find the first file, this will make sure that
    //  the file system is mounted
    //    
    if (!memcmp(pVolume->szDosPath, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)) {
        swprintf(szPath, L"\\\\?\\%ws\\*", pVolume->szDosPath + wcslen(ASRFMT_WSZ_DOS_DEVICES_PREFIX));
    }
    else {
        swprintf(szPath, L"\\\\%ws\\*", pVolume->szDosPath + 2);
    }

    handle = FindFirstFile(szPath, &win32FindData);
    if ((handle) && (INVALID_HANDLE_VALUE != handle)) {
        FindClose(handle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\asr_dlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_dlg.cpp

Abstract:

    Top level code to backup and restore information about the volumes on 
    a system.  This module handles the main application dialogue, including 
    parsing the command-line, and updating the progress bar and UI status
    text.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include "asr_fmt.h"
#include "asr_dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOLEAN g_bQuickFormat = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg dialog

CAsr_fmtDlg::CAsr_fmtDlg(CWnd* pParent /*=NULL*/)
     : CDialog(CAsr_fmtDlg::IDD, pParent)
{
     //{{AFX_DATA_INIT(CAsr_fmtDlg)
     //}}AFX_DATA_INIT
}

void CAsr_fmtDlg::DoDataExchange(CDataExchange* pDX)
{
     CDialog::DoDataExchange(pDX);
     //{{AFX_DATA_MAP(CAsr_fmtDlg)
     DDX_Control(pDX, IDC_PROGRESS, m_Progress);
     //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAsr_fmtDlg, CDialog)
     //{{AFX_MSG_MAP(CAsr_fmtDlg)
     //}}AFX_MSG_MAP

    // manually added message handlers (for user-defined messages) should be added OUTSIDE
    // the AFX_MSG_MAP part above

    ON_MESSAGE(WM_WORKER_THREAD_DONE, OnWorkerThreadDone)
    ON_MESSAGE(WM_UPDATE_STATUS_TEXT, OnUpdateStatusText)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg message handlers
//     ON_BN_CLICKED(IDOK, OnWorkerThreadDone)

BOOL CAsr_fmtDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // initialize the progress range and start posiiton
    m_Progress.SetRange(0, 100);
    m_Progress.SetPos(0);
    m_ProgressPosition = 0;

    // Launch the worker thread.
    CreateThread(NULL,     // no sid
        0,     // no initial stack size
        (LPTHREAD_START_ROUTINE) CAsr_fmtDlg::DoWork,
        this,  // parameter
        0,     // no flags
        NULL   // no thread ID
    );

    return TRUE;  // return TRUE unless you set the focus to a control
}

LRESULT 
CAsr_fmtDlg::OnWorkerThreadDone(
    WPARAM wparam, 
    LPARAM lparam
   )
{
    EndDialog(m_dwEndStatus);
    return 0;
}


LRESULT 
CAsr_fmtDlg::OnUpdateStatusText(
    WPARAM wparam, 
    LPARAM lparam 
   )
{
    SetDlgItemText(IDC_STATUS_TEXT, m_strStatusText);
    m_Progress.SetPos(m_ProgressPosition);

    return 0;
}


/**

     Name:         DoWork()

     Description:  This function runs as a thread launched form the Init
       of the dialog.  This function determines what needs to be done, then
       calls the appropraite function to do the work.

     Modified:     8/31/1998

     Returns:      TRUE

     Notes:        If an error occurs EndDialog will be called with the 
                exit status.

     Declaration:

**/
long 
CAsr_fmtDlg::DoWork(
    CAsr_fmtDlg *_this
    )
{
    ASRFMT_CMD_OPTION cmdOption = cmdUndefined;

    cmdOption = _this->ParseCommandLine();
    ((CAsr_fmtDlg *)_this)->m_AsrState = NULL;

    _this->m_dwEndStatus = ERROR_SUCCESS;

    switch (cmdOption) {

    case cmdBackup: {

        if (!(_this->BackupState())) {
            _this->m_dwEndStatus = GetLastError();
        }

        break;
    }

    case cmdRestore: {
        if (!(_this->RestoreState())) {
            _this->m_dwEndStatus = GetLastError();
        }
        break;
    }

    case cmdDisplayHelp: {
        _this->m_dwEndStatus = ERROR_INVALID_FUNCTION;      // display help ...
        break;
    }
 
    }

    if (ERROR_INVALID_FUNCTION != _this->m_dwEndStatus) {      // display help ...
        _this->PostMessage(WM_WORKER_THREAD_DONE, 0, 0);
    }

    return 0;           
}


/**

     Name:         BackupState()

     Description:  This function reads the current state file to get
       the current data for the sections to modify.  It then updates
       [VOLUMES], [REMOVABLEMEDIA] and [COMMANDS] sections.


     Notes:        If an error occurs an Error message popup is provided to
                the user.

     Declaration:

**/

BOOL
CAsr_fmtDlg::BackupState()
{
    BOOL result = FALSE;
    HANDLE hHeap = GetProcessHeap();
    int i = 0;

    CString strPleaseWait;
    strPleaseWait.LoadString(IDS_PLEASE_WAIT_BACKUP);
    SetDlgItemText(IDC_PROGRESS_TEXT, strPleaseWait);

    m_AsrState = (PASRFMT_STATE_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof (ASRFMT_STATE_INFO)
       );


    //
    // The only purpose of the for loops below are to slow down the 
    // UI and make the progress bar proceed smoothly, so that the user
    // can read the dialogue box on screen.
    //
    m_strStatusText.LoadString(IDS_QUERY_SYS_FOR_INFO);
    for (i = 3; i < 15; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    if (m_AsrState) {
        result = BuildStateInfo(m_AsrState);
    }
    if (!result) {
        goto EXIT;
    }

    //
    // The only purpose of the for loops below are to slow down the 
    // UI and make the progress bar proceed smoothly, so that the user
    // can read the dialogue box on screen.
    //
    m_strStatusText.LoadString(IDS_QUERY_SYS_FOR_INFO);
    for (i = 15; i < 45; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    //
    // Pretend we're doing something else (change UI text)
    //
    m_strStatusText.LoadString(IDS_BUILDING_VOL_LIST);
    for (i = 45; i < 80; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    m_strStatusText.LoadString(IDS_WRITING_TO_SIF);
    for (i = 80; i < 90; i++) {
        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);
    }


    result = WriteStateInfo(m_dwpAsrContext, m_AsrState);

    if (!result) {
        goto EXIT;
    }
    m_strStatusText.LoadString(IDS_WRITING_TO_SIF);

    for (i = 90; i < 101; i++) {
        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);
    }

EXIT:
    FreeStateInfo(&m_AsrState);
    return result;
}



/**

     Name:         RestoreState()

     Description:  This function restores the state found in the [VOLUMES] 
       section of the asr.sif file.   The state restored includs:
           the drive letter.
           If drive is inaccessible it is formated.
           the volume label.

     Notes:        If an error occurs an Error message popup is provided to
                the user.


**/
BOOL
CAsr_fmtDlg::RestoreState()
{

    BOOL bErrorsEncountered = FALSE,
        result = TRUE;

    CString strPleaseWait;
    strPleaseWait.LoadString(IDS_PLEASE_WAIT_RESTORE);

    
    SetDlgItemText(IDC_PROGRESS_TEXT, strPleaseWait);

    m_ProgressPosition = 0;
    m_strStatusText.LoadString(IDS_READING_SIF);
    PostMessage(WM_UPDATE_STATUS_TEXT);

    AsrfmtpInitialiseErrorFile();   // in case we need to log error messages

    //
    // 1.  Read the state file
    //
    result = ReadStateInfo( (LPCTSTR)m_strSifPath, &m_AsrState);
    if (!result || !m_AsrState) {
        DWORD status = GetLastError();

        CString strErrorTitle;
        CString strErrorMessage;
        CString strErrorFormat;

        strErrorTitle.LoadString(IDS_ERROR_TITLE);
        strErrorFormat.LoadString(IDS_ERROR_NO_DRSTATE);

        strErrorMessage.Format(strErrorFormat, (LPCTSTR)m_strSifPath, status);

        AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);
        AsrfmtpCloseErrorFile();
        
        return FALSE;
    }

    //
    // 2.  Loop through all the volumes listed in the state file.
    //
    PASRFMT_VOLUME_INFO pVolume = m_AsrState->pVolume;
    PASRFMT_REMOVABLE_MEDIA_INFO pMedia = m_AsrState->pRemovableMedia;
    UINT driveType = DRIVE_UNKNOWN;
    PWSTR lpDrive = NULL;  // Display string, of the form \DosDevices\C: or \??\Volume{Guid}
    DWORD cchVolumeGuid = 0;
    WCHAR szVolumeGuid[MAX_PATH + 1];
    int sizeIncrement = 0, i = 0;
    BOOL first = TRUE, isIntact = FALSE, isLabelIntact = TRUE;

    //
    // We need to first set all the guids a volume has, then try setting the drive
    // letters.  Also, we need to go through the guid loop twice, to handle this case:
    //
    // Consider a sif where we had the entries 
    // ... \vol1, \vol2
    // ... \vol1, \x:
    // ... \vol1, \vol3
    //
    // where vol1, vol2 and vol3 are volume guids (\??\Volume{Guid}), 
    // and x: is the drive letter (\DosDevices\X:)
    //
    // Now, our list will contain three nodes:
    // -->(vol1, vol3)-->(vol1, x:)-->(vol1, vol2)-->/
    //
    // The problem is, the partition could currently have the guid vol2.  (since
    // it is free to have any one of the three guids).
    // 
    // If we only went through the loop once, we'll try to map vol1 to vol3, or 
    // vice-versa if vol1 doesn't exist.  Since neither exist yet, we would've 
    // complained to the user.
    //
    // The advantage to doing it twice is this:  the first time, since neither vol1 
    // nor vol3 exist yet, we'll skip that node.  Then we'll skip the drive letter for
    // now (since we're only doing guids), and eventually we'll map vol2 to vol1.
    // 
    // The second time, we'll find vol1 exists (mapped to vol2), and we'll be 
    // able to map vol1 to vol3.  In a later loop, vol1 will also get the drive 
    // letter X, and all's well.
    //
    // By the way, we could optimise this by creating a better data structure,
    // but it's too late in the game now for that.  If the performance is
    // really bad, we could come back to this.
    //

    if (m_AsrState->countVolume > 1) {
        sizeIncrement = 50 / (m_AsrState->countVolume - 1);
    }
    else {
        sizeIncrement = 100;
    }

    m_ProgressPosition = 0;
    
    for (i = 0; i < 2; i++) {

        pVolume = m_AsrState->pVolume;

        while (pVolume) {

            m_ProgressPosition += sizeIncrement;
            m_strStatusText.Format(IDS_REST_SYM_LINKS, pVolume->szGuid);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            if ((!pVolume->IsDosPathAssigned) &&
                ASRFMT_LOOKS_LIKE_VOLUME_GUID(pVolume->szDosPath, (wcslen(pVolume->szDosPath) * sizeof(WCHAR)))
                ) {
                pVolume->IsDosPathAssigned = SetDosName(pVolume->szGuid, pVolume->szDosPath);

                if (!pVolume->IsDosPathAssigned) {
                    pVolume->IsDosPathAssigned = SetDosName(pVolume->szDosPath, pVolume->szGuid);
                }
            }

            pVolume = pVolume->pNext;
        }
    }

    pVolume = m_AsrState->pVolume;
    FormatInitialise();
    while (pVolume) {
        lpDrive = ((wcslen(pVolume->szDosPath) > 0) ? pVolume->szDosPath : pVolume->szGuid);
        //
        // Check if the drive is accessible.  If not, we log an error message 
        // and continue.  GetDriveType requires the name in the DOS name space, so we
        // convert our GUID (NT name space) to the required format first
        //
        cchVolumeGuid = wcslen(pVolume->szGuid);
        if (cchVolumeGuid >= MAX_PATH) {
            cchVolumeGuid = MAX_PATH - 1;
        }
        wcsncpy(szVolumeGuid, pVolume->szGuid, cchVolumeGuid);

        szVolumeGuid[1] = L'\\';
        szVolumeGuid[cchVolumeGuid] = L'\\';    // Trailing back-slash
        szVolumeGuid[cchVolumeGuid+1] = L'\0';

        driveType = GetDriveType(szVolumeGuid);

        if (DRIVE_NO_ROOT_DIR == driveType) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MISSING_VOL);

            strErrorMessage.Format(strErrorFormat, (PWSTR) pVolume->szGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

            bErrorsEncountered = TRUE;
        }

        if (DRIVE_FIXED != driveType) {
            //
            // Strange.  The volumes section should have only listed the drives that
            // were fixed (At backup time).  This could probably mean that a volume that
            // used to be on a fixed drive is now on a removable drive?!
            //
            pVolume = pVolume->pNext;
            continue;
        }

        //
        // Set the drive letter of the volume
        //
        result = TRUE;
        if (!pVolume->IsDosPathAssigned){
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_REST_DRIVE_LETTER, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            result = SetDosName(pVolume->szGuid, pVolume->szDosPath);
        }

        if (!result) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MOUNTING);

            strErrorMessage.Format(strErrorFormat, (PWSTR) pVolume->szDosPath, (PWSTR) pVolume->szGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);
            
            bErrorsEncountered = TRUE;

            pVolume = pVolume->pNext;
            continue;
        }

        //
        // Check if the volume needs to be formatted
        //
        m_ProgressPosition = 0;
        m_strStatusText.Format(IDS_CHECKING_VOLUME, lpDrive);
        PostMessage(WM_UPDATE_STATUS_TEXT);

        isIntact = IsFsTypeOkay(pVolume, &isLabelIntact);
        if (isIntact) {
            isIntact = IsVolumeIntact(pVolume);
        }

        //
        // Format the volume if needed
        //
        if (!isIntact && FormatVolume(pVolume)) {
            isLabelIntact = FALSE;
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_FORMATTING_VOLUME, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);
            //
            // FormatVolume is asynchronous.
            //
            first = TRUE;
            while (g_bFormatInProgress) {

                if (g_iFormatPercentComplete >= 100) {
                    if (first) {
                        m_ProgressPosition = 100;
                        m_strStatusText.Format(IDS_CREATING_FS_STRUCT, lpDrive);
                        PostMessage(WM_UPDATE_STATUS_TEXT);
                        first = FALSE;
                    }
                }
                else {
                    m_Progress.SetPos(g_iFormatPercentComplete);
                }

                Sleep(100);
            }

            if (!g_bFormatSuccessful) {
                CString strErrorTitle;
                CString strErrorMessage;
                CString strErrorFormat;

                strErrorTitle.LoadString(IDS_ERROR_TITLE);
                strErrorFormat.LoadString(IDS_ERROR_FORMATTING);

                strErrorMessage.Format(strErrorFormat, (PWSTR) lpDrive);
                AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

                bErrorsEncountered = TRUE;
                pVolume = pVolume->pNext;
                continue;
            }

            // 
            // Force the file-system to be mounted
            // 
            MountFileSystem(pVolume);

        }

        //
        // Set the volume label if it isn't intact
        //
        if (!isLabelIntact) {
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_REST_VOL_LABEL, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            if ((wcslen(pVolume->szFsName) > 0) &&
               !SetVolumeLabel(szVolumeGuid, pVolume->szLabel)) {

                bErrorsEncountered = TRUE;
            
                pVolume = pVolume->pNext;
                continue;
            }
        }

        pVolume = pVolume->pNext;
    }
    FormatCleanup();


    while (pMedia) {
        lpDrive = ((wcslen(pMedia->szDosPath) > 0) ? pMedia->szDosPath : pMedia->szVolumeGuid);

        // 
        // set the drive letter
        // 
        m_ProgressPosition = 0;
        m_strStatusText.Format(IDS_REST_DRIVE_LETTER, lpDrive);
        PostMessage(WM_UPDATE_STATUS_TEXT);

        result = SetRemovableMediaGuid(pMedia->szDevicePath, pMedia->szVolumeGuid);
        if (result) {
            result = SetDosName(pMedia->szVolumeGuid, pMedia->szDosPath);
        }

        if (!result) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MOUNTING);

            strErrorMessage.Format(IDS_ERROR_MOUNTING, (PWSTR) pMedia->szDosPath, (PWSTR) pMedia->szVolumeGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

            // ignore failures setting drive letter on CD.
            // bErrorsEncountered = TRUE;
        }

        pMedia = pMedia->pNext;
    }

    AsrfmtpCloseErrorFile();
    return (bErrorsEncountered ? FALSE : TRUE);
}


inline 
BOOL
IsGuiModeAsr()
{
    WCHAR szAsrFlag[20];

    //
    // If (and only if) this is GUI-mode ASR, the ASR_C_CONTEXT 
    // environment variable is set to "AsrInProgress"
    //
    return (GetEnvironmentVariable(L"ASR_C_CONTEXT", szAsrFlag, 20) &&
        !wcscmp(szAsrFlag, L"AsrInProgress"));
}

/**

     Name:         ParseCommandLine()

     Description:  This function reads the comand line and looks for the
                   "backup" or "restore" options.  

     Modified:     8/31/1998

     Returns:      cmdBackup, cmdRestore, or cmdDisplayHelp.

     Notes:        If neither backup or restore are found, then the usage
                   is displayed in the error box.

     Declaration:

**/
ASRFMT_CMD_OPTION
CAsr_fmtDlg::ParseCommandLine() 
{
     CString cmd;
     m_dwpAsrContext = 0;

     cmd = GetCommandLine();
     cmd.MakeLower();
     if (cmd.Find(TEXT("/backup")) != -1) {

         int pos = cmd.Find(TEXT("/context="));
         if (pos > -1) {
#ifdef _IA64_
             _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/context=%I64u"), &m_dwpAsrContext);
#else
             _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/context=%lu"), &m_dwpAsrContext);
#endif
             return cmdBackup;
         }


    } else if (cmd.Find(TEXT("/restore")) != -1) {

        if (cmd.Find(TEXT("/full")) != -1) {
            g_bQuickFormat = FALSE;
        }
        else if (cmd.Find(TEXT("/quick")) != -1) {
            g_bQuickFormat = TRUE;
        }
        else if (IsGuiModeAsr()) {
            g_bQuickFormat = FALSE;
        }
        else {
            g_bQuickFormat = TRUE;
        }


        int pos = cmd.Find(TEXT("/sifpath="));
        if (pos > -1) {
            _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/sifpath=%ws"), m_strSifPath.GetBuffer(1024));
            m_strSifPath.ReleaseBuffer();
            return cmdRestore;
        }
    }

    CString strErrorTitle;
    CString strErrorMessage;
    INT space_offset;

    strErrorTitle.LoadString(IDS_ERROR_TITLE);
    strErrorMessage.LoadString(IDS_ERROR_USAGE);

    space_offset = cmd.Find(' ');
    if (space_offset >0) {
       cmd = cmd.Left(cmd.Find(' '));
    }

    SetDlgItemText(IDC_PROGRESS_TEXT, strErrorMessage);

    CWnd *pText = GetDlgItem(IDC_STATUS_TEXT);
    pText->ShowWindow(SW_HIDE);

    CButton *pButton = (CButton*)GetDlgItem(IDOK);
    pButton->ShowWindow(SW_SHOW);
    pButton->SetState(TRUE);
    pButton->SetCheck(TRUE);

    CWnd *pBar = GetDlgItem(IDC_PROGRESS);
    pBar->ShowWindow(SW_HIDE);

    return cmdDisplayHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\inc\asr_dlg.h ===
// asr_fmtDlg.h : header file
//

#ifndef _INC_ASR_FMT__ASR_DLG_H_
#define _INC_ASR_FMT__ASR_DLG_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dr_state.h"

typedef enum {
    cmdUndefined = 0,
    cmdDisplayHelp,
    cmdBackup,
    cmdRestore
} ASRFMT_CMD_OPTION;


extern BOOLEAN g_bQuickFormat;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg dialog

class CAsr_fmtDlg:public CDialog
{

    enum {
        WM_WORKER_THREAD_DONE = WM_USER + 1,
        WM_UPDATE_STATUS_TEXT,
    };

public:
	CAsr_fmtDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAsr_fmtDlg)
	enum { IDD = IDD_ASR_FMT_DIALOG };
	CProgressCtrl	m_Progress;
    PASRFMT_STATE_INFO m_AsrState;

	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsr_fmtDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAsr_fmtDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	static long       DoWork(CAsr_fmtDlg *_this);
	BOOL              BackupState();
	BOOL              RestoreState();
    ASRFMT_CMD_OPTION ParseCommandLine();


    DWORD_PTR   m_dwpAsrContext;
    DWORD       m_dwEndStatus;

    CString     m_strStatusText;
    CString     m_strSifPath;
    
    int         m_ProgressPosition;

	DECLARE_MESSAGE_MAP()

    // manually added message-handler 
    afx_msg LRESULT OnWorkerThreadDone(WPARAM wparam, LPARAM lparam);
    afx_msg LRESULT OnUpdateStatusText(WPARAM wparam, LPARAM lparam);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



/////////////////////////////////////////////////////////////////////////////
// CProgress window

class CProgress : public CProgressCtrl
{
// Construction
public:
	CProgress();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgress)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProgress();

	// Generated message map functions
protected:
	//{{AFX_MSG(CProgress)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _INC_ASR_FMT__ASR_DLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\inc\asr_fmt.h ===
// asr_fmt.h : main header file for the ASR_FMT application
//

#ifndef _INC_ASR_FMT__ASR_FMT_H_
#define _INC_ASR_FMT__ASR_FMT_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp:
// See asr_fmt.cpp for the implementation of this class
//

class CAsr_fmtApp : public CWinApp
{
public:
	CAsr_fmtApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsr_fmtApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAsr_fmtApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _INC_ASR_FMT__ASR_FMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Used by Z:\nt\base\fs\utils\asr_fmt\asr_fmt.rc

//
// Strings 
//
#define IDS_PLEASE_WAIT_BACKUP          1001
#define IDS_QUERY_SYS_FOR_INFO          1002
#define IDS_BUILDING_VOL_LIST           1003
#define IDS_WRITING_TO_SIF              1004

#define IDS_PLEASE_WAIT_RESTORE         1011
#define IDS_READING_SIF                 1012

#define IDS_REST_DRIVE_LETTER           1021
#define IDS_REST_VOL_LABEL              1022
#define IDS_REST_SYM_LINKS              1023

#define IDS_FORMATTING_VOLUME           1031
#define IDS_CHECKING_VOLUME             1032
#define IDS_CREATING_FS_STRUCT          1033

#define IDS_ERROR_TITLE                 1101
#define IDS_ERROR_USAGE                 1102
#define IDS_ERROR_FORMATTING            1103
#define IDS_ERROR_MOUNTING              1104
#define IDS_ERROR_MISSING_VOL           1105
#define IDS_ERROR_NO_DRSTATE            1106

#define IDS_LOG_ERROR_FORMAT            1110
#define IDS_LOG_WARNING_FORMAT          1111

//
// Dialog
//
#define IDD_ASR_FMT_DIALOG              2001
#define IDR_MAINFRAME                   2011

//
// Controls
//
#define IDC_PROGRESS                    3001
#define IDC_PROGRESS_TEXT               3002
#define IDC_STATUS_TEXT                 3003

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2012
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         3004
#define _APS_NEXT_SYMED_VALUE           2002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\dr_state.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dr_state.cpp

Abstract:

    This module contains routines to query the symbolic names and file system
    information of all the volumes on a system, and save them out to an 
    ASR state file using the ASR api.

    Also contains routines to read in the volume information stored in an
    ASR state file, and recreate them using appropriate mountmgr calls.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include <setupapi.h>
#include <winioctl.h>
#include <mountmgr.h>
#include <winasr.h>
#include <ntddvol.h>
#include "dr_state.h"
#include "resource.h"

#include <clusstor.h>   // Cluster API's
#include <resapi.h>     // Cluster ResUtilEnumResources

#define ASRFMT_VOLUMES_SECTION                  L"[ASRFMT.FIXEDVOLUMES]"
#define ASRFMT_VOLUMES_SECTION_NAME             L"ASRFMT.FIXEDVOLUMES"

#define ASRFMT_REMOVABLE_MEDIA_SECTION          L"[ASRFMT.REMOVABLEMEDIA]"
#define ASRFMT_REMOVABLE_MEDIA_SECTION_NAME     L"ASRFMT.REMOVABLEMEDIA"

#define ASRFMT_COMMANDS_ENTRY                   L"1,3000,0,\"%SystemRoot%\\system32\\asr_fmt.exe\",\"/restore\""

const WCHAR ASRFMT_DEVICEPATH_FORMAT[]     = L"\\Device\\Harddisk%d\\Partition%d";
#define ASRFMT_DEVICEPATH_FORMAT_LENGTH    36

const WCHAR ASRFMT_CLUSTER_PHYSICAL_DISK[] = L"Physical Disk";

const WCHAR ASRFMT_ASR_ERROR_FILE_PATH[] = L"%SystemRoot%\\repair\\asr.err";


//
// The following must be Ansi strings
//
const char ASRFMT_CLUSTER_DLL_MODULE_NAME[] = "%SystemRoot%\\system32\\syssetup.dll";
const char ASRFMT_CLUSTER_DLL_PROC_NAME[]   = "AsrpGetLocalVolumeInfo";

typedef enum {
    mmfUndefined = 0,
    mmfGetDeviceName,
    mmfDeleteDosName,
    mmfDeleteVolumeGuid,
    mmfCreateSymbolicLinkName
} ASRFMT_MM_FUNCTION;

HANDLE Gbl_hErrorFile = NULL;

//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define ErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {        \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Line %lu, ErrorCode: %lu, GetLastError:%lu\n",        \
                __LINE__, ErrorCode, GetLastError());                   \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}

//
//
// Forward declarations
//
BOOL
DoMountMgrWork(
    IN HANDLE hMountMgr,               
    IN ASRFMT_MM_FUNCTION mmfFunction,
    IN PWSTR lpSymbolicName,
    IN PWSTR lpDeviceName
    );

PMOUNTMGR_MOUNT_POINTS  // Must be freed by caller
GetMountPoints();


//
//
//
VOID
FreeVolumeInfo(
    IN OUT PASRFMT_VOLUME_INFO *ppVolume
    )
{
    PASRFMT_VOLUME_INFO pTemp = NULL;
    HANDLE hHeap = GetProcessHeap();

    if (ppVolume && *ppVolume) {

        pTemp = *ppVolume;
        while (*ppVolume) {
            pTemp = ((*ppVolume)->pNext);
            HeapFree(hHeap, 0L, *ppVolume);
            *ppVolume = pTemp;
        }
    }
}


VOID
FreeRemovableMediaInfo(
    IN OUT PASRFMT_REMOVABLE_MEDIA_INFO *ppMedia
    )
{
    PASRFMT_REMOVABLE_MEDIA_INFO pTemp = NULL;
    HANDLE hHeap = GetProcessHeap();

    if (ppMedia && *ppMedia) {

        pTemp = *ppMedia;
        while (*ppMedia) {
            pTemp = (*ppMedia)->pNext;
            HeapFree(hHeap, 0L, *ppMedia);
            *ppMedia = pTemp;
        }
    }
}


VOID
FreeStateInfo(
    IN OUT PASRFMT_STATE_INFO *ppState
    )
{
    if (ppState && *ppState) {

        FreeVolumeInfo(&((*ppState)->pVolume));
        FreeRemovableMediaInfo(&((*ppState)->pRemovableMedia));

        HeapFree(GetProcessHeap(), 0L, (*ppState));
        *ppState = NULL;
    }
}


/**********************

   NAME : ReadStateInfo

**********************/
BOOL
ReadStateInfo( 
    IN PCWSTR lpwszFilePath,
    OUT PASRFMT_STATE_INFO *ppState
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HINF hSif = NULL;
    BOOL bResult = TRUE;
    HANDLE hHeap = NULL;

    PASRFMT_VOLUME_INFO pNewVolume = NULL;
    PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = NULL;

    INFCONTEXT infVolumeContext,
        infMediaContext;

    hHeap = GetProcessHeap();

    //
    // Release the ppState if necessary, and allocate memory.
    //
    if (*ppState) {
        FreeStateInfo(ppState);
    }

    *ppState = (PASRFMT_STATE_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(ASRFMT_STATE_INFO)
        );
    ErrExitCode(!(*ppState), dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Open asr.sif
    //
    hSif = SetupOpenInfFile(
        lpwszFilePath, 
        NULL, 
        INF_STYLE_WIN4, 
        NULL 
        );
    ErrExitCode((!hSif || INVALID_HANDLE_VALUE == hSif), dwStatus, GetLastError());

    //
    // Read in the [VOLUMES] section
    //
    bResult = SetupFindFirstLineW(hSif, ASRFMT_VOLUMES_SECTION_NAME, NULL, &infVolumeContext);
    while (bResult) {
        // 
        // Create a new volumeInfo struct
        //
        pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof(ASRFMT_VOLUME_INFO)
            );
        ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Read in the information.  The VOLUMES section contains:
        // [VOLUMES]
        // 0.volume-key = 1.system-key, 2."volume-guid", 3."dos-drive-letter", 
        //             4."FS-Type", 5."volume-label", 6."fs-cluster-size"
        //
        SetupGetIntField(&infVolumeContext, 0, (PINT) (&pNewVolume->dwIndex));

        SetupGetStringField(&infVolumeContext, 2, pNewVolume->szGuid, sizeof(pNewVolume->szGuid) / sizeof(WCHAR), NULL);
        SetupGetStringField(&infVolumeContext, 3, pNewVolume->szDosPath, sizeof(pNewVolume->szDosPath) / sizeof(WCHAR), NULL);

        SetupGetStringField(&infVolumeContext, 4, pNewVolume->szFsName, sizeof(pNewVolume->szFsName) / sizeof(WCHAR), NULL);
        SetupGetStringField(&infVolumeContext, 5, pNewVolume->szLabel, sizeof(pNewVolume->szLabel) / sizeof(WCHAR), NULL);

        SetupGetIntField(&infVolumeContext, 6, (PINT) (&pNewVolume->dwClusterSize));

        //
        // Add this to our list
        //
        pNewVolume->pNext = (*ppState)->pVolume;
        (*ppState)->pVolume = pNewVolume;
        (*ppState)->countVolume += 1;

        bResult = SetupFindNextLine(&infVolumeContext, &infVolumeContext);
    }


    //
    // Read in the [REMOVABLEMEDIA] section
    //
    bResult = SetupFindFirstLineW(hSif, ASRFMT_REMOVABLE_MEDIA_SECTION_NAME, NULL, &infMediaContext);
    while (bResult) {
        // 
        // Create a new REMOVALBLE_MEDIA struct
        //
        pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
            );
        ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Read in the information.  The REMOVABLEMEDIA section contains:
        //
        // [REMOVABLEMEDIA]
        // 0.rm-key = 1.system-key, 2."device-path", 3."volume-guid", 
        //             4."dos-drive-letter"
        //
        SetupGetIntField(&infMediaContext, 0, (PINT)(&pNewMedia->dwIndex));

        SetupGetStringField(&infMediaContext, 2, pNewMedia->szDevicePath, sizeof(pNewMedia->szDevicePath) / sizeof(WCHAR), NULL);
        SetupGetStringField(&infMediaContext, 3, pNewMedia->szVolumeGuid, sizeof(pNewMedia->szVolumeGuid) / sizeof(WCHAR), NULL);
        SetupGetStringField(&infMediaContext, 4, pNewMedia->szDosPath, sizeof(pNewMedia->szDosPath) / sizeof(WCHAR), NULL);

        //
        // Add this to our list
        //
        pNewMedia->pNext = (*ppState)->pRemovableMedia;
        (*ppState)->pRemovableMedia = pNewMedia;
        (*ppState)->countMedia += 1;

        bResult = SetupFindNextLine(&infMediaContext, &infMediaContext);
    }

EXIT:
    //
    //  Set the state pointer to null on failure
    //
    if (dwStatus != ERROR_SUCCESS) {
        if (ppState && *ppState) {
          FreeStateInfo(ppState);
        }
    }

    if (hSif && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


//
// WriteStateInfo
//
// This writes out the volumes and removablemedia sections, using 
// AsrAddSifEntry.  If the write is successful, or there's nothing 
// to write, it returns TRUE.
//
BOOL
WriteStateInfo( 
    IN DWORD_PTR AsrContext,        // AsrContext to pass in to AsrAddSifEntry
    IN PASRFMT_STATE_INFO pState    // data to write.
    )
{
    WCHAR szSifEntry[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD dwIndex = 1;
    BOOL bResult = TRUE;

    PASRFMT_VOLUME_INFO pVolume = NULL;
    PASRFMT_REMOVABLE_MEDIA_INFO pMedia = NULL;

    if (!pState) {
        //
        // Nothing to write
        //
        return TRUE;
    }

    bResult = AsrAddSifEntry(
         AsrContext,
         L"[COMMANDS]", // ASR_SIF_COMMANDS_SECTION_NAME,
         ASRFMT_COMMANDS_ENTRY
         );

    if (!bResult) {
        GetLastError(); // for debug
        return FALSE;
    }

    //
    // The [ASRFMT.FIXEDVOLUMES] section
    //
    pVolume = pState->pVolume;
    dwIndex = 1;
    while (pVolume) {

        //
        // Write out the information.  The VOLUMES section contains:
        // [ASRFMT.FIXEDVOLUMES]
        // 0.volume-key = 1.system-key, 2."volume-guid", 3."dos-drive-letter", 
        //             4.FS-Type, 5."volume-label", 6."fs-cluster-size"
        //

        // form the string
        swprintf(
            szSifEntry, 
            (PCWSTR) L"%d=1,\"%ws\",\"%ws\",%ws,\"%ws\",0x%x",
            dwIndex,
            pVolume->szGuid,
            (pVolume->szDosPath ? pVolume->szDosPath : L""),
            pVolume->szFsName,
            pVolume->szLabel,
            pVolume->dwClusterSize
            );

        bResult = AsrAddSifEntry(
             AsrContext,
             ASRFMT_VOLUMES_SECTION,
             szSifEntry
             );

        if (!bResult) {
            GetLastError(); // for debug
            return FALSE;
        }

        ++dwIndex;
        pVolume = pVolume->pNext;
    }

    //
    // The [REMOVABLEMEDIA] section
    //
    pMedia = pState->pRemovableMedia;
    dwIndex = 1;
    while (pMedia) {

        //
        // Write out the information.  The REMOVABLEMEDIA section contains:
        //
        // [ASRFMT.REMOVABLEMEDIA]
        // 0.rm-key = 1.system-key, 2."device-path", 3."volume-guid", 
        //             4."dos-drive-letter"
        //

        // form the string
        swprintf(
            szSifEntry, 
            (PCWSTR) L"%d=1,\"%ws\",\"%ws\",\"%ws\"",
            dwIndex,
            pMedia->szDevicePath,
            pMedia->szVolumeGuid,
            (pMedia->szDosPath ? pMedia->szDosPath : L"")
            );

        bResult = AsrAddSifEntry(
             AsrContext,
             ASRFMT_REMOVABLE_MEDIA_SECTION,
             szSifEntry
             );

        if (!bResult) {
            GetLastError(); // for debug
            return FALSE;
        }

        ++dwIndex;
        pMedia = pMedia->pNext;
    }

    return TRUE;
}


BOOL
GetVolumeDetails(
    IN  PWSTR lpVolumeGuid,
    OUT PWSTR lpFsName,
    IN  DWORD cchFsName,
    OUT PWSTR lpVolumeLabel,
    IN  DWORD cchVolumeLabel,
    OUT LPDWORD lpClusterSize
    )
{
    DWORD dwFSFlags = 0,
        dwSectorsPerCluster = 0,
        dwBytesPerSector = 0,
        dwNumFreeClusters = 0,
        dwTotalNumClusters = 0;

    BOOL result1 = TRUE,
        result2 = TRUE;

    *lpFsName = 0;
    *lpVolumeLabel = 0;
    *lpClusterSize = 0;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    result1 = GetVolumeInformation(lpVolumeGuid,
        lpVolumeLabel,
        cchVolumeLabel,
        NULL,   // no need for serial number
        NULL,   // max file name length
        &dwFSFlags, // !! we might need to store some of this ...
        lpFsName,
        cchFsName
        );

    result2 = GetDiskFreeSpace(lpVolumeGuid,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwNumFreeClusters,
        &dwTotalNumClusters
        );

    *lpClusterSize = dwSectorsPerCluster * dwBytesPerSector;

    return (result1 && result2);
}


BOOL
AddSortedVolumeInfo(
    IN OUT PASRFMT_VOLUME_INFO *ppHead,
    IN PASRFMT_VOLUME_INFO pNew
    )
{

    if (!pNew) {
        ASSERT(0 && L"Trying to add a null volume");
        return TRUE;
    }

    pNew->pNext = *ppHead;
    (*ppHead) = pNew;

    return TRUE;
}



BOOL
AddSortedRemovableMediaInfo(
    IN OUT PASRFMT_REMOVABLE_MEDIA_INFO *ppHead,
    IN PASRFMT_REMOVABLE_MEDIA_INFO pNew
    )
{

    if (!pNew) {
        ASSERT(0 && L"Trying to add a null Removable Media");
        return TRUE;
    }

    pNew->pNext = *ppHead;
    (*ppHead) = pNew;

    return TRUE;
}

typedef struct _ASRFMT_MP_LINK {

    PWSTR   pLink;
    USHORT  cchLink;

    struct _ASRFMT_MP_LINK *pNext;

} ASRFMT_MP_LINK, *PASRFMT_MP_LINK;


typedef struct _ASRFMT_MOUNT_POINTS_INFO {

    struct _ASRFMT_MOUNT_POINTS_INFO *pNext;

    //
    // Device Path, of the form \Device\HarddiskVolume1
    //
    PWSTR   pDeviceName;

    //
    // VolumeGuid for this volume  (\??\Volume{GUID})
    //
    PWSTR   pVolumeGuid;

    //
    // Additional symbolic links to this volume: including
    // DOS Drive letter (\DosDevices\C:) and additional Volume 
    // Guids (\??\Volume{GUID})
    //
    PASRFMT_MP_LINK pSymbolicLinks;

    PVOID   lpBufferToFree;

    DWORD   dwClusterSize;

    USHORT  cchDeviceName;
    USHORT  cchVolumeGuid;

    BOOL    IsClusterShared;
    
    WCHAR   szFsName[MAX_PATH + 1];
    WCHAR   szLabel[MAX_PATH + 1];

} ASRFMT_MOUNT_POINTS_INFO, *PASRFMT_MOUNT_POINTS_INFO;


VOID
FreeLink(
    IN PASRFMT_MP_LINK *ppLink
    )
{
    PASRFMT_MP_LINK pTemp = NULL,
        pCurrent = (*ppLink);
    HANDLE hHeap = GetProcessHeap();

    while (pCurrent) {
        pTemp = pCurrent->pNext;
        HeapFree(hHeap, 0L, pCurrent);
        pCurrent = pTemp;
    }

    *ppLink = NULL;
}

VOID
FreeMpInfo(
    IN PASRFMT_MOUNT_POINTS_INFO *ppMpInfo
    ) 
{
    PASRFMT_MOUNT_POINTS_INFO pTemp = NULL,
        pCurrent = (*ppMpInfo);
    HANDLE hHeap = GetProcessHeap();

    while (pCurrent) {
        if (pCurrent->pSymbolicLinks) {
            FreeLink(&(pCurrent->pSymbolicLinks));
        }

        if (pCurrent->lpBufferToFree) {
            HeapFree(hHeap, 0L, (pCurrent->lpBufferToFree));
            pCurrent->lpBufferToFree = NULL;
        }

        pTemp = pCurrent->pNext;
        HeapFree(hHeap, 0L, pCurrent);
        pCurrent = pTemp;
    }

    *ppMpInfo = NULL;
}



BOOL
AddSymbolicLink(
    IN PASRFMT_MOUNT_POINTS_INFO pMpInfoList, 
    IN PWSTR lpDeviceName, 
    IN USHORT cchDeviceName, 
    IN PWSTR lpSymbolicLink, 
    IN USHORT cchSymbolicLink,
    IN PVOID lpBufferToFree
    ) 
{
    BOOL foundAMatch = FALSE;
    HANDLE hHeap = GetProcessHeap();
    PASRFMT_MOUNT_POINTS_INFO pMp = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if (!pMpInfoList) {
        return FALSE;
    }

    pMp = pMpInfoList;
    while (pMp && !foundAMatch) {

        if ((pMp->pDeviceName) &&                       // Node has a device name
            (cchDeviceName == pMp->cchDeviceName) &&    // lengths are equal
            !wcsncmp(pMp->pDeviceName, lpDeviceName, cchDeviceName)) {      // strings match
            //
            // We already have a node for this device name.
            //
            if (!wcsncmp(ASRFMT_WSZ_VOLUME_GUID_PREFIX, lpSymbolicLink, ASRFMT_CB_VOLUME_GUID_PREFIX/sizeof(WCHAR))
                && !(pMp->pVolumeGuid)
                ) {
                //
                // This symbolic link looks like a volume GUID, and this node 
                // doesn't already have a pVolumeGuid set.
                //
                pMp->pVolumeGuid = lpSymbolicLink;
                pMp->cchVolumeGuid = cchSymbolicLink;
            }
            else {
                //
                // Either the node already has a pVolumeGuid set, or the
                // symbolic link doesn't look like a volume Guid.  So it
                // must be a new symbolic link.
                //
                PASRFMT_MP_LINK pNewLink = (PASRFMT_MP_LINK) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_MP_LINK)
                    );
                ErrExitCode(!pNewLink, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                pNewLink->pNext = pMp->pSymbolicLinks;
                pMp->pSymbolicLinks = pNewLink;

                pNewLink->pLink = lpSymbolicLink;
                pNewLink->cchLink = cchSymbolicLink;
            }
            foundAMatch = TRUE;
        }

        pMp = pMp->pNext;
    }

    if (!foundAMatch) {

        if (pMpInfoList->pDeviceName) {
            //
            // pMpInfoList is already taken
            //
            pMp = (PASRFMT_MOUNT_POINTS_INFO) HeapAlloc(
                hHeap,
                HEAP_ZERO_MEMORY,
                sizeof(ASRFMT_MOUNT_POINTS_INFO)
                );
            ErrExitCode(!pMp, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

            pMp->pNext = pMpInfoList->pNext;
            pMpInfoList->pNext = pMp;
        }
        else {
            pMp = pMpInfoList;
        }

        pMp->pDeviceName = lpDeviceName;
        pMp->cchDeviceName = cchDeviceName;
        pMp->lpBufferToFree = lpBufferToFree;

        //
        // Add the symbolic link to this new device
        //
        AddSymbolicLink(pMp, lpDeviceName, cchDeviceName, lpSymbolicLink, cchSymbolicLink, lpBufferToFree);
    }

EXIT:

    
    return (BOOL)(ERROR_SUCCESS == dwStatus);
}



//
// The following two definitions are also in syssetup:asrclus.cpp.  This MUST be
// kept in sync.
//
typedef struct _ASRFMT_CLUSTER_VOLUME_INFO {

    UINT driveType;

    DWORD PartitionNumber;

    ULONG FsNameOffset;
    USHORT FsNameLength;
    
    ULONG LabelOffset;
    USHORT LabelLength;

    ULONG SymbolicNamesOffset;
    USHORT SymbolicNamesLength;
    
    DWORD dwClusterSize;

} ASRFMT_CLUSTER_VOLUME_INFO, *PASRFMT_CLUSTER_VOLUME_INFO;


typedef struct _ASRFMT_CLUSTER_VOLUMES_TABLE {

    DWORD DiskSignature;

    DWORD NumberOfEntries;

    ASRFMT_CLUSTER_VOLUME_INFO VolumeInfoEntry[1];

} ASRFMT_CLUSTER_VOLUMES_TABLE, *PASRFMT_CLUSTER_VOLUMES_TABLE;



BOOL
GetVolumeDevicePath(
    IN PCWSTR lpPartitionDevicePath,
    IN CONST  cbPartitionDevicePath,
    OUT PWSTR *lpVolumeDevicePath
    )
{

    PMOUNTMGR_MOUNT_POINT   mountPointIn    = NULL;
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    MOUNTMGR_MOUNT_POINTS   mountPointsTemp;
    DWORD   mountPointsSize                 = 0;

    HANDLE  mpHandle                        = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;

    memset(&mountPointsTemp, 0L, sizeof(MOUNTMGR_MOUNT_POINTS));

    //
    // set OUT variables to known values.
    //
    *lpVolumeDevicePath = NULL;

    heapHandle = GetProcessHeap();
    ASSERT(heapHandle);

    //
    // Open the mount manager, and get the devicepath for this partition
    //

    // allocate memory for the mount point input structure
    mountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_MOUNT_POINT) + cbPartitionDevicePath
        );
    ErrExitCode(!mountPointIn, status, ERROR_NOT_ENOUGH_MEMORY);

    // get a handle to the mount manager
    mpHandle = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), status, GetLastError());

     // put the DeviceName right after struct mountPointIn
    wcsncpy((PWSTR) (mountPointIn + 1), lpPartitionDevicePath, (cbPartitionDevicePath / sizeof(WCHAR)) - 1);
    mountPointIn->DeviceNameOffset = sizeof(*mountPointIn);
    mountPointIn->DeviceNameLength = (USHORT) (cbPartitionDevicePath - sizeof(WCHAR));

    // this call should fail with ERROR_MORE_DATA
    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(*mountPointIn) + mountPointIn->DeviceNameLength,
        &mountPointsTemp,
        sizeof(mountPointsTemp),
        &mountPointsSize,
        NULL
        );

    if (!result) {
        status = GetLastError();

        // if buffer is of insufficient size, resize the buffer.
        if (ERROR_MORE_DATA             == status ||
            ERROR_INSUFFICIENT_BUFFER   == status ||
            ERROR_BAD_LENGTH            == status
            ) {

            status = ERROR_SUCCESS;

            mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                mountPointsTemp.Size
                );
            ErrExitCode(!mountPointsOut, status, ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // If some other error occurred, EXIT.
            // This is not a fatal error in the case of removable storage media
            //
            ErrExitCode(status, status, ERROR_SUCCESS);
        }
    }
    else {
        //
        // the call succeeded when we expected it to fail--something's wrong.
        // This is not a fatal error in the case of removable storage media.
        //
        ErrExitCode(result, status, ERROR_SUCCESS);
    }

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(*mountPointIn) + mountPointIn->DeviceNameLength,
        mountPointsOut,
        mountPointsTemp.Size,
        &mountPointsSize,
        NULL
        );
    ErrExitCode((!mountPointsSize || !result), status, GetLastError());

    (*lpVolumeDevicePath) = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        mountPointsOut->MountPoints[0].DeviceNameLength + sizeof(WCHAR)
        );
    ErrExitCode(!(*lpVolumeDevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Get the Device Path returned
    //
    CopyMemory((*lpVolumeDevicePath), 
        (PWSTR) (((LPBYTE) mountPointsOut) + mountPointsOut->MountPoints[index].SymbolicLinkNameOffset),
        mountPointsOut->MountPoints[0].DeviceNameLength
        );

EXIT:

    //
    // Free up locally allocated data
    //
    if (mountPointIn) {
       HeapFree(heapHandle, 0L, mountPointIn);
       mountPointIn = NULL;
    }

    if (mountPointsOut) {
       HeapFree(heapHandle, 0L, mountPointsOut);
       mountPointsOut = NULL;
    }

    if (status != ERROR_SUCCESS) {
        if (*lpVolumeDevicePath) {
            HeapFree(heapHandle, 0L, (*lpVolumeDevicePath));
        }
        
    }

    if ((mpHandle) && (INVALID_HANDLE_VALUE != mpHandle)) {
        CloseHandle(mpHandle);
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AddClusterInfoToMountPoints(
    IN PASRFMT_MOUNT_POINTS_INFO pMpInfoList, 
    IN PCWSTR   lpDeviceName,
    IN BOOL     bIsClusterShared,
    IN PCWSTR   lpFsName,
    IN DWORD    cchFsName,
    IN PCWSTR   lpLabel,
    IN DWORD    cchLabel,
    IN DWORD    dwClusterSize
    ) 
{

    BOOL foundAMatch = FALSE;
    PASRFMT_MOUNT_POINTS_INFO pMp = NULL;

    if (!pMpInfoList) {
        return FALSE;
    }

    pMp = pMpInfoList;
    while (pMp && !foundAMatch) {

        if ((pMp->pDeviceName) && 
            (pMp->cchDeviceName == wcslen(lpDeviceName)) && 
            !(wcsncmp(pMp->pDeviceName, lpDeviceName, pMp->cchDeviceName))) {
            
            //
            // This is the correct node, copy over the info .
            //
            pMp->IsClusterShared = bIsClusterShared;
            wcsncpy(pMp->szFsName, lpFsName, cchFsName);
            wcsncpy(pMp->szLabel, lpLabel, cchLabel);
            pMp->dwClusterSize = dwClusterSize;

            foundAMatch = TRUE;
        }

        pMp = pMp->pNext;
    }

    return foundAMatch;
}


//
// Sanity checks to see if all the offsets in the table are 
// inside the buffer
//
DWORD
AsrfmtpSanityCheckClusterTable(
    IN PASRFMT_CLUSTER_VOLUMES_TABLE pClusterVolTable,
    IN CONST DWORD dwBufferSize
    )
{
    DWORD dwCount = 0;
    
    if ((sizeof(ASRFMT_CLUSTER_VOLUMES_TABLE) + 
        (sizeof(ASRFMT_CLUSTER_VOLUME_INFO) * (pClusterVolTable->NumberOfEntries - 1))) > dwBufferSize) {
        return ERROR_INVALID_DATA;
    }

    for (dwCount = 0; dwCount < pClusterVolTable->NumberOfEntries; dwCount++) {

        if ((pClusterVolTable->VolumeInfoEntry[dwCount].FsNameOffset + 
            pClusterVolTable->VolumeInfoEntry[dwCount].FsNameLength) > dwBufferSize) {
            return ERROR_INVALID_DATA;
        }

        if ((pClusterVolTable->VolumeInfoEntry[dwCount].LabelOffset + 
            pClusterVolTable->VolumeInfoEntry[dwCount].LabelLength) > dwBufferSize) {
            return ERROR_INVALID_DATA;
        }

        if ((pClusterVolTable->VolumeInfoEntry[dwCount].SymbolicNamesLength + 
            pClusterVolTable->VolumeInfoEntry[dwCount].SymbolicNamesOffset) > dwBufferSize) {
            return ERROR_INVALID_DATA;
        }
    }

    return ERROR_SUCCESS;
}
//
// Enums the cluster disks, and for each disk,
// calls across to syssetup!XYZ on the owner node.
// 
// Which then goes through all the partitions on the disk,
// gets the volume info for each partition on the disk,
// and passes back the signature and other relevant
// volume info for each partition.
// 
// This struct then gets the local disk number for the
// disk, gets the volume guid for that partition, and
// adds in volume nodes for the partition.
//
DWORD 
ResourceCallBack(
    IN HRESOURCE hOriginal,   
    IN HRESOURCE hResource,  
    IN PVOID lpParams   
    )
{

    DISK_DLL_EXTENSION_INFO inBuffer;
    
    PBYTE outBuffer = NULL;
    
    DWORD sizeOutBuffer = 0,
        bytesReturned = 0;

    DWORD status = ERROR_SUCCESS;

    PASRFMT_MOUNT_POINTS_INFO pMountPoints = NULL;

    PASRFMT_CLUSTER_VOLUMES_TABLE pClusterVolTable = NULL;

    WCHAR szPartitionDevicePath[ASRFMT_DEVICEPATH_FORMAT_LENGTH];
    
    HANDLE heapHandle = NULL;

    BOOL done = FALSE,
        result = TRUE;

    DWORD dwCount = 0;
    
    PWSTR lpDevicePath = NULL,
        symbolicLink = NULL,
        lpFsName = NULL,
        lpLabel = NULL;

    USHORT cchFsName = 0,
        cchLabel = 0,
        cchDevicePath = 0,
        cchSymbolicLink = 0;

    DWORD dwClusterSize = 0;

    if (!lpParams) {
        //
        // The system must have at least one mount point that has been enumerated
        // already (the system volume, at least!), so our mount point list shouldn't be NULL.
        //
        ASSERT(0);
        return ERROR_INVALID_PARAMETER;
    }

    memset(szPartitionDevicePath, 0L, (ASRFMT_DEVICEPATH_FORMAT_LENGTH)*sizeof(WCHAR));
    heapHandle = GetProcessHeap();
    pMountPoints = (PASRFMT_MOUNT_POINTS_INFO) lpParams;

    //
    // Allocate a reasonably-sized memory for the out buffer.  If this isn't 
    // big enough, we'll re-allocate.
    //
    sizeOutBuffer = 4096;
    outBuffer = (PBYTE) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeOutBuffer
        );
    ErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Call AsrGetVolumeInfo on the node owning this disk resource
    // 
    ZeroMemory(&inBuffer, sizeof(inBuffer));
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy(inBuffer.DllModuleName, ASRFMT_CLUSTER_DLL_MODULE_NAME);
    strcpy(inBuffer.DllProcName, ASRFMT_CLUSTER_DLL_PROC_NAME);
    
    status = ClusterResourceControl(
        hResource,
        NULL,
        CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
        &inBuffer,
        sizeof(DISK_DLL_EXTENSION_INFO),
        (PVOID) outBuffer,
        sizeOutBuffer,
        &bytesReturned 
        );

    if (ERROR_INSUFFICIENT_BUFFER == status) {
        //
        // The buffer wasn't big enough, re-allocate as needed
        //
        HeapFree(heapHandle, 0L, outBuffer);

        sizeOutBuffer = bytesReturned;
        outBuffer = (PBYTE) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeOutBuffer
            );
        ErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

        status = ClusterResourceControl( 
            hResource,
            NULL,
            CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
            &inBuffer,
            sizeof(DISK_DLL_EXTENSION_INFO),
            (PVOID) outBuffer,
            sizeOutBuffer,
            &bytesReturned 
            );
    }
    ErrExitCode((ERROR_SUCCESS != status), status, status);

    pClusterVolTable = (PASRFMT_CLUSTER_VOLUMES_TABLE) outBuffer;

    //
    // Sanity check to see if all the offsets in the table are 
    // inside the buffer
    //
    status = AsrfmtpSanityCheckClusterTable(pClusterVolTable, sizeOutBuffer);
    ErrExitCode((ERROR_SUCCESS != status), status, status);
    
    //
    // Go through the Volume info entries for each partition, and copy over the 
    // info to the appropriate MpInfo node
    //
    for (dwCount = 0; dwCount < pClusterVolTable->NumberOfEntries; dwCount++) {

        lpFsName = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[dwCount].FsNameOffset);
        cchFsName = pClusterVolTable->VolumeInfoEntry[dwCount].FsNameLength / sizeof (WCHAR);

        lpLabel = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[dwCount].LabelOffset);
        cchLabel = pClusterVolTable->VolumeInfoEntry[dwCount].LabelLength / sizeof (WCHAR);

        dwClusterSize = (DWORD) (pClusterVolTable->VolumeInfoEntry[dwCount].dwClusterSize);

        if (!(pClusterVolTable->VolumeInfoEntry[dwCount].SymbolicNamesOffset)) {
            continue;
        }

        //
        // This is a "fake" device path (that is actually the first symbolic link), since 
        // absolute device paths for volumes on remote nodes are not relevant on local node.
        //
        lpDevicePath = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[dwCount].SymbolicNamesOffset);
        cchDevicePath = (USHORT) wcslen(lpDevicePath);

        AddSymbolicLink(pMountPoints, lpDevicePath, cchDevicePath, lpDevicePath, cchDevicePath, (LPVOID)outBuffer);

        //
        // Add VolumeInfo to pMountPoints DevicePath;
        //
        result = AddClusterInfoToMountPoints(
            pMountPoints, 
            lpDevicePath,
            TRUE,                               // IsClusterShared
            lpFsName,
            cchFsName,
            lpLabel,
            cchLabel,
            dwClusterSize
            );
        ASSERT(result);

        symbolicLink = (PWSTR) ((LPBYTE)lpDevicePath + (sizeof(WCHAR) * (cchDevicePath + 1)));
        while (*symbolicLink) {

            cchSymbolicLink = (USHORT) wcslen(symbolicLink);
            AddSymbolicLink(pMountPoints, lpDevicePath, cchDevicePath, symbolicLink, cchSymbolicLink, (LPVOID)outBuffer);

            symbolicLink = (PWSTR) ((LPBYTE)symbolicLink + (sizeof(WCHAR) * (cchSymbolicLink + 1)));
        }
    }

EXIT:

/*    if (outBuffer) {
        HeapFree(heapHandle, 0L, outBuffer);
    }
*/
    return status;
}


BOOL
HandleClusterVolumes(
    IN PASRFMT_MOUNT_POINTS_INFO pMountPoints
    )
{
    if (!pMountPoints) {
        ASSERT(0 && "pMountPoints is NULL");
        return FALSE;
    }

    ResUtilEnumResources(NULL,
        ASRFMT_CLUSTER_PHYSICAL_DISK,
        ResourceCallBack,
        pMountPoints
        );

    return TRUE;
}


BOOL
pAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    CloseHandle(hToken);
    return bResult;
}

BOOL
AsrfmtpIsInaccessibleSanVolume(
    IN PCWSTR szVolumeName
    )
/*++

Routine Description:
    
    Utility to check if the current volume is a shared SAN disk that's "owned"
    by a different machine (and is hence inaccessible).
    
Arguments:

    szVolumeName - Win-32 name for volume interest.

Return Value:

    If the function succeeds and the volume is a shared SAN disk that is 
            owned by some other machine, the return value is a nonzero value.

    If the function fails, or if the volume is not a shared SAN volume that
            is owned by a different machine (ie, is a local unshared volume, or
            a shared volume owned by this machine) the return value 
            is zero. 

--*/
{
    DWORD dwStatus = ERROR_SUCCESS,
        dwDummy = 0;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    BOOL bIsInaccessibleDevice = FALSE;

    //
    // Get a handle to the first partition on disk
    //
    hVolume = CreateFileW(
        szVolumeName,                    // lpFileName
        0,                                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                               // lpSecurityAttributes
        OPEN_EXISTING,                      // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,              // dwFlagsAndAttributes
        NULL                                // hTemplateFile
        );

    if (INVALID_HANDLE_VALUE == hVolume) {
        //
        // We couldn't open the partition.  Now check for the specific error
        // code we're interested in (STATUS_OFF_LINE, which gets mapped to
        // ERROR_NOT_READY).
        //
        dwStatus = GetLastError();

        if (ERROR_NOT_READY == dwStatus) {
            bIsInaccessibleDevice = TRUE;
        }
    }
    else {

        //
        // Dynamic disks don't support this IOCTL, and will return a failure.  
        // Basic disks that are online will return FALSE as well.  
        //
        bIsInaccessibleDevice = DeviceIoControl(
            hVolume,
            IOCTL_VOLUME_IS_OFFLINE,
            NULL,
            0,
            NULL,
            0,
            &dwDummy,
            NULL
            );
    }

    if (INVALID_HANDLE_VALUE != hVolume) {
        CloseHandle(hVolume);
    }

    return bIsInaccessibleDevice;
}



BOOL
BuildStateInfo(
    IN PASRFMT_STATE_INFO pState
    )
{
    UINT driveType = DRIVE_UNKNOWN;
    WCHAR szVolumeGuid[MAX_PATH + 1];

    PWSTR lpDevName = NULL,
        lpSymbolicLink = NULL;
    
    USHORT cchDevName = 0,
        cchSymbolicLink = 0;

    DWORD dwCount = 0;
    
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = FALSE;
    PMOUNTMGR_MOUNT_POINTS pMountPoints = NULL;
    HANDLE hHeap = NULL;

    PASRFMT_MOUNT_POINTS_INFO pMpInfoList = NULL,
        pMp = NULL;

    hHeap = GetProcessHeap();

    //
    // We need to acquire the backup and restore privileges to write to asr.sif
    //
    if (!pAcquirePrivilege(SE_BACKUP_NAME)) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    if (!pAcquirePrivilege(SE_RESTORE_NAME)) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    pMountPoints = GetMountPoints();
    if (!pMountPoints) {
        //
        // No volumes exist (!)
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    pMpInfoList = (PASRFMT_MOUNT_POINTS_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(ASRFMT_MOUNT_POINTS_INFO)
        );
    ErrExitCode(!pMpInfoList, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Now, we go through the mountpoint table returned, and
    // create the appropriate structs that we'll need to save.
    //
    // The mount point table consists of entries of the form:
    //   device name                symbolic link
    // ----------------------------------------------
    // \device\harddiskvolume1      \??\volume{guid1}
    // \device\harddiskvolume1      \dosdevices\c:
    // \device\harddiskvolume1      \??\volume{guid2}
    // \device\harddiskvolume2      \??\volume{guid3}
    // \device\harddiskvolume2      \dosdevices\d:
    // \device\floppy0              \dosdevices\a:
    // \device\floppy0              \??\volume{guid4}
    // \device\cdrom0               \dosdevices\e:
    // \device\cdrom0               \??\volume{guid5}
    //
    // ... etc
    //
    // For fixed disks, we don't care about the device name, and we
    // store the following in asr.sif:
    //
    // [VOLUMES]
    // \??\volume{guid1}, \dosdevices\c:
    // \??\volume{guid1}, \??\volume{guid2}
    // \??\volume{guid3}, \dosdevices\d:
    //
    //
    // For removable devices, we care about the device name as well, 
    // and store this in asr.sif:
    //
    // [RemovableMedia]
    // \device\floppy0, \??\volume{guid4}, \dosdevices\a:
    // \device\cdrom0, \??\volume{guid5}, \dosdevices\e:
    //
    //
    // First, we build up our structure containing the info
    //
    for (dwCount = 0; dwCount < pMountPoints->NumberOfMountPoints; dwCount++) {

        lpDevName = (PWSTR) (((LPBYTE)pMountPoints) + pMountPoints->MountPoints[dwCount].DeviceNameOffset);
        cchDevName = pMountPoints->MountPoints[dwCount].DeviceNameLength / sizeof (WCHAR);

        lpSymbolicLink = (PWSTR) (((LPBYTE)pMountPoints) + pMountPoints->MountPoints[dwCount].SymbolicLinkNameOffset);
        cchSymbolicLink = pMountPoints->MountPoints[dwCount].SymbolicLinkNameLength / sizeof (WCHAR);


        AddSymbolicLink(pMpInfoList, lpDevName, cchDevName, lpSymbolicLink, cchSymbolicLink, (LPVOID)NULL);

    }

    //
    // Add the volume info for any cluster volumes, since we cannot access them 
    // directly if the disk is owned by another node.  This function will fail
    // if we're not running on a cluster--so we don't care about the return value.
    //
    HandleClusterVolumes(pMpInfoList);

    //
    // Now, we go through the list, and build the pVolume and pRemovableMedia
    // structs
    //
    pMp = pMpInfoList;
    while (pMp) {

        if (!(pMp->pDeviceName && pMp->pVolumeGuid)) {
            pMp = pMp->pNext;
            continue;
        }

        DWORD cchGuid = pMp->cchVolumeGuid;

        WCHAR szFsName[ASRFMT_CCH_FS_NAME];
        WCHAR szLabel[ASRFMT_CCH_VOLUME_LABEL];
        DWORD dwClusterSize;

        //
        // GetDriveType needs the volume guid in the dos-name-space, while the
        // mount manager gives the volume guid in the nt-name-space.  Convert
        // the name by changing the \??\ at the beginning to \\?\, and adding 
        // a back-slash at the end.
        //
        wcsncpy(szVolumeGuid, pMp->pVolumeGuid, cchGuid);
        szVolumeGuid[1] = L'\\';


        szVolumeGuid[cchGuid] = L'\0'; 

        if (AsrfmtpIsInaccessibleSanVolume(szVolumeGuid)) {
            pMp = pMp->pNext;
            continue;
        }
        
        szVolumeGuid[cchGuid] = L'\\';    // Trailing back-slash
        szVolumeGuid[cchGuid+1] = L'\0';

        driveType = DRIVE_UNKNOWN;
        if (!pMp->IsClusterShared) {
            driveType = GetDriveType(szVolumeGuid);
        }

        if ((pMp->IsClusterShared) || (DRIVE_FIXED == driveType)) {

            if (!pMp->IsClusterShared) {
                //
                // Get the FS Label, cluster size, and so on.
                //
                bResult = GetVolumeDetails(szVolumeGuid, 
                    szFsName, 
                    ASRFMT_CCH_FS_NAME, 
                    szLabel, 
                    ASRFMT_CCH_VOLUME_LABEL,
                    &dwClusterSize
                    );
                // ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {
                //
                // If it's a cluster shared disk, then we already
                // got the relavant info earlier
                //
                wcsncpy(szFsName, pMp->szFsName, ASRFMT_CCH_FS_NAME-1);
                wcsncpy(szLabel, pMp->szLabel, ASRFMT_CCH_VOLUME_LABEL-1);

                szFsName[ASRFMT_CCH_FS_NAME-1] = L'\0';
                szLabel[ASRFMT_CCH_VOLUME_LABEL-1] = L'\0';
                dwClusterSize = pMp->dwClusterSize;
            }

            //
            // Now, create a VolumeInfo structure for each symbolic link.
            //
            PASRFMT_MP_LINK pCurrentLink = pMp->pSymbolicLinks;
            if (!pCurrentLink) {
                //
                // This volume does not have any symbolic links attached to it
                //
                PASRFMT_VOLUME_INFO pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_VOLUME_INFO)
                    );
                ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                wcsncpy(pNewVolume->szGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);

                wcscpy(pNewVolume->szFsName, szFsName);
                wcscpy(pNewVolume->szLabel, szLabel);
                pNewVolume->dwClusterSize = dwClusterSize;

                bResult = AddSortedVolumeInfo(&(pState->pVolume), pNewVolume);
                ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {
                while (pCurrentLink) {

                    PASRFMT_VOLUME_INFO pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
                        hHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(ASRFMT_VOLUME_INFO)
                        );
                    ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                    wcsncpy(pNewVolume->szGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                    wcsncpy(pNewVolume->szDosPath, pCurrentLink->pLink, pCurrentLink->cchLink);

                    wcscpy(pNewVolume->szFsName, szFsName);
                    wcscpy(pNewVolume->szLabel, szLabel);
                    pNewVolume->dwClusterSize = dwClusterSize;

                    bResult = AddSortedVolumeInfo(&(pState->pVolume), pNewVolume);
                    ErrExitCode(!bResult, dwStatus, GetLastError());

                    pCurrentLink = pCurrentLink->pNext;
                }
            }

        }
        else if (DRIVE_UNKNOWN != driveType) {

            PASRFMT_MP_LINK pCurrentLink = pMp->pSymbolicLinks;
            if (!pCurrentLink) {
                //
                // This volume has no symbolic links at all (ie no drive
                // letter or mountpoint)
                //
                PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
                    );
                ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                wcsncpy(pNewMedia->szVolumeGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                wcsncpy(pNewMedia->szDevicePath, pMp->pDeviceName, pMp->cchDeviceName);

                bResult = AddSortedRemovableMediaInfo(&(pState->pRemovableMedia), pNewMedia);
                ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {

                while (pCurrentLink) {

                    PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
                        hHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
                        );
                    ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                    wcsncpy(pNewMedia->szVolumeGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                    wcsncpy(pNewMedia->szDosPath, pCurrentLink->pLink, pCurrentLink->cchLink);
                    wcsncpy(pNewMedia->szDevicePath, pMp->pDeviceName, pMp->cchDeviceName);

                    bResult = AddSortedRemovableMediaInfo(&(pState->pRemovableMedia), pNewMedia);
                    ErrExitCode(!bResult, dwStatus, GetLastError());

                    pCurrentLink = pCurrentLink->pNext;
                }
            }
        }

        pMp = pMp->pNext;
     }

EXIT:
    if (pMountPoints) {
        HeapFree(hHeap, 0L, pMountPoints);
        pMountPoints = NULL;
    }

    if (pMpInfoList) {
        FreeMpInfo(&pMpInfoList);
    }

    return (ERROR_SUCCESS == dwStatus);
}


//
// Sets the dosdevices (of the form "\DosDevices\X:") for the 
// volume with the GUID passed in (of the form "\??\Volume{Guid}")
//
BOOL
SetDosName(
    IN PWSTR lpVolumeGuid,
    IN PWSTR lpDosPath
    )
{
    HANDLE hMountMgr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    WCHAR szDeviceNameForGuid[MAX_PATH + 1],
        szDeviceNameForDosPath[MAX_PATH + 1];

    if (!lpVolumeGuid || !lpDosPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Open the mount manager
    //
    hMountMgr = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        GENERIC_READ    | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!hMountMgr || INVALID_HANDLE_VALUE == hMountMgr), dwStatus, GetLastError());

    //
    // Get the Device Paths from the GUID and Dos Path
    //
    bResult = DoMountMgrWork(hMountMgr, mmfGetDeviceName, lpVolumeGuid, szDeviceNameForGuid);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    bResult = DoMountMgrWork(hMountMgr, mmfGetDeviceName, lpDosPath, szDeviceNameForDosPath);
    if (bResult && !wcscmp(szDeviceNameForGuid, szDeviceNameForDosPath)) {
        //
        // The Guid already has the Dos Path.  We're done.
        //
        ErrExitCode(TRUE, dwStatus, ERROR_SUCCESS);
    }

    //
    // Delete the dos path if it is currently being used by another volume
    //
    if (wcslen(lpDosPath) > 0) {
        bResult = DoMountMgrWork(hMountMgr, mmfDeleteDosName, lpDosPath, NULL);
    }

    //
    // If we're trying to set the drive letter, then delete any other dos path 
    // currently being used by this volume.
    //
    if (ASRFMT_LOOKS_LIKE_DOS_DEVICE(lpDosPath, (wcslen(lpDosPath) * sizeof(WCHAR)))
        || (0 == wcslen(lpDosPath))
        ) {
        bResult = DoMountMgrWork(hMountMgr, mmfDeleteDosName, NULL, szDeviceNameForGuid);
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

    //
    // Assign the Dos Path to this VolumeGuid
    //
    if (wcslen(lpDosPath) > 0) {
        bResult = DoMountMgrWork(hMountMgr, mmfCreateSymbolicLinkName, lpDosPath, lpVolumeGuid);
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

EXIT:
    if (hMountMgr && INVALID_HANDLE_VALUE != hMountMgr) {
        CloseHandle(hMountMgr);
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


BOOL
SetRemovableMediaGuid(
    IN PWSTR lpDeviceName,
    IN PWSTR lpGuid
    )
{
    static LONG s_LastCdIndex = 0;
    static LONG s_LastFloppyIndex = 0;
    static LONG s_LastJazIndex = 0;

    static PMOUNTMGR_MOUNT_POINTS s_pMountPoints = NULL;
    static HANDLE s_hMountMgr = NULL;

    WCHAR szNewDeviceName[MAX_PATH + 1];
    ZeroMemory(szNewDeviceName, (MAX_PATH+1) * sizeof(WCHAR));

    LONG index = 0;

    if ((!lpDeviceName) && (!lpGuid)) {
        //
        // Both parameters are NULL, we free the mount points and reset Indices.
        //
        s_LastCdIndex =  (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastFloppyIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastJazIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;

        if (s_pMountPoints) {
            HeapFree(GetProcessHeap(), 0L, s_pMountPoints);
            s_pMountPoints = NULL;
        }
        
        if (s_hMountMgr && INVALID_HANDLE_VALUE != s_hMountMgr) {
            CloseHandle(s_hMountMgr);
            s_hMountMgr = NULL;
        }
        
        return TRUE;
    } 

    if ((!lpDeviceName) || (!lpGuid)) {
        return FALSE;
    }

    if (!s_pMountPoints) {
        //
        // This is the first time this function is being called (after a 
        // clean-up), we get a list of mount points on the current machine
        // and store it.
        //
        s_pMountPoints = GetMountPoints();
        if (!s_pMountPoints) {
            return FALSE;
        }
        s_LastCdIndex =  (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastFloppyIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastJazIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
    }

    if ((!s_hMountMgr) || (INVALID_HANDLE_VALUE == s_hMountMgr)) {
        s_hMountMgr = CreateFileW(
            (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            INVALID_HANDLE_VALUE
            );

        if ((!s_hMountMgr) || (INVALID_HANDLE_VALUE == s_hMountMgr)) {
            return FALSE;
        }
    }

    index = s_pMountPoints->NumberOfMountPoints;

    if (wcsstr(lpDeviceName, L"\\Device\\CdRom")) {
        //
        // We're trying to set the GUID for a CD-ROM device  We go through the list of
        // the MountPoints, till we find the next \Device\CdRomX to use
        //
        for (index = s_LastCdIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );
            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a CD-ROM device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\CdRom")) {
                s_LastCdIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastCdIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastCdIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastCdIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastCdIndex;
                }
                break;
            }
        }
    } 
    else if (wcsstr(lpDeviceName, L"\\Device\\Floppy")) {
        //
        // We're trying to set the GUID for a floppy device  We go through the list of
        // the MountPoints, till we find the next \Device\FloppyX to use
        //
        for (index = s_LastFloppyIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );

            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a Floppy device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\Floppy")) {
                s_LastFloppyIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastFloppyIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastFloppyIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastFloppyIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastFloppyIndex;
                }
                break;
            }
        }
    } 
    else if (wcsstr(lpDeviceName, L"\\Device\\Harddisk") &&
        wcsstr(lpDeviceName, L"DP(") &&
        !wcsstr(lpDeviceName, L"Partition")
        ){
        //
        // This is most likely a JAZ or ZIP drive.  We can't do much to identify the 
        // JAZ/ZIP drives uniquely, so this may end up in the wrong drive getting the
        // wrong drive letter.
        // 
        for (index = s_LastJazIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );

            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a JAZ or ZIP device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\Harddisk") &&
                wcsstr(szNewDeviceName, L"DP(") &&
                !wcsstr(szNewDeviceName, L"Partition")
                ) {
                s_LastJazIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastJazIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastJazIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastJazIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastJazIndex;
                }
                break;
            }
        }
    }
    else {
        //
        // We don't recognise this Device
        //
        index = -1;
    }

    if (index < 0) {
        return FALSE;
    }

    if (!DoMountMgrWork(s_hMountMgr, mmfDeleteVolumeGuid, NULL, szNewDeviceName)) {
        return FALSE;
    }

    if (!DoMountMgrWork(s_hMountMgr, mmfCreateSymbolicLinkName, lpGuid, szNewDeviceName)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
DoMountMgrWork(
    IN HANDLE hMountMgr,               
    IN ASRFMT_MM_FUNCTION mmfFunction,
    IN PWSTR lpSymbolicName,
    IN PWSTR lpDeviceName
    )
{
    
    PMOUNTMGR_MOUNT_POINT pMountPointIn = NULL,
        pDeletePointIn = NULL;
    PMOUNTMGR_MOUNT_POINTS pMountPointsOut = NULL;
    PMOUNTMGR_CREATE_POINT_INPUT pCreatePointIn = NULL;
    MOUNTMGR_MOUNT_POINTS MountPointsTemp;

    DWORD cbSymbolicName = 0,
        cbDeviceName = 0,
        cbMountPoints = 0;

    DWORD index = 0;

    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    HANDLE hHeap = NULL;

    if (lpSymbolicName && !wcslen(lpSymbolicName)) {
        return TRUE;
    }

    hHeap = GetProcessHeap();

    if (lpSymbolicName) {
        cbSymbolicName = wcslen(lpSymbolicName) * sizeof(WCHAR);
    }

    if (lpDeviceName) {
        cbDeviceName = wcslen(lpDeviceName) * sizeof(WCHAR);
    }

    pMountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + cbSymbolicName + cbDeviceName
        );
    ErrExitCode(!pMountPointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    if (mmfCreateSymbolicLinkName != mmfFunction) {
        //
        // Query for the Unique Id
        //
        if (cbSymbolicName) {
            pMountPointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            pMountPointIn->SymbolicLinkNameLength = (USHORT) cbSymbolicName;

            CopyMemory(((LPBYTE)pMountPointIn) + pMountPointIn->SymbolicLinkNameOffset,
                       lpSymbolicName, pMountPointIn->SymbolicLinkNameLength);
        }
        else  {
            pMountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            pMountPointIn->DeviceNameLength = (USHORT) cbDeviceName;

            CopyMemory((LPBYTE)pMountPointIn + pMountPointIn->DeviceNameOffset,
                       lpDeviceName, pMountPointIn->DeviceNameLength);
        } 

        // this call should fail with ERROR_MORE_DATA
        bResult = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_QUERY_POINTS,
            pMountPointIn,
            (sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength + pMountPointIn->SymbolicLinkNameLength),
            &MountPointsTemp,
            sizeof(MountPointsTemp),
            &cbMountPoints,
            NULL
            );

        if (!bResult) {
            dwStatus = GetLastError();

            // if buffer is of insufficient size, resize the buffer.
            if (ERROR_MORE_DATA             == dwStatus || 
                ERROR_INSUFFICIENT_BUFFER   == dwStatus || 
                ERROR_BAD_LENGTH            == dwStatus 
                ) {

                dwStatus = ERROR_SUCCESS;

                pMountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                    hHeap, 
                    HEAP_ZERO_MEMORY, 
                    MountPointsTemp.Size
                    );
                ErrExitCode(!pMountPointsOut, dwStatus, ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                //
                // If some other error occurred, EXIT.
                // This is not a fatal error in the case of removable storage media
                //
                ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
            }
        }
        else {
            //
            // the call succeeded when we expected it to fail--something's wrong.
            // This is not a fatal error in the case of removable storage media.
            //
            ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
        }

        bResult = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_QUERY_POINTS,
            pMountPointIn,
            sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength + pMountPointIn->SymbolicLinkNameLength,
            pMountPointsOut,
            MountPointsTemp.Size,
            &cbMountPoints,
            NULL
            );
        ErrExitCode((!cbMountPoints || !bResult), dwStatus, GetLastError());
    }

    switch (mmfFunction) {
    case mmfGetDeviceName: {
        //
        //  Copy the device name to lpDeviceName, and we're done
        //
        CopyMemory(lpDeviceName, 
            ((LPBYTE) pMountPointsOut) + pMountPointsOut->MountPoints[0].DeviceNameOffset,
            pMountPointsOut->MountPoints[0].DeviceNameLength
            );

        // Null-terminate the string
        lpDeviceName[pMountPointsOut->MountPoints[0].DeviceNameLength / sizeof(WCHAR)] = L'\0';
        
        break;
    }
    
    case mmfDeleteDosName:
    case mmfDeleteVolumeGuid: {

        DWORD cbName = 0;
        PWSTR lpName = NULL;
        DWORD cbDeletePoint = 0;

        //
        // Go through the list of mount points returned, and delete the appropriate
        // entries.
        //
        for (index = 0; index < pMountPointsOut->NumberOfMountPoints; index++) {
            lpName = (PWSTR) (((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].SymbolicLinkNameOffset);
            cbName = (DWORD) pMountPointsOut->MountPoints[index].SymbolicLinkNameLength;

            if ((mmfDeleteDosName == mmfFunction) &&
               (ASRFMT_LOOKS_LIKE_DOS_DEVICE(lpName, cbName))
               ) {
               break;
            }

            if ((mmfDeleteVolumeGuid == mmfFunction) &&
                (ASRFMT_LOOKS_LIKE_VOLUME_GUID(lpName, cbName))
                ) {
               break;
            }
        }


        if (index == pMountPointsOut->NumberOfMountPoints) {
            //
            // No matching entries were found
            //
            break;
        }

        cbDeletePoint = sizeof(MOUNTMGR_MOUNT_POINT) +
            pMountPointsOut->MountPoints[index].SymbolicLinkNameLength +
            pMountPointsOut->MountPoints[index].UniqueIdLength +
            pMountPointsOut->MountPoints[index].DeviceNameLength;

        pDeletePointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            cbDeletePoint
            );
        ErrExitCode(!pDeletePointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        pDeletePointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
        pDeletePointIn->SymbolicLinkNameLength = pMountPointsOut->MountPoints[index].SymbolicLinkNameLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->SymbolicLinkNameOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].SymbolicLinkNameOffset,
            pDeletePointIn->SymbolicLinkNameLength);

        pDeletePointIn->UniqueIdOffset = pDeletePointIn->SymbolicLinkNameOffset +
                                        pDeletePointIn->SymbolicLinkNameLength;
        pDeletePointIn->UniqueIdLength = pMountPointsOut->MountPoints[index].UniqueIdLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->UniqueIdOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].UniqueIdOffset,
            pDeletePointIn->UniqueIdLength);

        pDeletePointIn->DeviceNameOffset = pDeletePointIn->UniqueIdOffset +
                                          pDeletePointIn->UniqueIdLength;
        pDeletePointIn->DeviceNameLength = pMountPointsOut->MountPoints[index].DeviceNameLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->DeviceNameOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].DeviceNameOffset,
            pDeletePointIn->DeviceNameLength);

        bResult = DeviceIoControl(hMountMgr,
            IOCTL_MOUNTMGR_DELETE_POINTS,
            pDeletePointIn,
            cbDeletePoint,
            pMountPointsOut,
            MountPointsTemp.Size,
            &cbMountPoints,
            NULL
            );
        ErrExitCode(!bResult, dwStatus, GetLastError());

        break;
    }

    case mmfCreateSymbolicLinkName: {

        pCreatePointIn = (PMOUNTMGR_CREATE_POINT_INPUT) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof (MOUNTMGR_CREATE_POINT_INPUT) + cbDeviceName + cbSymbolicName 
            );
        ErrExitCode(!pCreatePointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        pCreatePointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
        pCreatePointIn->SymbolicLinkNameLength = (USHORT) cbSymbolicName;

        pCreatePointIn->DeviceNameOffset = pCreatePointIn->SymbolicLinkNameOffset + pCreatePointIn->SymbolicLinkNameLength;
        pCreatePointIn->DeviceNameLength = (USHORT) cbDeviceName;

        CopyMemory(((LPBYTE)pCreatePointIn) + pCreatePointIn->SymbolicLinkNameOffset,
                   (LPBYTE)lpSymbolicName, pCreatePointIn->SymbolicLinkNameLength);

        CopyMemory(((LPBYTE)pCreatePointIn) + pCreatePointIn->DeviceNameOffset,
                   (LPBYTE)lpDeviceName, pCreatePointIn->DeviceNameLength);

        bResult = DeviceIoControl(
            hMountMgr, 
            IOCTL_MOUNTMGR_CREATE_POINT, 
            pCreatePointIn,
            sizeof(MOUNTMGR_CREATE_POINT_INPUT) + pCreatePointIn->SymbolicLinkNameLength + pCreatePointIn->DeviceNameLength, 
            NULL, 
            0, 
            &cbMountPoints, 
            NULL
            );
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

    }

EXIT:

    if (pCreatePointIn) {
        HeapFree(hHeap, 0L, pCreatePointIn);
        pCreatePointIn = NULL;
    }

    if (pDeletePointIn) {
        HeapFree(hHeap, 0L, pDeletePointIn);
        pDeletePointIn = NULL;
    }

    if (pMountPointIn) {
        HeapFree(hHeap, 0L, pMountPointIn);
        pMountPointIn = NULL;
    }

    if (pMountPointsOut) {
        HeapFree(hHeap, 0L, pMountPointsOut);
        pMountPointsOut = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


PMOUNTMGR_MOUNT_POINTS  // Must be freed by caller
GetMountPoints()
{
    PMOUNTMGR_MOUNT_POINTS pMountPointsOut = NULL;
    PMOUNTMGR_MOUNT_POINT pMountPointIn = NULL;
    MOUNTMGR_MOUNT_POINTS MountPointsTemp;
    HANDLE hMountMgr = NULL,
        hHeap = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    DWORD cbMountPoints = 0;


    hHeap = GetProcessHeap();

    pMountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + sizeof(WCHAR)
        );
    ErrExitCode(!pMountPointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    // put the DeviceName ("") right after struct pMountPointIn
    wcsncpy((PWSTR) (pMountPointIn + 1), L"", 1);
    pMountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    pMountPointIn->DeviceNameLength = 0;

    // get a handle to the mount manager
    hMountMgr = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!hMountMgr || INVALID_HANDLE_VALUE == hMountMgr), dwStatus, GetLastError());
     
    // this call should fail with ERROR_MORE_DATA
    bResult = DeviceIoControl(
        hMountMgr,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        pMountPointIn,
        sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength,
        &MountPointsTemp,
        sizeof(MountPointsTemp),
        &cbMountPoints,
        NULL
        );

    if (!bResult) {
        dwStatus = GetLastError();

        // if buffer is of insufficient size, resize the buffer.
        if (ERROR_MORE_DATA             == dwStatus || 
            ERROR_INSUFFICIENT_BUFFER   == dwStatus || 
            ERROR_BAD_LENGTH            == dwStatus 
            ) {

            dwStatus = ERROR_SUCCESS;

            pMountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                hHeap, 
                HEAP_ZERO_MEMORY, 
                MountPointsTemp.Size
                );
            ErrExitCode(!pMountPointsOut, dwStatus, ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // If some other error occurred, EXIT.
            // This is not a fatal error in the case of removable storage media
            //
            ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
        }
    }
    else {
        //
        // the call succeeded when we expected it to fail--something's wrong.
        // This is not a fatal error in the case of removable storage media.
        //
        ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
    }

    bResult = DeviceIoControl(
        hMountMgr,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        pMountPointIn,
        sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength,
        pMountPointsOut,
        MountPointsTemp.Size,
        &cbMountPoints,
        NULL
        );
    ErrExitCode((!cbMountPoints || !bResult), dwStatus, GetLastError());

EXIT:

    if (pMountPointIn) {
        HeapFree(hHeap, 0L, pMountPointIn);
        pMountPointIn = NULL;
    }
        
    if (ERROR_SUCCESS != dwStatus) {
        if (pMountPointsOut) {
            HeapFree(hHeap, 0L, pMountPointsOut);
            pMountPointsOut = NULL;
        }
    }

    if (hMountMgr && INVALID_HANDLE_VALUE != hMountMgr) {
        CloseHandle(hMountMgr);
    }

    return pMountPointsOut;
}

//
// Based on AsrpExpandEnvStrings in syssetup\setupasr.c
//
PWSTR   // must be freed by caller
AsrfmtpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    DWORD status = ERROR_SUCCESS;
    HANDLE heapHandle = GetProcessHeap();

    expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
    ErrExitCode((!expandedString), status, ERROR_NOT_ENOUGH_MEMORY);
        
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(heapHandle, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
        ErrExitCode((!expandedString), status, ERROR_NOT_ENOUGH_MEMORY);
        
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        HeapFree(heapHandle, 0L, expandedString);
        expandedString = NULL;
    }

EXIT:
    return expandedString;
}


VOID
AsrfmtpInitialiseErrorFile() 
{
    PWSTR szErrorFilePath = NULL;

    //
    // Get full path to the error file.
    //
    szErrorFilePath = AsrfmtpExpandEnvStrings(ASRFMT_ASR_ERROR_FILE_PATH);
    if (!szErrorFilePath) {
        return;
    }

    //
    // Open the error log
    //
    Gbl_hErrorFile = CreateFileW(
        szErrorFilePath,            // lpFileName
        GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_ALWAYS,                // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );
    HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
    szErrorFilePath = NULL;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Move to the end of file
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

}

VOID
AsrfmtpCloseErrorFile() {

    if ((Gbl_hErrorFile) && (INVALID_HANDLE_VALUE != Gbl_hErrorFile)) {
        CloseHandle(Gbl_hErrorFile);
        Gbl_hErrorFile = NULL;
    }
}



VOID
AsrfmtpLogErrorMessage(
    IN _AsrfmtpMessageSeverity Severity,
    IN const LPCTSTR Message
    ) 
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    WCHAR buffer[4196];
    BOOL formatLoaded = FALSE;
    int res = 0;
    CString strFormat;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Load the format of the error string to be logged
    //
    if (_SeverityError == Severity) {
        res =  strFormat.LoadString(IDS_LOG_ERROR_FORMAT);
        if (res != 0) {
            formatLoaded = TRUE;
        }
    }
    else if (_SeverityWarning == Severity) {
        res = strFormat.LoadString(IDS_LOG_WARNING_FORMAT);
        if (res != 0) {
            formatLoaded = TRUE;
        }
    }
    else {
        //
        // We should only log error or warning messages to the error file
        //
        return;
    }

    //
    // In case someone else wrote to this file since our last write
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

    //
    // Create our string, and write it out
    //
    GetLocalTime(&currentTime);
    swprintf(buffer,
        (LPCTSTR) (formatLoaded? strFormat :  L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu] %s\r\n"),
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        Message
        );

    WriteFile(Gbl_hErrorFile,
        buffer,
        (wcslen(buffer) * sizeof(WCHAR)),
        &bytesWritten,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\attrib\attrib.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    attrib.cxx

Abstract:

    This utility allows the user to change file attributes.
    It is functionaly compatible with DOS 5 attrib utility.

Author:

    Jaime F. Sasson

Environment:

    ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "stream.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "attrib.hxx"

PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();


extern "C" {
#include <stdio.h>
}

DEFINE_CONSTRUCTOR( ATTRIB, PROGRAM );


BOOLEAN
ATTRIB::Initialize(
    )

/*++

Routine Description:

    Initializes an ATTRIB class.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    PWSTRING DynSubDirectory;
    PWSTRING DynSubFileName;

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;

    ARRAY               ArgumentArray;

    STRING_ARGUMENT     ProgramNameArgument;
//  STRING_ARGUMENT     FileNameArgument;
    PCWSTRING           FullFileNameString;
    PATH                DirectoryNamePath;
    PCWSTRING           InvalidName;
    PCWSTRING           TempPathString;
    DSTRING             TempPathStringDrive;
    PATH                PathDrive;
    DSTRING             BackSlashString;
    STRING_ARGUMENT     InvalidSwitch;
    STRING_ARGUMENT     InvalidSwitchPlus;
    STRING_ARGUMENT     InvalidSwitchMinus;
    PWSTRING            InvalidArgument;
    DSTRING             InvalidSwitchString;
    BOOLEAN             ActOnDirectory;


    _InitialDirectory = NULL;
    //
    //  Initialize MESSAGE object
    //
    _OutStream = Get_Standard_Output_Stream();
    if (_OutStream == NULL) {
        DebugPrintTrace(("ATTRIB: Output stream is NULL\n"));
        return FALSE;
    }
    _Message.Initialize( _OutStream, Get_Standard_Input_Stream() );

    //
    // Initialize string that contains End-Of-Line characters
    //
    if( !_EndOfLineString.Initialize( (LPWSTR)L"\r\n" ) ) {
        DebugPrint( "_EndOfLineString.Initialize() failed" );
        return( FALSE );
    }


    //
    //  Parse command line
    //
    if ( !LexArray.Initialize( ) ) {
        DebugPrint( "LexArray.Initialize() failed \n" );
        return( FALSE );
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DebugPrint( "ArgLex.Initialize() failed \n" );
        return( FALSE );
    }

    ArgLex.PutSwitches( "/" );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutStartQuotes( "\"");
    ArgLex.PutEndQuotes( "\"");
    ArgLex.PutSeparators( " \t" );

    if( !ArgLex.PrepareToParse() ) {
        DebugPrint( "ArgLex.PrepareToParse() failed \n" );
        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    if ( !ArgumentArray.Initialize() ) {
        DebugPrint( "ArgumentArray.Initialize() failed \n" );
        return( FALSE );
    }
    if( !ProgramNameArgument.Initialize("*") ||
        !_FlagRemoveSystemAttribute.Initialize( "-S" ) ||
        !_FlagAddSystemAttribute.Initialize( "+S" ) ||
        !_FlagRemoveHiddenAttribute.Initialize( "-H" ) ||
        !_FlagAddHiddenAttribute.Initialize( "+H" ) ||
        !_FlagRemoveReadOnlyAttribute.Initialize( "-R" ) ||
        !_FlagAddReadOnlyAttribute.Initialize( "+R" ) ||
        !_FlagRemoveArchiveAttribute.Initialize( "-A" ) ||
        !_FlagAddArchiveAttribute.Initialize( "+A" ) ||
        !_FlagRecurseDirectories.Initialize( "/S" ) ||
        !_FlagActOnDirectories.Initialize( "/D" ) ||
        !_FlagDisplayHelp.Initialize( "/?" ) ||
        !InvalidSwitch.Initialize( "/*" ) ||
        !InvalidSwitchPlus.Initialize( "+*" ) ||
        !InvalidSwitchMinus.Initialize( "-*" ) ||
        !_FileNameArgument.Initialize( "*" ) ) {
        DebugPrint( "Unable to initialize flag or string arguments \n" );
        return( FALSE );
    }
    if( !ArgumentArray.Put( &ProgramNameArgument ) ||
        !ArgumentArray.Put( &_FlagRemoveSystemAttribute ) ||
        !ArgumentArray.Put( &_FlagAddSystemAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveHiddenAttribute ) ||
        !ArgumentArray.Put( &_FlagAddHiddenAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveReadOnlyAttribute ) ||
        !ArgumentArray.Put( &_FlagAddReadOnlyAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveArchiveAttribute ) ||
        !ArgumentArray.Put( &_FlagAddArchiveAttribute ) ||
        !ArgumentArray.Put( &_FlagRecurseDirectories ) ||
        !ArgumentArray.Put( &_FlagActOnDirectories ) ||
        !ArgumentArray.Put( &_FlagDisplayHelp ) ||
        !ArgumentArray.Put( &InvalidSwitch ) ||
        !ArgumentArray.Put( &InvalidSwitchPlus ) ||
        !ArgumentArray.Put( &InvalidSwitchMinus ) ||
        !ArgumentArray.Put( &_FileNameArgument ) ) {
        DebugPrint( "ArgumentArray.Put() failed \n" );
        return( FALSE );
    }
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    //
    // Check the existance of an invalid switch
    //
    if( InvalidSwitch.IsValueSet() ||
        InvalidSwitchPlus.IsValueSet() ||
        InvalidSwitchMinus.IsValueSet() ) {

        if( InvalidSwitch.IsValueSet() ) {
            //
            // The invalid switch starts with '/'
            //
            if( !InvalidSwitchString.Initialize( "/" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( / ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitch.GetString();
            DebugPtrAssert( InvalidArgument );
        } else if ( InvalidSwitchPlus.IsValueSet() ) {
            //
            // The invalid switch starts with '+'
            //
            if( !InvalidSwitchString.Initialize( "+" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( + ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitchPlus.GetString();
            DebugPtrAssert( InvalidArgument );
        } else {
            //
            // The invalid switch starts with '-'
            //
            if( !InvalidSwitchString.Initialize( "-" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( - ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitchMinus.GetString();
            DebugPtrAssert( InvalidArgument );
        }
        //
        // Display the error message followed by the invalid switch
        //
        if( !InvalidSwitchString.Strcat( InvalidArgument ) ) {
            DebugPrint( "InvalidSwitchString.Strcat( InvalidArgument ) failed \n" );
            return( FALSE );
        }
        _Message.Set( MSG_ATTRIB_INVALID_SWITCH );
        _Message.Display( "%W", &InvalidSwitchString );
        return( FALSE );
    }

    if ( _FlagActOnDirectories.QueryFlag() &&
         !_FlagRecurseDirectories.QueryFlag() ) {
        _Message.Set( MSG_ATTRIB_INVALID_COMBINATION );
        _Message.Display();
        return( FALSE );
    }
    //
    // +S -S or +H -H or +R -R or +A -A are not valid
    // combination of arguments
    //
    if( ( _FlagRemoveSystemAttribute.QueryFlag() &&
          _FlagAddSystemAttribute.QueryFlag() ) ||
        ( _FlagRemoveHiddenAttribute.QueryFlag() &&
          _FlagAddHiddenAttribute.QueryFlag() ) ||
        ( _FlagRemoveReadOnlyAttribute.QueryFlag() &&
          _FlagAddReadOnlyAttribute.QueryFlag() ) ||
        ( _FlagRemoveArchiveAttribute.QueryFlag() &&
          _FlagAddArchiveAttribute.QueryFlag() ) ) {

        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    if(  _FlagRemoveSystemAttribute.QueryFlag() ||
         _FlagAddSystemAttribute.QueryFlag() ||
         _FlagRemoveHiddenAttribute.QueryFlag() ||
         _FlagAddHiddenAttribute.QueryFlag() ||
         _FlagRemoveReadOnlyAttribute.QueryFlag() ||
         _FlagAddReadOnlyAttribute.QueryFlag() ||
         _FlagRemoveArchiveAttribute.QueryFlag() ||
         _FlagAddArchiveAttribute.QueryFlag() ) {
         _PrintAttribInfo = FALSE;
         _ResetMask = (FSN_ATTRIBUTE)0xffffffff;
         if( _FlagRemoveSystemAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_SYSTEM;
         }
         if( _FlagRemoveHiddenAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_HIDDEN;
         }
         if( _FlagRemoveReadOnlyAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_READONLY;
         }
         if( _FlagRemoveArchiveAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_ARCHIVE;
         }

         _MakeMask = 0;
         if( _FlagAddSystemAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_SYSTEM;
         }
         if( _FlagAddHiddenAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_HIDDEN;
         }
         if( _FlagAddReadOnlyAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_READONLY;
         }
         if( _FlagAddArchiveAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_ARCHIVE;
         }
    } else {
        _PrintAttribInfo = TRUE;
    }

    //
    //  Get filename
    //
    if( !_FileNameArgument.IsValueSet() ) {
        //
        // User didn't specify file name. Use *.* as default
        //
        FullFileNameString = NULL;
        if( !_FullFileNamePath.Initialize( (LPWSTR)L"*.*", TRUE ) ) {
            DebugPrint( "_FullFileNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    } else {
        //
        // Get name specified in the command line
        //
        FullFileNameString = _FileNameArgument.GetPath()->GetPathString();
        DebugPtrAssert( FullFileNameString );
        if( !_FullFileNamePath.Initialize( FullFileNameString, TRUE ) ) {
            DebugPrint( "_FullFileNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    }

    //
    // Get prefix and verify that it exists
    //
    if( ( DynSubDirectory = _FullFileNamePath.QueryPrefix() ) == NULL ) {
        DebugPrint( "_FullFileNamePath.QueryPrefix() failed \n" );
        return( FALSE );
    }
    if( !DirectoryNamePath.Initialize( DynSubDirectory ) ) {
        DELETE( DynSubDirectory );
        DebugPrint( "DirectoryNamePath.Initialize() failed \n" );
        return( FALSE );
    }
    DELETE( DynSubDirectory );
    //
    //  Have to test if DirectoryNamePath is a drive, and if it is
    //  add \ to it otherwise it won't be able to find a file that is
    //  in the root directory, if the current directory is not the root.
    //
    if( DirectoryNamePath.IsDrive() ) {
        if( !BackSlashString.Initialize( "\\" ) ) {
            DebugPrint( "BackSlashString.Initialize() failed \n" );
            return( FALSE );
        }
        TempPathString = DirectoryNamePath.GetPathString();
        DebugPtrAssert( TempPathString );
        if( !TempPathStringDrive.Initialize( TempPathString ) ) {
            DebugPrint( "TempPathStringDrive.Initialize() failed \n" );
            return( FALSE );
        }
        TempPathStringDrive.Strcat( &BackSlashString );
        if( !PathDrive.Initialize( &TempPathStringDrive ) ) {
            DebugPrint( "PathDrive.Initialize() failed \n" );
            return( FALSE );
        }
        if( !DirectoryNamePath.Initialize( &PathDrive ) ) {
            DebugPrint( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    }

    if( ( _InitialDirectory = SYSTEM::QueryDirectory( &DirectoryNamePath ) ) == NULL ) {
        InvalidName = DirectoryNamePath.GetPathString();
        DebugPtrAssert( InvalidName );
        _Message.Set( MSG_ATTRIB_PATH_NOT_FOUND );
        _Message.Display( "%W", InvalidName );
        return( FALSE );
    }

    //
    // Initialize filter for directories
    //
    if( !_FsnFilterDirectory.Initialize() ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetFileName( "*.*" ) ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetAttributes( FSN_ATTRIBUTE_DIRECTORY ) ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.SetAttributes() failed \n" );
        return( FALSE );
    }

    //
    // Get file name and initialize filter for files
    //
    if( ( DynSubFileName = _FullFileNamePath.QueryName() ) == NULL ) {
        if( _FileNameArgument.IsValueSet() ) {
            InvalidName = _FileNameArgument.GetPath()->GetPathString();
        } else {
            InvalidName = DirectoryNamePath.GetPathString();
        }
        DebugPtrAssert( InvalidName );

        _Message.Set( MSG_ATTRIB_FILE_NOT_FOUND );
        _Message.Display( "%W", InvalidName );
        DELETE( _InitialDirectory );
        return( FALSE );
    }

    //
    //  Determine whether attrib should act on a directory.
    //  It will do so only if the user specify a directory name that does
    //  not contain the characters '*' or '?'.
    //  Also, attrib will not act on directories if the switch /S is specified.
    //
    if( _FlagRecurseDirectories.QueryFlag() ||
        ( FullFileNameString == NULL ) ||
        ( FullFileNameString->Strchr( ( WCHAR )'*' ) != INVALID_CHNUM ) ||
        ( FullFileNameString->Strchr( ( WCHAR )'?' ) != INVALID_CHNUM ) ) {
        ActOnDirectory = _FlagActOnDirectories.QueryFlag();
    } else {
        ActOnDirectory = TRUE;
    }


    if( !_FsnFilterFile.Initialize() ) {
        DELETE( _InitialDirectory );
        DELETE( DynSubFileName );
        DebugPrint( "FsnFilter.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterFile.SetFileName( DynSubFileName ) ) {
        DELETE( _InitialDirectory );
        DELETE( DynSubFileName );
        DebugPrint( "FsnFilter.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !ActOnDirectory ) {
        if( !_FsnFilterFile.SetAttributes( 0, 0, FSN_ATTRIBUTE_DIRECTORY ) ) {
            DELETE( _InitialDirectory );
            DELETE( DynSubFileName );
            DebugPrint( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    } else {
        if( !_FsnFilterFile.SetAttributes( 0, 0, 0 ) ) {
            DELETE( _InitialDirectory );
            DELETE( DynSubFileName );
            DebugPrint( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    }
    DELETE( DynSubFileName );
    if( _FlagDisplayHelp.QueryFlag() ) {
        _Message.Set( MSG_ATTRIB_HELP_MESSAGE );
        _Message.Display( " " );
        return( FALSE );
    }

    _FoundFile = FALSE;
   LexArray.DeleteAllMembers();

   return( TRUE );
}



VOID
ATTRIB::Terminate(
    )

/*++

Routine Description:

    Deletes objects created during initialization.

Arguments:

    None.

Return Value:

    None.


--*/

{
    if( _InitialDirectory != NULL ) {
        DELETE( _InitialDirectory );
    }
}



VOID
ATTRIB::DisplayFileNotFoundMessage(
    )

/*++

Routine Description:

    Displays a message indicating that no file that meets the file filter
    criteria was found.

Arguments:

    None.

Return Value:

    None.


--*/

{
    PCWSTRING   FileName;

    if( !_FoundFile ) {
        if( _FileNameArgument.IsValueSet() ) {
            FileName = _FileNameArgument.GetPath()->GetPathString();
        } else {
            FileName = _FullFileNamePath.GetPathString();
        }
        DebugPtrAssert( FileName );

        _Message.Set( MSG_ATTRIB_FILE_NOT_FOUND );
        _Message.Display( "%W", FileName );
    }
}



VOID
ATTRIB::DisplayFileAttribute (
    IN PCFSNODE Fsn
    )

/*++

Routine Description:

    Displays a filename and its attributes

Arguments:

    Fsn - A pointer to an FSNODE that contains the information
          about the file.

Return Value:

    None.

--*/


{
//  PCWC_STRING pcWcString;
    PCWSTRING   pcWcString;

    WCHAR       Buffer[ 12 ];
    DSTRING     String;

    DebugPtrAssert( Fsn );
    DebugPtrAssert( Fsn->GetPath( ));
    pcWcString = ( Fsn->GetPath( ))->GetPathString( );
    DebugPtrAssert( pcWcString );


    swprintf( Buffer,
              ( LPWSTR )L"%lc  %lc%lc%lc     ",
              Fsn->IsArchived() ? ( WCHAR )'A' : ( WCHAR )' ',
              Fsn->IsSystem()   ? ( WCHAR )'S' : ( WCHAR )' ',
              Fsn->IsHidden()   ? ( WCHAR )'H' : ( WCHAR )' ',
              Fsn->IsReadOnly() ? ( WCHAR )'R' : ( WCHAR )' ' );

    if( !String.Initialize( Buffer ) ||
        !String.Strcat( pcWcString ) ||
        !String.Strcat( &_EndOfLineString ) ||
        !_OutStream->WriteString( &String ) ) {
        DebugPrint( "Unable to display message" );
    }
}


BOOLEAN
ATTRIB::ChangeFileAttributes(
    IN PFSNODE FsnFile
    )

/*++

Routine Description:

    Changes the file attributes. The attributes will be changed depending
    on the argumets specified in the command line, and on the current
    attributes of the file.
    The algorithm for changing attributes is presented below:

    if( ( -s and -h were specified as arguments ) or
        ( -s and +h were specified as arguments ) or
        ( +s and -h were specified as arguments ) or
        ( +s and +h were specified as arguments ) ) {
        Change file attributes;
    } else if ( ( -h and +h were not specified as arguments ) and
                ( file has hidden attribute ) ) {
        print( "Not resetting hidden file: <filename> " );
    } else if ( ( -s and +s were not specified as arguments ) and
                ( file has system attribute ) ) {
        print( "Not resetting system file: <filename> " );
    } else {
        Change file attributes;
    }


Arguments:

    FsnFile - A pointer to an FSNODE that contains the information
              about the file.

Return Value:

    BOOLEAN - Returns FALSE if this function fails due to a failure
              in an API call.


--*/


{
//    BOOLEAN     Result;
    BOOLEAN     Change;
    DWORD       Win32Error;

//  PCWC_STRING pcWcString;
    PCWSTRING   pcWcString;

    FSN_ATTRIBUTE       Attributes;

    DebugPtrAssert( FsnFile->GetPath( ));
    pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
    DebugPtrAssert( pcWcString );

    if( ( ( _FlagAddSystemAttribute.QueryFlag() ||
            _FlagRemoveSystemAttribute.QueryFlag() ) &&
          ( _FlagAddHiddenAttribute.QueryFlag() ||
            _FlagRemoveHiddenAttribute.QueryFlag() ) ) ) {
            Change = TRUE;
    } else if( !_FlagAddHiddenAttribute.QueryFlag() &&
               !_FlagRemoveHiddenAttribute.QueryFlag() &&
               FsnFile->IsHidden() ) {
//        DebugPtrAssert( FsnFile->GetPath( ));
//        pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
//        DebugPtrAssert( pcWcString );
        _Message.Set( MSG_ATTRIB_NOT_RESETTING_HIDDEN_FILE );
        _Message.Display( "%W", pcWcString );
        Change = FALSE;
    } else if( !_FlagAddSystemAttribute.QueryFlag() &&
               !_FlagRemoveSystemAttribute.QueryFlag() &&
               FsnFile->IsSystem() ) {
//        DebugPtrAssert( FsnFile->GetPath( ));
//        pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
//        DebugPtrAssert( pcWcString );
        _Message.Set( MSG_ATTRIB_NOT_RESETTING_SYS_FILE );
        _Message.Display( "%W", pcWcString );
        Change = FALSE;
    } else {
        Change = TRUE;
    }

//    Result = TRUE;
    if( Change ) {
        Attributes = FsnFile->QueryAttributes();
        if( !FsnFile->SetAttributes( ( Attributes & _ResetMask ) | _MakeMask,
                                     &Win32Error ) ) {
            if( Win32Error == ERROR_ACCESS_DENIED ) {
                _Message.Set( MSG_ATTRIB_ACCESS_DENIED );
            } else {
                _Message.Set( MSG_ATTRIB_UNABLE_TO_CHANGE_ATTRIBUTE );
            }
            _Message.Display( "%W", pcWcString );
            DebugPrint( "Unable to change file attribute \n" );
            return( FALSE );
        }
    }
    return( TRUE );
}



BOOLEAN
ATTRIB::ExamineFiles(
    IN  PFSN_DIRECTORY  Directory
    )

/*++

Routine Description:

    Builds an array of files in the specified directory, and
    tries to change the attributes of each of these files.
    Does the same thing in all subdirectories, if the "recurse"
    flag was specified in the command line.

Arguments:

    Directory - Pointer to an FSN_DIRECTORY that describes the
                directory to be examined

Return Value:

    Boolean: TRUE if Successful.

--*/

{
    PARRAY              DirectoryArray;
    PFSN_DIRECTORY      FsnDirectory;
    PARRAY_ITERATOR     DirectoryArrayIterator;
    PARRAY              FileArray;
    PARRAY_ITERATOR     FileArrayIterator;
    PFSNODE             FsnFile;


    DebugPtrAssert( Directory );
    //
    //  If /S was specified as argument in the command line, builds
    //  an array of PFSN_DIRECTORY of all sub-directories in the current
    //  directory and examines the files in each sub-directory
    //
    if( _FlagRecurseDirectories.QueryFlag() ) {
        if( ( DirectoryArray = Directory->QueryFsnodeArray( &_FsnFilterDirectory ) ) == NULL ) {
            DebugPrint( "Directory->QueryFsnodeArray( &_FsnFilterDirectory ) failed \n" );
            return( FALSE );
        }
        if( ( DirectoryArrayIterator =
                ( PARRAY_ITERATOR )( DirectoryArray->QueryIterator() ) ) == NULL ) {
            DebugPrint( "DirectoryArray->QueryIterator() failed \n" );
            return( FALSE );
        }

        while( ( FsnDirectory = ( PFSN_DIRECTORY )( DirectoryArrayIterator->GetNext( ) ) ) != NULL ) {
                ExamineFiles( FsnDirectory );
                DELETE( FsnDirectory );
        }

        DELETE( DirectoryArrayIterator );
        DELETE( DirectoryArray );
    }

    //
    // Builds an array of FSNODEs of the files tha meet the 'filter'
    // criteria, and change or display the attributes of these files
    //
    if( ( FileArray = Directory->QueryFsnodeArray( &_FsnFilterFile ) ) == NULL ) {
        DebugPrint( "Directory->QueryFsnodeArray( &_FsnFilterFile ) failed \n" );
        return( FALSE );
    }
    if( ( FileArrayIterator =
            ( PARRAY_ITERATOR )( FileArray->QueryIterator() ) ) == NULL ) {
        DebugPrint( "FileArray->QueryIterator() failed \n" );
        return( FALSE );
    }

    while( ( FsnFile = ( PFSNODE )( FileArrayIterator->GetNext( ) ) ) != NULL ) {
        if( _PrintAttribInfo ) {
            DisplayFileAttribute( FsnFile );
        } else {
            ChangeFileAttributes( FsnFile );
        }

        _FoundFile = TRUE;

        DELETE( FsnFile );
    }
    DELETE( FileArrayIterator );
    DELETE( FileArray );
    return( TRUE );
}



ULONG __cdecl
main()

{
    DEFINE_CLASS_DESCRIPTOR( ATTRIB );

    {
        ATTRIB  Attrib;

        if( Attrib.Initialize() ) {
            Attrib.ExamineFiles( Attrib.GetInitialDirectory() );
            Attrib.DisplayFileNotFoundMessage();
        }
        Attrib.Terminate();
    }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\attrib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=attrib

TARGETNAME=attrib
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\attrib.cxx ..\attrib.rc

INCLUDES=..\.;..\..\ulib\inc;

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autochk\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

NT_UP=0

MAJORCOMP=utils
MINORCOMP=autochk

TARGETNAME=autochk
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\autochk.cxx \
    ..\autochk.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src;\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT);\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O);\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1

!IF defined(CHKDSK_PRE_RELEASE_NOTICE)
C_DEFINES=$(C_DEFINES) /DPRE_RELEASE_NOTICE
!ENDIF

TARGETLIBS=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib   \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt
USE_NTDLL=1
W32_SB=1
SOURCES_USED=..\sources.inc

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\asr_fmt\inc\dr_state.h ===
#ifndef _INC_ASR_FMT__DR_STATE_H_
#define _INC_ASR_FMT__DR_STATE_H_

#define ASRFMT_WSZ_DOS_DEVICES_PREFIX L"\\DosDevices\\"
#define ASRFMT_CB_DOS_DEVICES_PREFIX 24
#define ASRFMT_LOOKS_LIKE_DOS_DEVICE(name, length) \
               ((length > ASRFMT_CB_DOS_DEVICES_PREFIX) && \
               (!memcmp(name, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)))

#define ASRFMT_WSZ_VOLUME_GUID_PREFIX L"\\??\\Volume{"
#define ASRFMT_CB_VOLUME_GUID_PREFIX 22
#define ASRFMT_LOOKS_LIKE_VOLUME_GUID(name, length) \
              ((length > ASRFMT_CB_VOLUME_GUID_PREFIX) && \
              (!memcmp(name, ASRFMT_WSZ_VOLUME_GUID_PREFIX, ASRFMT_CB_VOLUME_GUID_PREFIX)))

#define ASRFMT_CCH_VOLUME_GUID 64
#define ASRFMT_CCH_DOS_PATH 1024
#define ASRFMT_CCH_FS_NAME 16
#define ASRFMT_CCH_VOLUME_LABEL 256
#define ASRFMT_CCH_DEVICE_PATH 1024

      
typedef struct _ASRFMT_VOLUME_INFO {

    struct _ASRFMT_VOLUME_INFO *pNext;

    DWORD   dwIndex;

    WCHAR   szGuid[ASRFMT_CCH_VOLUME_GUID];

    WCHAR   szDosPath[ASRFMT_CCH_DOS_PATH];

    WCHAR   szFsName[ASRFMT_CCH_FS_NAME];

    WCHAR   szLabel[ASRFMT_CCH_VOLUME_LABEL];

    DWORD   dwClusterSize;

    BOOL    IsDosPathAssigned;  

} ASRFMT_VOLUME_INFO, *PASRFMT_VOLUME_INFO;



typedef struct _ASRFMT_REMOVABLE_MEDIA_INFO {

    struct _ASRFMT_REMOVABLE_MEDIA_INFO *pNext;

    DWORD   dwIndex;

    WCHAR   szDevicePath[ASRFMT_CCH_DEVICE_PATH];

    WCHAR   szVolumeGuid[ASRFMT_CCH_VOLUME_GUID];

    WCHAR   szDosPath[ASRFMT_CCH_DOS_PATH];

} ASRFMT_REMOVABLE_MEDIA_INFO, *PASRFMT_REMOVABLE_MEDIA_INFO;


typedef struct _ASRFMT_STATE_INFO {

    PASRFMT_VOLUME_INFO pVolume;

    DWORD   countVolume;

    PASRFMT_REMOVABLE_MEDIA_INFO pRemovableMedia;

    DWORD   countMedia;

} ASRFMT_STATE_INFO, *PASRFMT_STATE_INFO;



typedef enum __AsrfmtpMessageSeverity {
    _SeverityInfo = 0,
    _SeverityWarning,
    _SeverityError
} _AsrfmtpMessageSeverity;

// Public functions

//
// From format.cpp
//

extern BOOL g_bFormatInProgress;
extern BOOL g_bFormatSuccessful;
extern INT  g_iFormatPercentComplete;


BOOL
FormatInitialise();

BOOL
IsFsTypeOkay(
    IN PASRFMT_VOLUME_INFO pVolume,
    OUT PBOOL pIsLabelIntact
    );

BOOL
IsVolumeIntact(
    IN PASRFMT_VOLUME_INFO pVolume
    );

BOOL
FormatVolume(
    PASRFMT_VOLUME_INFO pVolume
    );

BOOL
FormatCleanup();

VOID
MountFileSystem(
    IN PASRFMT_VOLUME_INFO pVolume
    );

//
// dr_state.cpp
//
BOOL
BuildStateInfo(
    IN PASRFMT_STATE_INFO pState
    );

VOID
FreeStateInfo(
    IN OUT PASRFMT_STATE_INFO *ppState
    );

BOOL
ReadStateInfo( 
    IN PCWSTR lpwszFilePath,
    OUT PASRFMT_STATE_INFO *ppState
    );

BOOL
SetDosName(
    IN PWSTR lpVolumeGuid,
    IN PWSTR lpDosPath
    );

BOOL
SetRemovableMediaGuid(
    IN PWSTR lpDeviceName,
    IN PWSTR lpGuid
    );

BOOL
WriteStateInfo( 
    IN DWORD_PTR AsrContext,        // AsrContext to pass in to AsrAddSifEntry
    IN PASRFMT_STATE_INFO pState    // data to write.
    );


//
// Functions for logging error messages
//
VOID
AsrfmtpInitialiseErrorFile();

VOID
AsrfmtpCloseErrorFile();

VOID
AsrfmtpLogErrorMessage(
    IN _AsrfmtpMessageSeverity Severity,
    IN const LPCTSTR Message
    );



#endif // ifndef _INC_ASR_FMT__DR_STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autochk\autochk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autochk.cxx

Abstract:

    This is the main program for the autocheck version of chkdsk.

Author:

    Norbert P. Kusters (norbertk) 31-May-91

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "fatvol.hxx"
#include "untfs.hxx"
#include "ntfsvol.hxx"
#include "spackmsg.hxx"
#include "tmackmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "rcache.hxx"
#include "autoreg.hxx"
#include "ifsserv.hxx"
#include "mpmap.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif

#define CONTROL_NAME        \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
#define VALUE_NAME          L"SystemStartOptions"
#define VALUE_BUFFER_SIZE   \
    (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))

BOOLEAN
RegistrySosOption(
    );

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     USHORT           Algorithm,
    IN     INT              ArgCount,
    IN     CHAR             **ArgArray,
    IN     PARRAY           SkipList,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    );

BOOLEAN
ExtendNtfsVolume(
    PCWSTRING   DriveName,
    PMESSAGE    Message
    );

BOOLEAN
DeregisterAutochk(
    int     argc,
    char**  argv
    );

BOOLEAN
QueryAllHardDrives(
    PMOUNT_POINT_MAP    MountPointMap
    );

BOOLEAN
IsGuidVolName (
    PWSTRING    VolName
    );


int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG   DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for autocheck FAT chkdsk.

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                    the drive to check.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL ) ||
        !InitializeIfsUtil(NULL,0,NULL) ||
        !InitializeUfat(NULL,0,NULL) ||
        !InitializeUntfs(NULL,0,NULL)) {
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    InitializeMachineId();
#endif

    //
    // The declarations must come after these initialization functions.
    //
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             drive_letter;

    ARRAY               skip_list;

    AUTOCHECK_MESSAGE   *msg = NULL;

    BOOLEAN             onlyifdirty = TRUE;
    BOOLEAN             recover = FALSE;
    BOOLEAN             extend = FALSE;
    BOOLEAN             remove_registry = FALSE;

    ULONG               ArgOffset = 1;

    BOOLEAN             SetupOutput = FALSE;
    BOOLEAN             SetupTextMode = FALSE;
    BOOLEAN             SetupSpecialFixLevel = FALSE;

    ULONG               exit_status = 0;

    BOOLEAN             SuppressOutput = TRUE;      // dots only by default

    BOOLEAN             all_drives = FALSE;
    BOOLEAN             resize_logfile = FALSE;
    BOOLEAN             skip_index_scan = FALSE;
    BOOLEAN             skip_cycle_scan = FALSE;
    LONG                logfile_size = 0;
    LONG                algorithm = 0;
    BOOLEAN             algorithm_specified = FALSE;

    MOUNT_POINT_MAP     mount_point_map;
    ULONG               i;
    USHORT              rtncode;
    ULONG               chkdsk_flags;

    DSTRING             nt_name_prefix;
    DSTRING             dos_guidname_prefix;

    if (!drive_letter.Initialize() ||
        !volume_name.Initialize() ||
        !nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX) ||
        !skip_list.Initialize()) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));
        return 1;
    }

    // Parse the arguments--the accepted arguments are:
    //
    //      autochk [/s] [/dx:] [/p] [/r] [/m] [/i[:chunks]] [/c] nt-drive-name
    //      autochk      [/dx:] [/p] [/r] [/m] [/i[:chunks]] [/c] [/l:size] nt-drive-name
    //      autochk [/s] /x dos-drive-name (obsolete in NT 5.0)
    //      autochk [/k:drives] [/k:volname] ... *
    //
    //      /t - setup text mode: selectively output messages thru Ioctl
    //      /s - setup: no output
    //      /d - the drive letter is x: (obsolete)
    //      /p - check even if not dirty
    //      /r - recover; implies /p
    //      /l - resize log file to <size> kilobytes.  May not be combined with
    //              /s because /s explicitly inhibits logfile resizing.
    //      /x - extend volume; obsolete in NT 5.0
    //      /k - a list of drive letters or a guid volume name to skip
    //      /m - remove registry entry after running
    //      /e - turn on the volume upgrade bit; obsolete in NT 5.0
    //      /i - include index entries checking; implies /p
    //      /c - include checking of cycles within the directory tree; implies /p
    //      /i:chunks
    //         - does the index scan in <chunks> chunks; implies /p
    //

    //*****
    // Delete the following if when building a normal CONSOLE version for test
    //
    if (argc < 2) {
        // Not enough arguments.
        return 1;
    }

    for (ArgOffset = 1; ArgOffset < (ULONG)argc; ++ArgOffset) {

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 't' || argv[ArgOffset][1] == 'T') &&
            (argv[ArgOffset][2] == 0) ) {
            //
            // Then we're in silent mode plus I/O to setup
            //
            SetupTextMode = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 's' || argv[ArgOffset][1] == 'S') &&
            (argv[ArgOffset][2] == 0) ) {
            //
            // Then we're in silent mode
            //
            SetupOutput = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'p' || argv[ArgOffset][1] == 'P') &&
            (argv[ArgOffset][2] == 0) ) {

            // argv[ArgOffset] is the /p parameter, so argv[ArgOffset+1]
            // must be the drive.

            onlyifdirty = FALSE;

            continue;
        }
        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'r' || argv[ArgOffset][1] == 'R') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /p.
            //
            recover = TRUE;
            onlyifdirty = FALSE;
            continue;

        }
        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'x' || argv[ArgOffset][1] == 'X') &&
            (argv[ArgOffset][2] == 0) ) {

           // when the /x parameter is specified, we accept a
           // DOS name and do a complete check.
           //
           onlyifdirty = FALSE;
           extend = TRUE;

           if( !dos_drive_name.Initialize( argv[ArgOffset + 1] ) ||
               !IFS_SYSTEM::DosDriveNameToNtDriveName( &dos_drive_name,
                                                       &volume_name ) ) {

               return 1;
           }

           ArgOffset++;
           continue;

        }
#if 0
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'd' || argv[ArgOffset][1] == 'D')) {

            //
            // A parameter of the form "/dX:" indicates that we are checking
            // the volume whose drive letter is X:.
            //

            if (!drive_letter.Initialize(&argv[ArgOffset][2])) {
                return 1;
            }

            continue;

        }
#endif
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'l' || argv[ArgOffset][1] == 'L')) {

            DSTRING number;

            // The /l parameter indicates that we're to resize the log file.
            // The size should always be specified, and it is in kilobytes.
            //

            resize_logfile = TRUE;

            if (!number.Initialize(&argv[ArgOffset][3]) ||
                !number.QueryNumber(&logfile_size) ||
                logfile_size < 0) {
                return 1;
            }

            logfile_size *= 1024;

            continue;

        }
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'k' || argv[ArgOffset][1] == 'K')) {

            // Skip.

            PWSTRING    s;
            DSTRING     drive;
            DSTRING     colon;


            if (!drive.Initialize(&argv[ArgOffset][3]) ||
                !colon.Initialize(L":")) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory\n"));
                return 1;
            }

            if (drive.Stricmp(&dos_guidname_prefix,
                              0,
                              dos_guidname_prefix.QueryChCount()) == 0) {

                // just a dos guid volume name, so store it

                s = drive.QueryString();

                if (!s ||
                    !skip_list.Put(s)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory\n"));

                    return 1;
                }
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: guid name /k:%S\n",
                           s->GetWSTR()));
#endif
                continue;
            }

            // handle a list of dos drive names by inserting them
            // individually into the skip list

            while (drive.QueryChCount() != 0) {

                s = drive.QueryString(0, 1);

                if (!s ||
                    !s->Strcat(&colon) ||
                    !skip_list.Put(s)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory\n"));

                    return 1;
                }
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: drive letter /k:%S\n",
                           s->GetWSTR()));
#endif
                drive.DeleteChAt(0);
            }
            continue;
        }
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'm' || argv[ArgOffset][1] == 'M')) {

            remove_registry = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'i' || argv[ArgOffset][1] == 'I')) {

            DSTRING     number;

            if (argv[ArgOffset][2] == ':') {
                if (skip_index_scan || algorithm_specified ||
                    !number.Initialize(&argv[ArgOffset][3]) ||
                    !number.QueryNumber(&algorithm) ||
                    algorithm < 0 || algorithm > CHKDSK_MAX_ALGORITHM_VALUE) {
                    return 1;
                }
                algorithm_specified = TRUE;
                onlyifdirty = FALSE;
            } else if (algorithm_specified) {
                return 1;
            } else {
                skip_index_scan = TRUE;
                onlyifdirty = FALSE;
            }

            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'c' || argv[ArgOffset][1] == 'C')) {

            skip_cycle_scan = TRUE;
            onlyifdirty = FALSE;
            continue;
        }

        if ((argv[ArgOffset][0] != '/' && argv[ArgOffset][0] != '-')) {

            //  We've run off the options into the arguments.

            break;
        }
    }

    // argv[ArgOffset] is the drive;

    if (NULL != argv[ArgOffset]) {
        if ('*' == argv[ArgOffset][0]) {

            all_drives = TRUE;

        } else {

            all_drives = FALSE;

            //*****
            //
            // Substitute the following 3 lines for the next line to enable going
            //    AUTOCHK C: like for CHKDSK (when building a normal CONSOLE version for test)
            //
            // if ( !dos_drive_name.Initialize( argv[ArgOffset] ) ||
            //      !IFS_SYSTEM::DosDriveNameToNtDriveName( &dos_drive_name,
            //                                              &volume_name ) ) {
            //******
            if (!volume_name.Initialize(argv[ArgOffset])) {
            //******
                return 1;
            }
        }
    }

    //
    // Determine whether to suppress output or not.  If compiled with
    // DBG==1, print normal output.  Otherwise look in the registry to
    // see if the machine has "SOS" in the NTLOADOPTIONS.
    //
#if defined(_AUTOCHECK_DBG_)

    SuppressOutput = FALSE;

#else /* _AUTOCHECK_DBG */

    if (RegistrySosOption()) {
        SuppressOutput = FALSE;
    }

#endif /* _AUTOCHECK_DBG_ */

    //
    // If this is autochk /r, /l, /i, /c, we've been started from an explicit
    // registry entry and the dirty bit may not be set.  We want to
    // deliver interesting output regardless.
    //

    if (recover || resize_logfile || algorithm_specified ||
        skip_index_scan || skip_cycle_scan) {
        SuppressOutput = FALSE;
    }

    if (extend) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Option /x is no longer supported.\n"));
        return 1;
    }

    if (all_drives && (extend || SetupTextMode || SetupOutput)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Conflicting options that * and [xst] cannot be used at the same time.\n"));
        return 1;
    }

    if (SetupTextMode) {
        msg = NEW TM_AUTOCHECK_MESSAGE;
    } else if (SetupOutput) {
        msg = NEW SP_AUTOCHECK_MESSAGE;
    } else {
        msg = NEW AUTOCHECK_MESSAGE;
    }

    if (NULL == msg || !msg->Initialize(SuppressOutput)) {
        return 1;
    }

#if defined(PRE_RELEASE_NOTICE)
    msg->Set(MSG_CHK_PRE_RELEASE_NOTICE);
    msg->Display();
#endif

#if defined(_AUTOCHECK_DBG_)
    for(ArgOffset=1; ArgOffset < (ULONG)argc; ArgOffset++) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Argument: %s\n",
                   argv[ArgOffset]));
    }

    if (all_drives)
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: All drives\n"));
    else
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Not all drives\n"));
#endif

    if (!QueryAllHardDrives(&mount_point_map)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Unable to query all hard drives\n"));

        return 1;
    }

    if (skip_list.QueryMemberCount() > 0) {

        // convert all drive names to nt guid volume names

        DSTRING         drive_name;
        PWSTRING        drive;
        PARRAY_ITERATOR iter;

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Skip list has %d elements.\n",
                   skip_list.QueryMemberCount()));
#endif
        iter = (PARRAY_ITERATOR)skip_list.QueryIterator();

        if (iter == NULL)
            return 1;

        while (drive = (PWSTRING)iter->GetNext()) {
#if 0
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Skip list input: %S.\n",
                       drive->GetWSTR()));
#endif
            if (drive->QueryChCount() == 2) {
                if (!mount_point_map.QueryVolumeName(drive, &drive_name)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "AUTOCHK: Drive %S not recognized.\n",
                               drive->GetWSTR()));

                    continue;
                }
            } else {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(drive, &drive_name)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "AUTOCHK: Drive %S not recognized.\n",
                               drive->GetWSTR()));

                    continue;
                }
            }
#if 0
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Skip list: %S.\n",
                       drive_name.GetWSTR()));
#endif
            if (!drive->Initialize(&drive_name)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));

                DELETE(iter);
                return 1;
            }
        }
        DELETE(iter);
    }

    if (!all_drives &&
        drive_letter.QueryChCount() == 0) {

        // if drive letter is not specified

        if (volume_name.QueryChCount() == (nt_name_prefix.QueryChCount()+2) &&
            volume_name.Strcmp(&nt_name_prefix,
                               0,
                               nt_name_prefix.QueryChCount()) == 0) {

            // looks like \??\<drive letter>: format
            // so, exact drive letter from volume_name

            if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&volume_name, &drive_letter)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));
                return 1;
            }
            DebugAssert(drive_letter.QueryChCount() == 2  &&
                        drive_letter.QueryChAt(1) == (WCHAR)':');
            if (!mount_point_map.QueryVolumeName(&drive_letter, &volume_name)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Drive %S not found.\n",
                           drive_letter.GetWSTR()));

                return 1;
            }
        } else if (IsGuidVolName(&volume_name)) {

            // looks like a guid volume name
            // so look it up from the mount point map

            if (!mount_point_map.QueryDriveName(&volume_name, &drive_letter)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Drive %S not found.\n",
                           volume_name.GetWSTR()));

                return 1;
            }
            // drive_letter may still be empty
            // treat it as if there is no drive letter
            // during the "autocheck autochk *" case
        } else {
            // the volume name does not fit into any format
            // make drive letter the same as volume name
            if (!drive_letter.Initialize(&volume_name))
                return 1;
        }
    }

    // at this point, volume_name should contain an nt guid volume name

    chkdsk_flags = (onlyifdirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    chkdsk_flags |= ((recover || extend) ? CHKDSK_RECOVER_FREE_SPACE : 0);
    chkdsk_flags |= (recover ? CHKDSK_RECOVER_ALLOC_SPACE : 0);
    chkdsk_flags |= (resize_logfile ? CHKDSK_RESIZE_LOGFILE : 0);
    chkdsk_flags |= (skip_index_scan ? CHKDSK_SKIP_INDEX_SCAN : 0);
    chkdsk_flags |= (skip_cycle_scan ? CHKDSK_SKIP_CYCLE_SCAN : 0);
    chkdsk_flags |= (algorithm_specified ? CHKDSK_ALGORITHM_SPECIFIED : 0);

    for (i = 0;;) {

        if (all_drives && !mount_point_map.GetAt(i++, &drive_letter, &volume_name))
            break;

        __try {
            rtncode = InvokeAutoChk(&drive_letter,
                                    &volume_name,
                                    chkdsk_flags,
                                    remove_registry,
                                    SetupOutput || SetupTextMode,
                                    extend,
                                    logfile_size,
                                    (USHORT)algorithm,
                                    argc,
                                    argv,
                                    &skip_list,
                                    msg,
                                    &exit_status);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rtncode = 2;
            exit_status = CHKDSK_EXIT_COULD_NOT_FIX;
        }

        if (all_drives) {
            if (rtncode == 1) {
                // serious error return immediately
                return 1;
            } else if (rtncode == 2 || rtncode == 0) {
                // volume specific error or no error
                // re-initialize and continue
                if (!msg->Initialize(SuppressOutput))
                    return 1;
                continue;
            } else {
                // illegal return code
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Illegal return code %d\n",
                           (ULONG)rtncode));

                return 1;
            }
        } else {
            if (SetupOutput || SetupTextMode) {
                SetupSpecialFixLevel = TRUE;
            }
            if (rtncode == 1) {
                // serious error return immediately
                return SetupSpecialFixLevel ? CHKDSK_EXIT_COULD_NOT_FIX : 1;
            } else if (rtncode == 2 || rtncode == 0) {
                // volume specific error or no error
                // leave anyway
                break;
            } else {
                // illegal return code
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Illegal return code %d\n",
                           (ULONG)rtncode));

                return SetupSpecialFixLevel ? CHKDSK_EXIT_COULD_NOT_FIX : 1;
            }
        }
    }

    msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
    msg->Display();

    DELETE(msg);

    // If the /x switch was supplied, remove the
    // forcing entry from the registry, since Chkdsk
    // has completed successfully.
    //

    if (extend) {
        DeregisterAutochk( argc, argv );
    }

    if (SetupSpecialFixLevel) {
#if defined(_AUTOCHECK_DBG_)
        if (exit_status != CHKDSK_EXIT_SUCCESS) {
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Exit Status %d\n",
                       exit_status));
        }
#endif
        return exit_status;
    } else {
        return 0;
    }
}

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     USHORT           Algorithm,
    IN     INT              ArgCount,
    IN     CHAR             **ArgArray,
    IN     PARRAY           SkipList,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    )
/*++

Routine Description:

    This is the core of autochk.  It checks the specified drive.

Arguments:

    DriveLetter     - Supplies the drive letter of the drive
                      (can be empty string)
    VolumeName      - Supplies the guid volume name of the drive
    ChkdskFlags     - Supplies the chkdsk control flags
    RemoveRegistry  - Supplies TRUE if registry entry is to be removed
    SetupMode       - Supplies TRUE if invoked through setup
    Extend          - Supplies TRUE if extending the volume (obsolete)
    LogfileSize     - Supplies the size of the logfile
    Algorithm       - Supplies the algorithm to use
    ArgCount        - Supplies the number of arguments given to autochk.
    ArgArray        - Supplies the arguments given to autochk.
    SkipList        - Supplies the list of drives to skip checking
    Msg             - Supplies the outlet of messages
    ExitStatus      - Retrieves the exit status of chkdsk

Return Value:

    0   - Success
    1   - Fatal error
    2   - Volume specific error

--*/
{
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;

    PFAT_VOL            fatvol = NULL;
    PNTFS_VOL           ntfsvol = NULL;
    PVOL_LIODPDRV       vol = NULL;

    BOOLEAN             SetupSpecialFixLevel = FALSE;

    PREAD_CACHE         read_cache;

    DSTRING             boot_execute_log_file_name;
    FSTRING             boot_ex_temp;
    HMEM                logged_message_mem;
    ULONG               packed_log_length;

    DSTRING             fatname;
    DSTRING             fat32name;
    DSTRING             ntfsname;
    DSTRING             nt_name_prefix;
    DSTRING             dos_guidname_prefix;

    BOOLEAN             isDirty;
    BOOLEAN             skip_autochk = FALSE;

    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    if (!fatname.Initialize("FAT") ||
        !fat32name.Initialize("FAT32") ||
        !ntfsname.Initialize("NTFS") ||
        !nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX)) {
        return 1;
    }

    if (VolumeName->QueryChCount() == 0) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Volume name is missing.\n"));

        return 2;   // continue if all_drives are enabled
    }

    if (DriveLetter->QueryChCount() == 0) {
        // unable to map VolumeName to a drive letter so do the default
        if (!IFS_SYSTEM::NtDriveNameToDosDriveName(VolumeName, DriveLetter)) {
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "Out of memory.\n"));

            return 1;
        }
    }

    // at this point DriveLetter and VolumeName should be well defined

#if 0
    Msg->Set(MSG_CHK_NTFS_MESSAGE);
    Msg->Display("%s%W", "Drive Name: ", VolumeName);
    Msg->Display("%s%W", "Drive Letter: ", DriveLetter);
#endif

    if (SkipList->QueryMemberCount() > 0) {

        PARRAY_ITERATOR iter = (PARRAY_ITERATOR)SkipList->QueryIterator();
        PWSTRING        skip_item;

        if (iter == NULL)
            return 1;

        // skip drives that should not be checked

        while (skip_item = (PWSTRING)iter->GetNext()) {
            if (skip_item->Stricmp(VolumeName) == 0) {
                DELETE(iter);
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: Skipping: %S.\n",
                           VolumeName->GetWSTR()));
#endif
                return 0;
            }
        }
        DELETE(iter);
    }

    if ((ChkdskFlags & CHKDSK_CHECK_IF_DIRTY) &&
        !(ChkdskFlags & CHKDSK_RESIZE_LOGFILE) &&
        IFS_SYSTEM::IsVolumeDirty(VolumeName,&isDirty) &&
        !isDirty) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Skipping %S because it's not dirty.\n",
                   VolumeName->GetWSTR()));
        *ExitStatus = CHKDSK_EXIT_SUCCESS;
        skip_autochk = TRUE;
    }

    if (!skip_autochk) {
        if (!IFS_SYSTEM::QueryFileSystemName(VolumeName, &fsname,
                                             NULL, &fsNameAndVersion)) {
            Msg->Set( MSG_FS_NOT_DETERMINED );
            Msg->Display( "%W", VolumeName );

            return 2;
        }
    }

    Msg->SetLoggingEnabled();

    Msg->Set(MSG_CHK_RUNNING);
    Msg->Display("%W", DriveLetter);

    if (!skip_autochk) {
        Msg->Set(MSG_FILE_SYSTEM_TYPE);
        Msg->Display("%W", &fsname);


        if (fsname == fatname || fsname == fat32name) {

            if (!(fatvol = NEW FAT_VOL)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));

                return 1;
            }

            if (NoError != fatvol->Initialize(Msg,
                                              VolumeName,
                                              (BOOLEAN)(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY))) {
                DELETE(fatvol);
                return 2;
            }

            if ((read_cache = NEW READ_CACHE) &&
                read_cache->Initialize(fatvol, 75)) {
                fatvol->SetCache(read_cache);
            } else {
                DELETE(read_cache);
            }

            vol = fatvol;

        } else if (fsname == ntfsname) {

            if( Extend ) {

                // NOTE: this roundabout method is necessary to
                // convince NTFS to allow us to access the new
                // sectors on the volume.
                //
                if( !ExtendNtfsVolume( VolumeName, Msg ) ) {
                    return 1;
                }

                if (!(ntfsvol = NEW NTFS_VOL)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return 1;
                }

                if (NoError != ntfsvol->Initialize( VolumeName, Msg ))
                    return 1;

                if (!ntfsvol->Lock()) {
                    Msg->Set( MSG_CANT_LOCK_THE_DRIVE );
                    Msg->Display( "" );
                }

            } else {

                if (!(ntfsvol = NEW NTFS_VOL)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return 1;
                }

                if (NoError != ntfsvol->Initialize(VolumeName, Msg, TRUE)) {
                    DELETE(ntfsvol);
                    return 2;
                }

                if (SetupMode) {

                    //
                    // SetupSpecialFixLevel will be used for NTFS... it means
                    // to refrain from resizing the log file.
                    //

                    SetupSpecialFixLevel = TRUE;
                }
            }

            // The read cache for NTFS CHKDSK gets set in VerifyAndFix.

            vol = ntfsvol;

        } else {
            Msg->Set( MSG_FS_NOT_SUPPORTED );
            Msg->Display( "%s%W", "AUTOCHK", &fsname );
            return 2;
        }
    } else {
        Msg->SetLoggingEnabled(FALSE);  // no need to log anything if volume is clean
        Msg->DisplayMsg(MSG_CHK_VOLUME_CLEAN);
    }

    // If the /r, /l, /m, /i, /p, or /c switch is specified, remove the forcing
    // entry from the registry before calling Chkdsk, since
    // Chkdsk may reboot the system if we are checking the
    // boot partition.
    //

    if ((ChkdskFlags & (CHKDSK_RECOVER_ALLOC_SPACE |
                        CHKDSK_RESIZE_LOGFILE |
                        CHKDSK_ALGORITHM_SPECIFIED |
                        CHKDSK_SKIP_INDEX_SCAN |
                        CHKDSK_SKIP_CYCLE_SCAN)) ||
        !(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY) ||
        RemoveRegistry) {

        DeregisterAutochk( ArgCount, ArgArray );
    }

    // Invoke chkdsk.  Note that if the /r parameter is supplied,
    // we recover both free and allocated space, but if the /x
    // parameter is supplied, we only recover free space.
    //

    if (!skip_autochk &&
        !vol->ChkDsk(SetupSpecialFixLevel ? SetupSpecial : TotalFix,
                     Msg,
                     ChkdskFlags,
                     LogfileSize,
                     Algorithm,
                     ExitStatus,
                     DriveLetter)) {

        DELETE(vol);

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: ChkDsk failure\n"));

        return 2;
    }

    DELETE(vol);


    // Dump the message retained by the message object into a file.
    //

    if( (!Msg->IsInSetup() ||
         (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
          *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX))         &&
        Msg->IsLoggingEnabled()                              &&
        boot_execute_log_file_name.Initialize( VolumeName )  &&
        boot_ex_temp.Initialize( L"\\BOOTEX.LOG" )           &&
        boot_execute_log_file_name.Strcat( &boot_ex_temp )   &&
        logged_message_mem.Initialize()                      &&
        Msg->QueryPackedLog( &logged_message_mem, &packed_log_length ) ) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Dumping messages to bootex.log\n"));

        if (!IFS_SYSTEM::WriteToFile( &boot_execute_log_file_name,
                                      logged_message_mem.GetBuf(),
                                      packed_log_length,
                                      TRUE )) {
            Msg->Set(MSG_CHK_OUTPUT_LOG_ERROR);
            Msg->Display();
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AUTOCHK: Error writing messages to BOOTEX.LOG\n"));
        }

    }

    return 0;
}


BOOLEAN
RegistrySosOption(
    )
/*++

Routine Description:

    This function examines the registry to determine whether the
    user's NTLOADOPTIONS boot environment variable contains the string
    "SOS" or not.

    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control:SystemStartOptions

Arguments:

    None.

Return Value:

    TRUE if "SOS" was set.  Otherwise FALSE.

--*/
{
    NTSTATUS st;
    UNICODE_STRING uKeyName, uValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey;
    WCHAR ValueBuf[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuf;
    ULONG ValueLength;

    RtlInitUnicodeString(&uKeyName, CONTROL_NAME);
    InitializeObjectAttributes(&ObjectAttributes, &uKeyName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    st = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(st)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: can't open control key: 0x%x\n",
                   st));

        return FALSE;
    }

    RtlInitUnicodeString(&uValueName, VALUE_NAME);

    st = NtQueryValueKey(hKey, &uValueName, KeyValuePartialInformation,
        (PVOID)pKeyValueInfo, VALUE_BUFFER_SIZE, &ValueLength);

    DebugAssert(ValueLength < VALUE_BUFFER_SIZE);

    NtClose(hKey);

    if (!NT_SUCCESS(st)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: can't query value key: 0x%x\n",
                   st));

        return FALSE;
    }

    // uValue.Buffer = (PVOID)&pKeyValueInfo->Data;
    // uValue.Length = uValue.MaximumLength = (USHORT)pKeyValueInfo->DataLength;

    if (NULL != wcsstr((PWCHAR)&pKeyValueInfo->Data, L"SOS") ||
        NULL != wcsstr((PWCHAR)&pKeyValueInfo->Data, L"sos")) {
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
ExtendNtfsVolume(
    PCWSTRING   DriveName,
    PMESSAGE    Message
    )
/*++

Routine Description:

    This function changes the count of sectors in sector
    zero to agree with the drive object.  This is useful
    when extending volume sets.  Note that it requires that
    we be able to lock the volume, and that it should only
    be called if we know that the drive in question in an
    NTFS volume.  This function also copies the boot sector
    to the end of the partition, where it's kept as a backup.

Arguments:

    DriveName   --  Supplies the name of the volume.
    Message     --  Supplies an output channel for messages.

Return Value:

    TRUE upon completion.

--*/
{
    LOG_IO_DP_DRIVE Drive;
    SECRUN          Secrun;
    HMEM            Mem;

    PPACKED_BOOT_SECTOR BootSector;

    if( !Drive.Initialize( DriveName, Message ) ||
        !Drive.Lock() ||
        !Mem.Initialize() ||
        !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
        !Secrun.Read() ) {

        return FALSE;
    }

    BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

    //
    // We leave an extra sector at the end of the volume to contain
    // the new replica boot sector.
    //

    BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart() - 1;
    BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

    if (!Secrun.Write()) {

        return FALSE;
    }

    Secrun.Relocate( Drive.QuerySectors() - 2 );

    if (!Secrun.Write()) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Error: %x\n",
                   Drive.QueryLastNtStatus()));

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DeregisterAutochk(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autochk.

Arguments:

    argc    --  Supplies the number of arguments given to autochk.
    argv    --  supplies the arguments given to autochk.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString,
            CurrentArgString,
            OneSpace;
    int     i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autochk arg1 arg2...".
    //
    if( !CommandLineString.Initialize( "autocheck autochk" ) ||
        !OneSpace.Initialize( " " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize(argv[i] ) ||
            !CommandLineString.Strcat( &OneSpace ) ||
            !CommandLineString.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    return( AUTOREG::DeleteEntry( &CommandLineString ) );
}


BOOLEAN
QueryAllHardDrives(
    PMOUNT_POINT_MAP    MountPointMap
    )
{
    static BOOLEAN      first_time = TRUE;
    static HANDLE       dos_devices_object_dir;
    static ULONG        context = 0;

    WCHAR               link_target_buffer[MAXIMUM_FILENAME_LENGTH];
    POBJECT_DIRECTORY_INFORMATION
                        dir_info;
    OBJECT_ATTRIBUTES   object_attributes;
    CHAR                dir_info_buffer[1024];
    ULONG               length;
    HANDLE              handle;
    BOOLEAN             restart_scan;
    NTSTATUS            status;

    UNICODE_STRING      link_target;
    UNICODE_STRING      link_type_name;
    UNICODE_STRING      link_name;
    UNICODE_STRING      link_target_prefix1;
    UNICODE_STRING      link_target_prefix2;
    UNICODE_STRING      u;

    DSTRING             device_name;
    DSTRING             name;
    DSTRING             nt_name;
    DSTRING             dos_guidname_prefix;

    BOOLEAN             is_guidname;

    DebugPtrAssert(MountPointMap);

    if (!dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));

        return FALSE;
    }

    if (!MountPointMap->Initialize()) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Unable to initialize mount point map.\n"));

        return FALSE;
    }

    link_target.Buffer = link_target_buffer;
    dir_info = (POBJECT_DIRECTORY_INFORMATION)dir_info_buffer;

    RtlInitUnicodeString(&link_type_name, L"SymbolicLink");
    RtlInitUnicodeString(&link_target_prefix1, L"\\Device\\Volume");
    RtlInitUnicodeString(&link_target_prefix2, L"\\Device\\Harddisk");
    RtlInitUnicodeString(&link_name, GUID_VOLNAME_PREFIX);

    restart_scan = TRUE;

    RtlInitUnicodeString(&u, L"\\??");

    InitializeObjectAttributes(&object_attributes, &u,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenDirectoryObject(&dos_devices_object_dir,
                                   DIRECTORY_ALL_ACCESS,
                                   &object_attributes);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Unable to open %wZ directory - Status == %lx\n",
                   &u,
                   status));

        return FALSE;
    }

    for (;;) {

        status = NtQueryDirectoryObject(dos_devices_object_dir,
                                        (PVOID)dir_info,
                                        sizeof(dir_info_buffer),
                                        TRUE,
                                        restart_scan,
                                        &context,
                                        &length);

        if (status == STATUS_NO_MORE_ENTRIES) {

            return TRUE;
        }

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AUTOCHK: NtQueryDirectoryObject failed with %d\n",
                       status));

            return FALSE;
        }

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->TypeName: %wZ\n",
                   &(dir_info->TypeName)));

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->Name: %wZ\n",
                   &(dir_info->Name)));
#endif

        if (RtlEqualUnicodeString(&dir_info->TypeName, &link_type_name, TRUE) &&
            ((is_guidname = RtlPrefixUnicodeString(&link_name, &dir_info->Name, TRUE)) ||
             dir_info->Name.Buffer[(dir_info->Name.Length>>1)-1] == L':')) {

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->TypeName: %wZ\n",
                   &(dir_info->TypeName)));

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->Name: %wZ\n",
                   &(dir_info->Name)));
#endif

            InitializeObjectAttributes(&object_attributes,
                                       &dir_info->Name,
                                       OBJ_CASE_INSENSITIVE,
                                       dos_devices_object_dir,
                                       NULL);

            status = NtOpenSymbolicLinkObject(&handle,
                                              SYMBOLIC_LINK_ALL_ACCESS,
                                              &object_attributes);

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: NtOpenSymbolicLinkObject failed with %d\n",
                           status));

                return FALSE;
            }

            link_target.Length = 0;
            link_target.MaximumLength = sizeof(link_target_buffer);

            status = NtQuerySymbolicLinkObject(handle,
                                               &link_target,
                                               NULL);
            NtClose(handle);

            if (NT_SUCCESS(status) &&
                (RtlPrefixUnicodeString(&link_target_prefix1, &link_target, TRUE) ||
                 RtlPrefixUnicodeString(&link_target_prefix2, &link_target, TRUE))) {

                if (!device_name.Initialize(link_target.Buffer,
                                            link_target.Length / 2) ||
                    !name.Initialize(dir_info->Name.Buffer,
                                     dir_info->Name.Length / 2)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return FALSE;
                }

#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: Device Name: %S\n",
                           device_name.GetWSTR()));
#endif

                if (is_guidname) {
                    if (!name.InsertString(0, &dos_guidname_prefix)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Out of memory.\n"));

                        return FALSE;
                    }
                    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&name, &nt_name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to translate dos drive name to nt drive name.\n"));

                        return FALSE;
                    }
#if 0
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_INFO_LEVEL,
                               "AUTOCHK: Volume Name: %S\n",
                               nt_name.GetWSTR()));
#endif
                    if (!MountPointMap->AddVolumeName(&device_name, &nt_name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to add volume name into mount point map.\n"));

                        return FALSE;
                    }
                } else {
                    DebugAssert(name.QueryChCount() == 2);
#if 0
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_INFO_LEVEL,
                               "AUTOCHK: Drive Name: %S\n",
                               name.GetWSTR()));
#endif
                    if (!MountPointMap->AddDriveName(&device_name, &name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to add drive name into mount point map.\n"));

                        return FALSE;
                    }
                }

            } else if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: NtQuerySymbolicLinkObject failed with %d\n",
                           status));
            }
        }
        restart_scan = FALSE;
    }

    //NOTREACHED
    return FALSE;
}

BOOLEAN
IsGuidVolName (
    PWSTRING    VolName
    )
{
    DSTRING             nt_name_prefix;
    DSTRING             guid_volname_prefix;

    if (!nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !guid_volname_prefix.Initialize(GUID_VOLNAME_PREFIX)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));

        return FALSE;
    }

    if (VolName->QueryChCount() <= nt_name_prefix.QueryChCount())
        return FALSE;

    if (VolName->Stricmp(&nt_name_prefix,
                         0,
                         nt_name_prefix.QueryChCount()) != 0)
        return FALSE;
    if (VolName->Stricmp(&guid_volname_prefix,
                         nt_name_prefix.QueryChCount(),
                         guid_volname_prefix.QueryChCount()) != 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chcp\t_chcp.c ===
#include <stdio.h>
#include <conio.h>

int cdecl main(int argc, char **argv)
{
    int i;
    int j;
    
    printf(
"|    |0- |1- |2- |3- |4- |5- |6- |7- |8- |9- |A- |B- |C- |D- |E- |F- |\n");
    printf(
"|----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n");
    for (i = 0; i < 0x10; i++) {
        printf(
"|    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n");
        printf("| -%.1X |", i);
        for (j = 0; j < 0x10; j++) {
            unsigned char ch = (unsigned char)(j * 0x10 + i);
            if (((7 <= ch) && (ch <= 0xA)) || (ch == 0xD)) {
                printf("   |");
            } else {
                printf(" %.1c |", ch);
            }
        }
        printf("\n");
    }
    printf(
"|    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n");
    printf(
"|____|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chcp\chcp.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    Chcp

Abstract:

    Chcpo is a DOS5-Compatible codepage utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "stream.hxx"
#include "smsg.hxx"
#include "wstring.hxx"
#include "rtmsg.h"
#include "chcp.hxx"
#include <winnlsp.h>


VOID __cdecl
main (
        )

/*++

Routine Description:

    Main function of the Chcp utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
	SetThreadUILanguage(0);
        //
        //      Initialize stuff
        //
    DEFINE_CLASS_DESCRIPTOR( CHCP );

    {
        CHCP Chcp;

        if ( Chcp.Initialize() ) {

            Chcp.Chcp();
        }
    }
}



DEFINE_CONSTRUCTOR( CHCP,  PROGRAM );



CHCP::~CHCP (
        )

/*++

Routine Description:

    Destructs a CHCP object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
}




BOOLEAN
CHCP::Initialize (
        )

/*++

Routine Description:

    Initializes a CHCP object

Arguments:

    None.

Return Value:

    TRUE if initialized.

Notes:

--*/

{
    //
        //      Initialize program object
        //
    if ( PROGRAM::Initialize( MSG_CHCP_USAGE ) &&
         _Screen.Initialize( )

       ) {

        _SetCodePage = FALSE;
        _CodePage    = 0;

        return TRUE;

    }

    return FALSE;
}



BOOLEAN
CHCP::Chcp (
        )

/*++

Routine Description:

    Does the Chcp thing.

Arguments:

    None.

Return Value:

    TRUE.

Notes:

--*/

{
    ValidateVersion();

    if ( ParseArguments() ) {


        if ( _SetCodePage ) {

            //
            //  Set the code page
            //
            if ( !SetCodePage() ) {
                ExitProgram( EXIT_ERROR );
            }

        } else {

            //
            //  Display current code page
            //
            if ( !DisplayCodePage() ) {
                ExitProgram( EXIT_ERROR );
            }
        }

        ExitProgram( EXIT_NORMAL );

    } else {

        ExitProgram( EXIT_ERROR );

    }

    return TRUE;
}




BOOLEAN
CHCP::DisplayCodePage (
        )

/*++

Routine Description:

    Displays the active code page

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{

    DisplayMessage(
        MSG_CHCP_ACTIVE_CODEPAGE,
        NORMAL_MESSAGE, "%d",
        _Screen.QueryCodePage( )
        );

    return TRUE;
}


BOOLEAN
CHCP::ParseArguments (
        )

/*++

Routine Description:

    Parses arguments

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArgArray;

    STRING_ARGUMENT     ProgramNameArgument;
    LONG_ARGUMENT       CodePageArgument;
    FLAG_ARGUMENT       UsageArgument;


    if ( !ArgArray.Initialize()             ||
         !LexArray.Initialize()             ||
         !ArgLex.Initialize( &LexArray )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ProgramNameArgument.Initialize( "*" ) ||
         !UsageArgument.Initialize( "/?" )      ||
         !CodePageArgument.Initialize( "*" )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ArgArray.Put( &ProgramNameArgument ) ||
         !ArgArray.Put( &UsageArgument )       ||
         !ArgArray.Put( &CodePageArgument )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }


    //
    // Set up the defaults
        //
    ArgLex.PutSwitches( "/" );
    ArgLex.SetCaseSensitive( FALSE );


    if ( !ArgLex.PrepareToParse() ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ArgLex.DoParsing( &ArgArray ) ) {

        DisplayMessage( MSG_CHCP_INVALID_PARAMETER, ERROR_MESSAGE, "%W", ArgLex.QueryInvalidArgument() );
        ExitProgram( EXIT_ERROR );

    }


    //
    //  Display Help if requested
    //
    if ( UsageArgument.IsValueSet() ) {

        DisplayMessage( MSG_CHCP_USAGE, NORMAL_MESSAGE );
        ExitProgram( EXIT_NORMAL );

    }

    if ( CodePageArgument.IsValueSet() ) {

        _SetCodePage = TRUE;
        _CodePage    = (DWORD)CodePageArgument.QueryLong();

    } else {

        _SetCodePage = FALSE;
    }

    return TRUE;
}


inline bool IsFarEastCodePage(UINT cp)
{
    return cp == 932 || cp == 949 || cp == 936 || cp == 950;
}

inline bool IsFarEastLocale(LANGID langid)
{
    // Accepts primay langid only
    return langid == LANG_JAPANESE || langid == LANG_KOREAN || langid == LANG_CHINESE;
}

inline bool IsFarEastSystemLocale()
{
    return IsFarEastLocale(PRIMARYLANGID(GetSystemDefaultLangID()));
}

BOOLEAN
CHCP::SetCodePage (
        )

/*++

Routine Description:

    Sets the active code page

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{
    UINT OldCP = _Screen.QueryCodePage( );

    if (IsFarEastSystemLocale() &&
            (IsFarEastCodePage(_CodePage) || IsFarEastCodePage(OldCP)) &&
            _CodePage != OldCP) {
        /*
         * This CLS function is needed only if it's FE.
         */
        _Screen.MoveCursorTo(0, 0);
        _Screen.EraseScreenAndResetAttribute();
    }


    if ( _Screen.SetOutputCodePage( _CodePage ) ) {
        if (_Screen.SetCodePage( _CodePage ) ) {

/*
			// Comment from NT4J:
            // Since FormatMessage checks the current TEB's locale, and the Locale for
            // CHCP is initialized when the message class is initialized, the TEB has to
            // be updated after the code page is changed successfully.  All other code
            // pages other than JP and US are ignored.

            if (IsFarEastSystemLocale()) {
                LANGID LangId;

                switch (_CodePage) {
                case 932:
                    LangId = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
                    break;
                case 949:
                    LangId = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
                    break;
                case 936:
                    LangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
                    break;
                case 950:
                    LangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
                    break;
                default:
                    LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                    break;
                }

                SetThreadLocale(MAKELCID(LangId, SORT_DEFAULT));
            }
*/
			SetThreadUILanguage(0);
			
            return DisplayCodePage( );
        } else {
            // SetOutputCodePage failed.
            // Restore the privous input code page
            _Screen.SetOutputCodePage( OldCP );
        }
    }

    // Was unable to set the given code page
    DisplayMessage( MSG_CHCP_INVALID_CODEPAGE, ERROR_MESSAGE );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chcp\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=chcp
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chcp.cxx ..\chcp.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib \
    $(SDK_LIB_PATH)\kernl32p.lib     

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autoconv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=autoconv

TARGETNAME=autoconv
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\autoconv.cxx \
    ..\autoconv.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O);\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\cufat\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc; \
    $(PROJECT_ROOT)\fs\utils\untfs\inc;

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1
TARGETLIBS=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib   \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt
USE_NTDLL=1

W32_SB=1
SOURCES_USED=..\sources.inc

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autoconv\autoconv.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autoconv.cxx

Abstract:

    This is the main program for the autoconv version of convert.

Author:

    Ramon J. San Andres (ramonsa) 04-Dec-91

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "achkmsg.hxx"
#include "spackmsg.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ifsentry.hxx"
#include "convfat.hxx"
#include "fatvol.hxx"
#include "autoreg.hxx"
#include "autoentr.hxx"
#include "arg.hxx"
#include "rcache.hxx"

#if INCLUDE_OFS==1
#include "fatofs.hxx"
//#include "initexcp.hxx"
#endif  // INCLUDE_OFS

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );


BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    );

BOOLEAN
SaveMessageLog(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   DriveName
    );

BOOLEAN
FileDelete(
    IN  PCWSTRING DriveName,
    IN  PCWSTRING FileName
    );

#if INCLUDE_OFS==1

BOOLEAN
IsRestartFatToOfs( WSTRING const & DriveName,
                   WSTRING const & CurrentFsName,
                   WSTRING const & TargetFileSystem )
{

    DSTRING OfsName;
    DSTRING FatName;


    if ( !OfsName.Initialize( L"OFS" ) )
        return FALSE;

    if ( CurrentFsName != OfsName || TargetFileSystem != OfsName )
        return FALSE;

    PWSTR pwszDriveName = DriveName.QueryWSTR();

    BOOLEAN fIsRestart = IsFatToOfsRestart( pwszDriveName );
    DELETE( pwszDriveName );

    return fIsRestart;
}

BOOLEAN
IsFatToOfs( WSTRING const & CurrentFsName, WSTRING const & TargetFsName )
{
    DSTRING  FatName;
    DSTRING  OfsName;

    if ( !FatName.Initialize( L"FAT" ) )
        return FALSE;

    if ( !OfsName.Initialize( L"OFS" ) )
        return FALSE;

    return  0 == CurrentFsName.Stricmp(&FatName) &&
            0 == TargetFsName.Stricmp(&OfsName);
}

BOOLEAN
FatToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    IN      BOOLEAN             fInSetup,
    OUT     PCONVERT_STATUS     Status )
{

    PWSTR pwszNtDriveName = NtDriveName->QueryWSTR();
    FAT_OFS_CONVERT_STATUS cnvStatus;
    BOOLEAN fResult= ConvertFatToOfs(
                            pwszNtDriveName,
                            Message,
                            Verbose,
                            fInSetup,
                            &cnvStatus );

    DELETE( pwszNtDriveName );

    if ( FAT_OFS_CONVERT_SUCCESS == cnvStatus )
    {
        *Status = CONVERT_STATUS_CONVERTED;
    }
    else
    {
        *Status = CONVERT_STATUS_ERROR;
    }

    return fResult;
}

#else

BOOLEAN
IsRestartFatToOfs( WSTRING const & DriveName, WSTRING const & CurrentFsName,
                   WSTRING const & TargetFileSystem )
{
    return FALSE;
}

BOOLEAN
IsFatToOfs( WSTRING const & CurrentFsName, WSTRING const & TargetFsName )
{
    return FALSE;
}

BOOLEAN
FatToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    IN      BOOLEAN             fInSetup,
    OUT     PCONVERT_STATUS     Status )
{
    *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
    return FALSE;
}

#endif  // INCLUDE_OFS

int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for AutoConv

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autoconv
                  command line is:

    AUTOCONV drive-name /FS:target-file-system [/v] [/s] [/o] [/cvtarea:filename]

        /v -- verbose output
        /s -- run from setup
        /o -- pause before the final reboot (oem setup)
        /cvtarea:filename
           -- convert zone file name
        /nochkdsk
           -- skips chkdsk and go straight to conversion


Return Value:

    0   - Success.
    1   - Failure.

--*/
{

#if INCLUDE_OFS==1
    InitExceptionSystem();
#endif  // INCLUDE_OFS==1

    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)       ||
        !InitializeUntfs(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        DebugPrintTrace(( "Failed to initialize U* Dlls" ));
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    InitializeMachineId();
#endif

    PAUTOCHECK_MESSAGE  message;
    DSTRING             DriveName;
    DSTRING             FileSystemName;
    DSTRING             CvtZoneFileName;
    DSTRING             CurrentFsName;
    DSTRING             FatName;
    DSTRING             Fat32Name;
    DSTRING             QualifiedName;
    FSTRING             Backslash;
    BOOLEAN             Converted;
    BOOLEAN             Verbose = FALSE;
    BOOLEAN             NoChkdsk = FALSE;
    BOOLEAN             NoSecurity = FALSE;
    BOOLEAN             Error;
    CONVERT_STATUS      Status;
    int                 i;
    BOOLEAN             fInSetup = FALSE;
    BOOLEAN             Pause = FALSE;

    LARGE_INTEGER       DelayInterval;

    DSTRING             StrippedDriveName;
    BOOLEAN             enabled;
    NTSTATUS            status;
    UNICODE_STRING      driverName;
    ULONG               flags;

    status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &enabled);

    RtlInitUnicodeString( &driverName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Ntfs" );
    status = NtLoadDriver( &driverName );

    status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, enabled, FALSE, &enabled);

    DebugPrintTrace(( "Entering autoconv argc=%ld\n", argc ));
    for ( i = 0; i < argc; i++ )
    {
        DebugPrintTrace((" argv[%d] = %s\n", i, argv[i] ));
    }

    //
    //  Parse the arguments. The accepted arguments are:
    //
    //  autoconv NtDrive /fs:<filesystem> [/v]
    //

    if ( argc < 3 ) {
        return 1;
    }

    //
    //  First argument is drive
    //
    if ( !DriveName.Initialize( argv[1] ) ||
         !StrippedDriveName.Initialize( argv[1] ) ) {
        DebugPrintTrace(( "Failed to intialize DriveName \n" ));
        return 1;
    }

    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&DriveName, &StrippedDriveName)) {
        if (!StrippedDriveName.Initialize(&DriveName)) {
            DebugPrint( "Out of memory.\n" );
            return 1;
        }
    }

    DebugPrintTrace(("drive name: %ws\n", StrippedDriveName.GetWSTR()));

    //
    //  The rest of the arguments are flags.
    //
    for ( i = 2; i < argc; i++ ) {

        if ( (strlen(argv[i]) >= 5)                         &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'f' || argv[i][1] == 'F')       &&
             (argv[i][2] == 's' || argv[i][2] == 'S')       &&
             (argv[i][3] == ':') ) {

            if ( 0 != FileSystemName.QueryChCount() ||
                 !FileSystemName.Initialize( &(argv[i][4]) ) )
            {
                DebugPrintTrace(( "Failed to initialize FileSystemName \n" ));
                return 1;
            }
        }

        if (0 == _stricmp( argv[i], "/V" ) || 0 == _stricmp( argv[i], "-V" )) {
            Verbose = TRUE;
        }

        if (0 == _stricmp(argv[i], "/S") || 0 == _stricmp(argv[i], "-S")) {
            DebugPrintTrace(("Found /s option\n"));
            fInSetup = TRUE;
        }

        if (0 == _stricmp(argv[i], "/O") || 0 == _stricmp(argv[i], "-O")) {
            DebugPrintTrace(("Found /o option\n"));
            Pause = TRUE;
        }

        if ( (strlen(argv[i]) >= 10)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'c' || argv[i][1] == 'C')       &&
             (argv[i][2] == 'v' || argv[i][2] == 'V')       &&
             (argv[i][3] == 't' || argv[i][3] == 'T')       &&
             (argv[i][4] == 'a' || argv[i][4] == 'A')       &&
             (argv[i][5] == 'r' || argv[i][5] == 'R')       &&
             (argv[i][6] == 'e' || argv[i][6] == 'E')       &&
             (argv[i][7] == 'a' || argv[i][7] == 'A')       &&
             (argv[i][8] == ':') ) {

            if ( 0 != CvtZoneFileName.QueryChCount() ||
                 !CvtZoneFileName.Initialize( &(argv[i][9]) ) )
            {
                DebugPrintTrace(( "Failed to initialize CvtZoneFileName \n" ));
                return 1;
            }
        }

        if ( (strlen(argv[i]) >= 9)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'n' || argv[i][1] == 'N')       &&
             (argv[i][2] == 'o' || argv[i][2] == 'O')       &&
             (argv[i][3] == 'c' || argv[i][3] == 'C')       &&
             (argv[i][4] == 'h' || argv[i][4] == 'H')       &&
             (argv[i][5] == 'k' || argv[i][5] == 'K')       &&
             (argv[i][6] == 'd' || argv[i][6] == 'D')       &&
             (argv[i][7] == 's' || argv[i][7] == 'S')       &&
             (argv[i][8] == 'k' || argv[i][8] == 'K')
           ) {
            NoChkdsk = TRUE;
        }

        if ( (strlen(argv[i]) >= 11)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'n' || argv[i][1] == 'N')       &&
             (argv[i][2] == 'o' || argv[i][2] == 'O')       &&
             (argv[i][3] == 's' || argv[i][3] == 'S')       &&
             (argv[i][4] == 'e' || argv[i][4] == 'E')       &&
             (argv[i][5] == 'c' || argv[i][5] == 'C')       &&
             (argv[i][6] == 'u' || argv[i][6] == 'U')       &&
             (argv[i][7] == 'r' || argv[i][7] == 'R')       &&
             (argv[i][8] == 'i' || argv[i][8] == 'I')       &&
             (argv[i][9] == 't' || argv[i][9] == 'T')       &&
             (argv[i][10] == 'y' || argv[i][10] == 'Y')
           ) {
            NoSecurity = TRUE;
        }
    }

    if ( 0 == FileSystemName.QueryChCount() )
    {
        DebugPrintTrace(( "No FileSystem name specified\n" ));
        return 1;
    }

    DebugPrintTrace(("AUTOCONV: TargetFileSystem=%ws\n", FileSystemName.GetWSTR() ));

    if (fInSetup) {
        message = NEW SP_AUTOCHECK_MESSAGE;
        DebugPrintTrace(("Using setup output\n"));
    } else {
        DebugPrintTrace(("Not using setup output\n"));
        message = NEW AUTOCHECK_MESSAGE;
    }

    if (NULL == message || !message->Initialize()) {
        DebugPrintTrace(( "Failed to intitialize message structure\n" ));
        return 1;
    }

    message->SetLoggingEnabled(TRUE);

    if (!FatName.Initialize("FAT") ||
        !Fat32Name.Initialize("FAT32")) {
        message->Set(MSG_CONV_NO_MEMORY);
        message->Display();
        SaveMessageLog( message, &DriveName );
        return 1;
    }

    // If this is the System Partition of an ARC machine, don't
    // convert it.
    //
    if( IFS_SYSTEM::IsArcSystemPartition( &DriveName, &Error ) ) {

        message->Set( MSG_CONV_ARC_SYSTEM_PARTITION );
        message->Display( );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    if (!IFS_SYSTEM::QueryFileSystemName( &DriveName, &CurrentFsName )) {

        message->Set( MSG_FS_NOT_DETERMINED );
        message->Display( "%W", &StrippedDriveName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    if( IsPC98_N() ) {
        DP_DRIVE    dpdrive2;
        if( !dpdrive2.Initialize(&DriveName, message) ) {

            message->Set( MSG_CONV_CANNOT_AUTOCHK );
            message->Display( "%W%W", &DriveName, &FileSystemName );

            SaveMessageLog( message, &DriveName );
            DeRegister( argc, argv );
            return 1;
        }
        if( CurrentFsName == FatName ) { //***FAT***
            if((dpdrive2.QuerySectorSize() != dpdrive2.QueryPhysicalSectorSize())||
               (dpdrive2.QueryPhysicalSectorSize() == 2048)) {

                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );

                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }
        } else {     //***HPFS/NTFS**
            if( dpdrive2.QueryPhysicalSectorSize() == 2048 ) {

                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }
        }
    }
#endif

    CurrentFsName.Strupr();
    FileSystemName.Strupr();

    if ( CurrentFsName == FileSystemName ) {

        int iReturn = 0;

        if ( IsRestartFatToOfs( DriveName, CurrentFsName, FileSystemName ) ) {

            if ( !FatToOfs( &DriveName, message, Verbose, fInSetup, &Status ) ) {
                iReturn = 1;
            }
        }
        else {
            //
            //  The drive is already in the desired file system, our
            //  job is done.  Delete the name conversion table (if
            //  specified) and take ourselves out of the registry.
            //  Do not save the message log--there's nothing interesting
            //  in it.
            //
            //  If we're doing oem pre-install (Pause is TRUE) we don't
            //  want to print this "already converted" message.
            //

            message->SetLoggingEnabled(FALSE);
        }

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return iReturn;
    }

    message->Set( MSG_FILE_SYSTEM_TYPE );
    message->Display( "%W", &CurrentFsName );

    //  Determine whether the target file-system is enabled
    //  in the registry.  If it is not, refuse to convert
    //  the drive.
    //
    if( !IFS_SYSTEM::IsFileSystemEnabled( &FileSystemName ) ) {

        message->Set( MSG_CONVERT_FILE_SYSTEM_NOT_ENABLED );
        message->Display( "%W", &FileSystemName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    //  Since autoconvert will often be put in place by Setup
    //  to run after AutoSetp, delay for 3 seconds to give the
    //  file system time to clean up detritus of deleted files.
    //
    DelayInterval = RtlConvertLongToLargeInteger( -30000000 );

    NtDelayExecution( TRUE, &DelayInterval );

    //  Open a volume of the appropriate type.  The volume is
    //  opened for exclusive write access.
    //
    if( CurrentFsName == FatName || CurrentFsName == Fat32Name) {

        if (IsConversionAvailable(&FileSystemName)) {
            message->Set( MSG_CONV_CONVERSION_NOT_AVAILABLE );
            message->Display( "%W%W", &CurrentFsName, &FileSystemName );
            SaveMessageLog( message, &DriveName );
            DeRegister( argc, argv );
            return 1;
        }

        {
            DP_DRIVE    dpdrive;

            if( !dpdrive.Initialize(&DriveName, message) ) {
                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            switch (dpdrive.QueryDriveType()) {
                case UnknownDrive:  // it probably won't get this far
                    message->Set( MSG_CONV_INVALID_DRIVE_SPEC );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                case CdRomDrive:
                    message->Set( MSG_CONV_CANT_CDROM );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                case RemoteDrive:   // it probably won't get this far
                    message->Set( MSG_CONV_CANT_NETWORK );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                default:
                    break;
            }
        }

        if (!NoChkdsk) {

            PFAT_VOL            FatVolume;

            if( !(FatVolume = NEW FAT_VOL) ||
                !FatVolume->Initialize( message, &DriveName) ||
                !FatVolume->ChkDsk( TotalFix, message, 0, 0 ) ) {

                DELETE (FatVolume);

                message->Set( MSG_CONV_CANNOT_AUTOCHK );
                message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            DELETE (FatVolume);
        }

        message->Set( MSG_BLANK_LINE );
        message->Display();

        if ( IsFatToOfs( CurrentFsName, FileSystemName ) ) {

            message->Set( MSG_CONV_CONVERTING );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

            Converted = FatToOfs( &DriveName,
                                  message,
                                  Verbose,
                                  fInSetup,
                                  &Status );
        } else {

            PLOG_IO_DP_DRIVE pDrive;

            pDrive = NEW LOG_IO_DP_DRIVE;

            if (pDrive == NULL) {
                message->Set(MSG_CONV_NO_MEMORY);
                message->Display();
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            if ( !pDrive->Initialize(&DriveName, message) ) {
                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                DELETE( pDrive );
                return 1;
            }

            message->Set( MSG_CONV_CONVERTING );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

            //
            // there is no need to pass in /NoChkdsk
            //
            flags = Verbose ? CONVERT_VERBOSE_FLAG : 0;
            flags |= Pause ? CONVERT_PAUSE_FLAG : 0;
            flags |= NoSecurity ? CONVERT_NOSECURITY_FLAG : 0;

            Converted = ConvertFATVolume( pDrive,
                                          &FileSystemName,
                                          &CvtZoneFileName,
                                          message,
                                          flags,
                                          &Status );

            DELETE( pDrive );
        }

    } else {

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "AUTOCONV", &CurrentFsName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    if ( Converted ) {

        message->Set( MSG_CONV_CONVERSION_COMPLETE );
        message->Display();

    } else {

        //
        //  The conversion was not successful. Determine what the problem was
        //  and return the appropriate CONVERT exit code.
        //
        switch ( Status ) {

          case CONVERT_STATUS_CONVERTED:
            //
            //  This is an inconsistent state, Convert should return
            //  TRUE if the conversion was successful!
            //
            message->Set( MSG_CONV_CONVERSION_MAYHAVE_FAILED );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );
            break;

          case CONVERT_STATUS_INVALID_FILESYSTEM:
            //
            //  The conversion DLL does not recognize the target file system.
            //
            message->Set( MSG_CONV_INVALID_FILESYSTEM );
            message->Display( "%W", &FileSystemName );
            break;

          case CONVERT_STATUS_CONVERSION_NOT_AVAILABLE:
            //
            //  The target file system is valid, but the conversion is not
            //  available.
            //
            message->Set( MSG_CONV_CONVERSION_NOT_AVAILABLE );
            message->Display( "%W%W", &CurrentFsName, &FileSystemName );
            break;

          case CONVERT_STATUS_NTFS_RESERVED_NAMES:
            message->Set( MSG_CONV_NTFS_RESERVED_NAMES );
            message->Display( "%W", &StrippedDriveName );
            break;

          case CONVERT_STATUS_WRITE_PROTECTED:
            message->Set( MSG_CONV_WRITE_PROTECTED );
            message->Display( "%W", &StrippedDriveName );
            break;

          case CONVERT_STATUS_INSUFFICIENT_FREE_SPACE:
          case CONVERT_STATUS_CANNOT_LOCK_DRIVE:
          case CONVERT_STATUS_DRIVE_IS_DIRTY:
          case CONVERT_STATUS_ERROR:
            //
            //  The conversion failed.
            //
          default:
            //
            //  Invalid status code
            //
            message->Set( MSG_CONV_CONVERSION_FAILED );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );
            DebugPrintTrace(("AUTOCONV: Failed %x\n", Status));
            break;
        }
    }

    SaveMessageLog( message, &DriveName );
    DeRegister( argc, argv );

#if INCLUDE_OFS==1
    CleanupExceptionSystem();
#endif  // INCLUDE_OFS==1

    return ( Converted ? 0 : 1 );
}




BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autoconvert.

Arguments:

    argc    --  Supplies the number of arguments given to autoconv
    argv    --  supplies the arguments given to autoconv

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString1,
            CommandLineString2,
            CurrentArgString,
            OneSpace;

    int i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autoconv arg1 arg2...".
    //
    if( !CommandLineString1.Initialize( L"autoconv" ) ||
        !OneSpace.Initialize( L" " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize( argv[i] ) ||
            !CommandLineString1.Strcat( &OneSpace ) ||
            !CommandLineString1.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    // Now construct the secondary string, which is
    // "autocheck arg0 arg1 arg2..."
    //
    if( !CommandLineString2.Initialize( "autocheck " )  ||
        !CommandLineString2.Strcat( &CommandLineString1 ) ) {

        return FALSE;
    }

    return( AUTOREG::DeleteEntry( &CommandLineString1 ) &&
            AUTOREG::DeleteEntry( &CommandLineString2 ) );

}


BOOLEAN
SaveMessageLog(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   DriveName
    )
/*++

Routine Description:

    This function writes the logged messages from the supplied
    message object to the file "BOOTEX.LOG" in the root of the
    specified drive.

Arguments:

    Message     --  Supplies the message object.
    DriveName   --  Supplies the name of the drive.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING QualifiedName;
    FSTRING BootExString;
    HMEM    Mem;
    ULONG   Length;

    if( !Message->IsLoggingEnabled() ) {

        return TRUE;
    }

    return( QualifiedName.Initialize( DriveName )       &&
            BootExString.Initialize( L"\\BOOTEX.LOG" )  &&
            QualifiedName.Strcat( &BootExString )       &&
            Mem.Initialize()                            &&
            Message->QueryPackedLog( &Mem, &Length )    &&
            IFS_SYSTEM::WriteToFile( &QualifiedName,
                                     Mem.GetBuf(),
                                     Length,
                                     TRUE ) );
}

BOOLEAN
FileDelete(
    IN  PCWSTRING DriveName,
    IN  PCWSTRING FileName
    )
/*++

Routine Description:

    This function deletes a file.  It is used to clean up the
    name translation table.

Arguments:

    DriveName   --  Supplies the drive on which the file resides.
    FileName    --  Supplies the file name.  Note that the file
                    should be in the root directory.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING QualifiedName;
    FSTRING Backslash;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    FILE_DISPOSITION_INFORMATION DispositionInfo;
    HANDLE FileHandle;
    NTSTATUS Status;

    if( !Backslash.Initialize( L"\\" )          ||
        !QualifiedName.Initialize( DriveName )  ||
        !QualifiedName.Strcat( &Backslash )     ||
        !QualifiedName.Strcat( FileName ) ) {

        return FALSE;
    }

    UnicodeString.Buffer = (PWSTR)QualifiedName.GetWSTR();
    UnicodeString.Length = (USHORT)( QualifiedName.QueryChCount() * sizeof( WCHAR ) );
    UnicodeString.MaximumLength = UnicodeString.Length;

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile( &FileHandle,
                         FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE );

    if( NT_SUCCESS( Status ) ) {

        DispositionInfo.DeleteFile = TRUE;

        Status = NtSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       &DispositionInfo,
                                       sizeof( DispositionInfo ),
                                       FileDispositionInformation );
    }

    if( !NT_SUCCESS( Status ) ) {

        return FALSE;
    }

    NtClose( FileHandle );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chkdsk\chkdsk.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        chkdsk.cxx

Abstract:

        Chkdsk is a program that checks your disk for corruption and/or bad sectors.

Author:

        Bill McJohn (billmc) 12-April-91

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "arg.hxx"
#include "chkmsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"
#include "ifsentry.hxx"

#include "keyboard.hxx"

#include "supera.hxx"           // for CHKDSK_EXIT_*

int __cdecl
main(
        )
/*++

Routine Description:

    Entry point for chkdsk.exe.  This function parses the arguments,
    determines the appropriate file system (by querying the volume),
    and invokes the appropriate version of chkdsk.

    The arguments accepted by Chkdsk are:

        /f                  Fix errors on drive
        /v                  Verbose operation
        drive:              drive to check
        file-name           files to check for contiguity
                            (Note that HPFS ignores file-name parameters).
        /x                  Force the volume to dismount first if necessary (implied /f)
        /i                  include index entries checking during index verification
        /c                  include cycles checking during index verification
        /r                  locate bad sectors and recover readable information
        /l[:size]           change or display log file size

--*/
{
    DSTRING         CurrentDirectory;
    DSTRING         FsName;
    DSTRING         FsNameAndVersion;
    DSTRING         LibraryName;
    DSTRING         DosDriveName;
    DSTRING         CurrentDrive;
    DSTRING         NtDriveName;
    PWSTRING        p;
    HANDLE          FsUtilityHandle;
    DSTRING         ChkdskString;
    DSTRING         Colon;
    CHKDSKEX_FN     ChkdskEx = NULL;
    PWSTRING        pwstring;
    BOOLEAN         fix;
    BOOLEAN         resize_logfile;
    ULONG           logfile_size;
    FSTRING         acolon, bcolon;
    ULONG           exit_status;

    ARGUMENT_LEXEMIZER  Lexemizer;
    ARRAY               EmptyArray;
    ARRAY               ArgumentArray;
    FLAG_ARGUMENT       ArgumentHelp;
    FLAG_ARGUMENT       ArgumentForce;
    FLAG_ARGUMENT       ArgumentFix;
    FLAG_ARGUMENT       ArgumentVerbose;
    FLAG_ARGUMENT       ArgumentRecover;
    LONG_ARGUMENT       ArgumentAlgorithm;
    FLAG_ARGUMENT       ArgumentSkipIndexScan;
    FLAG_ARGUMENT       ArgumentSkipCycleScan;
    FLAG_ARGUMENT       ArgumentResize;
    LONG_ARGUMENT       ArgumentResizeLong;
    STRING_ARGUMENT     ArgumentProgramName;
    PATH_ARGUMENT       ArgumentPath;


    CHKDSK_MESSAGE      Message;
    NTSTATUS            Status;
    DWORD               oldErrorMode;
    PATH_ANALYZE_CODE   rst;
    PPATH               ppath;
    PATH                fullpath;
    PATH                drivepath;
    DSTRING             drivename;
    DSTRING             drive_path_string;
    BOOLEAN             is_drivepath_invalid = TRUE;
    DSTRING             ntfs_name;
    USHORT              algorithm;

    CHKDSKEX_FN_PARAM   param;


    if( !Message.Initialize( Get_Standard_Output_Stream(),
                             Get_Standard_Input_Stream() ) ) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

#if defined(PRE_RELEASE_NOTICE)
    Message.Set(MSG_CHK_PRE_RELEASE_NOTICE);
    Message.Display();
#endif

    // Initialize the colon string in case we need it later:

    if( !Colon.Initialize( ":" ) ||
        !ntfs_name.Initialize( "NTFS" )) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // Parse the arguments.  First, initialize all the
    // parsing machinery.  Then put the potential arguments
    // into the argument array,

    if( !ArgumentArray.Initialize( 5, 1 )               ||
        !EmptyArray.Initialize( 5, 1 )                  ||
        !Lexemizer.Initialize( &EmptyArray )            ||
        !ArgumentHelp.Initialize( "/?" )                ||
        !ArgumentForce.Initialize( "/X" )               ||
        !ArgumentFix.Initialize( "/F" )                 ||
        !ArgumentVerbose.Initialize( "/V" )             ||
        !ArgumentRecover.Initialize( "/R" )             ||
        !ArgumentAlgorithm.Initialize( "/I:*" )         ||
        !ArgumentSkipIndexScan.Initialize( "/I" )       ||
        !ArgumentSkipCycleScan.Initialize( "/C" )       ||
        !ArgumentResize.Initialize( "/L" )              ||
        !ArgumentResizeLong.Initialize( "/L:*" )        ||
        !ArgumentProgramName.Initialize( "*" )          ||
        !ArgumentPath.Initialize( "*", FALSE ) ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // CHKDSK is not case sensitive.

    Lexemizer.SetCaseSensitive( FALSE );

    if( !ArgumentArray.Put( &ArgumentProgramName )  ||
        !ArgumentArray.Put( &ArgumentHelp )         ||
        !ArgumentArray.Put( &ArgumentForce )        ||
        !ArgumentArray.Put( &ArgumentFix )          ||
        !ArgumentArray.Put( &ArgumentVerbose )      ||
        !ArgumentArray.Put( &ArgumentRecover )      ||
        !ArgumentArray.Put( &ArgumentAlgorithm )    ||
        !ArgumentArray.Put( &ArgumentSkipIndexScan )||
        !ArgumentArray.Put( &ArgumentSkipCycleScan )||
        !ArgumentArray.Put( &ArgumentResize )       ||
        !ArgumentArray.Put( &ArgumentResizeLong )   ||
        !ArgumentArray.Put( &ArgumentPath ) ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // Parse.  Note that PrepareToParse will, by default, pick
    // up the command line.

    if( !Lexemizer.PrepareToParse() ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // If the parsing failed, display a helpful command line summary.

    if( !Lexemizer.DoParsing( &ArgumentArray ) ) {

        Message.Set(MSG_INVALID_PARAMETER);
        Message.Display("%W", pwstring = Lexemizer.QueryInvalidArgument());
        DELETE(pwstring);

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // If the user requested help, give it.

    if( ArgumentHelp.QueryFlag() ) {

        Message.Set( MSG_CHK_USAGE_HEADER );
        Message.Display( "" );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );
        Message.Set( MSG_CHK_COMMAND_LINE );
        Message.Display( "" );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );
        Message.Set( MSG_CHK_DRIVE );
        Message.Display( "" );
        Message.Set( MSG_CHK_USG_FILENAME );
        Message.Display( "" );
        Message.Set( MSG_CHK_F_SWITCH );
        Message.Display( "" );
        Message.Set( MSG_CHK_V_SWITCH );
        Message.Display( "" );

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    if (!ArgumentPath.IsValueSet()) {

        if (!SYSTEM::QueryCurrentDosDriveName(&DosDriveName) ||
            !drivepath.Initialize(&DosDriveName)) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }
        ppath = &drivepath;
    } else {
        ppath = ArgumentPath.GetPath();
#if defined(RUN_ON_NT4)
        if (!DosDriveName.Initialize(ppath->GetPathString()))
            return CHKDSK_EXIT_COULD_NOT_CHK;
#endif
    }

#if !defined(RUN_ON_NT4)
    rst = ppath->AnalyzePath(&DosDriveName,
                             &fullpath,
                             &drive_path_string);

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            is_drivepath_invalid = fullpath.IsDrive() ||
                                   (fullpath.GetPathString()->QueryChCount() == 0);
            if (ppath->IsGuidVolName()) {
                if (!drivename.Initialize(&DosDriveName))
                    return CHKDSK_EXIT_COULD_NOT_CHK;
            } else {
                if (!drivename.Initialize(fullpath.GetPathString()))
                    return CHKDSK_EXIT_COULD_NOT_CHK;
            }

            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!DosDriveName.Initialize(fullpath.GetPathString())) {
                    return CHKDSK_EXIT_COULD_NOT_CHK;
                }
            }
            if (!fullpath.AppendString(&drive_path_string) ||
                !drivepath.Initialize(&drive_path_string))
                return CHKDSK_EXIT_COULD_NOT_CHK;
            break;

        case PATH_OUT_OF_MEMORY:
            DebugPrint("Out of memory.\n");
            return CHKDSK_EXIT_COULD_NOT_CHK;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            Message.Set(MSG_CHK_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;

        default:
            Message.Set(MSG_CHK_BAD_DRIVE_PATH_FILENAME);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
    }
#endif

    if (!DosDriveName.Strupr()) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // disable popups while we determine the drive type
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Make sure that drive is of a correct type.

    switch (SYSTEM::QueryDriveType(&DosDriveName)) {

        case RemoteDrive:
            SetErrorMode( oldErrorMode );
            Message.Set(MSG_CHK_CANT_NETWORK);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;

#if 0
        case CdRomDrive:
            SetErrorMode( oldErrorMode );
            Message.Set(MSG_CHK_CANT_CDROM);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
#endif

        default:
            break;

    }

    SetErrorMode( oldErrorMode );

    if (!SYSTEM::QueryCurrentDosDriveName(&CurrentDrive)) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // /R ==> /F
    // /X ==> /F

    fix = ArgumentFix.QueryFlag() ||
          ArgumentForce.QueryFlag() ||
          ArgumentRecover.QueryFlag();

    //      From here on we want to deal with an NT drive name:

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&DosDriveName, &NtDriveName)) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // disable popups while we determine the file system name and version
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Determine the type of the file system.
    // Ask the volume what file system it has.  The
    // IFS utilities for file system xxxx are in Uxxxx.DLL.
    //

    if (!IFS_SYSTEM::QueryFileSystemName(&NtDriveName,
                                         &FsName,
                                         &Status,
                                         &FsNameAndVersion )) {

        SetErrorMode( oldErrorMode );

        if( Status == STATUS_ACCESS_DENIED ) {

            Message.Set( MSG_DASD_ACCESS_DENIED );
            Message.Display( "" );

        } else if( Status != STATUS_SUCCESS ) {

            Message.Set( MSG_CANT_DASD );
            Message.Display( "" );

        } else {

            Message.Set( MSG_FS_NOT_DETERMINED );
            Message.Display( "%W", &drivename );
        }

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // re-enable hardware popups
    SetErrorMode( oldErrorMode );

    if (FsName == ntfs_name && drive_path_string.QueryChCount()) {
        Message.Set(MSG_CHK_BAD_DRIVE_PATH_FILENAME);
        Message.Display();
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    Message.SetLoggingEnabled();

    Message.Set( MSG_CHK_RUNNING );
    Message.Log( "%W", &drivename );

    Message.Set( MSG_FILE_SYSTEM_TYPE );
    Message.Display( "%W", &FsName );


    if ( !FsName.Strupr() ) {
       return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    DSTRING fat32_name;

    if ( !fat32_name.Initialize("FAT32") ) {
       return CHKDSK_EXIT_COULD_NOT_CHK;

    }

    if ( FsName == fat32_name ) {
       FsName.Initialize("FAT");
    }


    if ( !LibraryName.Initialize( "U" ) ||
         !LibraryName.Strcat( &FsName ) ||
         !ChkdskString.Initialize( "ChkdskEx" ) ) {

         Message.Set( MSG_CHK_NO_MEMORY );
         Message.Display( "" );
         return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    if (fix && (CurrentDrive == DosDriveName)) {

        Message.Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        Message.Display();

        if (IsNEC_98) {

            DP_DRIVE    dpdrive;

            dpdrive.Initialize(&NtDriveName, &Message);

            if (dpdrive.IsFloppy()) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
            }

        } else {

            acolon.Initialize((PWSTR) L"A:");
            bcolon.Initialize((PWSTR) L"B:");

            if (!DosDriveName.Stricmp(&acolon) ||
                !DosDriveName.Stricmp(&bcolon)) {

                return CHKDSK_EXIT_COULD_NOT_CHK;
            }

        }

        // Fall through so that the lock fails and then the
        // run autochk on reboot logic kicks in.
        //
    }

    if (ArgumentAlgorithm.IsValueSet() && ArgumentSkipIndexScan.QueryFlag()) {

        Message.Set(MSG_CHK_ALGORITHM_AND_SKIP_INDEX_SPECIFIED);
        Message.Display();
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    if (ArgumentAlgorithm.IsValueSet()) {

        if (ArgumentAlgorithm.QueryLong() < 0 ||
            ArgumentAlgorithm.QueryLong() > CHKDSK_MAX_ALGORITHM_VALUE) {

            Message.Set(MSG_CHK_INCORRECT_ALGORITHM_VALUE);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        } else
            algorithm = (USHORT)ArgumentAlgorithm.QueryLong();

    } else
        algorithm = 0;

    if (ArgumentSkipIndexScan.QueryFlag() || ArgumentAlgorithm.IsValueSet()) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_SKIP_INDEX_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

    }

    if (ArgumentSkipCycleScan.QueryFlag()) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_SKIP_CYCLE_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

    }

    // Does the user want to resize the logfile?  This is only sensible
    // for NTFS.  If she specified a size of zero, print an error message
    // because that's a poor choice and will confuse the untfs code,
    // which assumes that zero means resize to the default size.
    //

    resize_logfile = ArgumentResize.IsValueSet() || ArgumentResizeLong.IsValueSet();

    if (resize_logfile) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_LOGFILE_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

        if (ArgumentResizeLong.IsValueSet()) {

            if (ArgumentResizeLong.QueryLong() <= 0) {

                Message.Set(MSG_CHK_WONT_ZERO_LOGFILE);
                Message.Display();
                return CHKDSK_EXIT_COULD_NOT_CHK;
            }

            if (ArgumentResizeLong.QueryLong() > MAXULONG/1024) {
                Message.Set(MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG);
                Message.Display();
                return CHKDSK_EXIT_COULD_NOT_CHK;
            }
            logfile_size = ArgumentResizeLong.QueryLong() * 1024;
        } else {

            logfile_size = 0;
        }
    }

    if ((ChkdskEx =
        (CHKDSKEX_FN)SYSTEM::QueryLibraryEntryPoint( &LibraryName,
                                                     &ChkdskString,
                                                     &FsUtilityHandle )) !=
        NULL ) {

        if (fix &&
            !KEYBOARD::EnableBreakHandling()) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

        //
        // setup parameter block v1.0 to be passed to ChkdskEx
        //

        param.Major = 1;
        param.Minor = 1;
        param.Flags = (ArgumentVerbose.QueryFlag() ? CHKDSK_VERBOSE : 0);
        param.Flags |= (ArgumentRecover.QueryFlag() ? CHKDSK_RECOVER : 0);
        param.Flags |= (ArgumentForce.QueryFlag() ? CHKDSK_FORCE : 0);
        param.Flags |= (resize_logfile ? CHKDSK_RESIZE_LOGFILE : 0);
        param.Flags |= (ArgumentSkipIndexScan.QueryFlag() ? CHKDSK_SKIP_INDEX_SCAN : 0);
        param.Flags |= (ArgumentSkipCycleScan.QueryFlag() ? CHKDSK_SKIP_CYCLE_SCAN : 0);
        param.Flags |= (ArgumentAlgorithm.IsValueSet() ? CHKDSK_ALGORITHM_SPECIFIED : 0);
        param.LogFileSize = logfile_size;
        param.PathToCheck = &fullpath;
        param.RootPath = (is_drivepath_invalid) ? NULL : &drivepath;
        param.Algorithm = algorithm;

        if (fix) {
            ChkdskEx( &NtDriveName,
                      &Message,
                      fix,
                      &param,
                      &exit_status );
        } else {

//disable C4509 warning about nonstandard ext: SEH + destructor
#pragma warning(disable:4509)

            __try {
                ChkdskEx( &NtDriveName,
                          &Message,
                          fix,
                          &param,
                          &exit_status );
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                // If we get an access violation during read-only mode
                // CHKDSK then it's because the file system is partying
                // on the volume while we are.

                Message.Set(MSG_CHK_NTFS_ERRORS_FOUND);
                Message.Display();
                exit_status = CHKDSK_EXIT_ERRS_NOT_FIXED;
            }
        }

        if (CHKDSK_EXIT_ERRS_FIXED == exit_status && !fix) {
            exit_status = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }

        SYSTEM::FreeLibraryHandle( FsUtilityHandle );

        if (fix &&
            !KEYBOARD::DisableBreakHandling()) {

            return 1;
        }

    } else {

        Message.Set( MSG_FS_NOT_SUPPORTED );
        Message.Display( "%s%W", "CHKDSK", &FsName );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

//    Message.Set(MSG_CHK_NTFS_MESSAGE);
//    Message.Display("%s%d", "Exit Status ", exit_status);

    return exit_status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autofmt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=autofmt

TARGETNAME=autofmt
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\autofmt.cxx ..\autofmt.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O);\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1

TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt

W32_SB=1
SOURCES_USED=..\sources.inc

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\autofmt\autofmt.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autofmt.cxx

Abstract:

    This is the main program for the autofmt version of format.

Author:

    Matthew Bradburn (mattbr) 13-Dec-94

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "achkmsg.hxx"
#include "spackmsg.hxx"
#include "tmackmsg.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"
#include "fatvol.hxx"
#include "ntfsvol.hxx"
#include "autoreg.hxx"
#include "autoentr.hxx"
#include "arg.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUhpfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    );

BOOLEAN
SavemessageLog(
    IN OUT  PMESSAGE    message,
    IN      PCWSTRING   drive_name
    );

int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for AutoFmt

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autofmt
                  command line is:

    AUTOFMT drive-name /FS:target-file-system [/V:label] [/Q] [/A:size] [/C]
            [/S]

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)       ||
        !InitializeUntfs(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        return 1;
    }

    PFAT_VOL            fat_volume;
    PNTFS_VOL           ntfs_volume;
    PDP_DRIVE            dp_drive;

    PAUTOCHECK_MESSAGE  message;
    DSTRING             drive_name;
    DSTRING             file_system_name;
    DSTRING             label;
    DSTRING             fat_name;
    DSTRING             ntfs_name;
    DSTRING             fat32_name;
    BOOLEAN             quick = FALSE;
    BOOLEAN             compress = FALSE;
    BOOLEAN             error;
    FORMAT_ERROR_CODE   success;
    BOOLEAN             setup_output = FALSE;
    BOOLEAN             textmode_output = FALSE;
    BIG_INT             bigint;
    ULONG               cluster_size = 0;
    int                 i;

    LARGE_INTEGER       delay_interval;

    if (!file_system_name.Initialize()) {
        return 1;
    }
    if (!label.Initialize() || NULL == (dp_drive = NEW DP_DRIVE)) {
        return 1;
    }

    //
    //  Parse the arguments.
    //

    if ( argc < 2 ) {
        return 1;
    }

    //
    //  First argument is drive
    //
    if ( !drive_name.Initialize( argv[1] ) ) {
        return 1;
    }
    DebugPrintTrace(("drive name: %ws\n", drive_name.GetWSTR()));

    //
    //  The rest of the arguments are flags.
    //
    for (i = 2; i < argc; i++) {

        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'f' || argv[i][1] == 'F')    &&
            (argv[i][2] == 's' || argv[i][2] == 'S')    &&
            (argv[i][3] == ':')) {

            if (!file_system_name.Initialize(&argv[i][4])) {
                return 1;
            }
            DebugPrintTrace(("fsname: %ws\n", file_system_name.GetWSTR()));
            continue;
        }
        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'v' || argv[i][1] == 'V')    &&
            (argv[i][2] == ':')) {

            if (!label.Initialize(&argv[i][3])) {
                return 1;
            }
            continue;
        }
        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'a' || argv[i][1] == 'A')    &&
            (argv[i][2] == ':')) {

            cluster_size = atoi(&argv[i][3]);
            continue;
        }
        if (0 == _stricmp(argv[i], "/Q") || 0 == _stricmp(argv[i], "-Q")) {
            quick = TRUE;
            continue;
        }
        if (0 == _stricmp(argv[i], "/C") || 0 == _stricmp(argv[i], "-C")) {
            compress = TRUE;
            continue;
        }
        if (0 == _stricmp(argv[i], "/S") || 0 == _stricmp(argv[i], "-S")) {
            setup_output = TRUE;
        }
        if (0 == _stricmp(argv[i], "/T") || 0 == _stricmp(argv[i], "-T")) {
            textmode_output = TRUE;
        }
    }

    if (textmode_output) {
        message = NEW TM_AUTOCHECK_MESSAGE;
    } else if (setup_output) {
        message = NEW SP_AUTOCHECK_MESSAGE;
        DebugPrintTrace(("Using setup output\n"));
    } else {
        DebugPrintTrace(("Not using setup output\n"));
        message = NEW AUTOCHECK_MESSAGE;
    }
    if (NULL == message || !message->Initialize()) {
        return 1;
    }

#if 0 // Shouldn't limit the cluster size as long as it is reasonable.
    if (cluster_size != 0 && cluster_size != 512 && cluster_size != 1024 &&
        cluster_size != 2048 && cluster_size != 4096) {

        message->Set(MSG_UNSUPPORTED_PARAMETER);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }
#endif
    if (0 == file_system_name.QueryChCount()) {

        // attempt to get the current filesystem type from disk

        if (!IFS_SYSTEM::QueryFileSystemName(&drive_name, &file_system_name)) {

            message->Set( MSG_FS_NOT_DETERMINED );
            message->Display( "%W", &drive_name );

            DeRegister( argc, argv );
            return 1;
        }
        file_system_name.Strupr();
    }

    if (!fat_name.Initialize("FAT") ||
        !ntfs_name.Initialize("NTFS") ||
        !fat32_name.Initialize("FAT32")) {

        return 1;
    }

    file_system_name.Strupr();

    //
    // If compression is requested, make sure it's available.
    //

    if (compress && file_system_name != ntfs_name) {

        message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
        message->Display("%W", &file_system_name);
        DeRegister( argc, argv );
        return 1;
    }

    //  Since autoformat will often be put in place by Setup
    //  to run after AutoSetp, delay for 3 seconds to give the
    //  file system time to clean up detritus of deleted files.
    //
    delay_interval = RtlConvertLongToLargeInteger( -30000000 );

    NtDelayExecution( TRUE, &delay_interval );

    if (!dp_drive->Initialize(&drive_name, message)) {
        DeRegister( argc, argv );
        return 1;
    }

    if (dp_drive->IsFloppy()) {
        // MJB: refuse to format
        DeRegister( argc, argv );
        return 1;
    }

    switch (dp_drive->QueryDriveType()) {
        case UnknownDrive:
            message->Set(MSG_NONEXISTENT_DRIVE);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        case RemoteDrive:   // it probably won't get that far
            message->Set(MSG_FORMAT_NO_NETWORK);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        case RamDiskDrive:  // it probably won't get that far
            message->Set(MSG_FORMAT_NO_RAMDISK);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        default:
            break;
    }

    //
    // Print the "formatting <size>" message.
    //

    if (quick) {
        message->Set(MSG_QUICKFORMATTING_MB);
    } else {
        message->Set(MSG_FORMATTING_MB);
    }

    bigint = dp_drive->QuerySectors() * dp_drive->QuerySectorSize() /
        1048576;

    DebugAssert(bigint.GetHighPart() == 0);

    message->Display("%d", bigint.GetLowPart());

    if (file_system_name == fat_name || file_system_name == fat32_name) {


        BOOLEAN old_fat_vol = TRUE;

        if( file_system_name == fat32_name ) {
            old_fat_vol = FALSE;
        }

        if( !(fat_volume = NEW FAT_VOL) ||
            NoError != fat_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {

            DeRegister( argc, argv );
            return 1;
        }

        success = fat_volume->Format(&label,
                                     message,
                                     old_fat_vol ? FORMAT_BACKWARD_COMPATIBLE : 0,
                                     cluster_size);

        DebugPrintTrace(("Format return code: %d\n", success));

        DELETE( fat_volume );

    } else if (file_system_name == ntfs_name) {

        if (dp_drive->QueryDriveType() == CdRomDrive) {
            message->Set(MSG_FMT_NO_NTFS_ALLOWED);
            message->Display();
            DeRegister( argc, argv );
            return 1;
        }

        if( !(ntfs_volume = NEW NTFS_VOL) ||
            NoError != ntfs_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {

            DeRegister( argc, argv );
            return 1;
        }

        success = ntfs_volume->Format(&label,
                                      message,
                                      0,
                                      cluster_size);

        DebugPrintTrace(("Format return code: %d\n", success));

        DELETE( ntfs_volume );

    } else {

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "AUTOFMT", &file_system_name);

        DeRegister( argc, argv );
        return 1;
    }

    // Truncate "fat32" back to "fat"...yuck..
    if (file_system_name == fat32_name) {
       if (!file_system_name.Initialize("FAT")) {
          DeRegister( argc, argv );
          return 1;
       }
    }


    // Make sure the file system is installed.

    if (!IFS_SYSTEM::IsFileSystemEnabled(&file_system_name)) {
        message->Set(MSG_FMT_INSTALL_FILE_SYSTEM);
        message->Display("%W", &file_system_name);

        if (!IFS_SYSTEM::EnableFileSystem(&file_system_name)) {
            message->Set(MSG_FMT_CANT_INSTALL_FILE_SYSTEM);
            message->Display();
            return 1;
        }

        message->Set(MSG_FMT_FILE_SYSTEM_INSTALLED);
        message->Display();
    }

    if (compress && !IFS_SYSTEM::EnableVolumeCompression(&drive_name)) {
        message->Set(MSG_CANNOT_ENABLE_COMPRESSION);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }

    DeRegister( argc, argv );

    return (success != NoError);
}




BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autoconvert.

Arguments:

    argc    --  Supplies the number of arguments given to autoconv
    argv    --  supplies the arguments given to autoconv

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString1,
            CommandLineString2,
            CurrentArgString,
            OneSpace;

    int i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autoconv arg1 arg2...".
    //
    if( !CommandLineString1.Initialize( L"autofmt" ) ||
        !OneSpace.Initialize( L" " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize( argv[i] ) ||
            !CommandLineString1.Strcat( &OneSpace ) ||
            !CommandLineString1.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    // Now construct the secondary string, which is
    // "autocheck arg0 arg1 arg2..."
    //
    if( !CommandLineString2.Initialize( "autocheck " )  ||
        !CommandLineString2.Strcat( &CommandLineString1 ) ) {

        return FALSE;
    }

    return( AUTOREG::DeleteEntry( &CommandLineString1 ) &&
            AUTOREG::DeleteEntry( &CommandLineString2 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cipher\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chkdsk\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=chkdsk

TARGETNAME=chkdsk
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chkdsk.cxx ..\chkdsk.rc

LINKER_FLAGS=$(LINKER_FLAGS) -LARGEADDRESSAWARE

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

!IF defined(CHKDSK_PRE_RELEASE_NOTICE)
C_DEFINES=$(C_DEFINES) /DPRE_RELEASE_NOTICE
!ENDIF

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF


MSC_WARNING_LEVEL=/W3 /WX

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chkntfs\chkntfs.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chkntfs.cxx


Abstract:

    This utility allows the users to find the state of the dirty bit
    on NTFS volumes, to schedule autochk for specific drives, and to
    mofidy the default autochk action for a drive.


    SYNTAX:

        chkntfs drive: [...]            -- tells if a drive is dirty or chkdsk has been scheduled
        chkntfs /d                      -- restore default autochk behavior
        chkntfs /x drive: [...]         -- exclude drives from default autochk
        chkntfs /c drive: [...]         -- schedule autochk to run on drives
        chkntfs /e drive: [...]         -- enable automatic volume upgrades on drives
        chkntfs /t[:countdowntime]      -- display or set autochk countdown time


    EXIT:

        0   -- OK, dirty bit not set on drive or bit not checked
        1   -- OK, and dirty bit set on at least one drive
        2   -- Error

Author:

    Matthew Bradburn (MattBr)  19-Aug-1996


--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "ifssys.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "autoreg.hxx"
#include "chkntfs.hxx"
#include "mpmap.hxx"
#include "volume.hxx"

DEFINE_CONSTRUCTOR(CHKNTFS, PROGRAM);

BOOLEAN
CHKNTFS::Initialize(
    )

/*++

Routine Description:

    Initializes an object of class CHKNTFS.  Called once when the program
    starts.


Arguments:

    None.

Return Value:

    BOOLEAN - Indicates whether the initialization succeeded.

--*/

{
    ARGUMENT_LEXEMIZER  arg_lex;
    ARRAY               lex_array;
    ARRAY               argument_array;
    STRING_ARGUMENT     program_name_argument;

    FLAG_ARGUMENT       flag_restore_default;
    FLAG_ARGUMENT       flag_exclude;
    FLAG_ARGUMENT       flag_schedule_check;
    FLAG_ARGUMENT       flag_invalid;
    FLAG_ARGUMENT       flag_display_help;
    FLAG_ARGUMENT       flag_count_down_time;
    LONG_ARGUMENT       arg_count_down_time;

    ExitStatus = 0;

    PROGRAM::Initialize();

    if (!argument_array.Initialize()) {
        return FALSE;
    }

    if (!program_name_argument.Initialize("*")  ||
        !flag_restore_default.Initialize("/D")  ||
        !flag_exclude.Initialize("/X")          ||
        !flag_schedule_check.Initialize("/C")   ||
        !flag_count_down_time.Initialize("/T")  ||
        !arg_count_down_time.Initialize("/T:*") ||
        !flag_display_help.Initialize("/?")     ||
        !flag_invalid.Initialize("/*")          ||      // close comment */
        !_drive_arguments.Initialize("*", FALSE, TRUE)) {

        return FALSE;
    }

    if (!argument_array.Put(&program_name_argument) ||
        !argument_array.Put(&flag_display_help)     ||
        !argument_array.Put(&flag_restore_default)  ||
        !argument_array.Put(&flag_exclude)          ||
        !argument_array.Put(&flag_schedule_check)   ||
        !argument_array.Put(&flag_count_down_time)   ||
        !argument_array.Put(&arg_count_down_time)   ||
        !argument_array.Put(&flag_invalid)          ||
        !argument_array.Put(&_drive_arguments)) {

        return FALSE;
    }

    if (!lex_array.Initialize() ||
        !arg_lex.Initialize(&lex_array)) {

        return FALSE;
    }

    arg_lex.PutSwitches("/");
    arg_lex.PutStartQuotes("\"");
    arg_lex.PutEndQuotes("\"");
    arg_lex.PutSeparators(" \"\t");
    arg_lex.SetCaseSensitive(FALSE);

    if (!arg_lex.PrepareToParse()) {

        DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);

        return FALSE;
    }

    if (!arg_lex.DoParsing(&argument_array)) {

        if (flag_invalid.QueryFlag()) {

            DisplayMessage(MSG_CHKNTFS_INVALID_SWITCH, NORMAL_MESSAGE,
                           "%W", flag_invalid.GetLexeme());

        } else {

            DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);
        }

        return FALSE;

    } else if (_drive_arguments.WildCardExpansionFailed()) {

        DisplayMessage(MSG_CHKNTFS_NO_WILDCARDS);
        return FALSE;
    }

    if (flag_invalid.QueryFlag()) {

        DisplayMessage(MSG_CHKNTFS_INVALID_SWITCH);
        return FALSE;
    }

    if (flag_display_help.QueryFlag()) {

        DisplayMessage(MSG_CHKNTFS_USAGE);
        return FALSE;
    }

    _restore_default = flag_restore_default.QueryFlag();
    _exclude = flag_exclude.QueryFlag();
    _schedule_check = flag_schedule_check.QueryFlag();
    _display_count_down_time = flag_count_down_time.IsValueSet();
    _set_count_down_time = arg_count_down_time.IsValueSet() ?
                            arg_count_down_time.QueryLong() : -1;
    _count_down_time = _display_count_down_time || arg_count_down_time.IsValueSet();

    if (_restore_default + _exclude + _schedule_check + _count_down_time > 1) {

        DisplayMessage(MSG_CHKNTFS_ARGS_CONFLICT);
        return FALSE;
    }

    if (0 == _drive_arguments.QueryPathCount() &&
        !(_restore_default || _count_down_time)) {

        DisplayMessage(MSG_CHKNTFS_REQUIRES_DRIVE);
        return FALSE;
    }

    if ((_restore_default || _count_down_time)
        && _drive_arguments.QueryPathCount() > 0) {

        DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);
        return FALSE;
    }

    if (_count_down_time && arg_count_down_time.IsValueSet() &&
        (arg_count_down_time.QueryLong() > MAX_AUTOCHK_TIMEOUT_VALUE ||
         arg_count_down_time.QueryLong() < 0)) {

        DisplayMessage(MSG_CHKNTFS_INVALID_AUTOCHK_COUNT_DOWN_TIME,
                       NORMAL_MESSAGE, "%d%d",
                       MAX_AUTOCHK_TIMEOUT_VALUE, AUTOCHK_TIMEOUT);
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
CHKNTFS::CheckNtfs(
    )
/*++

Routine Description:

    Look at the arguments specified by the user and do what
    he wants.

Arguments:

    None.

Return Value:

    BOOLEAN -- success or failure.

--*/
{
    DSTRING             volume_name;
    PATH                fullpath;
    DSTRING             drive_path_string;
    PATH_ANALYZE_CODE   rst;

    MOUNT_POINT_MAP     drive_array_map;
    PMOUNT_POINT_TUPLE  mptuple;

    PARRAY              drive_array;
    PARRAY_ITERATOR     iterator;
    PPATH               current_drive;
    PCWSTRING           display_drive_string;
    PCWSTRING           dos_volume_name;
    PCWSTRING           dos_drive_name;
    DSTRING             nt_drive_name;
    DSTRING             ntfs_str;
    DSTRING             fat_str;
    DSTRING             fat32_str;
    DSTRING             fs_name;
    DSTRING             fs_name_and_version;
    BOOLEAN             is_dirty = 0;
    DSTRING             cmd_line;
    ULONG               old_error_mode;
    DRIVE_TYPE          drive_type;
    DP_DRIVE            dpdrive;

    if (_restore_default) {

        //  Remove all autochk commands and insert the
        //  default entry into the registry.

        if (!cmd_line.Initialize("autocheck autochk") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {

            return FALSE;
        }
        if (!cmd_line.Initialize("autocheck autochk *") ||
            !AUTOREG::AddEntry(&cmd_line)) {

            return FALSE;
        }

        return TRUE;
    }

    if (_count_down_time) {

        ULONG   timeout;

        if (_display_count_down_time) {
            if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
                timeout = AUTOCHK_TIMEOUT;
            }
            DisplayMessage(MSG_CHKNTFS_AUTOCHK_COUNT_DOWN_TIME,
                           NORMAL_MESSAGE, "%d", timeout);
            return TRUE;

        } else if (_set_count_down_time >= 0) {

            if (!VOL_LIODPDRV::SetAutochkTimeOut(_set_count_down_time)) {
                DisplayMessage(MSG_CHKNTFS_AUTOCHK_SET_COUNT_DOWN_TIME_FAILED,
                               NORMAL_MESSAGE, "%d", _set_count_down_time);
            }

            return TRUE;
        }

        DebugAssert(FALSE);
        return FALSE;
    }

    if (!ntfs_str.Initialize("NTFS") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32"))
        return FALSE;

    if (!drive_array_map.Initialize()) {
        DebugPrint("Unable to initialize drive_array_map.\n");
        return FALSE;
    }

    drive_array = _drive_arguments.GetPathArray();
    iterator = (PARRAY_ITERATOR)drive_array->QueryIterator();
    iterator->Reset();

    //
    //  Run through the arguments here and translate each of
    //  them into their ultimate volume names, and mount points.
    //  Build an array of tuple consists of the mount point,
    //  volume name, and original drive specification tuple.

    while (NULL != (current_drive = (PPATH)iterator->GetNext())) {

        display_drive_string = current_drive->GetPathString();

        rst = current_drive->AnalyzePath(&volume_name,
                                         &fullpath,
                                         &drive_path_string);

        switch (rst) {
            case PATH_OK:
            case PATH_COULD_BE_FLOPPY:
                if (drive_path_string.QueryChCount() != 0) {
                    DisplayMessage(MSG_CHKNTFS_BAD_ARG, NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

                mptuple = (PMOUNT_POINT_TUPLE)NEW MOUNT_POINT_TUPLE;
                if (mptuple == NULL ||
                    !mptuple->_DeviceName.Initialize(display_drive_string) ||
                    !mptuple->_VolumeName.Initialize(&volume_name) ||
                    !mptuple->_DriveName.Initialize(fullpath.GetPathString())) {
                    DebugPrint("Out of memory.\n");
                    DELETE(mptuple);
                    DELETE(iterator);
                    return FALSE;
                }
                if (!drive_array_map.Put(mptuple)) {
                    DebugPrint("Unable to put away an object.\n");
                    DELETE(mptuple);
                    DELETE(iterator);
                    return FALSE;
                }
                break;

            case PATH_OUT_OF_MEMORY:
                DebugPrint("Out of memory.\n");
                DELETE(iterator);
                return FALSE;

            case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
                DisplayMessage(MSG_CHKNTFS_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
                               NORMAL_MESSAGE, "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            default:
                DisplayMessage(MSG_CHKNTFS_BAD_ARG, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;
        }
    }
    DELETE(iterator);

    iterator = (PARRAY_ITERATOR)drive_array_map.QueryIterator();
    iterator->Reset();

    //
    //  Run through the tuples here and make sure they're all
    //  valid drive names.
    //

    while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

        display_drive_string = &(mptuple->_DeviceName);
        dos_volume_name = &(mptuple->_VolumeName);

        old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

        drive_type = SYSTEM::QueryDriveType(dos_volume_name);

        SetErrorMode(old_error_mode);

        switch (drive_type) {
            case UnknownDrive:
                DisplayMessage(MSG_CHKNTFS_NONEXISTENT_DRIVE, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RemoteDrive:
                DisplayMessage(MSG_CHKNTFS_NO_NETWORK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RamDiskDrive:
                DisplayMessage(MSG_CHKNTFS_NO_RAMDISK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RemovableDrive:

                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }

                old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

                if (!dpdrive.Initialize(&nt_drive_name)) {

                    SetErrorMode(old_error_mode);

                    DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

                SetErrorMode(old_error_mode);

                if (dpdrive.IsFloppy()) {
                    DisplayMessage(MSG_CHKNTFS_FLOPPY_DRIVE, NORMAL_MESSAGE, "%W",
                                   display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

            default:
                break;
        }
    }

    iterator->Reset();

    if (_exclude) {

        DSTRING     cmd_line2;
        DSTRING     option;

        //  Remove all previous autochk commands, if any.

        if (!cmd_line.Initialize("autocheck autochk *") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {
            DELETE(iterator);
            return FALSE;
        }

        if (!cmd_line.Initialize("autocheck autochk /k:") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {
            DELETE(iterator);
            return FALSE;
        }

        if (!cmd_line.Initialize("autocheck autochk") ||
            !option.Initialize(" /k:") ||
            !cmd_line2.Initialize("autocheck autochk")) {
            DELETE(iterator);
            return FALSE;
        }

        //
        //  Collect a list of drives to be excluded and add them to the
        //  command line
        //

        while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

            display_drive_string = &(mptuple->_DeviceName);
            dos_volume_name = &(mptuple->_VolumeName);
            dos_drive_name = &(mptuple->_DriveName);

            //  Warn the user if the filesystem is not NTFS.

            if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                       &nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name,
                                                NULL, &fs_name_and_version)) {

                DisplayMessage(MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE,
                               "%W", &fs_name);
            }

            if (!AUTOREG::DeleteEntry(&cmd_line2, &nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (dos_drive_name->QueryChCount() == 2) {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (!AUTOREG::DeleteEntry(&cmd_line2, &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (!cmd_line.Strcat(&option) ||
                    !cmd_line.Strcat(dos_drive_name->QueryString(0, 1))) {
                    DELETE(iterator);
                    return FALSE;
                }
            } else {
                if (!cmd_line.Strcat(&option) ||
                    !cmd_line.Strcat(dos_volume_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
            }
        }

        DELETE(iterator);

        DSTRING star;

        if (!star.Initialize(" *") ||
            !cmd_line.Strcat(&star)) {
            return FALSE;
        }

        //  Add the new command line.

        return AUTOREG::AddEntry(&cmd_line);
    }

    //
    //  This loop handles the "schedule check" and default actions.
    //


    while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

        display_drive_string = &(mptuple->_DeviceName);
        dos_volume_name = &(mptuple->_VolumeName);
        dos_drive_name = &(mptuple->_DriveName);

        if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                   &nt_drive_name)) {
            DELETE(iterator);
            return FALSE;
        }

        //
        //  Schedule check:  Put a line in the registry like
        //  "autocheck autochk \??\X:" for each command-line argument.
        //

        if (_schedule_check) {

            if (!IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name, NULL)) {

                DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;
            }

            if (fs_name == ntfs_str ||
                fs_name == fat_str ||
                fs_name == fat32_str) {

                if (!cmd_line.Initialize("autocheck autochk") ||
                    !AUTOREG::DeleteEntry(&cmd_line, &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }

                if (dos_drive_name->QueryChCount() == 2) {
                    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                               &nt_drive_name)) {
                        DELETE(iterator);
                        return FALSE;
                    }
                    if (!cmd_line.Initialize("autocheck autochk") ||
                        !AUTOREG::DeleteEntry(&cmd_line, &nt_drive_name)) {
                        DELETE(iterator);
                        return FALSE;
                    }
                }

                if (!cmd_line.Initialize("autocheck autochk /m ") ||
                    !cmd_line.Strcat(&nt_drive_name) ||
                    !AUTOREG::PushEntry(&cmd_line)) {
                    DELETE(iterator);
                    return FALSE;
                }
            } else {
                DisplayMessage(MSG_CHKNTFS_SKIP_DRIVE_RAW, NORMAL_MESSAGE,
                               "%W", display_drive_string);
            }

            continue;
        }

        //
        //  Default:  check to see if the volume is dirty.
        //

        if (IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name,
                                            NULL, &fs_name_and_version)) {

            DisplayMessage(MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE,
                           "%W", &fs_name);

        }

        if (!IFS_SYSTEM::IsVolumeDirty(&nt_drive_name, &is_dirty)) {

            DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                           "%W", display_drive_string);
            DELETE(iterator);
            return FALSE;

        }

        if (is_dirty) {

            DisplayMessage(MSG_CHKNTFS_DIRTY, NORMAL_MESSAGE,
                           "%W", display_drive_string);

            ExitStatus = 1;

        } else {

            DSTRING     cmd_line2;

            if (!cmd_line.Initialize("autocheck autochk") ||
                !cmd_line2.Initialize(" ") ||
                !cmd_line2.Strcat(&nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (AUTOREG::IsFrontEndPresent(&cmd_line, &nt_drive_name)) {
                DisplayMessage(MSG_CHKNTFS_CHKDSK_WILL_RUN,
                               NORMAL_MESSAGE,
                               "%W", display_drive_string);
                continue;
            } else if (dos_drive_name->QueryChCount() == 2) {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (AUTOREG::IsFrontEndPresent(&cmd_line, &nt_drive_name)) {
                    DisplayMessage(MSG_CHKNTFS_CHKDSK_WILL_RUN,
                                   NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    continue;
                }
            }
            DisplayMessage(MSG_CHKNTFS_CLEAN, NORMAL_MESSAGE,
                           "%W", display_drive_string);
        }
    }

    DELETE(iterator);
    return TRUE;
}

VOID __cdecl
main()
{
    DEFINE_CLASS_DESCRIPTOR(CHKNTFS);

    {
        CHKNTFS     ChkNtfs;

        if (!ChkNtfs.Initialize() ||
            !ChkNtfs.CheckNtfs()) {

            exit(2);
        }

        exit(ChkNtfs.ExitStatus);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cipher\support.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    Support.h

Abstract:

    Support routine interfaces

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994
    Robert  Reichel     [RobertRe]      01-Apr-1997

Revision History:


--*/

extern VOID
ArrangeCommandLine(
    PTCHAR **pargv,
    int *pargc
    );

extern BOOLEAN
IsNtldr(
    PTCHAR pch
    );

extern BOOLEAN
IsUncRoot(
    PTCHAR pch
    );

extern VOID
DisplayMsg(DWORD MsgNum, ... );

extern VOID
DisplayErr(PTCHAR Prefix, DWORD MsgNum, ... );


extern DWORD
GetResourceString(LPWSTR *OutStr, DWORD MsgNum, ...);

extern VOID
InitializeIoStreams();

extern DWORD
MySetThreadUILanguage(DWORD dwParam);

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

extern ULONG
FormatFileSize(
    IN  PLARGE_INTEGER FileSize,
    IN  DWORD          Width,
    OUT PTCHAR         FormattedSize,
    IN  BOOLEAN        WithCommas
    );

extern
PTOKEN_USER
GetTokenUser(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cipher\cipher.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cipher.c

Abstract:

    This module implements the encryption utility for encrypted
    NTFS files.

Author:

    Robert Reichel     [RobertRe]        28-Feb-1997
    Robert Gu          [RobertG]         24-Mar-1998

Revision History:

    Code reused from compact.exe, file compression utility


--*/

//
// Include the standard header files.
//

//#define UNICODE
//#define _UNICODE

#include <windows.h>
#include <stdio.h>

#include <winioctl.h>
#include <shellapi.h>
#include <winefs.h>
#include <malloc.h>

#include <rc4.h>
#include <randlib.h>    // NewGenRandom() - Win2k and whistler
#include <rpc.h>
#include <wincrypt.h>

#include "support.h"
#include "msg.h"

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

//
//  FIRST_COLUMN_WIDTH - When encrypting files, the width of the output
//  column which displays the file name
//

#define FIRST_COLUMN_WIDTH  (20)
#define ENUMPATHLENGTH      (4096)
#define DosDriveLimitCount  (26)

#define PASSWORDLEN         1024
#define UserChooseYes       0
#define UserChooseNo        1
#define ChoiceNotDefined    3

#define KEYPATH  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\EFS\\CurrentKeys")
#define KEYPATHROOT HKEY_CURRENT_USER
#define CERT_HASH      TEXT("CertificateHash")

#define WIPING_DIR  TEXT("EFSTMPWP\\")

#define RANDOM_BYTES(pv, cb)    NewGenRandom(NULL, NULL, pv, cb)

#define YEARCOUNT (LONGLONG) 10000000*3600*24*365 // One Year's tick count

//
// Local data structure
//

typedef struct _CIPHER_VOLUME_INFO {
    LPWSTR      VolumeName[DosDriveLimitCount];
    LPWSTR      DosDeviceName[DosDriveLimitCount];
} CIPHER_VOLUME_INFO, *PCIPHER_VOLUME_INFO;

//
//
// definitions for initializing and working with random fill data.
//

typedef struct {
    RC4_KEYSTRUCT       Key;
    CRITICAL_SECTION    Lock;
    BOOL                LockValid;
    PBYTE               pbRandomFill;
    DWORD               cbRandomFill;
    LONG                cbFilled;
    BOOLEAN             fRandomFill;    // is fill randomized?
} SECURE_FILL_INFO, *PSECURE_FILL_INFO;

//  Local procedure types
//

typedef BOOLEAN (*PACTION_ROUTINE) (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    );

typedef VOID (*PFINAL_ACTION_ROUTINE) (
    );


//
//  Declare global variables to hold the command line information
//

BOOLEAN DoSubdirectories      = FALSE;      // recurse
BOOLEAN IgnoreErrors          = FALSE;      // keep going despite errs
BOOLEAN UserSpecifiedFileSpec = FALSE;
BOOLEAN ForceOperation        = FALSE;      // encrypt/decrypt even if already so
BOOLEAN Quiet                 = FALSE;      // be less verbose
BOOLEAN DisplayAllFiles       = FALSE;      // dsply hidden, system?
BOOLEAN DoFiles               = FALSE;      // operation for files "/a"
BOOLEAN SetUpNewUserKey       = FALSE;      // Set up new user key
BOOLEAN RefreshUserKeyOnFiles = FALSE;      // Refresh User Key on EFS files
BOOLEAN DisplayFilesOnly      = FALSE;      // Do not refresh $EFS, just display the file names
BOOLEAN FillUnusedSpace       = FALSE;      // Fill unused disk space with random data
BOOLEAN GenerateDRA           = FALSE;      // Generate Data Recovery Certificate files
BOOLEAN ExportEfsCert         = FALSE;      // Export EFS certificate and keys to a PFX file
TCHAR   StartingDirectory[MAX_PATH];        // parameter to "/s"
ULONG   AttributesNoDisplay = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;

BOOLEAN DisplayUseOptionW     = FALSE;

//
//  Declare global variables to hold encryption statistics
//

LARGE_INTEGER TotalDirectoryCount;
LARGE_INTEGER TotalFileCount;

TCHAR Buf[1024];                            // for displaying stuff

SECURE_FILL_INFO    GlobalSecureFill;
BOOLEAN             GlobalSecureFillInitialized;

#if 0
#define TestOutPut
#endif

//
//  Now do the routines to list the encryption state and size of
//  a file and/or directory
//

BOOLEAN
DisplayFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    TCHAR PrintState;


    //
    //  Decide if the file is compressed and if so then
    //  get the compressed file size.
    //

    if (FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        PrintState = 'E';

    } else {

        PrintState = 'U';
    }

    //
    //  Print out the encryption state and file name
    //  The following swprintf should be safe. Any one component of the file path could not
    //  be longer than MAX_PATH. That means lstrlen(FindData->cFileName) <= MAX_PATH
    //  Buf holds 1024 TCHARs.
    //

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

        swprintf(Buf, TEXT("%c %s"), PrintState, FindData->cFileName);
        DisplayMsg(CIPHER_THROW_NL, Buf);
    }

    TotalFileCount.QuadPart += 1;

    return TRUE;
}



BOOLEAN
DoListAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    //
    //  List the encryption attribute for the directory
    //

    {
        ULONG Attributes;

        Attributes = GetFileAttributes( DirectorySpec );

        if (0xFFFFFFFF == Attributes) {

            if (!Quiet || !IgnoreErrors) {

                //
                // Refrain from displaying error only when in quiet
                // mode *and* we're ignoring errors.
                //

                DisplayErr(DirectorySpec, GetLastError());
            }

            if (!IgnoreErrors) {
                return FALSE;
            }
        } else {

            if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
                DisplayMsg(CIPHER_LIST_EDIR, DirectorySpec);
            } else {
                DisplayMsg(CIPHER_LIST_UDIR, DirectorySpec);
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and list its encryption state
    //

    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        //
        //  Make sure we don't try any paths that are too long for us
        //  to deal with.
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

            lstrcpy( DirectorySpecEnd, FileSpec );

            FindHandle = FindFirstFile( DirectorySpec, &FindData );

            if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  append the found file to the directory spec and open the
                   //  file
                   //

                   if (0 == lstrcmp(FindData.cFileName, TEXT("..")) ||
                       0 == lstrcmp(FindData.cFileName, TEXT("."))) {
                       continue;
                   }

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirectorySpec) +
                       lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                       continue;
                   }

                   lstrcpy( DirectorySpecEnd, FindData.cFileName );

                   //
                   //  Now print out the state of the file
                   //

                   DisplayFile( DirectorySpec, &FindData );

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  For if we are to do subdirectores then we will look for every
    //  subdirectory and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoListAction( DirectorySpec, FileSpec )) {

                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalListAction (
    )
{
    return;
}


BOOLEAN
EncryptAFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )

{
    USHORT State = 1;
    ULONG i;
    BOOL Success;
    double f = 1.0;

    //
    // ForceOperation actually doesn't do anything. EncryptFile() will not encrypt an EFS file.
    // A legacy option from compact.
    //

    if ((FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
        !ForceOperation) {

        return TRUE;
    }


    if ( (0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) && (!DoFiles)) {

        //
        // Skip the files
        //

        return TRUE;
    }


    Success = EncryptFile( FileSpec );

    if (!Success) {

        if (Quiet && IgnoreErrors) {
            return TRUE;
        }

        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(CIPHER_THROW, Buf);
        }

        DisplayMsg(CIPHER_ERR);

        if (!Quiet && !IgnoreErrors) {
            if (ERROR_INVALID_FUNCTION == GetLastError()) {

                // This error is caused by doing the fsctl on a
                // non-encrypting volume.

                DisplayMsg(CIPHER_WRONG_FILE_SYSTEM, FindData->cFileName);

            } else {
                DisplayErr(FindData->cFileName, GetLastError());
            }
        }

        return IgnoreErrors;
    }

    if (!DisplayUseOptionW && ( 0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))){

        DisplayUseOptionW = TRUE;

    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(CIPHER_THROW, Buf);
        }

        DisplayMsg(CIPHER_OK);
    }

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoEncryptAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll set the encryption bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        USHORT State = 1;
        ULONG Length;

        DisplayMsg(CIPHER_ENCRYPT_DIR, DirectorySpec);

        if (!EncryptFile( DirectorySpec )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(CIPHER_ERR);
            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            return IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(CIPHER_OK);
        }

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be encrypting within and say what its
    //  current encryption attribute is.
    //

    {
        ULONG Attributes;

        Attributes = GetFileAttributes( DirectorySpec );

        //
        //  DirectorySpec could be passed in from the user. It could be bogus.
        //

        if (-1 == Attributes) {
            DisplayErr(DirectorySpec, GetLastError());
            return FALSE;
        }

        if ( DoFiles ) {

            if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {


                DisplayMsg(CIPHER_ENCRYPT_EDIR, DirectorySpec);

            } else {

                DisplayMsg(CIPHER_ENCRYPT_UDIR, DirectorySpec);

            }

        } else {

            if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {


                DisplayMsg(CIPHER_ENCRYPT_EDIR_NF, DirectorySpec);

            } else {

                DisplayMsg(CIPHER_ENCRYPT_UDIR_NF, DirectorySpec);

            }

        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and encrypt it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ( (DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //


                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Hack hack, kludge kludge.  Refrain from compressing
                       //  files named "\NTDLR" to help users avoid hosing
                       //  themselves.
                       //

                       if (IsNtldr(DirectorySpec)) {

                           if (!Quiet) {
                               DisplayMsg(CIPHER_SKIPPING, DirectorySpecEnd);
                           }

                           continue;
                       }

                       EncryptAFile( DirectorySpec, &FindData );

                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoEncryptAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalEncryptAction (
    )
{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    if ( DoFiles ) {
        DisplayMsg(CIPHER_ENCRYPT_SUMMARY, FileCount, DirectoryCount);
        if (DisplayUseOptionW) {
            DisplayMsg(CIPHER_USE_W);
        }
    } else {
        DisplayMsg(CIPHER_ENCRYPT_SUMMARY_NF, FileCount, DirectoryCount);
    }
    return;

}


BOOLEAN
DecryptAFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    USHORT State = 0;
    ULONG Length;

    if (!(FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
        !ForceOperation) {

        return TRUE;
    }


    if ( (0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) && (!DoFiles)) {

        //
        // Skip the files
        //

        return TRUE;
    }

    if (!DecryptFile(FileSpec, 0L )) {

        if (!Quiet || !IgnoreErrors) {

            swprintf(Buf, TEXT("%s "), FindData->cFileName);
            DisplayMsg(CIPHER_THROW, Buf);

            DisplayMsg(CIPHER_ERR);

            if (!Quiet && !IgnoreErrors) {

                if (ERROR_INVALID_FUNCTION == GetLastError()) {

                    // This error is caused by doing the fsctl on a
                    // non-compressing volume.

                    DisplayMsg(CIPHER_WRONG_FILE_SYSTEM, FindData->cFileName);

                } else {
                    DisplayErr(FindData->cFileName, GetLastError());
                }
            }
        }
        return IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        DisplayMsg(CIPHER_OK);
    }

    //
    //  Increment our running total
    //

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoDecryptAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll clear the encryption bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 0;
        ULONG Length;

        DisplayMsg(CIPHER_DECRYPT_DIR, DirectorySpec);

        if (!DecryptFile( DirectorySpec, 0L )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(CIPHER_ERR);

            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }

            return IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(CIPHER_OK);
        }


        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be uncompressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        Attributes = GetFileAttributes( DirectorySpec );

        //
        //  DirectorySpec could be passed in from the user. It could be bogus.
        //

        if (-1 == Attributes) {
            DisplayErr(DirectorySpec, GetLastError());
            return FALSE;
        }

        if ( DoFiles) {

            if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

                DisplayMsg(CIPHER_DECRYPT_EDIR, DirectorySpec);

            } else {

                DisplayMsg(CIPHER_DECRYPT_UDIR, DirectorySpec);
            }

        } else {

            if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

                DisplayMsg(CIPHER_DECRYPT_EDIR_NF, DirectorySpec);

            } else {

                DisplayMsg(CIPHER_DECRYPT_UDIR_NF, DirectorySpec);
            }

        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and uncompress it
    //

    {
        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Now decrypt the file
                       //

                       DecryptAFile( DirectorySpec, &FindData );

                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );
           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoDecryptAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalDecryptAction (
    )

{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    if (DoFiles) {
        DisplayMsg(CIPHER_DECRYPT_SUMMARY, FileCount, DirectoryCount);
    } else {
        DisplayMsg(CIPHER_DECRYPT_SUMMARY_NF, FileCount, DirectoryCount);
    }

    return;
}


VOID
CipherConvertHashToStr(
    IN PBYTE pHashData,
    IN DWORD cbData,
    OUT LPWSTR OutHashStr
    )
{

    DWORD Index = 0;
    BOOLEAN NoLastZero = FALSE;

    for (; Index < cbData; Index+=2) {

        BYTE HashByteLow = pHashData[Index] & 0x0f;
        BYTE HashByteHigh = (pHashData[Index] & 0xf0) >> 4;

        OutHashStr[Index * 5/2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
        OutHashStr[Index * 5/2 + 1] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);

        if (Index + 1 < cbData) {
            HashByteLow = pHashData[Index+1] & 0x0f;
            HashByteHigh = (pHashData[Index+1] & 0xf0) >> 4;
    
            OutHashStr[Index * 5/2 + 2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
            OutHashStr[Index * 5/2 + 3] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);
    
            OutHashStr[Index * 5/2 + 4] = L' ';

        } else {
            OutHashStr[Index * 5/2 + 2] = 0;
            NoLastZero = TRUE;
        }

    }

    if (!NoLastZero) {
        OutHashStr[Index*5/2] = 0;
    }

}

VOID
CipherDisplayCrntEfsHash(
    )
{

    DWORD rc;
    HKEY hRegKey = NULL;
    PBYTE pbHash;
    DWORD cbHash;

    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    if (!GetComputerName ( LocalComputerName, &nSize )){

        //
        //  This is not likely to happen.
        //

        return;
    }

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             KEYPATH,
             0,
             GENERIC_READ,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                &cbHash
                );

        if (rc == ERROR_SUCCESS) {

            //
            // Query out the thumbprint, find the cert, and return the key information.
            //

            if (pbHash = (PBYTE)malloc( cbHash )) {

                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        pbHash,
                        &cbHash
                        );


                if (rc == ERROR_SUCCESS) {
            
                    LPWSTR OutHash;


                    OutHash = (LPWSTR) malloc(((((cbHash + 1)/2) * 5)+1) * sizeof(WCHAR));
                    if (OutHash) {
                
                        CipherConvertHashToStr(pbHash, cbHash, OutHash);
                        DisplayMsg(CIPHER_CURRENT_CERT, LocalComputerName, OutHash);
                        free(OutHash);
                
                    }
                }
                free(pbHash);
            }
        }
        RegCloseKey( hRegKey );
    }
    return;
}

BOOL
CipherConvertToDriveLetter(
    IN OUT LPWSTR VolBuffer, 
    IN     PCIPHER_VOLUME_INFO VolumeInfo
    )
{
    WCHAR DeviceName[MAX_PATH];
    WORD DriveIndex = 0;

    while (DriveIndex < DosDriveLimitCount) {
        if (VolumeInfo->VolumeName[DriveIndex]) {
            if (!wcscmp(VolBuffer, VolumeInfo->VolumeName[DriveIndex])) {
                lstrcpy(VolBuffer, TEXT("A:\\"));
                VolBuffer[0] += DriveIndex;
                return TRUE;
            }

            VolBuffer[48] = 0;
            if (VolumeInfo->DosDeviceName[DriveIndex] && QueryDosDevice( &(VolBuffer[4]), DeviceName, MAX_PATH)) {
    
                if (!wcscmp(DeviceName, VolumeInfo->DosDeviceName[DriveIndex])) {
                    lstrcpy(VolBuffer, TEXT("A:\\"));
                    VolBuffer[0] += DriveIndex;
                    return TRUE;
                }

    
            }
        }
        DriveIndex++;
    }

    return FALSE;

}

VOID
CipherTouchDirFiles(
    IN WCHAR *DirPath,
    IN PCIPHER_VOLUME_INFO VolumeInfo
    )
{
    
    PTCHAR DirectorySpecEnd;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    HANDLE hFile;


    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //


    DirectorySpecEnd = DirPath + lstrlen( DirPath );



    //
    //  setup the template for findfirst/findnext
    //

    if ((DirectorySpecEnd - DirPath)  < ENUMPATHLENGTH - 2* sizeof(WCHAR)) {

       lstrcpy( DirectorySpecEnd, TEXT("*") );

       FindHandle = FindFirstFile( DirPath, &FindData );

       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries
               //

               if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirPath) +
                            lstrlen( FindData.cFileName ) >= ENUMPATHLENGTH ) {

                       continue;
                   }

                   if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (FindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //
    
                       lstrcpy( DirectorySpecEnd, FindData.cFileName );
    
                       //
                       //  Now touch the file
                       //

                       if (DisplayFilesOnly) {
                           DisplayMsg(CIPHER_THROW_NL, DirPath);
                       } else {

                           hFile = CreateFileW(
                                        DirPath,
                                        GENERIC_READ,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL
                                        );
    
                           if ( INVALID_HANDLE_VALUE != hFile ){
    
                               DisplayMsg(CIPHER_TOUCH_OK, DirPath);
    
                               CloseHandle(hFile);
    
                           } else {
    
                               DisplayErr(DirPath, GetLastError());
    
                           }
                       }
    
                   }

               }

           } while ( FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    }


    //
    //  Setup findfirst/findnext to search the sub directory
    //

    if ((DirectorySpecEnd - DirPath)  < ENUMPATHLENGTH - 2* sizeof(WCHAR)) {

       lstrcpy( DirectorySpecEnd, TEXT("*") );

       FindHandle = FindFirstFile( DirPath, &FindData );
       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries otherwise we'll recurse
               //  like mad
               //

               if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  If the entry is for a directory then we'll tack on the
                   //  subdirectory name to the directory spec and recursively
                   //  call otherselves
                   //

                   if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                       BOOL  b;
                       WCHAR MountVolName[MAX_PATH];

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirPath) +
                           lstrlen( TEXT("\\") ) +
                           lstrlen( FindData.cFileName ) >= ENUMPATHLENGTH ) {

                           continue;
                       }

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );
                       lstrcat( DirectorySpecEnd, TEXT("\\") );

                       //
                       // Check if this DIR point to another volume
                       //


                       b = GetVolumeNameForVolumeMountPoint(DirPath, MountVolName, MAX_PATH);
                       if (b) {
                           if (CipherConvertToDriveLetter(MountVolName, VolumeInfo)){
                               continue;
                           }
                       }

                       CipherTouchDirFiles(DirPath, VolumeInfo);

                   }
               }

           } while ( FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    }

}

DWORD
CipherTouchEncryptedFiles(
                          )
{

    WCHAR  VolBuffer[MAX_PATH];
    WCHAR  *SearchPath = NULL;
    HANDLE SearchHandle;
    BOOL   SearchNext = TRUE;
    CIPHER_VOLUME_INFO VolumeInfo;
    LPWSTR VolumeNames;
    LPWSTR VolumeNamesCrnt;
    LPWSTR DosDeviceNames;
    LPWSTR DosDeviceNamesCrnt;
    DWORD  DriveIndex = 0;
    WCHAR  TmpChar;
    BOOL   b;

    VolumeNames = (LPWSTR) malloc ( DosDriveLimitCount * MAX_PATH * sizeof(WCHAR) );
    DosDeviceNames = (LPWSTR) malloc ( DosDriveLimitCount * MAX_PATH * sizeof(WCHAR) );

    if ( !VolumeNames || !DosDeviceNames) {
        if (VolumeNames) {
            free(VolumeNames);
        }
        if (DosDeviceNames) {
            free(DosDeviceNames);
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Don't popup when query floopy and etc.
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);
    lstrcpy(VolBuffer, TEXT("A:\\"));
    VolumeNamesCrnt = VolumeNames;
    DosDeviceNamesCrnt = DosDeviceNames;

    //
    //  Get all the volume and device names which has a drive letter assigned
    //

    while (DriveIndex < DosDriveLimitCount) {

        b = GetVolumeNameForVolumeMountPoint( VolBuffer, 
                                              VolumeNamesCrnt, 
                                              (DWORD)(VolumeNames + DosDriveLimitCount * MAX_PATH - VolumeNamesCrnt));
        if (!b) {
            VolumeInfo.VolumeName[DriveIndex] = NULL;
            VolumeInfo.DosDeviceName[DriveIndex++] = NULL;
            VolBuffer[0]++;
            continue;
        }

        VolumeInfo.VolumeName[DriveIndex] = VolumeNamesCrnt;
        VolumeNamesCrnt += lstrlen(VolumeNamesCrnt) + 1;

        //
        //  The number 48 is copied from utils\mountvol\mountvol.c
        //

        TmpChar = VolumeInfo.VolumeName[DriveIndex][48];
        VolumeInfo.VolumeName[DriveIndex][48] = 0;
        if (QueryDosDevice( &(VolumeInfo.VolumeName[DriveIndex][4]), 
                            DosDeviceNamesCrnt, 
                            (DWORD)(DosDeviceNames + DosDriveLimitCount * MAX_PATH - DosDeviceNamesCrnt))) {

            VolumeInfo.DosDeviceName[DriveIndex] = DosDeviceNamesCrnt;
            DosDeviceNamesCrnt += lstrlen(DosDeviceNamesCrnt) + 1;

        } else {
            VolumeInfo.DosDeviceName[DriveIndex] = NULL;
        }

        VolumeInfo.VolumeName[DriveIndex][48] = TmpChar;
        VolBuffer[0]++;
        DriveIndex++;

    }


    SearchPath = (WCHAR *) malloc( ENUMPATHLENGTH * sizeof(WCHAR) );
    if (!SearchPath) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SearchHandle = FindFirstVolume(VolBuffer, MAX_PATH);

    if ( INVALID_HANDLE_VALUE != SearchHandle ) {

        if (DisplayFilesOnly) {

            DisplayMsg(CIPHER_ENCRYPTED_FILES, NULL);

        }

        while ( SearchNext ) {
    
            if (CipherConvertToDriveLetter(VolBuffer, &VolumeInfo)){

                //
                // Check if this volume is a NTFS volume
                //

                if(GetVolumeInformation(
                        VolBuffer, // Current root directory.
                        NULL, // Volume name.
                        0, // Volume name length.
                        NULL, // Serial number.
                        NULL, // Maximum length.
                        NULL,
                        SearchPath, // File system type.
                        MAX_PATH
                        )){
                    if(!wcscmp(SearchPath, TEXT("NTFS"))){
        
                        lstrcpy( SearchPath, VolBuffer );
                        CipherTouchDirFiles(SearchPath, &VolumeInfo);

                    }
                }
            }
            SearchNext =  FindNextVolume(SearchHandle, VolBuffer, MAX_PATH);

        }
        FindVolumeClose(SearchHandle);
    }

    free(SearchPath);
    free(VolumeNames);
    free(DosDeviceNames);
    return ERROR_SUCCESS;
}


BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    )
{
    BOOL b = FALSE;

    if (CryptEncodeObject(
          dwEncodingType,
          lpszStructType,
          pvStructInfo,
          NULL,
          pcbEncoded )) {

        *pbEncoded = (PBYTE)malloc( *pcbEncoded );

        if (*pbEncoded) {

            if (CryptEncodeObject(
                  dwEncodingType,
                  lpszStructType,
                  pvStructInfo,
                  *pbEncoded,
                  pcbEncoded )) {

                b = TRUE;

            } else {

                free( *pbEncoded );
                *pbEncoded = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( b );
}


BOOLEAN
CreateSelfSignedRecoveryCertificate(
    OUT PCCERT_CONTEXT * pCertContext,
    OUT LPWSTR *lpContainerName,
    OUT LPWSTR *lpProviderName
    )
/*++

Routine Description:

    This routine sets up and creates a self-signed certificate.

Arguments:


Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOLEAN fReturn = FALSE;
    DWORD rc = ERROR_SUCCESS;

    PBYTE  pbHash          = NULL;
    LPWSTR lpDisplayInfo   = NULL;

    HCRYPTKEY hKey = 0;
    HCRYPTPROV hProv = 0;
    GUID    guidContainerName;
    LPWSTR  TmpContainerName;

    RPC_STATUS RpcStatus = ERROR_SUCCESS;

    *pCertContext = NULL;
    *lpContainerName = NULL;
    *lpProviderName  = NULL;


    //
    // Create a key pair
    //

    //
    // Container name
    //


    RpcStatus = UuidCreate(&guidContainerName);

    if ( (ERROR_SUCCESS != RpcStatus) && (RPC_S_UUID_LOCAL_ONLY != RpcStatus) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(fReturn);
    }


    if (ERROR_SUCCESS == UuidToStringW(&guidContainerName, (unsigned short **)lpContainerName )) {

        //
        // Copy the container name into LSA heap memory
        //

        *lpProviderName = MS_DEF_PROV;

        //
        // Create the key container
        //

        if (CryptAcquireContext(&hProv, *lpContainerName, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET )) {

            if (CryptGenKey(hProv, AT_KEYEXCHANGE, RSA1024BIT_KEY | CRYPT_EXPORTABLE, &hKey)) {

                DWORD NameLength = 64;
                LPWSTR AgentName = NULL;

                //
                // Construct the subject name information
                //

                AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));
                if (AgentName){
                    if (!GetUserName(AgentName, &NameLength)){
                        free(AgentName);
                        AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));

                        //
                        // Try again with big buffer
                        //

                        if ( AgentName ){

                            if (!GetUserName(AgentName, &NameLength)){
                                rc = GetLastError();
                                free(AgentName);
                                AgentName = NULL;
                            }

                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (AgentName) {

                    LPCWSTR     DNNameTemplate = L"CN=%ws,L=EFS,OU=EFS File Encryption Certificate";
                    DWORD       cbDNName = 0;

                    cbDNName = (wcslen( DNNameTemplate ) + 1) * sizeof( WCHAR ) + (wcslen( AgentName ) + 1) * sizeof( WCHAR );
                    lpDisplayInfo = (LPWSTR)malloc( cbDNName );
                    if (lpDisplayInfo) {
                        swprintf( lpDisplayInfo, DNNameTemplate, AgentName );
                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    free(AgentName);
                    AgentName = NULL;

                }

                if (lpDisplayInfo) {

                    //
                    // Use this piece of code to create the PCERT_NAME_BLOB going into CertCreateSelfSignCertificate()
                    //

                    CERT_NAME_BLOB SubjectName;

                    SubjectName.cbData = 0;

                    if(CertStrToNameW(
                           CRYPT_ASN_ENCODING,
                           lpDisplayInfo,
                           0,
                           NULL,
                           NULL,
                           &SubjectName.cbData,
                           NULL)) {

                        SubjectName.pbData = (BYTE *) malloc(SubjectName.cbData);

                        if (SubjectName.pbData) {

                            if (CertStrToNameW(
                                    CRYPT_ASN_ENCODING,
                                    lpDisplayInfo,
                                    0,
                                    NULL,
                                    SubjectName.pbData,
                                    &SubjectName.cbData,
                                    NULL) ) {

                                //
                                // Make the enhanced key usage
                                //

                                CERT_ENHKEY_USAGE certEnhKeyUsage;
                                LPSTR lpstr;
                                CERT_EXTENSION certExt;

                                lpstr = szOID_EFS_RECOVERY;
                                certEnhKeyUsage.cUsageIdentifier = 1;
                                certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

                                // now call CryptEncodeObject to encode the enhanced key usage into the extension struct

                                certExt.Value.cbData = 0;
                                certExt.Value.pbData = NULL;
                                certExt.fCritical = FALSE;
                                certExt.pszObjId = szOID_ENHANCED_KEY_USAGE;

                                //
                                // Encode it
                                //

                                if (EncodeAndAlloc(
                                        CRYPT_ASN_ENCODING,
                                        X509_ENHANCED_KEY_USAGE,
                                        &certEnhKeyUsage,
                                        &certExt.Value.pbData,
                                        &certExt.Value.cbData
                                        )) {

                                    //
                                    // finally, set up the array of extensions in the certInfo struct
                                    // any further extensions need to be added to this array.
                                    //

                                    CERT_EXTENSIONS certExts;
                                    CRYPT_KEY_PROV_INFO KeyProvInfo;
                                    SYSTEMTIME  StartTime;
                                    FILETIME    FileTime;
                                    LARGE_INTEGER TimeData;
                                    SYSTEMTIME  EndTime;

                                    certExts.cExtension = 1;
                                    certExts.rgExtension = &certExt;


                                    memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));

                                    KeyProvInfo.pwszContainerName = *lpContainerName;
                                    KeyProvInfo.pwszProvName      = *lpProviderName;
                                    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
                                    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;


                                    GetSystemTime(&StartTime);
                                    SystemTimeToFileTime(&StartTime, &FileTime);
                                    TimeData.LowPart = FileTime.dwLowDateTime;
                                    TimeData.HighPart = (LONG) FileTime.dwHighDateTime;
                                    TimeData.QuadPart += YEARCOUNT * 100;
                                    FileTime.dwLowDateTime = TimeData.LowPart;
                                    FileTime.dwHighDateTime = (DWORD) TimeData.HighPart;

                                    FileTimeToSystemTime(&FileTime, &EndTime);

                                    *pCertContext = CertCreateSelfSignCertificate(
                                                       hProv,
                                                       &SubjectName,
                                                       0,
                                                       &KeyProvInfo,
                                                       NULL,
                                                       &StartTime,
                                                       &EndTime,
                                                       &certExts
                                                       );

                                    if (*pCertContext) {

                                        fReturn = TRUE;

                                    } else {

                                        rc = GetLastError();
                                    }

                                    free( certExt.Value.pbData );

                                } else {

                                    rc = GetLastError();
                                }

                            } else {

                                rc = GetLastError();
                            }

                            free( SubjectName.pbData );

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {

                        rc = GetLastError();
                    }

                    free( lpDisplayInfo );

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                CryptDestroyKey( hKey );

            } else {

                 rc = GetLastError();
            }

            CryptReleaseContext( hProv, 0 );
            hProv = 0;
            if (ERROR_SUCCESS != rc) {

                //
                // Creating cert failed. Let's delete the key container.
                //

                CryptAcquireContext(&hProv, *lpContainerName, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );
            }

        } else {

            rc = GetLastError();
        }

        if (ERROR_SUCCESS != rc) {
            RpcStringFree( (unsigned short **)lpContainerName );
            *lpContainerName = NULL;
        }
    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }


    if (!fReturn) {

        if (*pCertContext) {
            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;
        }
    }

    SetLastError( rc );
    return( fReturn );
}

BOOLEAN
GetPassword(
    OUT LPWSTR *PasswordStr
    )
/*++

Routine Description:

    Input a string from stdin in the Console code page.

    We can't use fgetws since it uses the wrong code page.

Arguments:

    Buffer - Buffer to put the read string into.
        The Buffer will be zero terminated and will have any traing CR/LF removed

Return Values:

    None.

--*/
{
    int size;
    LPSTR MbcsBuffer = NULL;
    LPSTR Result;
    DWORD Mode;
    DWORD MbcsSize;
    DWORD MbcsLength;

    //
    // Allocate a local buffer to read the string into
    //  Include room for the trimmed CR/LF
    //

    MbcsSize = (PASSWORDLEN+2) * sizeof(WCHAR);
    MbcsBuffer = (LPSTR) malloc((PASSWORDLEN+2) * sizeof(WCHAR));
    *PasswordStr = (LPWSTR) malloc((PASSWORDLEN+1) * sizeof(WCHAR));

    if ( (MbcsBuffer == NULL) || (*PasswordStr == NULL) ) {

        if (MbcsBuffer) {
            free (MbcsBuffer);
        }
        if (*PasswordStr) {
            free (*PasswordStr);
        }
        DisplayMsg(CIPHER_NO_MEMORY);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    DisplayMsg(CIPHER_PROMPT_PASSWORD);

    // turn off echo
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &Mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
          (~(ENABLE_ECHO_INPUT)) & Mode);

    Result = fgets( MbcsBuffer, MbcsSize, stdin  );

    if ( Result == NULL ) {
        SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), Mode);
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    DisplayMsg(CIPHER_CONFIRM_PASSWORD);
    Result = fgets( (LPSTR)*PasswordStr, (PASSWORDLEN+1) * sizeof(WCHAR), stdin  );

    // turn echo back on
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), Mode);
    _putws ( L"\n" );

    if (strcmp( (LPSTR) *PasswordStr, MbcsBuffer)){

        //
        //  Password not match.
        //
        
        DisplayMsg(CIPHER_PASSWORD_NOMATCH);
        free(MbcsBuffer);
        free (*PasswordStr);
        SetLastError(ERROR_INVALID_PASSWORD);
        *PasswordStr = NULL;
        return FALSE;
    }

    if ( Result == NULL ) {
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    //
    // Trim any trailing CR or LF char from the string
    //

    MbcsLength = lstrlenA( MbcsBuffer );
    if ( MbcsLength == 0 ) {
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    if ( MbcsBuffer[MbcsLength-1] == '\n' || MbcsBuffer[MbcsLength-1] == '\r' ) {
        MbcsBuffer[MbcsLength-1] = '\0';
        MbcsLength --;
    }


    //
    // Convert the string to UNICODE
    //
    size = MultiByteToWideChar( GetConsoleOutputCP(),
                                0,
                                MbcsBuffer,
                                MbcsLength+1,   // Include trailing zero
                                *PasswordStr,
                                PASSWORDLEN );
    free(MbcsBuffer);

    if ( size == 0 ) {
        DisplayErr(NULL, GetLastError());
        free (*PasswordStr);
        *PasswordStr = NULL;
        return FALSE;
    }
    return TRUE;

}

DWORD
PromtUserYesNo(
     IN LPWSTR FileName,
     OUT DWORD *UserChoice
     )
{
    BOOLEAN Continue = TRUE;
    LPWSTR Result;
    LPWSTR Yesnotext;
    DWORD TextLen;

    //
    //  File exists
    //

    *UserChoice = ChoiceNotDefined;

    MySetThreadUILanguage(0);

    TextLen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL, CIPHER_YESNOANSWER, 0, (LPVOID)&Yesnotext, 0, NULL);

    if (TextLen && Yesnotext) {

        while (TRUE) {

            WCHAR FirstChar;

            DisplayMsg(CIPHER_FILE_EXISTS, FileName);
            Result = fgetws((LPWSTR)Buf, sizeof(Buf)/sizeof (WCHAR), stdin);
            if (!Result) {

                //
                // Error or end of file. Just return.
                //

                LocalFree(Yesnotext);   
                return GetLastError();

            }

            //
            // Trim any trailing CR or LF char from the string
            //

            FirstChar = towupper(Buf[0]);
            if (Yesnotext[0] == FirstChar) {
                *UserChoice = UserChooseYes;
                break;
            } else if (Yesnotext[1] == FirstChar) {
                *UserChoice = UserChooseNo;
                break;
            }
        
        }

        LocalFree(Yesnotext);   

    } else {

        return GetLastError();

    }

    return ERROR_SUCCESS;

}


DWORD
GenerateCertFiles(
    IN  LPWSTR StartingDirectory
    )
{
    HCERTSTORE memStore;
    DWORD dwLastError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext;
    LPWSTR ContainerName;
    LPWSTR ProviderName;
    LPWSTR CertFileName;
    LPWSTR PfxPassword;


    if (!GetPassword( &PfxPassword )){
        return GetLastError();
    }
    
    memStore = CertOpenStore(
                         CERT_STORE_PROV_MEMORY,
                         0,
                         0,
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                         NULL
                         );

    //
    // 5 -- .PFX or .CER plus NULL
    //

    CertFileName = (LPWSTR)malloc((wcslen(StartingDirectory)+5) * sizeof(WCHAR));

    if (memStore && CertFileName) {

        //
        // Let's check if the files exist or not
        //

        wcscpy(CertFileName, StartingDirectory);
        wcscat(CertFileName, L".PFX");
        if (GetFileAttributes(CertFileName) != -1) {

            DWORD UserChoice;

            if (((dwLastError = PromtUserYesNo(CertFileName, &UserChoice)) != ERROR_SUCCESS) ||
                 (UserChoice != UserChooseYes)) {

                free(CertFileName);
                CertCloseStore( memStore, 0 );
                return dwLastError;

            }

        }

        wcscpy(CertFileName, StartingDirectory);
        wcscat(CertFileName, L".CER");
        if (GetFileAttributes(CertFileName) != -1) {

            DWORD UserChoice;

            if (((dwLastError = PromtUserYesNo(CertFileName, &UserChoice)) != ERROR_SUCCESS) ||
                 (UserChoice != UserChooseYes)) {

                free(CertFileName);
                CertCloseStore( memStore, 0 );
                return dwLastError;

            }

        }

        //
        // Generate the cert first
        //

        if (CreateSelfSignedRecoveryCertificate(&pCertContext, &ContainerName, &ProviderName)){

            HANDLE hFile;
            HCRYPTPROV hProv = 0;
            DWORD  BytesWritten = 0;

            //
            // We got the certificate. Let's generate the CER file first
            //

            hFile = CreateFileW(
                         CertFileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
            if ( INVALID_HANDLE_VALUE != hFile) {

                //
                // Let's write out the CER file
                //


                if(!WriteFile(
                        hFile,
                        pCertContext->pbCertEncoded,
                        pCertContext->cbCertEncoded,
                        &BytesWritten,
                        NULL
                        )){

                    dwLastError = GetLastError();
                } else {
                    DisplayMsg(CIPHER_CER_CREATED);
                }

                CloseHandle(hFile);

            } else {

                dwLastError = GetLastError();

            }

            if (CertAddCertificateContextToStore(memStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL)){

                CRYPT_DATA_BLOB PFX;

                memset( &PFX, 0, sizeof( CRYPT_DATA_BLOB ));

                //
                // Asking password
                //

                if (PFXExportCertStoreEx(
                        memStore,
                        &PFX,
                        PfxPassword,
                        NULL,
                        EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){

                    PFX.pbData = (BYTE *) malloc(PFX.cbData);

                    if (PFX.pbData) {

                        if (PFXExportCertStoreEx(
                                memStore,
                                &PFX,
                                PfxPassword,
                                NULL,
                                EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){

                            //
                            // Write out the PFX file
                            //
                            wcscpy(CertFileName, StartingDirectory);
                            wcscat(CertFileName, L".PFX");
                
                            hFile = CreateFileW(
                                         CertFileName,
                                         GENERIC_WRITE,
                                         0,
                                         NULL,
                                         CREATE_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL
                                         );

                            if ( INVALID_HANDLE_VALUE != hFile) {
                
                                //
                                // Let's write out the CER file
                                //
                
                
                                if(!WriteFile(
                                        hFile,
                                        PFX.pbData,
                                        PFX.cbData,
                                        &BytesWritten,
                                        NULL
                                        )){
                
                                    dwLastError = GetLastError();
                                }  else {
                                    DisplayMsg(CIPHER_PFX_CREATED);
                                }

                
                                CloseHandle(hFile);
                
                            } else {
                
                                dwLastError = GetLastError();
                
                            }

                        } else {

                            dwLastError = GetLastError();

                        }

                        free( PFX.pbData );

                    } else {

                        dwLastError = ERROR_NOT_ENOUGH_MEMORY;

                    }

                } else {

                    dwLastError = GetLastError();

                }
            }


            //
            // Let's delete the key
            //

            CertFreeCertificateContext(pCertContext);
            RpcStringFree( (unsigned short **)&ContainerName );
            CryptAcquireContext(&hProv, ContainerName, ProviderName, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );

        } else {
            dwLastError = GetLastError();
        }

        //
        // Close Store and free the 
        //

        free(CertFileName);
        CertCloseStore( memStore, 0 );

    } else {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (PfxPassword){
        free(PfxPassword);
    }

    if (ERROR_SUCCESS != dwLastError) {

        DisplayErr(NULL, dwLastError);

    }

    return dwLastError;
}

DWORD
SecureInitializeRandomFill(
    IN OUT  PSECURE_FILL_INFO   pSecureFill,
    IN      ULONG               FillSize,
    IN      PBYTE               FillValue   OPTIONAL
    )
/*++

    FillValue = NULL
    Use Random fill and random mixing logic.
    
    FillValue = valid pointer to fill byte
    Fill region with specified value, with no random mixing.


--*/

{
    DWORD dwLastError;

    __try {
        
        //
        // allocate the critical section.
        //

        InitializeCriticalSection( &pSecureFill->Lock );
    } __except (EXCEPTION_EXECUTE_HANDLER )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pSecureFill->LockValid = TRUE;

    pSecureFill->cbRandomFill = FillSize;
    pSecureFill->pbRandomFill = VirtualAlloc(
                                        NULL,
                                        FillSize,
                                        MEM_COMMIT,
                                        PAGE_READWRITE
                                        );

    if( pSecureFill->pbRandomFill != NULL )
    {
        BYTE RandomFill[256];
        
        
        if( FillValue != NULL )
        {
            memset( pSecureFill->pbRandomFill, *FillValue, pSecureFill->cbRandomFill );
            pSecureFill->fRandomFill = FALSE;
            return ERROR_SUCCESS;
        }
        
        //
        // initialize the region with initial random pad.
        //
        
        pSecureFill->fRandomFill = TRUE;

        RANDOM_BYTES( RandomFill, sizeof(RandomFill) );

        rc4_key( &pSecureFill->Key, sizeof(RandomFill), RandomFill );
        rc4( &pSecureFill->Key, pSecureFill->cbRandomFill, pSecureFill->pbRandomFill );

        //
        // initialize the key.
        //

        RANDOM_BYTES( RandomFill, sizeof(RandomFill) );
        rc4_key( &pSecureFill->Key, sizeof(RandomFill), RandomFill );

        ZeroMemory( RandomFill, sizeof(RandomFill) );
        
        return ERROR_SUCCESS;
    }

    
    dwLastError = GetLastError();

    DeleteCriticalSection( &pSecureFill->Lock );
    pSecureFill->LockValid = FALSE;

    return dwLastError;
}

VOID
SecureMixRandomFill(
    IN OUT  PSECURE_FILL_INFO   pSecureFill,
    IN      ULONG               cbBytesThisFill
    )
{
    LONG Result;
    LONG Compare;
     
    if( !pSecureFill->fRandomFill )
    {
        return;
    }
    
    //
    // update the fill once it has been used 8 times.
    //

    Compare = (LONG)(8 * pSecureFill->cbRandomFill);

    Result = InterlockedExchangeAdd(
                &pSecureFill->cbFilled,
                cbBytesThisFill
                );

    if( (Result+Compare) > Compare )
    {
        Result = 0;
        
        //
        // if there was a race condition, only one thread will update the random fill.
        //

        if( TryEnterCriticalSection( &pSecureFill->Lock ) )
        {
            rc4( &pSecureFill->Key, pSecureFill->cbRandomFill, pSecureFill->pbRandomFill );

            LeaveCriticalSection( &pSecureFill->Lock );
        }
    }
}

DWORD
SecureDeleteRandomFill(
    IN      PSECURE_FILL_INFO   pSecureFill
    )
{
    if( pSecureFill->pbRandomFill != NULL )
    {
        VirtualFree( pSecureFill->pbRandomFill, pSecureFill->cbRandomFill, MEM_RELEASE );
    }

    if( pSecureFill->LockValid )
    {
        DeleteCriticalSection( &pSecureFill->Lock );
    }

    ZeroMemory( pSecureFill, sizeof(*pSecureFill) );

    return ERROR_SUCCESS;
}

#define MaxFileNum 100000000
#define MaxDigit   9

HANDLE
CreateMyTempFile(
    LPWSTR TempPath
    )
{
    static DWORD TempIndex = 0;
    WCHAR TempFileName[MAX_PATH];
    WCHAR TempIndexString[MaxDigit+2];
    DWORD TempPathLength;
    HANDLE TempHandle;
    BOOLEAN ContinueSearch = TRUE;
    DWORD RetCode;

    if (wcslen(TempPath) >= (MAX_PATH - 3 - MaxDigit)) {

        //
        //  Path too long. This should not happen as the TempPath should be the root of the volume
        //

        SetLastError(ERROR_LABEL_TOO_LONG);

        return INVALID_HANDLE_VALUE;

    }

    wcscpy(TempFileName, TempPath);
    TempPathLength = wcslen(TempPath);

    while ( (TempIndex <= MaxFileNum) && ContinueSearch ) {

        wsprintf(TempIndexString, L"%ld", TempIndex);
        wcscat(TempFileName, TempIndexString);
        wcscat(TempFileName, L".E");
        TempHandle =  CreateFileW(
                         TempFileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL |
                         FILE_FLAG_DELETE_ON_CLOSE,
                         NULL
                         );
        if (TempHandle != INVALID_HANDLE_VALUE) {
            return TempHandle;
        }

        RetCode = GetLastError();

        switch (RetCode) {
                case ERROR_INVALID_PARAMETER     :
                case ERROR_WRITE_PROTECT         :
                case ERROR_FILE_NOT_FOUND        :
                case ERROR_BAD_PATHNAME          :
                case ERROR_INVALID_NAME          :
                case ERROR_PATH_NOT_FOUND        :
                case ERROR_NETWORK_ACCESS_DENIED :
                case ERROR_DISK_CORRUPT          :
                case ERROR_FILE_CORRUPT          :
                case ERROR_DISK_FULL             :

                    ContinueSearch = FALSE;

                break;
        default:

                TempFileName[TempPathLength] = 0;
                break;

        }

        TempIndex++;

    }


    //
    // We got the filename.
    //

    return TempHandle;
}

DWORD
SecureProcessMft(
    IN  LPWSTR DriveLetter,
    IN  HANDLE hTempFile
    )
{
    NTFS_VOLUME_DATA_BUFFER VolumeData;
    DWORD cbOutput;

    __int64 TotalMftEntries;
    PHANDLE pHandleArray = NULL;
    DWORD FreeMftEntries;
    DWORD i;
    DWORD dwLastError = ERROR_SUCCESS;


    //
    // get the count of MFT records.  This will fail if not NTFS, so bail in that case.
    //

    if(!DeviceIoControl(
                    hTempFile,
                    FSCTL_GET_NTFS_VOLUME_DATA, // dwIoControlCode
                    NULL,
                    0,
                    &VolumeData,
                    sizeof(VolumeData),
                    &cbOutput,
                    NULL
                    ))
    {
        return GetLastError();
    }

    TotalMftEntries = VolumeData.MftValidDataLength.QuadPart / VolumeData.BytesPerFileRecordSegment;
    if( TotalMftEntries > (0xFFFFFFFF/sizeof(HANDLE)) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    FreeMftEntries = (DWORD)TotalMftEntries;

    pHandleArray = HeapAlloc(GetProcessHeap(), 0 , FreeMftEntries*sizeof(HANDLE));
    if( pHandleArray == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( pHandleArray, FreeMftEntries * sizeof(HANDLE) );


    for( i=0;i< FreeMftEntries ; i++ )
    {
        WCHAR szTempPath[ MAX_PATH + 1 ];
        DWORD FillIndex;
        
        pHandleArray[i] = CreateMyTempFile(DriveLetter);
        if( pHandleArray[i] == INVALID_HANDLE_VALUE )
        {
            dwLastError = GetLastError();
            break;
        }
    
        //
        // for each file created, write at most BytesPerFileRecordSegment data to it.
        //

        for( FillIndex = 0 ; FillIndex < (VolumeData.BytesPerFileRecordSegment/8) ; FillIndex++ )
        {
            DWORD dwBytesWritten;

            if(!WriteFile(
                    pHandleArray[i],
                    GlobalSecureFill.pbRandomFill,
                    8,
                    &dwBytesWritten,
                    NULL
                    ))
            {
                break;
            }

        }

        if (i && !(i % 200)) {

            //
            // Keep users informed for every 50 files we created.
            //

            printf(".");
        }
    }

    if( dwLastError == ERROR_DISK_FULL )
    {
        dwLastError = ERROR_SUCCESS;
    }


#ifdef TestOutPut
    printf("\nmft error=%lu entries created=%lu total = %I64u\n", dwLastError, i, TotalMftEntries);
#endif


    for (i=0;i < FreeMftEntries;i++) {
        if( pHandleArray[i] != INVALID_HANDLE_VALUE &&
            pHandleArray[i] != NULL
            )
        {
            CloseHandle( pHandleArray[i] );
        }
    }


    if( pHandleArray != NULL )
    {
        HeapFree(GetProcessHeap(), 0, pHandleArray );
    }

    return dwLastError;
}


DWORD
SecureProcessFreeClusters(
    IN  LPWSTR DrivePath,
    IN  HANDLE hTempFile
    )
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    
    WCHAR VolumeName[100]; // 50 should be enough. 100 is more than enough.
    
    NTFS_VOLUME_DATA_BUFFER VolumeData;
    STARTING_LCN_INPUT_BUFFER LcnInput;
    VOLUME_BITMAP_BUFFER *pBitmap = NULL;
    MOVE_FILE_DATA MoveFile;
    __int64 cbBitmap;
    DWORD cbOutput;

    unsigned __int64 ClusterLocation;
    unsigned __int64 Lcn;
    BYTE Mask;

    unsigned __int64 Free = 0;
    DWORD Fail = 0;

#ifdef TestOutPut
    DWORD dwStart, dwStop;
#endif
    
    __int64 ClusterIndex;
    DWORD dwLastError = ERROR_SUCCESS;

    //
    // first, find out if there are free or reserved clusters.
    // this will fail if the volume is not NTFS.
    //

    if (!GetVolumeNameForVolumeMountPoint(
              DrivePath,
              VolumeName,
              sizeof(VolumeName)/sizeof(WCHAR)  )){

        return GetLastError();

    }

    VolumeName[wcslen(VolumeName)-1] = 0;  // Truncate the trailing slash

    if(!DeviceIoControl(
                    hTempFile,
                    FSCTL_GET_NTFS_VOLUME_DATA, // dwIoControlCode
                    NULL,
                    0,
                    &VolumeData,
                    sizeof(VolumeData),
                    &cbOutput,
                    NULL
                    ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if( VolumeData.FreeClusters.QuadPart == 0 &&
        VolumeData.TotalReserved.QuadPart == 0 )
    {
        return ERROR_SUCCESS;
    }

    hVolume = CreateFileW(  VolumeName,
                            FILE_READ_ATTRIBUTES | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_NO_BUFFERING, // no buffering
                            NULL
                            );

    if( hVolume == INVALID_HANDLE_VALUE )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // allocate space for the volume bitmap.
    //

    cbBitmap = sizeof(VOLUME_BITMAP_BUFFER) + (VolumeData.TotalClusters.QuadPart / 8);
    if( cbBitmap > 0xFFFFFFFF )
    {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pBitmap = HeapAlloc(GetProcessHeap(), 0, (DWORD)cbBitmap);
    if( pBitmap == NULL )
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // grab the volume bitmap.
    //

    LcnInput.StartingLcn.QuadPart = 0;

    ZeroMemory( &MoveFile, sizeof(MoveFile) );

    MoveFile.FileHandle = hTempFile;
    MoveFile.StartingVcn.QuadPart = 0;
    MoveFile.ClusterCount = 1;

#ifdef TestOutPut
    dwStart = GetTickCount();
#endif


    if(!DeviceIoControl(
            hVolume,        
            FSCTL_GET_VOLUME_BITMAP,
            &LcnInput,
            sizeof(LcnInput),
            pBitmap,
            (DWORD)cbBitmap,
            &cbOutput,
            NULL
            ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }
    

    //
    // insure file is only bytes per cluster in length.
    // this will shrink the file if necessary.  We waited until after we fetched the
    // volume bitmap to insure we only process the free clusters that existed prior to
    // the shrink operation.
    //
    
    if(SetFilePointer(
                    hTempFile,
                    (LONG)VolumeData.BytesPerCluster,
                    NULL,
                    FILE_BEGIN
                    ) == INVALID_SET_FILE_POINTER)
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }
    
    if(!SetEndOfFile( hTempFile ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    Mask = 1;
    Lcn = pBitmap->StartingLcn.QuadPart;

    for(ClusterIndex = 0 ; ClusterIndex < VolumeData.TotalClusters.QuadPart ; ClusterIndex++)
    {
        if( (pBitmap->Buffer[ClusterIndex/8] & Mask) == 0 )
        {
            DWORD dwMoveError = ERROR_SUCCESS;

            //
            // move a single cluster from the temp file to the free cluster.
            //

            MoveFile.StartingLcn.QuadPart = Lcn;
            
            if(!DeviceIoControl(
                        hVolume,
                        FSCTL_MOVE_FILE,    // dwIoControlCode
                        &MoveFile,
                        sizeof(MoveFile),
                        NULL,
                        0,
                        &cbOutput,
                        NULL
                        ))
            {
                dwMoveError = GetLastError();
            }
            
            //
            // if it succeeded, or the cluster was in use, mark it used in the bitmap.
            //
            
            if( dwMoveError == ERROR_SUCCESS || dwMoveError == ERROR_ACCESS_DENIED )
            {
                pBitmap->Buffer[ClusterIndex/8] |= Mask;
            } else {
                Fail++;
            }

            Free++;
            if ( !(Free % 200) ) {

                //
                // Keep users informed for every 50 files we created.
                //
                printf(".");

            }
        }

        Lcn ++;
        
        Mask <<= 1;

        if(Mask == 0)
        {
            Mask = 1;
        }
    }

#ifdef TestOutPut
    dwStop = GetTickCount();

    printf("\nFreeCount = %I64x fail = %lu elapsed = %lu\n", Free, Fail, dwStop-dwStart);
#endif

Cleanup:
    
    if( pBitmap != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pBitmap );
    }

    if( hVolume != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hVolume );
    }

    return dwLastError;
}


DWORD
SecureDeleteFreeSpace(
    IN  LPWSTR Directory
    )
/*++

    This routine fills the disk specified by the input Directory parameter with random fill.
    Input is of the form "C:\", for instance.

    Notes on approaches not employed here:

    Alternate method would use defrag API to move random fill around the
    free cluster map.  Requires admin priviliges to the volume.  Slower than filling volume with
    a new file.
    
    Variant on alternate method: fill volume 80% with file, grab free cluster map,
    delete file associated with 80% fill, then use defrag API to fill the free cluster map
    mentioned previously.

    Does not fill cluster slack space for each file on the system.  Could do this by
    enumerating all files, and then extending+fill to slack boundry+restore original
    EOF.
    
    Does not fill $LOG.  Queried file system folks on whether this is possible by creating
    many small temporary files containing random fill.    

--*/
{
    UINT DriveType;
    DWORD DirNameLength;
    DWORD BufferLength;
    LPWSTR PathName = NULL;
    LPWSTR TempDirName = NULL;
    BOOL   b;
    BOOL   DirCreated = FALSE;
    DWORD  Attributes;

    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    WCHAR TempFileName[ MAX_PATH + 1 ];
    HANDLE hTempFile = INVALID_HANDLE_VALUE;
    DWORD dwWriteBytes;

    unsigned __int64 TotalBytesWritten;
    unsigned __int64 NotifyBytesWritten;
    unsigned __int64 NotifyInterval;
    ULARGE_INTEGER TotalFreeBytes;

    PBYTE pbFillBuffer = NULL;
    ULONG cbFillBuffer;

    NTFS_VOLUME_DATA_BUFFER VolumeData;
    __int64 MftEntries = 0;
    BOOLEAN ClustersRemaining = FALSE;
    DWORD cbOutput;

    DWORD dwLastError = ERROR_SUCCESS;
    DWORD dwTestError;

#ifdef TestOutPut

    ULARGE_INTEGER StartTime;
    ULARGE_INTEGER StopTime;

#endif


    //
    // collect information about the disk in question.
    //


    DirNameLength = wcslen(Directory);

    BufferLength = (DirNameLength + 1) <= MAX_PATH ?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (DirNameLength + 1) * sizeof (WCHAR);
    PathName = (LPWSTR) malloc(BufferLength);
    if ( !PathName ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    TempDirName = (LPWSTR) malloc(BufferLength + wcslen(WIPING_DIR) * sizeof (WCHAR));
    if ( !TempDirName ) {
        free(PathName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    b = GetVolumePathNameW(
                    Directory,
                    PathName,
                    BufferLength
                    );

    if (!b) {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    DriveType = GetDriveTypeW( PathName );


    if( DriveType == DRIVE_REMOTE ||
        DriveType == DRIVE_CDROM )
    {
        dwLastError = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    if(!GetDiskFreeSpaceW(
                PathName,
                &SectorsPerCluster,
                &BytesPerSector,
                NULL,
                NULL
                ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    
    //
    // allocate memory chunk to accomodate cluster size data
    //


    cbFillBuffer = GlobalSecureFill.cbRandomFill;
    pbFillBuffer = GlobalSecureFill.pbRandomFill;


    //
    // determine how many bytes free space on the disk to enable notification of
    // overall progress.
    //

    if(!GetDiskFreeSpaceExW(
                PathName,
                NULL,
                NULL,
                &TotalFreeBytes
                ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // Let's Create the temp directory
    //

    wcscpy(TempDirName, PathName);
    wcscat(TempDirName, WIPING_DIR);
    if (!CreateDirectory(TempDirName, NULL)){

        //
        // Could not create our temp directory. Quit.
        //

        if ((dwLastError = GetLastError()) != ERROR_ALREADY_EXISTS){
            goto Cleanup;
        }
        
    } 

    DirCreated = TRUE;

    //
    // generate temporary file.
    //

    if( GetTempFileNameW(
                TempDirName,
                L"fil",
                0,
                TempFileName
                ) == 0 )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    Attributes = GetFileAttributes(TempFileName);
    if (0xFFFFFFFF == Attributes) {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

        if (!DecryptFile(TempFileName, 0)){
            dwLastError = GetLastError();
            goto Cleanup;
        }

    }

    hTempFile = CreateFileW(
                        TempFileName,
                        GENERIC_WRITE,
                        0,                          // exclusive access
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_NO_BUFFERING |    // no buffering
                        FILE_FLAG_DELETE_ON_CLOSE,  // delete file when it closes.
                        NULL
                        );

    if( hTempFile == INVALID_HANDLE_VALUE )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

        USHORT State = COMPRESSION_FORMAT_NONE;

        //
        //  Uncompress the directory first
        //

        b = DeviceIoControl(hTempFile,
                            FSCTL_SET_COMPRESSION,
                            &State,
                            sizeof(USHORT),
                            NULL,
                            0,
                            &BufferLength,
                            FALSE
                            );

        if ( !b ){
            dwLastError = GetLastError();
            goto Cleanup;
        }

    }


    TotalBytesWritten = 0;
    
    //
    // tell the user something happened for each 1% processed.
    //

    NotifyInterval = (TotalFreeBytes.QuadPart / 100);
    NotifyBytesWritten = NotifyInterval;
    
    dwWriteBytes = cbFillBuffer;


#ifdef TestOutPut
    GetSystemTimeAsFileTime( (FILETIME*)&StartTime );
#endif
    
    while( TRUE )
    {
        DWORD BytesWritten;

        if( TotalBytesWritten >= NotifyBytesWritten )
        {
            printf(".");

            NotifyBytesWritten += NotifyInterval;
        }


        //
        // mix random fill.
        //

        SecureMixRandomFill( &GlobalSecureFill, dwWriteBytes );

        if(!WriteFile(
                hTempFile,
                pbFillBuffer,
                dwWriteBytes,
                &BytesWritten,
                NULL
                ))
        {
            if( GetLastError() == ERROR_DISK_FULL )
            {
                dwLastError = ERROR_SUCCESS;

                //
                // if the attempted write failed, enter a retry mode with downgraded
                // buffersize to catch the last bits of slop.
                //

                if( dwWriteBytes > BytesPerSector )
                {
                    dwWriteBytes = BytesPerSector;
                    continue;
                }
            } else {
                dwLastError = GetLastError();
            }

            break;
        }

        TotalBytesWritten += BytesWritten;
    }

#ifdef TestOutPut
    GetSystemTimeAsFileTime( (FILETIME*)&StopTime );

    {
        ULARGE_INTEGER ElapsedTime;
        SYSTEMTIME st;

        ElapsedTime.QuadPart = (StopTime.QuadPart - StartTime.QuadPart);

        FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &st );

        printf("\nTotalWritten = %I64u time = %02u:%02u:%02u.%02u\n",
                TotalBytesWritten,
                st.wHour,
                st.wMinute,
                st.wSecond,
                st.wMilliseconds
                );

    }
#endif


    
    //
    // at this point, the disk should be full.
    // If the disk is NTFS:
    // 1. Fill the MFT.
    // 2. Fill any free/reserved clusters.
    //

    dwTestError = SecureProcessMft( TempDirName, hTempFile );
//    dwTestError = SecureProcessMft( PathName, hTempFile );

#ifdef TestOutPut
    if (ERROR_SUCCESS != dwTestError) {
        printf("\nWriting NTFS MFT & LOG. Error:");
        DisplayErr(NULL, dwTestError);
    }
#endif

    dwTestError = SecureProcessFreeClusters( PathName, hTempFile );

#ifdef TestOutPut
    if (ERROR_SUCCESS != dwTestError) {
        printf("\nWriting NTFS reserved clusters. Error:");
        DisplayErr(NULL, dwTestError);
    }
#endif

Cleanup:

    if (hTempFile != INVALID_HANDLE_VALUE) {
        //
        // flush the buffers.  Likely has no effect if we used FILE_FLAG_NO_BUFFERING
        //
        //Sleep(INFINITE);
        FlushFileBuffers( hTempFile );
        CloseHandle( hTempFile );
    }

    if (DirCreated && TempDirName) {
        RemoveDirectory(TempDirName);
    }

    if( PathName != NULL ){
        free(PathName);
    }

    if ( TempDirName != NULL ) {
        free(TempDirName);
    }
    
    return dwLastError;
}

BOOL CheckMinVersion () 
{
   OSVERSIONINFOEX osvi;
   DWORDLONG dwlConditionMask = 0;
   BOOL GoodVersion;

   // Initialize the OSVERSIONINFOEX structure.

   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
   osvi.dwMajorVersion = 5;
   osvi.dwMinorVersion = 0;
   osvi.wServicePackMajor = 3;

   // Initialize the condition mask.

   VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
      VER_GREATER_EQUAL );
   VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
      VER_GREATER_EQUAL );
   VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, 
      VER_GREATER_EQUAL );

   // Perform the test.

   GoodVersion = VerifyVersionInfo(
                      &osvi, 
                      VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR,
                      dwlConditionMask
                      );

   return GoodVersion;
}


PCRYPT_KEY_PROV_INFO
GetKeyProvInfo(
    PCCERT_CONTEXT pCertContext
    )
{

    DWORD cbData = 0;
    BOOL b;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;

    b = CertGetCertificateContextProperty(
             pCertContext,
             CERT_KEY_PROV_INFO_PROP_ID,
             NULL,
             &cbData
             );

    if (b) {

        pCryptKeyProvInfo = (PCRYPT_KEY_PROV_INFO)malloc( cbData );

        if (pCryptKeyProvInfo != NULL) {

            b = CertGetCertificateContextProperty(
                     pCertContext,
                     CERT_KEY_PROV_INFO_PROP_ID,
                     pCryptKeyProvInfo,
                     &cbData
                     );

            if (!b) {

                free( pCryptKeyProvInfo );
                pCryptKeyProvInfo = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return ( pCryptKeyProvInfo );
}

DWORD
GetUserInput(
     IN DWORD MsgNum,
     IN OUT LPWSTR StrBuf,
     IN DWORD SizeInChars
     )
{
    int ii;

    DisplayMsg(MsgNum);
    if (!fgetws((LPWSTR)StrBuf, SizeInChars, stdin)) {

        //
        // Error or end of file. Just return.
        //

        return GetLastError();

    }

    //
    // Strip off CR and LN
    //

    ii = wcslen(StrBuf) - 1;

    while (ii >=0 ) {
        if ((StrBuf[ii] == 0x0a) || (StrBuf[ii] == 0x0d)) {
            StrBuf[ii] = 0;
            ii--;
        } else {
            break;
        }
    }


    return ERROR_SUCCESS;

}

DWORD
BackEfsCert(
    IN  LPWSTR EfsFileName, 
    IN  LPWSTR PfxFileName
    )

/*++

Routine Description:

    Export EFS certificate and keys to a PFX file

Arguments:

    EfsFileName - EFS file
    
    
    PfxFileName - PfxFileName

Return Values:

    Win32 Error code

--*/
{
    BOOLEAN EFSFileExist = FALSE;
    HCERTSTORE memStore = 0;
    HCERTSTORE myStore = 0;
    PCCERT_CONTEXT pCertContext = NULL;
    LPWSTR ContainerName = NULL;
    LPWSTR ProviderName = NULL;
    LPWSTR PfxPassword = NULL;

    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;
    HCRYPTKEY  hLocalKey = 0;
    HCRYPTPROV hLocalProv = 0;

    DWORD   Attributes;
    DWORD   RetCode = ERROR_SUCCESS;
    BOOLEAN ValidCertFound = FALSE;

    HKEY hRegKey = NULL;
    CRYPT_HASH_BLOB HashBlob;

    HANDLE hFile;
 

    if ((NULL == EfsFileName) || (NULL == PfxFileName)) {

        //
        //  EfsFileName & PfxFileName have MAX_PATH available 
        //

        return ERROR_INVALID_PARAMETER;
    }

    if (EfsFileName[0] != 0) {
        Attributes = GetFileAttributes( EfsFileName );
        if (0xFFFFFFFF == Attributes) {

            //
            // Failed
            //

            return GetLastError();

        }
        if (0 == (Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {

            return ERROR_FILE_NOT_ENCRYPTED;

        }
        EFSFileExist = TRUE;
    }

    if (EFSFileExist) {

        //
        // Export the certs existing on the file
        //


        PENCRYPTION_CERTIFICATE_HASH_LIST pUsers = NULL;

        RetCode = QueryUsersOnEncryptedFile(
                        EfsFileName,
                        &pUsers
                        );

        if ( ERROR_SUCCESS == RetCode) {

            //
            // Create a memory cert store
            //

            DWORD nCerts = 0;

            memStore = CertOpenStore(
                                 CERT_STORE_PROV_MEMORY,
                                 0,
                                 0,
                                 CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                                 NULL
                                 );
            if (memStore) {

                myStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            L"My"
                            );
            
                if (myStore) {


                    //
                    // Let's find the cert
                    //
    
                    nCerts = pUsers->nCert_Hash;
    
                    while(nCerts){
    
                        //
                        //  We will export all the certs in MY store. Usually only one.
                        //

                
                        pCertContext = CertFindCertificateInStore( myStore,
                                                                   CRYPT_ASN_ENCODING,
                                                                   0,
                                                                   CERT_FIND_HASH,
                                                                   (CRYPT_HASH_BLOB*) pUsers->pUsers[nCerts-1]->pHash,
                                                                   NULL
                                                                   );
                        if (pCertContext != NULL) {

                            //
                            //  Let's try to see if keys are available
                            //


                            pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );
                            if (pCryptKeyProvInfo) {

                                if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {
                            
                                    if (CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {

                                        //
                                        // We found the key. Let's add the cert to Memory store
                                        //
                                        if (CertAddCertificateContextToStore(memStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL)){

                                            //
                                            // Cert added.
                                            //

                                            ValidCertFound = TRUE;

                                        }

                                        CryptDestroyKey( hLocalKey );

                                    }
                                    CryptReleaseContext( hLocalProv, 0 );

                                }
                                free (pCryptKeyProvInfo);
                            }

                            CertFreeCertificateContext( pCertContext );
                
                        }

                        nCerts--;

                    }

                    if (!ValidCertFound) {

                        //
                        //  We didn't get good certs. Warn the user.
                        //
                        DisplayMsg(CIPHER_NO_LOCAL_CERT);

                    }

                    CertCloseStore(myStore, 0);
                    myStore = 0;

                } else {

                    CertCloseStore( memStore, 0 );
                    memStore = 0;

                    RetCode = GetLastError();
                }


            }
        

            if (pUsers) {
                FreeEncryptionCertificateHashList(pUsers);
                pUsers = NULL;
            }

        } else {
            return RetCode;
        }

    } else {

        //
        // EFS file not provided, try to export the current EFS cert
        //


        RetCode = RegOpenKeyEx(
                 KEYPATHROOT,
                 KEYPATH,
                 0,
                 GENERIC_READ,
                 &hRegKey
                 );
    
        if (RetCode == ERROR_SUCCESS) {
    
            DWORD Type;
    
            RetCode = RegQueryValueEx(
                    hRegKey,
                    CERT_HASH,
                    NULL,
                    &Type,
                    NULL,
                    &(HashBlob.cbData)
                    );
    
            if (RetCode == ERROR_SUCCESS) {
    
                //
                // Query out the thumbprint, find the cert, and return the key information.
                //
    
                if (HashBlob.pbData = (PBYTE)malloc( HashBlob.cbData )) {
    
                    RetCode = RegQueryValueEx(
                            hRegKey,
                            CERT_HASH,
                            NULL,
                            &Type,
                            HashBlob.pbData,
                            &(HashBlob.cbData)
                            );
    
                    if (RetCode == ERROR_SUCCESS) {

                        //
                        //  We get the cert hash. Get the cert from MY to MemStore
                        //

                        memStore = CertOpenStore(
                                             CERT_STORE_PROV_MEMORY,
                                             0,
                                             0,
                                             CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                                             NULL
                                             );
                        if (memStore) {
            
                            myStore = CertOpenStore(
                                        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                                        0,       // dwEncodingType
                                        0,       // hCryptProv,
                                        CERT_SYSTEM_STORE_CURRENT_USER,
                                        L"My"
                                        );
                        
                            if (myStore) {


                                pCertContext = CertFindCertificateInStore( myStore,
                                                                           CRYPT_ASN_ENCODING,
                                                                           0,
                                                                           CERT_FIND_HASH,
                                                                           (CRYPT_HASH_BLOB*) &HashBlob,
                                                                           NULL
                                                                           );
                                if (pCertContext != NULL) {
        
                                    //
                                    //  Let's try to see if keys are available
                                    //
        
        
                                    pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );
                                    if (pCryptKeyProvInfo) {
        
                                        if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {
                                    
                                            if (CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {
        
                                                //
                                                // We found the key. Let's add the cert to Memory store
                                                //
                                                if (CertAddCertificateContextToStore(memStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL)){
        
                                                    //
                                                    // Cert added.
                                                    //
        
                                                    ValidCertFound = TRUE;
        
                                                }
        
                                                CryptDestroyKey( hLocalKey );
        
                                            }
                                            CryptReleaseContext( hLocalProv, 0 );
        
                                        }
                                        free (pCryptKeyProvInfo);
                                    }
        
                                    CertFreeCertificateContext( pCertContext );
                                }

                                CertCloseStore(myStore, 0);
                                myStore = 0;
                            }
                        }
            
                    }
                    free(HashBlob.pbData);
                }
            }
            RegCloseKey( hRegKey );
        }

    }

    if (ValidCertFound && memStore && (RetCode == ERROR_SUCCESS)) {

        //
        // We got the cert ready to export. Warn the user with message box.
        //
        LPWSTR  WarnText = NULL;
        LPWSTR  WarnTitle= NULL;
        CRYPT_DATA_BLOB PFX;
        DWORD   TextLen = 0;
        int     ButtonID = 0;


        RetCode = GetResourceString(&WarnText, CIPHER_BACKUP_OK);

        if (ERROR_SUCCESS == RetCode) {
            RetCode = GetResourceString(&WarnTitle, CIPHER_BACKUP_WRN);
        }
    
        if (ERROR_SUCCESS == RetCode) {

            ButtonID = MessageBox(NULL, WarnText, WarnTitle, MB_OKCANCEL | MB_TOPMOST);
            LocalFree( WarnText );
            LocalFree( WarnTitle );

        } else {
            if (WarnText) {
                LocalFree( WarnText );
            }
            if (WarnTitle) {
                LocalFree( WarnTitle );
            }
        }

        if (ButtonID == IDOK) {


            if (PfxFileName[0] == 0 ) {

                //
                //  Let's try to get the PFX file name
                //
                
                RetCode = GetUserInput(
                             CIPHER_PFX_FILENAME_NEEDED,
                             PfxFileName,
                             MAX_PATH
                             );

                if (ERROR_SUCCESS != RetCode) {
                    PfxFileName[0] = 0;
                }
                
            }

            //
            // Adding the .PFX if the file extension not provided
            //

            TextLen = wcslen(PfxFileName);

            if ((PfxFileName[0] != 0) && TextLen > 4) {

                if (lstricmp(&PfxFileName[ TextLen - 4], L".PFX")){
                    if (TextLen <= MAX_PATH - 5) {
                        wcscpy(&PfxFileName[TextLen], L".PFX");
                    } else {
                        RetCode = ERROR_BUFFER_OVERFLOW;
                        PfxFileName[0] = 0;
                    }
                }
            } else if (PfxFileName[0] != 0) {
                wcscpy(&PfxFileName[TextLen], L".PFX");
            }

            if (PfxFileName[0]) {

                if (GetPassword( &PfxPassword )) {

                    memset( &PFX, 0, sizeof( CRYPT_DATA_BLOB ));
            
                    //
                    // Asking password
                    //
            
                    if (PFXExportCertStoreEx(
                            memStore,
                            &PFX,
                            PfxPassword,
                            NULL,
                            EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){
            
                        PFX.pbData = (BYTE *) malloc(PFX.cbData);
            
                        if (PFX.pbData) {
            
                            if (PFXExportCertStoreEx(
                                    memStore,
                                    &PFX,
                                    PfxPassword,
                                    NULL,
                                    EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){
            
                                //
                                // Write out the PFX file
                                //
                    
                                hFile = CreateFileW(
                                             PfxFileName,
                                             GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL
                                             );
            
                                if ( INVALID_HANDLE_VALUE != hFile) {
                    
                                    //
                                    // Let's write out the CER file
                                    //
                    
                    
                                    if(!WriteFile(
                                            hFile,
                                            PFX.pbData,
                                            PFX.cbData,
                                            &TextLen,
                                            NULL
                                            )){

                                        RetCode = GetLastError();
                                        DisplayMsg(CIPHER_CERTS_BACKUP_FAILED);                    

                                    }  else {

                                        DisplayMsg(CIPHER_CERTS_BACKED);
                                        RetCode = ERROR_SUCCESS;

                                    }
            
                    
                                    CloseHandle(hFile);
                    
                                } else {
                    
                                    RetCode = GetLastError();
                                    DisplayMsg(CIPHER_CERTS_BACKUP_FAILED);
                    
                                }
            
                            } else {
            
                                RetCode = GetLastError();
                                DisplayMsg(CIPHER_CERTS_BACKUP_FAILED);

            
                            }
            
                            free( PFX.pbData );
            
                        } else {
            
                            RetCode = ERROR_NOT_ENOUGH_MEMORY;
                            DisplayMsg(CIPHER_CERTS_BACKUP_FAILED);

            
                        }
                    }

                    if (PfxPassword) {
                        free(PfxPassword);
                        PfxPassword = 0;
                    }

                } else {

                    RetCode = GetLastError();

                }

            } else {
                RetCode = ERROR_INVALID_PARAMETER;
                DisplayMsg(CIPHER_CERTS_BACKUP_FAILED);
            }
        }

    }

    if (memStore) {
        CertCloseStore(memStore, 0);
    }

    return RetCode;

}


VOID
__cdecl
main()
{
    PTCHAR *argv;
    ULONG argc;

    ULONG i;

    PACTION_ROUTINE ActionRoutine = NULL;
    PFINAL_ACTION_ROUTINE FinalActionRoutine = NULL;

    TCHAR DirectorySpec[MAX_PATH];
    TCHAR FileSpec[MAX_PATH];
    PTCHAR p;
    BOOL b;

    InitializeIoStreams();


    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (NULL == argv) {
        DisplayErr(NULL, GetLastError());
        return;
    }

    //
    //  Scan through the arguments looking for switches
    //

    for (i = 1; i < argc; i += 1) {

        if (argv[i][0] == '/') {

            if (0 == lstricmp(argv[i], TEXT("/e"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoEncryptAction) {

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

                ActionRoutine = DoEncryptAction;
                FinalActionRoutine = DoFinalEncryptAction;

            } else if (0 == lstricmp(argv[i], TEXT("/d"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoListAction) {

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

                ActionRoutine = DoDecryptAction;
                FinalActionRoutine = DoFinalDecryptAction;

            } else if (0 == lstricmp(argv[i], TEXT("/a"))){

                DoFiles = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/q"))) {

                Quiet = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/k"))){

                SetUpNewUserKey = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/u"))){
            
                RefreshUserKeyOnFiles = TRUE;
                    
            } else if (0 == lstricmp(argv[i], TEXT("/n"))){

                DisplayFilesOnly = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/h"))){

                DisplayAllFiles = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/s"), 2)) {

                PTCHAR pch;

                DoSubdirectories = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {

                    //
                    //  We need space for \ * and NULL. That is where 3 comes from.
                    //

                    if (wcslen(pch+1) > ((sizeof(StartingDirectory) / sizeof (TCHAR)) - 3)){

                        //
                        // The dir is too long for us
                        //

                        DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
                        return;

                    } else {

                        lstrcpy(StartingDirectory, pch + 1);

                    }
                } else {

                    //
                    // We require an explicit directory to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else if (0 == lstricmp(argv[i], TEXT("/i"))) {

                IgnoreErrors = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/f"))) {

                ForceOperation = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/x"), 2)){

                DWORD dLen;

                ExportEfsCert = TRUE;

                //
                // Using FileSpec for the source encrypted file.
                // Using DirectorySpec for the destination PFX file.
                // CIPHER /X[:EFSFILE] [PFXFILE]
                //

                DirectorySpec[0] = 0;
                FileSpec[0] = 0;

                dLen = wcslen(argv[i]);

                if ((dLen > 3) && argv[i][2] == ':') {

                    

                    //
                    // Try to get the EFSFILE
                    //


                    if ( (dLen -3) >= MAX_PATH) {

                        //
                        //  3 is for /X:
                        //

                        DisplayMsg(CIPHER_INVALID_PATH, &(argv[i][3]));
                        return;

                    } else {

                        lstrcpy( FileSpec, &(argv[i][3]));
                
                    }

                }

                if ((i+1) < argc) {

                    //
                    //  Try to get the target PFX file name
                    //

                    if (wcslen(argv[i+1]) >= MAX_PATH) {

                        DisplayMsg(CIPHER_INVALID_PATH, argv[i+1]);
                        return;

                    } else {

                        lstrcpy( DirectorySpec, argv[i+1]);
                    }

                }

                break;

            } else if (0 == lstrnicmp(argv[i], TEXT("/r"), 2)){

                PTCHAR pch;

                GenerateDRA = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {

                    //
                    //  We will append .CER (PFX) to the path. Plus the NULL. Extra 5 TCHARs are needed.
                    //

                    if (wcslen(pch+1) > ((sizeof(StartingDirectory) / sizeof (TCHAR)) - 5)){

                        //
                        // The path is too long for us
                        //

                        DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
                        return;

                    }else {

                        lstrcpy(StartingDirectory, pch + 1);

                    }

                } else {

                    //
                    // We require an explicit file to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else if (0 == lstrnicmp(argv[i], TEXT("/w"), 2)){

                PTCHAR pch;

                FillUnusedSpace = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    if (wcslen(pch+1) > ((sizeof(StartingDirectory) / sizeof (TCHAR)) - 1)){

                        //
                        // The path is too long for us
                        //

                        DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
                        return;

                    }else {

                        lstrcpy(StartingDirectory, pch + 1);

                    }
                } else {

                    //
                    // We require an explicit directory to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else {

                DisplayMsg(CIPHER_USAGE, NULL);
                return;
            }

        } else {

            UserSpecifiedFileSpec = TRUE;
        }
    }

    if (SetUpNewUserKey) {

        DWORD RetCode;

        //
        // Set up new user key here
        //

        RetCode = SetUserFileEncryptionKey(NULL);
        if ( ERROR_SUCCESS != RetCode ) {

            //
            // Display error info.
            //

            DisplayErr(NULL, GetLastError());

            
        } else {

            //
            // Get the new hash and display it.
            //

            CipherDisplayCrntEfsHash();

        }

        //
        // Create user key should not be used with other options.
        // We will ignore other options if user do.
        //

        return;

    }

    if (RefreshUserKeyOnFiles) {

        DWORD RetCode;
        
        RetCode = CipherTouchEncryptedFiles();

        if (RetCode != ERROR_SUCCESS) {
            DisplayErr(NULL, RetCode);
        }

        return;

    }

    if (GenerateDRA) {

        DWORD RetCode;

        RetCode = GenerateCertFiles(StartingDirectory);
        return;

    }

    if (ExportEfsCert) {

        DWORD RetCode;

        RetCode = BackEfsCert(FileSpec, DirectorySpec);
        if (RetCode != ERROR_SUCCESS) {
            DisplayErr(NULL, RetCode);
        }

        return;

    }

    if (FillUnusedSpace) {

        BYTE FillByte[2] = { 0x00, 0xFF };
        DWORD WriteValue[3] = {CIPHER_WRITE_ZERO, CIPHER_WRITE_FF, CIPHER_WRITE_RANDOM};
        PBYTE pFillByte[3] = {&FillByte[0], &FillByte[1], NULL};
        LPWSTR WriteChars;
        DWORD RetCode;

        if (!CheckMinVersion()) {
            DisplayErr(NULL, ERROR_OLD_WIN_VERSION);
            return;
        }

        //
        // We are going to erase the disks
        //


        DisplayMsg(CIPHER_WIPE_WARNING, NULL);
        
        for (i = 0; i < 3; i++) {
            RetCode = SecureInitializeRandomFill( &GlobalSecureFill, 4096 * 128, pFillByte[i] );
            if (RetCode != ERROR_SUCCESS) {
                SecureDeleteRandomFill(&GlobalSecureFill);
                break;
            }

            if ( ERROR_SUCCESS == GetResourceString(&WriteChars, WriteValue[i])){ 
                DisplayMsg(CIPHER_WIPE_PROGRESS, WriteChars);
                LocalFree(WriteChars);
            }
            RetCode = SecureDeleteFreeSpace(StartingDirectory);
            printf("\n");
            SecureDeleteRandomFill( &GlobalSecureFill );
            if (RetCode != ERROR_SUCCESS) {
                break;
            }
        }

        if (RetCode != ERROR_SUCCESS) {
            DisplayErr(NULL, RetCode);
        }

        return;
    }


    //
    //  If the use didn't specify an action then set the default to do a listing
    //

    if (ActionRoutine == NULL) {

        ActionRoutine = DoListAction;
        FinalActionRoutine = DoFinalListAction;
    }



    //
    //  If the user didn't specify a file spec then we'll do just "*"
    //

    if (!UserSpecifiedFileSpec) {

        DWORD PathLen;

        //
        //  Get our current directory because the action routines might move us
        //  around
        //

        if (DoSubdirectories) {
            if (ActionRoutine != DoListAction) {
                (VOID)(ActionRoutine)( StartingDirectory, TEXT("") );
            }
            if (!SetCurrentDirectory( StartingDirectory )) {
                DisplayErr(StartingDirectory, GetLastError());
                return;
            }
        } else {
            PathLen = GetCurrentDirectory( MAX_PATH, StartingDirectory );
            if (0 == PathLen) {

                DisplayErr(NULL, GetLastError());
                return;

            } else if (PathLen >= MAX_PATH) {

                    DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
                    return;

            }
        }


        PathLen = GetFullPathName( TEXT("*"), MAX_PATH, DirectorySpec, &p );

        if (0 == PathLen) {

                DisplayErr(NULL, GetLastError());
                return;

        }
        if (PathLen >= MAX_PATH) {

            DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
            return;

        }

        //
        //  If PathLen < MAX_PATH, than wcslen(P) < MAX_PATH
        //

        lstrcpy( FileSpec, p ); *p = '\0';

        (VOID)(ActionRoutine)( DirectorySpec, FileSpec );

    } else {

        //
        //  Get our current directory because the action routines might move us
        //  around
        //

        DWORD PathLen;

        if (!DoSubdirectories) {

            PathLen = GetCurrentDirectory( MAX_PATH, StartingDirectory );
            if (0 == PathLen) {

                DisplayErr(NULL, GetLastError());
                return;

            } else if (PathLen >= MAX_PATH) {

                    DisplayErr(NULL, ERROR_BUFFER_OVERFLOW);
                    return;

            }

        } else if (!SetCurrentDirectory( StartingDirectory )) {
            DisplayErr(StartingDirectory, GetLastError());
            return;
        }

        //
        //  Now scan the arguments again looking for non-switches
        //  and this time do the action, but before calling reset
        //  the current directory so that things work again
        //

        for (i = 1; i < argc; i += 1) {

            if (argv[i][0] != '/') {

                SetCurrentDirectory( StartingDirectory );

                //
                // Handle a command with "." as the file argument specially,
                // since it doesn't make good sense and the results without
                // this code are surprising.
                //

                if ('.' == argv[i][0] && '\0' == argv[i][1]) {
                    argv[i] = TEXT("*");
                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    *p = '\0';
                    p = NULL;
                } else {

                    PWCHAR pwch;

                    //
                    // We need to deal with path longer than MAX_PATH later.
                    // This code is based on Compact. They have the same problem
                    // as we do. So far, we have not heard any one complaining about this.
                    // Let's track this in the RAID.
                    //
 
                    PathLen = GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    if ( (0 == PathLen) || ( PathLen > (MAX_PATH - 1)) ){
                        DisplayMsg(CIPHER_INVALID_PARAMETER, argv[i]);
                        break;
                    }

                    //
                    // We want to treat "foobie:xxx" as an invalid drive name,
                    // rather than as a name identifying a stream.  If there's
                    // a colon, there should be only a single character before
                    // it.
                    //

                    pwch = wcschr(argv[i], ':');
                    if (NULL != pwch && pwch - argv[i] != 1) {
                        DisplayMsg(CIPHER_INVALID_PATH, argv[i]);
                        break;
                    }

                    //
                    // GetFullPathName strips trailing dots, but we want
                    // to save them so that "*." will work correctly.
                    //

                    if ('.' == argv[i][lstrlen(argv[i]) - 1]) {

                        if (PathLen >= MAX_PATH - 2 ) {
                            DisplayMsg(CIPHER_INVALID_PATH, argv[i]);
                            break;
                        } else {
                            lstrcat(DirectorySpec, TEXT("."));
                        }
                    }
                }

                if (p != NULL) {

                    if (wcslen(p) >= (sizeof(FileSpec) / sizeof (TCHAR))) {

                        DisplayMsg(CIPHER_INVALID_PATH, argv[i]);
                        break;
                        
                    } else {

                        lstrcpy( FileSpec, p ); *p = '\0';

                    }
                } else {
                    FileSpec[0] = '\0';
                }

                if (!(ActionRoutine)( DirectorySpec, FileSpec ) &&
                    !IgnoreErrors) {
                    break;
                }
            }
        }
    }

    //
    //  Reset our current directory back
    //

    SetCurrentDirectory( StartingDirectory );

    //
    //  And do the final action routine that will print out the final
    //  statistics of what we've done
    //

    (FinalActionRoutine)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\compact\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\chkntfs\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=chkntfs

TARGETNAME=chkntfs
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chkntfs.cxx \
        ..\chkntfs.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cipher\support.c ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    Support routines for compact utility

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994
    Robert Reichel      [RobertRe]      01-Apr-1997

Revision History:


--*/

#undef UNICODE
#define UNICODE

#undef _UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <windows.h>
#include "support.h"
#include "msg.h"



//
//  Declare routines to put out internationalized messages
//

typedef enum {
    READ_ACCESS,
    WRITE_ACCESS
} STREAMACCESS;


DWORD MySetThreadUILanguage(DWORD dwParam)
{
    HMODULE  hKernel32Dll  = NULL;
    DWORD    hr = ERROR_SUCCESS; 
    typedef LANGID (WINAPI * SetThreadUILanguageFunc)(DWORD dwReserved);
    SetThreadUILanguageFunc   pSetThreadUILanguage  = NULL;

    hKernel32Dll = LoadLibraryW(L"kernel32.dll");
    if (NULL == hKernel32Dll) { 
        return GetLastError();
    }

    pSetThreadUILanguage = (SetThreadUILanguageFunc)GetProcAddress(hKernel32Dll, "SetThreadUILanguage");
    if (NULL != pSetThreadUILanguage) {
        pSetThreadUILanguage(dwParam);
    } else {
        hr = GetLastError();
    }

    FreeLibrary(hKernel32Dll);  
	
    return hr; 
}

HANDLE
GetStandardStream(
    IN HANDLE   Handle,
    IN STREAMACCESS Access
    );

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

}


VOID
InitializeIoStreams()
{
    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);
}

VOID
DisplayMsg(DWORD MsgNum, ... )
{
    DWORD len, bytes_written = 0;
    BOOL success = FALSE;
    DWORD status;
    va_list ap;
    LPTSTR DisplayBuffer;

    MySetThreadUILanguage(0);

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL, MsgNum, 0,
        (LPVOID)&DisplayBuffer, 0, &ap);

    if (len && DisplayBuffer) {

        if (ConsoleOutput) {
            success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                     &bytes_written, NULL);
    
        } else {
            DWORD ascii_len;
            LPSTR DisplayBufferAscii;
    
            len = lstrlen(DisplayBuffer);
    
            ascii_len = WideCharToMultiByte(
                CP_OEMCP,                                 // Unicode -> OEM
                0,                                        // gives best visual match
                DisplayBuffer, len+1,                     // source & length
                NULL, 0,                                  // dest & length
                NULL,                                     // default char
                NULL);

            if (ascii_len) {
                DisplayBufferAscii = LocalAlloc(LPTR, ascii_len);
                if (DisplayBufferAscii != NULL) {

                    ascii_len = WideCharToMultiByte(
                                    CP_OEMCP,
                                    0,
                                    DisplayBuffer, len+1,
                                    DisplayBufferAscii, ascii_len,
                                    NULL,
                                    NULL);
                    if (ascii_len) {
                        success = WriteFile(hOutput, (LPVOID)DisplayBufferAscii, ascii_len,
                                 &bytes_written, NULL);
            
                        len = ascii_len;
                    }
        
                    LocalFree(DisplayBufferAscii);
                }
            }
    
        }
    
        if (!success || bytes_written != len) {
            status = GetLastError();
        }
    
        LocalFree(DisplayBuffer);
    }

    va_end(ap);
}

VOID
DisplayErr(
    PTCHAR Prefix,
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written, PrefixLen;
    BOOL success = FALSE;
    BOOL errset = FALSE;
    DWORD status;
    va_list ap;
    LPTSTR DisplayBuffer;
    LPTSTR MessageBuffer;
    #define PREFIX_MSG TEXT(": ")

    MySetThreadUILanguage(0);

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL, MsgNum, 0,
            (LPVOID)&MessageBuffer, 0, &ap);
    if (len && MessageBuffer) {

        if (Prefix == NULL) {
            PrefixLen = 0;
        } else {
            PrefixLen = wcslen(Prefix)+wcslen(PREFIX_MSG);
        }
    
        DisplayBuffer = LocalAlloc(LPTR, (len+PrefixLen+1) * sizeof(WCHAR));
        if (DisplayBuffer != NULL) {
    
            if (NULL != Prefix) {
                lstrcpy(DisplayBuffer, Prefix);
                lstrcat(DisplayBuffer, PREFIX_MSG);
            } else {
                DisplayBuffer[0] = UNICODE_NULL;
            }
    
            lstrcat(DisplayBuffer, MessageBuffer);
    
            len = lstrlen(DisplayBuffer);
    
            if (ConsoleError) {
                success = WriteConsole(hError, (LPVOID)DisplayBuffer, len,
                         &bytes_written, NULL);
    
            } else {
                DWORD ascii_len;
                LPSTR DisplayBufferAscii;
    
                ascii_len = WideCharToMultiByte(
                    CP_OEMCP,                                 // Unicode -> OEM
                    0,                                        // gives best visual match
                    DisplayBuffer, len+1,                     // source & length
                    NULL, 0,                                  // dest & length
                    NULL,                                     // default char
                    NULL);

                if (ascii_len) {

                    DisplayBufferAscii = LocalAlloc(LPTR, ascii_len);
                    if (DisplayBufferAscii != NULL) {
                        ascii_len = WideCharToMultiByte(
                                        CP_OEMCP,
                                        0,
                                        DisplayBuffer, len+1,
                                        DisplayBufferAscii, ascii_len,
                                        NULL,
                                        NULL);

                        if (ascii_len) {
                            success = WriteFile(hError, (LPVOID)DisplayBufferAscii, ascii_len,
                                     &bytes_written, NULL);
                        } else {
                            status = GetLastError();
                            errset = TRUE;
                        }
        
        
                        LocalFree(DisplayBufferAscii);
                    } else {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        errset = TRUE;
                    }
                } else {
                    status = GetLastError();

                    //
                    // No need to get last error again
                    //

                    errset = TRUE;

                }
    
            }
    
            LocalFree(DisplayBuffer);
        }
    
        if (!success && !errset) {
            status = GetLastError();
        }
    
        LocalFree(MessageBuffer);
    }

    va_end(ap);
}

DWORD
GetResourceString(
    LPWSTR *OutStr,
    DWORD MsgNum,
    ...
    )
{

    DWORD rc = ERROR_SUCCESS;
    DWORD len;
    va_list ap;

    MySetThreadUILanguage(0);

    va_start(ap, MsgNum);

    *OutStr = NULL;

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL, 
            MsgNum, 
            0,
            (LPVOID)OutStr, 
            0, 
            &ap
            );

    if (len && *OutStr) {

        //
        // Let's get rid of \n
        //
        
        len = wcslen( *OutStr );
        if (((*OutStr)[len-1] == 0x000a) && ((*OutStr)[len-2] == 0x000d) ) {

            (*OutStr)[len-2] = 0;

        }

    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    va_end(ap);

    return rc;

}

BOOLEAN
IsNtldr(
    PTCHAR Path
    )
/*++

Routine Description:

    Used to keep the user from compressing \NTLDR (which would prevent
    the machine from booting).

Arguments:

    Path - the path to examine.

Return Value:

    TRUE - the path looks like \ntldr.
    FALSE - the path does not look like \ntldr.

--*/
{
    PTCHAR pch;

    // try "X:\ntldr"

    if (0 == lstricmp(Path + 2, TEXT("\\ntldr"))) {
        return TRUE;
    }

    // try "\\machine\share\ntldr"

    if ('\\' == Path[0] && '\\' != Path[1]) {
        pch = lstrchr(Path + 2, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        pch = lstrchr(pch + 1, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        if (0 == lstricmp(pch, TEXT("\\ntldr"))) {
            return TRUE;
        }
    }

    return FALSE;
}


ULONG
FormatFileSize(
    IN PLARGE_INTEGER FileSize,
    IN DWORD Width,
    OUT PTCHAR FormattedSize,
    IN BOOLEAN Commas
    )
{
    TCHAR Buffer[100];
    PTCHAR s, s1;
    ULONG DigitIndex, Digit;
    ULONG Size;
    LARGE_INTEGER TempSize;

    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    TempSize = *FileSize;
    while (TempSize.HighPart != 0) {
        if (TempSize.HighPart != 0) {
            Digit = (ULONG)(TempSize.QuadPart % 10);
            TempSize.QuadPart = TempSize.QuadPart / 10;
        } else {
            Digit = TempSize.LowPart % 10;
            TempSize.LowPart = TempSize.LowPart / 10;
        }
        *--s = (TCHAR)(TEXT('0') + Digit);

        if ((++DigitIndex % 3) == 0 && Commas) {
            *--s = TEXT(',');
        }
    }
    Size = TempSize.LowPart;
    while (Size != 0) {
        *--s = (TCHAR)(TEXT('0') + (Size % 10));
        Size = Size / 10;

        if ((++DigitIndex % 3) == 0 && Commas) {
            *--s = TEXT(',');
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    } else if (Commas && *s == TEXT(',')) {
        s += 1;
    }

    Size = lstrlen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        lstrcpy( s1, s );
    } else {
        lstrcpy( FormattedSize, s );
    }

    return lstrlen( FormattedSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\comp\comp.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    Comp.cxx

Abstract:

    Compares the contents of two files or sets of files.

    COMP [data1] [data2] [/D] [/A] [/L] [/N=number] [/C]

      data1     Specifies location and name(s) of first file(s) to compare.
      data2     Specifies location and name(s) of second files to compare.
      /D        Displays differences in decimal format. This is the default
                setting.
      /A        Displays differences in ASCII characters.
      /L        Displays line numbers for differences.
      /N=number Compares only the first specified number of lines in each file.
      /C        Disregards case of ASCII letters when comparing files.
      /OFFLINE  Do not skip files with offline attribute set.

    To compare sets of files, use wildcards in data1 and data2 parameters.

Author:

    Barry J. Gilhuly  ***  W-Barry  *** Jun 91

Environment:

    ULIB, User Mode

--*/

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "bytestrm.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "iterator.hxx"
#include "path.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "smsg.hxx"
#include "comp.hxx"


extern "C" {
#include <ctype.h>
#include <stdio.h>
#include <string.h>
}


STREAM_MESSAGE  *psmsg = NULL;  // Create a pointer to the stream message
                                // class for program output.
ULONG           Errlev;         // The current program error level
ULONG           CompResult;



//
// Define a macro to deal with case insensitive comparisons
//
#define CASE_SENSITIVE( x )     ( ( _CaseInsensitive ) ? towupper( x ) : x )

VOID
StripQuotesFromString(
    IN  PWSTRING String
    )
/*++

Routine Description:

    This routine removes leading and trailing quote marks (if
    present) from a quoted string.  If the string is not a quoted
    string, it is left unchanged.

--*/
{
    if( String->QueryChCount() >= 2    &&
        String->QueryChAt( 0 ) == '\"' &&
        String->QueryChAt( String->QueryChCount() - 1 ) == '\"' ) {

        String->DeleteChAt( String->QueryChCount() - 1 );
        String->DeleteChAt( 0 );
    }
}

DEFINE_CONSTRUCTOR( COMP, PROGRAM );

VOID
COMP::Construct(
    )
/*++

Routine Description:

    Initializes the object.

Arguments:

    None.

Return Value:

    None.


--*/

{
    _InputPath1 = NULL;
    _InputPath2 = NULL;

    return;
}

VOID
COMP::Destruct(
    )
/*++

Routine Description:

    Cleans up after finishing with an FC object.

Arguments:

    None.

Return Value:

    None.


--*/

{
    DELETE( psmsg );
    if( _InputPath1 != NULL ) {
        DELETE( _InputPath1 );
    }
    if( _InputPath2 != NULL ) {
        DELETE( _InputPath2 );
    }

    return;
}

BOOLEAN
COMP::Initialize(
    )

/*++

Routine Description:

    Initializes an FC object.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArrayOfArg;
    PATH_ARGUMENT       ProgramName;
    FLAG_ARGUMENT       FlagDecimalFormat;
    FLAG_ARGUMENT       FlagAsciiFormat;
    FLAG_ARGUMENT       FlagLineNumbers;
    FLAG_ARGUMENT       FlagCaseInsensitive;
    FLAG_ARGUMENT       FlagRequestHelp;
    FLAG_ARGUMENT       FlagWrongNumber;
    FLAG_ARGUMENT       FlagIncludeOffline;
    FLAG_ARGUMENT       FlagIncludeOffline2;
    LONG_ARGUMENT       LongMatchLines;
    PATH_ARGUMENT       InFile1;
    PATH_ARGUMENT       InFile2;
    STRING_ARGUMENT     StringInvalidSwitch;
    WCHAR               WChar;
    DSTRING             InvalidString;

    _Numbered = FALSE;
    _Limited = FALSE;
    _InputPath1 = NULL;
    _InputPath2 = NULL;
    if( !LexArray.Initialize() ) {
        DebugPrintTrace(( "LexArray.Initialize() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }
    if( !ArgLex.Initialize(&LexArray) ) {
        DebugPrintTrace(( "ArgLex.Initialize() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    ArgLex.PutSwitches("/");
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutMultipleSwitch( "acdl" );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );

    if( !ArgLex.PrepareToParse() ) {
        DebugPrintTrace(( "ArgLex.PrepareToParse() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    if( !ProgramName.Initialize("*")                ||
        !FlagDecimalFormat.Initialize("/D")         ||
        !FlagAsciiFormat.Initialize("/A")           ||
        !FlagLineNumbers.Initialize("/L")           ||
        !FlagCaseInsensitive.Initialize("/C")       ||
        !FlagIncludeOffline.Initialize("/OFFLINE")  ||
        !FlagIncludeOffline2.Initialize("/OFF")     ||
        !FlagWrongNumber.Initialize("/N")           ||
        !LongMatchLines.Initialize("/N=*")          ||
        !FlagRequestHelp.Initialize("/?")           ||
        !StringInvalidSwitch.Initialize("/*")       ||
        !InFile1.Initialize("*")                    ||
        !InFile2.Initialize("*") ) {

        DebugPrintTrace(( "Unable to Initialize some or all of the Arguments!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }


    if( !ArrayOfArg.Initialize() ) {
        DebugPrintTrace(( "ArrayOfArg.Initialize() Failed\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    if( !ArrayOfArg.Put(&ProgramName)           ||
        !ArrayOfArg.Put(&FlagDecimalFormat)     ||
        !ArrayOfArg.Put(&FlagAsciiFormat)       ||
        !ArrayOfArg.Put(&FlagLineNumbers)       ||
        !ArrayOfArg.Put(&FlagCaseInsensitive)   ||
        !ArrayOfArg.Put(&FlagIncludeOffline)    ||
        !ArrayOfArg.Put(&FlagIncludeOffline2)   ||
        !ArrayOfArg.Put(&FlagWrongNumber)       ||
        !ArrayOfArg.Put(&LongMatchLines)        ||
        !ArrayOfArg.Put(&FlagRequestHelp)       ||
        !ArrayOfArg.Put(&StringInvalidSwitch)   ||
        !ArrayOfArg.Put(&InFile1)               ||
        !ArrayOfArg.Put(&InFile2) ) {

        DebugPrintTrace(( "ArrayOfArg.Put() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );

    }


    if( !ArgLex.DoParsing( &ArrayOfArg ) ||
         StringInvalidSwitch.IsValueSet() ) {

        if( StringInvalidSwitch.IsValueSet() ) {
            //
            // An invalid switch was found...
            //
//          InvalidString.Initialize( "/" );
//          InvalidString.Strcat( StringInvalidSwitch.GetString() );
            InvalidString.Initialize( "" );
            InvalidString.Strcat( StringInvalidSwitch.GetLexeme() );
            Errlev = INV_SWITCH;
            psmsg->Set( MSG_COMP_INVALID_SWITCH );
            psmsg->Display( "%W", &InvalidString );
        } else {
            psmsg->Set( MSG_COMP_BAD_COMMAND_LINE );
            psmsg->Display( "" );
            Errlev = SYNT_ERR;
        }
        return( FALSE );
    }

    if( FlagWrongNumber.IsValueSet() ) {
        psmsg->Set( MSG_COMP_NUMERIC_FORMAT );
        psmsg->Display( "" );
    }

    // It should now be safe to test the arguments for their values...
    if( FlagRequestHelp.QueryFlag() ) {

        // Send help message
        psmsg->Set( MSG_COMP_HELP_MESSAGE );
        psmsg->Display( "" );
        return( FALSE );
    }

    if( InFile1.IsValueSet() ) {
        StripQuotesFromString( (PWSTRING)InFile1.GetPath()->GetPathString() );
        if( ( _InputPath1 = NEW PATH ) == NULL ) {
            psmsg->Set( MSG_COMP_NO_MEMORY );
            psmsg->Display( "" );
            Errlev = NO_MEM_AVAIL;
            return( FALSE );
        }
        if( !_InputPath1->Initialize( InFile1.GetPath(), FALSE ) ) {
            DebugAbort( "Failed to initialize canonicolized version of the path 1\n" );
            Errlev = INTERNAL_ERROR;
            return( FALSE );
        }
    } else {
        _InputPath1 = NULL;
    }

    if( InFile2.IsValueSet() ) {
        StripQuotesFromString( (PWSTRING)InFile2.GetPath()->GetPathString() );
        if( ( _InputPath2 = NEW PATH ) == NULL ) {
            Errlev = NO_MEM_AVAIL;
            psmsg->Set( MSG_COMP_NO_MEMORY );
            psmsg->Display( "" );
            return( FALSE );
        }
        if( !_InputPath2->Initialize( InFile2.GetPath(), FALSE ) ) {
            DebugAbort( "Failed to initialize canonicolized version of the path 2\n" );
            Errlev = INTERNAL_ERROR;
            return( FALSE );
        }
    } else {
        _InputPath2 = NULL;
    }

    //
    // Set the output mode...
    //
    if( FlagAsciiFormat.QueryFlag() ) {
        _Mode = OUTPUT_ASCII;
    } else if( FlagDecimalFormat.QueryFlag() ) {
        _Mode = OUTPUT_DECIMAL;
    } else {
        _Mode = OUTPUT_HEX;
    }

    //
    // Set the remaining flags...
    //
    if( LongMatchLines.IsValueSet() ) {
        if( ( ( WChar = ( LongMatchLines.GetLexeme()->QueryChAt( 3 ) ) ) == '+' ) ||
            WChar == '-' ||
            ( _NumberOfLines = LongMatchLines.QueryLong() ) < 0 ) {
            Errlev = INV_SWITCH;
            psmsg->Set( MSG_COMP_BAD_NUMERIC_ARG );
            psmsg->Display( "%W", LongMatchLines.GetLexeme() );
            return( FALSE );
        }

        if ( _NumberOfLines != 0 ) {
            _Numbered = TRUE;
            _Limited = TRUE;
        }

    } else {
        _Numbered = FlagLineNumbers.QueryFlag();
        _Limited = FALSE;
    }
    _CaseInsensitive = FlagCaseInsensitive.QueryFlag();

    _SkipOffline = ( !FlagIncludeOffline.QueryFlag() ) &&
                   ( !FlagIncludeOffline2.QueryFlag() );

    if( FlagDecimalFormat.IsValueSet()      ||
        FlagAsciiFormat.IsValueSet()        ||
        FlagLineNumbers.IsValueSet()        ||
        FlagCaseInsensitive.IsValueSet()    ||
        FlagIncludeOffline.IsValueSet()     ||
        FlagIncludeOffline2.IsValueSet()    ||
        LongMatchLines.IsValueSet()         ||
        ( InFile1.IsValueSet()              &&
          InFile2.IsValueSet() ) ) {
        _OptionsFound = TRUE;
    } else {
        _OptionsFound = FALSE;
    }

    return( TRUE );
}

VOID
COMP::Start(
    )
/*++

Routine Description:

    Query missing information from the user and start the comparison

Arguments:

    None.

Return Value:

    None.


--*/


{
    DSTRING UserInput;
    PWSTRING InvalidSwitch;
    USHORT  OptionCount;
    LONG  Number;

    for( ;; ) {

        if( _InputPath1 == NULL ) {

            // Query a path for file 1...
            psmsg->Set( MSG_COMP_QUERY_FILE1, ERROR_MESSAGE );
            psmsg->Display( "" );
            if( !psmsg->QueryStringInput( &UserInput ) ) {
                psmsg->Set( MSG_COMP_UNEXPECTED_END );
                psmsg->Display( "" );
                Errlev = UNEXP_EOF;
                return;
            }
            if( ( _InputPath1 = NEW PATH ) == NULL ) {
                psmsg->Set( MSG_COMP_NO_MEMORY );
                psmsg->Display( "" );
                Errlev = NO_MEM_AVAIL;
                return;
            }
            if( !_InputPath1->Initialize( &UserInput, FALSE ) ) {
                DebugPrintTrace(( "Unable to initialize the path for file 1\n" ));
                Errlev = INTERNAL_ERROR;
                return;
            }
        }
        if( _InputPath2 == NULL ) {

            // Query a path for file 2...
            psmsg->Set( MSG_COMP_QUERY_FILE2, ERROR_MESSAGE );
            psmsg->Display( "" );
            if( !psmsg->QueryStringInput( &UserInput ) ) {
                psmsg->Set( MSG_COMP_UNEXPECTED_END );
                psmsg->Display( "" );
                Errlev = UNEXP_EOF;
                return;
            }
            if( ( _InputPath2 = NEW PATH ) == NULL ) {
                psmsg->Set( MSG_COMP_NO_MEMORY );
                psmsg->Display( "" );
                Errlev = NO_MEM_AVAIL;
                return;
            }
            if( !_InputPath2->Initialize( &UserInput, FALSE ) ) {
                DebugPrintTrace(( "Unable to initialize the path for file 2\n" ));
                Errlev = INTERNAL_ERROR;
                return;
            }
        }
        if( !_OptionsFound ) {

            //
            // Query Options from the user...
            //
            DSTRING Options;
            DSTRING Delim;
            CHNUM   CurSwitchStart, NextSwitchStart, Len;

            Delim.Initialize( "/-" );
            // Query a new list of options from the user
            for( OptionCount = 0; OptionCount < 5; OptionCount++ ) {
                psmsg->Set( MSG_COMP_OPTION, ERROR_MESSAGE );
                psmsg->Display( "" );
                if( !psmsg->QueryStringInput( &Options ) ) {
                    psmsg->Set( MSG_COMP_UNEXPECTED_END );
                    psmsg->Display( "" );
                    Errlev = UNEXP_EOF;
                    return;
                }
                if( Options.QueryChCount() == 0 ) {
                    break;
                }

                CurSwitchStart = Options.Strcspn( &Delim );
                if( CurSwitchStart != 0 ) {
                    psmsg->Set( MSG_COMP_BAD_COMMAND_LINE );
                    psmsg->Display( "" );
                    Errlev = SYNT_ERR;
                    return;
                }
                for( ;; ) {

                    Len = 0;
                    CurSwitchStart++;
                    NextSwitchStart = Options.Strcspn( &Delim, CurSwitchStart );

                    switch( towupper( Options.QueryChAt( CurSwitchStart ) ) ) {
                        case    'A':
                            _Mode = OUTPUT_ASCII;
                            CurSwitchStart++;
                            break;
                        case    'D':
                            _Mode = OUTPUT_DECIMAL;
                            CurSwitchStart++;
                            break;
                        case    'C':
                            _CaseInsensitive = TRUE;
                            CurSwitchStart++;
                            break;
                        case    'L':
                            _Numbered = TRUE;
                            CurSwitchStart++;
                            break;
                        case    'O':
                            PWSTRING pArg;
                            if( NextSwitchStart == INVALID_CHNUM ) {
                                pArg = Options.QueryString(CurSwitchStart);
                            } else {
                                pArg = Options.QueryString(CurSwitchStart, NextSwitchStart-CurSwitchStart);
                            }
                            if (pArg                                            &&
                                (0 == _wcsicmp(pArg->GetWSTR(), L"OFFLINE")) ) {
                                _SkipOffline = FALSE;
                                CurSwitchStart += wcslen( L"OFFLINE" );
                                DELETE( pArg );
                            } else if (pArg                                      &&
                                (0 == _wcsicmp(pArg->GetWSTR(), L"OFF")) ) {
                                _SkipOffline = FALSE;
                                CurSwitchStart += wcslen( L"OFF" );
                                DELETE( pArg );
                            } else {
                                InvalidSwitch = Options.QueryString( CurSwitchStart );
                                psmsg->Set( MSG_COMP_INVALID_SWITCH );
                                psmsg->Display( "%W", InvalidSwitch );
                                Errlev = INV_SWITCH;
                                DELETE( InvalidSwitch );
                                DELETE( pArg );

                                return;
                            }
                            break;
                        case    'N':
                            ++CurSwitchStart;
                            if( Options.QueryChAt( CurSwitchStart ) != '=' ) {
                                psmsg->Set( MSG_COMP_NUMERIC_FORMAT );
                                psmsg->Display( "" );
                                break;
                            }
                            ++CurSwitchStart;
                            if( CurSwitchStart == NextSwitchStart ) {
                                break;
                            }
                            if( NextSwitchStart == INVALID_CHNUM ) {
                                Len = INVALID_CHNUM;
                            } else {
                                Len = NextSwitchStart - CurSwitchStart;
                            }
                            if( !Options.QueryNumber( &Number, CurSwitchStart, Len ) ) {
                                InvalidSwitch = Options.QueryString( CurSwitchStart );
                                psmsg->Set( MSG_COMP_BAD_NUMERIC_ARG );
                                psmsg->Display( "%W", InvalidSwitch );
                                Errlev = BAD_NUMERIC_ARG;
                                DELETE( InvalidSwitch );

                                return;
                            }
                            if (Options.QueryNumber( &_NumberOfLines, CurSwitchStart, Len ) )    {
                                _Numbered = TRUE;
                                _Limited = TRUE;
                            }
                            CurSwitchStart += Len;
                            break;
                        default:
                            InvalidSwitch = Options.QueryString( CurSwitchStart - 1 );
                            psmsg->Set( MSG_COMP_INVALID_SWITCH );
                            psmsg->Display( "%W", InvalidSwitch );
                            Errlev = INV_SWITCH;
                            DELETE( InvalidSwitch );

                            return;
                    }
                    if( ( CurSwitchStart != NextSwitchStart ) ||
                        ( Len == INVALID_CHNUM ) ) {
                        break;
                    }
                }
            }
        }

        DoCompare();

        //
        // Check if there are more files to be compared...
        //
        psmsg->Set( MSG_COMP_MORE, ERROR_MESSAGE );
        psmsg->Display( "" );
        if( !psmsg->IsYesResponse() ) {
            break;
        }
        DELETE( _InputPath1 );
        DELETE( _InputPath2 );
        _InputPath1 = NULL;
        _InputPath2 = NULL;
        _OptionsFound = NULL;
    }

    return;
}

VOID
COMP::DoCompare(
    )
/*++

Routine Description:

    Perform the comparison of the files.

Arguments:

    None.

Return Value:

    None.


--*/


{
    FSN_FILTER          Filter;
    PARRAY              pNodeArray;
    PITERATOR           pIterator;
    PWSTRING            pTmp;
    PATH                File1Path;
    PFSN_DIRECTORY      pDirectory = NULL;
    PATH                CanonPath1;     // Canonicolized versions of the user paths
    PATH                CanonPath2;
    DSTRING             WildCardString;
    BOOLEAN             PrintSkipWarning = FALSE;
    BOOLEAN             OfflineSkipped;

    //
    // Initialize the wildcard string..
    //
    WildCardString.Initialize( "" );
    SYSTEM::QueryResourceString( &WildCardString, MSG_COMP_WILDCARD_STRING, "" );

    // Check to see if the input paths are empty.

    if (_InputPath1->GetPathString()->QueryChCount() == 0) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath1->GetPathString() );
        return;
    }

    if (_InputPath2->GetPathString()->QueryChCount() == 0) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath2->GetPathString() );
        return;
    }

    //
    // Test if the input paths contain only a directory name.  If it
    // does, append '*.*' to the path so all files in that directory
    // may be compared.
    //
    if( _InputPath1->IsDrive() ||
        ( !_InputPath1->HasWildCard() &&
          ( pDirectory = SYSTEM::QueryDirectory( _InputPath1 ) ) != NULL ) ) {

        // The input path corresponds to a directory...
        _InputPath1->AppendBase( &WildCardString );

    }
    DELETE( pDirectory );
    if( _InputPath2->IsDrive() ||
        ( !_InputPath2->HasWildCard() &&
          ( pDirectory = SYSTEM::QueryDirectory( _InputPath2 ) ) != NULL ) ) {

        // The input path corresponds to a directory...
        _InputPath2->AppendBase( &WildCardString );

    }
    DELETE( pDirectory );

    //
    // Canonicolize the input paths...
    //
    CanonPath1.Initialize( _InputPath1, TRUE );
    CanonPath2.Initialize( _InputPath2, TRUE );

    //
    // Test if the first path name contains any wildcards.  If it does,
    // the program must initialize an array of FSN_NODES (for multiple
    // files...
    //
    if( CanonPath1.HasWildCard() ) {
        PPATH   pTmpPath;
        //
        // Get a directory based on what the user specified for File 1
        //
        if( ( pTmpPath = CanonPath1.QueryFullPath() ) == NULL ) {
            DebugPrintTrace(( "Unable to grab the Prefix from the input path...\n" ));
            Errlev = INTERNAL_ERROR;
            return;
        }
        pTmpPath->TruncateBase();
        if( ( pDirectory = SYSTEM::QueryDirectory( pTmpPath, FALSE ) ) != NULL ) {
            //
            // Create an FSN_FILTER so we can use the directory to create an
            // array of FSN_NODES
            Filter.Initialize();

            pTmp = CanonPath1.QueryName();
            Filter.SetFileName( pTmp );
            DELETE( pTmp );
            Filter.SetAttributes( (FSN_ATTRIBUTE)0,             // ALL
                                  FSN_ATTRIBUTE_FILES,          // ANY
                                  FSN_ATTRIBUTE_DIRECTORY );    // NONE
            pNodeArray = pDirectory->QueryFsnodeArray( &Filter );
            pIterator = pNodeArray->QueryIterator();
            DELETE( pDirectory );

            _File1 = (FSN_FILE *)pIterator->GetNext();
        } else {
            _File1 = NULL;
        }
        DELETE( pTmpPath );
    } else {
        _File1 = SYSTEM::QueryFile( &CanonPath1 );
    }

    if( _File1 == NULL ) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath1->GetPathString() );
        return;
    }

    do {

        //
        // Explicitly find if File1 has offline attributes set (This is required
        // because SYSTEM::QueryFile is not used for getting the FSN_FILE object)
        //
        if (_SkipOffline && IsOffline(_File1)) {
            PrintSkipWarning = TRUE;
            Errlev = FILES_SKIPPED;
            DELETE( _File1 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }

        //
        // Replace the input path filename with what is to be opened...
        //
        pTmp = _File1->GetPath()->QueryName();
        _InputPath1->SetName( pTmp );
        DELETE( pTmp );


        // Determine if filename 2 contains any wildcards...
        if( CanonPath2.HasWildCard() ) {
            // ...if it does, expand them...
            PPATH   pExpanded;

            pExpanded = CanonPath2.QueryWCExpansion( (PATH *)_File1->GetPath() );
            if( pExpanded == NULL ) {
                Errlev = COULD_NOT_EXP;
                psmsg->Set( MSG_COMP_UNABLE_TO_EXPAND );
                psmsg->Display( "%W%W", _InputPath1->GetPathString(), _InputPath2->GetPathString() );
                DELETE( _File1 );
                break;
            }

            //
            // Place the expanded name in the input path...
            //
            pTmp = pExpanded->QueryName();
            _InputPath2->SetName( pTmp );
            DELETE( pTmp );

            psmsg->Set( MSG_COMP_COMPARE_FILES );
            psmsg->Display( "%W%W", _InputPath1->GetPathString(),
                                    _InputPath2->GetPathString()
                          );
            _File2 = SYSTEM::QueryFile( pExpanded, _SkipOffline, &OfflineSkipped );
            DELETE( pExpanded );

        } else {

            psmsg->Set( MSG_COMP_COMPARE_FILES );
            psmsg->Display( "%W%W", _InputPath1->GetPathString(),
                                    _InputPath2->GetPathString()
                          );
            _File2 = SYSTEM::QueryFile( &CanonPath2, _SkipOffline, &OfflineSkipped );

        }

        if( _File2 == NULL ) {
            if (OfflineSkipped) {
                // Skipping offline files is not an error, just track this happened
                PrintSkipWarning = TRUE;
                Errlev = FILES_SKIPPED;
            } else {
                // Display error message
                psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
                psmsg->Display( "%W", _InputPath2->GetPathString() );
                Errlev = CANT_OPEN_FILE;
            }
            DELETE( _File1 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }


        //
        // Open the streams...
        // Initialize _ByteStream1 and _ByteStream2 with BufferSize = 1024, to
        // improve performance
        //
        if( (( _FileStream1 = (FILE_STREAM *)_File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ) ) == NULL) ||
            !_ByteStream1.Initialize( _FileStream1, 1024 )
          ) {
            Errlev = CANT_READ_FILE;
            psmsg->Set( MSG_COMP_UNABLE_TO_READ );
            psmsg->Display( "%W", _File1->GetPath()->GetPathString() );
            DELETE( _File1 );
            DELETE( _File2 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }
        if( (( _FileStream2 = (FILE_STREAM *)_File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ) ) == NULL ) ||
            !_ByteStream2.Initialize( _FileStream2, 1024 )
          ) {
            Errlev = CANT_READ_FILE;
            psmsg->Set( MSG_COMP_UNABLE_TO_READ );
            psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
            DELETE( _FileStream1 );
            DELETE( _File1 );
            DELETE( _File2 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }

        BinaryCompare();

        // Close both streams now, since we are done with them...
        DELETE( _FileStream1 );
        DELETE( _FileStream2 );
        DELETE( _File1 );
        DELETE( _File2 );

        if( !CanonPath1.HasWildCard() ) {
            break;
        }

    } while( ( _File1 = (FSN_FILE *)pIterator->GetNext() ) != NULL );

    //
    // Print warning message if offline files were skipped
    //
    if(PrintSkipWarning) {
        psmsg->Set( MSG_COMP_OFFLINE_FILES_SKIPPED );
        psmsg->Display( "" );
    }

    return;
}

BOOLEAN
COMP::IsOffline(
    PFSN_FILE pFile
    )
/*++

Routine Description:

    Checks if a file object represents an offline file

Arguments:

    pFile - The file to check

Return Value:

    TRUE - if offline

Notes:

    This routine assumes a valid object that represnts a valid file
    On error, it returns FALSE since a none offline file is the default.

--*/
{
    PWSTRING    FullPath        =   NULL;
    BOOLEAN     fRet            =   FALSE;
    PCWSTR      FileName;
    DWORD       dwAttributes;

    DebugAssert( pFile );

    if ( pFile                                                                       &&
         ((FullPath = pFile->GetPath()->QueryFullPathString()) != NULL )             &&
         ((FileName = FullPath->GetWSTR()) != NULL )                                 &&
         ( FileName[0] != (WCHAR)'\0' )                                              &&
         ((dwAttributes = GetFileAttributes( FileName )) != -1) ) {

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE) {
            fRet = TRUE;
        }
    }

    DELETE( FullPath );

    return fRet;
}


#ifdef FE_SB  // v-junm - 08/30/93

BOOLEAN
COMP::CharEqual(
    PUCHAR  c1,
    PUCHAR  c2
    )
/*++

Routine Description:

    Checks to see if a PCHAR DBCS or SBCS char is equal or not.  For SBCS
    chars, if the CaseInsensitive flag is set, the characters are converted
    to uppercase and checked for equality.

Arguments:

    c1 - NULL terminating DBCS/SBCS char *.
    c2 - NULL terminating DBCS/SBCS char *.

Return Value:

    TRUE - if equal.

Notes:

    The char string sequence is:

        SBCS:
            c1[0] - char code.
            c1[1] - 0.
        DBCS:
            c1[0] - leadbyte.
            c1[1] - tailbyte.
            c1[2] - 0.

--*/
{
    if ( (*(c1+1) == 0)  && (*(c2+1) == 0 ) )
        return( CASE_SENSITIVE( *c1 ) == CASE_SENSITIVE( *c2 ) );
    else
        return( (*c1 == *c2) && (*(c1+1) == *(c2+1)) );
}

#endif

VOID
COMP::BinaryCompare(
    )
/*++

Routine Description:

    Does the actual binary compare between the two streams

Arguments:

    None.

Return Value:

    None.

Notes:

    The binary compare simply does a byte by byte comparison of the two
    files and reports all differences, as well as the offset into the
    file...   ...no line buffer is required for this comparision...

--*/
{
    ULONG   FileOffset = 0;
    ULONG   LineCount = 1;                  // Start the line count at 1...
    USHORT  Differences = 0;
    BYTE    Byte1, Byte2;
#ifdef FE_SB  // v-junm - 08/30/93
    BOOLEAN Lead = 0;                       // Set when leadbyte is read.
    UCHAR   Byte1W[3], Byte2W[3];           // PCHAR to contain DBCS/SBCS char.
    ULONG   DBCSFileOffset = 0;             // When ASCII output and DBCS char,
                                            //  the offset is where the lead
                                            //  byte is, not the tail byte.
#endif
    STR     Message[ 9 ];
    DSTRING ErrType;

    //
    // Set up the message string...
    //
    Message[ 0 ] = '%';
    Message[ 1 ] = 'W';
    if( !_Numbered ) {
        if (!SYSTEM::QueryResourceString(&ErrType, MSG_COMP_OFFSET_STRING, "")) {
            DebugPrintTrace(("COMP: Unable to read resource string %d\n", MSG_COMP_OFFSET_STRING));
            Errlev = INTERNAL_ERROR;
            return;
        }
        Message[ 2 ] = '%';
        Message[ 3 ] = 'X';
    } else {
        if (!SYSTEM::QueryResourceString(&ErrType, MSG_COMP_LINE_STRING, "")) {
            DebugPrintTrace(("COMP: Unable to read resource string %d\n", MSG_COMP_LINE_STRING));
            Errlev = INTERNAL_ERROR;
            return;
        }
        Message[ 2 ] = '%';
        Message[ 3 ] = 'd';
    }
    if( _Mode == OUTPUT_HEX ) {
        Message[ 4 ] = '%';
        Message[ 5 ] = 'X';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'X';
    } else if( _Mode == OUTPUT_DECIMAL ) {
        Message[ 4 ] = '%';
        Message[ 5 ] = 'd';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'd';
    } else {
#ifdef FE_SB  // v-junm - 08/30/93
// This is needed to display DBCS chars.  DBCS chars will be handed over
// as a pointer of chars.  In which turns out to go to a call to swprintf in
// basesys.cxx.  You may wonder why a DBCS char is stored as a string, but
// it works because before the call to swprintf is made, a 'h' is placed before
// the '%s' and makes a conversion to unicode.

        Message[ 4 ] = '%';
        Message[ 5 ] = 's';
        Message[ 6 ] = '%';
        Message[ 7 ] = 's';
#else // FE_SB
        Message[ 4 ] = '%';
        Message[ 5 ] = 'c';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'c';
#endif // FE_SB
    }
    Message[ 8 ] = 0;

    // Compare the lengths of the files - if they aren't the same and
    // the number of lines to match hasn't been specified, then return
    // 'Files are different sizes'.
    if( !_Limited ) {
        if( _File1->QuerySize() != _File2->QuerySize() ) {
            Errlev = DIFFERENT_SIZES;
            CompResult = FILES_ARE_DIFFERENT;
            psmsg->Set( MSG_COMP_DIFFERENT_SIZES );
            psmsg->Display( "" );
            return;
        }
    }

    for( ;; FileOffset++ ) {
        //if( !_FileStream1->ReadByte( &Byte1 ) ) {
        if( !_ByteStream1.ReadByte( &Byte1 ) ) {
            if( !_ByteStream1.IsAtEnd() ) {
                Errlev = CANT_READ_FILE;
                psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                psmsg->Display( "%W", _File1->GetPath()->GetPathString() );
                return;
            }
            //if( !_FileStream2->ReadByte( &Byte2 ) ) {
            if( !_ByteStream2.ReadByte( &Byte2 ) ) {
                if( !_ByteStream2.IsAtEnd() ) {
                    Errlev = CANT_READ_FILE;
                    psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                    psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
                    return;
                }
                break;
            } else {
                Errlev = FILE1_LINES;
                psmsg->Set( MSG_COMP_FILE1_TOO_SHORT );
                psmsg->Display( "%d", LineCount-1 );
                return;
            }
        } else {
            //if( !_FileStream2->ReadByte( &Byte2 ) ) {
            if( !_ByteStream2.ReadByte( &Byte2 ) ) {
                if( !_ByteStream2.IsAtEnd() ) {
                    Errlev = CANT_READ_FILE;
                    psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                    psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
                    return;
                }
                Errlev = FILE2_LINES;
                psmsg->Set( MSG_COMP_FILE2_TOO_SHORT );
                psmsg->Display( "%d", LineCount-1 );
                return;
            }
        }

#ifdef FE_SB  // v-junm - 08/30/93
// For hex and decimal display, we don't want to worry about DBCS chars.  This
// is a different spec than DOS/V (Japanese DOS), but it's much cleaner this
// way.  So, we will only worry about DBCS chars when the user asks us to
// display the difference in characters (/A option).  The file offset displayed
// for DBCS characters is always where the leadbyte is in the file even though
// only the tailbyte is different.

        DBCSFileOffset = FileOffset;

        //
        // Only going to worry about DBCS when user is comparing with
        // ASCII output.
        //
        //if ( _Mode == OUTPUT_ASCII )  {


        //kksuzuka: #133
        //We have to worry about DBCS with 'c' option also.
        if ( (_Mode==OUTPUT_ASCII) || ( _CaseInsensitive ) )  {

            if ( Lead )  {

                //
                // DBCS leadbyte already found.  Setup variables and
                // fill in tailbyte and null.
                //

                DBCSFileOffset--;
                Lead = FALSE;
                *(Byte1W+1) = Byte1;
                *(Byte2W+1) = Byte2;
                *(Byte1W+2) = *(Byte2W+2) = 0;

            }
            else if ( IsDBCSLeadByte( Byte1 ) || IsDBCSLeadByte( Byte2 ) )  {

                //
                // Found leadbyte.  Set lead flag telling the next time
                // around that the character is a tailbyte.
                //

                //
                // Save the leadbyte.  Tailbyte will be filled next time
                // around(above).
                //

                *Byte1W = Byte1;
                *Byte2W = Byte2;
                Lead = TRUE;
                continue;

            }
            else  {

                //
                // SBCS char.
                //

                *Byte1W = Byte1;
                *Byte2W = Byte2;
                *(Byte1W+1) = *(Byte2W+1) = 0;
                Lead = FALSE;
            }
        }
        else  {

            //
            // Not ASCII output (/a option).  Perform original routines.
            //

            *Byte1W = Byte1;
            *Byte2W = Byte2;
            *(Byte1W+1) = *(Byte2W+1) = 0;
        }

        //
        // Check to see if chars are equal.  If not, display difference.
        //

        if ( CharEqual( Byte1W, Byte2W ) == FALSE )  {

            psmsg->Set( MSG_COMP_COMPARE_ERROR );

            if ( _Mode == OUTPUT_ASCII )  {

                if ( _Numbered )
                    psmsg->Display( Message, &ErrType,
                                    LineCount, Byte1W, Byte2W );
                else
                    psmsg->Display( Message, &ErrType,
                                    DBCSFileOffset, Byte1W, Byte2W );

            }
            else  {
                if ( _Numbered )
                    psmsg->Display( Message, &ErrType,
                                    LineCount, *Byte1W, *Byte2W );
                //kksuzuka: #133
                //We have to worry about DBCS with c option also.
                //else
                else {
                    if( *Byte1W != *Byte2W ) {
                        psmsg->Display( Message, &ErrType,
                                    FileOffset, *Byte1W, *Byte2W );
                    }
                    else {
                        psmsg->Display( Message, &ErrType,
                                    FileOffset, *(Byte1W+1), *(Byte2W+1) );
                    }
                }
            }
#else // FE_SB
        // Now compare the bytes...if they are different, report the
        // difference...
        if( CASE_SENSITIVE( Byte1 ) != CASE_SENSITIVE( Byte2 ) ) {
            if( _Numbered ) {
                psmsg->Set( MSG_COMP_COMPARE_ERROR );
                psmsg->Display( Message, &ErrType, LineCount, Byte1, Byte2 );
            } else {
                psmsg->Set( MSG_COMP_COMPARE_ERROR );
                psmsg->Display( Message, &ErrType, FileOffset, Byte1, Byte2 );
            }

#endif // FE_SB

            if( ++Differences == MAX_DIFF ) {
                psmsg->Set( MSG_COMP_TOO_MANY_ERRORS );
                psmsg->Display( "" );
                Errlev = TEN_MISM;
                CompResult = FILES_ARE_DIFFERENT;
                return;
            }
        }
        //
        // Use <CR>'s imbedded in File1 to determine the line count.  This is
        // an inexact method (the differing byte may be '/r') but it is good
        // enough for the purposes of this program.
        //
#ifdef FE_SB // v-junm - 08/30/93
        if( *Byte1W == '\r' ) {
#else // FE_SB
        if( Byte1 == '\r' ) {
#endif // FE_SB
            LineCount++;
        }
        if( _Limited ) {
            if( LineCount > (ULONG)_NumberOfLines ) {
                break;
            }
        }
    }

#ifdef FE_SB  // v-junm - 08/30/93
// There may be a leadbyte without a tailbyte at the end of the file.  Check
// for it, and process accordingly.

    if ( _Mode == OUTPUT_ASCII && Lead )  {

        //
        // There is a leadbyte left.  Check to see if they are equal and
        // print difference if not.
        //

        if ( *Byte2W != *Byte1W )  {

            *(Byte1W+1) = *(Byte2W+1) = 0;
            Differences++;

            psmsg->Set( MSG_COMP_COMPARE_ERROR );
            if ( _Numbered )
                psmsg->Display(Message, &ErrType, LineCount, Byte1W, Byte2W);
            else
                psmsg->Display(Message, &ErrType, FileOffset-1, Byte1W, Byte2W);
        }
    }

#endif // FE_SB

    //
    // Check if any differences were found in the files
    //
    if( !Differences ) {
        psmsg->Set( MSG_COMP_FILES_OK );
        psmsg->Display( " " );
    } else {
        CompResult = FILES_ARE_DIFFERENT;
    }

    return;
}


int __cdecl
main(
    )
{


    DEFINE_CLASS_DESCRIPTOR( COMP );


    __try {

        COMP    Comp;

        psmsg = NEW STREAM_MESSAGE;

        if (psmsg == NULL) {
            DebugPrint("COMP: Out of memory\n");
            Errlev = NO_MEM_AVAIL;
            return( CANNOT_COMPARE_FILES );
        }
        // Initialize the stream message for standard input, stdout
        if (!Get_Standard_Output_Stream() ||
            !Get_Standard_Input_Stream() ||
            !psmsg->Initialize( Get_Standard_Output_Stream(),
                                Get_Standard_Input_Stream(),
                                Get_Standard_Error_Stream() )) {

            if (!Get_Standard_Output_Stream()) {
                DebugPrintTrace(("COMP: Output stream is NULL\n"));
            } else if (!Get_Standard_Input_Stream()) {
                DebugPrintTrace(("COMP: Input stream is NULL\n"));
            } else {
                DebugPrintTrace(("COMP: Unable to initialize message stream\n"));
            }

            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
        }

        if( !SYSTEM::IsCorrectVersion() ) {
            DebugPrintTrace(( "COMP: Incorrect Version Number...\n" ));
            psmsg->Set( MSG_COMP_INCORRECT_VERSION );
            psmsg->Display( "" );
            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
//            return( INCORRECT_DOS_VER );
        }

        // Set the Error level to Zero - No error...
        Errlev = NO_ERRORS;
        CompResult = FILES_ARE_EQUAL;

        if( !( Comp.Initialize() ) ) {
            //
            // The Command line didn't initialize properly, die nicely
            // without printing any error messages - Main doesn't know
            // why the Initialization failed...
            //
            // What has to be deleted by hand, or can everything be removed
            // by the destructor for the FC class?
            //
            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
//            return( Errlev );
        }


        // Do file comparison stuff...
        Comp.Start();
        Comp.Destruct();
//        return( Errlev );
        if( ( Errlev == NO_ERRORS ) || ( Errlev == TEN_MISM ) || ( Errlev == DIFFERENT_SIZES ) ) {
            return( CompResult );
        } else {
            return( CANNOT_COMPARE_FILES );
        }

    } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        // may not be able to display anything if initialization failed
        // in additional to out of stack space
        // so just send a message to the debug port

        DebugPrint("COMP: Out of stack space\n");
        Errlev = NO_MEM_AVAIL;
        return CANNOT_COMPARE_FILES;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\compact\support.h ===
/*++

Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    Support.h

Abstract:

    Support routine interfaces

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994

Revision History:


--*/


extern TCHAR    DecimalPlace[];
extern TCHAR    ThousandSeparator[];

extern VOID
ArrangeCommandLine(
    PTCHAR **pargv,
    int *pargc
    );

extern BOOLEAN
ExcludeThisFile(
    IN PTCHAR pch
    );

extern BOOLEAN
IsUncRoot(
    PTCHAR pch
    );

extern VOID
DisplayMsg(DWORD MsgNum, ... );

extern VOID
DisplayErr(PTCHAR Prefix, DWORD MsgNum, ... );

extern VOID
InitializeIoStreams();

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

extern ULONG
FormatFileSize(
    IN  PLARGE_INTEGER FileSize,
    IN  DWORD          Width,
    OUT PTCHAR         FormattedSize,
    IN  BOOLEAN        WithCommas
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\compact\compact.c ===
/*++

Copyright (c) 1994-2001 Microsoft Corporation

Module Name:

    Compact.c

Abstract:

    This module implements the double stuff utility for compressed NTFS
    volumes.

Author:

    Gary Kimura     [garyki]        10-Jan-1994

Revision History:


--*/

//
// Include the standard header files.
//

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <shellapi.h>
#include <tchar.h>

#include "support.h"
#include "msg.h"

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

//
//  FIRST_COLUMN_WIDTH - When compressing files, the width of the output
//  column which displays the file name
//

#define FIRST_COLUMN_WIDTH  (20)

//
//  Local procedure types
//

typedef BOOLEAN (*PACTION_ROUTINE) (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    );

typedef VOID (*PFINAL_ACTION_ROUTINE) (
    );

//
//  Declare global variables to hold the command line information
//

BOOLEAN DoSubdirectories      = FALSE;      // recurse
BOOLEAN IgnoreErrors          = FALSE;      // keep going despite errs
BOOLEAN UserSpecifiedFileSpec = FALSE;
BOOLEAN ForceOperation        = FALSE;      // compress even if already so
BOOLEAN Quiet                 = FALSE;      // be less verbose
BOOLEAN DisplayAllFiles       = FALSE;      // dsply hidden, system?
TCHAR   StartingDirectory[MAX_PATH];        // parameter to "/s"
ULONG   AttributesNoDisplay = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;

//
//  Declere global variables to hold compression statistics
//

LARGE_INTEGER TotalDirectoryCount;
LARGE_INTEGER TotalFileCount;
LARGE_INTEGER TotalCompressedFileCount;
LARGE_INTEGER TotalUncompressedFileCount;

LARGE_INTEGER TotalFileSize;
LARGE_INTEGER TotalCompressedSize;

TCHAR Buf[1024];                            // for displaying stuff


HANDLE
OpenFileForCompress(
    IN      PTCHAR      ptcFile
    )
/*++

Routine Description:

    This routine jumps through the hoops necessary to open the file
    for READ_DATA|WRITE_DATA even if the file has the READONLY
    attribute set.

Arguments:

    ptcFile     - Specifies the file that should be opened.

Return Value:

    A handle open on the file if successfull, INVALID_HANDLE_VALUE
    otherwise, in which case the caller may use GetLastError() for more
    info.

--*/
{
    BY_HANDLE_FILE_INFORMATION fi;
    HANDLE hRet;
    HANDLE h;
    INT err;

    hRet = CreateFile(
                ptcFile,
                FILE_READ_DATA | FILE_WRITE_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if (INVALID_HANDLE_VALUE != hRet) {
        return hRet;
    }

    if (ERROR_ACCESS_DENIED != GetLastError()) {
        return INVALID_HANDLE_VALUE;
    }

    err = GetLastError();

    h = CreateFile(
            ptcFile,
            FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    if (INVALID_HANDLE_VALUE == h) {
        return INVALID_HANDLE_VALUE;
    }

    if (!GetFileInformationByHandle(h, &fi)) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    if ((fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0) {

        // If we couldn't open the file for some reason other than that
        // the readonly attribute was set, fail.

        SetLastError(err);
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    fi.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;

    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    hRet = CreateFile(
            ptcFile,
            FILE_READ_DATA | FILE_WRITE_DATA,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    CloseHandle(h);

    if (INVALID_HANDLE_VALUE == hRet) {
        return INVALID_HANDLE_VALUE;
    }

    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY;

    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) {
        CloseHandle(hRet);
        return INVALID_HANDLE_VALUE;
    }

    return hRet;
}

//
//  Now do the routines to list the compression state and size of
//  a file and/or directory
//

BOOLEAN
DisplayFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    LARGE_INTEGER FileSize;
    LARGE_INTEGER CompressedSize;
    TCHAR PrintState;

    ULONG Percentage = 100;
    double Ratio = 1.0;

    FileSize.LowPart = FindData->nFileSizeLow;
    FileSize.HighPart = FindData->nFileSizeHigh;
    PrintState = ' ';

    //
    //  Decide if the file is compressed and if so then
    //  get the compressed file size.
    //

    CompressedSize.LowPart = GetCompressedFileSize( FileSpec,
        &CompressedSize.HighPart );

    if (FindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        // detecting any error according to Jul 2000 MSDN GetCompressedFileSize doc

        if (CompressedSize.LowPart == -1 && GetLastError() != 0) {
            CompressedSize.QuadPart = 0;
        }

        PrintState = 'C';
        TotalCompressedFileCount.QuadPart += 1;

    } else {

        // detecting any error according to Jul 2000 MSDN GetCompressedFileSize doc

        if ((CompressedSize.LowPart != -1 || GetLastError() == 0) &&
            CompressedSize.QuadPart != 0 &&
            CompressedSize.QuadPart < FileSize.QuadPart) {

            // File on DblSpace partition.

            PrintState = 'd';
            TotalCompressedFileCount.QuadPart += 1;

        } else {

            CompressedSize = FileSize;
            TotalUncompressedFileCount.QuadPart += 1;
        }
    }


    //
    //  Calculate the compression ratio for this file
    //

    if (CompressedSize.QuadPart != 0) {

        if (CompressedSize.QuadPart > FileSize.QuadPart) {

            //
            // The file probably grew between the time we got its size
            // and the time we got its compressed size.  Kludge.
            //

            FileSize.QuadPart = CompressedSize.QuadPart;
        }

        Ratio = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart;
    }

    //
    //  Print out the sizes compression state and file name
    //

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

        FormatFileSize(&FileSize, 9, Buf, FALSE);
        lstrcat(Buf, TEXT(" : "));
        FormatFileSize(&CompressedSize, 9, &Buf[lstrlen(Buf)], FALSE);

        swprintf(&Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), Ratio);

        if (_tcslen(DecimalPlace) == 1) {
            Buf[lstrlen(Buf)-3] = DecimalPlace[0];
        }

        DisplayMsg(COMPACT_THROW, Buf);

        DisplayMsg(COMPACT_TO_ONE);

        swprintf(Buf, TEXT("%c %s"), PrintState, FindData->cFileName);
        DisplayMsg(COMPACT_THROW_NL, Buf);
    }

    //
    //  Increment our running total
    //

    TotalFileSize.QuadPart += FileSize.QuadPart;
    TotalCompressedSize.QuadPart += CompressedSize.QuadPart;
    TotalFileCount.QuadPart += 1;

    return TRUE;
}


BOOLEAN
DoListAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    //
    //  List the compression attribute for the directory
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (0xFFFFFFFF == Attributes) {

                if (!Quiet || !IgnoreErrors) {

                    //
                    // Refrain from displaying error only when in quiet
                    // mode *and* we're ignoring errors.
                    //

                    DisplayErr(DirectorySpec, GetLastError());
                }

                if (!IgnoreErrors) {
                    return FALSE;
                }
            } else {

                if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {
                    DisplayMsg(COMPACT_LIST_CDIR, DirectorySpec);
                } else {
                    DisplayMsg(COMPACT_LIST_UDIR, DirectorySpec);
                }
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and list its compression state
    //

    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        //
        //  Make sure we don't try any paths that are too long for us
        //  to deal with.
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

            lstrcpy( DirectorySpecEnd, FileSpec );

            FindHandle = FindFirstFile( DirectorySpec, &FindData );

            if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  append the found file to the directory spec and open the
                   //  file
                   //

                   if (0 == lstrcmp(FindData.cFileName, TEXT("..")) ||
                       0 == lstrcmp(FindData.cFileName, TEXT("."))) {
                       continue;
                   }

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirectorySpec) +
                       lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                       continue;
                   }

                   lstrcpy( DirectorySpecEnd, FindData.cFileName );

                   //
                   //  Now print out the state of the file
                   //

                   DisplayFile( DirectorySpec, &FindData );

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  For if we are to do subdirectores then we will look for every
    //  subdirectory and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoListAction( DirectorySpec, FileSpec )) {

                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalListAction (
    )
{
    ULONG TotalPercentage = 100;
    double f = 1.0;

    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];
    TCHAR CompressedFileCount[32];
    TCHAR UncompressedFileCount[32];
    TCHAR CompressedSize[32];
    TCHAR FileSize[32];
    TCHAR Percentage[10];
    TCHAR Ratio[8];

    if (TotalCompressedSize.QuadPart != 0) {
        f = (double)TotalFileSize.QuadPart /
            (double)TotalCompressedSize.QuadPart;
    }

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);
    FormatFileSize(&TotalCompressedFileCount, 0, CompressedFileCount, FALSE);
    FormatFileSize(&TotalUncompressedFileCount, 0, UncompressedFileCount, FALSE);
    FormatFileSize(&TotalCompressedSize, 0, CompressedSize, TRUE);
    FormatFileSize(&TotalFileSize, 0, FileSize, TRUE);

    swprintf(Percentage, TEXT("%d"), TotalPercentage);
    swprintf(Ratio, TEXT("%2.1lf"), f);

    if (_tcslen(DecimalPlace) == 1)
        Ratio[lstrlen(Ratio)-2] = DecimalPlace[0];

    DisplayMsg(COMPACT_LIST_SUMMARY, FileCount, DirectoryCount,
               CompressedFileCount, UncompressedFileCount,
               FileSize, CompressedSize,
               Ratio );

    return;
}


BOOLEAN
CompressFile (
    IN HANDLE Handle,
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )

{
    USHORT State = 1;
    ULONG Length;
    ULONG i;
    BOOL Success;
    double f = 1.0;

    if ((FindData->dwFileAttributes &
         (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ENCRYPTED)) &&
        !ForceOperation) {

        return TRUE;
    }

    Success = DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &State,
        sizeof(USHORT), NULL, 0, &Length, FALSE );

    if (!Success) {

        if (Quiet && IgnoreErrors) {
            return FALSE || IgnoreErrors;
        }

        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(COMPACT_THROW, Buf);
        }

        DisplayMsg(COMPACT_ERR);

        if (!Quiet && !IgnoreErrors) {
            if (ERROR_INVALID_FUNCTION == GetLastError()) {

                // This error is caused by doing the fsctl on a
                // non-compressing volume.

                DisplayMsg(COMPACT_WRONG_FILE_SYSTEM_OR_CLUSTER_SIZE, FindData->cFileName);

            } else {
                DisplayErr(FindData->cFileName, GetLastError());
            }
        }

        return FALSE || IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(COMPACT_THROW, Buf);
        }
    }


    //
    //  Gather statistics and increment our running total
    //

    {
        LARGE_INTEGER FileSize;
        LARGE_INTEGER CompressedSize;
        ULONG Percentage = 100;

        FileSize.LowPart = FindData->nFileSizeLow;
        FileSize.HighPart = FindData->nFileSizeHigh;

        CompressedSize.LowPart = GetCompressedFileSize( FileSpec,
            &CompressedSize.HighPart );

        if (CompressedSize.LowPart == -1 && GetLastError() != 0)
            CompressedSize.QuadPart = 0;

        //
        // This statement to prevent confusion from the case where the
        // compressed file had been 0 size, but has grown since the filesize
        // was examined.
        //

        if (0 == FileSize.QuadPart) {
            CompressedSize.QuadPart = 0;
        }

        if (CompressedSize.QuadPart != 0) {

            f = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart;
        }

        //
        //  Print out the sizes compression state and file name
        //

        if (!Quiet &&
            (DisplayAllFiles ||
                (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

            FormatFileSize(&FileSize, 9, Buf, FALSE);
            lstrcat(Buf, TEXT(" : "));
            FormatFileSize(&CompressedSize, 9, &Buf[lstrlen(Buf)], FALSE);

            swprintf(&Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), f);

            if (_tcslen(DecimalPlace) == 1)
                Buf[lstrlen(Buf)-3] = DecimalPlace[0];

            DisplayMsg(COMPACT_THROW, Buf);

            DisplayMsg(COMPACT_TO_ONE);
            DisplayMsg(COMPACT_OK);
        }

        //
        //  Increment our running total
        //

        TotalFileSize.QuadPart += FileSize.QuadPart;
        TotalCompressedSize.QuadPart += CompressedSize.QuadPart;
        TotalFileCount.QuadPart += 1;
    }

    return TRUE;
}

BOOLEAN
DoCompressAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll set the compression bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 1;
        ULONG Length;

        FileHandle = OpenFileForCompress(DirectorySpec);

        if (INVALID_HANDLE_VALUE == FileHandle) {

            DisplayErr(DirectorySpec, GetLastError());
            return FALSE || IgnoreErrors;
        }

        DisplayMsg(COMPACT_COMPRESS_DIR, DirectorySpec);

        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &State,
            sizeof(USHORT), NULL, 0, &Length, FALSE )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(COMPACT_ERR);
            }
            if (!Quiet && !IgnoreErrors) {
	            if (ERROR_INVALID_FUNCTION == GetLastError()) {

    	            // This error is caused by doing the fsctl on a
        	        // non-compressing volume.

            	    DisplayMsg(COMPACT_WRONG_FILE_SYSTEM_OR_CLUSTER_SIZE, DirectorySpec);

	            } else {
    	            DisplayErr(DirectorySpec, GetLastError());
        	    }
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(COMPACT_OK);
        }

        CloseHandle( FileHandle );

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be compressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (Attributes == 0xFFFFFFFF) {
                DisplayErr(DirectorySpec, GetLastError());
                return FALSE || IgnoreErrors;
            }

            if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

                DisplayMsg(COMPACT_COMPRESS_CDIR, DirectorySpec);

            } else {

                DisplayMsg(COMPACT_COMPRESS_UDIR, DirectorySpec);

            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and compress it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ( (DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //


                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Hack hack, kludge kludge.  Refrain from compressing
                       //  files named "\NTDLR" to help users avoid hosing
                       //  themselves.
                       //

                       if (ExcludeThisFile(DirectorySpec)) {

                           if (!Quiet) {
                               DisplayMsg(COMPACT_SKIPPING, DirectorySpecEnd);
                           }

                           continue;
                       }

                       FileHandle = OpenFileForCompress(DirectorySpec);

                       if (INVALID_HANDLE_VALUE == FileHandle) {

                           if (!Quiet || !IgnoreErrors) {
                               DisplayErr(FindData.cFileName, GetLastError());
                           }

                           if (!IgnoreErrors) {
                               FindClose(FindHandle);
                               return FALSE;
                           }
                           continue;
                       }

                       //
                       //  Now compress the file
                       //

                       if (!CompressFile( FileHandle, DirectorySpec, &FindData )) {
                           CloseHandle( FileHandle );
                           FindClose( FindHandle );
                           return FALSE || IgnoreErrors;
                       }

                       //
                       //  Close the file and go get the next file
                       //

                       CloseHandle( FileHandle );
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoCompressAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalCompressAction (
    )
{
    ULONG TotalPercentage = 100;
    double f = 1.0;

    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];
    TCHAR CompressedSize[32];
    TCHAR FileSize[32];
    TCHAR Percentage[32];
    TCHAR Ratio[8];

    if (TotalCompressedSize.QuadPart != 0) {
        f = (double)TotalFileSize.QuadPart /
            (double)TotalCompressedSize.QuadPart;
    }

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);
    FormatFileSize(&TotalCompressedSize, 0, CompressedSize, TRUE);
    FormatFileSize(&TotalFileSize, 0, FileSize, TRUE);

    swprintf(Percentage, TEXT("%d"), TotalPercentage);
    swprintf(Ratio, TEXT("%2.1f"), f);

    if (_tcslen(DecimalPlace) == 1)
        Ratio[lstrlen(Ratio)-2] = DecimalPlace[0];

    DisplayMsg(COMPACT_COMPRESS_SUMMARY, FileCount, DirectoryCount,
                FileSize, CompressedSize, Ratio );

}


BOOLEAN
UncompressFile (
    IN HANDLE Handle,
    IN PWIN32_FIND_DATA FindData
    )
{
    USHORT State = 0;
    ULONG Length;

    if (!(FindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) &&
        !ForceOperation) {

        return TRUE;
    }

    if (!DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &State,
        sizeof(USHORT), NULL, 0, &Length, FALSE )) {

        if (!Quiet || !IgnoreErrors) {

            swprintf(Buf, TEXT("%s "), FindData->cFileName);
            DisplayMsg(COMPACT_THROW, Buf);

            DisplayMsg(COMPACT_ERR);

            if (!Quiet && !IgnoreErrors) {

                if (ERROR_INVALID_FUNCTION == GetLastError()) {

                    // This error is caused by doing the fsctl on a
                    // non-compressing volume.

                    DisplayMsg(COMPACT_WRONG_FILE_SYSTEM, FindData->cFileName);

                } else {
                    DisplayErr(FindData->cFileName, GetLastError());
                }
            }
        }
        return FALSE || IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        DisplayMsg(COMPACT_OK);
    }

    //
    //  Increment our running total
    //

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoUncompressAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll clear the compression bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 0;
        ULONG Length;

        FileHandle = OpenFileForCompress(DirectorySpec);

        if (INVALID_HANDLE_VALUE == FileHandle) {

            if (!Quiet || !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        DisplayMsg(COMPACT_UNCOMPRESS_DIR, DirectorySpec);

        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &State,
            sizeof(USHORT), NULL, 0, &Length, FALSE )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(COMPACT_ERR);

            }
            if (!Quiet && !IgnoreErrors) {
	            if (ERROR_INVALID_FUNCTION == GetLastError()) {

    	            // This error is caused by doing the fsctl on a
        	        // non-compressing volume.

            	    DisplayMsg(COMPACT_WRONG_FILE_SYSTEM_OR_CLUSTER_SIZE, DirectorySpec);

	            } else {
    	            DisplayErr(DirectorySpec, GetLastError());
        	    }
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(COMPACT_OK);
        }

        CloseHandle( FileHandle );

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be uncompressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (Attributes == 0xFFFFFFFF) {
                DisplayErr(DirectorySpec, GetLastError());
                return FALSE || IgnoreErrors;
            }

            if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

                DisplayMsg(COMPACT_UNCOMPRESS_CDIR, DirectorySpec);

            } else {

                DisplayMsg(COMPACT_UNCOMPRESS_UDIR, DirectorySpec);
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and uncompress it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       FileHandle = OpenFileForCompress(DirectorySpec);

                       if (INVALID_HANDLE_VALUE == FileHandle) {

                           if (!Quiet || !IgnoreErrors) {
                               DisplayErr(DirectorySpec, GetLastError());
                           }

                           if (!IgnoreErrors) {
                               FindClose( FindHandle );
                               return FALSE;
                           }
                           continue;
                       }

                       //
                       //  Now compress the file
                       //

                       if (!UncompressFile( FileHandle, &FindData )) {
                           CloseHandle( FileHandle );
                           FindClose( FindHandle );
                           return FALSE || IgnoreErrors;
                       }

                       //
                       //  Close the file and go get the next file
                       //

                       CloseHandle( FileHandle );
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );
           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoUncompressAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalUncompressAction (
    )

{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    DisplayMsg(COMPACT_UNCOMPRESS_SUMMARY, FileCount, DirectoryCount);

    return;
}


int
__cdecl
main()
{
    PTCHAR  *argv;
    ULONG   argc;

    ULONG   i;

    PACTION_ROUTINE         ActionRoutine = NULL;
    PFINAL_ACTION_ROUTINE   FinalActionRoutine = NULL;

    BOOLEAN UserSpecifiedFileSpec = FALSE;

    TCHAR   DirectorySpec[MAX_PATH];
    TCHAR   FileSpec[MAX_PATH];
    PTCHAR  p;
    INT     rtncode;

    InitializeIoStreams();

    DirectorySpec[0] = '\0';

    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (NULL == argv) {
        DisplayErr(NULL, GetLastError());
        return 1;
    }

    //
    //  Scan through the arguments looking for switches
    //

    for (i = 1; i < argc; i += 1) {

        if (argv[i][0] == '/') {

            if (0 == lstricmp(argv[i], TEXT("/c"))) {

                if (ActionRoutine != NULL &&
                    ActionRoutine != DoCompressAction) {

                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

                ActionRoutine = DoCompressAction;
                FinalActionRoutine = DoFinalCompressAction;

            } else if (0 == lstricmp(argv[i], TEXT("/u"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoListAction) {

                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

                ActionRoutine = DoUncompressAction;
                FinalActionRoutine = DoFinalUncompressAction;

            } else if (0 == lstricmp(argv[i], TEXT("/q"))) {

                Quiet = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/s"), 2)) {

                PTCHAR pch;

                DoSubdirectories = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    lstrcpy(StartingDirectory, pch + 1);
                } else if (2 == lstrlen(argv[i])) {

                    // Starting dir is CWD

                    GetCurrentDirectory( MAX_PATH, StartingDirectory );

                } else {
                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

            } else if (0 == lstricmp(argv[i], TEXT("/i"))) {

                IgnoreErrors = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/f"))) {

                ForceOperation = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/a"))) {

                DisplayAllFiles = TRUE;

            } else {

                DisplayMsg(COMPACT_USAGE, NULL);
                if (0 == lstricmp(argv[i], TEXT("/?")))
                    return 0;
                else
                    return 1;
            }

        } else {

            UserSpecifiedFileSpec = TRUE;
        }
    }

    //
    //  If the use didn't specify an action then set the default to do a listing
    //

    if (ActionRoutine == NULL) {

        ActionRoutine = DoListAction;
        FinalActionRoutine = DoFinalListAction;
    }

    //
    //  Get our current directoy because the action routines might move us
    //  around
    //

    if (!DoSubdirectories) {
        GetCurrentDirectory( MAX_PATH, StartingDirectory );
    } else if (!SetCurrentDirectory( StartingDirectory )) {
        DisplayErr(StartingDirectory, GetLastError());
        return 1;
    }

    //
    //  If the user didn't specify a file spec then we'll do just "*"
    //

    rtncode = 0;

    if (!UserSpecifiedFileSpec) {

        (VOID)GetFullPathName( TEXT("*"), MAX_PATH, DirectorySpec, &p );

        lstrcpy( FileSpec, p ); *p = '\0';

        //
        // Also want to make "compact /c" set the bit for the current
        // directory.
        //

        if (ActionRoutine != DoListAction) {

            if (!(ActionRoutine)( DirectorySpec, TEXT("") ))
                rtncode = 1;
        }

        if (!(ActionRoutine)( DirectorySpec, FileSpec ))
            rtncode = 1;

    } else {

        //
        //  Now scan the arguments again looking for non-switches
        //  and this time do the action, but before calling reset
        //  the current directory so that things work again
        //

        for (i = 1; i < argc; i += 1) {

            if (argv[i][0] != '/') {

                SetCurrentDirectory( StartingDirectory );

                //
                // Handle a command with "." as the file argument specially,
                // since it doesn't make good sense and the results without
                // this code are surprising.
                //

                if ('.' == argv[i][0] && '\0' == argv[i][1]) {
                    argv[i] = TEXT("*");
                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    *p = '\0';
                    p = NULL;
                } else {

                    PWCHAR pwch;

                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);

                    //
                    // We want to treat "foobie:xxx" as an invalid drive name,
                    // rather than as a name identifying a stream.  If there's
                    // a colon, there should be only a single character before
                    // it.
                    //

                    pwch = wcschr(argv[i], ':');
                    if (NULL != pwch && pwch - argv[i] != 1) {
                        DisplayMsg(COMPACT_INVALID_PATH, argv[i]);
                        rtncode = 1;
                        break;
                    }

                    //
                    // GetFullPathName strips trailing dots, but we want
                    // to save them so that "*." will work correctly.
                    //

                    if ((lstrlen(argv[i]) > 0) &&
                        ('.' == argv[i][lstrlen(argv[i]) - 1])) {
                        lstrcat(DirectorySpec, TEXT("."));
                    }
                }

                if (IsUncRoot(DirectorySpec)) {

                    //
                    // If the path is like \\server\share, we append an
                    // additional slash to make things come out right.
                    //

                    lstrcat(DirectorySpec, TEXT("\\"));
                    p = NULL;
                }


                if (p != NULL) {
                    lstrcpy( FileSpec, p ); *p = '\0';
                } else {
                    FileSpec[0] = '\0';
                }

                if (!(ActionRoutine)( DirectorySpec, FileSpec ) &&
                    !IgnoreErrors) {
                    rtncode = 1;
                    break;
                }
            }
        }
    }

    //
    //  Reset our current directory back
    //

    SetCurrentDirectory( StartingDirectory );

    //
    //  And do the final action routine that will print out the final
    //  statistics of what we've done
    //

    (FinalActionRoutine)();

    return rtncode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\compact\support.c ===
/*++

Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    Support routines for compact utility

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994

Revision History:


--*/

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <windows.h>
#include <tchar.h>
#include <limits.h>

#include "support.h"
#include "msg.h"


//
//  Declare routines to put out internationalized messages
//

typedef enum {
    READ_ACCESS,
    WRITE_ACCESS
} STREAMACCESS;

HANDLE
GetStandardStream(
    IN HANDLE   Handle,
    IN STREAMACCESS Access
    );

BOOLEAN
IsFile(
    IN PTCHAR   File,
    IN PTCHAR   Path
    );

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

TCHAR   ThousandSeparator[8];
TCHAR   DecimalPlace[8];

int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

}


VOID
InitializeIoStreams()
{
#ifdef FE_SB
    LANGID  LangId;
    LCID    lcid;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( lcid = MAKELCID(LangId, SORT_DEFAULT) );

    if (!GetLocaleInfo(lcid, LOCALE_STHOUSAND, ThousandSeparator, sizeof(ThousandSeparator)/sizeof(ThousandSeparator[0]))) {
        _tcscpy(ThousandSeparator, TEXT(","));
    }
    if (!GetLocaleInfo(lcid, LOCALE_SDECIMAL, DecimalPlace, sizeof(DecimalPlace)/sizeof(DecimalPlace[0]))) {
        _tcscpy(DecimalPlace, TEXT("."));
    }

#endif

    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);
}

TCHAR DisplayBuffer[4096];
CHAR DisplayBuffer2[4096];

VOID
DisplayMsg(DWORD MsgNum, ... )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0,
        DisplayBuffer, 4096, &ap);

    if (ConsoleOutput) {
        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len,
                 &bytes_written, NULL);
    }

    if (!success || bytes_written != len) {
        status = GetLastError();
    }

    va_end(ap);
}

VOID
DisplayErr(
    PTCHAR Prefix,
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;
    ULONG i;

    va_start(ap, MsgNum);

    if (NULL != Prefix) {
        lstrcpy(DisplayBuffer, Prefix);
        lstrcat(DisplayBuffer, TEXT(": "));
    } else {
        DisplayBuffer[0] = UNICODE_NULL;
    }

    i = lstrlen(DisplayBuffer);

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, MsgNum, 0,
        DisplayBuffer + i, 4096 - i, &ap);

    if (ConsoleError) {
        success = WriteConsole(hError, (LPVOID)DisplayBuffer, len + i,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hError, (LPVOID)DisplayBuffer2, len + i,
                 &bytes_written, NULL);
    }

    if (!success) {
        status = GetLastError();
    }
    va_end(ap);
}

BOOLEAN
ExcludeThisFile(
    IN PTCHAR Path
    )
/*++

Routine Description:

    Used to keep the user from compressing certain files
    which the machine needs to boot up.

Arguments:

    File - name to check for
    Path - the path to examine.

Return Value:

    TRUE  - the path looks like one that should not be compressed
    FALSE - the path looks like one that can be compressed

--*/
{
  return IsFile(TEXT("\\ntldr"), Path) ||
         IsFile(TEXT("\\cmldr"), Path);
}

BOOLEAN
IsFile(
    IN PTCHAR   File,
    IN PTCHAR   Path
    )
/*++

Routine Description:

    Checks to see if the given File matches that specified by Path.

Arguments:

    File - Name to look for
    Path - Path to examine

Return Value:

    TRUE - the path looks like the specified file.
    FALSE - the path does not look like the specified file.

--*/
{
    PTCHAR pch;

    // try "X:\<File>"

    if (0 == lstricmp(Path + 2, File)) {
        return TRUE;
    }

    // try "\\machine\share\<File>"

    if ('\\' == Path[0] && '\\' != Path[1]) {
        pch = lstrchr(Path + 2, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        pch = lstrchr(pch + 1, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        if (0 == lstricmp(pch, File)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
IsUncRoot(
    PTCHAR Path
    )
/*++

Routine Description:

    Determine whether the given path is of the form \\server\share.

Arguments:

    Path - the path to examine.

Return Value:

    TRUE - the path looks like a unc share name.
    FALSE - the path does not look like that.

--*/
{
    PTCHAR pch;

    if ('\\' != *Path || '\\' != *(Path + 1)) {
        return FALSE;
    }

    pch = lstrchr(Path + 2, '\\');
    if (NULL == pch) {
        //
        // There is no slash to seperate server and share.
        //

        return FALSE;
    }

    pch = lstrchr(pch + 1, '\\');
    if (NULL != pch) {
        //
        // There are additional component -- no match.
        //

        return FALSE;
    }

    if ('\\' == *(Path + lstrlen(Path))) {

        //
        // The string ends in slash -- it doesn't match.
        //

        return FALSE;
    }

    return TRUE;
}

ULONG
FormatFileSize(
    IN PLARGE_INTEGER FileSize,
    IN DWORD Width,
    OUT PTCHAR FormattedSize,
    IN BOOLEAN Commas
    )
{
    TCHAR           Buffer[100];
    PTCHAR          s, s1;
    ULONG           DigitIndex, Digit;
    ULONG           Size;
    LARGE_INTEGER   TempSize;
    ULONG           tslen;


    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    TempSize = *FileSize;
    while (TempSize.HighPart != 0) {
        if (TempSize.HighPart != 0) {
            Digit = (ULONG)(TempSize.QuadPart % 10);
            TempSize.QuadPart = TempSize.QuadPart / 10;
        } else {
            Digit = TempSize.LowPart % 10;
            TempSize.LowPart = TempSize.LowPart / 10;
        }
        *--s = (TCHAR)(TEXT('0') + Digit);

        if ((++DigitIndex % 3) == 0 && Commas) {
            tslen = _tcslen(ThousandSeparator);
            s -= tslen;
            _tcsncpy(s, ThousandSeparator, tslen);
        }
    }
    Size = TempSize.LowPart;
    while (Size != 0) {
        *--s = (TCHAR)(TEXT('0') + (Size % 10));
        Size = Size / 10;

        if ((++DigitIndex % 3) == 0 && Commas) {
            tslen = _tcslen(ThousandSeparator);
            s -= tslen;
            _tcsncpy(s, ThousandSeparator, tslen);
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    } else if (Commas && !_tcsncmp(s, ThousandSeparator, tslen)) {
        s += 1;
    }

    Size = lstrlen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        lstrcpy( s1, s );
    } else {
        lstrcpy( FormattedSize, s );
    }

    return lstrlen( FormattedSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\comp\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=comp
TARGETPATH=obj
TARGETTYPE=PROGRAM

LINKER_STACKCOMMITSIZE=4096

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\comp.cxx ..\comp.rc

INCLUDES=..\.;..\..\ulib\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\convert\convert.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        convert.cxx

Abstract:

        This module contains the definition of the CONVERT class, which
        implements the File System Conversion Utility.

Author:

    Ramon J. San Andres (ramonsa) sep-23-1991

Environment:

        ULIB, User Mode

--*/


#define _NTAPI_ULIB_
#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ulibcl.hxx"
#include "arg.hxx"
#include "file.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "autoreg.hxx"
#include "ifssys.hxx"
#include "ifsentry.hxx"
#include "hmem.hxx"
#include "convert.hxx"
#include "supera.hxx"

extern "C" {
#include <stdio.h>
#include "undo.h"
}

#include "fatofs.hxx"


#define     AUTOCHK_PROGRAM_NAME    L"AUTOCHK.EXE"
#define     AUTOCONV_PROGRAM_NAME   L"AUTOCONV.EXE"

#define     AUTOCHK_NAME            L"AUTOCHK"
#define     AUTOCONV_NAME           L"AUTOCONV"

#define     VALUE_NAME_PATH         L"PATH"
#define     VALUE_NAME_ARGS         L"ARGUMENTS"
#define     VALUE_NAME_FS           L"TARGET FILESYSTEM"

//
//  Scheduling status codes
//
#define     CONV_STATUS_NONE        0
#define     CONV_STATUS_SCHEDULED   1

static WCHAR    NameBuffer[16];         // holds cvf name

DWORD
WINAPI
SceConfigureConvertedFileSecurity(
    IN  PWSTR   pszDriveName,
    IN  DWORD   dwConvertDisposition
    );

INT __cdecl
main (
        )

/*++

Routine Description:

        Entry point for the conversion utility.

Arguments:

    None.

Return Value:

        One of the CONVERT exit codes.

Notes:

--*/

{

    INT     ExitCode = EXIT_ERROR;      //  Let's be pessimistic

    DEFINE_CLASS_DESCRIPTOR( CONVERT );

    {
        CONVERT Convert;

        //
        //      Initialize the CONVERT object.
        //
        if ( Convert.Initialize( &ExitCode ) ) {

            //
            //      Do the conversion
            //
            ExitCode = Convert.Convert();
        }
    }

    return ExitCode;
}



DEFINE_CONSTRUCTOR( CONVERT, PROGRAM );


NONVIRTUAL
VOID
CONVERT::Construct (
    )
/*++

Routine Description:

    converts a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    _Autochk    =   NULL;
    _Autoconv   =   NULL;
}



NONVIRTUAL
VOID
CONVERT::Destroy (
    )
/*++

Routine Description:

    Destroys a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    DELETE( _Autochk );
    DELETE( _Autoconv );
}




CONVERT::~CONVERT (
        )

/*++

Routine Description:

        Destructs a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    Destroy();
}




BOOLEAN
CONVERT::Initialize (
        OUT PINT        ExitCode
        )

/*++

Routine Description:

    Initializes the CONVERT object. Initialization consist of allocating memory
    for certain object members and argument parsing.

Arguments:

    ExitCode    -   Supplies pointer to CONVERT exit code.

Return Value:

    BOOLEAN -   TRUE if initialization succeeded, FALSE otherwise.

Notes:

--*/

{
    Destroy();

    //
    //      Initialize program object
    //
    if ( PROGRAM::Initialize( MSG_CONV_USAGE ) ) {

        //
        //      Parse the arguments
        //
        return ParseArguments( ExitCode );
    }

    //
    //  Could not initialize the program object.
    //
    *ExitCode = EXIT_ERROR;
    return FALSE;
}


INT
CONVERT::Convert (
        )
/*++

Routine Description:

    Converts the file system in a volume.
    Depending on the current file system, it loads the appropriate
    conversion library and calls its conversion entry point.

Arguments:

    None

Return Value:

    INT -   One of the CONVERT return codes

Notes:


--*/
{
    DSTRING         CurrentFsName;      //  Name of current FS in volume
    DSTRING         LibraryName;        //  Name of library to load
    DSTRING         EntryPoint;         //  Name of entry point in DLL
    DSTRING         fat_name;
    DSTRING         fat32_name;
    DSTRING         driveletter;
    DSTRING         user_old_label;
    DSTRING         null_string;
    PWSTRING        old_volume_label = NULL;
    PATH            dos_drive_path;
    INT             ExitCode = EXIT_SUCCESS;           //  CONVERT exit code
    CONVERT_STATUS  ConvertStatus;      //  Conversion status
    NTSTATUS        Status;             //  NT API status
    HANDLE          FsUtilityHandle;    //  Handle to DLL
    CONVERT_FN      Convert;            //  Pointer to entry point in DLL
    IS_CONVERSION_AVAIL_FN      IsConversionAvailable;
    DWORD           OldErrorMode;
    DRIVE_TYPE      drive_type;
    VOL_SERIAL_NUMBER old_serial;
    BOOLEAN         Error = FALSE;
    BOOLEAN         Success;
    BOOLEAN         Result;
    ULONG           flags;

#if defined(FE_SB) && defined(_X86_)
    if(IsPC98_N()){
        CONVERT Convert2;

        Convert2.ChangeBPB1(&_NtDrive);
    }
#endif

    //      Check to see if this is an ARC System Partition--if it
    //      is, don't convert it.
    //
    if( IFS_SYSTEM::IsArcSystemPartition( &_NtDrive, &Error ) ) {

        DisplayMessage( MSG_CONV_ARC_SYSTEM_PARTITION, ERROR_MESSAGE );
        return EXIT_ERROR;
    }

    //
    //      Ask the volume what file system it has, and use that name to
    //      figure out what DLL to load.
    //
    if ( !IFS_SYSTEM::QueryFileSystemName( &_NtDrive,
                                           &CurrentFsName,
                                           &Status )) {

        if ( Status == STATUS_ACCESS_DENIED ) {
            DisplayMessage( MSG_DASD_ACCESS_DENIED, ERROR_MESSAGE );
        } else {
            DisplayMessage( MSG_FS_NOT_DETERMINED, ERROR_MESSAGE, "%W", &_DisplayDrive );
        }

        return EXIT_ERROR;
    }

    CurrentFsName.Strupr();
    _FsName.Strupr();

    if( CurrentFsName == _FsName ) {
        DisplayMessage( MSG_CONV_ALREADY_CONVERTED, ERROR_MESSAGE, "%W%W",
                        &_DisplayDrive, &_FsName );
        return EXIT_ERROR;
    }

    if (!fat_name.Initialize("FAT") ||
        !fat32_name.Initialize("FAT32")) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return EXIT_ERROR;
    }

    if (CurrentFsName == fat_name || CurrentFsName == fat32_name) {

        if ( !LibraryName.Initialize( "CNVFAT" ) ||
             !EntryPoint.Initialize( "IsConversionAvailable" ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return( EXIT_ERROR );
        }

        //
        //  Get pointer to the conversion entry point and convert the volume.
        //
        if (NULL == (IsConversionAvailable =
                     (IS_CONVERSION_AVAIL_FN)SYSTEM::QueryLibraryEntryPoint(
                      &LibraryName, &EntryPoint, &FsUtilityHandle ))) {
            //
            //  There is no conversion DLL for the file system in the volume.
            //
            DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                            "CONVERT", &CurrentFsName );
            return EXIT_ERROR;
        }

        if (IsConversionAvailable(&_FsName) == -1) {
            DisplayMessage ( MSG_CONV_CONVERSION_NOT_AVAILABLE, ERROR_MESSAGE,
                             "%W%W", &CurrentFsName, &_FsName );
            return EXIT_ERROR;
        }

    } else {
        DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                        "CONVERT", &CurrentFsName );
        return EXIT_ERROR;
    }

    //
    //  Display the current file system type. (Standard in all file system utilities)
    //
    DisplayMessage( MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE, "%W", &CurrentFsName );

    //
    //  We also initialize the name of the conversion entry point in the DLL
    //  ("Convert")
    //
    if ( !EntryPoint.Initialize( "ConvertFAT" )) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return( EXIT_ERROR );
    }

    //
    //  Get pointer to the conversion entry point and convert the volume.
    //
    if (NULL == (Convert = (CONVERT_FN)SYSTEM::QueryLibraryEntryPoint(
        &LibraryName, &EntryPoint, &FsUtilityHandle ))) {
        //
        //  There is no conversion DLL for the file system in the volume.
        //
        DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                        "CONVERT", &CurrentFsName );
        return EXIT_ERROR;
    }


    // If the volume has a label, prompt the user for it.
    // Note that if it has no label we do nothing.

    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    drive_type = SYSTEM::QueryDriveType(&_DosDrive);

    if (null_string.Initialize( "" ) &&
        (drive_type != RemovableDrive) &&
        dos_drive_path.Initialize( &_DosDrive) &&
        (old_volume_label =
         SYSTEM::QueryVolumeLabel( &dos_drive_path,
                                   &old_serial )) != NULL &&
        old_volume_label->Stricmp( &null_string ) != 0 ) {

        // This drive has a label. To give the user
        // a bit more protection, prompt for the old label:

        DisplayMessage( MSG_ENTER_CURRENT_LABEL, NORMAL_MESSAGE, "%W",
                        &_DisplayDrive );

        _Message.QueryStringInput( &user_old_label );

        if( old_volume_label->Stricmp( &user_old_label ) != 0 ) {

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            DisplayMessage( MSG_WRONG_CURRENT_LABEL, ERROR_MESSAGE );

            DELETE( old_volume_label );

            return EXIT_ERROR;
        }
    }

    // Re-enable hard error popups

    SetErrorMode( OldErrorMode );

    DELETE( old_volume_label );

    BOOLEAN         delete_uninstall_backup = FALSE;
    OSVERSIONINFOEX os_version_info;

    if (Uninstall_Valid == IsUninstallImageValid(Uninstall_FatToNtfsConversion, &os_version_info)) {
        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP, NORMAL_MESSAGE );
        if (!_Message.IsYesResponse(FALSE)) {
            return EXIT_ERROR;
        }
        delete_uninstall_backup = TRUE;
    }


    flags = _Verbose ? CONVERT_VERBOSE_FLAG : 0;
    flags |= _NoChkdsk ? CONVERT_NOCHKDSK_FLAG : 0;
    flags |= _ForceDismount ? CONVERT_FORCE_DISMOUNT_FLAG : 0;
    flags |= _NoSecurity ? CONVERT_NOSECURITY_FLAG : 0;
    //
    // no pause flag needed since we don't want to pause
    //

    Result = Convert( &_NtDrive,
                      &_FsName,
                      &_CvtZoneFileName,
                      &_Message,
                      flags,
                      &ConvertStatus);

    SYSTEM::FreeLibraryHandle( FsUtilityHandle );

    if ( Result ) {

        DWORD       sce_result = NO_ERROR;

        ExitCode = EXIT_SUCCESS;

        if (!_NoSecurity && _DosDrive.QueryChCount() == 2 && _DosDrive.QueryChAt(1) == ':') {

            DSTRING     msg;

            sce_result = SceConfigureConvertedFileSecurity( (PWSTR)_DosDrive.GetWSTR(), 0 );
            if ( sce_result != NO_ERROR ) {
                if ( SYSTEM::QueryWindowsErrorMessage( sce_result, &msg ) ) {
                    DisplayMessage( MSG_CONV_SCE_FAILURE_WITH_MESSAGE, ERROR_MESSAGE, "%W", &msg );
                } else {
                    DisplayMessage( MSG_CONV_SCE_SET_FAILURE, ERROR_MESSAGE, "%d", sce_result );
                }
            }
        }

        if (!NT_SUCCESS(SUPERAREA::GenerateLabelNotification(&_NtDrive))) {
            DisplayMessage( MSG_CONV_UNABLE_TO_NOTIFY, ERROR_MESSAGE );
            ExitCode = EXIT_ERROR;
        }

        if (delete_uninstall_backup && !RemoveUninstallImage()) {

            DWORD       last_error = GetLastError();
            DSTRING     errmsg;

            if (SYSTEM::QueryWindowsErrorMessage( last_error, &errmsg )) {
                DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%W", &errmsg );
            } else {
                DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%d", last_error );
            }
            ExitCode = EXIT_ERROR;
        }

        //
        // We're done.
        //
        if ( sce_result == NO_ERROR && ExitCode == EXIT_SUCCESS ) {
            DisplayMessage( MSG_CONV_CONVERSION_COMPLETE, NORMAL_MESSAGE );
            return EXIT_SUCCESS;
        } else {
            return EXIT_ERROR;
        }

    } else {

        //
        //  The conversion was not successful. Determine what the problem
        //  was and return the appropriate CONVERT exit code.
        //
        switch ( ConvertStatus ) {

          case CONVERT_STATUS_CONVERTED:
            //
            //  This is an inconsistent state, Convert should return
            //  TRUE if the conversion was successful!
            //
            DebugPrintTrace(( "CONVERT Error: Conversion failed, but status is success!\n" ));
            DebugAssert( FALSE );
            DisplayMessage( MSG_CONV_CONVERSION_MAYHAVE_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_INVALID_FILESYSTEM:
            //
            //  The conversion DLL does not recognize the target file system.
            //
            DisplayMessage( MSG_CONV_INVALID_FILESYSTEM, ERROR_MESSAGE, "%W", &_FsName );
            ExitCode = EXIT_UNKNOWN;
            break;

          case CONVERT_STATUS_CONVERSION_NOT_AVAILABLE:
            //
            //  The target file system is valid, but the conversion is not
            //  available.
            //
            DisplayMessage( MSG_CONV_CONVERSION_NOT_AVAILABLE, ERROR_MESSAGE,
                            "%W%W", &CurrentFsName, &_FsName );
            ExitCode = EXIT_NOCANDO;
            break;

          case CONVERT_STATUS_NTFS_RESERVED_NAMES:
            DisplayMessage( MSG_CONV_NTFS_RESERVED_NAMES, ERROR_MESSAGE, "%W", &_DisplayDrive );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_WRITE_PROTECTED:
            DisplayMessage( MSG_CONV_WRITE_PROTECTED, ERROR_MESSAGE, "%W", &_DisplayDrive );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_CANNOT_LOCK_DRIVE:
            //
            //  The drive cannot be locked. We must schedule ChkDsk and AutoConv
            //  to do the job during the next system boot.
            //

            DisplayMessage( MSG_CONVERT_ON_REBOOT_PROMPT, NORMAL_MESSAGE, "%W",
                            &_DisplayDrive );

            // Note that ScheduleAutoConv reports its success or
            // failure, so no additional messages are required.
            //
            if ( _Message.IsYesResponse( FALSE ) &&
                 ScheduleAutoConv() ) {
                if (!_NoSecurity && _DosDrive.QueryChCount() == 2 && _DosDrive.QueryChAt(1) == ':') {

                    DSTRING     msg;
                    DWORD       sce_result;

                    sce_result = SceConfigureConvertedFileSecurity( (PWSTR)_DosDrive.GetWSTR(), 1 );
                    if ( sce_result != NO_ERROR ) {
                        if ( SYSTEM::QueryWindowsErrorMessage( sce_result, &msg ) ) {
                            DisplayMessage( MSG_CONV_SCE_FAILURE_WITH_MESSAGE, ERROR_MESSAGE, "%W", &msg );
                        } else {
                            DisplayMessage( MSG_CONV_SCE_SCHEDULE_FAILURE, ERROR_MESSAGE, "%d", sce_result );
                        }
                        //
                        // error in setting up security for files
                        //
                        ExitCode = EXIT_ERROR;
                    } else {
                        ExitCode = EXIT_SCHEDULED;
                    }

                } else {
                    //
                    // no need to worry about security and so return success
                    //
                    ExitCode = EXIT_SCHEDULED;
                }

                if (delete_uninstall_backup && !RemoveUninstallImage()) {

                    DWORD       last_error = GetLastError();
                    DSTRING     errmsg;

                    if (SYSTEM::QueryWindowsErrorMessage( last_error, &errmsg )) {
                        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%W", &errmsg );
                    } else {
                        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%d", last_error );
                    }
                    ExitCode = EXIT_ERROR;
                }

            } else {
                //
                // Don't want to schedule a convert or scheduling failed
                //
                ExitCode = EXIT_ERROR;
            }

            break;

          case CONVERT_STATUS_INSUFFICIENT_FREE_SPACE:
          case CONVERT_STATUS_DRIVE_IS_DIRTY:
          case CONVERT_STATUS_ERROR:
            //
            //  The conversion failed.
            //
            DisplayMessage( MSG_CONV_CONVERSION_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            if(ConvertStatus == CONVERT_STATUS_INSUFFICIENT_FREE_SPACE) {
                ExitCode = EXIT_NOFREESPACE;
            } else {
                ExitCode = EXIT_ERROR;
            }
            break;

          default:
            //
            //  Invalid status code
            //
            DebugPrintTrace(( "CONVERT Error: Convert status code %X invalid!\n",
                              ConvertStatus ));
            DisplayMessage( MSG_CONV_CONVERSION_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            ExitCode = EXIT_ERROR;
            break;
        }

        return ExitCode;
    }
}


PPATH
CONVERT::FindSystemFile(
    IN  PWSTR   FileName
    )

/*++

Routine Description:

    Makes sure that the given file is in the system directory.

Arguments:

    FileName    -   Supplies the name of the file to look for.

Return Value:

    PPATH   -   Path to the file found

--*/

{


    DSTRING     Name;
    PPATH       Path    = NULL;
    PFSN_FILE   File    = NULL;


    if ( !(Path = SYSTEM::QuerySystemDirectory() ) ) {

        DisplayMessage( MSG_CONV_CANNOT_FIND_SYSTEM_DIR, ERROR_MESSAGE );
        return FALSE;

    }

    if ( !Name.Initialize( FileName ) ||
         !Path->AppendBase( &Name ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE   );
        DELETE( Path );
                return FALSE;
    }


    if ( !(File = SYSTEM::QueryFile( Path )) ) {
        DisplayMessage( MSG_CONV_CANNOT_FIND_FILE, ERROR_MESSAGE, "%W", Path->GetPathString() );
        DELETE( Path );
                return FALSE;
    }

    DELETE( File );

    return Path;
}





BOOLEAN
CONVERT::ParseArguments(
        OUT PINT                        ExitCode
        )

/*++

Routine Description:

    Parses the command line and sets the parameters used by the conversion
        utility.

    The arguments accepted are:

        drive:              Drive to convert
        /fs:fsname          File system to convert to
        /v                  Verbose mode
        /?                  Help
        /CVTAREA:filename   Filename for convert zone as place holder
                            for the $MFT, $Logfile, and Volume bitmap
        /NoSecurity         Allow everyone access
        /NoChkdsk           Skip chkdsk
        /x                  Force a dismount on the volume if necessary


Arguments:

    ExitCode -          Supplies pointer to CONVERT exit code

Return Value:

    BOOLEAN - TRUE if arguments were parsed correctly and program can
                    continue.
              FALSE if the program should exit. ExitCode contains the
                    value with which the program should exit. Note that this
                    does not necessarily means an error (e.g. user requested
                    help).

--*/

{

    UCHAR       SequenceNumber;

    PATH                path;
    DSTRING             drive_path_string;
    PATH_ANALYZE_CODE   rst;

    DebugPtrAssert( ExitCode );

    //
    //  Parse command line
    //
    if ( !ParseCommandLine( NULL, TRUE ) ) {

        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

        //
        //      If the user requested help, give it.
        //
    if ( _Help ) {
        DisplayMessage( MSG_CONV_USAGE );
        *ExitCode = EXIT_SUCCESS;
        return FALSE;
    }


#ifdef DBLSPACE_ENABLED
    if (_Compress && !_Uncompress) {
        //
        // We don't allow you to specify /c (compress resulting
        // filesystem) unless the source filesystem has dblspace.
        //

        DisplayMessage(MSG_CONV_SLASH_C_INVALID, ERROR_MESSAGE);
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }
#endif // DBLSPACE_ENABLED

    //
    //  If the command line did not specify a drive, we use the
    //  current drive.
    //
    if ( _DosDrive.QueryChCount() == 0 ) {

        if ( !SYSTEM::QueryCurrentDosDriveName( &_DosDrive ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
    }

    if ( !path.Initialize( &_DosDrive ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

    rst = path.AnalyzePath( &_GuidDrive,
                            &_FullPath,
                            &drive_path_string );

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            if (drive_path_string.QueryChCount() != 0) {
                DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
                *ExitCode = EXIT_ERROR;
                return FALSE;
            }
            if (path.IsGuidVolName()) {
                if (!_DisplayDrive.Initialize(&_GuidDrive)) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            } else {
                if (!_DisplayDrive.Initialize(_FullPath.GetPathString())) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            }
            if (_FullPath.GetPathString()->QueryChCount() == 2 &&
                _FullPath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!_DosDrive.Initialize(_FullPath.GetPathString())) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            } else {
                if (!_DosDrive.Initialize(&_GuidDrive)) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            }
            break;

        case PATH_OUT_OF_MEMORY:
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            DisplayMessage( MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        default:
            DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
    }

    if (!_DosDrive.Strupr()) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

    //
    // Make sure that drive is valid and is not remote.
    //
    switch ( SYSTEM::QueryDriveType( &_DosDrive ) ) {

        case UnknownDrive:
            DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case CdRomDrive:
            DisplayMessage( MSG_CONV_CANT_CDROM, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case RemoteDrive:
            DisplayMessage( MSG_CONV_CANT_NETWORK, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        default:
            break;

    }

    //
    //  Make sure a target file system was specified. Note that we do not
    //  validate the file system, we accept any string.
    //
    if ( _FsName.QueryChCount() == 0 ) {
        DisplayMessage( MSG_CONV_NO_FILESYSTEM_SPECIFIED, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }



    //
    //  Set other object members.
    //
    if ( !IFS_SYSTEM::DosDriveNameToNtDriveName( &_DosDrive, &_NtDrive )) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    //
    // If we're to uncompress a dblspace volume, generate the cvf name.
    //

    if (_Uncompress) {
        swprintf(NameBuffer, L"DBLSPACE.%03d", SequenceNumber);

        if ( _FullPath.GetPathString()->QueryChCount() == 0 ) {
            DisplayMessage( MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
        if (!_CvfName.Initialize(NameBuffer)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
    }
#endif // DBLSPACE_ENABLED

    *ExitCode = EXIT_SUCCESS;
    return TRUE;
}



BOOLEAN
CONVERT::ParseCommandLine (
    IN      PCWSTRING   CommandLine,
    IN      BOOLEAN     Interactive
    )
/*++

Routine Description:

    Parses the CONVERT (AUTOCONV) command line.

    The arguments accepted are:

        drive:                  Drive to convert
        /fs:fsname              File system to convert to
        /v                      Verbose mode
        /uncompress[:sss]       Convert from dblspace
        /c                      Compress resulting filesystem
        /?                      Help
        /CVTAREA:filename       Filename for convert zone as place holder
                                for the $MFT, $Logfile, and Volume bitmap

Arguments:

    CommandLine     -   Supplies command line to parse
    Interactive     -   Supplies Interactive flag

Return Value:

    BOOLEAN - TRUE if arguments were parsed correctly.

--*/

{
    ARRAY               ArgArray;               //  Array of arguments
    ARRAY               LexArray;               //  Array of lexemes
    ARGUMENT_LEXEMIZER  ArgLex;                 //  Argument Lexemizer
    STRING_ARGUMENT     DriveArgument;          //  Drive argument
    STRING_ARGUMENT     ProgramNameArgument;    //  Program name argument
    STRING_ARGUMENT     FsNameArgument;         //  Target FS name argument
    STRING_ARGUMENT     ConvertZoneArgument;    //  Convert Zone file name
    FLAG_ARGUMENT       HelpArgument;           //  Help flag argument
    FLAG_ARGUMENT       VerboseArgument;        //  Verbose flag argument
    FLAG_ARGUMENT       NoSecurityArgument;     //  Skip setting of security argument
    FLAG_ARGUMENT       NoChkdskArgument;       //  Skip chkdsk argument
    FLAG_ARGUMENT       ForceDismountArgument;  //  Force a dismount argument
#ifdef DBLSPACE_ENABLED
    FLAG_ARGUMENT       UncompressArgument;     //  Uncompress flag argument
    FLAG_ARGUMENT       CompressArgument;       //  Compress flag argument
    LONG_ARGUMENT       UncompressNumberArgument;// Sequence number argument
#endif // DBLSPACE_ENABLED
    PWSTRING            InvalidArg;             //  Invalid argument catcher


    //
    //      Initialize all the argument parsing machinery.
    //
    if( !ArgArray.Initialize( 7, 1 )                    ||
        !LexArray.Initialize( 7, 1 )                    ||
        !ArgLex.Initialize( &LexArray )                 ||
        !DriveArgument.Initialize( "*" )                ||
        !HelpArgument.Initialize( "/?" )                ||
        !VerboseArgument.Initialize( "/V" )             ||
        !NoSecurityArgument.Initialize( "/NoSecurity" ) ||
        !NoChkdskArgument.Initialize( "/NoChkdsk" )     ||
        !ForceDismountArgument.Initialize( "/X" )       ||
#ifdef DBLSPACE_ENABLED
        !CompressArgument.Initialize( "/C" )            ||
#endif // DBLSPACE_ENABLED
        !ProgramNameArgument.Initialize( "*" )          ||
#ifdef DBLSPACE_ENABLED
        !UncompressArgument.Initialize( "/UNCOMPRESS" ) ||
        !UncompressNumberArgument.Initialize( "/UNCOMPRESS:*" ) ||
#endif // DBLSPACE_ENABLED
        !FsNameArgument.Initialize( "/FS:*" )           ||
        !ConvertZoneArgument.Initialize( "/CVTAREA:*" ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
        return FALSE;
    }

    //
    //  The conversion utility is case-insensitive
    //
    ArgLex.SetCaseSensitive( FALSE );

    if( !ArgArray.Put( &ProgramNameArgument )           ||
        !ArgArray.Put( &HelpArgument )                  ||
        !ArgArray.Put( &DriveArgument )                 ||
        !ArgArray.Put( &VerboseArgument )               ||
        !ArgArray.Put( &NoSecurityArgument )            ||
        !ArgArray.Put( &NoChkdskArgument )              ||
        !ArgArray.Put( &ForceDismountArgument )         ||
#ifdef DBLSPACE_ENABLED
        !ArgArray.Put( &CompressArgument )              ||
#endif // DBLSPACE_ENABLED
#ifdef DBLSPACE_ENABLED
        !ArgArray.Put( &UncompressArgument )            ||
        !ArgArray.Put( &UncompressNumberArgument )      ||
#endif // DBLSPACE_ENABLED
        !ArgArray.Put( &FsNameArgument )                ||
        !ArgArray.Put( &ConvertZoneArgument ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
        return FALSE;
    }

    //
    //  Lexemize the command line.
    //
    if ( !ArgLex.PrepareToParse( (PWSTRING)CommandLine ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
                return FALSE;
    }

        //
        //      Parse the arguments.
        //
    if( !ArgLex.DoParsing( &ArgArray ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_INVALID_PARAMETER, ERROR_MESSAGE, "%W",
                            InvalidArg = ArgLex.QueryInvalidArgument() );
            DELETE( InvalidArg );
        }
                return FALSE;
    }


    _Help       = HelpArgument.QueryFlag();
    _Verbose    = VerboseArgument.QueryFlag();
    _NoSecurity = NoSecurityArgument.QueryFlag();
    _NoChkdsk   = NoChkdskArgument.QueryFlag();
    _ForceDismount = ForceDismountArgument.QueryFlag();
    _Restart    = FALSE;    // obsolete argument
#ifdef DBLSPACE_ENABLED
    _Compress   = CompressArgument.QueryFlag();
#endif // DBLSPACE_ENABLED


    if ( DriveArgument.IsValueSet() ) {
        if ( !_DosDrive.Initialize( DriveArgument.GetString() ) ) {
            return FALSE;
        }

    } else {
        if ( !_DosDrive.Initialize( L"" ) ) {
            return FALSE;
        }
    }

    if ( FsNameArgument.IsValueSet() ) {
        if ( !_FsName.Initialize( FsNameArgument.GetString() ) ) {
            return FALSE;
        }
    } else {
        if ( !_FsName.Initialize( L"" ) ) {
            return FALSE;
        }
    }

    if( ConvertZoneArgument.IsValueSet() ) {

        if( !_CvtZoneFileName.Initialize( ConvertZoneArgument.GetString() ) ) {

            return FALSE;
        }

    } else {

        _CvtZoneFileName.Initialize( L"" );
    }

#ifdef DBLSPACE_ENABLED
    _SequenceNumber = 0;

    _Uncompress = FALSE;
    if (UncompressArgument.IsValueSet()) {
        _Uncompress = TRUE;
    }
    if (UncompressNumberArgument.IsValueSet()) {
        _SequenceNumber = (UCHAR)UncompressNumberArgument.QueryLong();
        _Uncompress = TRUE;
    }
#endif // DBLSPACE_ENABLED

    return TRUE;
}



BOOLEAN
CONVERT::Schedule (
    )

/*++

Routine Description:

    Schedules AutoConv

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if AutoConv successfully scheduled.
                FALSE otherwise

--*/

{
    DSTRING CommandLine;
    DSTRING Space;
    DSTRING FileSystem;
    DSTRING ConvertZoneFlag;
    DSTRING NoChkdskFlag;
    DSTRING VerboseFlag;
    DSTRING NoSecurityFlag;

    if( !CommandLine.Initialize( (LPWSTR)L"autocheck autoconv " )   ||
        !Space.Initialize( (LPWSTR)L" " )                           ||
        !FileSystem.Initialize( (LPWSTR)L"/FS:" )                   ||
        !CommandLine.Strcat( &_NtDrive )                            ||
        !CommandLine.Strcat( &Space )                               ||
        !CommandLine.Strcat( &FileSystem )                          ||
        !CommandLine.Strcat( &_FsName ) ) {

        return FALSE;
    }

    if( _CvtZoneFileName.QueryChCount() &&
        ( !CommandLine.Strcat( &Space )                 ||
          !ConvertZoneFlag.Initialize( L"/CVTAREA:" )   ||
          !CommandLine.Strcat( &ConvertZoneFlag )       ||
          !CommandLine.Strcat( &_CvtZoneFileName ) ) ) {

        return FALSE;
    }

    if( _NoChkdsk &&
        ( !CommandLine.Strcat( &Space )              ||
          !NoChkdskFlag.Initialize( L"/NoChkdsk" )   ||
          !CommandLine.Strcat( &NoChkdskFlag ) ) ) {

        return FALSE;
    }

    if( _Verbose &&
        ( !CommandLine.Strcat( &Space )      ||
          !VerboseFlag.Initialize( L"/V" )   ||
          !CommandLine.Strcat( &VerboseFlag ) ) ) {

        return FALSE;
    }

    if( _NoSecurity &&
        ( !CommandLine.Strcat( &Space )      ||
          !NoSecurityFlag.Initialize( L"/NoSecurity" )   ||
          !CommandLine.Strcat( &NoSecurityFlag ) ) ) {

        return FALSE;
    }

    //
    // There is no need to add options that are only for convert.exe
    // like /x.
    //
    return( AUTOREG::AddEntry( &CommandLine ) );
}



BOOLEAN
CONVERT::ScheduleAutoConv(
        )

/*++

Routine Description:

    Schedules AutoConv to be invoked during boot the next time
    that the machine reboots.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if AutoConv successfully scheduled.
                FALSE otherwise

--*/

{
    BOOLEAN     Ok;

    //
    //  Make sure that Autoconv.exe is in the right place.
    //
    if ( !(_Autoconv = FindSystemFile( (LPWSTR)AUTOCONV_PROGRAM_NAME )) ) {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
        return FALSE;
    }

    // Remove any previously scheduled conversion
    //
    if ( !RemoveScheduledAutoConv( ) ) {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
        return FALSE;
    }

    //
    //  schedule autoconvert
    //
    if ( Ok = Schedule( ) ) {
        DisplayMessage( MSG_CONV_WILL_CONVERT_ON_REBOOT, NORMAL_MESSAGE, "%W", &_DisplayDrive );
    } else {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
    }

    return Ok;
}



BOOLEAN
CONVERT::RemoveScheduledAutoConv(
    )
/*++

Routine Description:

    Remove possibly old entry of autoconv for the specified volume.

Arguments:

    N/A

Return Value:

    TRUE if no error.

--*/

{
    DSTRING CommandLine;
    DSTRING NtDrive;

    if (!CommandLine.Initialize( (LPWSTR)L"autocheck autoconv " )) {
        return FALSE;
    }

    if (!AUTOREG::DeleteEntry(&CommandLine, &_NtDrive)) {
        return FALSE;
    }

    if (_DosDrive.Stricmp(&_GuidDrive) == 0)
        return FALSE;

    DebugAssert(_DosDrive.QueryChCount() == 2);

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&_GuidDrive, &NtDrive)) {
        return FALSE;
    }

    if (!AUTOREG::DeleteEntry(&CommandLine, &NtDrive)) {
        return FALSE;
    }

    return TRUE;
}

#if defined(FE_SB) && defined(_X86_)

BOOLEAN
CONVERT::ChangeBPB1(
    IN      PCWSTRING     NtDrive
        )

/*++

Routine Description:

    Change Bpb parameters Logical to Physical

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE  Change OK
                FALSE otherwise

--*/

{
    USHORT              work,work2;
    ULONG               work3;

    BIG_INT             start_sec;
    ULONG               sector_len;
    PUCHAR      Bpb_Buff;
    HMEM        hmem;

    _NtDrive.Initialize(NtDrive);

    start_sec=0;
    sector_len=1;
    LOG_IO_DP_DRIVE    dpdrive;
//*** open
    if (!dpdrive.Initialize( &_NtDrive, &_Message )) {
        return FALSE;
    }

    if (!hmem.Acquire(2048, dpdrive.QueryAlignmentMask())) {
        return(FALSE);
    }
    Bpb_Buff = (PUCHAR)hmem.GetBuf();

//*** read
      if(!dpdrive.Read( start_sec, sector_len, Bpb_Buff)){
         return FALSE;
      }

        work=(USHORT)dpdrive.QueryPhysicalSectorSize();     // get physical sector size

//*** change to physical from logical ***
        _BytePerSec  = Bpb_Buff[11]+Bpb_Buff[12]*256;
        _SecPerClus  = Bpb_Buff[13];
        _Reserved    = Bpb_Buff[14]+Bpb_Buff[15]*256;
        _SectorNum   = Bpb_Buff[19]+Bpb_Buff[20]*256;
        _SecPerFat   = Bpb_Buff[22]+Bpb_Buff[23]*256;
        _LargeSector = Bpb_Buff[32]+Bpb_Buff[33]*256+Bpb_Buff[34]*256*256+Bpb_Buff[35]*256*256*256;
        if (work != _BytePerSec){
            Bpb_Buff[11] = (UCHAR)(work%256);
            Bpb_Buff[12] = (UCHAR)(work/256);
            Bpb_Buff[13]*= (UCHAR)(_BytePerSec/work);
            work2 = _Reserved*_BytePerSec/work;
            Bpb_Buff[14] = (UCHAR)(work2%256);
            Bpb_Buff[15] = (UCHAR)(work2/256);
            work2 = _SecPerFat*_BytePerSec/work;
            Bpb_Buff[22] = (UCHAR)(work2%256);
            Bpb_Buff[23] = (UCHAR)(work2/256);
            if (_SectorNum*(_BytePerSec/work)>0xffff){
                Bpb_Buff[19] = 0;
                Bpb_Buff[20] = 0;
                work3 = ((long)_SectorNum*(long)(_BytePerSec/work));
                Bpb_Buff[32] = (UCHAR)(work3%256L);
                Bpb_Buff[35] = (UCHAR)(work3/(256L*256L*256L));
                Bpb_Buff[34] = (UCHAR)(work3/(256L*256L)-(ULONG)Bpb_Buff[31]*256L);
                Bpb_Buff[33] = (UCHAR)(work3/256L-(ULONG)Bpb_Buff[31]*256L*256L-(ULONG)Bpb_Buff[30]*256L);

            } else {
                work2 = _SectorNum*(_BytePerSec/work);
                Bpb_Buff[19] = (UCHAR)(work2%256);
                Bpb_Buff[20] = (UCHAR)(work2/256);
                work3 = _LargeSector;
                Bpb_Buff[32] = (UCHAR)(work3%256L);
                Bpb_Buff[35] = (UCHAR)(work3/(256L*256L*256L));
                Bpb_Buff[34] = (UCHAR)(work3/(256L*256L)-(ULONG)Bpb_Buff[31]*256L);
                Bpb_Buff[33] = (UCHAR)(work3/256L-(ULONG)Bpb_Buff[31]*256L*256L-(ULONG)Bpb_Buff[30]*256L);
            }

            start_sec=0;
            sector_len=1;
//*** write
        if (!dpdrive.Write(start_sec,sector_len,Bpb_Buff)){
//*** close
           return FALSE;
        }

    } else {
//*** close
        return FALSE;
    }

    return TRUE;

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\classfac.cpp ===
#include "priv.h"
#include "cryptmnu.h"

CCryptMenuClassFactory::CCryptMenuClassFactory()  {
   m_ObjRefCount = 1;
   g_DllRefCount++;	
}

CCryptMenuClassFactory::~CCryptMenuClassFactory() {
   g_DllRefCount--;
}

STDMETHODIMP 
CCryptMenuClassFactory::QueryInterface( REFIID iid, void **ppvObject)  {
   if (IsEqualIID(iid,IID_IUnknown))  {
      *ppvObject = (LPUNKNOWN)(LPCLASSFACTORY) this; 	
      m_ObjRefCount++;
	  return(NOERROR);
   } 
   if (IsEqualIID(iid,IID_IClassFactory))  {
      *ppvObject = (LPCLASSFACTORY) this; 	
      m_ObjRefCount++;
	  return(NOERROR);
   }
   *ppvObject = NULL;
   return(E_NOINTERFACE);
}

STDMETHODIMP_(DWORD) 
CCryptMenuClassFactory::AddRef()  {
   return(++m_ObjRefCount);
}

STDMETHODIMP_(DWORD)
CCryptMenuClassFactory::Release()  {
   if(--m_ObjRefCount ==0)  {
   	  delete this;
   }

   return(m_ObjRefCount);
}

STDMETHODIMP 
CCryptMenuClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  void **ppvObject) {
   CCryptMenuExt *pCryptMenu;
   HRESULT hr;

   *ppvObject = NULL;

   if (pUnkOuter)  {
   	  return(CLASS_E_NOAGGREGATION);
   }
   
   pCryptMenu = new CCryptMenuExt;
   if (!pCryptMenu)  {
   	  return(E_OUTOFMEMORY);
   }

   hr = pCryptMenu->QueryInterface(riid,ppvObject);
   pCryptMenu->Release();
   
   return hr;
}

STDMETHODIMP 
CCryptMenuClassFactory::LockServer(BOOL)  {
    return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\cryptmnu.h ===
// {853FE2B1-B769-11d0-9C4E-00C04FB6C6FA}
DEFINE_GUID(CLSID_CryptMenu, 
0x853fe2b1, 0xb769, 0x11d0, 0x9c, 0x4e, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa);


class CCryptMenuClassFactory : public IClassFactory
{
protected:
	DWORD m_ObjRefCount;

public:
	CCryptMenuClassFactory();
	~CCryptMenuClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
   STDMETHODIMP LockServer(BOOL);
};


class CCryptMenuExt : public IShellExtInit, public IContextMenu 
{
public:
   CCryptMenuExt();
   ~CCryptMenuExt();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();
   
   //IShellExtInit methods
   STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);
   
   //IContextMenu methods
   STDMETHODIMP QueryContextMenu(HMENU, UINT, UINT, UINT, UINT);
   STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO);
   STDMETHODIMP GetCommandString(UINT_PTR, UINT, LPUINT, LPSTR, UINT);

protected:
   void ResetSelectedFileList();
   HRESULT GetNextSelectedFile(LPTSTR *, __int64 *);

   DWORD m_ObjRefCount;
   LPDATAOBJECT m_pDataObj;

   int m_nToEncrypt;
   int m_nToDecrypt;
   __int64 m_cbToEncrypt;
   __int64 m_cbToDecrypt;
   int m_nFile;
   int m_nFiles;
   DWORD m_cbFile;
   LPTSTR m_szFile;

   bool m_fShutDown;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\cryptmnu.cpp ===
#include "priv.h"
#include "cryptmnu.h"
#include <shellapi.h>
#include "resource.h"

enum {
    VERB_ERROR = -1,
    VERB_ENCRYPT = 0,
    VERB_DECRYPT,
};

LPTSTR szVerbs[] = {
   TEXT("encrypt"),
   TEXT("decrypt"),
};

bool Encryptable(LPCTSTR szFile);

CCryptMenuExt::CCryptMenuExt()  {
   InitCommonControls();
   m_pDataObj = NULL;
   m_ObjRefCount = 1;
   g_DllRefCount++;
   m_nFile = m_nFiles = m_nToDecrypt = m_nToEncrypt = 0;
   m_cbToEncrypt = m_cbToDecrypt = 0;
   m_cbFile = 256;
   m_szFile = new TCHAR[m_cbFile];
   m_fShutDown = false;
}

CCryptMenuExt::~CCryptMenuExt()  {
   ResetSelectedFileList();
   if (m_pDataObj)  {
      m_pDataObj->Release();
   }
   if (m_szFile) {
      delete[] m_szFile;
   }

   g_DllRefCount--;
}

//IUnknown methods
STDMETHODIMP
CCryptMenuExt::QueryInterface(REFIID riid, void **ppvObject)  {
   if (IsEqualIID(riid, IID_IUnknown)) {
      *ppvObject = (LPUNKNOWN) (LPCONTEXTMENU) this;
      AddRef();
      return(S_OK);
   } else if (IsEqualIID(riid, IID_IShellExtInit))  {
      *ppvObject = (LPSHELLEXTINIT) this;
      AddRef();
      return(S_OK);
   } else if (IsEqualIID(riid, IID_IContextMenu)) {
      *ppvObject = (LPCONTEXTMENU) this;
      AddRef();
      return(S_OK);
   }

   *ppvObject = NULL;
   return(E_NOINTERFACE);
}

STDMETHODIMP_(DWORD)
CCryptMenuExt::AddRef()  {
   return(++m_ObjRefCount);

}

STDMETHODIMP_(DWORD)
CCryptMenuExt::Release()  {
   if (--m_ObjRefCount == 0)  {
      m_fShutDown = true;
      delete this;
   }
   return(m_ObjRefCount);
}

//Utility methods
HRESULT
CCryptMenuExt::GetNextSelectedFile(LPTSTR *szFile, __int64 *cbFile) {
   FORMATETC fe;
   STGMEDIUM med;
   HRESULT hr;
   DWORD cbNeeded;
   WIN32_FIND_DATA w32fd;
   DWORD dwAttributes;

   if (!m_pDataObj) {
       return E_UNEXPECTED;
   }

   if (!szFile) {
      return E_INVALIDARG;
   }

   *szFile = NULL;
   while (!*szFile) {
      HANDLE hFile = INVALID_HANDLE_VALUE;

      // get the next file out of m_pDataObj
      fe.cfFormat = CF_HDROP;
      fe.ptd      = NULL;
      fe.dwAspect = DVASPECT_CONTENT;
      fe.lindex   = -1;
      fe.tymed    = TYMED_HGLOBAL;

      hr = m_pDataObj->GetData(&fe,&med);
      if (FAILED(hr))  {
         return(E_FAIL);
      }

      if (!m_nFiles) {
         m_nFiles = DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),0xFFFFFFFF,NULL,0);
      }

      if (m_nFile >= m_nFiles) {
         return E_FAIL;
      }

      cbNeeded = DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),m_nFile,NULL,0) + 1;
      if (cbNeeded > m_cbFile) {
         if (m_szFile) delete[] m_szFile;
         m_szFile = new TCHAR[cbNeeded];
         m_cbFile = cbNeeded;
      }

      DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),m_nFile++,m_szFile,m_cbFile);
      *szFile = m_szFile;

       if (!Encryptable(*szFile)) {
            *szFile = NULL;
            continue;
      }

      hFile = FindFirstFile(*szFile,&w32fd);

      if (hFile != INVALID_HANDLE_VALUE)
      {
         *cbFile = MAXDWORD * w32fd.nFileSizeHigh + w32fd.nFileSizeLow +1;
         FindClose(hFile);
      }
      else
      {
         *szFile = NULL;
         continue;
      }

      dwAttributes = GetFileAttributes(*szFile);

      // If we found a system file then skip it:
      if ((FILE_ATTRIBUTE_SYSTEM & dwAttributes) ||
          (FILE_ATTRIBUTE_TEMPORARY & dwAttributes)) {
         *szFile = NULL;
         continue;
      }
   }

   return S_OK;
}

void
CCryptMenuExt::ResetSelectedFileList() {
   m_nFile = 0;
}

// A file can be encrypted only if it is on an NTFS volume.
bool
Encryptable(LPCTSTR szFile) {
    TCHAR szFSName[6]; // This just needs to be longer than "NTFS"
   LPTSTR szRoot;
    int cchFile;
    int nWhack = 0;


    if (!szFile || (cchFile = lstrlen(szFile)) < 3) return false;
   szRoot = new TCHAR [ cchFile + 1 ];
   lstrcpy(szRoot,szFile);
                
    // GetVolumeInformation wants only the root path, so we need to
    // strip off the rest.  Yuck.
    if ('\\' == szRoot[0] && '\\' == szRoot[1]) {
       /* UNC Path: chop after the second '\': \\server\share\ */
       for(int i=2;i<cchFile;i++) {
          if ('\\' == szRoot[i]) nWhack++;
          if (2 == nWhack) {
             szRoot[i+1] = '\0';
             break;
          }
       }
    } else {
       // Drive Letter
       szRoot[3] = '\0';
    }
    if (!GetVolumeInformation(szRoot,NULL,0,NULL,NULL,NULL,
                szFSName,sizeof(szFSName)/sizeof(szFSName[0]))) {
      delete[] szRoot;
      return false;
    }

   delete[] szRoot;
    return 0 == lstrcmp(szFSName,TEXT("NTFS"));
}

BOOL CALLBACK
EncryptProgressDlg(HWND hdlg, UINT umsg, WPARAM wp, LPARAM lp) {
   switch(umsg) {
      case WM_INITDIALOG:
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wp)) {
            case IDCANCEL: {
               DestroyWindow(hdlg);
            }
         }
         break;
   }
   return FALSE;
}


//IShellExtInit methods
STDMETHODIMP
CCryptMenuExt::Initialize(LPCITEMIDLIST pidlFolder,
                      LPDATAOBJECT  pDataObj,
                      HKEY hkeyProgID)
{
   DWORD dwAttributes;
   LPTSTR szFile;
   __int64 cbFile;

   // Hang on to the data object for later.
   // We'll want this information in QueryContextMenu and InvokeCommand
   if (!m_pDataObj)  {
      m_pDataObj = pDataObj;
      m_pDataObj->AddRef();
   } else {
      return(E_UNEXPECTED);
   }

   ResetSelectedFileList();
   while(SUCCEEDED(GetNextSelectedFile(&szFile,&cbFile))) {
      // is it encrypted?  increment our count of decryptable files
      //        otherwise increment our count of encryptable files
      dwAttributes = GetFileAttributes(szFile);
      if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
          m_nToDecrypt++;
         m_cbToDecrypt += cbFile;
      } else {
            m_nToEncrypt++; 
         m_cbToEncrypt += cbFile;
      }
      //We need the actual values for the title of the progress dialog
      //if ((m_nToEncrypt > 1) && (m_nToDecrypt > 1)) break;
   }

   return(NOERROR);
}



//IContextMenu methods
STDMETHODIMP
CCryptMenuExt::QueryContextMenu(HMENU hmenu,
                      UINT indexMenu,
                      UINT idCmdFirst,
                      UINT idCmdLast,
                      UINT uFlags)
{
   TCHAR szMenu[50];
   UINT idCmd;

   if (!m_pDataObj) {
      return E_UNEXPECTED;
   }

   if ((CMF_EXPLORE != (0xF & uFlags)) &&
       (CMF_NORMAL != (0xF & uFlags))) {
      return(NOERROR);
   }

   idCmd = idCmdFirst;
   if (1 < m_nToEncrypt) {
      LoadString(g_hinst,IDS_ENCRYPTMANY,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   } else if (1 == m_nToEncrypt) {
       LoadString(g_hinst,IDS_ENCRYPTONE,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   }
   if (m_nToEncrypt) {
      InsertMenu(hmenu,indexMenu++,MF_STRING|MF_BYPOSITION,idCmd,szMenu);
   }
   idCmd++;

   if (1 < m_nToDecrypt) {
      LoadString(g_hinst,IDS_DECRYPTMANY,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   } else if (1 == m_nToDecrypt) {
      LoadString(g_hinst,IDS_DECRYPTONE,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   }
   if (m_nToDecrypt) {
      InsertMenu(hmenu,indexMenu++,MF_STRING|MF_BYPOSITION,idCmd,szMenu);
   }
   idCmd++;

   return(MAKE_SCODE(SEVERITY_SUCCESS,0,idCmd-idCmdFirst));
}


DWORD WINAPI
DoEncryptFile(LPVOID szFile) {
    return EncryptFile(reinterpret_cast<LPTSTR>(szFile));
}

DWORD WINAPI
DoDecryptFile(LPVOID szFile) {
   return DecryptFile(reinterpret_cast<LPTSTR>(szFile),0);
}



STDMETHODIMP
CCryptMenuExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpici) {
   HRESULT hrRet;
   LPCMINVOKECOMMANDINFO pici;
   int nVerb;
   LPTSTR szFile;

   if (!m_pDataObj) {
      return E_UNEXPECTED;
   }

   pici = reinterpret_cast<LPCMINVOKECOMMANDINFO>(lpici);

   // If pici->lpVerb has 0 in the high word then the low word
   // contains the offset to the menu as set in QueryContextMenu
   if (HIWORD(pici->lpVerb) == 0) {
      nVerb = LOWORD(pici->lpVerb);
   } else {
      // Initialize nVerb to an illegal value so we don't accidentally
      // recognize an invalid verb as legitimate
      nVerb = VERB_ERROR;
      for(int i=0;i<sizeof(szVerbs)/sizeof(szVerbs[0]);i++) {
         if (0 == lstrcmp(reinterpret_cast<LPCTSTR>(pici->lpVerb),szVerbs[i])) {
             nVerb = i;
              break;
         }
      }
   }

   switch(nVerb) {
      case VERB_ENCRYPT:
      case VERB_DECRYPT: {
         HWND hDlg;
         TCHAR szDlgTitle[50];
         TCHAR szDlgFormat[50];
         TCHAR szTimeLeft[50];
         TCHAR szTimeFormat[50];
         TCHAR szTimeFormatInMin[50];
         DWORD nTimeStarted;
         DWORD nTimeElapsed;
         __int64 nTimeLeft;
         __int64 cbDone;  // How many bytes we've handled
         __int64 cbToDo;  // How many bytes total we have to do
         __int64 cbFile;  // How many bites in the current file
         int nShifts;     // How many right shifts we need to do to get cbToDo
                          // into a range handleable by the progress bar.


         hDlg = CreateDialog(g_hinst,MAKEINTRESOURCE(IDD_ENCRYPTPROGRESS),GetForegroundWindow(),
                             reinterpret_cast<DLGPROC>(EncryptProgressDlg));

         // Setup the dialog's title, progress bar & animation
         if (VERB_ENCRYPT==nVerb) {
            if (1 == m_nToEncrypt) {
               LoadString(g_hinst,IDS_ENCRYPTINGONE,szDlgTitle,sizeof(szDlgTitle)/sizeof(szDlgTitle[0]));
            } else {
               LoadString(g_hinst,IDS_ENCRYPTINGMANY,szDlgFormat,sizeof(szDlgFormat)/sizeof(szDlgFormat[0]));
               wsprintf(szDlgTitle,szDlgFormat,m_nToEncrypt);
            }
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,m_nToEncrypt));
            SendDlgItemMessage(hDlg,IDC_ANIMATE,ACM_OPEN,0,reinterpret_cast<LPARAM>(MAKEINTRESOURCE(IDA_ENCRYPT)));

            cbToDo = m_cbToEncrypt;
         } else {
            if (1 == m_nToDecrypt) {
               LoadString(g_hinst,IDS_DECRYPTINGONE,szDlgTitle,sizeof(szDlgTitle)/sizeof(szDlgTitle[0]));
            } else {
               LoadString(g_hinst,IDS_DECRYPTINGMANY,szDlgFormat,sizeof(szDlgFormat)/sizeof(szDlgFormat[0]));
               wsprintf(szDlgTitle,szDlgFormat,m_nToDecrypt);
            }
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,m_nToDecrypt));
            SendDlgItemMessage(hDlg,IDC_ANIMATE,ACM_OPEN,0,reinterpret_cast<LPARAM>(MAKEINTRESOURCE(IDA_ENCRYPT)));
            cbToDo = m_cbToDecrypt;
         }

         nShifts = 0;
         cbDone = 0;
         while((cbToDo >> nShifts) > 65535) {
            nShifts++;
         }

#ifdef DISPLAY_TIME_ESTIMATE
         LoadString(g_hinst,IDS_TIMEEST,szTimeFormat,sizeof(szTimeFormat)/sizeof(szTimeFormat[0]));
         LoadString(g_hinst,IDS_TIMEESTMIN,szTimeFormatInMin,sizeof(szTimeFormatInMin)/sizeof(szTimeFormatInMin[0]));
#endif // DISPLAY_TIME_ESTIMATE

         SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,cbToDo >> nShifts));
         SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETPOS,0,0);
         SetWindowText(hDlg,szDlgTitle);
        ShowWindow(hDlg,SW_NORMAL);

         nTimeStarted = GetTickCount();
         ResetSelectedFileList();
         while(SUCCEEDED(GetNextSelectedFile(&szFile,&cbFile))) {
               if (!IsWindow(hDlg)) {
                  break;
               }

            if (GetFileAttributes(szFile) & FILE_ATTRIBUTE_ENCRYPTED) {
               if (VERB_ENCRYPT == nVerb) {
                  continue;
               }
            } else {
               if (VERB_DECRYPT == nVerb) {
                  continue;
               }
            }
            // Set the name of the file currently being encrypted
               SetDlgItemText(hDlg,IDC_NAME,szFile);

            HANDLE hThread;
            if (VERB_ENCRYPT == nVerb) {
                  hThread = CreateThread(NULL,0,DoEncryptFile,szFile,0,NULL);
              } else {
                  hThread = CreateThread(NULL,0,DoDecryptFile,szFile,0,NULL);
              } 


            MSG msg;
            DWORD dw;
            do {
               dw = MsgWaitForMultipleObjects(1,&hThread,0,INFINITE,QS_ALLINPUT);
               while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
               }
            } while (WAIT_OBJECT_0 != dw);

            GetExitCodeThread(hThread,&dw);
            if (0 == dw) {
               // Encrypt or Decrypt Failed
               TCHAR szFormat[512];
               TCHAR szBody[512];
               TCHAR szTitle[80];
               int nResBody,nResTitle;
               UINT uMBType;

               uMBType = MB_OKCANCEL;
               if (VERB_ENCRYPT == nVerb) {
                  nResTitle = IDS_ENCRYPTFAILEDTITLE;
                  if (1 == m_nToEncrypt) {
                     uMBType = MB_OK;
                     nResBody = IDS_ENCRYPTFAILEDONE;
                  } else {
                     nResBody = IDS_ENCRYPTFAILEDMANY;
                  }
               } else {
                  nResTitle = IDS_DECRYPTFAILEDTITLE;
                  if (1 == m_nToDecrypt) {
                     uMBType = MB_OK;
                     nResBody = IDS_DECRYPTFAILEDONE;
                  } else {
                     nResBody = IDS_DECRYPTFAILEDMANY;
                  }
               }
               LoadString(g_hinst,nResBody,szFormat,sizeof(szFormat)/sizeof(szFormat[0]));
               wsprintf(szBody,szFormat,szFile);
               LoadString(g_hinst,nResTitle,szFormat,sizeof(szFormat)/sizeof(szFormat[0]));
               wsprintf(szTitle,szFormat,szFile);
               if (IDCANCEL == MessageBox(hDlg,szBody,szTitle,uMBType|MB_ICONWARNING)) {
                  if (IsWindow(hDlg)) {
                     DestroyWindow(hDlg);
                  }
               }
            }
            CloseHandle(hThread);

               if (!IsWindow(hDlg)) {
                  break;
               }
            // Advance the progress Bar
            cbDone += cbFile;
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETPOS,(DWORD)(cbDone >> nShifts),0);

#ifdef DISPLAY_TIME_ESTIMATE
            nTimeElapsed = GetTickCount() - nTimeStarted;
            nTimeLeft = (cbToDo * nTimeElapsed) / cbDone - nTimeElapsed;
            nTimeLeft /= 1000; // Convert to seconds
            if (nTimeLeft < 60) {
               wsprintf(szTimeLeft,szTimeFormat,(DWORD)(nTimeLeft));
            } else {
               wsprintf(szTimeLeft,szTimeFormatInMin,(DWORD)(nTimeLeft / 60), (DWORD) (nTimeLeft % 60));
            }
            SetDlgItemText(hDlg,IDC_TIMEEST,szTimeLeft);
#endif // DISPLAY_TIME_ESTIMATE
         }
           if (IsWindow(hDlg)) {
              DestroyWindow(hDlg);
         }
            hrRet = NOERROR;
         }
          break;
       default:
         hrRet = E_UNEXPECTED;
           break;
   }

   return(hrRet);
}

STDMETHODIMP
CCryptMenuExt::GetCommandString(
    UINT_PTR idCmd,   //Menu item identifier offset
    UINT uFlags,  //Specifies information to retrieve
    LPUINT pwReserved,   //Reserved; must be NULL
    LPSTR pszName,   //Address of buffer to receive string
    UINT cchMax   //Size of the buffer that receives the string
   )
{
   LPTSTR wszName;

   // On NT we get unicode here, even though the base IContextMenu class
   // is hardcoded to ANSI.
   wszName = reinterpret_cast<LPTSTR>(pszName);

   if (idCmd >= sizeof(szVerbs)/sizeof(szVerbs[0])) {
      return(E_INVALIDARG);
   }
   switch(uFlags)  {
      case GCS_HELPTEXT:
         switch(idCmd) {
             case VERB_ENCRYPT:
                 if (1 < m_nToEncrypt) {
                  LoadString(g_hinst,IDS_ENCRYPTMANYHELP,wszName,cchMax);
               } else {
                  LoadString(g_hinst,IDS_ENCRYPTONEHELP,wszName,cchMax);
               }
               break;
            case VERB_DECRYPT:
                 if (1 < m_nToDecrypt) {
                    LoadString(g_hinst,IDS_DECRYPTMANYHELP,wszName,cchMax);
               } else {
                  LoadString(g_hinst,IDS_DECRYPTONEHELP,wszName,cchMax);
               }
               break;
            default:
               break;
         }
         break;

      case GCS_VALIDATE: {
         break;
      }
      case GCS_VERB:
          lstrcpyn(wszName,szVerbs[idCmd],cchMax);
        pszName[cchMax-1] = '\0';
          break;
   }

   return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\priv.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <shlobj.h>

extern DWORD g_DllRefCount;
extern HINSTANCE g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\convert\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=convert
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\convert.cxx ..\convert.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;..\..\cufat\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib \
    $(SDK_LIB_PATH)\scecli.lib \
    $(PROJECT_LIB_PATH)\osuninst.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\dllmain.cpp ===
#include "priv.h"
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "cryptmnu.h"
DWORD g_DllRefCount;
HINSTANCE g_hinst;

extern "C" {
   BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) ;
}
STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv);

BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)  {
   switch(dwReason)  {
      case DLL_PROCESS_ATTACH:
          DisableThreadLibraryCalls(hInstance);
		 g_hinst = hInstance;
         break;
      case DLL_PROCESS_DETACH:
         break;
      case DLL_THREAD_ATTACH:
         break;
      case DLL_THREAD_DETACH:
         break;
   }
   return(TRUE);
}

STDAPI
DllCanUnloadNow(void)  {
   return(g_DllRefCount ? S_FALSE : S_OK);
}

STDAPI
DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv)  {
   HRESULT hr;

   *ppv = NULL;


   if (!IsEqualCLSID(rclsid,CLSID_CryptMenu))  {
      return(CLASS_E_CLASSNOTAVAILABLE);
   }

   CCryptMenuClassFactory *pCF = new CCryptMenuClassFactory();
   if (!pCF)  {
      return(E_OUTOFMEMORY);
   }

   hr = pCF->QueryInterface(riid,ppv);
   pCF->Release();

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cryptmnu\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptmnu.rc
//
#define IDS_ENCRYPTONE                  1
#define IDS_DECRYPTONE                  2
#define IDS_ENCRYPTMANY                 3
#define IDS_DECRYPTMANY                 4
#define IDS_ENCRYPTHELP                 5
#define IDS_ENCRYPTMANYHELP             5
#define IDS_DECRYPTHELP                 6
#define IDS_DECRYPTMANYHELP             6
#define IDS_ENCRYPTONEHELP              7
#define IDS_DECRYPTONEHELP              8
#define IDS_ENCRYPTINGONE               9
#define IDS_ENCRYPTINGMANY              10
#define IDS_DECRYPTINGONE               11
#define IDS_DECRYPTINGMANY              12
#define IDS_TIMEEST                     13
#define IDS_TIMEESTMIN                  14
#define IDS_ENCRYPTFAILEDTITLE          15
#define IDS_DECRYPTFAILEDTITLE          16
#define IDS_ENCRYPTFAILEDMANY           17
#define IDS_DECRYPTFAILEDMANY           18
#define IDS_ENCRYPTFAILEDONE            19
#define IDS_DECRYPTFAILEDONE            20
#define IDD_ENCRYPTPROGRESS             101
#define IDA_ENCRYPT                     102
#define IDA_DECRYPT                     103
#define IDC_ANIMATE                     1000
#define IDC_PROBAR                      1001
#define IDC_NAME                        1002
#define IDC_TONAME                      1003
#define IDC_TIMEEST                     1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cufat\src\convfat.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

        entry.cxx

Abstract:

        This module contains the Convert entry point for CUFAT.DLL.

Author:

        Ramon San Andres (ramonsa)      Sep-19-91

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#include "ulib.hxx"
#include "error.hxx"
#include "drive.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "fatsa.hxx"
#include "fatntfs.hxx"
#include "convfat.hxx"
#include "rwcache.hxx"
#include "rfatsa.hxx"
#include "ifssys.hxx"

#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)

#include "fatofs.hxx"     // FAT->OFS Conversion
#include "system.hxx"

#include <stdio.h>

#endif  // _AUTOCHECK_ || _SETUP_LOADER_

//#define RWCACHE_PERF_COUNTERS   1
//#define CONVERT_CACHE_BLOCKS    1

//
//    This file maintains a table that maps file system names to
//  conversion functions. The Convert entry point looks up the
//  target file name system in the table, if found, then it calls
//  the corresponding conversion function.  This data-driven scheme
//  makes it easy to add new conversions to the library, since no
//  code has to be changed.
//
//    The code & data for performing a particular conversion are
//  contained in a class. This avoids name conflicts and lets us
//  have the global data for each conversion localized.
//
//    Each conversion function will typically just initialize
//  the appropriate conversion object and invoke its conversion
//  method.
//



//
//  A FAT_CONVERT_FN is a pointer to a conversion function.
//
typedef BOOLEAN(FAR APIENTRY * FAT_CONVERT_FN)( PLOG_IO_DP_DRIVE,
                                                PREAL_FAT_SA,
                                                PCWSTRING,
                                                PMESSAGE,
                                                ULONG,
                                                PCONVERT_STATUS );

//
//    Prototypes of conversion functions. Note that all conversion
//  functions must have the same interface since they are all called
//  thru a FAT_CONVERT_FN pointer.
//
//    Also note that the Drive object passed to the function is
//  LOCKED by the Convert entry point before invoking the function.
//
BOOLEAN
FAR APIENTRY
ConvertFatToNtfs(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    );


//
//  The FILESYSTEM_MAP structure is used to map the name of
//  a file system to the function in charge of converting a FAT
//  volume to that particular file system.
//
typedef struct _FILESYSTEM_MAP {

    PWCHAR          FsName;         //      Name of the file system
    FAT_CONVERT_FN  Function;       //      Conversion function

} FILESYSTEM_MAP, *PFILESYSTEM_MAP;

//  To add a new conversion, create a FAT_CONVERT_FN function
//  for it and add the appropriate entry to the FileSystemMap
//  table.
//
//  Note that this table contains an entry for every known
//  file system. A NULL entry in the Function field means that
//  the particular conversion is not implemented.
//
//    This table has to be NULL-terminated.
//
FILESYSTEM_MAP  FileSystemMap[] = {

        { L"NTFS",   ConvertFatToNtfs    },
        { L"HPFS",   NULL                },
        { L"FAT",    NULL                },
        { L"CDFS",   NULL                },
        { L"FAT32",  NULL                },
        { NULL,     NULL                }
};


LONG
FAR APIENTRY
IsConversionAvailable(
    IN      PCWSTRING           TargetFileSystem
    )
/*++

Routine Description:

    This method determines if a conversion is allowed from FAT/FAT32
    to the desired TargetFileSystem.

Arguments:

    TargetFileSyste --  Supplies the name of the file system to convert
                        the drive to.

Return Value:

    >= 0 if conversion is supported.
    -1 if conversion is not supported.

--*/
{
    PFILESYSTEM_MAP     FsMap;                  //  Maps name->Function
    DSTRING             FsName;

    //
    //  Find out if the target file system is valid and
    //  if we can convert to it, by looking up the target
    //  file system in the FileSystemMap table.
    //
    FsMap = FileSystemMap;

    while ( FsMap->FsName ) {

        //
        //  If this is the guy we are looking for, we stop searching
        //
        if ( WSTRING::Stricmp((PWSTR)TargetFileSystem->GetWSTR(), FsMap->FsName) == 0 ) {

            break;
        }

        FsMap++;
    }

    if (FsMap->FsName && FsMap->Function)
        return (LONG)(FsMap - FileSystemMap);
    else
        return -1;
}


BOOLEAN
IsTargetNTFS(
    IN      PCWSTRING           TargetFileSystem )
{
    DSTRING NTFSName;


    if(!NTFSName.Initialize("NTFS")) {
    return TRUE;
    }
    return 0 == TargetFileSystem->Stricmp(&NTFSName);
}

NTSTATUS
FileExists(
    PCWSTRING lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

    This routine is a copy of the WIN32 one and also takes the drive
    in the NT form rather than the DOS form. We would need this in
    the AUTOCHK case in any event since WIN32 isn't around for AUTOCHK,
    but we also need it in the non-AUTOCHK case since we only have the NT
    form drive name available.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
    be gotten. This must be a WFP using the NT drive name format.

Return Value:

     Returns STATUS_SUCCESS if file does exist.
     Returns STATUS_OBJECT_NAME_NOT_FOUND if file does not exist.
     Returns other NTSTATUS.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    FILE_BASIC_INFORMATION BasicInfo;
    UNICODE_STRING FileName;

    RtlInitUnicodeString(&FileName, lpFileName->GetWSTR());

    InitializeObjectAttributes(
        &Obja,
    &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Get the file attributes
    //

    Status = NtQueryAttributesFile(
                 &Obja,
                 &BasicInfo
                 );

    return Status;
}

BOOLEAN
CheckForNTFSReserveNames(
     IN      PCWSTRING           NtDriveName,
        OUT  PBOOLEAN            Found
     )
{
     char * NTFSResvdNames[] = {
                                         { "\\$Mft"     },
                                         { "\\$MftMirr" },
                                         { "\\$LogFile" },
                                         { "\\$Volume"  },
                                         { "\\$AttrDef" },
                                         { "\\$BitMap"  },
                                         { "\\$Boot"    },
                                         { "\\$BadClus" },
                                         { "\\$Secure"  },
                                         { "\\$UpCase"  },
                                         { "\\$Extend"  },
                                         { "\\$Quota"   },
                                         { NULL   }
                                        };
     int     i = 0;
     DSTRING ThisName1;
     DSTRING ThisName2;

     *Found = FALSE;
     while (NTFSResvdNames[i]) {

        if (!ThisName1.Initialize(NtDriveName) ||
            !ThisName2.Initialize(NTFSResvdNames[i]) ||
            !ThisName1.Strcat(&ThisName2)) {
            return FALSE;
        }

        if (FileExists(&ThisName1) != STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // if it didn't say it does not exist, assume it does
            //
            *Found = TRUE;
            return TRUE;
        }
        i++;
     }
     return TRUE;
}

BOOLEAN
FAR APIENTRY
CvtAreaFileExist(
     IN      PCWSTRING           NtDriveName,
     IN      PCWSTRING           CvtZoneFileName,
        OUT  PBOOLEAN            Found
     )
{
    DSTRING     ThisName1;
    DSTRING     ThisName2;
    NTSTATUS    status;

    *Found = FALSE;

    if (CvtZoneFileName->QueryChCount() == 0) {
        return TRUE;
    }

    if (!ThisName1.Initialize(NtDriveName) ||
        !ThisName2.Initialize(L"\\") ||
        !ThisName2.Strcat(CvtZoneFileName) ||
        !ThisName1.Strcat(&ThisName2)) {
        return FALSE;
    }

    status = FileExists(&ThisName1);

    switch (status) {
      case STATUS_SUCCESS:
        //
        // if it didn't say it exists, assumes it doesn't
        //
        *Found = TRUE;
        break;

      case STATUS_OBJECT_NAME_NOT_FOUND:
        break;  // this is expected

      default:
        DebugPrintTrace(("CNVFAT: Unable to query file %08x.\n", status));
    }

    return TRUE;
}

BOOLEAN
FAR APIENTRY
ConvertFATVolume(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PCWSTRING           TargetFileSystem,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    )
/*++

Routine Description:

    This method converts an opened FAT volume to another
    file system.

Arguments:

    Drive           --  Supplies the drive to be converted; note that
                        the drive must already be opened and locked
                        (Convert) or opened for exclusive write access
                        (Autoconvert).
    TargetFileSyste --  Supplies the name of the file system to which
                        the drive will be converted.
    CvtZoneFileName --  Supplies the name of the convert zone.
    Message         --  Supplies a channel for messages.
    Flags           --  Supplies flags (CONVERT_VERBOSE_FLAG, CONVERT_FORCE_DISMOUNT_FLAG, etc)
    Status          --  Receives the status of the conversion.

Return Value:

    TRUE upon successful completion.

--*/
{
    REAL_FAT_SA         FatSa;                  //  Fat SuperArea
    LONG                indx;                   // index to conversion table
    PREAD_WRITE_CACHE   rwcache = NULL;
    ULONG               blocks;

    SYSTEM_BASIC_INFORMATION    sys_basic_info;
    NTSTATUS                    status;
    ULONG64                     vm_pages;

    DebugPtrAssert( Drive );
    DebugPtrAssert( TargetFileSystem );
    DebugPtrAssert( Status );

    if (!Drive->IsWriteable()) {
        *Status = CONVERT_STATUS_WRITE_PROTECTED;
        return FALSE;
    }

    //
    // Obtain number of physical pages and page size first
    //
    status = NtQuerySystemInformation(SystemBasicInformation,
                                      &sys_basic_info,
                                      sizeof(sys_basic_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("CNVFAT: NtQuerySystemInformation(SystemBasicInformation) failed (%x)\n", status));
        return FALSE;
    }

    vm_pages = (sys_basic_info.MaximumUserModeAddress -
                sys_basic_info.MinimumUserModeAddress)/sys_basic_info.PageSize;

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: Page Size = %x\n", sys_basic_info.PageSize));
    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: User Virtual pages = %I64x\n", vm_pages));
    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: Physical pages = %x\n", sys_basic_info.NumberOfPhysicalPages));

    if (sys_basic_info.NumberOfPhysicalPages < vm_pages) {
        vm_pages = sys_basic_info.NumberOfPhysicalPages;
    }

#if defined(_AUTOCHECK_)
    SYSTEM_PERFORMANCE_INFORMATION  perf_info;

    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &perf_info,
                                      sizeof(perf_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("CNVFAT: NtQuerySystemInformation(SystemPerformanceInformation) failed (%x)\n", status));
        return FALSE;
    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: AvailablePages = %x\n", perf_info.AvailablePages));

    if (perf_info.AvailablePages < vm_pages)
        vm_pages = perf_info.AvailablePages;
#endif

    //
    // For a 32GB drive, the FAT can be as large as 16MB and
    // the two bitmaps can be each be as large as 8MB.
    // Thus the 32MB below.
    //
    vm_pages = vm_pages - (32*1024*1024)/sys_basic_info.PageSize;
    vm_pages = vm_pages/2;

    if (vm_pages <= (64*1024*1024)/sys_basic_info.PageSize) {
        vm_pages = min(vm_pages, (4*1024*1024)/sys_basic_info.PageSize);
    } else {
        vm_pages = min(vm_pages, (256*1024*1024)/sys_basic_info.PageSize);
    }

    vm_pages *= sys_basic_info.PageSize;
    blocks = (ULONG)(vm_pages / Drive->QuerySectorSize());

#if !defined(_AUTOCHECK_) && defined(CONVERT_CACHE_BLOCKS)

    PWCHAR      wstr;

    if (wstr = _wgetenv(L"CONVERT_CACHE_BLOCKS")) {

        INT     r;
        ULONG   blks;

        r = swscanf(wstr, L"%d", &blks);
        if (r != 0 && r != EOF) {
            blocks = blks;
        }
    }
#endif

    //
    // Set up a read-write cache for the volume.
    //
    if (blocks != 0 &&
        (rwcache = NEW READ_WRITE_CACHE) &&
        rwcache->Initialize(Drive, blocks)) {
        Drive->SetCache(rwcache);

#if defined(CONVERT_CACHE_BLOCKS)
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        Message->Display("%s%d", "Cache blocks = ", blocks);
#endif

    } else {

        DELETE(rwcache);
    }

    //
    //  Find out if the target file system is valid and
    //  if we can convert to it, by looking up the target
    //  file system in the FileSystemMap table.
    //

    indx = IsConversionAvailable(TargetFileSystem);

    //
    //  If the target file system is valid, and there is a conversion
    //  for it, lock the drive, initialize the superarea, and
    //  invoke the conversion function.
    //
    if ( indx >= 0) {

#if defined(_AUTOCHECK_)
        if (IsTargetNTFS( TargetFileSystem )) {

            BOOLEAN             found;

            if (CheckForNTFSReserveNames(Drive->GetNtDriveName(), &found)) {
                if (found) {
                    *Status = CONVERT_STATUS_NTFS_RESERVED_NAMES;
                    return FALSE;
                }
            } else {
                Message->Set(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
                Message->Display();
                *Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }
        }
#endif

        if ( FatSa.Initialize( Drive, Message, TRUE ) ||
             FatSa.Initialize( Drive, Message, FALSE )) {

            if (FatSa.Read( Message )) {

                BOOLEAN     rst;
                //
                //  The dive is locked and we have the
                //  FAT superarea. Invoke the conversion
                //  function.
                //

#if !defined(RUN_ON_NT4)
                NTSTATUS            es_status;
                EXECUTION_STATE     prev_state;

                es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                      ES_DISPLAY_REQUIRED|
                                                      ES_SYSTEM_REQUIRED,
                                                      &prev_state);

                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("CNVFAT: Unable to set thread execution state (%x)\n", es_status));
                }

                __try {
#endif
                    rst = (FileSystemMap[indx].Function)( Drive,
                                                          &FatSa,
                                                          CvtZoneFileName,
                                                          Message,
                                                          Flags,
                                                          Status );

                    RestoreThreadExecutionState(es_status, prev_state);
#if !defined(RUN_ON_NT4)
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    RestoreThreadExecutionState(es_status, prev_state);
                    rst = FALSE;
                    *Status = CONVERT_STATUS_ERROR;
                }
#endif

#if defined(RWCACHE_PERF_COUNTERS)
                if (rwcache) {

                    ULONG   rmiss, rhit, roverhead, wmiss, whit, usage;

                    rwcache->Flush();
                    rwcache->QueryPerformanceCounters(&rmiss, &rhit, &roverhead, &wmiss, &whit, &usage);
                    printf("RMiss = %d (%d)\n", rmiss, (rmiss*100)/(rmiss+rhit));
                    printf("RHit = %d (%d)\n", rhit, (rhit*100)/(rmiss+rhit));
                    printf("ROverHead = %d (%d)\n", roverhead, (roverhead*100)/(rmiss+rhit));
                    printf("WMiss = %d (%d)\n", wmiss, (wmiss*100)/(wmiss+whit));
                    printf("WHit = %d (%d)\n", whit, (whit*100)/(wmiss+whit));
                    printf("Usage = %d (%d)\n", usage, (usage*100)/blocks);
                }
#endif
                return rst;

            } else {

                //
                //  Cannot read superarea
                //
                *Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }

        } else {

            //
            //  Cannot initialize Superarea
            //
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

    } else {

        //
        //  The file system is not valid
        //
        *Status = CONVERT_STATUS_INVALID_FILESYSTEM;
        return FALSE;
    }
}

#if !defined(_AUTOCHECK_)

BOOLEAN
IsTargetOfs(
    IN      PCWSTRING           TargetFileSystem )
{
    DSTRING Ofs;
    Ofs.Initialize("OFS");

    return 0 == TargetFileSystem->Stricmp(&Ofs);
}

BOOLEAN
IsChkdskOkay(
    IN        PCWSTRING      NtDriveName,
    IN OUT    PMESSAGE       Message,
    IN        BOOLEAN        Verbose
            )
{
    DSTRING             libraryName;
    DSTRING             entryPoint;
    HANDLE              fsUtilityHandle;
    CHKDSKEX_FN         Chkdsk;
    CHKDSKEX_FN_PARAM   param;

    if (!libraryName.Initialize( L"UFAT.DLL" ) ||
          !entryPoint.Initialize( L"ChkdskEx" )) {
          Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        Message->Display();
          return FALSE;
     }

    Chkdsk = (CHKDSKEX_FN)SYSTEM::QueryLibraryEntryPoint(&libraryName,
                                                       &entryPoint,
                                                       &fsUtilityHandle );

    if ( NULL == Chkdsk ) {
        //
        //  There is no conversion DLL for the file system in the volume.
        //

        Message->Set( MSG_FS_NOT_SUPPORTED );
        Message->Display( "%s%W", "CHKDSK", L"FAT" );
        Message->Set( MSG_BLANK_LINE );
        Message->Display( "" );

        return FALSE;
    }

    ULONG   exitStatus;

    memset(&param, 0, sizeof(param));

    param.Major = 1;
    param.Minor = 1;
    param.Flags = Verbose ? CHKDSK_VERBOSE : 0;

    Chkdsk( NtDriveName,
            Message,
            FALSE,      // don't fix - just see if they are consistent
            &param,
            &exitStatus );

    SYSTEM::FreeLibraryHandle( fsUtilityHandle );

    if ( CHKDSK_EXIT_SUCCESS != exitStatus ) {
        Message->Set(MSG_CONV_NTFS_CHKDSK);
        Message->Display();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ConvertToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    OUT     PCONVERT_STATUS     Status
            )
{
    DSTRING libraryName;
    DSTRING entryPoint;
    HANDLE  fsUtilityHandle;

    libraryName.Initialize( FAT_TO_OFS_DLL_NAME );

    entryPoint.Initialize( FAT_TO_OFS_FUNCTION_NAME );

    FAT_OFS_CONVERT_FN Convert;

    Convert = (FAT_OFS_CONVERT_FN)SYSTEM::QueryLibraryEntryPoint(
        &libraryName, &entryPoint, &fsUtilityHandle );

    if ( NULL == Convert )
    {
        //
        //  There is no conversion DLL for the file system in the volume.
        //
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    PWSTR pwszNtDriveName = NtDriveName->QueryWSTR();
    FAT_OFS_CONVERT_STATUS cnvStatus;
    BOOLEAN fResult= Convert( pwszNtDriveName,
                              Message,
                              Verbose,
                              FALSE,    // Not in Setup Time
                              &cnvStatus );

    DELETE( pwszNtDriveName );
    SYSTEM::FreeLibraryHandle( fsUtilityHandle );

    if ( FAT_OFS_CONVERT_SUCCESS == cnvStatus )
    {
        *Status = CONVERT_STATUS_CONVERTED;
    }
    else
    {
        *Status = CONVERT_STATUS_ERROR;
    }

    return fResult;

}
#endif  // _AUTOCHECK_


BOOLEAN
FAR APIENTRY
ConvertFAT(
    IN      PCWSTRING           NtDriveName,
    IN      PCWSTRING           TargetFileSystem,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
        )
/*++

Routine Description:

        Converts a FAT volume to another file system.

Arguments:

        NtDrivName       -- supplies the name of the drive to check
        TargetFileSystem -- supplies the name of the target file system
        CvtZoneFileName  -- supplies the name of the convert zone
        Message          -- supplies an outlet for messages
        Flags            -- supplies flags (CONVERT_VERBOSE_FLAG, CONVERT_FORCE_DISMOUNT_FLAG, etc)
        Status           -- supplies pointer to convert status code

Return Value:

        BOOLEAN -   TRUE if conversion successful

--*/
{
#if defined(_AUTOCHECK_)
    return FALSE;
#else
    //
    // If we are converting to OFS, we have to delete the drive before
    // calling the routine. So, use a pointer instead of a stack object.
    //
    PLOG_IO_DP_DRIVE    pDrive;     //  Drive to convert

    DebugPtrAssert( NtDriveName );
    DebugPtrAssert( TargetFileSystem );
    DebugPtrAssert( Status );

    BOOLEAN             ForceDismount;

    ForceDismount = (Flags & CONVERT_FORCE_DISMOUNT_FLAG) ? TRUE : FALSE;

    if (!(Flags & CONVERT_NOCHKDSK_FLAG)) {

        pDrive = NEW LOG_IO_DP_DRIVE;
        if ( NULL == pDrive ) {
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

        //
        // Open the drive and make sure we can lock it before proceeding into chkdsk.
        // Eventually, we need to support a readonly chkdsk with volume locked.
        //
        if ( !pDrive->Initialize( NtDriveName ) ) {

            //
            //  Could not initialize the drive
            //
            *Status = CONVERT_STATUS_ERROR;
            DELETE(pDrive);
            return FALSE;
        }

        if (!pDrive->IsWriteable()) {
            *Status = CONVERT_STATUS_WRITE_PROTECTED;
            DELETE(pDrive);
            return FALSE;
        }

        if (pDrive->IsSonyMS()) {
            *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Lock() ) {
            //
            //  Could not lock the volume
            //  Try to dismount the volume or prompt the user to do so
            //
            if (!ForceDismount) {
                Message->Set(MSG_CONV_FORCE_DISMOUNT_PROMPT);
                Message->Display();
                if (Message->IsYesResponse(FALSE)) {
                    ForceDismount = TRUE;
                }
            }

            if (ForceDismount) {
                if (!IFS_SYSTEM::DismountVolume(NtDriveName)) {
                    Message->Set(MSG_CONV_UNABLE_TO_DISMOUNT);
                    Message->Display();
                    ForceDismount = FALSE;
                } else {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                }
            }

            if (!ForceDismount) {
                *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
                DELETE(pDrive);
                return FALSE;
            }

            if ( !pDrive->Initialize( NtDriveName ) ) {

                //
                //  Could not initialize the drive
                //
                *Status = CONVERT_STATUS_ERROR;
                DELETE(pDrive);
                return FALSE;
            }

            if ( !pDrive->Lock() ) {

                //
                // Still cannot lock the volume
                //
                *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
                DELETE(pDrive);
                return FALSE;
            }
        }

        DELETE(pDrive); // unlock it so that we can run chkdsk

        //
        // Do a chkdsk before proceeding ahead.
        //
        if ( !IsChkdskOkay( NtDriveName, Message, (Flags & CONVERT_VERBOSE_FLAG) ? TRUE : FALSE) ) {
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

        Message->Set(MSG_BLANK_LINE);
        Message->Display();
    }

    pDrive = NEW LOG_IO_DP_DRIVE;
    if ( NULL == pDrive ) {
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    // Open the drive and lock it.
    //
    if ( !pDrive->Initialize( NtDriveName ) ) {

        //
        //  Could not initialize the drive
        //
        *Status = CONVERT_STATUS_ERROR;
        DELETE(pDrive);
        return FALSE;
    }

    if (!pDrive->IsWriteable()) {
        *Status = CONVERT_STATUS_WRITE_PROTECTED;
        DELETE(pDrive);
        return FALSE;
    }

    if (pDrive->IsSonyMS()) {
        *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
        DELETE(pDrive);
        return FALSE;
    }

    if (IsTargetNTFS( TargetFileSystem )) {

        BOOLEAN    found;

        if (CheckForNTFSReserveNames(NtDriveName, &found)) {
             if (found) {
                 *Status = CONVERT_STATUS_NTFS_RESERVED_NAMES;
                 DELETE(pDrive);
                 return FALSE;
             }
        } else {
             Message->Set(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
             Message->Display();
             *Status = CONVERT_STATUS_ERROR;
             DELETE(pDrive);
             return FALSE;
        }
    }

    if ( !pDrive->Lock() ) {
        //
        //  Could not lock the volume
        //  Try to dismount the volume or prompt the user to do so
        //
        if (!ForceDismount) {
            Message->Set(MSG_CONV_FORCE_DISMOUNT_PROMPT);
            Message->Display();
            if (Message->IsYesResponse(FALSE)) {
                ForceDismount = TRUE;
            }
        }

        if (ForceDismount) {
            if (!IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->Set(MSG_CONV_UNABLE_TO_DISMOUNT);
                Message->Display();
                ForceDismount = FALSE;
            } else {
                //
                // Display the message only if this is the first time we dismount
                //
                if (Flags & CONVERT_NOCHKDSK_FLAG) {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                }
            }
        }

        if (!ForceDismount) {
            *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Initialize( NtDriveName ) ) {

            //
            //  Could not initialize the drive
            //
            *Status = CONVERT_STATUS_ERROR;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Lock() ) {

            //
            // Still cannot lock the volume
            //
            *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
            DELETE(pDrive);
            return FALSE;
        }
    }

    BOOLEAN fResult = ConvertFATVolume( pDrive,
                                        TargetFileSystem,
                                        CvtZoneFileName,
                                        Message,
                                        Flags,
                                        Status );

    DELETE( pDrive );
    return fResult;
#endif
}


BOOLEAN
FAR APIENTRY
ConvertFatToNtfs(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    )

/*++

Routine Description:

    Converts a FAT volume to NTFS

Arguments:

    Drive                           supplies pointer to drive
    FatSa                           supplies pointer to FAT superarea
    CvtZoneFileName                 supplies the name of the convert zone.
    Message                         supplies an outlet for messages
    Verbose                         TRUE if should run inv verbose mode
    Status                          supplies pointer to convert status code

Return Value:

    BOOLEAN -   TRUE if conversion successful

Notes:

    The volume is locked on entry. The FAT superarea has
    been read.

--*/

{
    FAT_NTFS        FatNtfs;    //  FAT-NTFS conversion object

    DebugPrintTrace(( "CONVERT: Converting FAT volume to NTFS\n"));

    //
    //  Initialize the conversion object and invoke its
    //  conversion method.
    //

    if ( FatNtfs.Initialize( Drive, FatSa, CvtZoneFileName, Message, Flags )) {

        return FatNtfs.Convert( Status );

    } else {

        //
        //  Could not initialize FAT_NTFS object
        //
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskcomp\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=diskcomp
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\diskcomp.cxx ..\diskcomp.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cufat\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

	pch.cxx

Abstract:

	This module is used to pre-compiles cufat headers.

Author:

	Matthew Bradburn (mattbr)  27-Apr-1994

--*/

#define _NTAPI_ULIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskcopy\diskcopy.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        diskcopy.cxx

Abstract:

        Utility to duplicate a disk

Author:

        Norbert P. Kusters (norbertk) 10-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "ulibcl.hxx"
#include "mldcopy.hxx"

INT __cdecl
main(
    )
/*++

Routine Description:

    Main program for DISKCOPY.

Arguments:

    None.

Return Value:

    0   - Copy was successful.
    1   - A nonfatal read/write error occured.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    STRING_ARGUMENT     drive_arg1;
    STRING_ARGUMENT     drive_arg2;
    FLAG_ARGUMENT       slashv;
    FLAG_ARGUMENT       helparg;
    FLAG_ARGUMENT       genvalue;
    DSTRING             dossource;
    DSTRING             dosdest;
    DSTRING             ntsource;
    DSTRING             ntdest;
    DSTRING             currentdrive;
    PWSTRING            pwstring;
    DSTRING             colon;
    INT                 result;

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    message = &msg;

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 4;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 4;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 4;
    }

    if (!progname.Initialize("*") ||
        !drive_arg1.Initialize("*:") ||
        !drive_arg2.Initialize("*:") ||
        !slashv.Initialize("/v") ||
        !helparg.Initialize("/?") ||
        !genvalue.Initialize("/machinetoken")) {
        return 4;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&drive_arg1) ||
        !arg_array.Put(&drive_arg2) ||
        !arg_array.Put(&slashv) ||
        !arg_array.Put(&helparg) ||
        !arg_array.Put(&genvalue)) {
        return 4;
    }

    if (!arglex.DoParsing(&arg_array)) {
        message->Set(MSG_INVALID_PARAMETER);
        message->Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 4;
    }

    if (genvalue.QueryFlag()) {
        message->Set(MSG_ONE_STRING_NEWLINE);
        message->Display("%X", QueryMachineUniqueToken());
        return 0;
    }

    if (helparg.QueryFlag()) {
        message->Set(MSG_DCOPY_INFO);
        message->Display();
        message->Set(MSG_DCOPY_USAGE);
        message->Display();
        message->Set(MSG_DCOPY_SLASH_V);
        message->Display();
        message->Set(MSG_DCOPY_INFO_2);
        message->Display();
        return 0;
    }

    if (!colon.Initialize(":")) {
        return 4;
    }

    if (drive_arg1.IsValueSet()) {
        if (!dossource.Initialize(drive_arg1.GetString()) ||
            !dossource.Strcat(&colon) ||
            !dossource.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dossource)) {
            return 4;
        }
    }

    if (drive_arg2.IsValueSet()) {
        if (!dosdest.Initialize(drive_arg2.GetString()) ||
            !dosdest.Strcat(&colon) ||
            !dosdest.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dosdest)) {
            return 4;
        }
    }

    if (SYSTEM::QueryDriveType(&dossource) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (SYSTEM::QueryDriveType(&dosdest) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!SYSTEM::QueryCurrentDosDriveName(&currentdrive) ||
        currentdrive == dosdest) {

        message->Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dossource, &ntsource)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdest, &ntdest)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    for (;;) {

        result = DiskCopyMainLoop(&ntsource, &ntdest, &dossource, &dosdest,
                                  slashv.QueryFlag(), message);

        if (result > 1) {
            message->Set(MSG_DCOPY_ENDED);
            message->Display();
        }

        message->Set(MSG_DCOPY_ANOTHER);
        message->Display();

        if (!message->IsYesResponse(FALSE)) {
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cufat\src\cufat.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        Cufat.cxx

Abstract:

        This module contains run-time, global support for the
        FAT Conversion library (CUFAT). This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Ramon Juan San Andres (ramonsa) 23-Sep-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#include "ulib.hxx"

//
//      Local prototypes
//
STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C" BOOLEAN
InitializeCufat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

BOOLEAN
InitializeCufat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Cufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Cufat initialization failed!!!\n" );
        return( FALSE );
    }

    DebugPrint("CUFAT.DLL got attached.\n");

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
                DebugPrintTrace(("CUFAT.DLL got attached %d times.\n", count));
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Cufat initialization failed!!!\n" );
                return( FALSE );
            }

            DebugPrint("CUFAT.DLL got attached.\n");

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
                DebugPrintTrace(("CUFAT.DLL got detached.  %d time(s) left.\n", count));
                return TRUE;
            }
            if (count == 1) {

                DebugPrint("CUFAT.DLL got detached.\n");

                UndefineClassDescriptors();
                count--;
            } else
                DebugPrint("CUFAT.DLL detached more than attached\n");
            break;
    }
#endif // _AUTOCHECK || _SETUP_LOADER_

    return TRUE;
}



DECLARE_CLASS(  FAT_NTFS        );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if ( DEFINE_CLASS_DESCRIPTOR(   FAT_NTFS        )        &&
                TRUE ) {
                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(   FAT_NTFS        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cufat\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=cnvfat
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib              \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib       \
           ..\..\..\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib       \
           ..\..\..\untfs\src\$(ALT_PROJECT)\$(O)\untfs.lib     \
           ..\..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1

DLLENTRY=InitializeCufat
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\convfat.cxx \
        ..\cufat.cxx   \
        ..\cufat.rc    \
        ..\fatntfs.cxx

INCLUDES=..\.;                          \
         ..\..\inc;                     \
         ..\..\..\ufat\inc;             \
         ..\..\..\untfs\inc;            \
         ..\..\..\ulib\inc;             \
         ..\..\..\ifsutil\inc;          \
         $(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

UMTYPE=console
DLLDEF=..\cufat.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\cufat\src\fatntfs.cxx ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    fatntfs.cxx

Abstract:

    This module implements the conversion from FAT to NTFS

Author:

    Ramon J. San Andres (ramonsa)  Sep-19-1991

Environment:

    ULIB, User Mode

--*/


#include <pch.cxx>

//
//  ULIB include files
//
#define _NTAPI_ULIB_
#include "ulib.hxx"
#include "array.hxx"
#include "drive.hxx"
#include "hmem.hxx"
#include "wstring.hxx"
#include "rtmsg.h"

//#define CONVERT_PERF_COUNTERS   1

//
//  IFSUTIL include files
//
#include "secrun.hxx"

#if defined ( _AUTOCONV_ )
#include "ifssys.hxx"
#else
#if defined(CONVERT_PERF_COUNTERS)
#include <stdio.h>
#endif
#endif

//
//  CUFAT include files
//

#include "fatsa.hxx"
#include "fatntfs.hxx"

//
//  UFAT include files
//
#include "fatdent.hxx"
#include "fatdir.hxx"
#include "filedir.hxx"

//
//  UNTFS include files
//
#include "attrib.hxx"
#include "upfile.hxx"
#include "logfile.hxx"
#include "ntfssa.hxx"

//
//  Number of clusters in boot sector
//
#define CLUSTERS_IN_BOOT         ((BYTES_IN_BOOT_AREA + _ClusterFactor*_Drive->QuerySectorSize() - 1)/ \
                                  (_ClusterFactor*_Drive->QuerySectorSize()))

//
//  Maximum ntfs cluster size to use during conversion
//
#define MAX_NTFS_CLUSTER_SIZE   (1024*4)    // 4K

//
// Size of the buffer used to display filenames in verbose mode
//
#define DISPLAY_BUFFER_SIZE 128

DEFINE_CONSTRUCTOR( FAT_NTFS, OBJECT );

#if defined(CONVERT_PERF_COUNTERS)
typedef struct _PERF_DATA {
    BOOLEAN             first_call;
    LARGE_INTEGER       t1;
    LARGE_INTEGER       wwtime;
    LARGE_INTEGER       wrtime;
    LARGE_INTEGER       wctime;
    LARGE_INTEGER       wscnt;
    LARGE_INTEGER       wccnt;
    LARGE_INTEGER       rrtime;
    LARGE_INTEGER       rscnt;
    LARGE_INTEGER       rccnt;
} PERF_DATA;

BOOLEAN
CheckTime(
    PMESSAGE            Message,
    PLOG_IO_DP_DRIVE    pDrive,
    PERF_DATA           *pData,
    PCHAR               Title
)
{
    LARGE_INTEGER   freq;
    LARGE_INTEGER   wwtime;
    LARGE_INTEGER   wrtime;
    LARGE_INTEGER   wctime;
    LARGE_INTEGER   wscnt;
    LARGE_INTEGER   wccnt;
    LARGE_INTEGER   rrtime;
    LARGE_INTEGER   rscnt;
    LARGE_INTEGER   rccnt;
    LARGE_INTEGER   t2;

    if (pData->first_call) {
        pData->first_call = FALSE;
        pDrive->QueryPerformanceCounters(&pData->wwtime,
                                         &pData->wrtime,
                                         &pData->wctime,
                                         &pData->wscnt,
                                         &pData->wccnt,
                                         &pData->rrtime,
                                         &pData->rscnt,
                                         &pData->rccnt);
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "VVVV ", Title);
        QueryPerformanceCounter(&pData->t1);
    } else {
        QueryPerformanceCounter(&t2);
        pDrive->QueryPerformanceCounters(&wwtime,
                                         &wrtime,
                                         &wctime,
                                         &wscnt,
                                         &wccnt,
                                         &rrtime,
                                         &rscnt,
                                         &rccnt);
        QueryPerformanceFrequency(&freq);
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        Message->Display("%s%I64d", "^^^^ Elapsed time in ms: ",
                         ((t2.QuadPart-pData->t1.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WWTime: ", ((wwtime.QuadPart-pData->wwtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WRTime: ", ((wrtime.QuadPart-pData->wrtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WCTime: ", ((wctime.QuadPart-pData->wctime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WSCnt: ",  wscnt.QuadPart -pData->wscnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ WCCnt: ",  wccnt.QuadPart -pData->wccnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ RCTime: ", ((rrtime.QuadPart-pData->rrtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ RSCnt: ",  rscnt.QuadPart -pData->rscnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ RCCnt: ",  rccnt.QuadPart -pData->rccnt.QuadPart);

        pData->wwtime = wwtime;
        pData->wrtime = wrtime;
        pData->wctime = wctime;
        pData->wscnt = wscnt;
        pData->wccnt = wccnt;
        pData->rrtime = rrtime;
        pData->rscnt = rscnt;
        pData->rccnt = rccnt;

        Message->Display("%s%s", "VVVV ", Title);
        QueryPerformanceCounter(&pData->t1);
    }
    return TRUE;
}
#endif


VOID
FAT_NTFS::Construct (
    )
/*++

Routine Description:

    Constructs a FAT_NTFS object

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FatSa          =   NULL;
    _Drive          =   NULL;
    _Message        =   NULL;
    _FileNameBuffer =   NULL;
}



VOID
FAT_NTFS::Destroy (
    )
/*++

Routine Description:

    Destroys a FAT_NTFS object

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _FatSa );
    DELETE( _Drive );
    DELETE( _Message );
    DELETE( _FileNameBuffer );
}



FAT_NTFS::~FAT_NTFS (
    )
/*++

Routine Description:

    Destructor for FAT_NTFS.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



BOOLEAN
FAT_NTFS::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags
    )
/*++

Routine Description:

    Initializes a FAT_NTFS object

Arguments:

    FatVol  -   Supplies the FAT volume
    FatSa   -   Supplies pointer to FAT superarea
    CvtZoneFileName - Supplies the name of the convert zone.
    Message -   Supplies message object
    Flags   -   Supplies convert flags

Return Value:

    BOOLEAN -   TRUE if successfully initialized, FALSE otherwise

--*/

{
    ULONG   fat_cluster_size;
    LCN     cvt_zone_in_ntfs;
    BIG_INT cvt_zone_size_in_ntfs;

    DebugPtrAssert( Drive     );
    DebugPtrAssert( FatSa     );
    DebugPtrAssert( Message   );

    //
    //  Initialize the stuff passed as argument
    //
    _FatSa          =   FatSa;
    _Drive          =   Drive;
    _Message        =   Message;
    _Flags          =   Flags;

    //  Floppies cannot be converted to NTFS.
    //
    if( _Drive->IsFloppy() ) {

        Message->Set(MSG_NTFS_FORMAT_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //  To protect ourselves from disk drivers that cannot
    //  correctly determine the disk geometry, compare the
    //  boot-code-critical values from the existing BPB with
    //  the drive's values.  If they don't match, we can't
    //  convert this drive because if it's the system partition,
    //  the system won't boot.
    //
    if( !CheckGeometryMatch( ) ) {

        _Message->Set( MSG_CONV_GEOMETRY_MISMATCH );
        _Message->Display( "%s", "NTFS"  );
        return FALSE;
    }

    fat_cluster_size = FatSa->QuerySectorsPerCluster() * _Drive->QuerySectorSize();

    //
    //  For volumes that are not data aligned, make cluster size
    //  equals sector size.
    //  For volumes that are data aligned, preserve the cluster size
    //
    if (FatSa->IsVolumeDataAligned()) {
        _ClusterFactor = min(FatSa->QuerySectorsPerCluster(),
                             MAX_NTFS_CLUSTER_SIZE/_Drive->QuerySectorSize());
        _ClusterRatio = max(1, fat_cluster_size/MAX_NTFS_CLUSTER_SIZE);
    } else {
        _ClusterFactor = 1;
        _ClusterRatio = FatSa->QuerySectorsPerCluster();
    }


    if (SMALL_FRS_SIZE >= Drive->QuerySectorSize())
        _FrsSize = SMALL_FRS_SIZE;
    else
        _FrsSize = Drive->QuerySectorSize();

    //  Set the default number of clusters per Index Allocation Buffer
    //  to a useful value.
    //
    _ClustersPerIndexBuffer = NTFS_SA::QueryDefaultClustersPerIndexBuffer(
                                       _Drive, _ClusterFactor);

    //
    //  _NumberOfFiles and _NumberOfDirectories are used to extend
    //  the MFT when we know how many files there are in the volume.
    //  Unless we do a volume census these values must be zero.
    //
    _NumberOfFiles          =   0;
    _NumberOfDirectories    =   0;

    if ( CvtZoneFileName->QueryChCount() ) {

        PFATDIR     RootDir;
        FAT_DIRENT  CvtZoneFileEntry;

        //
        //  Get the root directory
        //
        RootDir = (PFATDIR)_FatSa->GetRootDir();
        if ( !RootDir ) {
            RootDir = (PFATDIR)_FatSa->GetFileDir();
        }

        DebugPtrAssert( RootDir );

        //
        //  Locate the convert zone file. If it exists then remember its starting cluster
        //  number and it's size.
        //
        //  The starting cluster of the convert zone is remembered because it is used
        //  later on for identifying the convert zone file while traversing the root directory.
        //

        if ( CvtZoneFileEntry.Initialize( RootDir->SearchForDirEntry( CvtZoneFileName ),
                                          FatSa->GetFileDir() ? FAT_TYPE_FAT32 : FAT_TYPE_EAS_OKAY )) {

            if (CvtZoneFileEntry.IsDirectory()) {
                Message->Set(MSG_CONV_CVTAREA_MUST_BE_FILE, ERROR_MESSAGE);
                Message->Display("%W", CvtZoneFileName);
                return FALSE;
            }
            _CvtZoneFileFirstCluster = CvtZoneFileEntry.QueryStartingCluster();
            _CvtZoneSize = (((BIG_INT)CvtZoneFileEntry.QueryFileSize() + fat_cluster_size - 1)/fat_cluster_size).GetLowPart();

            if (!FatSa->IsFileContiguous(_CvtZoneFileFirstCluster)) {
                Message->Set(MSG_CONV_CVTAREA_FILE_NOT_CONTIGUOUS, ERROR_MESSAGE);
                Message->Display("%W", CvtZoneFileName);
                return FALSE;
            }

            cvt_zone_in_ntfs = FatClusterToLcn(_CvtZoneFileFirstCluster)/_ClusterFactor;
            cvt_zone_size_in_ntfs = _CvtZoneSize*_ClusterRatio;
        } else {
            Message->Set(MSG_CONV_CVTAREA_FILE_MISSING, ERROR_MESSAGE);
            Message->Display("%W", CvtZoneFileName);
            return FALSE;
        }
    } else {
        _CvtZoneFileFirstCluster = 0;
        _CvtZoneSize = 0;
        cvt_zone_in_ntfs = 0;
        cvt_zone_size_in_ntfs = 0;
    }

    DebugAssert(cvt_zone_in_ntfs.GetHighPart() == 0);
    DebugAssert(cvt_zone_size_in_ntfs.GetHighPart() == 0);

    //  Allocate space for the file name attribute buffer and initialize
    //  the NTFS superarea and the Bad LCN stack.
    //

    if ( (

        _FileNameBuffer =
         (PFILE_NAME)MALLOC( sizeof(FILE_NAME) +
                             sizeof(WCHAR) * NAMEBUFFERSIZE )) == NULL ||
        !_RootIndexName.Initialize( FileNameIndexNameData ) ||
        !_NtfsSa.Initialize( _Drive, _Message,
                             cvt_zone_in_ntfs,
                             cvt_zone_size_in_ntfs )       ||
        !_BadLcn.Initialize() ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
FAT_NTFS::Convert(
    OUT PCONVERT_STATUS Status
    )

/*++

Routine Description:

    Converts a FAT volume to NTFS

Arguments:

    Status  -   Supplies pointer to conversion status

Return Value:

    BOOLEAN -   TRUE if successfully converted, FALSE otherwise

--*/

{
    BOOLEAN     Converted;
#if defined(CONVERT_PERF_COUNTERS)
    PERF_DATA   pdata;

    pdata.first_call = TRUE;
#endif

    DebugPtrAssert( Status );

#if defined ( _AUTOCONV_ )

    _Message->Set( MSG_CONV_WILL_REBOOT );
    _Message->Display();

#endif // _AUTOCONV_

    //
    //  The conversion from FAT to NTFS consists of a sequence of well-defined
    //  steps:
    //
    //  1.- Create holes (i.e. relocate FAT clusters) for fixed-location
    //      NTFS structures and save FAT.
    //
    //  2.- Create NTFS elementary data structures in FAT free space
    //
    //  3.- Convert the File system, creating the NTFS file system in
    //      the FAT free space.
    //
    //  4.- Mark as free in the NTFS bitmap those NTFS clusters being used
    //      by FAT-specific structures.
    //
    //  5.- Write NTFS boot sector
    //
    //
    //  Since a crash can occur at any time, we must minimize the chance of
    //  disk corruption. Note that (almost) all writes are to FAT free space,
    //  so a crash will preserve the FAT intact.
    //
    //  The only times at which we write to non-free space, i.e. the times at
    //  which a crash might cause problems are:
    //
    //  a.- At the end of step 1, when we overwrite the FAT. The algorithm
    //      for relocating clusters (in UFAT) guarantees that CHKDSK will be
    //      able to fix the disk without any loss of data.
    //
    //  b.- In step 5, while writting the boot sector. If a crash occurs during
    //      this step, We're out of luck.
    //
    //

    Converted = (BOOLEAN)(  //
                            //  Create holes for fixed-location structures
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CheckSpaceAndCreateHoles") &&
#endif
                            CheckSpaceAndCreateHoles( )                                     &&
                            //
                            //    Initialize the bitmaps
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CreateBitmaps")            &&
#endif
                            CreateBitmaps( )                                                &&
                            //
                            //    Create the NTFS elementary data structures
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CreateElementary")         &&
#endif
                            CreateElementary( )                                             &&
                            //
                            //    Convert the file system
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "ConvertFileSystem")        &&
#endif
                            ConvertFileSystem( )                                            &&
                            //
                            //    Mark the reserved sectors as free
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "FreeReservedSectors")      &&
#endif
                            FreeReservedSectors( )                                          &&
                            //
                            //    Volume converted, write the boot code
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "WriteBoot")                &&
#endif
                            WriteBoot( )                                                    &&

#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "Done")                     &&
#endif
                            (TRUE));

    *Status = _Status;

    return Converted;
}



BOOLEAN
FAT_NTFS::CheckSpaceAndCreateHoles (
    )

/*++

Routine Description:

    Determines free space requirements, makes sure that there is
    enough space for conversion, and makes holes. All this
    is done in one step so that we only have to traverse the
    file system once.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if there is enough space for conversion and
                the holes are in place.
                FALSE otherwise

--*/

{
    INTSTACK        HoleStack;          //  Stack of holes
    CENSUS_REPORT   CensusReport;       //  Census report
    PCENSUS_REPORT  Census;             //  Pointer to census report
    BIG_INT         SectorsTotal;       //  Number of sectors on the volume
    BIG_INT         SectorsFree;        //  Free sectors on the volume
    BIG_INT         SectorsNeeded;      //  Sectors needed by conversion
    BIG_INT         KbytesTotal;
    BIG_INT         KbytesFree;
    BIG_INT         KbytesNeeded;
    BOOLEAN         Relocated;          //  TRUE if relocated sectors


#if !defined ( _AUTOCHECK_ )

    if(_FatSa->QueryVolumeFlags() & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) {
    //
    //  The volume dirty bit is set??? Need to CHKDSK first.
    //
        _Message->Set( MSG_CONV_DISK_IS_DIRTY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_DRIVE_IS_DIRTY;
        return FALSE;
    }

#endif // !_AUTOCHECK_

    //
    //  Identify all the "holes" that we need i.e. all those spots
    //  that are used by NTFS structures that need to be at a fixed
    //  location.
    //
    //
    if ( !QueryNeededHoles( &HoleStack ) ) {
        return FALSE;
    }

    SectorsTotal = _FatSa->QueryVirtualSectors();
    SectorsFree  = _FatSa->QueryFreeSectors();
    // Census =  ( SectorsFree > ( SectorsTotal / 2 ) ) ? NULL : &CensusReport;
    Census       = &CensusReport;
    Relocated    = FALSE;

    //
    //  Create the holes and obtain the census if necessary
    //
    _Message->Set( MSG_CONV_CHECKING_SPACE );
    _Message->Display();

    if ( !_FatSa->QueryCensusAndRelocate( Census, &HoleStack, &Relocated )) {

        _Message->Set( MSG_CONV_CANNOT_RELOCATE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

#if defined ( _AUTOCONV_ )

    //
    //  If relocated sectors, then we will be overwritting data that might
    //  be needed by the system. In order to avoid this, we reboot so that
    //  the system will read its stuff from the new locations.
    //
    if ( Relocated ) {

        _Drive->FlushCache();

        _Message->Set( MSG_CONV_REBOOT_AFTER_RELOCATION );
        _Message->Display();

        IFS_SYSTEM::Reboot();
        //
        //  If we reach this point, the reboot failed and we should not
        //  continue the conversion.
        //
        _Message->Set( MSG_CONV_CANNOT_RELOCATE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }


#endif

    //
    //  Determine the number of sectors needed for the conversion
    //
    if ( Census ) {

        //
        //  Estimate the number of sectors needed based on the
        //  volume census.
        //
        QuerySectorsNeededForConversion( Census, &SectorsNeeded );

    } else {

        //
        //  We'll say that we need half of the disk
        //
        SectorsNeeded = SectorsTotal / 2;
    }

    //
    // Take into account that the convert zone file is actually a free
    // space for NTFS to use to put system files
    //
    SectorsFree += (_CvtZoneSize * _FatSa->QuerySectorsPerCluster());

    KbytesTotal = SectorsTotal * _Drive->QuerySectorSize() / 1024;
    KbytesFree = SectorsFree * _Drive->QuerySectorSize() / 1024;
    KbytesNeeded = SectorsNeeded * _Drive->QuerySectorSize() / 1024;

    _Message->Set( MSG_CONV_KBYTES_TOTAL );
    _Message->Display( "%8d", KbytesTotal.GetLowPart() );
    _Message->Set( MSG_CONV_KBYTES_FREE );
    _Message->Display( "%8d", KbytesFree.GetLowPart() );
    _Message->Set( MSG_CONV_KBYTES_NEEDED );
    _Message->Display( "%8d", KbytesNeeded.GetLowPart() );


    if ( SectorsFree < SectorsNeeded ) {
        //
        //  Not enough disk space for conversion
        //
        _Message->Set( MSG_CONV_NO_DISK_SPACE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_INSUFFICIENT_FREE_SPACE;
        return FALSE;
    }


    //
    //  The disk has enough disk space.
    //
    return TRUE;
}



BOOLEAN
FAT_NTFS::ConvertRoot (
    IN PFATDIR  Directory
    )

/*++

Routine Description:

    Converts the FAT root directory and recursively all its
    subdirectories.

    This is basically the same as the ConvertDirectory method, the
    differences being:

    1.- The index for the root has already been created by
        NTFS_SA::CreateElementaryStructures()

    2.- No FRS is created

    3.- ConvertRoot does some extra checkings for
        EA file (which is at the root level only).


Arguments:

    Directory   -   Supplies root directory.

Return Value:

    BOOLEAN -   TRUE if root directory successfully converted
                FALSE otherwise

--*/

{
    NTFS_FILE_RECORD_SEGMENT    FrsOfRootIndex;             //  FRS of NTFS root index
    NTFS_INDEX_TREE             RootIndex;                  //  Root index
    BOOLEAN                     Converted;


    DebugPtrAssert( Directory );

    _Level = 0;

    //
    //  Obtain the NTFS root index
    //
    if ( !FrsOfRootIndex.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, &_Mft )  ||
         !FrsOfRootIndex.Read()                                            ||
         !RootIndex.Initialize( _Drive,
                                _ClusterFactor,
                                &_VolumeBitmap,
                                FrsOfRootIndex.GetUpcaseTable(),
                                FrsOfRootIndex.QueryMaximumAttributeRecordSize()/2,
                                &FrsOfRootIndex,
                                &_RootIndexName )
       ) {

        _Message->Set( MSG_CONV_CANNOT_MAKE_INDEX, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Convert the directory
    //
    if ( Converted = ConvertDir( Directory, &RootIndex, &FrsOfRootIndex )) {
        //
        //  Save the index
        //
        if ( !RootIndex.Save( &FrsOfRootIndex ) ||
             !FrsOfRootIndex.Flush( &_VolumeBitmap ) ) {

            _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
        }
    }

    return Converted;
}



BOOLEAN
FAT_NTFS::ConvertDirectory (
    IN      PFATDIR                     Directory,
    IN      PFAT_DIRENT                 DirEntry,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FrsDir
    )

/*++

Routine Description:

    Converts a FAT directory and recursively all its subdirectories

Arguments:

    Directory   -   Supplies directory to convert
    DirEntry    -   Supplies the directory entry of the directory
    FrsDir      -   Supplies pointer to FRS of directory

Return Value:

    BOOLEAN -   TRUE if directory successfully converted
                FALSE otherwise

--*/

{

    NTFS_INDEX_TREE             Index;                      //  NTFS index
    BOOLEAN                     Converted;                  //  FALSE if error
    ULONG                       DirSize;                    //  Dir size
    ULONG                       SectorsPerFatCluster;       //  Sectors per cluster
    ULONG                       Cluster;                    //  Dir cluster number
    PFAT                        Fat;                        //  Pointer to FAT
    LCN                         Lcn;                        //  LCN


    DebugPtrAssert( Directory );
    DebugPtrAssert( DirEntry );
    DebugPtrAssert( FrsDir );


    //
    //  Create an index for this directory:
    //
    if ( !Index.Initialize( $FILE_NAME,
                            _Drive,
                            _ClusterFactor,
                            &_VolumeBitmap,
                            FrsDir->GetUpcaseTable(),
                            COLLATION_FILE_NAME,
                            SMALL_INDEX_BUFFER_SIZE,
                            FrsDir->QueryMaximumAttributeRecordSize() /2,
                            &_RootIndexName
                          )
       ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    _Level++;

    //
    //  Convert the directory.
    //
    if ( Converted = ConvertDir( Directory, &Index, FrsDir ) ) {

        //
        //  If the directory has extended attributes, convert them.
        //
        //  Then save the index.
        //
        if ( Converted = (BOOLEAN)( !DirEntry->QueryEaHandle() ||
                                    ConvertExtendedAttributes( DirEntry, FrsDir ) ) ) {


            //
            //  Mark the sectors used by this directory in the reserved
            //  bitmap.
            //
            DirSize                 = DirEntry->QueryFileSize();
            SectorsPerFatCluster    = _FatSa->QuerySectorsPerCluster();
            Cluster                 = DirEntry->QueryStartingCluster();
            Fat                     = _FatSa->GetFat();

            while ( TRUE ) {

                Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;

                _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );

                if ( Fat->IsEndOfChain( Cluster )) {
                    break;
                }

                Cluster = Fat->QueryEntry( Cluster );
            }


            //
            //  Save the index for this directory
            //
            if ( !( Converted = (Index.Save( FrsDir ) ) ) ) {
                _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
            }
        }
    }

    _Level--;

    return Converted;
}



BOOLEAN
FAT_NTFS::ConvertDir (
    IN      PFATDIR                     Directory,
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FrsDir
    )

/*++

Routine Description:

    Converts a FAT directory and recursively all its subdirectories

Arguments:


Return Value:

    BOOLEAN -   TRUE if directory successfully converted
                FALSE otherwise

--*/

{

    FAT_DIRENT                  Entry;              //  Directory entry
    HMEM                        HMem;               //  Memory
    DSTRING                     DirName;            //  This dir's name
    DSTRING                     LongName;           //  the associated long name
    BOOLEAN                     UseLongName;        //  make one name attrib
    STANDARD_INFORMATION        StandardInformation;//  Std. Info
    ULONG                       EntryNumber;        //  Entry number counter
    BOOLEAN                     Converted;          //  FALSE if error
    NTFS_FILE_RECORD_SEGMENT    Frs;                //  FRS of each entry
    VCN                         FileNumber;         //  File Number of child.
    USHORT                      FrsFlags;
    PVOID                       DirEntry;
    FILEDIR                     SubDir;
    BOOLEAN                     HasLongName;
    UCHAR                       FatType;
    CANNED_SECURITY_TYPE        Sd;

#if defined(CONVERT_PERF_COUNTERS)
    PERF_DATA   pdata;
#endif

    Converted = TRUE;
    EntryNumber = 0;

    if (_FatSa->GetFileDir())
        FatType = FAT_TYPE_FAT32;
    else
        FatType = FAT_TYPE_EAS_OKAY;

    DebugPtrAssert( Directory );
    DebugPtrAssert( Index );
    DebugPtrAssert( FrsDir );


    //
    //  Traverse the directory, converting all its entries.
    //
    while ( Converted ) {

        //
        //  Get next directory entry
        //
        if ( !(DirEntry = Directory->GetDirEntry( EntryNumber ))) {
            break;
        }
        if ( !Entry.Initialize( DirEntry, FatType))
        {
            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
            DebugAssert(FALSE);
            break;
        }

        //
        //  If end of directory, get out
        //
        if ( Entry.IsEndOfDirectory() ) {
            break;
        }

        //
        //  Ignore the deleted, the "parent" and the "self" entries, the
        //  volume label and the EA file.
        //
        if (( Entry.IsErased()        ||
              Entry.IsDot()           ||
              Entry.IsDotDot()        ||
              Entry.IsVolumeLabel()   ||
              Entry.IsLongEntry()     ||
              (_CvtZoneFileFirstCluster != 0 &&
               Entry.QueryStartingCluster() == _CvtZoneFileFirstCluster) ||
              (_EAFileFirstCluster != 0 &&
               Entry.QueryStartingCluster() == _EAFileFirstCluster) ) ) {

              EntryNumber++;
              continue;
        }

        //  Fill in the standard information for this file or
        //  directory.  Note that NTFS stores Universal Time,
        //  whereas FAT stores Local Time, so the time has to
        //  be converted.
        //

        LARGE_INTEGER FatTime, NtfsTime;

        Entry.QueryLastWriteTime( &FatTime );
        RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );

        StandardInformation.LastModificationTime = NtfsTime;
        StandardInformation.LastChangeTime = NtfsTime;

        if (Entry.IsValidCreationTime()) {

            Entry.QueryCreationTime( &FatTime );
            RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );
            StandardInformation.CreationTime = NtfsTime;
        } else {

            StandardInformation.CreationTime = StandardInformation.LastChangeTime;
        }

        if (Entry.IsValidLastAccessTime()) {

            Entry.QueryLastAccessTime( &FatTime );
            RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );
            StandardInformation.LastAccessTime = NtfsTime;
        } else {

            StandardInformation.LastAccessTime = StandardInformation.LastChangeTime;
        }

        StandardInformation.FileAttributes = Entry.QueryAttributeByte();


        //
        //  Get the WSTR name of the entry and fill in the FILE_NAME
        //  structure for the file name attribute.  If this entry
        //  does not have an associated Long File Name, then its
        //  name is both a valid DOS and NTFS name; if there is an
        //  associated Long File Name, then the name is the DOS name
        //  and the long name is the NTFS name.
        //
        //  If the long name is identical to the short name, ignore
        //  the long name.
        //
        Entry.QueryName( &DirName );

        if( !Directory->QueryLongName( EntryNumber, &LongName ) ) {

            DebugPrintTrace(( "CUFAT: QueryLongName failed.\n" ));
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
            break;
        }

        HasLongName = (LongName.QueryChCount() != 0);

        //
        // If the long name is only a casewise permutation of the
        // short name, use the long name as the single ntfs name
        // attribute.
        //

        UseLongName = (HasLongName &&
                   0 == NtfsUpcaseCompare( DirName.GetWSTR(),
                                           DirName.QueryChCount(),
                                           LongName.GetWSTR(),
                                           LongName.QueryChCount(),
                                           FrsDir->GetUpcaseTable(),
                                           FALSE ));


        _FileNameBuffer->ParentDirectory = FrsDir->QuerySegmentReference();
        _FileNameBuffer->FileNameLength  = (unsigned char)DirName.QueryChCount();
        if (UseLongName) {

            _FileNameBuffer->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

            if ( !LongName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                Converted = FALSE;
                DebugAssert(FALSE);
                break;
            }

        } else {

            _FileNameBuffer->Flags = HasLongName ?
                                     FILE_NAME_DOS :
                                     FILE_NAME_NTFS | FILE_NAME_DOS;

            if ( !DirName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                Converted = FALSE;
                DebugAssert(FALSE);
                break;
            }
        }

        //  Allocate and create the FRS for this file or directory,
        //  add its file name, and add an appropriate entry to the
        //  index.
        //
        FrsFlags = (Entry.IsDirectory()) ? (USHORT)FILE_FILE_NAME_INDEX_PRESENT : (USHORT)0;

        if (_Flags & CONVERT_NOSECURITY_FLAG) {
            Sd = Entry.IsDirectory() ? EditWorldCannedDirSd : EditWorldCannedFileSd;
        } else {
            Sd = Entry.IsDirectory() ? NoAclCannedSd : NoAclCannedFileSd;
        }

        if ( !_Mft.AllocateFileRecordSegment( &FileNumber, FALSE )  ||
             !Frs.Initialize( FileNumber, &_Mft )          ||
             !Frs.Create( &StandardInformation, FrsFlags ) ||
             !Frs.AddFileNameAttribute( _FileNameBuffer )  ||
             !Frs.AddSecurityDescriptor( Sd, &_VolumeBitmap )  ||
             !Index->InsertEntry( NtfsFileNameGetLength( _FileNameBuffer ),
                                  _FileNameBuffer,
                                  Frs.QuerySegmentReference() ) ) {

            DebugPrint( "Can't create FRS in ConvertDirectory.\n" );
            Converted = FALSE;
            break;
        }

        //  If the file has separate long name, add that entry to the FRS
        //  and the index.
        //
        if( HasLongName && !UseLongName ) {


            _FileNameBuffer->ParentDirectory = FrsDir->QuerySegmentReference();
            _FileNameBuffer->FileNameLength  = (unsigned char)LongName.QueryChCount();
            _FileNameBuffer->Flags = FILE_NAME_NTFS;

            if ( !LongName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                 _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                 _Message->Display();
                 _Status = CONVERT_STATUS_ERROR;
                 Converted = FALSE;
                 DebugAssert(FALSE);
                 break;
            }

            if ( !Frs.AddFileNameAttribute( _FileNameBuffer )   ||
                 !Index->InsertEntry( NtfsFileNameGetLength( _FileNameBuffer ),
                                      _FileNameBuffer,
                                      Frs.QuerySegmentReference() ) ) {

                DebugPrint( "Can't create FRS in ConvertDirectory.\n" );
                Converted = FALSE;
                break;
            }
        }

        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            STATIC CHAR NameDisplayBuffer[DISPLAY_BUFFER_SIZE];
            ULONG NameStart = _Level * 4;
            PWSTRING Name;

            Name = (HasLongName ? &LongName : &DirName);

            if (NameStart > (DISPLAY_BUFFER_SIZE-4) ) {
                memset(NameDisplayBuffer, ' ', (DISPLAY_BUFFER_SIZE-4));
                memset(NameDisplayBuffer + (DISPLAY_BUFFER_SIZE-4), '.', 3);
            }
            else {
                memset(NameDisplayBuffer, ' ', NameStart);
                Name->QuerySTR( 0, TO_END, NameDisplayBuffer + NameStart,
                    DISPLAY_BUFFER_SIZE - NameStart, TRUE);
            }
            NameDisplayBuffer[DISPLAY_BUFFER_SIZE-1] = 0;
            _Message->Set( MSG_ONE_STRING );
            _Message->Display( "%s", NameDisplayBuffer );
        }

        //
        //  Determine if the entry is a directory or a file, and proccess it
        //  accordingly.
        //
        if ( Entry.IsDirectory() ) {

            //
            //  Directory
            //
            //
            //  Convert the directory (and all its subdirectories)
            //


            if ( !HMem.Initialize()     ||
                 !SubDir.Initialize( &HMem,
                                     _Drive,
                                     _FatSa,
                                     _FatSa->GetFat(),
                                     Entry.QueryStartingCluster() ) ) {

                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                DebugAssert(FALSE);
                return FALSE;
            }

            if ( !SubDir.Read() ) {
                _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
                _Message->Display( );
                _Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }

#if defined(CONVERT_PERF_COUNTERS)
            pdata.first_call = TRUE;
            CheckTime(_Message, _Drive, &pdata, "ConvertDirectory");
            _Message->Set(MSG_CHK_NTFS_MESSAGE);
            _Message->Display("%s%W", "VVVV Dir: ", &DirName);
#endif
            if ( !ConvertDirectory( &SubDir, &Entry, &Frs ) ||
                 !Frs.Flush( &_VolumeBitmap, Index ) ) {

                _Message->Set( MSG_CONV_CANNOT_CONVERT_DIRECTORY );
                _Message->Display( "%W", &DirName );
                Converted = FALSE;
                break;
            }
#if defined(CONVERT_PERF_COUNTERS)
            CheckTime(_Message, _Drive, &pdata, "ConvertDirectory Done");
#endif

        } else {

            //
            //  File
            //
            DebugAssert( !Entry.IsVolumeLabel() );
            DebugAssert( !Entry.IsLongEntry() );
            DebugAssert( !_EAFileFirstCluster ||
                       (Entry.QueryStartingCluster() != _EAFileFirstCluster) );

            //
            //  Convert the file.
            //
            if ( !ConvertFile( &Entry, &Frs ) ||
                 !Frs.Flush( &_VolumeBitmap, Index ) ) {

                Converted = FALSE;
                break;
            }
        }

        EntryNumber++;
    }


    return Converted;
}




BOOLEAN
FAT_NTFS::ConvertExtendedAttributes (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the extended attributes of a FAT directory entry.

Arguments:

    Dirent  -   Supplies the directory entry
    Frs     -   Supplies the file's FRS

Return Value:

    BOOLEAN -   TRUE if extended attributes converted
                FALSE otherwise

--*/

{
    USHORT  EaHandle;

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    EaHandle = Dirent->QueryEaHandle();

    //
    //  If this entry has extended attributes, convert them
    //
    if ( EaHandle ) {

        //
        //  Make sure that there is an EA file
        //
        if ( _EAFileFirstCluster == 0 ) {

            _Message->Set( MSG_CONV_NO_EA_FILE, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;

            return FALSE;
        }

        //
        //  Convert the attributes
        //
        return ConvertExtendedAttributes( Frs,
                                          EaHandle );


    }

    return TRUE;
}




BOOLEAN
FAT_NTFS::ConvertExtendedAttributes (
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN      USHORT                      EaHandle
    )

/*++

Routine Description:

    Converts the extended attributes of a FAT directory entry.

Arguments:

    Frs         -   Supplies the file's FRS
    Eahandle    -   Supplies the EA handle

Return Value:

    BOOLEAN -   TRUE if extended attributes converted
                FALSE otherwise

--*/

{
    EA_INFORMATION  EaInformation;
    NTFS_ATTRIBUTE  EaInformationAttribute;
    NTFS_ATTRIBUTE  EaDataAttribute;

    EA_SET      EaSet;      //  Extended attribute set
    HMEM        Mem;        //  Memory
    ULONG       Index;      //  EA Index
    PEA         Ea;         //  Pointer to EA
    ULONG       Cluster;    //  EA set cluster number
    PBYTE       UnpackedEaList;
    ULONG       PackedEaLength, UnpackedEaLength, PackedListLength,
                UnpackedListLength, NeedEaCount, TargetOffset;


    //
    //  Read in the EA set
    //
    Cluster = (_FatSa->GetFat())->QueryNthCluster( _EAFileFirstCluster,
                                                   _EAHeader.QueryEaSetClusterNumber( EaHandle ));

    if ( !Mem.Initialize()                          ||
         !EaSet.Initialize( &Mem,
                            _Drive,
                            _FatSa,
                            _FatSa->GetFat(),
                            Cluster )
       ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !EaSet.Read() ) {
        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    // Walk the list to determine the packed and unpacked length.  The
    // packed list is simply all the EA's concatenated together, so its
    // length is the sum of the individual lengths.  The unpacked list
    // consists of a set of entries which in turn consist of a ULONG
    // and a DWORD-aligned EA, so it length is a bit more complex to
    // compute.
    //
    Index = 0;
    PackedListLength = 0;
    UnpackedListLength = 0;
    NeedEaCount = 0;

    while( (Ea = EaSet.GetEa( Index++ )) != NULL ) {

        PackedEaLength = sizeof( EA ) + Ea->NameSize +
                            *(USHORT UNALIGNED *)Ea->ValueSize;

        UnpackedEaLength = sizeof(ULONG) + DwordAlign( PackedEaLength );

        PackedListLength += PackedEaLength;
        UnpackedListLength += UnpackedEaLength;

        if( Ea->Flag & NeedFlag ) {

            NeedEaCount += 1;
        }
    }

    //
    // Allocate a buffer to hold the unpacked list.
    //
    if( (UnpackedEaList = (PBYTE)MALLOC( (unsigned int)UnpackedListLength )) == NULL ) {

        return FALSE;
    }

    memset( UnpackedEaList, 0, (unsigned int)UnpackedListLength );

    //
    // Walk the list again, copying EA's into the packed list buffer.
    //
    Index = 0;
    TargetOffset = 0;

    while( (Ea = EaSet.GetEa( Index++ )) != NULL ) {

        PackedEaLength = sizeof( EA ) + Ea->NameSize +
                            *(USHORT UNALIGNED *)Ea->ValueSize;

        UnpackedEaLength = sizeof(ULONG) + DwordAlign( PackedEaLength );

        memcpy( UnpackedEaList + TargetOffset,
                &UnpackedEaLength,
                sizeof( ULONG ) );

        memcpy( UnpackedEaList + TargetOffset + sizeof( ULONG ),
                Ea,
                (unsigned int)PackedEaLength );

        TargetOffset += UnpackedEaLength;
    }

    // Create the EA Information Attribute--fill in the fields of
    // the EA information structure, put it into a resident attribute
    // of type $EA_INFORMATION, and insert the attribute into the file.
    //
    EaInformation.PackedEaSize      = (unsigned short)PackedListLength;
    EaInformation.NeedEaCount       = (unsigned short)NeedEaCount;
    EaInformation.UnpackedEaSize    = UnpackedListLength;

    if( !EaInformationAttribute.Initialize( _Drive,
                                            _Mft.QueryClusterFactor(),
                                            &EaInformation,
                                            sizeof( EA_INFORMATION ),
                                            $EA_INFORMATION,
                                            NULL,
                                            0 ) ||
        !EaInformationAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        FREE( UnpackedEaList );
        return FALSE;
    }

    //
    // Set up the Ea Data attribute.  Start out with it resident; if
    // it doesn't fit into the FRS, make it nonresident.
    //
    if( !EaDataAttribute.Initialize( _Drive,
                                     _Mft.QueryClusterFactor(),
                                     UnpackedEaList,
                                     UnpackedListLength,
                                     $EA_DATA,
                                     NULL,
                                     0 ) ) {

        DebugPrint( "Cannot initialize resident attribute for EA List.\n" );
        FREE( UnpackedEaList );
        return FALSE;
    }

    if( !EaDataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        // Couldn't insert it in resident form; make it nonresident.

        if( !EaDataAttribute.MakeNonresident( &_VolumeBitmap ) ||
            !EaDataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

            // Can't insert it.

            FREE( UnpackedEaList );
            return FALSE;
        }
    }


    //
    //  All the EAs have been converted
    //
    FREE( UnpackedEaList );
    return TRUE;
}



BOOLEAN
FAT_NTFS::ConvertFile (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   File
    )

/*++

Routine Description:

    Converts a file from FAT to NTFS

Arguments:

    Dirent      -   Supplies the directory entry of the file to convert
    ParentFrs   -   Supplies the FRS of the directory which contains this file
    File        -   Supplies pointer to FRS of file

Return Value:

    BOOLEAN -   TRUE if file successfully converted
                FALSE otherwise

--*/

{
    DSTRING                     FileName;               //  File name

    DebugPtrAssert( Dirent );
    DebugPtrAssert( File );

    Dirent->QueryName( &FileName );

    //
    //  Convert the file data and extended attributes.
    //
    if ( !ConvertFileData( Dirent, File )                ||
         !( !Dirent->QueryEaHandle()                     ||
            ConvertExtendedAttributes( Dirent, File ))
       ) {


        _Message->Set( MSG_CONV_CANNOT_CONVERT_FILE, ERROR_MESSAGE );
        _Message->Display( "%W", &FileName );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;

    }

    //
    //  File converted
    //
    return TRUE;
}




BOOLEAN
FAT_NTFS::ConvertFileData (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    ULONG               FileSize;               //  File size
    ULONG               SectorsPerFatCluster;   //  Sectors per cluster

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize                = Dirent->QueryFileSize();
    SectorsPerFatCluster    = _FatSa->QuerySectorsPerCluster();

    //
    //  If the data is small enough to fit in the FRS, we make it resident and free
    //  the cluster it occupies, otherwise we reuse its allocation and make it
    //  non-resident.
    //
    //  Note that we only make the data resident if it is less than one FAT cluster
    //  long.
    //
    if ( ( Frs->QueryFreeSpace() > (FileSize + SIZE_OF_RESIDENT_HEADER ) )  &&
         ( FileSize <= (SectorsPerFatCluster * _Drive->QuerySectorSize( )) )
       ) {

        return ConvertFileDataResident( Dirent, Frs );

    } else {

        DebugAssert( FileSize > 0 );

        return ConvertFileDataNonResident( Dirent, Frs );
    }
}





BOOLEAN
FAT_NTFS::ConvertFileDataNonResident (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS in nonresident form

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    ULONG               Cluster;                //  File cluster number
    NTFS_ATTRIBUTE      DataAttribute;          //  File's $DATA attribute
    NTFS_EXTENT_LIST    ExtentList;             //  NTFS extent list
    ULONG               Length;                 //  Length of extent
    ULONG               FileSize;               //  File size
    ULONG               ClusterSize;            //  NTFS cluster size
    ULONG               ClustersLeft;           //  NTFS clusters left to convert
    ULONG               SectorsPerCluster;      //  Sectors per FAT cluster
    VCN                 Vcn;                    //  VCN
    LCN                 Lcn;                    //  LCN
    PFAT                Fat;                    //  Pointer to FAT

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize            = Dirent->QueryFileSize();
    SectorsPerCluster   = _FatSa->QuerySectorsPerCluster();

    DebugAssert( FileSize > 0 );

    //
    //  First we generate an extent list mapping the file's data
    //  allocation. We just add all the clusters in the file as
    //  extents of size SectorsPerCluster. Note that we don't
    //  have to do anything special about consecutive clusters
    //  (the Extent List coallesces them for us).
    //
    //  If there are unused sectors in the last cluster, we mark
    //  them in  the ReservedBitmap.
    //
    if ( !ExtentList.Initialize( 0, 0 ) ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    Cluster             = Dirent->QueryStartingCluster();
    ClusterSize         = _ClusterFactor*_Drive->QuerySectorSize();
    ClustersLeft        = (FileSize + ClusterSize - 1)/ClusterSize;
    Fat                 = _FatSa->GetFat();
    Vcn                 = 0;

    //  Add all the FAT clusters to the NTFS extent list. Note that in the last
    //  cluster we only add those sectors that contain file data, and the rest
    //  will become free after the conversion.
    //
    while ( ClustersLeft ) {

        Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;
        Length = min( ClustersLeft, _ClusterRatio );

        //DebugPrintTrace(( "    Extent: Cluster %d Vcn %d Lcn %d Length %d Left %d\n",
        //            Cluster, Vcn.GetLowPart(), Lcn.GetLowPart(), Length,
        //            SectorsLeft ));

        if ( !ExtentList.AddExtent( Vcn, Lcn, Length ) ) {
            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        Vcn += Length;
        ClustersLeft -= Length;

        DebugAssert((ClustersLeft > 0) || Fat->IsEndOfChain(Cluster));

        Cluster = Fat->QueryEntry( Cluster );
    }

    //
    //  Unused sectors in the last cluster are marked in the
    //  ReservedBitmap.
    //
    if ( Length < _ClusterRatio  ) {

        _ReservedBitmap.SetAllocated( Lcn+Length,
                                      _ClusterRatio - Length );
    }

    //
    //  Now put the file data in the $DATA attribute of the file
    //
    if ( !DataAttribute.Initialize( _Drive,
                                    _ClusterFactor,
                                    &ExtentList,
                                    FileSize,
                                    FileSize,
                                    $DATA ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !DataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        _Message->Set( MSG_CONV_CANNOT_CONVERT_DATA, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  File data converted
    //
    return TRUE;
}





BOOLEAN
FAT_NTFS::ConvertFileDataResident (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS in resident form

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    HMEM                Hmem;                   //  Memory
    CLUSTER_CHAIN       ClusterChain;           //  File cluster
    NTFS_ATTRIBUTE      DataAttribute;          //  File's $DATA attribute
    ULONG               FileSize;               //  File size

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize = Dirent->QueryFileSize();

    if ( FileSize > 0 ) {
        //
        //  Read the file data.
        //
        if ( !Hmem.Initialize() ||
             !ClusterChain.Initialize( &Hmem,
                                       _Drive,
                                       _FatSa,
                                       _FatSa->GetFat(),
                                       Dirent->QueryStartingCluster(), 1 ) ) {

            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        if ( !ClusterChain.Read() ) {

            //
            //  We cannot read the file data, possibly because there is a
            //  bad sector on the volume. We will try make the file data
            //  non-resident (that way we don't need to read the data, since
            //  all we do is generate the allocation info). Doing things
            //  this way does not change the state of the drive (i.e. it was
            //  bad before conversion, it is bad after the conversion).
            //
            return ConvertFileDataNonResident( Dirent, Frs );
        }
    }

    //
    //  Now put the file data in the $DATA attribute of the file
    //
    if ( (FileSize > 0 && !ClusterChain.GetBuf()) ||
         !DataAttribute.Initialize( _Drive,
                                    _ClusterFactor,
                                    (FileSize > 0) ? ClusterChain.GetBuf() : NULL,
                                    FileSize,
                                    $DATA ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !DataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        _Message->Set( MSG_CONV_CANNOT_CONVERT_DATA, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  We can now mark the cluster with the file data in the
    //  ReservedBitmap, so it will be freed after the conversion.
    //
    //  Note that we cannot mark it free in the VolumeBitmap because
    //  the conversion process must NOT overwrite it (or data may
    //  be lost if the conversion fails!).
    //
    if ( FileSize > 0 ) {
        ReserveCluster( Dirent->QueryStartingCluster() );
    }

    //
    //  File data converted
    //
    return TRUE;
}





BOOLEAN
FAT_NTFS::ConvertFileSystem(
    )

/*++

Routine Description:

    Converts the existing FAT file system to NTFS. This is done by
    traversing the file system tree and converting the FAT structures
    (i.e. directories, files and EAs).

    The space occupied by FAT-specific files (e.g. the EA file) is marked
    in the ReservedBitmap so it will be freed up when the conversion is
    done.

    Note that Operating-System-specific files (e.g. IO.SYS, MSDOS.SYS) are
    NOT removed by the conversion process. This is a File System conversion,
    not an Operating System conversion (If this file system conversion is
    being invoked by an operating system conversion program, then that
    program is responsible for removing any system files).

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if file system successfully converted
                FALSE otherwise

--*/

{
    PFATDIR                     RootDir;        //  FAT root directory
    FAT_DIRENT                  EAFileDirEnt;   //  Entry for EA file
    DSTRING                     EAFile;         //  Name of EA file
    ULONG                       i;              //  Cluster index
    PFAT                        Fat;            //  Pointer to FAT
    UCHAR    FatType;

    _Message->Set( MSG_CONV_CONVERTING_FS );
    _Message->Display();

    //
    //  Get the root directory
    //
    RootDir = (PFATDIR)_FatSa->GetRootDir();

    FatType = FAT_TYPE_EAS_OKAY;

    if ( !RootDir ) {
        RootDir = (PFATDIR)_FatSa->GetFileDir();
        FatType = FAT_TYPE_FAT32;
    }

    DebugPtrAssert( RootDir );

    //
    //  Locate the EA file. If it exists then remember its starting cluster
    //  number and initialize the EA header.
    //
    //  The starting cluster of the EA file is remembered because it is used
    //  later on for identifying the EA file while traversing the root directory.
    //
    EAFile.Initialize( "EA DATA. SF" );

    if ( (FAT_TYPE_FAT32 != FatType) && EAFileDirEnt.Initialize( RootDir->SearchForDirEntry( &EAFile )) )
    {
        _EAFileFirstCluster = EAFileDirEnt.QueryStartingCluster();

        Fat = _FatSa->GetFat();

        if ( !_EAMemory.Initialize()                        ||
             !_EAHeader.Initialize( &_EAMemory,
                                    _Drive,
                                    _FatSa,
                                    Fat,
                                    _EAFileFirstCluster )   ||

             !_EAHeader.Read()
           ) {

            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        //
        //  Mark all the EA file sectors in the ReservedBitmap, so the
        //  space will be freed up when the conversion is done.
        //
        i = _EAFileFirstCluster;

#if DBG
        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            DebugPrintTrace(( "EA file at cluster %X\n", _EAFileFirstCluster ));
        }
#endif

        while (TRUE) {

            ReserveCluster( i );

            if ( Fat->IsEndOfChain( i ) ) {
                break;
            }

            i = Fat->QueryEntry( i );
        }

    } else {

#if DBG
        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            DebugPrintTrace(( "The volume contains no EA file\n" ));
        }
#endif

        _EAFileFirstCluster = 0;

    }


    //
    //  Convert the volume by recursively converting the root directory
    //
    return ConvertRoot( RootDir );
}



BOOLEAN
FAT_NTFS::CreateBitmaps(
    )

/*++

Routine Description:

    Creates the NTFS bitmaps for the volume and the bad block stack.

    Two bitmaps are created:

        _VolumeBitmap   - Is the bitmap for the volume. Represents the volume at
                          seemed by NTFS.

        _ReservedBitmap - Contains those NTFS clusters that are marked as "in use"
                          in the _VolumeBitmap during the conversion, but that must
                          be marked as "free" after the conversion. This is
                          required so that the conversion don't try to allocate
                          those clusters. These "reserved" clusters include all
                          the FAT structures that will be thrown away after the
                          conversion.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if bitmaps and bad block stack created.
                FALSE otherwise

--*/

{
    PFAT    Fat;                //  The FAT
    ULONG   Cluster;            //  Used to traverse FAT
    LCN     Lcn;                //  Same as Cluster, but in sectors
    ULONG   ClusterCount;       //  Number of clusters in volume
    LCN     DataAreaStart;      //  Start of data area;
    ULONG   SectorsPerFatCluster;   //  Sector counter
    BIG_INT NumberOfClusters;

    //
    //  Initialize bitmaps
    //

    DebugAssert(_FatSa->IsVolumeDataAligned() || (_ClusterFactor == 1));

    NumberOfClusters = (_Drive->QuerySectors() - 1)/_ClusterFactor;
    DebugAssert(NumberOfClusters.GetHighPart() == 0);

    if (!_VolumeBitmap.Initialize(NumberOfClusters, FALSE, _Drive, _ClusterFactor) ||
        !_ReservedBitmap.Initialize(NumberOfClusters, FALSE, NULL, 0)) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  The boot area must be free (it will become reserved when creating
    //  the elementary NTFS structures).
    //

    //
    //  The FAT ( From the end of the boot area up to the beginning of
    //  the data area) is reserved but will be freed at the end of the
    //  conversion.
    //
    DataAreaStart = _FatSa->QueryStartDataLbn();

    DebugAssert(!_FatSa->IsVolumeDataAligned() || (DataAreaStart % _ClusterFactor == 0));

    DataAreaStart = DataAreaStart / _ClusterFactor;

    _VolumeBitmap.SetAllocated( CLUSTERS_IN_BOOT,
                                DataAreaStart - CLUSTERS_IN_BOOT );

    _ReservedBitmap.SetAllocated( CLUSTERS_IN_BOOT,
                                  DataAreaStart - CLUSTERS_IN_BOOT );

    //
    //  Allocate the rest of the bitmap according to the FAT
    //
    Lcn             = DataAreaStart;
    Cluster         = FirstDiskCluster;
    ClusterCount    = _FatSa->QueryClusterCount() - (ULONG)FirstDiskCluster;
    Fat             = _FatSa->GetFat();
    SectorsPerFatCluster = _ClusterRatio * _ClusterFactor;

    while ( ClusterCount-- ) {

        //
        //  If the cluster is not free then allocate it if its OK, or
        //  push it onto the bad stack if it is bad.
        //
        if ( Fat->IsClusterFree( Cluster ) ) {

            Lcn += _ClusterRatio;

        } else if ( Fat->IsClusterBad( Cluster ) ) {

            _BadLcn.Add( Lcn*_ClusterFactor, SectorsPerFatCluster );
            Lcn += _ClusterRatio;

        } else {

            _VolumeBitmap.SetAllocated( Lcn, _ClusterRatio );
            Lcn += _ClusterRatio;
        }

        Cluster++;
    }

    //
    //  Note that CLUSTERS_IN_BOOT are not really free (will be
    //  allocated later on).
    //
    _FreeSectorsBefore = ((BIG_INT)(_VolumeBitmap.QueryFreeClusters() - CLUSTERS_IN_BOOT))*
                         _Drive->QuerySectorSize();

    return TRUE;
}




BOOLEAN
FAT_NTFS::CreateElementary(
    )

/*++

Routine Description:

    Creates the elementary NTFS data structures.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if elementary NTFS data structures created.
                FALSE otherwise

--*/

{
    NTFS_UPCASE_FILE    UpcaseFile;
    NTFS_ATTRIBUTE      UpcaseAttribute;
    NTFS_LOG_FILE       LogFile;
    DSTRING             VolumeLabel;    //  Volume label

    BOOLEAN             Error;

    DebugAssert( _VolumeBitmap.IsFree( 0, CLUSTERS_IN_BOOT ) );

    //
    //  Get the volume label and create the elementary NTFS structures.
    //  Pass in zero for the initial log file size to indicate that
    //  CreateElementaryStructures should decide how big to make it.
    //
    if ( !_FatSa->QueryLabel( &VolumeLabel )            ||
         !_NtfsSa.CreateElementaryStructures( &_VolumeBitmap,
                                              _ClusterFactor,
                                              _FrsSize,
                                              SMALL_INDEX_BUFFER_SIZE,
                                              0,
                                              &_BadLcn,
                                              TRUE,
                                              TRUE,
                                              _Message,
                                              _FatSa->GetBpb(),
                                              &VolumeLabel ) ) {


        _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;

        return FALSE;
    }

    //
    //  Now that we have the elementary structures, obtain the MFT, which is
    //  used later on during the conversion.  Since we don't have an upcase
    //  table yet, pass in NULL for that parameter.
    //
    if ( !_Mft.Initialize( _Drive,
                           _NtfsSa.QueryMftStartingLcn(),
                           _ClusterFactor,
                           _FrsSize,
                           _NtfsSa.QueryVolumeSectors(),
                           &_VolumeBitmap,
                           NULL )             ||
         !_Mft.Read() ) {

        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;

        return FALSE;
    }

    // Tell the volume bitmap about the new Mft so it can add any
    // bad clusters it finds to the bad cluster file.

    _VolumeBitmap.SetMftPointer(_Mft.GetMasterFileTable());


    // Get the upcase table.
    //
    if( !UpcaseFile.Initialize( _Mft.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &Error, $DATA ) ||
        !_UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        DebugPrint( "Can't get the upcase table.\n" );
        return FALSE;
    }

    _Mft.SetUpcaseTable( &_UpcaseTable );
    _Mft.GetMasterFileTable()->SetUpcaseTable( &_UpcaseTable );

    //
    //  If we know how many files there are on the volume, extend the
    //  MFT so it is (sort of) contiguous.
    //
    if ( (_NumberOfFiles + _NumberOfDirectories) > 0 ) {

        if ( !_Mft.Extend( _NumberOfFiles + _NumberOfDirectories + 20 ) ) {

            DebugPrintTrace(( "Cannot extend MFT by %d segments\n", _NumberOfFiles + _NumberOfDirectories  ));

            _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }
    }

    //  Flush the MFT now, so that it gets first claim to the FRS's
    //  at the beginning of the MFT.
    //
    if( !_Mft.Flush() ) {

        DebugPrintTrace(( "CONVERT: Cannot flush the MFT\n"  ));

        _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    // Sanity check: make sure that the log file doesn't have
    // an attribute list.  The file system will die horribly
    // if Convert creates a log file with external attributes.
    //
    if( !LogFile.Initialize( _Mft.GetMasterFileTable() ) ||
        !LogFile.Read() ||
        LogFile.IsAttributePresent( $ATTRIBUTE_LIST ) ) {

        _Message->Set( MSG_CONV_VOLUME_TOO_FRAGMENTED );
        _Message->Display( "" );
        return FALSE;
    }


    return TRUE;
}




BOOLEAN
FAT_NTFS::FreeReservedSectors (
    )

/*++

Routine Description:

    Frees up those sectors marked as "in use" in the _ReservedBitmap.
    The _VolumeBitmap is updated and written to disk.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if sectors freed and _VolumeBitmap written.
                FALSE otherwise.

--*/

{

    NTFS_BITMAP_FILE        BitmapFile;     //  NTFS bitmap file
    NTFS_ATTRIBUTE          Attribute;      //  $DATA attribute of bitmap file
    LCN                     Lcn;            //  LCN
    BOOLEAN                 Error;
    PFILEDIR                DirF32;         // Pointer to FAT 32 Root dir
    BIG_INT                 NumberOfLcn;

    //
    //  Free the "reserved" clusters
    //
    NumberOfLcn = _Drive->QuerySectors()/_ClusterFactor;
    for ( Lcn = 0; Lcn < NumberOfLcn; Lcn += 1 ) {
        if ( !_ReservedBitmap.IsFree( Lcn, 1 ) ) {
            _VolumeBitmap.SetFree( Lcn, 1 );
            _ReservedBitmap.SetFree( Lcn, 1 );
        }
    }

    DirF32 = _FatSa->GetFileDir();
    if (DirF32) { // it's a fat32 drive..
        ULONG       clus;
        PFAT        Fat;                //  The FAT
        ULONG       SectorsPerCluster;  //  Sectors per cluster
        LCN         DataAreaStart;      //  Start of data area;
        LCN         Lcn;                //  Logical cluster number

        SectorsPerCluster = _FatSa->QuerySectorsPerCluster();
        Fat           = _FatSa->GetFat();
        DataAreaStart = _FatSa->QueryStartDataLbn();

        //
        // Mark the first 32 reserved sectors for later cleanup
        //
        _ReservedBitmap.SetAllocated( CLUSTERS_IN_BOOT, (32-1)/_ClusterFactor+1-CLUSTERS_IN_BOOT );

        //
        // Mark the root chain as "UN-used" in the NTFS bitmap.
        // Mark those root directory clusters in the reserved bitmap for later cleanup
        //
        for (clus = DirF32->QueryStartingCluster(); !Fat->IsEndOfChain(clus); clus = Fat->QueryEntry(clus)) {
            {   // Free sectors under this Root Dir Cluster
                Lcn = (DataAreaStart + ((clus-FirstDiskCluster)*SectorsPerCluster))/_ClusterFactor;
                _VolumeBitmap.SetFree( Lcn, _ClusterRatio );
                _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );
            }
        }
        {   // Free sectors under this Root Dir Cluster
            Lcn = (DataAreaStart + ((clus-FirstDiskCluster)*SectorsPerCluster))/_ClusterFactor;
            _VolumeBitmap.SetFree( Lcn, _ClusterRatio );
            _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );
        }
    } else {

        ULONG root_offset = _FatSa->QueryReservedSectors()+_FatSa->QueryFats()*_FatSa->QuerySectorsPerFat();
        ULONG root_size = (_FatSa->QueryRootEntries()*BytesPerDirent - 1)/_Drive->QuerySectorSize() + 1;

        DebugAssert( root_offset % _ClusterFactor == 0 );
        DebugAssert( root_size % _ClusterFactor == 0 );

        _ReservedBitmap.SetAllocated( root_offset/_ClusterFactor, root_size/_ClusterFactor );
    }

    //
    //  Update the Bitmap file.
    //
    if ( !BitmapFile.Initialize( _Mft.GetMasterFileTable() )  ||
         !BitmapFile.Read()                                   ||
         !BitmapFile.QueryAttribute( &Attribute, &Error, $DATA )
         ) {

        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Update the Bitmap file data attribute (i.e. the volume bitmap)
    //
    if ( !_VolumeBitmap.Write( &Attribute, &_VolumeBitmap ) ) {
        _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    _FreeSectorsAfter = ((BIG_INT)_VolumeBitmap.QueryFreeClusters())*_ClusterFactor;

#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "Free sectors before conversion: %d\n", _FreeSectorsBefore.GetLowPart() ));
        DebugPrintTrace(( "Free sectors after conversion:  %d\n", _FreeSectorsAfter.GetLowPart() ));
    }
#endif

    return TRUE;
}





BOOLEAN
FAT_NTFS::QueryNeededHoles (
    OUT  PINTSTACK   Stack
    )

/*++

Routine Description:

    Determines what holes are required and pushes the hole
    information in the supplied stack.

Arguments:

    Stack   -   Supplies the stack where the hole information is
                passed

Return Value:

    BOOLEAN -   TRUE if all hole information is in stack
                FALSE otherwise

--*/

{
    BIG_INT     HoleStart;              //  Starting sector of hole
    BIG_INT     HoleSize;               //  Size of the hole
    BIG_INT     BootSize;               //  Size of boot code
    BIG_INT     MftSize;                //  Size of MFT
    BIG_INT     MftReflectionSize;      //  Size of MFT reflection
    ULONG       sectorsize;
    USHORT      i;

    //
    //  Initialize the hole stack
    //

    if ( !Stack->Initialize() ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  The only NTFS structure that needs a fixed location is
    //  the BOOT backup.  Push the size and location of this sector
    //  onto the stack.
    //

    if ( !Stack->Push( 1 )   ||
     !Stack->Push( _FatSa->QueryVirtualSectors() - 1 ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  We also want to create a hole big enough for the MFT and
    //  the MFT reflection. These don't need to be in a particular
    //  location, but they have to be contiguous (i.e. occupy a
    //  single "hole").
    //
    sectorsize = _Drive->QuerySectorSize();

    MftSize = (_FrsSize * FIRST_USER_FILE_NUMBER + (sectorsize - 1)) / sectorsize;

    MftReflectionSize = (_FrsSize * REFLECTED_MFT_SEGMENTS + (sectorsize - 1))
                / sectorsize;

    HoleSize = MftSize + MftReflectionSize;
    HoleStart = _FatSa->QueryVirtualSectors() - 1 - HoleSize;

#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "Hole required: Sector %X, size %X\n",
                     HoleStart.GetLowPart(), HoleSize.GetLowPart() ));
    }
#endif

    //
    //  Make sure that the hole lies entirely in the FAT data area. Otherwise
    //  we won't be able to relocate the clusters in the hole.
    //
    if ( HoleStart < _FatSa->QueryStartDataLbn() ) {
        _Message->Set( MSG_CONV_CANNOT_CONVERT_VOLUME, ERROR_MESSAGE );
        _Message->Display( "%s%s", "NTFS", "FAT" );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Push the hole data in the stack. Size goes first!
    //
    if ( !Stack->Push( HoleSize  )   ||
         !Stack->Push( HoleStart ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    return TRUE;
}




VOID
FAT_NTFS::QuerySectorsNeededForConversion (
    IN  PCENSUS_REPORT  Census,
    OUT PBIG_INT        SectorsNeeded
    )
/*++

Routine Description:

    Determines how many sectors are required for the conversion, given
    the volume census.

Arguments:

    Census          -   Supplies the volume census
    SectorsNeeded   -   Supplies pointer to number of sectors needed

Return Value:

    None

--*/

{
    BIG_INT     SectorsRequired;
    BIG_INT     BytesInIndices;

    ULONG   szTemp;
    ULONG       NtfsClusterSize;    //  Size of an NTFS cluster
    ULONG       sectorsize;

    CONST       AverageBytesPerIndexEntry = 128;


#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "\n" ));
        DebugPrintTrace(( "---- Volume Census Data ----\n" ));
        DebugPrintTrace(( "Number of dirs:      %d\n", Census->DirEntriesCount ));
        DebugPrintTrace(( "Number of files:     %d\n", Census->FileEntriesCount ));
        DebugPrintTrace(( "Clusters in dirs:    %d\n", Census->DirClusters ));
        DebugPrintTrace(( "Clusters in files:   %d\n", Census->FileClusters ));
        DebugPrintTrace(( "Clusters in EA file: %d\n", Census->EaClusters ));
        DebugPrintTrace(( "\n\n" ));
    }
#endif


    NtfsClusterSize      = _Drive->QuerySectorSize() * _ClusterFactor;
    _NumberOfFiles       = Census->FileEntriesCount;
    _NumberOfDirectories = Census->DirEntriesCount;

    SectorsRequired =
        NTFS_SA::QuerySectorsInElementaryStructures( _Drive,
                                                     _ClusterFactor,
                                                     _FrsSize,
                                                     _ClustersPerIndexBuffer,
                                                     0 );

    //
    // Ensure that the above call has not failed
    //
    DebugAssert(SectorsRequired != 0);


    //
    //  We will need _ClustersPerFrs clusters for each file or
    //  directory, plus enough index blocks to hold the required
    //  index entries.  (Multiply the size of indices by two to
    //  reflect the fact that the average index block will be
    //  half full.)
    //

    sectorsize = _Drive->QuerySectorSize();

    SectorsRequired += ( _NumberOfFiles + _NumberOfDirectories ) *
                            ((_FrsSize + (sectorsize - 1))/sectorsize);

    BytesInIndices = ( _NumberOfFiles + _NumberOfDirectories ) *
                         AverageBytesPerIndexEntry * 2;

    SectorsRequired += BytesInIndices / _Drive->QuerySectorSize();

    //
    //  Extended attributes
    //
    if(Census->EaClusters) {

        //
        // With EAs each file will require one extra header for the EA itself
        //
        SectorsRequired += _NumberOfFiles *
                           ((_FrsSize + (sectorsize - 1))/sectorsize);

        //
        // Compute the "per file average EA size", round it up to
        // the sector size and multiply it times the file count to get
        // the projected EA size on NTFS.
        //
        szTemp = Census->EaClusters * _FatSa->QuerySectorsPerCluster();
        szTemp = (szTemp + (_NumberOfFiles - 1)) / _NumberOfFiles; // sectors per file in EAs
        if(szTemp == 0) {
            szTemp = 1;
        }
        SectorsRequired += szTemp * _NumberOfFiles;
    }

    //
    //  In case of unreported bad sectors, we reserve 0.1% of the disk
    //
    SectorsRequired += _Drive->QuerySectors() / 1000;

    // And that's that.

    *SectorsNeeded = SectorsRequired;

}





BOOLEAN
FAT_NTFS::ReserveCluster (
    IN ULONG     Cluster
    )
/*++

Routine Description:

    "Reserves" all the sectors in the given clusters. This is done
    by marking the sectors in the ReservedBitmap.

Arguments:

    Cluster -   Supplies cluster whose sectors are to be reserved

Return Value:

    BOOLEAN -   TRUE if all sectors in the cluster have been reserved
                FALSE otherwise

--*/

{
    LCN         Lcn;
    BIG_INT     Clusters;

    Clusters = ((ULONG)_FatSa->QuerySectorsPerCluster()) / _ClusterFactor;

    if ( Cluster > 0 ) {

        Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;

        _ReservedBitmap.SetAllocated( Lcn, Clusters );

        return TRUE;
    }

    return FALSE;
}



NONVIRTUAL
BOOLEAN
FAT_NTFS::CheckGeometryMatch(
    )
/*++

Routine Description:

    This method checks that the geometry recorded in the
    Bios Parameter Block agrees with the geometry reported
    by the driver.

Arguments:

    None.

Return Value:

    TRUE if the geometry in the BPB matches that reported
    by the driver; false if not.  Note that the only field
    which is checked is BytesPerSector.

--*/
{
    USHORT SectorSize, SectorsPerTrack, Heads;
    ULONG HiddenSectors;

    _FatSa->QueryGeometry( &SectorSize,
                           &SectorsPerTrack,
                           &Heads,
                           &HiddenSectors );

    if( SectorSize      != _Drive->QuerySectorSize() ) {

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
FAT_NTFS::WriteBoot (
    )

/*++

Routine Description:

    Updates the boot sector and writes any other information (e.g.
    partition data) so that the volume will be recognized as an NTFS
    volume.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if boot sector updated
                FALSE otherwise

--*/

{
    FSTRING BootLogFileName;
    PBYTE   ZeroBuf;
    ULONG   Lcn;

    BOOLEAN Done;

    Done =  (BOOLEAN)(_Mft.Flush() &&
                      _NtfsSa.Write( _Message ) &&
                      _NtfsSa.WriteRemainingBootCode());

    if (Done) {
        //
        // Now that it passses the point of no return, we clean up
        // any remaining fat32 reserved boot sectors and/or fat root directory.
        //

        ZeroBuf = (PBYTE)MALLOC( _Drive->QuerySectorSize()*_ClusterFactor );

        if (ZeroBuf == NULL) {
            _Message->Set( MSG_CONV_NO_MEMORY );
            _Message->Display();
            return FALSE;
        }

        memset( ZeroBuf, 0, _Drive->QuerySectorSize()*_ClusterFactor );

        for ( Lcn = 0; Lcn < _ReservedBitmap.QuerySize(); Lcn +=1 ) {

            if ( !_ReservedBitmap.IsFree( Lcn, 1 ) && _VolumeBitmap.IsFree( Lcn, 1 ) ) {
                if (!_Drive->Write( Lcn*_ClusterFactor, 1, ZeroBuf )) {
                    DebugPrintTrace(("CUFAT: Failed to wipe clean cluster %x\n", Lcn));
                }
            }
        }

        FREE(ZeroBuf);
    }

#if defined ( _AUTOCONV_ )

    if ( Done ) {

        //
        //  The volume is no longer FAT. We have to reboot so that the
        //  system recognizes it.  Note that before we reboot, we
        //  must flush the drive's cache.
        //
        BootLogFileName.Initialize( L"bootex.log" );

        if( _Message->IsLoggingEnabled() &&
            !NTFS_SA::DumpMessagesToFile( &BootLogFileName,
                                          &_Mft,
                                          _Message ) ) {

            DebugPrintTrace(( "CONVERT: Error writing messages to BOOTEX.LOG\n" ));
        }

        _Drive->FlushCache();

        _Drive->InvalidateVolume();

        //
        // Unlock the volume and close our handle, to let the filesystem
        // notice that things have changed.
        //

        DELETE(_Drive);

        if ( _Flags & CONVERT_PAUSE_FLAG ) {

            _Message->Set( MSG_CONV_PAUSE_BEFORE_REBOOT );
            _Message->Display();

            _Message->WaitForUserSignal();
        } else {
            _Message->Set( MSG_CONV_CONVERSION_COMPLETE );
            _Message->Display();
        }

        //
        // If we've paused for oem setup, we pass PowerOff = TRUE to
        // Reboot.
        //

        IFS_SYSTEM::Reboot( (_Flags & CONVERT_PAUSE_FLAG) ? TRUE : FALSE );
    }
#endif

    return Done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskcomp\diskcomp.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        diskcomp.cxx

Abstract:

        Utility to compare two disks

Author:

        Norbert P. Kusters (norbertk) 10-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "ulibcl.hxx"


INT
DiskComp(
    IN      PCWSTRING   SrcNtDriveName,
    IN      PCWSTRING   DstNtDriveName,
    IN      PCWSTRING   SrcDosDriveName,
    IN      PCWSTRING   DstDosDriveName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine copies on floppy diskette to another floppy diskette.

Arguments:

    SrcNtDriveName  - Supplies the NT style drive name for the source.
    DstNtDriveName  - Supplies the NT style drive name for the destination.
    SrcDosDriveName - Supplies the DOS style drive name for the source.
    DstDosDriveName - Supplies the DOS style drive name for the destination.
    Message         - Supplies an outlet for messages.

Return Value:

    0   - The disks are the same.
    1   - The disks are different.
    3   - A hard error occurred.
    4   - An initialization error occurred.

--*/
{
    LOG_IO_DP_DRIVE src_drive;
    LOG_IO_DP_DRIVE dst_drive;
    HMEM            src_hmem;
    HMEM            dst_hmem;
    CONT_MEM        src_cmem;
    PVOID           mem_ptr;
    SECRUN          src_secrun;
    SECRUN          dst_secrun;
    SECTORCOUNT     sec_per_track;
    ULONG           total_tracks;
    ULONG           grab;       // number of tracks to grab at once.
    ULONG           sector_size;
    BOOLEAN         one_drive;
    ULONG           src_top;    // src track pointer -- next read
    ULONG           dst_top;    // dst track pointer -- next write
    PCHAR           dst_pchar;
    PCHAR           src_pchar;
    ULONG           i;
    BOOLEAN         the_same;
    ULONG           heads;
    DSTRING         fsname;
#if defined(FE_SB) && defined(_X86_)
    MEDIA_TYPE      AltMediaType;
#endif

    one_drive = (*SrcDosDriveName == *DstDosDriveName);

    Message->Set(MSG_DCOMP_INSERT_FIRST);
    Message->Display("%W", SrcDosDriveName);

    if (!one_drive) {
        Message->Set(MSG_DCOMP_INSERT_SECOND);
        Message->Display("%W", DstDosDriveName);
    }

    Message->Set(MSG_PRESS_ENTER_WHEN_READY);
    Message->Display();
    Message->WaitForUserSignal();

    if (!src_drive.Initialize(SrcNtDriveName)) {

        // Verify that we can access the source drive:

        if (src_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            return 4;
        }

        Message->Set(MSG_DCOMP_FIRST_DISK_BAD);
        Message->Display();
        return 3;
    }

    if (!src_drive.IsFloppy()) {
        Message->Set(MSG_DCOPY_INVALID_DRIVE);
        Message->Display();
        return 4;
    }

    if (src_drive.QueryMediaType() == Unknown) {
        Message->Set(MSG_DCOMP_FIRST_DISK_BAD);
        Message->Display();
        return 3;
    }

    Message->Set(MSG_DCOMP_COMPARING);
    Message->Display("%d%d%d", src_drive.QueryCylinders().GetLowPart(),
                               src_drive.QuerySectorsPerTrack(),
                               src_drive.QueryHeads());

    sec_per_track = src_drive.QuerySectorsPerTrack();
    sector_size = src_drive.QuerySectorSize();
    total_tracks = src_drive.QueryTracks().GetLowPart();
    heads = src_drive.QueryHeads();

    DebugAssert(src_drive.QuerySectors().GetHighPart() == 0);

    src_top = 0;

    if (!dst_hmem.Initialize()) {
        return 4;
    }

    the_same = TRUE;

    for (dst_top = 0; dst_top < total_tracks; dst_top++) {

        if (src_top == dst_top) {

            if (src_top && one_drive) {
                Message->Set(MSG_DCOMP_INSERT_FIRST);
                Message->Display("%W", SrcDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();
            }


            // Allocate memory for read.

            for (grab = total_tracks - src_top;
                 !src_hmem.Initialize() ||
                 !(mem_ptr = src_hmem.Acquire(grab*sector_size*sec_per_track,
                                              src_drive.QueryAlignmentMask()));
                 grab /= 2) {

                if (grab < 2) {
                    Message->Set(MSG_CHK_NO_MEMORY);
                    Message->Display();
                    return 4;
                }
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                return 4;
            }


            // Read the source, track by track.

            for (i = 0; i < grab; i++) {
                if (!src_secrun.Initialize(&src_cmem, &src_drive,
                                           src_top*sec_per_track,
                                           sec_per_track)) {
                    return 4;
                }

                if (!src_secrun.Read()) {

                    if (src_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        src_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        return 3;
                    }

                    Message->Set(MSG_DCOPY_READ_ERROR);
                    Message->Display("%W%d%d", SrcDosDriveName,
                                               src_top%heads, src_top/heads);
                    the_same = FALSE;
                }
                src_top++;
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                return 4;
            }

            if (one_drive) {
                Message->Set(MSG_DCOMP_INSERT_SECOND);
                Message->Display("%W", DstDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();
            }

                        if (!dst_top) {

                if (!dst_drive.Initialize(DstNtDriveName)) {

                    // verify that we can access the destination drive:

                    if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {

                        Message->Set(MSG_DASD_ACCESS_DENIED);
                        Message->Display( "" );
                        return 4;
                    }

                    Message->Set(MSG_DCOMP_SECOND_DISK_BAD);
                    Message->Display();
                    return 3;
                }

                if (dst_drive.QueryMediaType() != src_drive.QueryMediaType()) {
#if defined(FE_SB) && defined(_X86_)
                    switch (src_drive.QueryMediaType()) {
                        case F5_1Pt23_1024:
                            AltMediaType = F3_1Pt23_1024;
                            break;
                        case F3_1Pt23_1024:
                            AltMediaType = F5_1Pt23_1024;
                            break;
                        case F5_1Pt2_512:
                            AltMediaType = F3_1Pt2_512;
                            break;
                        case F3_1Pt2_512:
                            AltMediaType = F5_1Pt2_512;
                            break;
                        case F3_720_512:
                            AltMediaType = F5_720_512;
                            break;
                        case F5_720_512:
                            AltMediaType = F3_720_512;
                            break;
                        case F5_640_512:
                            AltMediaType = F3_640_512;
                            break;
                        case F3_640_512:
                            AltMediaType = F5_640_512;
                            break;
                        default:
                            AltMediaType = src_drive.QueryMediaType();
                            break;
                    }

                    // Second try with AltMediaType
                    if (dst_drive.QueryMediaType() != AltMediaType) {
#endif
                        Message->Set(MSG_DCOMP_NOT_COMPATIBLE);
                        Message->Display();
                        return 4;
#if defined(FE_SB) && defined(_X86_)
                    }
#endif
                }
            }
        }

        if (!dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                   dst_top*sec_per_track, sec_per_track)) {
            return 4;
        }

        if (dst_secrun.Read()) {
            src_pchar = (PCHAR) src_cmem.Acquire(sector_size*sec_per_track);
            dst_pchar = (PCHAR) dst_secrun.GetBuf();

            if (!dst_top) {
                if ((src_pchar[0x26] == 0x28 || src_pchar[0x26] == 0x29) &&
                    (dst_pchar[0x26] == 0x28 || dst_pchar[0x26] == 0x29)) {
                    memcpy(src_pchar + 0x27, dst_pchar + 0x27, sizeof(ULONG));
                }
            }

            if (memcmp(src_pchar, dst_pchar, (UINT) (sector_size*sec_per_track))) {
                Message->Set(MSG_DCOMP_COMPARE_ERROR);
                Message->Display("%d%d", dst_top%heads, dst_top/heads);
                the_same = FALSE;
            }

        } else {

            if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                return 3;
            }

            Message->Set(MSG_DCOPY_READ_ERROR);
            Message->Display("%W%d%d", DstDosDriveName,
                                       dst_top%heads, dst_top/heads);
            the_same = FALSE;
        }
    }

    if (the_same) {
        Message->Set(MSG_DCOMP_OK);
        Message->Display();
    }

    return the_same ? 0 : 1;
}


INT __cdecl
main(
    )
/*++

Routine Description:

    Main program for DISKCOMP.

Arguments:

    None.

Return Value:

    0   - The disks are the same.
    1   - The disks are different.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    STRING_ARGUMENT     drive_arg1;
    STRING_ARGUMENT     drive_arg2;
        FLAG_ARGUMENT           slashv;
        FLAG_ARGUMENT           helparg;
    DSTRING             dossource;
    DSTRING             dosdest;
    DSTRING             ntsource;
    DSTRING             ntdest;
    PWSTRING            pwstring;
    DSTRING             colon;
    INT                 result;


    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    message = &msg;

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 4;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 4;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 4;
    }

    if (!progname.Initialize("*") ||
        !drive_arg1.Initialize("*:") ||
        !drive_arg2.Initialize("*:") ||
                !helparg.Initialize("/?")) {
        return 4;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&drive_arg1) ||
        !arg_array.Put(&drive_arg2) ||
                !arg_array.Put(&helparg)) {
        return 4;
        }

        if (!arglex.DoParsing(&arg_array)) {
                message->Set(MSG_INVALID_PARAMETER);
                message->Display("%W", pwstring = arglex.QueryInvalidArgument());
                DELETE(pwstring);
                return 4;
        }

        if (helparg.QueryFlag()) {
        message->Set(MSG_DCOMP_INFO);
        message->Display();
        message->Set(MSG_DCOMP_USAGE);
        message->Display();
        return 0;
        }

    if (!colon.Initialize(":")) {
        return 4;
    }

    if (drive_arg1.IsValueSet()) {
        if (!dossource.Initialize(drive_arg1.GetString()) ||
            !dossource.Strcat(&colon) ||
            !dossource.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dossource)) {
            return 4;
        }
    }

    if (drive_arg2.IsValueSet()) {
        if (!dosdest.Initialize(drive_arg2.GetString()) ||
            !dosdest.Strcat(&colon) ||
            !dosdest.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dosdest)) {
            return 4;
        }
    }

    if (SYSTEM::QueryDriveType(&dossource) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (SYSTEM::QueryDriveType(&dosdest) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dossource, &ntsource)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdest, &ntdest)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    for (;;) {

        result = DiskComp(&ntsource, &ntdest, &dossource, &dosdest, message);

        if (result > 1) {
            message->Set(MSG_DCOMP_ENDED);
            message->Display();
        }

        message->Set(MSG_DCOMP_ANOTHER);
        message->Display();

        if (!message->IsYesResponse(FALSE)) {
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskcopy\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=diskcopy
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

SOURCES=..\diskcopy.cxx ..\diskcopy.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\attrio.cxx ===
#include "ulib.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "attrio.hxx"
#include "mftfile.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG FileNumber = 0;
STATIC ULONG AttributeType = 0;
STATIC TCHAR Name[20];

BOOLEAN
ATTR_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    NTFS_SA ntfssa;
    MESSAGE msg;
    DSTRING attr_name;
    PCWSTRING pcAttrName;
    BOOLEAN error;
    NTFS_MFT_FILE mft;
    NTFS_UPCASE_FILE upcase_file;
    NTFS_ATTRIBUTE upcase_attribute;
    PNTFS_UPCASE_TABLE upcase_table = NULL;

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadAttributeBox"),
                   WindowHandle, ReadAttribute)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    if (!Drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !(upcase_table = new NTFS_UPCASE_TABLE) ||
        !upcase_table->Initialize(&upcase_attribute)
        ) {

        delete upcase_table;
        return FALSE;
    }

    mft.GetMasterFileTable()->SetUpcaseTable( upcase_table );

    if (0 == wcslen(Name)) {
        pcAttrName = NULL;
    } else {
        if (!attr_name.Initialize(Name)) {
            return FALSE;
        }

        pcAttrName = &attr_name;
    }

    //
    // NTFS_FILE_RECORD_SEGMENT::QueryAttribute can't query an
    // attribute list, so if that's what we're trying to read we'll
    // do things differently.
    //

    _attr_list_io = (AttributeType == $ATTRIBUTE_LIST);

    if (_attr_list_io) {

        if (!_hmem.Initialize()) {
            return FALSE;
        }

        if (!_frsstruc.Initialize(&_hmem,
                mft.GetMasterFileTable()->GetDataAttribute(), FileNumber,
                ntfssa.QueryClusterFactor(),
                ntfssa.QueryVolumeSectors(),
                ntfssa.QueryFrsSize(),
                NULL) ||
            !_frsstruc.Read()) {

            return FALSE;
        }
        if (!_frsstruc.QueryAttributeList(&_attr_list)) {
            return FALSE;
        }

        _length = _attr_list.QueryValueLength().GetLowPart();


    } else {
        if (!_frs.Initialize((VCN)FileNumber, &mft) ||
            !_frs.Read()) {

            return FALSE;
        }
        if (!_frs.QueryAttribute(&_attr, &error, AttributeType, pcAttrName)) {
            return FALSE;
        }
        _length = _attr.QueryValueLength().GetLowPart();
    }

#if FALSE
    {
        TCHAR String[128];

        wsprintf( String, TEXT("Allocating %x"), _length );
        MessageBox( WindowHandle, String, TEXT("ATTR_IO::Setup"), MB_OK|MB_ICONINFORMATION );
    }
#endif

    _data = Mem->Acquire(_length, Drive->QueryAlignmentMask());

    if (NULL == _data) {

        _length = min( _length, 4 * 1024 * 1024 );

#if FALSE
        {
            TCHAR String[128];

            wsprintf( String, TEXT("Smaller allocation %x"), _length );
            MessageBox( WindowHandle, String, TEXT("ATTR_IO::Setup"), MB_OK|MB_ICONINFORMATION );
        }
#endif

        _data = Mem->Acquire(_length, Drive->QueryAlignmentMask());

        if (NULL == _data) {
            return FALSE;
        }
        wsprintf(_header_text, TEXT("DiskEdit - Reduced Size Attribute %x, %x, \"%s\" "),
            FileNumber, AttributeType, Name);
    } else {
        wsprintf(_header_text, TEXT("DiskEdit - Attribute %x, %x, \"%s\" "),
            FileNumber, AttributeType, Name);
    }


    return TRUE;
}


BOOLEAN
ATTR_IO::Read(
    OUT PULONG  pError
    )
{
    ULONG bytes_read;

    *pError = 0;

    if (_attr_list_io) {
        if (!_attr_list.ReadList()) {
            return FALSE;
        }
        memcpy(_data, (PVOID)_attr_list.GetNextAttributeListEntry(NULL),
            _length);

        return TRUE;
    }


    if (!_attr.Read(_data, 0, _length, &bytes_read) ||
        bytes_read != _length) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ATTR_IO::Write(
    )
{
    ULONG bytes_written;

    if (_attr_list_io) {
       return _attr_list.WriteList(NULL);
    }

    return _attr.Write(_data, 0, _length, &bytes_written, NULL) &&
           bytes_written == _length;
}


PVOID
ATTR_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _length;
    }

    return _data;
}


PTCHAR
ATTR_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadAttribute(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    TCHAR String[128];
    HWND hCombo;
    INT i;

    switch (message) {
    case WM_INITDIALOG:

        hCombo = GetDlgItem(hDlg, IDTEXT2);

        for (i = 1; $END != TypeCodeNameTab[i].Code; ++i) {
            swprintf(String, TEXT("%x %s"), TypeCodeNameTab[i].Code,
                TypeCodeNameTab[i].Name);

            SendMessage(hCombo, CB_ADDSTRING, (WPARAM)0, (LPARAM)String);
        }

        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            TCHAR buf[1024];
            INT n;

            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &FileNumber);

            n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &AttributeType);

            n = GetDlgItemText(hDlg, IDTEXT3, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            wcscpy(Name, buf);

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\atrlsted.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "atrlsted.hxx"
#include "crack.hxx"
#include "attrlist.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
ATTR_LIST_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}

VOID
ATTR_LIST_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/3);
}

STATIC TCHAR buf[1024];

VOID
ATTR_LIST_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    PTCHAR  pc;
    TCHAR   sbFlags[32];
    ULONG   LengthOfList = _size;
    ULONG   CurrentOffset;
    ULONG   CurrentLine = 0;

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/3, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)((PCHAR)_buffer);
    CurrentOffset = 0;

    while (CurrentOffset < LengthOfList) {

        if (0 != CurrentOffset) {
            CurrentLine++;
        }

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(
            CurrentEntry->AttributeTypeCode);

        swprintf(buf, TEXT("Attribute type code: \t%x (%s)"),
            CurrentEntry->AttributeTypeCode, SymbolicTypeCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Record length \t\t%x"), CurrentEntry->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name length \t%x"),
            CurrentEntry->AttributeNameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name offset \t%x"),
            CurrentEntry->AttributeNameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Lowest vcn \t\t<%x,%x>"),
            CurrentEntry->LowestVcn.GetHighPart(),
            CurrentEntry->LowestVcn.GetLowPart());
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Segment reference: \t<%x,%x>"),
            CurrentEntry->SegmentReference.HighPart,
            CurrentEntry->SegmentReference.LowPart,
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Sequence number: \t%x"),
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Instance: \t\t%x"), CurrentEntry->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("Attribute name:\t\t"));
        pc = buf + wcslen(buf);

        for (int i = 0; i < min(64, CurrentEntry->AttributeNameLength); ++i) {
            *pc++ = (CHAR)CurrentEntry->AttributeName[i];
        }
        *pc++ = '\0';

        if (CurrentEntry->AttributeNameLength > 64) {
            wcscat(buf, TEXT("..."));
        }
        WriteLine(DeviceContext, CurrentLine++, buf);

        if (CurrentEntry->RecordLength == 0) {
            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry(CurrentEntry);
    }
}

VOID
ATTR_LIST_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
ATTR_LIST_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\clusio.cxx ===
#include "ulib.hxx"
#include "ntfssa.hxx"
#include "clusio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG StartCluster = 0;
STATIC ULONG NumClusters = 1;


BOOLEAN
CLUSTER_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    HMEM    mem;
    MESSAGE msg;

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadClustersBox"),
                   WindowHandle, ReadClusters)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    _drive = Drive;

    if (!NumClusters || !_drive) {
        return FALSE;
    }

    PPACKED_BOOT_SECTOR     p;
    BIOS_PARAMETER_BLOCK    bpb;
    ULONG                   ClusterFactor;

    //
    // Read the boot sector.
    //

    if (!_secrun.Initialize(&mem, _drive, 0, 1) || !_secrun.Read()) {
        return FALSE;
    }
    p = (PPACKED_BOOT_SECTOR)_secrun.GetBuf();

    UnpackBios(&bpb, &(p->PackedBpb));

    ClusterFactor = bpb.SectorsPerCluster;

    if (!_secrun.Initialize(Mem, _drive,
                            StartCluster*ClusterFactor,
                            NumClusters*ClusterFactor)) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - Cluster 0x%X for 0x%X"), StartCluster, NumClusters);

    return TRUE;
}


BOOLEAN
CLUSTER_IO::Read(
    OUT PULONG pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_secrun.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
CLUSTER_IO::Write(
    )
{
    return _drive ? _secrun.Write() : FALSE;
}


PVOID
CLUSTER_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _drive ? (_drive->QuerySectorSize()*_secrun.QueryLength()) : 0;
    }

    return _secrun.GetBuf();
}


PTCHAR
CLUSTER_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadClusters(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    TCHAR buf[1024];

    switch (message) {
        case WM_INITDIALOG:
            wsprintf(buf, TEXT("%x"), StartCluster);
            SetDlgItemText(hDlg, IDTEXT, buf);

            wsprintf(buf, TEXT("%x"), NumClusters);
            SetDlgItemText(hDlg, IDTEXT2, buf);

            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &StartCluster);

                n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &NumClusters);

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\bootedit.cxx ===
#include "ulib.hxx"
#include "bootedit.hxx"
#include "bpb.hxx"


extern "C" {
#include <stdio.h>
}


VOID
DOS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
DOS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    EXTENDED_BIOS_PARAMETER_BLOCK   bios;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    memset(&bios, 0, sizeof(EXTENDED_BIOS_PARAMETER_BLOCK));

    // Unpack the bios
    UnpackExtendedBios(&bios, (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)_buffer);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String:                      %c%c%c%c%c%c%c%c"),
                 bios.OemData[0],
                 bios.OemData[1],
                 bios.OemData[2],
                 bios.OemData[3],
                 bios.OemData[4],
                 bios.OemData[5],
                 bios.OemData[6],
                 bios.OemData[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector:                %x"), bios.Bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster:             %x"), bios.Bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors:                %x"), bios.Bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats:                  %x"), bios.Bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries:                    %x"), bios.Bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count:              %x"), bios.Bpb.Sectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte:                      %x"), bios.Bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat:                 %x"), bios.Bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
       
    if(!bios.Bpb.SectorsPerFat){
   
       swprintf(buf, TEXT("Large sectors per fat:           %x"), bios.Bpb.BigSectorsPerFat);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;
    }
    
    swprintf(buf, TEXT("Sectors per track:               %x"),
        bios.Bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads:                 %x"),
        bios.Bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors:        %x"),
                 bios.Bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors:         %x"),
                 bios.Bpb.LargeSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    if(!bios.Bpb.SectorsPerFat){
    
       swprintf(buf, TEXT("Extended flags:                  %x"),
                bios.Bpb.ExtFlags);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("File system version:             %x"),
                 bios.Bpb.FS_Version);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("Root directory start cluster:    %x"), bios.Bpb.RootDirStrtClus);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("File system info sector number:  %x"), bios.Bpb.FSInfoSec);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("Backup boot sector:              %x"), bios.Bpb.BkUpBootSec);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;
    
    }

    swprintf(buf, TEXT("Physical drive:                  %x"), bios.PhysicalDrive);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Current head:                    %x"), bios.CurrentHead);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Extended boot signature:         %x"), bios.Signature);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Serial number:                   %x"), bios.SerialNumber);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Label:                           %c%c%c%c%c%c%c%c%c%c%c"),
                 bios.Label[0],
                 bios.Label[1],
                 bios.Label[2],
                 bios.Label[3],
                 bios.Label[4],
                 bios.Label[5],
                 bios.Label[6],
                 bios.Label[7],
                 bios.Label[8],
                 bios.Label[9],
                 bios.Label[10]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("System id:                       %c%c%c%c%c%c%c%c"),
                 bios.SystemIdText[0],
                 bios.SystemIdText[1],
                 bios.SystemIdText[2],
                 bios.SystemIdText[3],
                 bios.SystemIdText[4],
                 bios.SystemIdText[5],
                 bios.SystemIdText[6],
                 bios.SystemIdText[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\diskedit.h ===
#define IDM_ABOUT               100
#define IDM_OPEN                200
#define IDM_READ_SECTORS        300
#define IDM_READ_FRS            400
#define IDM_READ_ATTRIBUTE      450
#define IDM_VIEW_BYTES          500
#define IDM_VIEW_FRS            600
#define IDM_EXIT                700
#define IDM_WRITE_IT            800
#define IDM_READ_ROOT           900
#define IDM_READ_CHAIN          1000
#define IDM_READ_LOG_RECORD     1050
#define IDM_VIEW_FAT_BOOT       1100
#define IDM_VIEW_NTFS_BOOT      1200
#define IDM_READ_PREVIOUS       1300
#define IDM_READ_NEXT           1400
#define IDM_READ_REMOVE         1500
#define IDM_VIEW_LAST           1600
#define IDM_CRACK_NTFS          1700
#define IDM_CRACK_FAT           1800
#define IDM_CRACK_LSN           1850
#define IDM_CRACK_NEXT_LSN      1875
#define IDM_VIEW_NTFS_INDEX     1900
#define IDM_VIEW_NTFS_SECURITY_ID       1950
#define IDM_VIEW_NTFS_SECURITY_HASH     1951
#define IDM_VIEW_NTFS_SECURITY_STREAM   1952
#define IDM_BACKTRACK_FRS       2000
#define IDM_RELOCATE_SECTORS    2100
#define IDM_RELOCATE_FRS        2200
#define IDM_RELOCATE_ROOT       2300
#define IDM_RELOCATE_CHAIN      2400
#define IDM_READ_FILE           2600
#define IDM_RELOCATE_FILE       2700
#define IDM_READ_CLUSTERS       2800
#define IDM_RELOCATE_CLUSTERS   2900
#define IDM_VIEW_PARTITION_TABLE 3000
#define IDM_VIEW_GPT            3050
#define IDM_VIEW_RESTART_AREA   3100
#define IDM_VIEW_RECORD_PAGE    3200
#define IDM_VIEW_LOG_RECORD     3300
#define IDM_VIEW_SPLIT          3400
#define IDM_VIEW_ATTR_LIST      3500

#define IDTEXT      51
#define IDTEXT2     52
#define IDCHECKBOX  53
#define IDTEXT3     54
#define IDLISTBOX   55
#define IDVOLUME    56
#define IDRADIO1    57
#define IDRADIO2    58

#define IDSTATIC    -1


BOOLEAN InitApplication(HINSTANCE);
BOOLEAN InitInstance(HINSTANCE, INT, HWND*, HACCEL*);
LRESULT MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT SplitWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT ChildWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR About(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadSectors(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadClusters(HWND, UINT, WPARAM, LPARAM);
INT_PTR OpenVolume(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadFrs(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadChain(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadLogRecord(HWND, UINT, WPARAM, LPARAM);
INT_PTR InputPath(HWND, UINT, WPARAM, LPARAM);
INT_PTR InputLsn(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadTheFile(HWND, UINT, WPARAM, LPARAM);
INT_PTR ReadAttribute(HWND, UINT, WPARAM, LPARAM);

typedef struct _DISK_TYPE_TABLE {
    ULONG Code;
    PTCHAR Name;
} DISK_TYPE_TABLE, *PDISK_TYPE_TABLE;

extern DISK_TYPE_TABLE TypeCodeNameTab[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\crack.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "rfatsa.hxx"
#include "rcache.hxx"
#include "hmem.hxx"
#include "recordpg.hxx"
#include "crack.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

extern PLOG_IO_DP_DRIVE Drive;

TCHAR             Path[MAX_PATH];

VOID
CrackNtfsPath(
    IN  HWND    WindowHandle
    )
{
    DSTRING                     path;
    NTFS_SA                     ntfssa;
    MESSAGE                     msg;
    NTFS_MFT_FILE               mft;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_ATTRIBUTE              bitmap_attribute;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_ATTRIBUTE              upcase_attribute;
    NTFS_UPCASE_TABLE           upcase_table;
    NTFS_FILE_RECORD_SEGMENT    file_record;
    BOOLEAN                     error;
    BOOLEAN                     system_file;
    ULONG                       file_number;
    TCHAR                        buf[100];


    if (!path.Initialize(Path)) {
        wsprintf(buf, TEXT("Out of memory"));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
        return;
    }

    if (!Drive ||
        !ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(ntfssa.QueryVolumeSectors() /
              (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read()) {

        swprintf(buf, TEXT("Could not init NTFS data structures"));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);

        return;
    }
    if (!ntfssa.QueryFrsFromPath(&path, mft.GetMasterFileTable(),
        &volume_bitmap, &file_record, &system_file, &error)) {
        wsprintf(buf, TEXT("File not found."));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONINFORMATION);

        return;
    }

    file_number = file_record.QueryFileNumber().GetLowPart();

    wsprintf(buf, TEXT("The given path points to file record 0x%X"), file_number);

    MessageBox(WindowHandle, buf, TEXT("Path Image"), MB_OK);
}

BOOLEAN
BacktrackFrs(
    IN      VCN                     FileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    OUT     PWCHAR                  PathBuffer,
    IN      ULONG                   BufferLength,
    OUT     PULONG                  PathLength
    )
/*++

Routine Description:

    This function finds a path from the root to a given FRS.

Arguments:

    FileNumber      --  Supplies the file number of the target FRS.
    Mft             --  Supplies the volume's Master File Table.
    PathBuffer      --  Receives a path to the FRS.
    BufferLength    --  Supplies the length (in characters) of
                        the client's buffer.
    PathLength      --  Receives the length (in characters) of
                        the path.

Return Value:

    TRUE upon successful completion.  The returned path may
    not be NULL-terminated.

--*/
{
    NTFS_FILE_RECORD_SEGMENT CurrentFrs;
    NTFS_ATTRIBUTE FileNameAttribute;
    VCN ParentFileNumber;
    PCFILE_NAME FileName;
    ULONG i;
    BOOLEAN Error;

    if( FileNumber == ROOT_FILE_NAME_INDEX_NUMBER ) {

        // This is the root; return a NULL path.
        //
        *PathLength = 0;
        return TRUE;
    }

    // Initialize the FRS and extract a name (any name will do).
    //
    if( !CurrentFrs.Initialize( FileNumber, Mft ) ||
        !CurrentFrs.Read() ||
        !CurrentFrs.QueryAttribute( &FileNameAttribute, &Error, $FILE_NAME ) ||
        !FileNameAttribute.IsResident() ) {

        return FALSE;
    }

    FileName = (PCFILE_NAME)FileNameAttribute.GetResidentValue();

    ParentFileNumber.Set( FileName->ParentDirectory.LowPart,
                          (LONG)FileName->ParentDirectory.HighPart );

    // Now recurse into this file's parent.
    //
    if( !BacktrackFrs( ParentFileNumber,
                       Mft,
                       PathBuffer,
                       BufferLength,
                       PathLength ) ) {

        return FALSE;
    }

    // Add this file's name to the path.
    //
    if( *PathLength + FileName->FileNameLength + 1 > BufferLength ) {

        // Buffer is too small.
        //
        return FALSE;
    }

    PathBuffer[*PathLength] = '\\';

    for( i = 0; i < FileName->FileNameLength; i++ ) {

        PathBuffer[*PathLength+1+i] = FileName->FileName[i];
    }

    *PathLength += 1 + FileName->FileNameLength;

    return TRUE;

}

BOOLEAN
BacktrackFrsFromScratch(
    IN  HWND    WindowHandle,
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This function finds a path from the root to a given
    FRS; it sets up the MFT and its helper objects as
    needed.

Arguments:

    WindowHandle    --  Supplies a handle to the parent window.
    FileNumber      --  Supplies the file number of the target FRS.

Return Value:

    TRUE upon successful completion.  The returned path may
    not be NULL-terminated.

--*/
{
    WCHAR                       WPath[MAX_PATH];

    NTFS_SA                     ntfssa;
    MESSAGE                     msg;
    NTFS_MFT_FILE               mft;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_ATTRIBUTE              bitmap_attribute;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_ATTRIBUTE              upcase_attribute;
    NTFS_UPCASE_TABLE           upcase_table;
    BOOLEAN                     error;
    ULONG                       BufferLength, PathLength, i;

    BufferLength = sizeof(WPath);

    if (!Drive ||
        !ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(Drive->QuerySectors()/
               (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(Drive->QuerySectors()/
             (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !BacktrackFrs( FileNumber, mft.GetMasterFileTable(), WPath,
                            BufferLength, &PathLength ) ) {

        return FALSE;
    }

    MessageBox(WindowHandle, WPath, TEXT("Path Image"), MB_OK);

    return TRUE;
}



VOID
CrackFatPath(
    IN  HWND    WindowHandle
    )
{
    DSTRING      path;
    REAL_FAT_SA  fatsa;
    MESSAGE      msg;
    ULONG        cluster_number;
    TCHAR        buf[100];

    if (!path.Initialize(Path) ||
        !Drive ||
        !fatsa.Initialize(Drive, &msg) ||
        !fatsa.FAT_SA::Read()) {

        return;
    }

    cluster_number = fatsa.QueryFileStartingCluster(&path);

    wsprintf(buf, TEXT("The given path points to cluster 0x%X"), cluster_number);

    MessageBox(WindowHandle, buf, TEXT("Path Image"), MB_OK);
}

VOID
CrackLsn(
    IN HWND     WindowHandle
    )
{
    extern LSN  Lsn;
    TCHAR       buf[100];
    LONGLONG    FileOffset;

    (void)GetLogPageSize(Drive);

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);

    wsprintf(buf, TEXT("page at %x, offset %x, seq %x"), (ULONG)FileOffset,
        LfsLsnToPageOffset(Drive, Lsn) , LfsLsnToSeqNumber(Drive, Lsn));
    MessageBox(WindowHandle, buf, TEXT("LSN"), MB_OK);
}

//
// CrackNextLsn -- given an LSN in the Lsn variable, find the
//      LSN following that one in the log file.  This involves
//      reading the log record for the given lsn to find it's
//      size, and figuring the page and offset of the following
//      lsn from that.
//
BOOLEAN
CrackNextLsn(
    IN HWND     WindowHandle
    )
{
    extern LSN  Lsn;
    TCHAR       buf[100];
    NTFS_SA     ntfssa;
    NTFS_MFT_FILE mft;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    MESSAGE     msg;
    BOOLEAN     error;
    NTFS_FILE_RECORD_SEGMENT frs;
    NTFS_ATTRIBUTE attrib;

    LFS_RECORD_HEADER RecordHeader;
    ULONG       bytes_read;
    ULONG       RecordLength;
    ULONG       PageSize;
    ULONGLONG   NextLsn;
    ULONG       SeqNumber;

    if (0 == (PageSize = GetLogPageSize(Drive))) {
        return FALSE;
    }

    if (!Drive)
        return FALSE;
    if (!ntfssa.Initialize(Drive, &msg))
        return FALSE;
    if (!ntfssa.Read())
        return FALSE;
    if (!mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL))
        return FALSE;
    if (!mft.Read())
        return FALSE;
    if (!frs.Initialize((VCN)LOG_FILE_NUMBER, &mft))
        return FALSE;
    if (!frs.Read())
        return FALSE;
    if (!frs.QueryAttribute(&attrib, &error, $DATA, NULL)) {
        return FALSE;
    }

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(Drive, Lsn);
    SeqNumber = (ULONG)LfsLsnToSeqNumber(Drive, Lsn);

    if (!attrib.Read((PVOID)&RecordHeader, ULONG(PageOffset | FileOffset),
        LFS_RECORD_HEADER_SIZE, &bytes_read))
        return FALSE;

    if (bytes_read != LFS_RECORD_HEADER_SIZE) {
        return FALSE;
    }

    RecordLength = LFS_RECORD_HEADER_SIZE + RecordHeader.ClientDataLength;

    if (PageOffset + RecordLength < PageSize &&
        PageSize - (PageOffset + RecordLength) >= LFS_RECORD_HEADER_SIZE) {

        //
        // the current record ends on this page, and the next record begins
        // immediately after
        //

        PageOffset += RecordLength;

    } else if (PageSize - (PageOffset+RecordLength) < LFS_RECORD_HEADER_SIZE) {

        //
        // The next record header will not fit on this page... it
        // will begin on the next page immediately following the page
        // header
        //

        FileOffset += PageSize;
        PageOffset = LFS_PACKED_RECORD_PAGE_HEADER_SIZE;

    } else {
        //
        // the next log record starts on a following page
        //

        ULONG left;
        ULONG page_capacity;

        left = PageSize - (PageOffset + RecordLength);
        page_capacity = PageSize - LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
        PageOffset += (left / page_capacity + 1) * PageSize;
        FileOffset = left % page_capacity + LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
    }

    // create lsn from FileOffset + PageOffset

    NextLsn = LfsFileOffsetToLsn(Drive, FileOffset | PageOffset, SeqNumber);

    wsprintf(buf, TEXT("Next LSN %x:%x, at %x + %x"), ((PLSN)&NextLsn)->HighPart,
        ((PLSN)&NextLsn)->LowPart, (ULONG)FileOffset, (ULONG)PageOffset);
    MessageBox(WindowHandle, buf, TEXT("LSN"), MB_OK);

    return TRUE;
}

DISK_TYPE_TABLE TypeCodeNameTab[] = {
    { $UNUSED,                  TEXT("$UNUSED") },
    { $STANDARD_INFORMATION,    TEXT("$STANDARD_INFORMATION") },
    { $ATTRIBUTE_LIST,          TEXT("$ATTRIBUTE_LIST") },
    { $FILE_NAME,               TEXT("$FILE_NAME") },
    { $OBJECT_ID,           TEXT("$OBJECT_ID") },
    { $SECURITY_DESCRIPTOR,     TEXT("$SECURITY_DESCRIPTOR") },
    { $VOLUME_NAME,             TEXT("$VOLUME_NAME") },
    { $VOLUME_INFORMATION,      TEXT("$VOLUME_INFORMATION") },
    { $DATA,                    TEXT("$DATA") },
    { $INDEX_ROOT,              TEXT("$INDEX_ROOT") },
    { $INDEX_ALLOCATION,        TEXT("$INDEX_ALLOCATION") },
    { $BITMAP,                  TEXT("$BITMAP") },
    { $SYMBOLIC_LINK,           TEXT("$SYMBOLIC_LINK") },
    { $EA_INFORMATION,          TEXT("$EA_INFORMATION") },
    { $EA_DATA,                 TEXT("$EA_DATA") },
    { $END,                     TEXT("$END") }
};

PTCHAR
GetNtfsAttributeTypeCodeName(
    IN  ULONG   Code
    )
{
    for (INT i = 0; $END != TypeCodeNameTab[i].Code; ++i) {
        if (Code == TypeCodeNameTab[i].Code) {
            return TypeCodeNameTab[i].Name;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\chainio.cxx ===
#include "ulib.hxx"
#include "chainio.hxx"
#include "diskedit.h"
#include "rfatsa.hxx"

extern "C" {
#include <stdio.h>
}

STATIC USHORT   StartingCluster = 0;

BOOLEAN
CHAIN_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    REAL_FAT_SA fatsa;
    MESSAGE msg;

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadChainBox"),
                   WindowHandle, ReadChain)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    _drive = Drive;

    if (!_drive ||
        !StartingCluster ||
        !fatsa.Initialize(_drive, &msg) ||
        !fatsa.FAT_SA::Read() ||
        !_cluster.Initialize(Mem, _drive, &fatsa,
                             fatsa.GetFat(), StartingCluster)) {

        return FALSE;
    }

    _buffer = _cluster.GetBuf();
    _buffer_size = fatsa.QuerySectorsPerCluster()*_drive->QuerySectorSize()*
                    _cluster.QueryLength();

    wsprintf(_header_text, TEXT("DiskEdit - Starting Cluster 0x%X"), StartingCluster);


    return TRUE;
}


BOOLEAN
CHAIN_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }

    if (!_cluster.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
CHAIN_IO::Write(
    )
{
    return _drive ? _cluster.Write() : FALSE;
}


PVOID
CHAIN_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
CHAIN_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadChain(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    ULONG   tmp;

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &tmp);

                StartingCluster = (USHORT) tmp;

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\diskedit.cxx ===
#include "ulib.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "rfatsa.hxx"
#include "secio.hxx"
#include "clusio.hxx"
#include "frsio.hxx"
#include "rootio.hxx"
#include "chainio.hxx"
#include "fileio.hxx"
#include "logrecio.hxx"
#include "secedit.hxx"
#include "frsedit.hxx"
#include "indxedit.hxx"
#include "secstr.hxx"
#include "bootedit.hxx"
#include "nbedit.hxx"
#include "ofsbedit.hxx"
#include "partedit.hxx"
#include "gptedit.hxx"
#include "restarea.hxx"
#include "logreced.hxx"
#include "rcache.hxx"
#include "hmem.hxx"
#include "attrio.hxx"
#include "recordpg.hxx"
#include "crack.hxx"
#include "atrlsted.hxx"
#include "diskedit.h"

extern "C" {
    #include <stdio.h>
}

DECLARE_CLASS( IO_COUPLE );

class IO_COUPLE : public OBJECT {

    public:

        DECLARE_CONSTRUCTOR( IO_COUPLE );

        VIRTUAL
        ~IO_COUPLE(
            ) { Destroy(); };

        PHMEM           Mem;
        PIO_OBJECT      IoObject;
        PEDIT_OBJECT    EditObject;
        PEDIT_OBJECT    OtherEditObject;
        PEDIT_OBJECT    SplitEditObject;

    private:

        NONVIRTUAL
        VOID
        Construct() {
            Mem = NULL;
            IoObject = NULL;
            EditObject = NULL;
            OtherEditObject = NULL;
            SplitEditObject = NULL;
        };

        NONVIRTUAL
        VOID
        Destroy(
            );

};

enum SPLIT_OPERATION {
    eSplitToggle,
    eSplitCreate,
    eSplitDestroy,
    eSplitQuery
};

extern BOOLEAN SplitView(HWND, SPLIT_OPERATION);


DEFINE_CONSTRUCTOR( IO_COUPLE, OBJECT );


VOID
IO_COUPLE::Destroy(
    )
{
    DELETE(Mem);
    DELETE(IoObject);
    DELETE(EditObject);
    DELETE(OtherEditObject);
    DELETE(SplitEditObject);
}

#define IoCoupleSetEdit(IoCouple,type,hWnd,hwndChild,ClientHeight,ClientWidth,Drive) \
{                                                                           \
    VERTICAL_TEXT_SCROLL *V = NEW type;                                     \
                                                                            \
    do {                                                                    \
                                                                            \
        if (NULL == V) {                                                    \
            ReportError(hwndChild, 0);                                      \
            continue;                                                       \
        }                                                                   \
        if (!V->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {  \
            DELETE(V);                                                      \
            ReportError(hWnd, 0);                                           \
            continue;                                                       \
        }                                                                   \
                                                                            \
        IoCouple->EditObject->KillFocus(hwndChild);                         \
        DELETE(IoCouple->OtherEditObject);                                  \
        IoCouple->OtherEditObject = IoCouple->EditObject;                   \
        IoCouple->EditObject = V;                                           \
        IoCouple->IoObject->GetBuf(&size);                                  \
        IoCouple->EditObject->SetBuf(hwndChild,                             \
            IoCouple->IoObject->GetBuf(), size);                            \
        IoCouple->EditObject->SetFocus(hwndChild);                          \
        InvalidateRect(hwndChild, NULL, TRUE);                              \
                                                                            \
        if (NULL != hwndSplit) {                                            \
            if (NULL == (V = NEW type)) {                                   \
                ReportError(hwndSplit, 0);                                  \
                continue;                                                   \
            }                                                               \
            if (!V->Initialize(hwndSplit, ClientHeight,                     \
                    ClientWidth, Drive)) {                                  \
                DELETE(V);                                                  \
                ReportError(hWnd, 0);                                       \
                continue;                                                   \
            }                                                               \
                                                                            \
            IoCouple->SplitEditObject = V;                                  \
            IoCouple->IoObject->GetBuf(&size);                              \
            IoCouple->SplitEditObject->SetBuf(hwndSplit,                    \
                IoCouple->IoObject->GetBuf(), size);                        \
        }                                                                   \
    } while ( 0 );                                                          \
}



PLOG_IO_DP_DRIVE Drive = NULL;
LSN              Lsn;

STATIC HINSTANCE        hInst;
STATIC PIO_COUPLE       IoCouple = NULL;
STATIC PLIST            IoList = NULL;
STATIC PITERATOR        IoListIterator = NULL;
STATIC INT              ClientHeight = 0;
STATIC INT              ClientWidth = 0;
STATIC INT              BacktrackFileNumber;

BOOLEAN
DbgOutput(
    PCHAR   Stuff
    )
{
    OutputDebugStringA(Stuff);
    return TRUE;
}


VOID
ReportError(
    IN  HWND    hWnd,
    IN  ULONG   Error
    )
{
    TCHAR message[64];

    DialogBox(hInst, TEXT("ErrorBox"), hWnd, About);

    if (0 != Error) {
        wsprintf(message, TEXT("Error code: 0x%x\n"), Error);
        MessageBox(hWnd, message, TEXT("Error Information"), MB_OK|MB_ICONINFORMATION);
    }
}


INT
WinMain(
    IN  HINSTANCE  hInstance,
    IN  HINSTANCE  hPrevInstance,
    IN  LPSTR   lpCmdLine,
    IN  INT     nCmdShow
    )
{
    MSG     msg;
    HACCEL  hAccel;
    HWND    hWnd;
    HICON   hIcon;

    if (!hPrevInstance && !InitApplication(hInstance)) {
        return FALSE;
    }

    if (!InitInstance(hInstance, nCmdShow, &hWnd, &hAccel)) {
        return FALSE;
    }

    while (GetMessage(&msg, NULL, NULL, NULL)) {
        if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (int)msg.wParam;
}


BOOLEAN
InitApplication(
    IN  HINSTANCE  hInstance
    )
{
    WNDCLASS  wc;

    //
    // Class for the normal viewing window
    //

    wc.style = NULL;
    wc.lpfnWndProc = ChildWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, TEXT("diskedit"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("ChildWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    //
    // Class for the split, byte-view window.
    //

    wc.style = NULL;
    wc.lpfnWndProc = SplitWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SplitWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    //
    // Class for the parent window.
    //

    wc.style = NULL;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, TEXT("diskedit"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  TEXT("DiskEditMenu");
    wc.lpszClassName = TEXT("DiskEditWinClass");

    if (0 == RegisterClass(&wc))
        return 0;

    return 1;
}


BOOLEAN
InitInstance(
    IN  HINSTANCE  hInstance,
    IN  INT     nCmdShow,
    OUT HWND*   phWnd,
    OUT HACCEL* hAccel
    )
{
    HDC         hdc;
    TEXTMETRIC  textmetric;


    hInst = hInstance;

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;
    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(NULL, hdc);

    *phWnd = CreateWindow(
        TEXT("DiskEditWinClass"),
        TEXT("DiskEdit"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        84*textmetric.tmMaxCharWidth,
        36*(textmetric.tmExternalLeading + textmetric.tmHeight),
        NULL,
        NULL,
        hInstance,
        NULL
        );
    if (NULL == *phWnd) {
        return FALSE;
    }

    *hAccel = (HACCEL) LoadAccelerators(hInst, TEXT("DiskEditAccel"));

    ShowWindow(*phWnd, nCmdShow);
    UpdateWindow(*phWnd);

    return TRUE;
}

INT_PTR
FrsNumberDialogProc(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
/*++

Routine Description:

    This is the dialog procedure for the dialog box which queries
    an FRS number to backtrack.

Arguments:

    hDlg    --  identifies the dialog box
    message --  supplies the message ID received by the dialog box
    wParam  --  message-type-dependent parameter
    lParam  --  message-type-dependent parameter

Returns:

    TRUE if this procedure handled the message, FALSE if it
    did not.

--*/
{
    UNREFERENCED_PARAMETER(lParam);

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &BacktrackFileNumber);

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

STATIC HWND hwndChild = NULL;
STATIC HWND hwndSplit = NULL;

LRESULT
MainWndProc(
    IN  HWND    hWnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HDC                 hDC;
    PAINTSTRUCT         ps;

    PDOS_BOOT_EDIT      boot_edit;
    PNTFS_BOOT_EDIT     ntboot_edit;
    PPARTITION_TABLE_EDIT part_edit;
    PGUID_PARTITION_TABLE_EDIT guid_part_edit;
    PRESTART_AREA_EDIT  rest_area_edit;
    PRECORD_PAGE_EDIT   rec_page_edit;
    PLOG_RECORD_EDIT    log_rec_edit;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status = 0;
    PIO_COUPLE          next_couple;
    PEDIT_OBJECT        tmp_edit;

    switch (message) {
    case WM_SETFOCUS:

        IoCouple->EditObject->SetFocus(hwndChild);
        break;

    case WM_CREATE:

       if (!DEFINE_CLASS_DESCRIPTOR( IO_COUPLE ) ||
            !(IoCouple = NEW IO_COUPLE) ||
            !(IoCouple->IoObject = NEW IO_OBJECT) ||
            !(IoCouple->EditObject = NEW EDIT_OBJECT) ||
            !(IoCouple->OtherEditObject = NEW EDIT_OBJECT) ||
            !(IoList = NEW LIST) ||
            !IoList->Initialize() ||
            !IoList->Put((POBJECT) IoCouple) ||
            !(IoListIterator = IoList->QueryIterator()) ||
            !IoListIterator->GetNext()) {

            PostQuitMessage(0);
        }

        hwndChild = CreateWindow(
            TEXT("ChildWinClass"),
            TEXT("PrimaryView"),
            WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
            0, 0,
            ClientWidth, ClientHeight,
            hWnd,
            NULL,
            hInst,
            NULL
            );
        if (NULL == hwndChild) {
            int error = GetLastError();
            PostQuitMessage(0);
        }

        ShowWindow(hwndChild, SW_SHOW);
        UpdateWindow(hwndChild);

        SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
            SWP_SHOWWINDOW);

        break;

    case WM_SIZE:
        ClientHeight = HIWORD(lParam);
        ClientWidth = LOWORD(lParam);

        if (NULL == hwndSplit) {
            IoCouple->EditObject->ClientSize(ClientHeight, ClientWidth);

            SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
                SWP_SHOWWINDOW);
        } else {
            IoCouple->EditObject->ClientSize(ClientHeight, ClientWidth / 2);
            IoCouple->SplitEditObject->ClientSize(ClientHeight, ClientWidth / 2);

            SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth / 2,
                ClientHeight, SWP_SHOWWINDOW);

            SetWindowPos(hwndSplit, HWND_TOP, ClientWidth / 2, 0,
                ClientWidth / 2, ClientHeight, SWP_SHOWWINDOW);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_ABOUT:
            DialogBox(hInst, TEXT("AboutBox"), hWnd, About);
            break;

        case IDM_EXIT:
            DestroyWindow(hWnd);
            break;

        case IDM_OPEN:
            if (!DialogBox(hInst, TEXT("OpenVolumeBox"), hWnd, OpenVolume)) {
                ReportError(hWnd, 0);
            }

            SplitView(hWnd, eSplitDestroy);

            IoCouple->EditObject->KillFocus(hwndChild);
            IoListIterator->Reset();
            IoList->DeleteAllMembers();

            if (!(IoCouple = NEW IO_COUPLE) ||
                !(IoCouple->IoObject = NEW IO_OBJECT) ||
                !(IoCouple->EditObject = NEW EDIT_OBJECT) ||
                !(IoCouple->OtherEditObject = NEW EDIT_OBJECT) ||
                !IoList->Initialize() ||
                !IoList->Put(IoCouple) ||
                !IoListIterator->GetNext()) {

                PostQuitMessage(0);
            }
            SetWindowText(hWnd, TEXT("DiskEdit"));
            InvalidateRect(hWnd, NULL, TRUE);
            InvalidateRect(hwndChild, NULL, TRUE);
            break;

        case IDM_READ_SECTORS:
        case IDM_READ_CLUSTERS:
        case IDM_READ_FRS:
        case IDM_READ_ROOT:
        case IDM_READ_CHAIN:
        case IDM_READ_FILE:
        case IDM_READ_ATTRIBUTE:
        case IDM_READ_LOG_RECORD:
            if (!(next_couple = NEW IO_COUPLE)) {
                break;
            }

            switch (LOWORD(wParam)) {

            case IDM_READ_SECTORS:
                next_couple->IoObject = NEW SECTOR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_CLUSTERS:
                next_couple->IoObject = NEW CLUSTER_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_FRS:
                next_couple->IoObject = NEW FRS_IO;
                command = IDM_VIEW_FRS;
                break;

            case IDM_READ_ATTRIBUTE:
                next_couple->IoObject = NEW ATTR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_LOG_RECORD:
                next_couple->IoObject = NEW LOG_RECORD_IO;
                command = IDM_VIEW_LOG_RECORD;
                break;

            case IDM_READ_ROOT:
                next_couple->IoObject = NEW ROOT_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_CHAIN:
                next_couple->IoObject = NEW CHAIN_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_READ_FILE:
                next_couple->IoObject = NEW FILE_IO;
                command = IDM_VIEW_BYTES;
                break;

            default:
                next_couple->IoObject = NULL;
                break;
            }

            error = TRUE;

            if (next_couple->IoObject && (next_couple->Mem = NEW HMEM) &&
                next_couple->Mem->Initialize() &&
                next_couple->IoObject->Setup(next_couple->Mem,
                    Drive, hInst, hwndChild, &error) &&
                next_couple->IoObject->Read(&error_status) &&
                (next_couple->EditObject = NEW EDIT_OBJECT) &&
                (next_couple->OtherEditObject = NEW EDIT_OBJECT) &&
                IoList->Put(next_couple)) {

                if (NULL != hwndSplit) {
                    next_couple->SplitEditObject = NEW EDIT_OBJECT;
                    if (NULL == next_couple->SplitEditObject) {
                        DELETE(next_couple);
                        break;
                    }
                }

                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = next_couple;
                IoCouple->EditObject->SetFocus(hwndChild);
                IoListIterator->Reset();
                IoListIterator->GetPrevious();
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

                SendMessage(hWnd, WM_COMMAND, command, 0);
                if (NULL != hwndSplit) {
                    SendMessage(hwndSplit, WM_COMMAND, command, 0);
                }

            } else {

                if (error) {
                     ReportError(hWnd, error_status);
                    }
                DELETE(next_couple);
            }
            break;

        case IDM_READ_PREVIOUS:
            if (NULL != IoListIterator->GetPrevious()) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE)IoListIterator->GetCurrent();
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hWnd, NULL, TRUE);

                if (NULL != IoCouple->SplitEditObject && NULL == hwndSplit) {
                    SplitView(hwndChild, eSplitCreate);
                    InvalidateRect(hwndSplit, NULL, TRUE);
                }
                if (NULL == IoCouple->SplitEditObject && NULL != hwndSplit) {
                    SplitView(hwndChild, eSplitDestroy);
                }
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

            } else {
                ReportError(hwndChild, 0);
                IoListIterator->GetNext();
            }
            break;

        case IDM_READ_NEXT:
            if (IoListIterator->GetNext()) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE) IoListIterator->GetCurrent();
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

                if (NULL != IoCouple->SplitEditObject && NULL == hwndSplit) {
                    SplitView(hwndChild, eSplitCreate);
                    InvalidateRect(hwndSplit, NULL, TRUE);
                }
                if (NULL == IoCouple->SplitEditObject && NULL != hwndSplit) {
                    SplitView(hwndChild, eSplitDestroy);
                }

                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());
            } else {
                ReportError(hwndChild, 0);
                IoListIterator->GetPrevious();
            }
            break;

        case IDM_READ_REMOVE:
            if (IoList->QueryMemberCount() > 1) {
                IoCouple->EditObject->KillFocus(hwndChild);
                IoCouple = (PIO_COUPLE) IoList->Remove(IoListIterator);
                DELETE(IoCouple);
                IoCouple = (PIO_COUPLE) IoListIterator->GetCurrent();
                if (!IoCouple) {
                    IoCouple = (PIO_COUPLE) IoListIterator->GetPrevious();
                }
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);
                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());
            }
            break;

        case IDM_RELOCATE_SECTORS:
        case IDM_RELOCATE_CLUSTERS:
        case IDM_RELOCATE_FRS:
        case IDM_RELOCATE_ROOT:
        case IDM_RELOCATE_CHAIN:
        case IDM_RELOCATE_FILE:

            IoCouple->IoObject->GetBuf(&size);

            DELETE(IoCouple->IoObject);

            switch (LOWORD(wParam)) {
            case IDM_RELOCATE_SECTORS:
                IoCouple->IoObject = NEW SECTOR_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_CLUSTERS:
                IoCouple->IoObject = NEW CLUSTER_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_FRS:
                IoCouple->IoObject = NEW FRS_IO;
                command = IDM_VIEW_FRS;
                break;

            case IDM_RELOCATE_ROOT:
                IoCouple->IoObject = NEW ROOT_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_CHAIN:
                IoCouple->IoObject = NEW CHAIN_IO;
                command = IDM_VIEW_BYTES;
                break;

            case IDM_RELOCATE_FILE:
                IoCouple->IoObject = NEW FILE_IO;
                if (IoCouple->IoObject) {
                    if (!((PFILE_IO) IoCouple->IoObject)->Initialize(size)) {

                        DELETE(IoCouple->IoObject);
                    }
                }
                command = IDM_VIEW_BYTES;
                break;

            default:
                IoCouple->IoObject = NULL;
                break;
            }

            error = TRUE;

            if (IoCouple->IoObject && IoCouple->IoObject->Setup(IoCouple->Mem,
                Drive, hInst, hwndChild, &error)) {

                SetWindowText(hWnd, IoCouple->IoObject->GetHeaderText());

            } else {
                if (error) {
                     ReportError(hWnd, 0);
                    }
            }
            break;

        case IDM_VIEW_BYTES:

            IoCoupleSetEdit( IoCouple,
                             SECTOR_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_FRS:

            IoCoupleSetEdit( IoCouple,
                             FRS_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_ATTR_LIST:

            IoCoupleSetEdit( IoCouple,
                             ATTR_LIST_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_INDEX:

            IoCoupleSetEdit( IoCouple,
                             NAME_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );


            break;

        case IDM_VIEW_NTFS_SECURITY_ID:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_ID_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_SECURITY_HASH:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_HASH_INDEX_BUFFER_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_NTFS_SECURITY_STREAM:

            IoCoupleSetEdit( IoCouple,
                             SECURITY_STREAM_EDIT,
                             hWnd, hwndChild,
                             ClientHeight, ClientWidth,
                             Drive );

            break;

        case IDM_VIEW_FAT_BOOT:
            if (NULL == (boot_edit = NEW DOS_BOOT_EDIT)) {
                ReportError(hwndChild, 0);
                break;
            }

            IoCouple->EditObject->KillFocus(hwndChild);
            DELETE(IoCouple->OtherEditObject);
            IoCouple->OtherEditObject = IoCouple->EditObject;
            IoCouple->EditObject = boot_edit;
            IoCouple->IoObject->GetBuf(&size);
            IoCouple->EditObject->SetBuf(hwndChild,
                                         IoCouple->IoObject->GetBuf(), size);
            IoCouple->EditObject->SetFocus(hwndChild);
            InvalidateRect(hwndChild, NULL, TRUE);

            break;

        case IDM_VIEW_NTFS_BOOT:
            if (ntboot_edit = NEW NTFS_BOOT_EDIT) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = ntboot_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(ntboot_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_PARTITION_TABLE:

            if ( (part_edit = NEW PARTITION_TABLE_EDIT) &&
                part_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = part_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {

                DELETE( part_edit );
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_GPT:

            if ( (guid_part_edit = NEW GUID_PARTITION_TABLE_EDIT) &&
                guid_part_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = guid_part_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {

                DELETE( guid_part_edit );
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_RESTART_AREA:

            if ((rest_area_edit = NEW RESTART_AREA_EDIT) &&
                rest_area_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive )) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = rest_area_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(rest_area_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_RECORD_PAGE:

            if ((rec_page_edit = NEW RECORD_PAGE_EDIT) &&
                rec_page_edit->Initialize(hwndChild, ClientHeight, ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = rec_page_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(rec_page_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_LOG_RECORD:

            if ((log_rec_edit = NEW LOG_RECORD_EDIT) &&
                log_rec_edit->Initialize(hwndChild, ClientHeight,
                    ClientWidth, Drive)) {

                IoCouple->EditObject->KillFocus(hwndChild);
                DELETE(IoCouple->OtherEditObject);
                IoCouple->OtherEditObject = IoCouple->EditObject;
                IoCouple->EditObject = log_rec_edit;
                IoCouple->IoObject->GetBuf(&size);
                IoCouple->EditObject->SetBuf(hwndChild,
                    IoCouple->IoObject->GetBuf(), size);
                IoCouple->EditObject->SetFocus(hwndChild);
                InvalidateRect(hwndChild, NULL, TRUE);

            } else {
                DELETE(log_rec_edit);
                ReportError(hWnd, 0);
            }
            break;

        case IDM_VIEW_LAST:
            IoCouple->EditObject->KillFocus(hwndChild);
            tmp_edit = IoCouple->EditObject;
            IoCouple->EditObject = IoCouple->OtherEditObject;
            IoCouple->OtherEditObject = tmp_edit;
            IoCouple->EditObject->SetFocus(hwndChild);
            InvalidateRect(hwndChild, NULL, TRUE);
            break;

        case IDM_VIEW_SPLIT:

            SplitView(hWnd, eSplitToggle);
            break;

        case IDM_WRITE_IT:
            if (!IoCouple->IoObject->Write()) {
                ReportError(hWnd, 0);
            }
            break;

        case IDM_CRACK_NTFS:
            if (DialogBox(hInst, TEXT("InputPathBox"), hWnd, InputPath)) {
                CrackNtfsPath(hWnd);
            }
            break;

        case IDM_CRACK_FAT:
            if (DialogBox(hInst, TEXT("InputPathBox"), hWnd, InputPath)) {
                CrackFatPath(hWnd);
            }
            break;

        case IDM_CRACK_LSN:
            if (DialogBox(hInst, TEXT("CrackLsnBox"), hWnd, InputLsn)) {
                 CrackLsn(hWnd);
            }
            break;

        case IDM_CRACK_NEXT_LSN:
            if (DialogBox(hInst, TEXT("CrackNextLsnBox"), hWnd, InputLsn)) {
                 CrackNextLsn(hWnd);
            }
            break;

        case IDM_BACKTRACK_FRS:

            if (DialogBox(hInst, TEXT("BacktrackFrsBox"), hWnd, FrsNumberDialogProc)) {

                BacktrackFrsFromScratch(hWnd, BacktrackFileNumber);
            }
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);

        }
        break;

    case WM_PAINT:
        hDC = BeginPaint(hWnd, &ps);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        IoCouple->EditObject->KillFocus(hwndChild);
        IoList->DeleteAllMembers();
        DELETE(IoListIterator);
        DELETE(IoList);
        DELETE(Drive);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);

    }

    return 0;
}


INT_PTR
About(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}


INT_PTR
OpenVolume(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    PREAD_CACHE rcache;

    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, TRUE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            DSTRING dos_name, nt_name, tmp_name;
            DSTRING volfile_name, volfile_path, backslash;
            TCHAR   volume_buf[32];
            TCHAR   volfile_buf[32];
            INT     n;

            n = GetDlgItemText(hDlg, IDTEXT, volume_buf, sizeof(volume_buf)/sizeof(TCHAR));
            volume_buf[n] = 0;

            n = GetDlgItemText(hDlg, IDTEXT2, volfile_buf, sizeof(volfile_buf)/sizeof(TCHAR));
            volfile_buf[n] = 0;

            DELETE(Drive);

            if (!backslash.Initialize("\\") ||
                !dos_name.Initialize(volume_buf)) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (dos_name.QueryChCount() > 0 &&
                dos_name.QueryChAt(0) >= '0' &&
                dos_name.QueryChAt(0) <= '9') {

                if (!nt_name.Initialize("\\device\\harddisk") ||
                    !nt_name.Strcat(&dos_name) ||
                    !tmp_name.Initialize("\\partition0") ||
                    !nt_name.Strcat(&tmp_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            } else {

                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dos_name,
                                                           &nt_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            }

            if (!volfile_name.Initialize(volfile_buf)) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (0 != wcslen(volfile_buf)) {

                if (!volfile_path.Initialize(&nt_name) ||
                    !volfile_path.Strcat(&backslash) ||
                    !volfile_path.Strcat(&volfile_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                if (NULL == (Drive = NEW LOG_IO_DP_DRIVE) ||
                    !Drive->Initialize(&nt_name, &volfile_path)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }

            } else {

                if (NULL == (Drive = NEW LOG_IO_DP_DRIVE) ||
                    !Drive->Initialize(&nt_name)) {

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
            }

            if ((rcache = NEW READ_CACHE) &&
                rcache->Initialize(Drive, 1024)) {

                Drive->SetCache(rcache);

            } else {
                DELETE(rcache);
            }

            if (IsDlgButtonChecked(hDlg, IDCHECKBOX) &&
                !Drive->Lock()) {

                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}


INT_PTR
InputPath(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    INT n;

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {
                n = GetDlgItemText(hDlg, IDTEXT, Path, MAX_PATH);
                Path[n] = 0;
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

INT_PTR
InputLsn(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    INT n;
    TCHAR buf[40];
    PTCHAR pch;

    switch (message) {
    case WM_INITDIALOG:
        wsprintf(buf, TEXT("%x:%x"), Lsn.HighPart, Lsn.LowPart);
        SetDlgItemText(hDlg, IDTEXT, buf);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {
            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;

            if (NULL == (pch = wcschr(buf, ':'))) {
                Lsn.HighPart = 0;
                swscanf(buf, TEXT("%x"), &Lsn.LowPart);
            } else {
                *pch = 0;
                swscanf(buf, TEXT("%x"), &Lsn.HighPart);
                swscanf(pch + 1, TEXT("%x"), &Lsn.LowPart);
                *pch = ':';
            }
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

static ULONG SeqNumberBits;

ULONG
GetLogPageSize(
    PLOG_IO_DP_DRIVE Drive
    )
{
    static ULONG PageSize;
    static BOOLEAN been_here = FALSE;
    static UCHAR buf[0x600];
    NTFS_SA         NtfsSa;
    MESSAGE         Msg;
    NTFS_MFT_FILE   Mft;
    NTFS_FILE_RECORD_SEGMENT Frs;
    NTFS_ATTRIBUTE  Attrib;
    PLFS_RESTART_PAGE_HEADER pRestPageHdr;
    PLFS_RESTART_AREA pRestArea;
    ULONG           bytes_read;
    BOOLEAN         error;

    if (been_here) {
        return PageSize;
    }

    pRestPageHdr = (PLFS_RESTART_PAGE_HEADER)buf;

    if (!Drive ||
        !NtfsSa.Initialize(Drive, &Msg) ||
        !NtfsSa.Read() ||
        !Mft.Initialize(Drive, NtfsSa.QueryMftStartingLcn(),
            NtfsSa.QueryClusterFactor(), NtfsSa.QueryFrsSize(),
            NtfsSa.QueryVolumeSectors(), NULL, NULL) ||
        !Mft.Read() ||
        !Frs.Initialize((VCN)LOG_FILE_NUMBER, &Mft) ||
        !Frs.Read() ||
        !Frs.QueryAttribute(&Attrib, &error, $DATA) ||
        !Attrib.Read((PVOID)pRestPageHdr, 0, 0x600,
            &bytes_read) ||
        bytes_read != 0x600) {

        return 0;
    }

    PageSize = pRestPageHdr->LogPageSize;

    pRestArea = PLFS_RESTART_AREA(PUCHAR(pRestPageHdr) + pRestPageHdr->RestartOffset);

    SeqNumberBits = pRestArea->SeqNumberBits;

    been_here = 1;
    return PageSize;
}

ULONG
GetSeqNumberBits(
    PLOG_IO_DP_DRIVE Drive
    )
{
    (void)GetLogPageSize(Drive);

    return SeqNumberBits;
}

BOOLEAN
SplitView(
    HWND hWnd,
    SPLIT_OPERATION Op
    )
{
    static BOOLEAN CheckState = FALSE;
    int flags;
    PSECTOR_EDIT        sector_edit;
    CREATESTRUCT cs;
    ULONG size;
    HMENU hMenu = GetMenu(hWnd);

    if (Op == eSplitToggle) {
        CheckState = !CheckState;
    } else if (Op == eSplitCreate) {
        CheckState = TRUE;
    } else if (Op == eSplitDestroy) {
        CheckState = FALSE;
    } else if (Op == eSplitQuery) {
        DebugAssert(hWnd == NULL);
        return CheckState;
    } else {
        return FALSE;
    }


    if (!CheckState) {
        // Destroy the extra window, remove the checkbox from
        // the menu entry.

        if (NULL == hwndSplit) {
            return 0;
        }

        DestroyWindow(hwndSplit);
        hwndSplit = NULL;
        flags = MF_BYCOMMAND | MF_UNCHECKED;
        if (hMenu == NULL) {
            return FALSE;
        }
        CheckMenuItem(hMenu, IDM_VIEW_SPLIT, flags);

        SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth, ClientHeight,
            SWP_SHOWWINDOW);

        IoCouple->EditObject->SetFocus(hwndChild);
        SetFocus(hwndChild);

        return TRUE;
    }

    //
    // Split the window.
    //

    memset(&cs, 0, sizeof(cs));

    cs.y = ClientWidth / 2;
    cs.x = 0;
    cs.cy = ClientWidth / 2;
    cs.cx = ClientHeight;

    hwndSplit = CreateWindow(TEXT("SplitWinClass"), TEXT("hwndSplit"),
        WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
        ClientWidth / 2, 0,
        ClientWidth / 2, ClientHeight,
        hWnd,
        NULL,
        hInst,
        &cs);

    if (NULL == hwndSplit) {
        int error = GetLastError();
        return FALSE;
    }

    SetWindowPos(hwndChild, HWND_TOP, 0, 0, ClientWidth / 2, ClientHeight,
        SWP_SHOWWINDOW);

    flags = MF_BYCOMMAND | MF_CHECKED;
    CheckMenuItem(hMenu, IDM_VIEW_SPLIT, flags);

    ShowWindow(hwndSplit, SW_SHOW);
    UpdateWindow(hwndSplit);

    if (NULL != IoCouple->SplitEditObject) {
        // use the existing edit object
        return TRUE;
    }

    if ((sector_edit = NEW SECTOR_EDIT) &&
        sector_edit->Initialize(hwndSplit, ClientHeight, ClientWidth / 2, Drive)) {

        IoCouple->SplitEditObject = sector_edit;

        IoCouple->IoObject->GetBuf(&size);
        IoCouple->SplitEditObject->SetBuf(hwndSplit,
            IoCouple->IoObject->GetBuf(), size);

        IoCouple->EditObject->SetFocus(hwndChild);
        SetFocus(hwndChild);

    } else {
        DELETE(sector_edit);
        DestroyWindow(hwndSplit);
        ReportError(hWnd, 0);
    }

    return TRUE;
}

LRESULT
ChildWndProc(
    IN  HWND    hwnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HDC                 hdc;
    PAINTSTRUCT         ps;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status;

    switch (message) {

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);

        IoCouple->EditObject->Paint(hdc, ps.rcPaint, hwnd);

        EndPaint(hwnd, &ps);
        return 0;


    case WM_CHAR:
        IoCouple->EditObject->Character(hwnd, (CHAR)wParam);
        break;

    case WM_VSCROLL:
        switch (LOWORD(wParam)) {
        case SB_LINEUP:
            IoCouple->EditObject->ScrollUp(hwnd);
            break;

        case SB_LINEDOWN:
            IoCouple->EditObject->ScrollDown(hwnd);
            break;

        case SB_PAGEUP:
            IoCouple->EditObject->PageUp(hwnd);
            break;

        case SB_PAGEDOWN:
            IoCouple->EditObject->PageDown(hwnd);
            break;

        case SB_THUMBPOSITION:
            IoCouple->EditObject->ThumbPosition(hwnd, HIWORD(wParam));
            break;

        default:
            break;

        }
        break;

    case WM_KEYDOWN:
        switch (LOWORD(wParam)) {
        case VK_UP:
            IoCouple->EditObject->KeyUp(hwnd);
            break;

        case VK_DOWN:
            IoCouple->EditObject->KeyDown(hwnd);
            break;

        case VK_LEFT:
            IoCouple->EditObject->KeyLeft(hwnd);
            break;

        case VK_RIGHT:
            IoCouple->EditObject->KeyRight(hwnd);
            break;

        case VK_PRIOR:
            IoCouple->EditObject->PageUp(hwnd);
            break;

        case VK_NEXT:
            IoCouple->EditObject->PageDown(hwnd);
            break;

        default:
            break;

        }
        break;

    case WM_SETFOCUS:
        IoCouple->EditObject->SetFocus(hwnd);
        break;

    case WM_KILLFOCUS:
        IoCouple->EditObject->KillFocus(hwnd);
        break;

    case WM_LBUTTONDOWN:
        IoCouple->EditObject->Click(hwnd, LOWORD(lParam), HIWORD(lParam));
        break;
    }

    return 0;
}


LRESULT
SplitWndProc(
    IN  HWND    hwnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HDC                 hdc;
    PAINTSTRUCT         ps;
    ULONG               size;
    WORD                command;
    BOOLEAN             error;
    ULONG               error_status;

    switch (message) {

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);

        if (NULL != IoCouple->SplitEditObject) {
            IoCouple->SplitEditObject->Paint(hdc, ps.rcPaint, hwnd);
        }

        EndPaint(hwnd, &ps);
        return 0;


    case WM_CHAR:
        IoCouple->SplitEditObject->Character(hwnd, (CHAR)wParam);
        break;

    case WM_VSCROLL:
        switch (LOWORD(wParam)) {
        case SB_LINEUP:
            IoCouple->SplitEditObject->ScrollUp(hwnd);
            break;

        case SB_LINEDOWN:
            IoCouple->SplitEditObject->ScrollDown(hwnd);
            break;

        case SB_PAGEUP:
            IoCouple->SplitEditObject->PageUp(hwnd);
            break;

        case SB_PAGEDOWN:
            IoCouple->SplitEditObject->PageDown(hwnd);
            break;

        case SB_THUMBPOSITION:
            IoCouple->SplitEditObject->ThumbPosition(hwnd, HIWORD(wParam));
            break;

        default:
            break;

        }
        break;

    case WM_KEYDOWN:
        switch (LOWORD(wParam)) {
        case VK_UP:
            IoCouple->SplitEditObject->KeyUp(hwnd);
            break;

        case VK_DOWN:
            IoCouple->SplitEditObject->KeyDown(hwnd);
            break;

        case VK_LEFT:
            IoCouple->SplitEditObject->KeyLeft(hwnd);
            break;

        case VK_RIGHT:
            IoCouple->SplitEditObject->KeyRight(hwnd);
            break;

        case VK_PRIOR:
            IoCouple->SplitEditObject->PageUp(hwnd);
            break;

        case VK_NEXT:
            IoCouple->SplitEditObject->PageDown(hwnd);
            break;

        default:
            break;

        }
        break;

    case WM_SETFOCUS:
        IoCouple->SplitEditObject->SetFocus(hwnd);
        break;

    case WM_KILLFOCUS:
        IoCouple->SplitEditObject->KillFocus(hwnd);
        break;

    case WM_LBUTTONDOWN:
        IoCouple->SplitEditObject->Click(hwnd, LOWORD(lParam), HIWORD(lParam));
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\edit.cxx ===
#include "ulib.hxx"
#include "edit.hxx"

EDIT_OBJECT::~EDIT_OBJECT(
    )
{
}


VOID
EDIT_OBJECT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
}

VOID
EDIT_OBJECT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
}


VOID
EDIT_OBJECT::ClientSize(
    IN  INT Height,
    IN  INT Width
    )
{
}


VOID
EDIT_OBJECT::ScrollUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::ScrollDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::PageUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::PageDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::ThumbPosition(
    IN  HWND    WindowHandle,
    IN  INT     NewThumbPosition
    )
{
}


VOID
EDIT_OBJECT::Click(
    IN  HWND    WindowHandle,
    IN  INT     Xcoordinate,
    IN  INT     Ycoordinate
    )
{
}


VOID
EDIT_OBJECT::KeyUp(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyDown(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyLeft(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::KeyRight(
    IN  HWND    WindowHandle
    )
{
}


VOID
EDIT_OBJECT::Character(
    IN  HWND    WindowHandle,
    IN  CHAR    Char
    )
{
}


VOID
EDIT_OBJECT::SetFocus(
    IN  HWND    WindowHandle
    )
{
    ::SetFocus(WindowHandle);
}


VOID
EDIT_OBJECT::KillFocus(
    IN  HWND    WindowHandle
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\frsio.cxx ===
#include "ulib.hxx"
#include "frsio.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

extern PLOG_IO_DP_DRIVE Drive;

STATIC ULONG FileNumber = 0;

BOOLEAN
FRS_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    NTFS_SA ntfssa;
    MESSAGE msg;
    HMEM    hmem;

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadFrsBox"),
                   WindowHandle, ReadFrs)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    _drive = Drive;
    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(_drive, &msg) ||
        !ntfssa.Read() ||
        !hmem.Initialize() ||
        !_frs.Initialize(&hmem, _drive,
                         ntfssa.QueryMftStartingLcn(),
                         ntfssa.QueryClusterFactor(),
                         ntfssa.QueryVolumeSectors(),
                         ntfssa.QueryFrsSize(),
                         NULL) ||
        !_frs.Read() ||
        !_frs.SafeQueryAttribute($DATA, &_mftdata, &_mftdata) ||
        !_frs.Initialize(Mem, &_mftdata, FileNumber,
                         ntfssa.QueryClusterFactor(),
                         ntfssa.QueryVolumeSectors(),
                         ntfssa.QueryFrsSize(),
                         NULL)) {

        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - File Record 0x%X"), FileNumber);

    return TRUE;
}


BOOLEAN
FRS_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_frs.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
FRS_IO::Write(
    )
{
    return _drive ? _frs.Write() : FALSE;
}


PVOID
FRS_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _frs.QuerySize();
    }

    return *((PVOID*) ((PCHAR) &_frs + 2*sizeof(PVOID)));
}


PTCHAR
FRS_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadFrs(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (message) {
    case WM_INITDIALOG:

            SetDlgItemText( hDlg, IDVOLUME, Drive->GetNtDriveName()->GetWSTR() );
            CheckDlgButton( hDlg, IDRADIO1, BST_CHECKED );
            return TRUE;

    case WM_COMMAND:


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;
                
                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;

                if (IsDlgButtonChecked( hDlg, IDRADIO2)) {
                    swscanf(buf, TEXT("%x"), &FileNumber);
                } else {

                    DSTRING                     path;
                    NTFS_SA                     ntfssa;
                    MESSAGE                     msg;
                    NTFS_MFT_FILE               mft;
                    NTFS_BITMAP_FILE            bitmap_file;
                    NTFS_ATTRIBUTE              bitmap_attribute;
                    NTFS_BITMAP                 volume_bitmap;
                    NTFS_UPCASE_FILE            upcase_file;
                    NTFS_ATTRIBUTE              upcase_attribute;
                    NTFS_UPCASE_TABLE           upcase_table;
                    NTFS_FILE_RECORD_SEGMENT    file_record;
                    BOOLEAN                     error;
                    BOOLEAN                     system_file;

                    if (!path.Initialize(buf)) {
                        wsprintf(buf, TEXT("Out of memory"));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
                        return FALSE;
                    } else if (!Drive ||
                        !ntfssa.Initialize(Drive, &msg) ||
                        !ntfssa.Read() ||
                        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                                        ntfssa.QueryClusterFactor(),
                                        ntfssa.QueryFrsSize(),
                                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
                        !mft.Read() ||
                        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
                        !bitmap_file.Read() ||
                        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
                        !volume_bitmap.Initialize(ntfssa.QueryVolumeSectors() /
                              (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
                        !volume_bitmap.Read(&bitmap_attribute) ||
                        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
                        !upcase_file.Read() ||
                        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
                        !upcase_table.Initialize(&upcase_attribute) ||
                        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                                        ntfssa.QueryClusterFactor(),
                                        ntfssa.QueryFrsSize(),
                                        ntfssa.QueryVolumeSectors(),
                                        &volume_bitmap,
                                        &upcase_table) ||
                        !mft.Read()) {
                    
                        swprintf(buf, TEXT("Could not init NTFS data structures"));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
                        return FALSE;
                    
                    } else if (!ntfssa.QueryFrsFromPath(&path, mft.GetMasterFileTable(),
                               &volume_bitmap, &file_record, &system_file, &error)) {
                            
                        wsprintf(buf, TEXT("File not found."));
                        MessageBox(hDlg, buf, TEXT("DiskEdit"), MB_OK|MB_ICONINFORMATION);
                        return FALSE;
                        
                    } else {
                        FileNumber = file_record.QueryFileNumber().GetLowPart();
                    }
                }
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\indxedit.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "indxedit.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"

extern "C" {
#include <stdio.h>
}

///////////////////////////////////////////////////////////////////////////////
//  Common support for USA fixups                                            //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
PostReadMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first verifies that the first element of the
    update sequence array is written at the end of every
    SEQUENCE_NUMBER_STRIDE bytes.  If not, then this routine
    returns FALSE.

    Otherwise this routine swaps the following elements in the
    update sequence array into the appropriate positions in the
    multi sector buffer.

    This routine will also check to make sure that the update
    sequence array is valid and that the BufferSize is appropriate
    for this size of update sequence array.  Otherwise, this
    routine will not update the array sequence and return TRUE.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    FALSE   - The last write to this buffer failed.
    TRUE    - There is no evidence that this buffer is bad.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return TRUE;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        if (*pnumber != parray[0]) {
            return FALSE;
        }

        *pnumber = parray[i];
    }

    return TRUE;
}


VOID
PreWriteMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first checks to see if the update sequence
    array is valid.  If it is then this routine increments the
    first element of the update sequence array.  It then
    writes the value of the first element into the buffer at
    the end of every SEQUENCE_NUMBER_STRIDE bytes while
    saving the old values of those locations in the following
    elements of the update sequence arrary.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    None.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    parray[0]++;

    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        parray[i] = *pnumber;
        *pnumber = parray[0];
    }
}

///////////////////////////////////////////////////////////////////////////////
//  Common support for viewing  indexes                                      //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
INDEX_BUFFER_BASE::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
INDEX_BUFFER_BASE::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

VOID
INDEX_BUFFER_BASE::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
INDEX_BUFFER_BASE::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
INDEX_BUFFER_BASE::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    if (0 != memcmp(_buffer, "INDX", 4) && 0 != memcmp(_buffer, "BAAD", 4)) {
        PaintIndexRoot(DeviceContext, InvalidRect, WindowHandle);
        return;
    }

    INT BytesRemaining = _size;
    PVOID CurrentBuffer = _buffer;
    INT   CurrentLine = 0;
    ULONG BufferNumber = 0;;

    while( BytesRemaining ) {

        // Resolve the update sequence array.  Note that we must
        // resolve it back before we exit this function, or else
        // write will get hosed.
        //
        PINDEX_ALLOCATION_BUFFER  IndexBuffer =
            (PINDEX_ALLOCATION_BUFFER)CurrentBuffer;

        INT BytesPerIndexBuffer =
            FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader ) +
                IndexBuffer->IndexHeader.BytesAvailable;

        ULONG CurrentOffset =
            BufferNumber * BytesPerIndexBuffer +
                FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader );

        PostReadMultiSectorFixup( CurrentBuffer, BytesPerIndexBuffer );

        swprintf(buf, TEXT("Signature: %c%c%c%c"),
                IndexBuffer->MultiSectorHeader.Signature[0],
                IndexBuffer->MultiSectorHeader.Signature[1],
                IndexBuffer->MultiSectorHeader.Signature[2],
                IndexBuffer->MultiSectorHeader.Signature[3]);
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("Update sequence array offset: %x"),
                IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset);
        WriteLine( DeviceContext, CurrentLine++, buf );


        swprintf(buf, TEXT("Update sequence array size: %x"),
                IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize);
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("This VCN: %x"), IndexBuffer->ThisVcn.GetLowPart() );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf(buf, TEXT("INDEX HEADER at offset %x"), CurrentOffset );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  FirstIndexEntry: \t%x"),
            IndexBuffer->IndexHeader.FirstIndexEntry );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  FirstFreeByte:   \t%x"),
            IndexBuffer->IndexHeader.FirstFreeByte );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  BytesAvailable:  \t%x"),
            IndexBuffer->IndexHeader.BytesAvailable );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Flags: \t\t%x"), IndexBuffer->IndexHeader.Flags );
        if( IndexBuffer->IndexHeader.Flags & INDEX_NODE ) {

            wcscat( buf, TEXT("\t INDEX_NODE "));
        }
        WriteLine( DeviceContext, CurrentLine++, buf );

        //
        // Don't print the Update Sequence Array--it's not interesting.
        //

        //
        // Now iterate through the index entries:
        //
        CurrentOffset += IndexBuffer->IndexHeader.FirstIndexEntry;

        WalkAndPaintIndexRecords( DeviceContext, CurrentOffset, CurrentLine );

        PreWriteMultiSectorFixup( CurrentBuffer, BytesPerIndexBuffer );

        if( BytesRemaining <= BytesPerIndexBuffer ) {

            BytesRemaining = 0;

        } else {

            BytesRemaining -= BytesPerIndexBuffer;
            CurrentBuffer = (PBYTE)CurrentBuffer + BytesPerIndexBuffer;
            BufferNumber++;

            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("****************************************") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("****************************************") );
            WriteLine( DeviceContext, CurrentLine++, TEXT("") );
        }
    }

    SetRange(WindowHandle, CurrentLine + 50);
}


VOID
INDEX_BUFFER_BASE::PaintIndexRoot(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    INT BytesRemaining = _size;
    PVOID CurrentBuffer = _buffer;
    INT CurrentLine = 0;
    ULONG BufferNumber = 0;
    PINDEX_ROOT IndexRoot = (PINDEX_ROOT)CurrentBuffer;

    ULONG BytesPerIndexRoot =
        FIELD_OFFSET(INDEX_ROOT, IndexHeader ) +
            IndexRoot->IndexHeader.BytesAvailable;

    ULONG CurrentOffset = FIELD_OFFSET(INDEX_ROOT, IndexHeader);

    swprintf(buf, TEXT("Attribute type code: %x"),
        IndexRoot->IndexedAttributeType);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Collation rule: %x"), IndexRoot->CollationRule);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Bytes Per Index Buffer: %x"),
            IndexRoot->BytesPerIndexBuffer);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("Clusters Per Index Buffer: %x"),
            IndexRoot->ClustersPerIndexBuffer);
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf(buf, TEXT("INDEX HEADER at offset %x"), CurrentOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  FirstIndexEntry: \t%x"),
        IndexRoot->IndexHeader.FirstIndexEntry );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  FirstFreeByte:   \t%x"),
        IndexRoot->IndexHeader.FirstFreeByte );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  BytesAvailable:  \t%x"),
        IndexRoot->IndexHeader.BytesAvailable );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("  Flags: \t\t%x"), IndexRoot->IndexHeader.Flags );
    if( IndexRoot->IndexHeader.Flags & INDEX_NODE ) {

        wcscat( buf, TEXT("\t INDEX_NODE "));
    }
    WriteLine( DeviceContext, CurrentLine++, buf );

    //
    // Now iterate through the index entries:
    //
    CurrentOffset += IndexRoot->IndexHeader.FirstIndexEntry;

    WalkAndPaintIndexRecords( DeviceContext, CurrentOffset, CurrentLine );
}


VOID
INDEX_BUFFER_BASE::WalkAndPaintIndexRecords(
    IN HDC      DeviceContext,
    IN ULONG    Offset,
    IN OUT int &CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  Iterate through the index entries:
    //
    while( Offset < _size ) {

        PINDEX_ENTRY CurrentEntry = (PINDEX_ENTRY)((PBYTE)_buffer + Offset);

        //
        // check for corruption that will mess up the loop--if
        // the length of the current entry is zero or would overflow
        // the buffer, exit.
        //
        if( CurrentEntry->Length == 0  ||
            Offset + CurrentEntry->Length > _size ) {

            // Don't need to comment on the corruption--the user
            // can recognize it by noting that the last entry
            // is not an END entry.
            //
            break;
        }

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("INDEX ENTRY at offset %x"), Offset );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Length: \t %x"), CurrentEntry->Length );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Value Length:  %x"), CurrentEntry->AttributeLength );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Flags: \t %x"), CurrentEntry->Flags );
        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            wcscat( buf, TEXT(" INDEX_ENTRY_NODE") );
        }
        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            wcscat( buf, TEXT(" INDEX_ENTRY_END") );
        }
        WriteLine( DeviceContext, CurrentLine++, buf );

        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            swprintf( buf, TEXT("  Downpointer: %x"), (GetDownpointer(CurrentEntry)).GetLowPart() );
            WriteLine( DeviceContext, CurrentLine++, buf );
        }

        //
        // If the current entry is the END entry, we're done.
        //
        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            break;
        }

        if( sizeof( INDEX_ENTRY ) + CurrentEntry->AttributeLength >
            CurrentEntry->Length ) {

            swprintf( buf, TEXT("  ***Attribute value overflows entry.") );
            WriteLine( DeviceContext, CurrentLine++, buf );

        } else {
            PaintIndexRecord( DeviceContext, CurrentEntry, CurrentLine );
        }

        Offset += CurrentEntry->Length;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  Support for viewing namespace indexes                                    //
///////////////////////////////////////////////////////////////////////////////


VOID
NAME_INDEX_BUFFER_EDIT::PaintIndexRecord (
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];
    PFILE_NAME FileName;
    ULONG i, j;

    swprintf( buf, TEXT("  File Reference (FRS, Seq No): %x, %x"),
                     CurrentEntry->FileReference.LowPart,
                     CurrentEntry->FileReference.SequenceNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );

    // This had better be a file name attribute, since
    // that's how I'll display it.
    //
    swprintf( buf, TEXT("  FILE NAME at offset %x"),
              (PCHAR) CurrentEntry - (PCHAR) _buffer + sizeof( INDEX_ENTRY ) );
    FileName = (PFILE_NAME)( (PBYTE)CurrentEntry + sizeof(INDEX_ENTRY) );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Parent Directory (FRS, Seq No): %x, %x"),
             FileName->ParentDirectory.LowPart,
             FileName->ParentDirectory.SequenceNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Name Length: %x"), FileName->FileNameLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    Flags: \t %x"), FileName->Flags );
    if( FileName->Flags & FILE_NAME_DOS ) {

        wcscat( buf, TEXT(" D") );
    }
    if( FileName->Flags & FILE_NAME_NTFS ) {

        wcscat( buf, TEXT(" N") );
    }
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("    File name:   ") );
    j = wcslen( buf );

    for( i = 0; i < FileName->FileNameLength; i++ ) {

        buf[i+j] = (TCHAR)(FileName->FileName[i]);
    }
    buf[FileName->FileNameLength+j] = 0;
    WriteLine( DeviceContext, CurrentLine++, buf );
}

///////////////////////////////////////////////////////////////////////////////
//  Support for viewing Security Id indexes                                  //
///////////////////////////////////////////////////////////////////////////////

VOID
SECURITY_ID_INDEX_BUFFER_EDIT::PaintIndexRecord(
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  This had better be a security id index record.  The format of
    //  the record is:
    //
    //      INDEX_ENTRY
    //          DataOffset
    //          DataLength
    //      SECURITY_ID
    //      SECURITY_DESCRIPTOR_HEADER
    //

    swprintf( buf, TEXT( "  DataOffset %x" ), CurrentEntry->DataOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  DataLength %x" ), CurrentEntry->DataLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    PULONG SecurityId = (PULONG) ((PBYTE)CurrentEntry + sizeof( INDEX_ENTRY ));
    PSECURITY_DESCRIPTOR_HEADER Header =
        (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)CurrentEntry + CurrentEntry->DataOffset);

    swprintf( buf, TEXT( "  Key Security Id %08x" ), *SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), Header->HashKey.Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), Header->HashKey.SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Offset %I64x" ), Header->Offset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Length %x" ), Header->Length );
    WriteLine( DeviceContext, CurrentLine++, buf );
}

///////////////////////////////////////////////////////////////////////////////
//  Support for viewing Security Hash indexes                                //
///////////////////////////////////////////////////////////////////////////////

VOID
SECURITY_HASH_INDEX_BUFFER_EDIT::PaintIndexRecord(
    IN HDC          DeviceContext,
    IN PINDEX_ENTRY CurrentEntry,
    IN OUT int &  CurrentLine
    )
{
    TCHAR buf[1024];

    //
    //  This had better be a security id index record.  The format of
    //  the record is:
    //
    //      INDEX_ENTRY
    //          DataOffset
    //          DataLength
    //      SECURITY_HASHKEY
    //      SECURITY_DESCRIPTOR_HEADER
    //

    swprintf( buf, TEXT( "  DataOffset %x" ), CurrentEntry->DataOffset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  DataLength %x" ), CurrentEntry->DataLength );
    WriteLine( DeviceContext, CurrentLine++, buf );

    PSECURITY_HASH_KEY HashKey = (PSECURITY_HASH_KEY) ((PBYTE)CurrentEntry + sizeof( INDEX_ENTRY ));
    PSECURITY_DESCRIPTOR_HEADER Header =
        (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)CurrentEntry + CurrentEntry->DataOffset);

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), HashKey->Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), HashKey->SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.Hash %08x" ), Header->HashKey.Hash );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  HashKey.SecurityId %08x" ), Header->HashKey.SecurityId );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Offset %I64x" ), Header->Offset );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "  Header.Length %x" ), Header->Length );
    WriteLine( DeviceContext, CurrentLine++, buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\frsedit.cxx ===
#include "ulib.hxx"
#include "frsedit.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "attrlist.hxx"
#include "crack.hxx"

extern "C" {
#include <stdio.h>
}


BOOLEAN
FRS_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read()) {

        return FALSE;
    }

    _cluster_factor = ntfssa.QueryClusterFactor();
    _frs_size = ntfssa.QueryFrsSize();

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
FRS_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

STATIC  TCHAR  buf[1024];

VOID
FRS_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    INT                             nDrawX, nDrawY;
    INT                             CurrentLine;
    PCFILE_RECORD_SEGMENT_HEADER    pfrs;
    TCHAR                           sbFlags[32];

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || !_size) {
        return;
    }

    pfrs = (PCFILE_RECORD_SEGMENT_HEADER) _buffer;

    CurrentLine = 0;

    swprintf(buf, TEXT("FILE_RECORD_SEGMENT_HEADER {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    MULTI_SECTOR_HEADER MultiSectorHeader {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Signature: \t\t\t%c%c%c%c"),
            pfrs->MultiSectorHeader.Signature[0],
            pfrs->MultiSectorHeader.Signature[1],
            pfrs->MultiSectorHeader.Signature[2],
            pfrs->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Update sequence array offset: \t%x"),
            pfrs->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Update sequence array size: \t%x"),
            pfrs->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Lsn: \t\t\t<%x,%x>"), pfrs->Lsn.HighPart,
        pfrs->Lsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Sequence number: \t\t%x"), pfrs->SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Reference count: \t\t%x"),
            pfrs->ReferenceCount);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    First attribute offset: \t%x"),
         pfrs->FirstAttributeOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfrs->Flags & FILE_RECORD_SEGMENT_IN_USE) {
        wcscpy(sbFlags, TEXT("U"));
    } else {
        wcscpy(sbFlags, TEXT(" "));
    }
    if (pfrs->Flags & FILE_FILE_NAME_INDEX_PRESENT) {
        wcscat(sbFlags, TEXT("I"));
    }
    swprintf(buf, TEXT("    Flags: \t\t\t%x \t%s"), pfrs->Flags, sbFlags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    First free byte: \t\t%x"), pfrs->FirstFreeByte);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Bytes available: \t\t%x"), pfrs->BytesAvailable);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    FILE_REFERENCE BaseFileRecordSegment {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        LowPart: \t %x"),
         pfrs->BaseFileRecordSegment.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Sequence number: %x"),
        pfrs->BaseFileRecordSegment.SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    Next attribute instance: %x"),
             pfrs->NextAttributeInstance);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfrs->MultiSectorHeader.UpdateSequenceArrayOffset >=
        FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {
        swprintf(buf, TEXT("    Segment Number:          <%x,%x>"),
                 pfrs->SegmentNumberHighPart, pfrs->SegmentNumberLowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);
    }

    swprintf(buf, TEXT("}"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    // At this point enumerate all of the attribute records.

    NTFS_FRS_STRUCTURE          frs;
    PATTRIBUTE_RECORD_HEADER    prec;
    NTFS_ATTRIBUTE_RECORD       attrrec;
    DSTRING                     record_name;
    PWSTR                       pstr;
    CONT_MEM                    cmem;

    if (!cmem.Initialize(_buffer, _size) ||
        !frs.Initialize(&cmem, _drive, 0, _cluster_factor,
                        0, _frs_size, NULL)) {
        return;
    }

    prec = NULL;
    while (prec = (PATTRIBUTE_RECORD_HEADER) frs.GetNextAttributeRecord(prec)) {

        if (!attrrec.Initialize(NULL, prec) ||
            !attrrec.QueryName(&record_name) ||
            !(pstr = record_name.QueryWSTR())) {
            return;
        }

        swprintf(buf, TEXT("ATTRIBUTE_RECORD_HEADER at offset %x {"), (PCHAR) prec - (PCHAR) pfrs);
        WriteLine(DeviceContext, CurrentLine++, buf);

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(prec->TypeCode);

        swprintf(buf, TEXT("    Type code, name: \t%x (%s), %s"), prec->TypeCode,
            NULL == SymbolicTypeCode ? TEXT("unknown") : SymbolicTypeCode,
            pstr);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Record length: \t%x"), prec->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Form code: \t\t%x"), prec->FormCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Name length: \t%x"), prec->NameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Name offset: \t%x"), prec->NameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        if (prec->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) {
            wcscpy(sbFlags, TEXT("C"));
        } else {
            sbFlags[0] = '\0';
        }
        swprintf(buf, TEXT("    Flags: \t\t%x \t%s"), prec->Flags, sbFlags);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    Instance: \t\t%x"), prec->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);
        CurrentLine++;

        if (!(prec->FormCode & NONRESIDENT_FORM)) {

            //
            // Resident Attribute
            //

            swprintf(buf, TEXT("    Resident form {"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("        Value length: \t%x"),
                    prec->Form.Resident.ValueLength);
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("        Value offset: \t%x"),
                    prec->Form.Resident.ValueOffset);
            WriteLine(DeviceContext, CurrentLine++, buf);

            if (prec->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) {
                wcscpy(sbFlags, TEXT("I"));
            } else {
                sbFlags[0] = '\0';
            }
            swprintf(buf, TEXT("        Resident flags: %x \t%s"),
                    prec->Form.Resident.ResidentFlags, sbFlags);
            WriteLine(DeviceContext, CurrentLine++, buf);

            swprintf(buf, TEXT("    }"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            __try {

                if ($FILE_NAME == prec->TypeCode) {
                    DisplayFileName(prec, DeviceContext, CurrentLine);
                } else if ($ATTRIBUTE_LIST == prec->TypeCode) {
                    DisplayAttrList(prec, DeviceContext, CurrentLine);
                } else if ($STANDARD_INFORMATION == prec->TypeCode) {
                    DisplayStandardInformation( prec, DeviceContext, CurrentLine );
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                swprintf(buf, TEXT("[ADDRESS ERROR]"));
                WriteLine(DeviceContext, CurrentLine++, buf);
            }

            swprintf(buf, TEXT("}"));
            WriteLine(DeviceContext, CurrentLine++, buf);

            CurrentLine++;

            DELETE(pstr);
            continue;
        }

        //
        // Nonresident Attribute
        //

        swprintf(buf, TEXT("    Nonresident form {"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Lowest vcn: \t\t%x"),
                prec->Form.Nonresident.LowestVcn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Highest vcn: \t\t%x"),
                prec->Form.Nonresident.HighestVcn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Mapping pairs offset: \t%x"),
                prec->Form.Nonresident.MappingPairsOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Compression unit: \t%x"),
                prec->Form.Nonresident.CompressionUnit);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Allocated length: \t%x"),
                prec->Form.Nonresident.AllocatedLength.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        File size: \t\t%x"),
                prec->Form.Nonresident.FileSize.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("        Valid data length: \t%x"),
                prec->Form.Nonresident.ValidDataLength.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        if ((prec->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) != 0) {
            swprintf(buf, TEXT("        Total allocated: \t%x"),
                    prec->Form.Nonresident.TotalAllocated.LowPart);
            WriteLine(DeviceContext, CurrentLine++, buf);
        }

        NTFS_EXTENT_LIST    extents;
        BIG_INT             vcn, lcn, run_length;
        ULONG               i;

        if (!attrrec.QueryExtentList(&extents)) {
            return;
        }

        swprintf(buf, TEXT("        Extent list {"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        for (i = 0; i < extents.QueryNumberOfExtents(); i++) {

            nDrawY = CurrentLine * QueryCharHeight();

            if (nDrawY < QueryScrollPosition()*QueryCharHeight()) {
                nDrawY += QueryCharHeight();
                CurrentLine++;
                continue;
            }

            if (nDrawY > QueryScrollPosition()*QueryCharHeight() +
                         QueryClientHeight()) {

                break;
            }

            if (!extents.QueryExtent(i, &vcn, &lcn, &run_length)) {
                break;
            }

            swprintf(buf, TEXT("            (vcn, lcn, run length): (%x, %x, %x)"),
                    vcn.GetLowPart(), lcn.GetLowPart(), run_length.GetLowPart());
            WriteLine(DeviceContext, CurrentLine++, buf);
        }

        swprintf(buf, TEXT("        }"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    }"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("}"));
        WriteLine(DeviceContext, CurrentLine++, buf);

        CurrentLine++;

        DELETE(pstr);
    }

    SetRange(WindowHandle, CurrentLine - 1);
}


VOID
FRS_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
FRS_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
FRS_EDIT::DisplayStandardInformation(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PSTANDARD_INFORMATION2 Info2;
    PSTANDARD_INFORMATION  Info;
    PTCHAR   pc;
    TCHAR    sbFlags[32];

    Info  = (PSTANDARD_INFORMATION ) ((PCHAR)pRec + pRec->Form.Resident.ValueOffset);
    Info2 = (PSTANDARD_INFORMATION2) ((PCHAR)pRec + pRec->Form.Resident.ValueOffset);

    swprintf( buf, TEXT( "    CreationTime:         %16I64x" ), Info->CreationTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastModificationTime: %16I64x" ), Info->LastModificationTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastChangeTime:       %16I64x" ), Info->LastChangeTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    LastAccessTime:       %16I64x" ), Info->LastAccessTime );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    FileAttributes:   %08lx" ), Info->FileAttributes );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    MaximumVersions:  %08lx" ), Info->MaximumVersions );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT( "    VersionNumber:    %08lx" ), Info->VersionNumber );
    WriteLine( DeviceContext, CurrentLine++, buf );


    if (pRec->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION2 )) {
        swprintf( buf, TEXT( "    ClassId:    %08lx" ), Info2->ClassId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    OwnerId:    %08lx" ), Info2->OwnerId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    SecurityId: %08lx" ), Info2->SecurityId );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    QuotaCharged: %16I64x" ), Info2->QuotaCharged );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT( "    Usn:          %16I64x" ), Info2->Usn );
        WriteLine( DeviceContext, CurrentLine++, buf );
    }
}

VOID
FRS_EDIT::DisplayFileName(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PFILE_NAME pfn;
    PTCHAR   pc;
    TCHAR    sbFlags[32];

    pfn = (PFILE_NAME)((PCHAR)pRec + pRec->Form.Resident.ValueOffset);

    swprintf(buf, TEXT("    File name: \t"));
    pc = buf + wcslen(buf);

    for (int i = 0; i < min(64, pfn->FileNameLength); ++i) {
        *pc++ = (CHAR)pfn->FileName[i];
    }
    *pc++ = '\0';

    if (pfn->FileNameLength > 64) {
        wcscat(buf, TEXT("..."));
    }

    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    FILE_REFERENCE ParentDirectory {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        LowPart: \t %x"),
         pfn->ParentDirectory.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("        Sequence number: %x"),
        pfn->ParentDirectory.SequenceNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (pfn->Flags & FILE_NAME_NTFS) {
        wcscpy(sbFlags, TEXT("N"));
    } else {
        wcscpy(sbFlags, TEXT(" "));
    }
    if (pfn->Flags & FILE_NAME_DOS) {
        wcscat(sbFlags, TEXT("D"));
    }
    swprintf(buf, TEXT("    Flags: \t%x \t%s"), pfn->Flags, sbFlags);
    WriteLine(DeviceContext, CurrentLine++, buf);
}

VOID
FRS_EDIT::DisplayAttrList(
    IN      PATTRIBUTE_RECORD_HEADER pRec,
    IN      HDC DeviceContext,
    IN OUT  INT &CurrentLine
    )
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    PTCHAR  pc;
    CHAR    sbFlags[32];
    ULONG   LengthOfList = pRec->Form.Resident.ValueLength;
    ULONG   CurrentOffset;

    swprintf(buf, TEXT("    Attribute List Data {"));
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)((PCHAR)pRec +
        pRec->Form.Resident.ValueOffset);
    CurrentOffset = 0;

    while (CurrentOffset < LengthOfList) {

        if (0 != CurrentOffset) {
            CurrentLine++;
        }

        PTCHAR SymbolicTypeCode = GetNtfsAttributeTypeCodeName(
            CurrentEntry->AttributeTypeCode);

        swprintf(buf, TEXT("\tAttribute type code: \t%x (%s)"),
            CurrentEntry->AttributeTypeCode, SymbolicTypeCode);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tRecord length \t\t%x"), CurrentEntry->RecordLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name length \t%x"),
            CurrentEntry->AttributeNameLength);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name offset \t%x"),
            CurrentEntry->AttributeNameOffset);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tLowest vcn \t\t<%x,%x>"),
            CurrentEntry->LowestVcn.GetHighPart(),
            CurrentEntry->LowestVcn.GetLowPart());
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tSegment reference: \t<%x,%x>"),
            CurrentEntry->SegmentReference.HighPart,
            CurrentEntry->SegmentReference.LowPart,
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tSequence number: \t%x"),
            CurrentEntry->SegmentReference.SequenceNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tInstance: \t\t%x"), CurrentEntry->Instance);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("\tAttribute name:\t\t"));
        pc = buf + wcslen(buf);

        for (int i = 0; i < min(64, CurrentEntry->AttributeNameLength); ++i) {
            *pc++ = (CHAR)CurrentEntry->AttributeName[i];
        }
        *pc++ = '\0';

        if (CurrentEntry->AttributeNameLength > 64) {
            wcscat(buf, TEXT("..."));
        }
        WriteLine(DeviceContext, CurrentLine++, buf);

        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry(CurrentEntry);
    }

    swprintf(buf, TEXT("    }"));
    WriteLine(DeviceContext, CurrentLine++, buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\gptedit.cxx ===
#include "ulib.hxx"
#include "gptedit.hxx"


extern "C" {
#include <stdio.h>
}

BOOLEAN
GUID_PARTITION_TABLE_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);

    return TRUE;
}


VOID
GUID_PARTITION_TABLE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}


VOID
GUID_PARTITION_TABLE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    GPT_HEADER                  header;
    PGPT_HEADER                 pgpth;
    GPT_ENTRY                   entry;
    PGPT_ENTRY                  pgpte;
    TEXTMETRIC                  textmetric;
    INT                         ch, CurrentLine;
    TCHAR                       buf[1024];
    ULONG                       i, *pul, blockSize, firstEntryOffset;
    PUCHAR                      pch; 

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    blockSize = 512;
    
    //
    // BUGBUG keithka 4/10/00 -- consider catching folks using either
    // sector 0 or an MBR by mistake?
    //
    pgpth = (PGPT_HEADER)((PBYTE)_buffer);

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    CurrentLine = 0;

    pch = (PUCHAR) &pgpth->Signature;
    swprintf( buf, TEXT("Signature:         %c%c%c%c%c%c%c%c"), 
              pch[0], pch[1], pch[2], pch[3], pch[4], pch[5], pch[6], pch[7] );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("Revision:          0x%x"), pgpth->Revision );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("HeaderSize:        0x%x"), pgpth->HeaderSize );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("HeaderCRC32:       0x%x"), pgpth->HeaderCRC32 );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("MyLBA:             0x%x"), pgpth->MyLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("AlternateLBA:      0x%x"), pgpth->AlternateLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("FirstUsableLBA:    0x%x"), pgpth->FirstUsableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("LastUsableLBA:     0x%x"), pgpth->LastUsableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

//    swprintf( buf, TEXT("DiskGUID: 0x%x"), pgpth->DiskGUID );
//    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("TableLBA:          0x%x"), pgpth->TableLBA );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("Entries Allocated: 0x%x"), pgpth->EntriesAllocated );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("SizeOfGPT_ENTRY:   0x%x"), pgpth->SizeOfGPT_ENTRY );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    swprintf( buf, TEXT("TableCRC32:        0x%x"), pgpth->TableCRC32 );
    WriteLine( DeviceContext, CurrentLine++, buf );    

    // Compute the sector checksum.  BUGBUG keithka 4/10/00 -- consider???
    //

    swprintf( buf, TEXT("") );
    WriteLine( DeviceContext, CurrentLine++, buf );

    if (pgpth->MyLBA >= pgpth->TableLBA) {

        swprintf( buf, TEXT("MyLBA >= TableLBA, corrupt GPT?") );
        WriteLine( DeviceContext, CurrentLine++, buf );

    } else {

        firstEntryOffset = (ULONG) (blockSize * (pgpth->TableLBA - pgpth->MyLBA));
        
        pgpte = (PGPT_ENTRY) ((PBYTE)pgpth + firstEntryOffset);
        
        for( i = 0; i < pgpth->EntriesAllocated; i++ ) {

            if( (firstEntryOffset + (i + 1) * sizeof(GPT_ENTRY)) > _size ) {

                // About to read beyond our buffer.
                //
                break;
            }

            swprintf( buf, TEXT("Entry %d"), i );
            WriteLine( DeviceContext, CurrentLine++, buf );

//            swprintf( buf, TEXT("  PartitionType: 0x%x"), pgpte->PartitionType );
//            WriteLine( DeviceContext, CurrentLine++, buf );

//            swprintf( buf, TEXT("  PartitionID:   0x%x"), pgpte->PartitionID );
//            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Starting LBA:  0x%x"), pgpte->StartingLBA );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Ending LBA:    0x%x"), pgpte->EndingLBA );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  Attributes:    0x%x"), pgpte->Attributes );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("  PartitionName: %s"), pgpte->PartitionName );
            WriteLine( DeviceContext, CurrentLine++, buf );

            swprintf( buf, TEXT("") );
            WriteLine( DeviceContext, CurrentLine++, buf );

            pgpte++;
        }

        if (0 == i) {

            swprintf( buf, TEXT("No valid GPT entries in the range read") );
            WriteLine( DeviceContext, CurrentLine++, buf );
        }
    }

    SetRange(WindowHandle, CurrentLine - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\fileio.cxx ===
#include "ulib.hxx"
#include "fileio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC TCHAR FilePath[MAX_PATH];

BOOLEAN
FILE_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadFileBox"),
                   WindowHandle, ReadTheFile)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    _file_handle = CreateFile(FilePath, GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!_buffer_size) {
        _buffer_size = GetFileSize(_file_handle, NULL);
    }

    if (_buffer_size == (ULONG) -1) {
        return FALSE;
    }

    _buffer = Mem->Acquire(_buffer_size, Drive->QueryAlignmentMask());
    if (!_buffer) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("%s"), FilePath);

    return TRUE;
}


BOOLEAN
FILE_IO::Read(
    OUT PULONG  pError
    )
{
    DWORD   bytes_read;

    *pError = 0;

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (SetFilePointer(_file_handle, 0, NULL, FILE_BEGIN) == (DWORD) -1) {
        return FALSE;
    }

    if (!ReadFile(_file_handle, _buffer, _buffer_size, &bytes_read, NULL) ||
        bytes_read != _buffer_size) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
FILE_IO::Write(
    )
{
    DWORD   bytes_written;

    if (_file_handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (SetFilePointer(_file_handle, 0, NULL, FILE_BEGIN) == (DWORD) -1) {
        return FALSE;
    }

    if (!WriteFile(_file_handle, _buffer, _buffer_size, &bytes_written, NULL) ||
        bytes_written != _buffer_size) {

        return FALSE;
    }

    if (!SetEndOfFile(_file_handle)) {
        return FALSE;
    }

    return TRUE;
}


PVOID
FILE_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
FILE_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadTheFile(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, FilePath, sizeof(FilePath)/sizeof(TCHAR));
                FilePath[n] = 0;

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\io.cxx ===
#include "ulib.hxx"
#include "io.hxx"


STATIC TCHAR HeaderText[] = { 'D', 'i', 's', 'k', 'E', 'd', 'i', 't', 0 };


IO_OBJECT::~IO_OBJECT(
    )
{
}


BOOLEAN
IO_OBJECT::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    *Error = FALSE;
    return TRUE;
}


BOOLEAN
IO_OBJECT::Read(
    OUT PULONG  pError
    )
{
    return TRUE;
}


BOOLEAN
IO_OBJECT::Write(
    )
{
    return TRUE;
}


PVOID
IO_OBJECT::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = 0;
    }
    return NULL;
}


PTCHAR
IO_OBJECT::GetHeaderText(
    )
{
    return HeaderText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\lfsdisk.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsDisk.h

Abstract:

    This module defines the on-disk structures present in the log file.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

IMPORTANT NOTE:

    The Log File Service will by used on systems that require that on-disk
    structures guarantee the natural alignment of all arithmetic quantities
    up to and including quad-word (64-bit) numbers.  Therefore, all Lfs
    on-disk structures are quad-word aligned, etc.

--*/

#ifndef _LFSDISK_
#define _LFSDISK_

#define MINIMUM_LFS_PAGES               0x00000030
#define MINIMUM_LFS_CLIENTS             1

//
//  The following macros are used to set and query with respect to the
//  update sequence arrays.
//

#define UpdateSequenceStructureSize( MSH )              \
    ((((PMULTI_SECTOR_HEADER) (MSH))->UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE)

#define UpdateSequenceArraySize( STRUCT_SIZE )          \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1)

#define FIRST_STRIDE                                    \
    (SEQUENCE_NUMBER_STRIDE - sizeof( UPDATE_SEQUENCE_NUMBER ))


//
//  Log client ID.  This is used to uniquely identify a client for a
//  particular log file.
//

typedef struct _LFS_CLIENT_ID {

    USHORT SeqNumber;
    USHORT ClientIndex;

} LFS_CLIENT_ID, *PLFS_CLIENT_ID;


//
//  Log Record Header.  This is the header that begins every Log Record in
//  the log file.
//

typedef struct _LFS_RECORD_HEADER {

    //
    //  Log File Sequence Number of this log record.
    //

    LSN ThisLsn;

    //
    //  The following fields are used to back link Lsn's.  The ClientPrevious
    //  and ClientUndoNextLsn fields are used by a client to link his log
    //  records.
    //

    LSN ClientPreviousLsn;
    LSN ClientUndoNextLsn;

    //
    //  The following field is the size of data area for this record.  The
    //  log record header will be padded if necessary to fill to a 64-bit
    //  boundary, so the client data will begin on a 64-bit boundary to
    //  insure that all of his data is 64-bit aligned.  The below value
    //  has not been padded to 64 bits however.
    //

    ULONG ClientDataLength;

    //
    //  Client ID.  This identifies the owner of this log record.  The owner
    //  is uniquely identified by his offset in the client array and the
    //  sequence number associated with that client record.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  This the Log Record type.  This could be a commit protocol record,
    //  a client restart area or a client update record.
    //

    LFS_RECORD_TYPE RecordType;

    //
    //  Transaction ID.  This is used externally by a client (Transaction
    //  Manager) to group log file entries.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Log record flags.
    //

    USHORT Flags;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

} LFS_RECORD_HEADER, *PLFS_RECORD_HEADER;

#define LOG_RECORD_MULTI_PAGE           (0x0001)

#define LFS_RECORD_HEADER_SIZE          QuadAlign( sizeof( LFS_RECORD_HEADER ))


//
//  Following are the version specific fields in the record page header.
//

typedef struct _LFS_UNPACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    //
    //  Reserved.  The following array is reserved for possible future use.
    //

    USHORT Reserved;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_UNPACKED_RECORD_PAGE, *PLFS_UNPACKED_RECORD_PAGE;

typedef struct _LFS_PACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    ULONG DWordAlign;

    //
    //  The following is the Lsn for the last log record which ends on the page.
    //

    LSN LastEndLsn;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_PACKED_RECORD_PAGE, *PLFS_PACKED_RECORD_PAGE;


//
//  Log Record Page Header.  This structure is present at the beginning of each
//  log file page in the client record section.
//

typedef struct _LFS_RECORD_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    union {

        //
        //  Highest Lsn in this log file page.  This field is only for
        //  regular log pages.
        //

        LSN LastLsn;

        //
        //  Log file offset.  This is for the tail copies and indicates the
        //  location in the file where the original lays.  In this case the
        //  LastLsn field above can be obtained from the last ending Lsn
        //  field in the PACKED_RECORD_PAGE structure.
        //

        LONGLONG FileOffset;

    } Copy;

    //
    //  Page Header Flags.  These are the same flags that are stored in the
    //  Lbcb->Flags field.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //

    ULONG Flags;

    //
    //  I/O Page Position.  The following fields are used to determine
    //  where this log page resides within a Lfs I/O transfer.
    //

    USHORT PageCount;
    USHORT PagePosition;

    //
    //  The following is the difference between version 1.1 and earlier.
    //

    union {

        LFS_UNPACKED_RECORD_PAGE Unpacked;
        LFS_PACKED_RECORD_PAGE Packed;

    } Header;

} LFS_RECORD_PAGE_HEADER, *PLFS_RECORD_PAGE_HEADER;

#define LOG_PAGE_LOG_RECORD_END             (0x00000001)

#define LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE        (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Unpacked.UpdateSequenceArray )     \
)

#define LFS_PACKED_RECORD_PAGE_HEADER_SIZE          (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Packed.UpdateSequenceArray )       \
)

//
//  Id strings for the page headers.
//

#define LFS_SIGNATURE_RESTART_PAGE          "RSTR"
#define LFS_SIGNATURE_RESTART_PAGE_ULONG    0x52545352
#define LFS_SIGNATURE_RECORD_PAGE           "RCRD"
#define LFS_SIGNATURE_RECORD_PAGE_ULONG     0x44524352
#define LFS_SIGNATURE_BAD_USA               "BAAD"
#define LFS_SIGNATURE_BAD_USA_ULONG         0x44414142
#define LFS_SIGNATURE_MODIFIED              "CHKD"
#define LFS_SIGNATURE_MODIFIED_ULONG        0x444b4843
#define LFS_SIGNATURE_UNINITIALIZED         "\377\377\377\377"
#define LFS_SIGNATURE_UNINITIALIZED_ULONG   0xffffffff


//
//  Log Client Record.  A log client record exists for each client user of
//  the log file.  One of these is in each Lfs restart area.
//

#define LFS_NO_CLIENT                           0xffff
#define LFS_CLIENT_NAME_MAX                     64

#define RESTART_SINGLE_PAGE_IO              (0x0001)

#define LFS_RESTART_AREA_SIZE       (FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray ))

#endif // _LFSDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\lfs.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Lfs.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Log File Service.

Author:
    Brian Andrew    [BrianAn]   20-June-1991


Revision History:

--*/

#ifndef _LFS_
#define _LFS_

//
// The Multi-Sector Header and Update Sequence Array provide detection of
// incomplete multi-sector transfers for devices which either have a
// physical sector size equal to the Sequence Number Stride or greater, or
// which do not transfer sectors out of order.  If a device exists which has
// a sector size smaller than the Sequence Number Stride *and* it sometimes
// transfers sectors out of order, then the Update Sequence Array will not
// provide absolute detection of incomplete transfers.  The Sequence Number
// Stride is set to a small enough number to provide absolute protection for
// all known hard disks.  It is not set any smaller, in order to avoid
// excessive run time and space overhead.
//
// The Multi-Sector Header contains space for a four-byte signature for the
// convenience of its user.  It then provides the offset to and length of the
// the Update Sequence Array.  The Update Sequence Array consists of an array
// of n saved USHORTs, where n is the size of the structure being protected
// divided by the sequence number stride.  (The size of structure being
// protected must be a nonzero power of 2 times the Sequence Number Stride,
// and less than or equal to the physical page size of the machine.)  The
// first word of the Update Sequence Array contains the Update Sequence Number,
// which is a cyclical counter (however 0 is not used) of the number of times
// the containing structure has been written to disk.  Following the Update
// Sequence Number are the n saved USHORTs which were overwritten by the
// Update Sequence Number the last time the containing structure was
// written to disk.
//
// In detail, just prior to each time the protected structure is written to
// disk, the last word in each Sequence Number Stride is saved to its
// respective position in the Sequence Number Array, and then it is overwritten
// with the next Update Sequence Number.  Just after this write, or whenever
// reading the structure, the saved word from the Sequence Number Array is
// restored to its actual position in the structure.  Before restoring the
// saved words on reads, all of the sequence numbers at the end of each
// stride are compared with the actual sequence number at the start of the
// array.  If any of these compares come up not equal, then a failed
// multi-sector transfer has been detected.
//
// The size of the array is determined by the size of the containing structure.
// As a C detail, the array is declared here with a size of 1, since its
// actual size can only be determined at runtime.
//
// The Update Sequence Array should be included at the end of the header of
// the structure it is protecting, since it is variable size.  Its user must
// insure that the correct size is reserved for it, namely:
//
//      (sizeof-structure / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)
//

#define SEQUENCE_NUMBER_STRIDE           (512)

typedef USHORT UPDATE_SEQUENCE_NUMBER, *PUPDATE_SEQUENCE_NUMBER;

//
// This array must be present at the offset described above.
//

typedef UPDATE_SEQUENCE_NUMBER UPDATE_SEQUENCE_ARRAY[1];

typedef UPDATE_SEQUENCE_ARRAY *PUPDATE_SEQUENCE_ARRAY;

//
//  The following structure is used to identify a log record by a log
//  sequence number.
//

typedef LARGE_INTEGER LSN, *PLSN;

//
//  The following Lsn will never occur in a file, it is used to indicate
//  a non-lsn.
//

extern LSN LfsZeroLsn;

//
//  The following type defines the different log record types.
//

typedef enum _LFS_RECORD_TYPE {

    LfsClientRecord = 1,
    LfsClientRestart

} LFS_RECORD_TYPE, *PLFS_RECORD_TYPE;

//
//  The following search modes are supported.
//

typedef enum _LFS_CONTEXT_MODE {

    LfsContextUndoNext = 1,
    LfsContextPrevious,
    LfsContextForward

} LFS_CONTEXT_MODE, *PLFS_CONTEXT_MODE;

typedef ULONG TRANSACTION_ID, *PTRANSACTION_ID;

typedef enum _TRANSACTION_STATE {

    TransactionUninitialized = 0,
    TransactionActive,
    TransactionPrepared,
    TransactionCommitted

} TRANSACTION_STATE, *PTRANSACTION_STATE;

typedef enum _LFS_INFO {

    LfsUseUsa = 1,
    LfsPackLog

} LFS_INFO, *PLFS_INFO;

typedef PVOID LFS_LOG_HANDLE, *PLFS_LOG_HANDLE;

typedef PVOID LFS_LOG_CONTEXT, *PLFS_LOG_CONTEXT;

//
//  Write Entry for LfsWrite and LfsForceWrite.  The interface to these
//  routines takes a pointer to a Write Entry along with a count of how
//  many Write Entries to expect to describe pieces of the caller's buffer
//  which are supposed to be copied in sequence to the log file.
//

typedef struct _LFS_WRITE_ENTRY {

    PVOID Buffer;
    ULONG ByteLength;

} LFS_WRITE_ENTRY, *PLFS_WRITE_ENTRY;


//
// Global Maintenance routines
//

BOOLEAN
LfsInitializeLogFileService (
    );

//
//  Log File Registration routines
//

typedef struct _LOG_FILE_INFORMATION {

    //
    //  This is the total useable space in the log file after space for
    //  headers and Lfs Restart Areas.
    //

    LONGLONG TotalAvailable;

    //
    //  This is the useable space in the log file from the current position
    //  in the log file to the lowest BaseLsn.  This total as returned is not
    //  yet reduced for undo commitments, returned separately below.
    //

    LONGLONG CurrentAvailable;

    //
    //  This is the total undo commitment for all clients of the log file.
    //  LfsWrite requests are refused when the sum of the write size of the
    //  request plus the UndoRequirement for the request plus the TotalUndoCommitment
    //  are greater than the CurrentAvailable.
    //

    LONGLONG TotalUndoCommitment;

    //
    //  This is the total undo commitment for this client.
    //

    LONGLONG ClientUndoCommitment;

    //
    //  Current system Lsn's.  Includes the Oldest, LastFlushed and current
    //  Lsn.
    //

    LSN OldestLsn;
    LSN LastFlushedLsn;
    LSN LastLsn;

} LOG_FILE_INFORMATION, *PLOG_FILE_INFORMATION;

#define LOG_FILE_DATA_BITS(D)      ((sizeof(LSN) * 8) - GetSeqNumberBits(D))
#define LOG_PAGE_MASK(D)        (GetLogPageSize(D) - 1)
#define LOG_PAGE_INVERSE_MASK(D)   (~LOG_PAGE_MASK(D))
#define LfsLogPageOffset(D, i)   ((i) & LOG_PAGE_MASK(D))
#define LfsLsnToPageOffset(D, lsn) (LfsLogPageOffset(D, (lsn).LowPart << three))
extern const int three;

#define LfsLsnToFileOffset(D, LSN)                 \
    /*xxShr*/(((ULONGLONG)/*xxShl*/((LSN).QuadPart << GetSeqNumberBits(D))) >> (GetSeqNumberBits(D) - three))
 
#define LfsTruncateLsnToLogPage(D, lsn, FO) {           \
    *(FO) = LfsLsnToFileOffset((D), (lsn));             \
    *((PULONG)(FO)) &= LOG_PAGE_INVERSE_MASK(D);        \
    }

#define LfsLsnToSeqNumber(D, LSN)                     \
    /*xxShr*/((ULONGLONG)/*xxShl*/((LSN).QuadPart) >> LOG_FILE_DATA_BITS(D))

#define LfsFileOffsetToLsn(D, FO, SN)          \
    ((((ULONGLONG)(FO)) >> three) + ((SN) << LOG_FILE_DATA_BITS(D)))
    

extern ULONG GetLogPageSize(PLOG_IO_DP_DRIVE);
extern ULONG GetSeqNumberBits(PLOG_IO_DP_DRIVE);

#endif  // LFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\ntfslog.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsLog.h

Abstract:

    This module defines the Ntfs-specific log file structures.

Author:

    Tom Miller      [TomM]          21-Jul-1991

Revision History:

--*/

#ifndef _NTFSLOG_
#define _NTFSLOG_

#pragma pack(4)

//
//  The following type defines the Ntfs log operations.
//
//  The comment specifies the record type which follows the record.
//  These record types are defined either here or in ntfs.h.
//

typedef enum _NTFS_LOG_OPERATION {

    Noop =                         0x00, //
    CompensationLogRecord =        0x01, //
    InitializeFileRecordSegment =  0x02, //  FILE_RECORD_SEGMENT_HEADER
    DeallocateFileRecordSegment =  0x03, //
    WriteEndOfFileRecordSegment =  0x04, //  ATTRIBUTE_RECORD_HEADER
    CreateAttribute =              0x05, //  ATTRIBUTE_RECORD_HEADER
    DeleteAttribute =              0x06, //
    UpdateResidentValue =          0x07, //  (value)
    UpdateNonresidentValue =       0x08, //  (value)
    UpdateMappingPairs =           0x09, //  (value = mapping pairs bytes)
    DeleteDirtyClusters =          0x0A, //  array of LCN_RANGE
    SetNewAttributeSizes =         0x0B, //  NEW_ATTRIBUTE_SIZES
    AddIndexEntryRoot =            0x0C, //  INDEX_ENTRY
    DeleteIndexEntryRoot =         0x0D, //  INDEX_ENTRY
    AddIndexEntryAllocation =      0x0E, //  INDEX_ENTRY
    DeleteIndexEntryAllocation =   0x0F, //  INDEX_ENTRY
    WriteEndOfIndexBuffer =        0x10, //  INDEX_ENTRY
    SetIndexEntryVcnRoot =         0x11, //  VCN
    SetIndexEntryVcnAllocation =   0x12, //  VCN
    UpdateFileNameRoot =           0x13, //  DUPLICATED_INFORMATION
    UpdateFileNameAllocation =     0x14, //  DUPLICATED_INFORMATION
    SetBitsInNonresidentBitMap =   0x15, //  BITMAP_RANGE
    ClearBitsInNonresidentBitMap = 0x16, //  BITMAP_RANGE
    HotFix =                       0x17, //
    EndTopLevelAction =            0x18, //
    PrepareTransaction =           0x19, //
    CommitTransaction =            0x1A, //
    ForgetTransaction =            0x1B, //
    OpenNonresidentAttribute =     0x1C, //  OPEN_ATTRIBUTE_ENTRY+ATTRIBUTE_NAME_ENTRY
    OpenAttributeTableDump =       0x1D, //  OPEN_ATTRIBUTE_ENTRY array
    AttributeNamesDump =           0x1E, //  (all attribute names)
    DirtyPageTableDump =           0x1F, //  DIRTY_PAGE_ENTRY array
    TransactionTableDump =         0x20  //  TRANSACTION_ENTRY array

} NTFS_LOG_OPERATION, *PNTFS_LOG_OPERATION;

char *NtfsLogOperationStrings[] = {
    "Noop"
    "CompensationLogRecord" ,
    "InitializeFileRecordSegment",
    "DeallocateFileRecordSegment",
    "WriteEndOfFileRecordSegment",
    "CreateAttribute",
    "DeleteAttribute",
    "UpdateResidentValue",
    "UpdateNonresidentValue",
    "UpdateMappingPairs",
    "DeleteDirtyClusters",
    "SetNewAttributeSize",
    "AddIndexEntryRoot",
    "DeleteIndexEntryRoot",
    "AddIndexEntryAllocation",
    "DeleteIndexEntryAllocation",
    "WriteEndOfIndexBuffer",
    "SetIndexEntryVcnRoot",
    "SetIndexEntryVcnAllocation",
    "UpdateFileNameRoot",
    "UpdateFileNameAllocation",
    "SetBitsInNonresidentBitMap",
    "ClearBitsInNonresidentBitMap" ,
    "HotFix",
    "EndTopLevelAction",
    "PrepareTransaction",
    "CommitTransaction",
    "ForgetTransaction",
    "OpenNonresidentAttribute",
    "OpenAttributeTableDump",
    "AttributeNamesDump",
    "DirtyPageTableDump",
    "TransactionTableDump"
};


//
//  The Ntfs log record header precedes every log record written to
//  disk by Ntfs.
//

//
//  Log record header.
//

typedef struct _NTFS_LOG_RECORD_HEADER {

    //
    //  Log Operations (LOG_xxx codes)
    //

    USHORT RedoOperation;
    USHORT UndoOperation;

    //
    //  Offset to Redo record, and its length
    //

    USHORT RedoOffset;
    USHORT RedoLength;

    //
    //  Offset to Undo record, and its length.  Note, for some Redo/Undo
    //  combinations, the expected records may be the same, and thus
    //  these two values will be identical to the above values.
    //

    USHORT UndoOffset;
    USHORT UndoLength;

    //
    //  Open attribute table index to which this update applies.  Index 0 is
    //  always reserved for the MFT itself.  The value of this field
    //  essentially distinguishes two cases for this update, which will be
    //  referred to as MFT update and nonresident attribute update.
    //
    //  MFT updates are for initialization and deletion of file record
    //  segments and updates to resident attributes.
    //
    //  Nonresident attribute updates are used to update attributes which
    //  have been allocated externally to the MFT.
    //

    USHORT TargetAttribute;

    //
    //  Number of Lcns in use at end of header.
    //

    USHORT LcnsToFollow;

    //
    //  Byte offset and Vcn for which this update is to be applied.  If the
    //  TargetAttribute is the MFT, then the Vcn will always be the exact
    //  Vcn of the start of the file record segment being modified, even
    //  if the modification happens to be in a subsequent cluster of the
    //  same file record.  The byte offset in this case is the offset to
    //  the attribute being changed.  For the Mft, AttributeOffset may be used
    //  to represent the offset from the start of the attribute record
    //  at which an update is to be applied.
    //
    //  If the update is to some other (nonresident) attribute, then
    //  TargetVcn and RecordOffset may be used to calculate the reference
    //  point for the update.
    //
    //  As a bottom line, the exact use of these fields is up to the
    //  writer of this particular log operation, and the associated
    //  restart routines for this attribute.
    //

    USHORT RecordOffset;
    USHORT AttributeOffset;
    USHORT Reserved[2];
    LONGLONG TargetVcn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes log records according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LONGLONG LcnsForPage[1];

    //
    //  Immediately following the last run is a log-operation-specific record
    //  whose length may be calculated by subtracting the length of this header
    //  from the length of the entire record returned by LFS.  These records
    //  are defined below.
    //

} NTFS_LOG_RECORD_HEADER, *PNTFS_LOG_RECORD_HEADER;


//
//  RESTART AREA STRUCTURES
//
//  The following structures are present in the Restart Area.
//

//
//  Generic Restart Table
//
//  This is a generic table definition for the purpose of describing one
//  of the three table structures used at Restart: the Open Attribute Table,
//  the Dirty Pages Table, and the Transaction Table.  This simple structure
//  allows for common initialization and free list management.  Allocation
//  and Deallocation and lookup by index are extremely fast, while lookup
//  by value (only performed in the Dirty Pages Table during Restart) is
//  a little slower.  I.e., all accesses to these tables during normal
//  operation are extremely fast.
//
//  If fast access to a table entry by value becomes an issue, then the
//  table may be supplemented by an external Generic Table - it is probably
//  not a good idea to make the Generic Table be part of the structure
//  written to the Log File.
//
//  Entries in a Restart Table should start with:
//
//      ULONG AllocatedOrNextFree;
//
//  An allocated entry will have the pattern RESTART_ENTRY_ALLOCATED
//  in this field.
//

#define RESTART_ENTRY_ALLOCATED          (0xFFFFFFFF)

typedef struct _RESTART_TABLE {

    //
    //  Entry size, in bytes
    //

    USHORT EntrySize;

    //
    //  Total number of entries in table
    //

    USHORT NumberEntries;

    //
    //  Number entries that are allocated
    //

    USHORT NumberAllocated;

    //
    //  Reserved for alignment
    //

    USHORT Reserved[3];

    //
    //  Free goal - Offset after which entries should be freed to end of
    //  list, as opposed to front.  At each checkpoint, the table may be
    //  truncated if there are enough free entries at the end of the list.
    //  Expressed as an offset from the start of this structure.
    //

    ULONG FreeGoal;

    //
    //  First Free entry (head of list) and Last Free entry (used to deallocate
    //  beyond Free Goal).  Expressed as an offset from the start of this
    //  structure.
    //

    ULONG FirstFree;
    ULONG LastFree;

    //
    //  The table itself starts here.
    //

} RESTART_TABLE, *PRESTART_TABLE;

//
//  Macro to get a pointer to an entry in a Restart Table, from the Table
//  pointer and entry index.
//

#define GetRestartEntryFromIndex(TBL,INDX) (    \
    (PVOID)((PCHAR)(TBL)->Table + (INDX))       \
)

//
//  Macro to get an index for an entry in a Restart Table, from the Table
//  pointer and entry pointer.
//

#define GetIndexFromRestartEntry(TBL,ENTRY) (           \
    (ULONG)((PCHAR)(ENTRY) - (PCHAR)(TBL)->Table)       \
)

//
//  Macro to see if an entry in a Restart Table is allocated.
//

#define IsRestartTableEntryAllocated(PTR) (                 \
    (BOOLEAN)(*(PULONG)(PTR) == RESTART_ENTRY_ALLOCATED)    \
)

//
//  Macro to retrieve the size of a Restart Table in bytes.
//

#define SizeOfRestartTable(TBL) (                                   \
    (ULONG)(((TBL)->Table->NumberEntries *                          \
     (TBL)->Table->EntrySize) +                                     \
    sizeof(RESTART_TABLE))                                          \
)

//
//  Macro to see if Restart Table is empty.  It is empty if the
//  number allocated is zero.
//

#define IsRestartTableEmpty(TBL) (!(TBL)->Table->NumberAllocated)

//
//  Macro to see if an index is within the currently allocated size
//  for that table.
//

#define IsRestartIndexWithinTable(TBL,INDX) (               \
    (BOOLEAN)((INDX) < SizeOfRestartTable(TBL))             \
)

//
//  Macros to acquire and release a Restart Table.
//

#define NtfsAcquireExclusiveRestartTable(TBL,WAIT) {        \
    ExAcquireResourceExclusiveLite( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedRestartTable(TBL,WAIT) {           \
    ExAcquireResourceSharedLite( &(TBL)->Resource,(WAIT));      \
}

#define NtfsReleaseRestartTable(TBL) {                      \
    ExReleaseResourceLite(&(TBL)->Resource);                    \
}

//
//  Define some tuning parameters to keep the restart tables a
//  reasonable size.
//

#define INITIAL_NUMBER_TRANSACTIONS      (5)
#define HIGHWATER_TRANSACTION_COUNT      (10)
#define INITIAL_NUMBER_ATTRIBUTES        (8)
#define HIGHWATER_ATTRIBUTE_COUNT        (16)

//
//  Attribute Name Entry.  This is a simple structure used to store
//  all of the attribute names for the Open Attribute Table during
//  checkpoint processing.  The Attribute Names record written to the log
//  is a series of Attribute Name Entries terminated by an entry with
//  Index == NameLength == 0.  The end of the table may be tested for by
//  looking for either of these fields to be 0, as 0 is otherwise invalid
//  for both.
//
//  Note that the size of this structure is equal to the overhead for storing
//  an attribute name in the table, including the UNICODE_NULL.
//

typedef struct _ATTRIBUTE_NAME_ENTRY {

    //
    //  Index for Attibute with this name in the Open Attribute Table.
    //

    USHORT Index;

    //
    //  Length of attribute name to follow in bytes, including a terminating
    //  UNICODE_NULL.
    //

    USHORT NameLength;

    //
    //  Start of attribute name
    //

    WCHAR Name[1];

} ATTRIBUTE_NAME_ENTRY, *PATTRIBUTE_NAME_ENTRY;

//
//  Open Attribute Table
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _OPEN_ATTRIBUTE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  The following overlay either contains an optional pointer to an
    //  Attribute Name Entry from the Analysis Phase of Restart, or a
    //  pointer to an Scb once attributes have been open and in the normal
    //  running system.
    //
    //  Specifically, after the Analysis Phase of Restart:
    //
    //      AttributeName == NULL if there is no attribute name, or the
    //                       attribute name was captured in the Attribute
    //                       Names Dump in the last successful checkpoint.
    //      AttributeName != NULL if an OpenNonresidentAttribute log record
    //                       was encountered, and an Attribute Name Entry
    //                       was allocated at that time (and must be
    //                       deallocated when no longer needed).
    //
    //  Once the Nonresident Attributes have been opened during Restart,
    //  and in the running system, this is an Scb pointer.
    //

    union {
        PWSTR AttributeName;
        PVOID Scb;
    } Overlay;

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;

    //
    //  Reserved for alignment
    //

    UCHAR Reserved[3];

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

} OPEN_ATTRIBUTE_ENTRY, *POPEN_ATTRIBUTE_ENTRY;

#define SIZEOF_OPEN_ATTRIBUTE_ENTRY (                               \
    FIELD_OFFSET( OPEN_ATTRIBUTE_ENTRY, BytesPerIndexBuffer ) + 4   \
)

//
//  Dirty Pages Table
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

typedef struct _DIRTY_PAGE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Reserved for alignment
    //

    ULONG Reserved;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY, *PDIRTY_PAGE_ENTRY;

//
//  Transaction Table
//
//  One transaction entry exists for each existing transaction at the time
//  the Restart Area is written.
//
//  Currently only local transactions are supported, and the transaction
//  ID is simply used to index into this table.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_TRANSACTION_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _TRANSACTION_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Transaction State
    //

    UCHAR TransactionState;

    //
    //  Reserved for proper alignment
    //

    UCHAR Reserved[3];

    //
    //  First Lsn for transaction.  This tells us how far back in the log
    //  we may have to read to abort the transaction.
    //

    LSN FirstLsn;

    //
    //  PreviousLsn written for the transaction and UndoNextLsn (next record
    //  which should be undone in the event of a rollback.
    //

    LSN PreviousLsn;
    LSN UndoNextLsn;

    //
    //  Number of of undo log records pending abort, and total undo size.
    //

    ULONG UndoRecords;
    LONG UndoBytes;

} TRANSACTION_ENTRY, *PTRANSACTION_ENTRY;

//
//  Restart record
//
//  The Restart record used by NTFS is small, and it only describes where
//  the above information has been written to the log.  The above records
//  may be considered logically part of NTFS's restart area.
//

typedef struct _RESTART_AREA {

    //
    //  Version numbers of NTFS Restart Implementation
    //

    ULONG MajorVersion;
    ULONG MinorVersion;

    //
    //  Lsn of Start of Checkpoint.  This is the Lsn at which the Analysis
    //  Phase of Restart must begin.
    //

    LSN StartOfCheckpoint;

    //
    //  Lsns at which the four tables above plus the attribute names reside.
    //

    LSN OpenAttributeTableLsn;
    LSN AttributeNamesLsn;
    LSN DirtyPageTableLsn;
    LSN TransactionTableLsn;

    //
    //  Lengths of the above structures in bytes.
    //

    ULONG OpenAttributeTableLength;
    ULONG AttributeNamesLength;
    ULONG DirtyPageTableLength;
    ULONG TransactionTableLength;

} RESTART_AREA, *PRESTART_AREA;


//
//  RECORD STRUCTURES USED BY LOG RECORDS
//

//
//  Set new attribute sizes
//

typedef struct _NEW_ATTRIBUTE_SIZES {

    LONGLONG AllocationSize;
    LONGLONG ValidDataLength;
    LONGLONG FileSize;

} NEW_ATTRIBUTE_SIZES, *PNEW_ATTRIBUTE_SIZES;

//
//  Describe a bitmap range
//

typedef struct _BITMAP_RANGE {

    ULONG BitMapOffset;
    ULONG NumberOfBits;

} BITMAP_RANGE, *PBITMAP_RANGE;

//
//  Describe a range of Lcns
//

typedef struct _LCN_RANGE {

    LCN StartLcn;
    LONGLONG Count;

} LCN_RANGE, *PLCN_RANGE;

#pragma pack()

#endif //  _NTFSLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\ofsbedit.cxx ===
#include "ulib.hxx"
#include "ofs.hxx"
#include "ofsbedit.hxx"

extern "C" {
#include <stdio.h>
}


VOID
OFS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
OFS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    DSKPACKEDBOOTSECT       *p;
    DSKBPB                  bpb;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    p = (DSKPACKEDBOOTSECT *) _buffer;
    UnpackOfsBios(&bpb, &(p->PackedBpb));

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String: %c%c%c%c%c%c%c%c"),
                 p->Oem[0],
                 p->Oem[1],
                 p->Oem[2],
                 p->Oem[3],
                 p->Oem[4],
                 p->Oem[5],
                 p->Oem[6],
                 p->Oem[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector: %x"), bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster: %x"), bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors: %x"),  bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats: %x"), bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries: %x"), bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count: %x"), bpb.Sectors16);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte: %x"), bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat: %x"), bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per track: %x"), bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads: %x"), bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors: %x"), bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors: %x"), bpb.Sectors32);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Volume Id: <%x,%x>"), (ULONG)(p->VolumeId >> 32),
        (ULONG)(p->VolumeId));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("OFS number of sectors: <%x,%x>"), (ULONG)(p->Sectors >> 32),
        (ULONG)(p->Sectors));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("OfsVolCatExtent: %x for %x"), ExtentAddr(p->OfsVolCatExtent),
        ExtentSize(p->OfsVolCatExtent));
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("CheckSum: %x"), p->CheckSum);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Flags: %x"), p->Flags);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\logrecio.cxx ===
#include "ulib.hxx"
#include "logrecio.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "diskedit.h"

extern "C" {
#include "lfs.h"
#include "lfsdisk.h"
#include <stdio.h>
}

const int three = 3;

STATIC LSN Lsn;

BOOLEAN
LOG_RECORD_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    NTFS_SA ntfssa;
    MESSAGE msg;
    NTFS_MFT_FILE mft;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    BOOLEAN error;

    _drive = Drive;

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadLogRecordBox"),
                   WindowHandle, ReadLogRecord)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    if (!_drive ||
        !ntfssa.Initialize(_drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(_drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !_frs.Initialize((VCN)LOG_FILE_NUMBER, &mft) ||
        !_frs.Read()) {

        return FALSE;
    }

    if (!_frs.QueryAttribute(&_attrib, &error, $DATA, NULL)) {
        return FALSE;
    }

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(Drive, Lsn);

    swprintf(_header_text, TEXT("DiskEdit - Log record: page @ %x, offset %x"),
            (ULONG)FileOffset, PageOffset);

    return TRUE;
}


BOOLEAN
LOG_RECORD_IO::Read(
    OUT PULONG  pError
    )
{
    LFS_RECORD_HEADER RecordHeader;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    ULONG       bytes_read;
    ULONG       RemainingLength, CurrentPos, ThisPagePortion;

    *pError = 0;

    (void)GetLogPageSize(_drive);

    LfsTruncateLsnToLogPage(_drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(_drive, Lsn);

    //
    // Read in the record header to see how big the total record
    // is.
    //

    if (!_attrib.Read((PVOID)&RecordHeader, ULONG(PageOffset | FileOffset),
        LFS_RECORD_HEADER_SIZE, &bytes_read) ||
        bytes_read != LFS_RECORD_HEADER_SIZE) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }

    _length = LFS_RECORD_HEADER_SIZE + RecordHeader.ClientDataLength;
    if (NULL == (_buffer = MALLOC(_length))) {
        *pError = (ULONG)STATUS_INSUFFICIENT_RESOURCES;
        return FALSE;
    }

    RemainingLength = _length;
    CurrentPos = 0;

    while (RemainingLength > 0) {
        ThisPagePortion = MIN(GetLogPageSize(_drive) - PageOffset,
             RemainingLength);

        if (!_attrib.Read((PUCHAR)_buffer + CurrentPos,
            ULONG(FileOffset | PageOffset),
            ThisPagePortion, &bytes_read) ||
            bytes_read != ThisPagePortion) {
            *pError = _drive->QueryLastNtStatus();
            return FALSE;
        }

        CurrentPos += ThisPagePortion;
        RemainingLength -= ThisPagePortion;
        FileOffset += GetLogPageSize(_drive);
        PageOffset = LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
    }

    return TRUE;
}


BOOLEAN
LOG_RECORD_IO::Write(
    )
{
    return FALSE;
}


PVOID
LOG_RECORD_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _length;
    }

    return _buffer;
}


PTCHAR
LOG_RECORD_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadLogRecord(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    TCHAR buf[1024];
    PTCHAR pch;
    INT n;

    switch (message) {
    case WM_INITDIALOG:
            swprintf(buf, TEXT("%x:%x"), Lsn.HighPart, Lsn.LowPart);
            SetDlgItemText(hDlg, IDTEXT, buf);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {
            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;

            if (NULL == (pch = wcschr(buf, ':'))) {
                Lsn.HighPart = 0;
                swscanf(buf, TEXT("%x"), &Lsn.LowPart);
            } else {
                *pch = 0;
                swscanf(buf, TEXT("%x"), &Lsn.HighPart);
                swscanf(pch + 1, TEXT("%x"), &Lsn.LowPart);
                *pch = ':';
            }
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\ntfsstru.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsStru.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Ntfs file system.

    The global data structures start with the NtfsData record.  It contains
    a pointer to a File System Device object, and a queue of Vcb's.  There
    is a Vcb for every currently mounted volume.  The Vcb's are allocated as
    the extension to a volume device object.

        +--------+
        |NtfsData|     +--------+
        |        | --> |FilSysDo|
        |        |     |        |
        |        | <+  +--------+
        +--------+  |
                    |
                    |  +--------+     +--------+
                    |  |VolDo   |     |VolDo   |
                    |  |        |     |        |
                    |  +--------+     +--------+
                    +> |Vcb     | <-> |Vcb     | <-> ...
                       |        |     |        |
                       +--------+     +--------+

    The File System Device Object contains the global work queue for
    NTFS while each volume device object contains an overflow work queue.

    Each Vcb contains a table of all Fcbs for the volume indexed by their
    file reference (Called the FcbTable).  And each Vcb contains a pointer
    a root Lcb for the volume.  An Lcb is used to connect an indexed Scb (i.e.,
    a directory) to an Fcb and give it a name.

    The following diagram shows the root structure.

        +--------+
        |Vcb     |
        |        |  +---+   +--------+
        |        | -|Lcb|-> |RootFcb |
        +--------+  |'\'|   |        |
                    +---+   |        |
                            +--------+

    Each Scb will only have one parent Fcb but multiple Fcb children (each
    connected via an Lcb).  An Fcb can have multiple Scb parents (via Lcbs)
    and multiple Scb Children.

    Now associated with each Fcb is potentially many Scbs.  An Scb
    is allocated for each opened stream file object (i.e., an attribute that
    the file system is manipulating as a stream file).  Each Scb contains
    a common fsrtl header and information necessary for doing I/O to the
    stream.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+

    In the following diagram we have two index scb (Scb1 and Scb2).  The
    are two file opened under Scb1 both for the same File.  The file was opened
    once with the name LcbA and another time with the name LcbB.  Scb2 also has
    two opened file one is Fcb1 and named LcbC and the other is Fcb2 and named
    LcbD.  Fcb1 has two opened Scbs under it (Scb3 and Scb4), and Fcb2 has
    one opened Scb underneath it (Scb5).


           +--------+                +--------+
           |Scb     |                |Scb     |
           |    1   |                |    2   |
           |        |                |        |
           +--------+                +--------+

             |    |                    |    |

            Lcb  Lcb                  Lcb  Lcb
             A    B                    C    D

             |    |     +--------+     |    |     +--------+
             |    +---> |Fcb     | <---+    +---> |Fcb     |
             |          |    1   |                |    2   |
             +--------> |        |                |        |
                        +--------+                +--------+
                          ^    ^                    ^    ^
             +------------+    +------------+  +----+    +----+
             |                              |  |              |
             |  +--------+      +--------+  |  |  +--------+  |
             +> |Scb     | <--> |Scb     | <+  +> |Scb     | <+
                |    3   |      |    4   |        |    5   |
                |        |      |        |        |        |
                +--------+      +--------+        +--------+

    In addition off of each Lcb is a list of Ccb and Prefix entries.  The Ccb list
    is for each ccb that has opened that File (fcb) via the name.  The Prefix list
    contains the prefix table entries that we are caching.


    The NtfsData, all Vcbs, and the paging file Fcb, and all Scbs are allocated
    out of nonpaged pool.  The Fcbs are allocated out of paged pool.

    The resources protecting the NTFS memory structures are setup as follows:

    1. There is a global resource in the NtfsData record.  This resource
       protects the NtfsData record which includes any changes to its
       Vcb queue.

    2. There is a resource per Vcb.  This resource pretects the Vcb record
       which includes adding and removing Fcbs, and Scbs

    3. There is a single resource protecting an Fcb and its assigned
       Scbs.  This resource protects any changes to the Fcb, and Scb
       records.  The way this one works is that each Fcb, and Scb point
       to the resource.  The Scb also contain back pointers to their parent
       Fcb but we cannot use this pointer to get the resource because
       the Fcb might be in nonpaged pool.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+
               |
               |           |            |
               |           v            |
               |                        |
               |       +--------+       |
               +-----> |Resource| <-----+
                       |        |
                       +--------+



    There are four types of opens possible for each file object handled by
    NTFS.  They are UserFileOpen, UserDirectoryOpen, UserVolumeOpen, and
    StreamFileOpen.  The first three types correspond to user opens on
    files, directories, and dasd respectively.  The last type is for any
    file object created by NTFS for its stream I/O (e.g., the volume
    bitmap).   The file system uses the FsContext and FsContext2 fields of
    the file object to store information about the type of open and the
    fcb/scb/ccb associated with the file object.  We can overload the low
    bits of the fields to be more than pointers because they must always
    point to longword aligned records.  The fields are used as follows:

        Type of open                FsContext                   FsContext2
        ------------                ---------                   ----------

        UserFileOpen        Pointer to Scb with             Pointer to Ccb
                            0 in the last two bits

        UserDirectoryOpen   Pointer to Scb with             Pointer to Ccb
                            1 in the last two bits

        UserVolumeOpen      Pointer to Scb with             Pointer to Ccb
                            2 in the last two bits

        StreamFileOpen      Pointer to Scb                  null

    The only part of the NTFS code that actually needs to know this
    information is in FilObSup.c.  But we talk about it here to help
    developers debug the system.


    To mount a new NTFS volume requires a bit of juggling.  The idea is
    to have as little setup in memory as necessary to recoginize the volume,
    call a restart routine that will recover the volume, and then precede with
    the mounting.  To aid in this the regular directory structures of the
    Fcb is bypassed.  In its place we have a linked list of Fcbs off
    of the Vcb.  This is done because during recovery we do not know where
    an Fcb belongs in the directory hierarchy.  So at restart time all
    new fcbs get put in this prerestart Fcb list.  Then after restart whenever
    we create a new Fcb we search this list for a match (on file reference).
    If we find one we remove the fcb from this list and move it to the proper
    place in the directory hierarchy tree (fcb tree).

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSSTRU_
#define _NTFSSTRU_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

//
//  Define who many freed structures we are willing to keep around
//

#define FREE_CCB_SIZE                    (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_LCB_SIZE                    (8)
#define FREE_SCB_DATA_SIZE               (4)
#define FREE_SCB_SHARE_DATA_SIZE         (8)
#define FREE_SCB_INDEX_SIZE              (8)
#define FREE_SCB_NONPAGED_SIZE           (8)

#define FREE_DEALLOCATED_RECORDS_SIZE    (8)
#define FREE_ERESOURCE_SIZE              (8)
#define FREE_INDEX_CONTEXT_SIZE          (8)
#define FREE_KEVENT_SIZE                 (8)
#define FREE_NUKEM_SIZE                  (8)
#define FREE_SCB_SNAPSHOT_SIZE           (8)
#define FREE_IO_CONTEXT_SIZE             (8)
#define FREE_FILE_LOCK_SIZE              (8)

#define FREE_FCB_TABLE_SIZE              (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)

#define MAX_DELAYED_CLOSE_COUNT_SMALL    (20)
#define MAX_DELAYED_CLOSE_COUNT_MEDIUM   (100)
#define MAX_DELAYED_CLOSE_COUNT_LARGE    (500)


//
//  The NTFS_DATA record is the top record in the NTFS file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _NTFS_DATA {

    //
    //  The type and size of this record (must be NTFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A queue of all the devices that are mounted by the file system.
    //  Corresponds to the field Vcb->VcbLinks;
    //

    LIST_ENTRY VcbQueue;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A resource variable to control access to the global NTFS data record
    //

    ERESOURCE Resource;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  The following list entry is used for performing closes that can't
    //  be done in the context of the original caller.
    //

    LIST_ENTRY AsyncCloseList;

    BOOLEAN AsyncCloseActive;
    BOOLEAN ReduceDelayedClose;

    //
    //  The following fields describe the deferred close file objects.
    //

    ULONG DelayedCloseCount;

    LIST_ENTRY DelayedCloseList;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM NtfsCloseItem;

    //
    //  The following fields are used to allocate IRP context structures
    //  using the zone allocator, and other fixed sized structures from a
    //  small cache.  The spinlock protects access to the zone/lists
    //

    KSPIN_LOCK StrucSupSpinLock;

    ZONE_HEADER IrpContextZone;

    struct _CCB                 *FreeCcbArray[FREE_CCB_SIZE];
    struct _FCB                 *FreeFcbArray[FREE_FCB_SIZE];
    struct _LCB                 *FreeLcbArray[FREE_LCB_SIZE];
    struct _SCB                 *FreeScbDataArray[FREE_SCB_DATA_SIZE];
    struct _SCB                 *FreeScbShareDataArray[FREE_SCB_SHARE_DATA_SIZE];
    struct _SCB                 *FreeScbIndexArray[FREE_SCB_INDEX_SIZE];
    struct _SCB_NONPAGED        *FreeScbNonpagedArray[FREE_SCB_NONPAGED_SIZE];

    struct _DEALLOCATED_RECORDS *FreeDeallocatedRecordsArray[FREE_DEALLOCATED_RECORDS_SIZE];
    struct _ERESOURCE           *FreeEresourceArray         [FREE_ERESOURCE_SIZE];
    struct _INDEX_CONTEXT       *FreeIndexContextArray      [FREE_INDEX_CONTEXT_SIZE];
    struct _KEVENT              *FreeKeventArray            [FREE_KEVENT_SIZE];
    struct _NUKEM               *FreeNukemArray             [FREE_NUKEM_SIZE];
    struct _SCB_SNAPSHOT        *FreeScbSnapshotArray       [FREE_SCB_SNAPSHOT_SIZE];
    struct _NTFS_IO_CONTEXT     *FreeIoContextArray         [FREE_IO_CONTEXT_SIZE];
    struct _FILE_LOCK           *FreeFileLockArray          [FREE_FILE_LOCK_SIZE];

    PVOID                       *FreeFcbTableArray[FREE_FCB_TABLE_SIZE];

    PVOID                       *Free128ByteArray[FREE_128_BYTE_SIZE];
    PVOID                       *Free256ByteArray[FREE_256_BYTE_SIZE];
    PVOID                       *Free512ByteArray[FREE_512_BYTE_SIZE];

    UCHAR FreeCcbSize;
    UCHAR FreeFcbSize;
    UCHAR FreeLcbSize;
    UCHAR FreeScbDataSize;
    UCHAR FreeScbShareDataSize;
    UCHAR FreeScbIndexSize;
    UCHAR FreeScbNonpagedSize;

    UCHAR FreeDeallocatedRecordsSize;
    UCHAR FreeEresourceSize;
    UCHAR FreeIndexContextSize;
    UCHAR FreeKeventSize;
    UCHAR FreeNukemSize;
    UCHAR FreeScbSnapshotSize;
    UCHAR FreeIoContextSize;
    UCHAR FreeFileLockSize;

    UCHAR FreeFcbTableSize;

    UCHAR Free128ByteSize;
    UCHAR Free256ByteSize;
    UCHAR Free512ByteSize;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is a list of all of the threads currently doing read ahead.
    //  We will not hot fix for these threads.
    //

    LIST_ENTRY ReadAheadThreads;

    //
    //  The following fields are used for the CheckpointVolumes() callback.
    //

    KDPC VolumeCheckpointDpc;
    KTIMER VolumeCheckpointTimer;

    KSPIN_LOCK VolumeCheckpointSpinLock;
    WORK_QUEUE_ITEM VolumeCheckpointItem;

    BOOLEAN Modified;
    BOOLEAN ExtraCheckpoint;
    BOOLEAN TimerSet;

} NTFS_DATA;
typedef NTFS_DATA *PNTFS_DATA;


//
//  The record allocation context structure is used by the routines that allocate
//  and deallocate records based on a bitmap (for example the mft bitmap or the
//  index bitmap).  The context structure needs to be defined here because
//  the mft bitmap context is declared as part of the vcb.
//

typedef struct _RECORD_ALLOCATION_CONTEXT {

    //
    //  The following field is a pointer to the scb for the data part of
    //  the file that this bitmap controls.  For example, it is a pointer to
    //  the data attribute for the MFT.
    //
    //  NOTE !!!!  The Data Scb must remain the first entry in this structure.
    //  If we need to uninitialize and reinitialize this structure in the
    //  running system we don't want to touch this field.
    //
    //  NOTE !!!!  The code that clears the record allocation context expects
    //  the BitmapScb field to follow the Data Scb field.
    //

    struct _SCB *DataScb;

    //
    //  The following field is used to indicate if the bitmap attribute is
    //  in a resident form or a nonresident form.  If the bitmap is in a
    //  resident form then the pointer is null, and whenever a bitmap
    //  routine is called it must also be passed an attribute enumeration
    //  context to be able to read the bitmap.  If the field is not null
    //  then it points to the scb for the non resident bitmap attribute
    //

    struct _SCB *BitmapScb;

    //
    //  The following two fields describe the current size of the bitmap
    //  (in bits) and the number of free bits currently in the bitmap.
    //  A value of MAXULONG in the CurrentBitmapSize indicates that we need
    //  to reinitialize the record context structure.
    //

    ULONG CurrentBitmapSize;
    ULONG NumberOfFreeBits;

    //
    //  The following three fields are used to indicate the allocation
    //  size for the bitmap (i.e., each bit in the bitmap represents how
    //  many bytes in the data attribute).  Also it indicates the granularity
    //  with which we will either extend or shrink the bitmap.
    //

    ULONG BytesPerRecord;

    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    //
    //  The following field contains the index of last bit that we know
    //  to be set.  This is used for truncation purposes.
    //

    LONG IndexOfLastSetBit;

} RECORD_ALLOCATION_CONTEXT;
typedef RECORD_ALLOCATION_CONTEXT *PRECORD_ALLOCATION_CONTEXT;


//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  They are ordered in a queue off of NtfsData.VcbQueue.
//  This structure must be allocated from non-paged pool
//

#define DEFAULT_ATTRIBUTE_TABLE_SIZE     (32)
#define DEFAULT_TRANSACTION_TABLE_SIZE   (32)
#define DEFAULT_DIRTY_PAGES_TABLE_SIZE   (64)

//
//  The Restart Pointers structure is the actual structure supported by
//  routines and macros to get at a Restart Table.  This structure is
//  required since the restart table itself may move, so one must first
//  acquire the resource to synchronize, then follow the pointer to the table.
//

typedef struct _RESTART_POINTERS {

    //
    //  Pointer to the actual Restart Table.
    //

    struct _RESTART_TABLE *Table;

    //
    //  Resource to synchronize with table moves.  This resource must
    //  be held shared while dealing with pointers to table entries,
    //  and exclusive to move the table.
    //

    ERESOURCE Resource;

    //
    //  Remember if the resource was initialized.
    //

    BOOLEAN ResourceInitialized;

    //
    //  Spin Lock synchronizing allocates and deletes of entries in the
    //  table.  The resource must be held at least shared.
    //

    KSPIN_LOCK SpinLock;

} RESTART_POINTERS, *PRESTART_POINTERS;


//
//  Structure used to track the deallocated clusters.
//

typedef struct _DEALLOCATED_CLUSTERS {

    LSN Lsn;
    LONGLONG ClusterCount;
    LARGE_MCB Mcb;

} DEALLOCATED_CLUSTERS, *PDEALLOCATED_CLUSTERS;

//
//  The Vcb structure corresponds to every mounted NTFS volume in the system
//

typedef struct _VCB {

    //
    //  The type and size of this record (must be NTFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the queue of all the Vcbs in the system.
    //  Corresponds to the filld NtfsData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  Pointer to the Scb for the special system file.  If the field is null
    //  then we haven't yet built the scb for that system file.  Also the pointer
    //  to the stream file object is located in the scb.
    //
    //  NOTE: AcquireExclusiveFiles depends on this order.  Any change here
    //  should be checked with the code there.
    //

    struct _SCB *MftScb;
    struct _SCB *Mft2Scb;
    struct _SCB *LogFileScb;
    struct _SCB *VolumeDasdScb;
    struct _SCB *AttributeDefTableScb;
    struct _SCB *UpcaseTableScb;
    struct _SCB *RootIndexScb;
    struct _SCB *BitmapScb;
    struct _SCB *BootFileScb;
    struct _SCB *BadClusterFileScb;
    struct _SCB *QuotaTableScb;
    struct _SCB *MftBitmapScb;

    //
    //  The root Lcb for this volume.
    //

    struct _LCB *RootLcb;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  The internal state of the volume.  This is a collection of Vcb
    //  state flags.  The VcbState is synchronized with the Vcb resource.
    //  The MftDefragState is synchronized with the CheckpointEvent.
    //  The MftReserveFlags are sychronized with the MftScb.
    //

    ULONG VcbState;
    ULONG MftReserveFlags;
    ULONG MftDefragState;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume. And a count of the number of special system
    //  files that we have open
    //

    CLONG CleanupCount;
    CLONG CloseCount;
    CLONG ReadOnlyCloseCount;
    CLONG SystemFileCloseCount;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  The following events are used to synchronize the Fcb table and
    //  the shared security structures.
    //

    KEVENT FcbTableEvent;
    PVOID FcbTableThread;

    KEVENT FcbSecurityEvent;
    PVOID FcbSecurityThread;

    //
    //  Following events are used to control the volume checkpoint
    //  operations.
    //

    KEVENT CheckpointEvent;
    PVOID CheckpointThread;

    KEVENT CheckpointNotifyEvent;
    PVOID CheckpointNotifyThread;

    ULONG CheckpointFlags;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following volume-specific parameters are extracted from the
    //  Boot Sector.
    //

    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;
    LONGLONG NumberSectors;
    LCN MftStartLcn;
    LCN Mft2StartLcn;
    ULONG ClustersPerFileRecordSegment;
    ULONG DefaultClustersPerIndexAllocationBuffer;

    //
    //  This field contains a calculated value which determines when an
    //  individual attribute is large enough to be moved to free up file
    //  record space.  (The calculation of this variable must be considered
    //  in conjunction with the constant MAX_MOVEABLE_ATTRIBUTES below.)
    //

    ULONG BigEnoughToMove;

    //
    //  The following fields are used to verify that an NTFS volume hasn't
    //  changed.  The serial number is stored in the boot sector on disk,
    //  and the four times are from the standard information field of the
    //  volume file.
    //

    LONGLONG VolumeSerialNumber;

    LONGLONG VolumeCreationTime;
    LONGLONG VolumeLastModificationTime;
    LONGLONG VolumeLastChangeTime;
    LONGLONG VolumeLastAccessTime;

    //
    //  The following table of unicode values is the case mapping, with the
    //  size in number of Unicode characters.
    //

    PWCH UpcaseTable;
    ULONG UpcaseTableSize;

    //
    //  This is a pointer to the attribute definitions for the volume
    //  which are loaded into nonpaged pool.
    //

    PATTRIBUTE_DEFINITION_COLUMNS AttributeDefinitions;

    //
    //  Convenient constants for the conversion macros
    //

    ULONG ClusterMask;              // BytesPerCluster - 1
    ULONG InverseClusterMask;       // ~ClusterMask
    ULONG ClusterShift;             // 2**ClusterShift == BytesPerCluster
    ULONG MftShift;                 //
    ULONG MftToClusterShift;
    ULONG ClustersPerPage;
    ULONG MftReserved;
    ULONG MftCushion;

    //
    //  Lfs Log Handle for this volume
    //

    LFS_LOG_HANDLE LogHandle;

    //
    //  LSNs of the end of the last checkpoint and the last RestartArea.
    //  Normally the RestartArea Lsn is greater than the other one, however
    //  if the VcbState indicates that a checkpoint is in progress, then these
    //  Lsns are in flux.
    //

    LSN EndOfLastCheckpoint;
    LSN LastRestartArea;
    LSN LastBaseLsn;

    //
    //  Open attribute table.
    //

    RESTART_POINTERS OpenAttributeTable;

    //
    //  Transaction table.
    //

    RESTART_POINTERS TransactionTable;

    //
    //  A table of all the fcb that have been created for this volume.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  The following fields are used by the BitmpSup routines.  The first
    //  value contains the total number of clusters on the volume, this
    //  is computed from the boot sector information.  The second value
    //  is the current number of free clusters available for allocation on
    //  the volume.  Allocation is handled by using two MCBs: FreeSpace
    //  describes some small window of known clusters that are free.
    //  RecentlyAllocated describes those clusters that have been recently
    //  allocated.
    //
    //  In addition there are two simply LRU arrays used by BitmpSup to keep
    //  the size of the corresponding MCB within limits.  The array field
    //  points to an array of lcn entries which is maintained in a round-robin
    //  lru fashion.  The size field denotes the number of Lcn entries
    //  allocated to the array, and tail and head are indices into the array.
    //
    //  The last field is for storing local volume specific data needed by
    //  the bitmap routines
    //

    LONGLONG TotalClusters;
    LONGLONG FreeClusters;
    LONGLONG DeallocatedClusters;

    LARGE_MCB FreeSpaceMcb;
    PLCN FreeSpaceLruArray;
    ULONG FreeSpaceLruSize;
    ULONG FreeSpaceLruTail;
    ULONG FreeSpaceLruHead;

    LARGE_MCB RecentlyAllocatedMcb;
    PLCN RecentlyAllocatedLruArray;
    ULONG RecentlyAllocatedLruSize;
    ULONG RecentlyAllocatedLruTail;
    ULONG RecentlyAllocatedLruHead;

    LCN LastBitmapHint;     //  Last Lcn used for fresh allocation

    //
    //  The following are used to track the deallocated clusters waiting
    //  for a checkpoint.  The pointers are used so we can toggle the
    //  use of the structures.
    //

    DEALLOCATED_CLUSTERS DeallocatedClusters1;
    DEALLOCATED_CLUSTERS DeallocatedClusters2;

    PDEALLOCATED_CLUSTERS PriorDeallocatedClusters;
    PDEALLOCATED_CLUSTERS ActiveDeallocatedClusters;

    //
    //  The following field is also used by the bitmap allocation routines
    //  to keep track of recently deallocated clusters.  A cluster that has
    //  been recently deallocated will not be reallocated until the
    //  operation (transaction) is complete.  That way if the operation
    //  needs to abort itself the space it had deallocated can easily be
    //  unwound.  NtfsDeallocateClusters adds to this mcb and
    //  NtfsDeallocateClusterComplete removes entries from it.
    //

    LARGE_MCB RecentlyDeallocatedMcb;

    //
    //  The following field is used for mft bitmap allocation
    //

    RECORD_ALLOCATION_CONTEXT MftBitmapAllocationContext;

    //
    //  The following two fields are used by the bitmap routines to determine
    //  what is called the mft zone.  The Mft zone are those clusters on the
    //  disk were we will try and put the mft and only the mft unless the disk
    //  is getting too full.
    //

    LCN MftZoneStart;
    LCN MftZoneEnd;

    //
    //  The following string contains the device name for this partition.
    //

    UNICODE_STRING DeviceName;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following mutex is used to manage the list of Irps pending
    //  dir notify.
    //

    KMUTEX DirNotifyMutex;

    //
    //  The following fields are used for the Mft defrag operation.  In addition
    //  we use the number of free clusters stored earlier in this structure.
    //
    //  The upper and lower thresholds are used to determine if the number of free
    //  file records in the Mft will cause us to trigger or cease defragging.
    //
    //  The count of free records is based on the size of the Mft and the allocated
    //  records.  The hole count is the count of how many file records are not
    //  allocated.
    //
    //  The count of the bitmap bits per hole.  This is the number of file records
    //  per hole.  Must be converted to clusters to find a hole in the Mft Mcb.
    //

    ULONG MftDefragUpperThreshold;
    ULONG MftDefragLowerThreshold;

    ULONG MftFreeRecords;
    ULONG MftHoleRecords;
    ULONG MftHoleGranularity;
    ULONG MftClustersPerHole;
    ULONG MftHoleMask;
    ULONG MftHoleInverseMask;

} VCB;
typedef VCB *PVCB;

//
//  These are the VcbState flags.  Synchronized with the Vcb resource.
//

#define VCB_STATE_VOLUME_MOUNTED            (0x00000001)
#define VCB_STATE_LOCKED                    (0x00000002)
#define VCB_STATE_REMOVABLE_MEDIA           (0x00000004)
#define VCB_STATE_VOLUME_MOUNTED_DIRTY      (0x00000008)
#define VCB_STATE_RESTART_IN_PROGRESS       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN             (0x00000020)
#define VCB_STATE_NO_SECONDARY_AVAILABLE    (0x00000040)
#define VCB_STATE_RELOAD_FREE_CLUSTERS      (0x00000080)
#define VCB_STATE_ALREADY_BALANCED          (0x00000100)
#define VCB_STATE_VOL_PURGE_IN_PROGRESS     (0x00000200)

//
//  These are the flags for the Mft and the reserveration state.
//  Although these are in the Vcb they are synchronized with
//  the resource in the MftScb.
//

#define VCB_MFT_RECORD_RESERVED             (0x00000001)
#define VCB_MFT_RECORD_15_USED              (0x00000002)

//
//  These are the MftDefragState flags.  Synchronized with the
//  CheckpointEvent.
//

#define VCB_MFT_DEFRAG_PERMITTED            (0x00000001)
#define VCB_MFT_DEFRAG_ENABLED              (0x00000002)
#define VCB_MFT_DEFRAG_TRIGGERED            (0x00000004)
#define VCB_MFT_DEFRAG_ACTIVE               (0x00000008)
#define VCB_MFT_DEFRAG_EXCESS_MAP           (0x00000010)

//
//  These are the Checkpoint flags.  Synchronized with the
//  CheckpointEvent.  These flags are in the MftDefragState
//  flags field.
//

#define VCB_CHECKPOINT_IN_PROGRESS          (0x00000020)
#define VCB_LAST_CHECKPOINT_CLEAN           (0x00000040)

//
//  This is the maximum number of attributes in a file record which could
//  be considered for moving.  This value should be changed only in conjunction
//  with the initialization of the BigEnoughToMove field above.
//

#define MAX_MOVEABLE_ATTRIBUTES          (3)


//
//  The Volume Device Object is an I/O system device object with a workqueue
//  and an VCB record appended to the end.  There are multiple of these
//  records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload of
//  work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;



//
//  This structure is used to contain a link name and connections into
//  the splay tree for the parent.
//

typedef struct _NAME_LINK {

    UNICODE_STRING LinkName;
    RTL_SPLAY_LINKS Links;

} NAME_LINK, *PNAME_LINK;

//
//  The Lcb record corresponds to every open path between an Scb and an Fcb.
//  It denotes the name which was used to go from the scb to the fcb and
//  it also contains a queue of ccbs that have opened the fcb via that name
//  and also a queue of Prefix Entries that will get us to this lcb
//

typedef struct _LCB {

    //
    //  Type and size of this record must be NTFS_NTC_LCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for all the Lcbs that emminate out of an Scb and a pointer
    //  back to the Scb.  Corresponds to Scb->LcbQueue.
    //

    LIST_ENTRY ScbLinks;
    struct _SCB *Scb;

    //
    //  The links for all the Lcbs that go into an Fcb and a pointer
    //  back to the Fcb.  Corresponds to Fcb->LcbQueue.
    //

    LIST_ENTRY FcbLinks;
    struct _FCB *Fcb;

    //
    //  This is the number of unclean handles on this link.
    //

    ULONG CleanupCount;

    //
    //  This is the number of references to this link.  The parent
    //  Scb must be owned to modify this count.
    //

    ULONG ReferenceCount;

    UCHAR FileNameFlags;

    //
    //  These are the flags for the changes to this link and the
    //  change count for the duplicated information on this link.
    //

    UCHAR InfoFlags;

    //
    //  The following are the case-sensitive and case-insensitive
    //  name links.
    //

    NAME_LINK IgnoreCaseLink;
    NAME_LINK ExactCaseLink;

    //
    //  A queue of Ccbs that have the Fcb (via this edge) opened.
    //  Corresponds to Ccb->LcbLinks
    //

    LIST_ENTRY CcbQueue;

    //
    //  Internal state of the Lcb
    //

    ULONG LcbState;

} LCB;
typedef LCB *PLCB;

#define LCB_STATE_DELETE_ON_CLOSE        (0x00000001)
#define LCB_STATE_LINK_IS_GONE           (0x00000002)
#define LCB_STATE_EXACT_CASE_IN_TREE     (0x00000004)
#define LCB_STATE_IGNORE_CASE_IN_TREE    (0x00000008)

#define LcbSplitPrimaryLink( LCB )  \
    ((LCB)->FileNameFlags == FILE_NAME_NTFS || (LCB)->FileNameFlags == FILE_NAME_DOS )

#define LcbSplitPrimaryComplement( LCB )    \
    (((LCB)->FileNameFlags == FILE_NAME_NTFS) ? FILE_NAME_DOS : FILE_NAME_NTFS)

#define LcbLinkIsDeleted( LCB )                                                 \
    ((FlagOn( (LCB)->LcbState, LCB_STATE_DELETE_ON_CLOSE ))                     \
     || ((FlagOn( (LCB)->FileNameFlags, FILE_NAME_DOS | FILE_NAME_NTFS ))       \
         && (FlagOn( (LCB)->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED ))))


//
//  The Fcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool while the SCB must be allocated from non-paged
//  pool.  There is an SCB for every file stream associated with the Fcb.
//
//  Note that the Fcb, multiple Scb records all use the same resource so
//  if we need to grab exclusive access to the Fcb we only need to grab one
//  resource and we've blocked all the scbs
//

typedef struct _FCB {

    //
    //  Type and size of this record must be NTFS_NTC_FCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The Queue of all the Lcb that we are part of.  The list is actually
    //  ordered in a small sense.  The get next scb routine that traverses the
    //  Fcb/Scb graph always will put the current lcb edge that it is traversing
    //  into the front of this queue.
    //

    LIST_ENTRY LcbQueue;

    //
    //  A pointer to the Vcb containing this Fcb
    //

    PVCB Vcb;

    //
    //  The internal state of the Fcb.  This is a collection Fcb state flags.
    //  Also the delete relavent counts for the file.
    //

    ULONG FcbState;
    ULONG FcbDenyDelete;
    ULONG FcbDeleteFile;

    //
    //  A count of the number of file objects that have been opened for
    //  this file, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this file.
    //

    CLONG CloseCount;

    //
    //  A count of other references to this Fcb.
    //

    CLONG ReferenceCount;

    //
    //  The following field contains the file reference for the Fcb
    //

    FILE_REFERENCE FileReference;

    //
    //  A queue of Scb associated with the fcb.
    //  Corresponds to Scb->FcbLinks
    //

    LIST_ENTRY ScbQueue;

    //
    //  These are the links for the list of exclusively-owned Scbs off of
    //  the IrpContext.  We need to keep track of the exclusive count
    //  in the Fcb before our acquire so we know how many times to release it.
    //

    LIST_ENTRY ExclusiveFcbLinks;

    //
    //  This is the links for all paging Io resources acquired for a transaction.
    //

    LIST_ENTRY ExclusivePagingIoLinks;

    USHORT BaseExclusiveCount;
    USHORT BaseExclusivePagingIoCount;

    //
    //  This counts the number of times the Ea's on this file have been
    //  modified.
    //

    USHORT EaModificationCount;

    //
    //  The following field is used to store a pointer to the resource
    //  protecting the Fcb
    //

    PERESOURCE Resource;

    //
    //  The following field contains a pointer to the resource synchronizing
    //  a changing FileSize with paging Io.
    //

    PERESOURCE PagingIoResource;

    //
    //  Copy of the duplicated information for this Fcb.
    //  Also a flags field to tell us what has changed in the structure.
    //

    LONGLONG CurrentLastAccess;

    DUPLICATED_INFORMATION Info;
    ULONG InfoFlags;
    ULONG LinkCount;

    //
    //  The following fields contains a pointer to the security descriptor for this
    //  file.  The field can start off null and later be loaded in by any of the
    //  security support routines.  On delete Fcb the field pool should be deallocated
    //  when the fcb goes away
    //

    struct _SHARED_SECURITY *SharedSecurity;
    ULONG CreateSecurityCount;

    //
    //  This is a pointer to a shared security descriptor for
    //  a non-index child of this directory.  Ignored for non-directory files.
    //

    struct _SHARED_SECURITY *ChildSharedSecurity;

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_FILE_DELETED           (0x00000001)
#define FCB_STATE_NONPAGED               (0x00000002)
#define FCB_STATE_PAGING_FILE            (0x00000004)
#define FCB_STATE_FROM_PRERESTART        (0x00000008)
#define FCB_STATE_DUP_INITIALIZED        (0x00000010)
#define FCB_STATE_NO_ACL                 (0x00000020)
#define FCB_STATE_UPDATE_STD_INFO        (0x00000040)
#define FCB_STATE_PRIMARY_LINK_DELETED   (0x00000080)
#define FCB_STATE_EA_SCB_INVALID         (0x00000100)
#define FCB_STATE_IN_FCB_TABLE           (0x00000200)
#define FCB_STATE_MODIFIED_SECURITY      (0x00000400)

#define FCB_INFO_CHANGED_CREATE          (0x00000001)
#define FCB_INFO_CHANGED_LAST_MOD        (0x00000002)
#define FCB_INFO_CHANGED_LAST_CHANGE     (0x00000004)
#define FCB_INFO_CHANGED_LAST_ACCESS     (0x00000008)
#define FCB_INFO_CHANGED_ALLOC_SIZE      (0x00000010)
#define FCB_INFO_CHANGED_FILE_SIZE       (0x00000020)
#define FCB_INFO_CHANGED_FILE_ATTR       (0x00000040)
#define FCB_INFO_CHANGED_EA_SIZE         (0x00000080)

#define FCB_CREATE_SECURITY_COUNT        (5)
#define FCB_LARGE_ACL_SIZE               (512)


//
//  The following three structures are the separate union structures for
//  Scb structure.
//

typedef struct _SCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    PFILE_LOCK FileLock;

    //
    //  Share Access structure for this stream.  May not be present
    //  in this Scb.  Check the flag in the Scb.
    //

    SHARE_ACCESS ShareAccess;

} SCB_DATA, *PSCB_DATA;

typedef struct _SCB_INDEX {

    //
    //  This is a list of records within the index allocation stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  A queue of all the lcbs that are opened under this Scb.
    //  Corresponds to Lcb->ScbLinks
    //

    LIST_ENTRY LcbQueue;

    //
    //  A change count incremented every time an index buffer is deleted.
    //

    ULONG ChangeCount;

    //
    //  Type of attribute being indexed.
    //

    ATTRIBUTE_TYPE_CODE AttributeBeingIndexed;

    //
    //  Collation rule, for how the indexed attribute is collated.
    //

    ULONG CollationRule;

    //
    //  Size of Index Allocation Buffer in bytes, or 0 if not yet
    //  initialized.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  Size of Index Allocation Buffers in units of clusters, or 0
    //  if not yet initialized.
    //

    UCHAR ClustersPerIndexBuffer;

    //
    //  Flag to indicate whether the RecordAllocationContext has been
    //  initialized or not.  If it is not initialized, this means
    //  either that there is no external index allocation, or that
    //  it simply has not been initialized yet.
    //

    BOOLEAN AllocationInitialized;

    //
    //  Index Depth Hint
    //

    USHORT IndexDepthHint;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  The following are the splay links of Lcbs opened under this
    //  Scb.  Note that not all of the Lcb in the list above may
    //  be in the splay links below.
    //

    PRTL_SPLAY_LINKS ExactCaseNode;
    PRTL_SPLAY_LINKS IgnoreCaseNode;

    //
    //  Share access structure for this file.
    //

    SHARE_ACCESS ShareAccess;

} SCB_INDEX, *PSCB_INDEX;

typedef struct _SCB_MFT {

    //
    //  This is a list of records within the Mft Scb stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  The following field contains index of a reserved free record.  To
    //  keep us out of the chicken & egg problem of the Mft being able to
    //  be self mapping we added the ability to reserve an mft record
    //  to describe additional mft data allocation within previous mft
    //  run.  A value of zero means that index has not been reserved.
    //

    ULONG ReservedIndex;

    //
    //  The following Mcb's are used to track clusters being added and removed
    //  from the Mcb for the Scb.  This Scb must always be fully loaded after
    //  an abort.  We can't depend on reloading on the next LookupAllocation
    //  call.  Instead we keep one Mcb with the clusters added and one Mcb
    //  with the clusters removed.  During the restore phase of abort we
    //  will adjust the Mft Mcb by reversing the operations done during the
    //  transactions.
    //

    LARGE_MCB AddedClusters;
    LARGE_MCB RemovedClusters;

    //
    //  The following are the changes made to the Mft file as file records are added,
    //  freed or allocated.  Also the change in the number of file records which are
    //  part of holes.
    //

    LONG FreeRecordChange;
    LONG HoleRecordChange;

} SCB_MFT, *PSCB_MFT;

//
//  The following is the non-paged part of the scb.
//

typedef struct _SCB_NONPAGED {

    //
    //  Type and size of this record must be NTFS_NTC_SCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  Index allocated for this file in the Open Attribute Table.
    //

    ULONG OpenAttributeTableIndex;

    //
    //  Copy of the Vcb pointer so we can find the Vcb in the dirty page callback
    //  routine.
    //

    PVCB Vcb;

} SCB_NONPAGED, *PSCB_NONPAGED;


//
//  The following structure is the stream control block.  There can
//  be multiple records per fcb.  One is created for each attribute being
//  handled as a stream file.
//

typedef struct _SCB {

    //
    //  The following field is used for fast I/O.  It contains the node type code
    //  and size, indicates if fast I/O is possible, contains allocation, file,
    //  and valid data size, a resource, and call back pointers for FastIoRead and
    //  FastMdlRead.
    //
    //  The node type codes for the Scb must be either NTFS_NTC_SCB_INDEX,
    //  NTFS_NTC_SCB_ROOT_INDEX, or NTFS_NTC_SCB_DATA.  Which one it is determines
    //  the state of the union below.
    //

    FSRTL_COMMON_FCB_HEADER Header;

    //
    //  The links for the queue of Scb off of a given Fcb.  And a pointer back
    //  to the Fcb.  Corresponds to Fcb->ScbQueue
    //

    LIST_ENTRY FcbLinks;
    PFCB Fcb;

    //
    //  A pointer to the Vcb containing this Scb
    //

    PVCB Vcb;

    //
    //  The internal state of the Scb.
    //

    ULONG ScbState;

    //
    //  The following two fields identify the actual attribute for this
    //  Scb with respect to its file.   We identify the attribute by
    //  its type code and name.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  Stream File Object for internal use.  This field is NULL if the file
    //  stream is not being accessed internally.
    //

    PFILE_OBJECT FileObject;

    //
    //  A count of the number of file objects that have been opened for
    //  this attribute, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this attribute.
    //

    CLONG CloseCount;

    //
    //  This pointer is used to detect writes that eminated from the
    //  cache manager's worker thread.  It prevents lazy writer threads,
    //  who already have the Fcb shared, from trying to acquire it
    //  exclusive, and thus causing a deadlock.
    //

    PVOID LazyWriteThread;

    //
    //  Pointer to structure containing snapshotted Scb values, or NULL
    //  if the values have not been snapshotted.
    //

    struct _SCB_SNAPSHOT * ScbSnapshot;

    //
    //  First unknown Vcn in the Mcb.  This field is maintained every time
    //  allocation is looked up by someone currently holding the Scb exclusive,
    //  in order to not "reload" space into the Mcb when deleting files with
    //  multiple file records.
    //

    VCN FirstUnknownVcn;

    //
    //  The following field contains the mcb for this Scb
    //

    LARGE_MCB Mcb;

    //
    //  Pointer to the non-paged section objects and open attribute
    //  table index.
    //

    PSCB_NONPAGED NonpagedScb;

    //
    //  Compression unit from attribute record.
    //

    ULONG CompressionUnit;

    //
    //  Highest Vcn written to disk, important for file compression.
    //

    VCN HighestVcnToDisk;

    //
    //  Number of clusters added due to Split Mcb calls.  The user has
    //  not asked for this allocation.
    //

    LONGLONG ExcessFromSplitMcb;

    //
    //  Scb Type union, for different types of Scbs
    //

    union {

        SCB_DATA Data;
        SCB_INDEX Index;
        SCB_MFT Mft;

    } ScbType;

} SCB;
typedef SCB *PSCB;

#define SIZEOF_SCB_DATA             (FIELD_OFFSET( SCB, ScbType ) + FIELD_OFFSET( SCB_DATA, ShareAccess ))
#define SIZEOF_SCB_SHARE_DATA       (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_DATA ))
#define SIZEOF_SCB_INDEX            (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_INDEX ))
#define SIZEOF_SCB_MFT              (FIELD_OFFSET( SCB, ScbType ) + sizeof( SCB_MFT ))

#define SCB_STATE_TRUNCATE_ON_CLOSE         (0x00000001)
#define SCB_STATE_DELETE_ON_CLOSE           (0x00000002)
#define SCB_STATE_CHECK_ATTRIBUTE_SIZE      (0x00000004)
#define SCB_STATE_ATTRIBUTE_RESIDENT        (0x00000008)
#define SCB_STATE_UNNAMED_DATA              (0x00000010)
#define SCB_STATE_HEADER_INITIALIZED        (0x00000020)
#define SCB_STATE_NONPAGED                  (0x00000040)
#define SCB_STATE_USA_PRESENT               (0x00000080)
#define SCB_STATE_INTERNAL_ATTR_STREAM      (0x00000100)
#define SCB_STATE_ATTRIBUTE_DELETED         (0x00000200)
#define SCB_STATE_FILE_SIZE_LOADED          (0x00000400)
#define SCB_STATE_MODIFIED_NO_WRITE         (0x00000800)
#define SCB_STATE_USE_PAGING_IO_RESOURCE    (0x00001000)
#define SCB_STATE_CC_HAS_PAGING_IO_RESOURCE (0x00002000)
#define SCB_STATE_CREATE_MODIFIED_SCB       (0x00004000)
#define SCB_STATE_UNINITIALIZE_ON_RESTORE   (0x00008000)
#define SCB_STATE_RESTORE_UNDERWAY          (0x00010000)
#define SCB_STATE_SHARE_ACCESS              (0x00020000)
#define SCB_STATE_NOTIFY_ADD_STREAM         (0x00040000)
#define SCB_STATE_NOTIFY_REMOVE_STREAM      (0x00080000)
#define SCB_STATE_NOTIFY_RESIZE_STREAM      (0x00100000)
#define SCB_STATE_NOTIFY_MODIFY_STREAM      (0x00200000)
#define SCB_STATE_TEMPORARY                 (0x00400000)
#define SCB_STATE_COMPRESSED                (0x00800000)
#define SCB_STATE_REALLOCATE_ON_WRITE       (0x01000000)
#define SCB_STATE_DELAY_CLOSE               (0x02000000)

#define MAX_SCB_ASYNC_ACQUIRE               (0xf000)


//
//  Structure to contain snapshotted Scb values for error recovery.
//

typedef struct _SCB_SNAPSHOT {

    //
    //  Links for list snapshot structures off of IrpContext
    //

    LIST_ENTRY SnapshotLinks;

    //
    //  Saved values of the corresponding Scb (or FsRtl Header) fields
    //  The low bit of allocation size is set to remember when the
    //  attribute was resident.  The next bit, bit 1, is set to remember
    //  when the attribute was compressed.
    //

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;

    VCN LowestModifiedVcn;

    //
    //  Compression Unit
    //

    ULONG CompressionUnit;

    //
    //  Pointer to the Scb which has been snapped.
    //

    PSCB Scb;

} SCB_SNAPSHOT;
typedef SCB_SNAPSHOT *PSCB_SNAPSHOT;


//
//  The Ccb record is allocated for every file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be NTFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The query template is used to filter directory query requests.
    //  It originally is set to null and on the first call the NtQueryDirectory
    //  it is set the the input filename or "*" if no name is supplied.
    //  All subsquent queries then use this template.
    //

    ULONG QueryLength;
    PVOID QueryBuffer;

    //
    //  The last returned value.  A copy of an IndexEntry is saved.  We only
    //  grow this buffer, to avoid always deallocating and reallocating.
    //

    ULONG IndexEntryLength;
    PINDEX_ENTRY IndexEntry;

    //
    //  Pointer to the index context structure for enumerations
    //

    struct _INDEX_CONTEXT *IndexContext;

    //
    //  This is the offset of the next Ea to return to the user.
    //

    ULONG NextEaOffset;

    //
    //  This is the Ccb Ea modification count.  If this count is in
    //  sync with the Fcb value, then the above offset is valid.
    //

    USHORT EaModificationCount;

    //
    //  Ccb flags.
    //

    ULONG Flags;

    //
    //  The links for the queue of Ccb off of a given Lcb and a pointer
    //  back to the Lcb.  Corresponds to Lcb->CcbQueue
    //

    LIST_ENTRY LcbLinks;
    PLCB Lcb;

    //
    //  This is a unicode string for the full filename used to
    //  open this file.
    //

    UNICODE_STRING FullFileName;
    USHORT LastFileNameOffset;

} CCB;
typedef CCB *PCCB;

#define CCB_FLAG_IGNORE_CASE                (0x00000001)
#define CCB_FLAG_OPEN_AS_FILE               (0x00000002)
#define CCB_FLAG_WILDCARD_IN_EXPRESSION     (0x00000004)
#define CCB_FLAG_OPEN_BY_FILE_ID            (0x00000008)
#define CCB_FLAG_USER_SET_LAST_MOD_TIME     (0x00000010)
#define CCB_FLAG_USER_SET_LAST_CHANGE_TIME  (0x00000020)
#define CCB_FLAG_USER_SET_LAST_ACCESS_TIME  (0x00000040)
#define CCB_FLAG_TRAVERSE_CHECK             (0x00000080)

#define CCB_FLAG_RETURN_DOT                 (0x00000100)
#define CCB_FLAG_RETURN_DOTDOT              (0x00000200)
#define CCB_FLAG_DOT_RETURNED               (0x00000400)
#define CCB_FLAG_DOTDOT_RETURNED            (0x00000800)

#define CCB_FLAG_DELETE_FILE                (0x00001000)
#define CCB_FLAG_DENY_DELETE                (0x00002000)

#define CCB_FLAG_ALLOCATED_FILE_NAME        (0x00004000)
#define CCB_FLAG_CLEANUP                    (0x00008000)


//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the NtfsComplete
//  request routine.
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be NTFS_NTC_IRP_CONTEXT)
    //
    //  NOTE:  THIS STRUCTURE MUST REMAIN 64-bit ALIGNED IN SIZE, SINCE
    //         IT IS ZONE ALLOCATED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    //
    //  This is a list of exclusively-owned Scbs which may only be
    //  released after the transaction is committed.
    //

    LIST_ENTRY ExclusiveFcbList;

    //
    //  This is a list of exclusively-owned paging Io resources which may only be
    //  released after the transaction is committed.
    //

    LIST_ENTRY ExclusivePagingIoList;

    //
    //  This structure contains the first ScbSnapshot for a modifying
    //  request which acquires files exclusive and snaps Scb values.
    //  If the SnapshotLinks field contains NULLs, then no data has
    //  been snapshot for this request, and the list is empty.  If
    //  the links are not NULL, then this snapshot structure is in
    //  use.  If the SnapshotLinks are not NULL, and do not represent
    //  an empty list, then there are addtional dynamically allocated
    //  snapshot structures in this list.
    //

    SCB_SNAPSHOT ScbSnapshot;

    //
    //  This is the Last Restart Area Lsn captured from the Vcb at
    //  the time log file full was raised.  The caller will force
    //  a checkpoint if this has not changed by the time he gets
    //  the global resource exclusive.
    //

    LSN LastRestartArea;

    //
    //  A pointer to the originating Irp.  We will store the Scb for
    //  delayed or async closes here while the request is queued.
    //

    PIRP OriginatingIrp;

    //
    //  Originating Device (required for workque algorithms)
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Irp Context flags
    //

    ULONG Flags;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception.  We will temporarily store the Ccb
    //  for a delayed or deferred close here while the request is queued.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Transaction Id for this request, which must be qualified by Vcb.
    //  We will store the type of open for a delayed or async close here
    //  while the request is queued.
    //

    PVCB Vcb;
    TRANSACTION_ID TransactionId;

    //
    //  The following field is used to maintain a queue of records that have been
    //  deallocated while processing this irp context.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  The following union contains pointers to the IoContext for I/O based requests
    //  and a pointer to a security context for requests which need to capture the
    //  subject context in the calling thread.
    //

    union {

        //
        //  The following context block is used for non-cached Io.
        //

        struct _NTFS_IO_CONTEXT *NtfsIoContext;

        //
        //  The following is the captured subject context.
        //

        PSECURITY_SUBJECT_CONTEXT SubjectContext;

    } Union;

    //
    //  This is the IrpContext for the top level request.
    //

    struct _IRP_CONTEXT *TopLevelIrpContext;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_FROM_POOL          (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT               (0x00000004)
#define IRP_CONTEXT_FLAG_WRITE_THROUGH      (0x00000008)
#define IRP_CONTEXT_LARGE_ALLOCATION        (0x00000010)
#define IRP_CONTEXT_DEFERRED_WRITE          (0x00000020)
#define IRP_CONTEXT_FLAG_ALLOC_CONTEXT      (0x00000040)
#define IRP_CONTEXT_FLAG_ALLOC_SECURITY     (0x00000080)
#define IRP_CONTEXT_MFT_RECORD_15_USED      (0x00000100)
#define IRP_CONTEXT_MFT_RECORD_RESERVED     (0x00000200)
#define IRP_CONTEXT_FLAG_IN_FSP             (0x00000400)
#define IRP_CONTEXT_FLAG_RAISED_STATUS      (0x00000800)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN        (0x00001000)
#define IRP_CONTEXT_FLAG_ACQUIRE_VCB_EX     (0x00002000)
#define IRP_CONTEXT_FLAG_READ_ONLY_FO       (0x00004000)


//
//  The top level context is used to determine whether this request has other
//  requests below it on the stack.
//

typedef struct _TOP_LEVEL_CONTEXT {

    BOOLEAN TopLevelRequest;

    ULONG Ntfs;

    VCN VboBeingHotFixed;

    PSCB ScbBeingHotFixed;

    PIRP SavedTopLevelIrp;

    PIRP_CONTEXT TopLevelIrpContext;

} TOP_LEVEL_CONTEXT;
typedef TOP_LEVEL_CONTEXT *PTOP_LEVEL_CONTEXT;


//
//  The found attribute part of the attribute enumeration context describes
//  an attribute record that had been located or created.  It may refer to
//  either a base or attribute list.
//

typedef struct _FOUND_ATTRIBUTE {

    //
    //  The following identify the attribute which was mapped.  These are
    //  necessary if forcing the range of bytes into memory by pinning.
    //  These include the Bcb on which the attribute was read (if this field
    //  is NULL, this is the initial attribute) and the offset of the
    //  record segment in the Mft.
    //

    PBCB Bcb;

    LONGLONG MftFileOffset;

    //
    //  Pointer to the Attribute Record
    //

    PATTRIBUTE_RECORD_HEADER Attribute;

    //
    //  Pointer to the containing record segment.
    //

    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    //
    //  Some state information.
    //

    BOOLEAN AttributeDeleted;
    BOOLEAN AttributeAllocationDeleted;

} FOUND_ATTRIBUTE;
typedef FOUND_ATTRIBUTE *PFOUND_ATTRIBUTE;

//
//  The structure guides enumeration through the attribute list.
//

typedef struct _ATTRIBUTE_LIST_CONTEXT {

    //
    //  This field is used to remember the location of the Attribute
    //  List attribute within the base file record, if existent.
    //

    PATTRIBUTE_RECORD_HEADER AttributeList;

    //
    //  A Bcb for the attribute list.
    //

    PBCB Bcb;

    //
    //  This points to the first entry in the attribute list.  This is
    //  needed when the attribute list is non-resident.
    //

    PATTRIBUTE_LIST_ENTRY FirstEntry;

    //
    //  This points to the first attribute list entry; it is advanced
    //  when we are searching for a particular exteral attribute.
    //

    PATTRIBUTE_LIST_ENTRY Entry;

    //
    //  This points just beyond the final attribute list entry.
    //

    PATTRIBUTE_LIST_ENTRY BeyondFinalEntry;

} ATTRIBUTE_LIST_CONTEXT;
typedef ATTRIBUTE_LIST_CONTEXT *PATTRIBUTE_LIST_CONTEXT;

//
//  The Attribute Enumeration Context structure returns information on an
//  attribute which has been found by one of the Attribute Lookup or Creation
//  routines.  It is also used as an IN OUT structure to perform further
//  lookups/modifications to attributes.  It does not have a node type code
//  and size since it is usually allocated on the caller's stack.
//

typedef struct _ATTRIBUTE_ENUMERATION_CONTEXT {

    //
    //  Contains the actual attribute we found.
    //

    FOUND_ATTRIBUTE FoundAttribute;

    //
    //  Allows enumeration through the attribute list.
    //

    ATTRIBUTE_LIST_CONTEXT AttributeList;

} ATTRIBUTE_ENUMERATION_CONTEXT;
typedef ATTRIBUTE_ENUMERATION_CONTEXT *PATTRIBUTE_ENUMERATION_CONTEXT;


//
//  Define struct which will be used to remember the path that was followed
//  to locate a given INDEX_ENTRY or insertion point for an INDEX_ENTRY.
//  This structure is always filled in by LookupIndexEntry.
//
//  The Index Lookup Stack is generally allocated as a local variable in
//  one of the routines in this module that may be called from another module.
//  A pointer to this stack is then passed in to some of the internal routines.
//
//  The first entry in the stack describes context in the INDEX attribute in the
//  file record, and all subsequent stack entries refer to Index buffers in
//  the INDEX_ALLOCATION attribute.
//
//  Outside of indexsup.c, this structure should only be passed as an "opaque"
//  context, and individual fields should not be referenced.
//

typedef struct _INDEX_LOOKUP_STACK {

    //
    //  Bcb pointer for the Index Buffer.  In the "bottom" (first entry) of
    //  the stack this field contains a NULL, and the Bcb must be found via
    //  the Attribute Enumeration Context.
    //

    PBCB Bcb;

    //
    //  Pointer to the start of the File Record or Index Buffer
    //

    PVOID StartOfBuffer;

    //
    //  Pointer to Index Header in the File Record or Index Buffer
    //

    PINDEX_HEADER IndexHeader;

    //
    //  Pointer to to the current INDEX_ENTRY on search path
    //

    PINDEX_ENTRY IndexEntry;

    //
    //  Vcn of IndexBuffer
    //

    VCN Vcn;

    //
    //  Saved Lsn for faster enumerations
    //

    LSN CapturedLsn;

} INDEX_LOOKUP_STACK;

typedef INDEX_LOOKUP_STACK *PINDEX_LOOKUP_STACK;

#define INDEX_LOOKUP_STACK_SIZE      (3)

//
//  Index Context structure.
//
//  This structure maintains a context which describes the lookup stack to a
//  given index entry.  It includes the Attribute Enumeration Context for the
//  Index Root, the Index lookup stack remembering the path to the index entry,
//  and the current stack pointer within the stack pointing to the stack entry
//  for the current index entry or where we are at in a bucket split or delete
//  operation.
//
//  Outside of indexsup.c, this structure should only be passed as an "opaque"
//  context, and individual fields should not be referenced.
//

typedef struct _INDEX_CONTEXT {

    //
    //  Index lookup stack.
    //

    INDEX_LOOKUP_STACK LookupStack[INDEX_LOOKUP_STACK_SIZE];

    //
    //  Base of dynamically allocated lookup stack - either points
    //  to the one above or a dynamically allocated larger one.
    //

    PINDEX_LOOKUP_STACK Base;

    //
    //  Stack pointer within the Index Lookup Stack
    //

    PINDEX_LOOKUP_STACK Current;

    //
    //  Stack pointer to top of Lookup Stack.  This field essentially
    //  remembers how deep the index Btree is.
    //

    PINDEX_LOOKUP_STACK Top;

    //
    //  Captured Scb (Index type) change count
    //

    ULONG ScbChangeCount;

    //
    //  This field remembers where the index root attribute was last
    //  seen, to support correct operation of FindMoveableIndexRoot.
    //

    PATTRIBUTE_RECORD_HEADER OldAttribute;

    //
    //  Number of entries allocated in the lookup stack.
    //

    USHORT NumberEntries;

    //
    //  Reserved...
    //

    USHORT Reserved;

    //
    //  Attribute Enumeration Context for the Index Root
    //

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

} INDEX_CONTEXT;

typedef INDEX_CONTEXT *PINDEX_CONTEXT;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the Read/Write Multiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _NTFS_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    UCHAR IrpSpFlags;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;

        } Async;

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;

    } Wait;


} NTFS_IO_CONTEXT;

typedef NTFS_IO_CONTEXT *PNTFS_IO_CONTEXT;

//
//  An array of these structures is passed to NtfsMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    VBO StartingVbo;
    LBO StartingLbo;
    ULONG BufferOffset;
    ULONG ByteCount;
    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;


//
//  This structure is used by the name manipulation routines to described a
//  parsed file name componant.
//

typedef struct _NTFS_NAME_DESCRIPTOR {

    //
    //  The follow flag tells which fields were present in the name.
    //

    ULONG FieldsPresent;

    UNICODE_STRING FileName;
    UNICODE_STRING AttributeType;
    UNICODE_STRING AttributeName;
    ULONG VersionNumber;

} NTFS_NAME_DESCRIPTOR;
typedef NTFS_NAME_DESCRIPTOR *PNTFS_NAME_DESCRIPTOR;

//
//  Define the bits in FieldsPresent above.
//

#define FILE_NAME_PRESENT_FLAG          (1)
#define ATTRIBUTE_TYPE_PRESENT_FLAG     (2)
#define ATTRIBUTE_NAME_PRESENT_FLAG     (4)
#define VERSION_NUMBER_PRESENT_FLAG     (8)


//
//  The following is used to perform Ea related routines.
//

typedef struct _EA_LIST_HEADER {

    //
    //  The size of buffer needed to pack these Ea's
    //

    ULONG PackedEaSize;

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;

    //
    //  This is the size of the buffer used to store the ea's
    //

    ULONG BufferSize;

    //
    //  This is the pointer to the first entry in the list.
    //

    PFILE_FULL_EA_INFORMATION FullEa;

} EA_LIST_HEADER;
typedef EA_LIST_HEADER *PEA_LIST_HEADER;


//
//  The following structure is used to maintain a list of recently deallocated
//  records so that the file system will not reuse a recently deallocated record
//  until it is safe to do so.  Each instance of this structure is placed on
//  two queues.  One queue is per index SCB and the other queue is per Irp Context.
//
//  Whenever we delete a record we allocate a new structure if necessary and add
//  it to the scb queue and the irp context queue.  We indicate in the structure
//  the index of the record we just deallocated.
//
//  Whenever we need to allocate a new record we filter out any canidate we want
//  to allocate to avoid allocating one in the scb's recently deallocated queue.
//
//  Whenever we delete an irp context we scan through its recently deallocated
//  queue removing it from the scb queue.
//

#define DEALLOCATED_RECORD_ENTRIES          32

typedef struct _DEALLOCATED_RECORDS {

    //
    //  The following field links this structure into the Scb->RecentlyDeallocatedQueue
    //

    LIST_ENTRY ScbLinks;

    //
    //  The following field links this structure into the IrpContext->RecentlyDeallocatedQueue
    //

    LIST_ENTRY IrpContextLinks;

    //
    //  This is a pointer to the Scb that this record is part of
    //

    PSCB Scb;

    //
    //  The following two fields describe the total size of this structure and
    //  the number of entries actually being used.  NumberOfEntries is the size
    //  of the Index array and NextFreeEntryis the index of the next free slot.
    //  If NumberOfEntries is equal to NextFreeEntry then this structure is full
    //

    ULONG NumberOfEntries;
    ULONG NextFreeEntry;

    //
    //  This is an array of indices that have been dealloated.
    //

    ULONG Index[DEALLOCATED_RECORD_ENTRIES];

} DEALLOCATED_RECORDS;
typedef DEALLOCATED_RECORDS *PDEALLOCATED_RECORDS;

#define DEALLOCATED_RECORDS_HEADER_SIZE (FIELD_OFFSET( DEALLOCATED_RECORDS, Index ))

typedef struct _FCB_TABLE_ELEMENT {

    FILE_REFERENCE FileReference;
    PFCB Fcb;

} FCB_TABLE_ELEMENT;
typedef FCB_TABLE_ELEMENT *PFCB_TABLE_ELEMENT;


//
//  Security descriptor information.  This structure is used to allow
//  Fcb's to share security descriptors.
//

typedef struct _SHARED_SECURITY {

    PFCB ParentFcb;
    ULONG ReferenceCount;
    ULONG SecurityDescriptorLength;
    UCHAR SecurityDescriptor[1];

} SHARED_SECURITY, *PSHARED_SECURITY;


//
//  The following structure is used to store the state of an Scb to use during
//  unwind operations.  We keep a copy of all of the file sizes.
//

typedef struct _OLD_SCB_SNAPSHOT {

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;

    UCHAR CompressionUnit;
    BOOLEAN Resident;
    BOOLEAN Compressed;

} OLD_SCB_SNAPSHOT, *POLD_SCB_SNAPSHOT;

//
//  Structure used to track the number of threads doing read ahead, so that
//  we do not hot fix for them.
//

typedef struct _READ_AHEAD_THREAD {

    //
    //  Links of read ahead structures.
    //

    LIST_ENTRY Links;

    //
    //  Thread Id
    //

    PVOID Thread;
} READ_AHEAD_THREAD, *PREAD_AHEAD_THREAD;

//
//  Structure used to post to Defrag Mft routine.
//

typedef struct _DEFRAG_MFT {

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    PVCB Vcb;

    BOOLEAN DeallocateWorkItem;

} DEFRAG_MFT, *PDEFRAG_MFT;

#endif // _NTFSSTRU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\nbedit.cxx ===
#include "ulib.hxx"
#include "nbedit.hxx"
#include "untfs.hxx"

extern "C" {
#include <stdio.h>
}


VOID
NTFS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
NTFS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PPACKED_BOOT_SECTOR     p;
    BIOS_PARAMETER_BLOCK    bpb;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    p = (PPACKED_BOOT_SECTOR) _buffer;
    UnpackBios(&bpb, &(p->PackedBpb));

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String:           %c%c%c%c%c%c%c%c"),
                 p->Oem[0],
                 p->Oem[1],
                 p->Oem[2],
                 p->Oem[3],
                 p->Oem[4],
                 p->Oem[5],
                 p->Oem[6],
                 p->Oem[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector:     %x"), bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster:  %x"), bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors:     %x"),  bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats:       %x"), bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries:         %x"), bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count:   %x"), bpb.Sectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte:           %x"), bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat:      %x"), bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per track:    %x"), bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads:      %x"), bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors: %x"), bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors:  %x"), bpb.LargeSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Physical drive:       %x"), p->PhysicalDrive);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("NTFS number of sectors:   %x"), p->NumberSectors.LowPart);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("MFT starting cluster: %x"), p->MftStartLcn.GetLowPart());
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("MFT mirror starting cluster: %x"),
                 p->Mft2StartLcn.GetLowPart());
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Clusters per file record:    %x"),
                 p->ClustersPerFileRecordSegment);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Clusters per index block:    %x"),
                 p->DefaultClustersPerIndexAllocationBuffer);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("SerialNumber:         %08x%08x"), p->SerialNumber.HighPart,
                                           p->SerialNumber.LowPart);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Checksum:             %x"), p->Checksum);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\logreced.cxx ===
#include "ulib.hxx"
#include "logreced.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "lfs.h"
#include "lfsdisk.h"
//#include "ntfsstru.h"
#include "ntfslog.h"

extern "C" {
#include <stdio.h>
}


BOOLEAN
LOG_RECORD_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _drive = Drive;

    if (!_drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read()) {

        return FALSE;
    }

    _cluster_factor = ntfssa.QueryClusterFactor();
    _frs_size = ntfssa.QueryFrsSize();

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
LOG_RECORD_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/4);
}


VOID
LOG_RECORD_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR                           buf[1024];
    INT                             nDrawX, nDrawY;
    PLFS_RECORD_HEADER              plog;
    PNTFS_LOG_RECORD_HEADER         pntfs_record;
    TEXTMETRIC                      tm;
    INT                             ch, CurrentLine;

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/4, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    if (!_buffer || !_size) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    plog = (PLFS_RECORD_HEADER)_buffer;
    pntfs_record = PNTFS_LOG_RECORD_HEADER(PUCHAR(_buffer) +
         LFS_RECORD_HEADER_SIZE);

    swprintf(buf, TEXT("ThisLsn: %x:%x"),
         plog->ThisLsn.HighPart,
         plog->ThisLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientPreviousLsn: %x:%x"),
         plog->ClientPreviousLsn.HighPart,
         plog->ClientPreviousLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientUndoNextLsn: %x:%x"),
         plog->ClientUndoNextLsn.HighPart,
         plog->ClientUndoNextLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientDataLength: %x"), plog->ClientDataLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientId.SeqNumber: %x"), plog->ClientId.SeqNumber);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientId.ClientIndex: %x"), plog->ClientId.ClientIndex);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordType: %x"), plog->RecordType);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TransactionId: %x"), plog->TransactionId);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (LOG_RECORD_MULTI_PAGE == plog->Flags) {
        swprintf(buf, TEXT("Flags: LOG_RECORD_MULTI_PAGE"));
    } else {
        swprintf(buf, TEXT("Flags: %x"), plog->Flags);
    }
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    swprintf(buf, TEXT("RedoOperation: %x"), pntfs_record->RedoOperation);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoOperation: %x"), pntfs_record->UndoOperation);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RedoOffset: %x"), pntfs_record->RedoOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RedoLength: %x"), pntfs_record->RedoLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoOffset: %x"), pntfs_record->UndoOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("UndoLength: %x"), pntfs_record->UndoLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TargetAttribute: %x"), pntfs_record->TargetAttribute);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LcnsToFollow: %x"), pntfs_record->LcnsToFollow);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordOffset: %x"), pntfs_record->RecordOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("AttributeOffset: %x"), pntfs_record->AttributeOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("TargetVcn: %x"), (ULONG)pntfs_record->TargetVcn);
    WriteLine(DeviceContext, CurrentLine++, buf);

    if (0 != pntfs_record->LcnsToFollow) {

        WriteLine(DeviceContext, CurrentLine++, TEXT("Lcns:"));
    
        for (USHORT i = 0; i < pntfs_record->LcnsToFollow; ++i) {
    
            swprintf(buf, TEXT("    %x"), (ULONG)pntfs_record->LcnsForPage[i]);
            WriteLine(DeviceContext, CurrentLine++, buf);
        }
    }
}

VOID
LOG_RECORD_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
LOG_RECORD_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\partedit.cxx ===
#include "ulib.hxx"
#include "partedit.hxx"


extern "C" {
#include <stdio.h>
}

BOOLEAN
PARTITION_TABLE_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);

    return TRUE;
}


VOID
PARTITION_TABLE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}


VOID
PARTITION_TABLE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PARTITION_TABLE_ENTRY   Entry;
    PPARTITION_TABLE_ENTRY  p;
    TEXTMETRIC              textmetric;
    INT                     ch, CurrentLine;
    TCHAR                   buf[1024];
    ULONG                   i, Checksum, *pul;

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    p = (PPARTITION_TABLE_ENTRY)((PBYTE)_buffer+0x1be);

    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    CurrentLine = 0;

    swprintf( buf, TEXT("Disk Signature: 0x%x"), *((PULONG)_buffer + 0x6E) );
    WriteLine( DeviceContext, CurrentLine++, buf );

    // Compute the sector checksum.
    //
    Checksum = 0;

    for( i = 0, pul = (PULONG)_buffer; i < 0x80; i++, pul++ ) {

        Checksum += *pul;
    }

    swprintf( buf, TEXT("Sector Checksum: 0x%x"), Checksum );
    WriteLine( DeviceContext, CurrentLine++, buf );

    swprintf( buf, TEXT("") );
    WriteLine( DeviceContext, CurrentLine++, buf );

    for( i = 0; i < 4; i++ ) {

        memcpy( &Entry, p, sizeof(PARTITION_TABLE_ENTRY) );

        swprintf( buf, TEXT("Entry %d"), i );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Boot Indicator: 0x%x"), Entry.BootIndicator );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Head: 0x%x"), Entry.BeginningHead );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Sector: 0x%x"), Entry.BeginningSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Beginning Cylinder: 0x%x"), Entry.BeginningCylinder );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  System ID: 0x%x"), Entry.SystemID );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Head: 0x%x"), Entry.EndingHead );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Sector: 0x%x"), Entry.EndingSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Ending Cylinder: 0x%x"), Entry.EndingCylinder );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Starting Sector: 0x%x"), Entry.StartingSector );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("  Sectors: 0x%x"), Entry.Sectors );
        WriteLine( DeviceContext, CurrentLine++, buf );

        swprintf( buf, TEXT("") );
        WriteLine( DeviceContext, CurrentLine++, buf );

        p++;
    }

    SetRange(WindowHandle, CurrentLine - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\recordpg.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "untfs.hxx"
#include "recordpg.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
RECORD_PAGE_EDIT::Initialize(
    IN      HWND    WindowHandle,
    IN      INT     ClientHeight,
    IN      INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  tm;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &tm);
    ReleaseDC(WindowHandle, hdc);

    if (!VERTICAL_TEXT_SCROLL::Initialize(
        WindowHandle,
        0,
        ClientHeight,
        ClientWidth,
        tm.tmExternalLeading + tm.tmHeight,
        tm.tmMaxCharWidth
        )) {
        return FALSE;
    }

    return TRUE;
}


VOID
RECORD_PAGE_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/2);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
RECORD_PAGE_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PLFS_RECORD_PAGE_HEADER pRecordPageHeader;
    TEXTMETRIC tm;
    INT ch, CurrentLine;
    TCHAR buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/2, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    if (!_buffer || _size < 512) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    pRecordPageHeader = (PLFS_RECORD_PAGE_HEADER)_buffer;

    swprintf(buf, TEXT("MultiSectorHeader.Signature: %c%c%c%c"),
        pRecordPageHeader->MultiSectorHeader.Signature[0],
        pRecordPageHeader->MultiSectorHeader.Signature[1],
        pRecordPageHeader->MultiSectorHeader.Signature[2],
        pRecordPageHeader->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);
    
    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArrayOffset: %ul"),
        pRecordPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);
    
    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArraySize: %x"),
        pRecordPageHeader->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Copy.LastLsn: %x:%x"),
        pRecordPageHeader->Copy.LastLsn.HighPart,
        pRecordPageHeader->Copy.LastLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Copy.FileOffset: %x"), pRecordPageHeader->Copy.FileOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Flags: %x"), pRecordPageHeader->Flags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("PageCount: %x"), pRecordPageHeader->PageCount);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("PagePosition: %x"), pRecordPageHeader->PagePosition);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Header.Packed.NextRecordOffset: %x"),
        pRecordPageHeader->Header.Packed.NextRecordOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Header.Packed.LastEndLsn: %x:%x"),
        pRecordPageHeader->Header.Packed.LastEndLsn.HighPart,
        pRecordPageHeader->Header.Packed.LastEndLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    // then Header.Packed.UpdateSequenceArray
}

VOID
RECORD_PAGE_EDIT::KeyUp(
    IN HWND WindowHandle
    )
{
    ScrollUp(WindowHandle);
}

VOID
RECORD_PAGE_EDIT::KeyDown(
    IN HWND WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\rootio.cxx ===
#include "ulib.hxx"
#include "rootio.hxx"
#include "diskedit.h"
#include "rfatsa.hxx"

extern "C" {
#include <stdio.h>
}


BOOLEAN
ROOT_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    REAL_FAT_SA             fatsa;
    MESSAGE                 msg;

    _drive = Drive;

    *Error = TRUE;

    if (!_drive ||
        !fatsa.Initialize(_drive, &msg) ||
        !fatsa.FAT_SA::Read() ||
        !_rootdir.Initialize(Mem, _drive,
                             fatsa.QueryReservedSectors() +
                             fatsa.QueryFats() * fatsa.QuerySectorsPerFat(),
                             fatsa.QueryRootEntries())) {

        return FALSE;
    }

    _buffer = _rootdir.GetDirEntry(0);
    _buffer_size = ((BytesPerDirent*fatsa.QueryRootEntries() - 1)/
                     _drive->QuerySectorSize() + 1)*_drive->QuerySectorSize();

    wsprintf(_header_text, TEXT("DiskEdit - Root Directory"));

    return TRUE;
}


BOOLEAN
ROOT_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_rootdir.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
ROOT_IO::Write(
    )
{
    return _drive ? _rootdir.Write() : FALSE;
}


PVOID
ROOT_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
ROOT_IO::GetHeaderText(
    )
{
    return _header_text;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\secio.cxx ===
#include "ulib.hxx"
#include "secio.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG StartSector = 0;
STATIC ULONG NumSectors = 0;


BOOLEAN
SECTOR_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{

    if (!DialogBox((HINSTANCE)Application, TEXT("ReadSectorsBox"),
                   WindowHandle, ReadSectors)) {
        *Error = FALSE;
        return FALSE;
    }

    *Error = TRUE;

    _drive = Drive;

    if (!NumSectors || !_drive) {
        return FALSE;
    }

    if (!_secrun.Initialize(Mem, _drive, StartSector, NumSectors)) {
        return FALSE;
    }

    swprintf(_header_text, TEXT("DiskEdit - Sector 0x%X for 0x%X"),
        StartSector, NumSectors);

    return TRUE;
}


BOOLEAN
SECTOR_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }
    if (!_secrun.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
SECTOR_IO::Write(
    )
{
    return _drive ? _secrun.Write() : FALSE;
}


PVOID
SECTOR_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _drive ? (_drive->QuerySectorSize()*_secrun.QueryLength()) : 0;
    }

    return _secrun.GetBuf();
}


PTCHAR
SECTOR_IO::GetHeaderText(
    )
{
    return _header_text;
}


INT_PTR
ReadSectors(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            TCHAR buf[1024];
            INT n;

            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &StartSector);

            n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &NumSectors);

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\secstr.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "secstr.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"

extern "C" {
#include <stdio.h>
}

///////////////////////////////////////////////////////////////////////////////
//  Security stream support                                                  //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SECURITY_STREAM_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;
    NTFS_SA     ntfssa;
    MESSAGE     msg;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;

    return VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth);
}


VOID
SECURITY_STREAM_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
}

VOID
SECURITY_STREAM_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    ScrollUp(WindowHandle);
}


VOID
SECURITY_STREAM_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    ScrollDown(WindowHandle);
}

VOID
SECURITY_STREAM_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    TCHAR buf[1024];

    if (!_buffer || !_size) {
        return;
    }

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));


    //
    //  While there are more windows to dump
    //

    PVOID CurrentWindow = _buffer;
    INT CurrentLine = 0;

    while ((PCHAR)CurrentWindow < (PCHAR)_buffer + _size) {

        //
        //  Dump window
        //

        PSECURITY_DESCRIPTOR_HEADER Header = (PSECURITY_DESCRIPTOR_HEADER) CurrentWindow;

        while ((PBYTE)Header < (PBYTE)CurrentWindow + 256 * 1024 &&
               Header->HashKey.SecurityId != SECURITY_ID_INVALID) {

            swprintf( buf, TEXT( "%08x: Hash %08x  SecurityId %08x  Offset %016I64x  Length %08x" ),
                      (PCHAR)Header - (PCHAR)_buffer,
                      Header->HashKey.Hash, Header->HashKey.SecurityId,
                      Header->Offset, Header->Length );
            WriteLine( DeviceContext, CurrentLine++, buf );

            Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)Header + ((Header->Length + 15) & ~15));
        }

        //
        //  Dump mirror
        //

        Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE) CurrentWindow + 256 * 1024);

        while ((PBYTE)Header < (PBYTE)_buffer + _size &&
               (PBYTE)Header < (PBYTE)CurrentWindow + 512 * 1024 &&
               Header->HashKey.SecurityId != SECURITY_ID_INVALID) {

            swprintf( buf, TEXT( "%08x: Hash %08x  SecurityId %08x  Offset %016I64x  Length %08x" ),
                      (PCHAR)Header - (PCHAR)_buffer,
                      Header->HashKey.Hash, Header->HashKey.SecurityId,
                      Header->Offset, Header->Length );
            WriteLine( DeviceContext, CurrentLine++, buf );

            Header = (PSECURITY_DESCRIPTOR_HEADER) ((PBYTE)Header + ((Header->Length + 15) & ~15));
        }

        //
        //  Advance to next block
        //

        CurrentWindow = (PVOID) ((PBYTE)CurrentWindow + 512 * 1024);
    }

    SetRange(WindowHandle, CurrentLine + 50);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\sources.inc ===
!IF 0

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=diskedit
TARGETPATH=obj
TARGETTYPE=PROGRAM

INCLUDES= \
    $(SDK_INC_PATH)\port1632;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    ..;\
    $(DDK_INC_PATH)

C_DEFINES= -DWIN32 -DUNICODE -D_UNICODE

SOURCES=                   \
        ..\attrio.cxx      \
        ..\chainio.cxx     \
        ..\clusio.cxx      \
        ..\crack.cxx       \
        ..\diskedit.cxx    \
        ..\edit.cxx        \
        ..\fileio.cxx      \
        ..\frsedit.cxx     \
        ..\frsio.cxx       \
        ..\gptedit.cxx     \
        ..\indxedit.cxx    \
        ..\io.cxx          \
        ..\rootio.cxx      \
        ..\secedit.cxx     \
        ..\secio.cxx       \
        ..\vscroll.cxx     \
        ..\bootedit.cxx    \
        ..\nbedit.cxx      \
        ..\partedit.cxx    \
        ..\recordpg.cxx    \
        ..\restarea.cxx    \
        ..\logreced.cxx    \
        ..\logrecio.cxx    \
        ..\atrlsted.cxx    \
        ..\secstr.cxx      \
        ..\res.rc

USE_MSVCRT=1

UMENTRY=winmain
UMTYPE=windows
TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(PROJECT_ROOT)\fs\utils\untfs\src\$(ALT_PROJECT)\$(O)\untfs.lib \
    $(PROJECT_ROOT)\fs\utils\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib \
    $(SDK_LIB_PATH)\ntdll.lib

W32_SB=1
SOURCES_USED=..\sources.inc

PRECOMPILED_INCLUDE=..\ulib.hxx
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\secedit.cxx ===
#include "ulib.hxx"
#include "secedit.hxx"

extern "C" {
#include <ctype.h>
#include <stdio.h>
}


BOOLEAN
SECTOR_EDIT::Initialize(
    IN  HWND    WindowHandle,
    IN  INT     ClientHeight,
    IN  INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textmetric;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(hdc, &textmetric);
    ReleaseDC(WindowHandle, hdc);

    _buffer = NULL;
    _size = 0;
    _edit_nibble = 0;

    if (!VERTICAL_TEXT_SCROLL::Initialize(
            WindowHandle,
            0,
            ClientHeight,
            ClientWidth,
            textmetric.tmExternalLeading + textmetric.tmHeight,
            textmetric.tmMaxCharWidth)) {
        return FALSE;
    }

    return TRUE;
}


VOID
SECTOR_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;

    SetScrollPos(WindowHandle, SB_VERT, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
    SetRange(WindowHandle, _size/16);
}


VOID
SECTOR_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    INT     xcoor, ycoor;
    PUCHAR  p;
    TCHAR   buf[10];
    INT     i, j;

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    ycoor = InvalidRect.top/QueryCharHeight()*QueryCharHeight();
    p = (PUCHAR) _buffer;
    for (i = QueryScrollPosition() + InvalidRect.top/QueryCharHeight();
         (unsigned)i < _size/16 && ycoor < InvalidRect.bottom; i++) {

        xcoor = 0;
        swprintf(buf, TEXT("%04X"), i*16);
        TextOut(DeviceContext, xcoor, ycoor, buf, 4);
        xcoor += 6*QueryCharWidth();

        for (j = 0; j < 16; j++) {

            if (j == 8) {
                xcoor += QueryCharWidth();
            }

            swprintf(buf, TEXT("%02X"), p[i*16 + j]);
            TextOut(DeviceContext, xcoor, ycoor, buf, 2);
            xcoor += 3*QueryCharWidth();
        }
        xcoor += QueryCharWidth();

        for (j = 0; j < 16; j++) {
            swprintf(buf, TEXT("%c"), isprint(p[i*16+j]) ? p[i*16+j] : '.');
            TextOut(DeviceContext, xcoor, ycoor, buf, 1);
            xcoor += QueryCharWidth();
        }

        ycoor += QueryCharHeight();
    }

    if (_edit_nibble < ULONG(32*QueryScrollPosition()) ||
        _edit_nibble >=
        ULONG(32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) ||
        _edit_nibble >= 2*_size) {

        _edit_nibble = min((ULONG)32*QueryScrollPosition(), (ULONG)2*_size - 1);
    }

    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyUp(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble < 32) {
        return;
    }

    if (_edit_nibble - 32 < ULONG(32*QueryScrollPosition())) {
        ScrollUp(WindowHandle);
    }

    _edit_nibble -= 32;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyDown(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble + 32 >= 2*_size) {
        return;
    }

    if (_edit_nibble + 32 >= (ULONG)
        32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) {

        ScrollDown(WindowHandle);
    }

    _edit_nibble += 32;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyLeft(
    IN  HWND    WindowHandle
    )
{
    if (!_edit_nibble) {
        return;
    }

    if (_edit_nibble == (ULONG)32*QueryScrollPosition()) {
        ScrollUp(WindowHandle);
    }

    _edit_nibble--;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KeyRight(
    IN  HWND    WindowHandle
    )
{
    if (_edit_nibble + 1 >= 2*_size) {
        return;
    }

    if (_edit_nibble + 1 == (ULONG)
        32*(QueryScrollPosition() + QueryClientHeight()/QueryCharHeight())) {

        ScrollDown(WindowHandle);
    }

    _edit_nibble++;
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::Click(
    IN  HWND    WindowHandle,
    IN  INT     Xcoordinate,
    IN  INT     Ycoordinate
    )
{
    Xcoordinate /= QueryCharWidth();
    Ycoordinate /= QueryCharHeight();

    if (Xcoordinate < 6 || Xcoordinate >= 54 || Xcoordinate % 3 == 2 ||
        Ycoordinate + QueryScrollPosition() >= QueryNumLines()) {
        return;
    }

    _edit_nibble = (Ycoordinate + QueryScrollPosition())*32 +
                   ((Xcoordinate - 6)/3)*2 +
                   ((Xcoordinate % 3 == 1) ? 1 : 0);

    SetCaretToNibble();
}


VOID
SECTOR_EDIT::Character(
    IN  HWND    WindowHandle,
    IN  CHAR    Char
    )
{
    PUCHAR  p;
    UCHAR   nibble;
    BOOLEAN nibble_entered;

    p = (PUCHAR) _buffer;
    if (Char >= '0' && Char <= '9') {
        nibble = Char - '0';
        nibble_entered = TRUE;
    } else if (Char >= 'a' && Char <= 'f') {
        nibble = Char - 'a' + 10;
        nibble_entered = TRUE;
    } else {
        nibble_entered = FALSE;
    }

    if (nibble_entered) {
        if (_edit_nibble%2 == 0) {
            nibble = (nibble << 4);
            p[_edit_nibble/2] &= 0x0F;
            p[_edit_nibble/2] |= nibble;
        } else {
            p[_edit_nibble/2] &= 0xF0;
            p[_edit_nibble/2] |= nibble;
        }
    }

    InvalidateNibbleRect(WindowHandle);
    _edit_nibble++;
    if (_edit_nibble >= _size*2) {
        _edit_nibble--;
    }
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::SetFocus(
    IN  HWND    WindowHandle
    )
{
    EDIT_OBJECT::SetFocus(WindowHandle);

    if (!_size || !_buffer) {
        return;
    }

    CreateCaret(WindowHandle, NULL, QueryCharWidth(), QueryCharHeight());
    ShowCaret(WindowHandle);
    SetCaretToNibble();
}


VOID
SECTOR_EDIT::KillFocus(
    IN  HWND    WindowHandle
    )
{
    if (!_size || !_buffer) {
        return;
    }

    HideCaret(WindowHandle);
    DestroyCaret();
}


VOID
SECTOR_EDIT::SetCaretToNibble(
    )
{
    ULONG   byte_num;
    BOOLEAN high_byte;
    ULONG   x, y;

    if (!_buffer || !_size) {
        return;
    }

    byte_num = _edit_nibble/2;
    high_byte = (_edit_nibble%2 == 0);

    x = (byte_num%16)*3*QueryCharWidth() + 6*QueryCharWidth() +
        (high_byte ? 0 : QueryCharWidth());

    if (byte_num % 16 > 7)
        x += QueryCharWidth();

    y = (byte_num/16 - QueryScrollPosition())*QueryCharHeight();

    SetCaretPos(x, y);
}


VOID
SECTOR_EDIT::InvalidateNibbleRect(
    IN  HWND    WindowHandle
    )
{
    RECT    rect;
    ULONG   byte_num;

    byte_num = _edit_nibble/2;

    rect.left = 0;
    rect.top = (byte_num/16 - QueryScrollPosition())*QueryCharHeight();
    rect.right = 84*QueryCharWidth();
    rect.bottom = rect.top + QueryCharHeight();

    InvalidateRect(WindowHandle, &rect, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\restarea.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "untfs.hxx"
#include "restarea.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
RESTART_AREA_EDIT::Initialize(
    IN      HWND    WindowHandle,
    IN      INT     ClientHeight,
    IN      INT     ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  tm;
    HDC         hdc;

    hdc = GetDC(WindowHandle);
    if (hdc == NULL)
        return FALSE;
    GetTextMetrics(hdc, &tm);
    ReleaseDC(WindowHandle, hdc);

    if (!VERTICAL_TEXT_SCROLL::Initialize(
        WindowHandle,
        0,
        ClientHeight,
        ClientWidth,
        tm.tmExternalLeading + tm.tmHeight,
        tm.tmMaxCharWidth
        )) {
        return FALSE;
    }

    return TRUE;
}


VOID
RESTART_AREA_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetRange(WindowHandle, _size/2);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
RESTART_AREA_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    PLFS_RESTART_PAGE_HEADER pRestPageHeader;
    PLFS_RESTART_AREA       pRestArea;
    PLFS_CLIENT_RECORD      pClientRecord;
    TEXTMETRIC              tm;
    INT                     ch, CurrentLine;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, _size/2, FALSE);
    SetScrollPos(WindowHandle, SB_VERT, QueryScrollPosition(), TRUE);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));

    if (!_buffer || _size < 512) {
        return;
    }

    GetTextMetrics(DeviceContext, &tm);
    ch = tm.tmExternalLeading + tm.tmHeight;
    CurrentLine = 0;

    pRestPageHeader = (PLFS_RESTART_PAGE_HEADER)_buffer;

    swprintf(buf, TEXT("MultiSectorHeader.Signature: \t\t\t%c%c%c%c"),
        pRestPageHeader->MultiSectorHeader.Signature[0],
        pRestPageHeader->MultiSectorHeader.Signature[1],
        pRestPageHeader->MultiSectorHeader.Signature[2],
        pRestPageHeader->MultiSectorHeader.Signature[3]);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArrayOffset: \t%u"),
        pRestPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MultiSectorHeader.UpdateSequenceArraySize: \t%x"),
        pRestPageHeader->MultiSectorHeader.UpdateSequenceArraySize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ChkDskLsn: \t%x:%x"),
        pRestPageHeader->ChkDskLsn.HighPart,
        pRestPageHeader->ChkDskLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("SystemPageSize: %x"), pRestPageHeader->SystemPageSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogPageSize: \t%x"), pRestPageHeader->LogPageSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RestartOffset: \t%x"), pRestPageHeader->RestartOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("MinorVersion: \t%d"), pRestPageHeader->MinorVersion);
    WriteLine(DeviceContext, CurrentLine++, buf);
    swprintf(buf, TEXT("MajorVersion: \t%d"), pRestPageHeader->MajorVersion);
    WriteLine(DeviceContext, CurrentLine++, buf);

    CurrentLine++;

    pRestArea = PLFS_RESTART_AREA(PUCHAR(_buffer) + pRestPageHeader->RestartOffset);

    swprintf(buf, TEXT("CurrentLsn: \t\t%x:%x"), pRestArea->CurrentLsn.HighPart,
        pRestArea->CurrentLsn.LowPart);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogClients: \t\t%x"), pRestArea->LogClients);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientFreeList: \t%x"), pRestArea->ClientFreeList);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientInUseList: \t%x"), pRestArea->ClientInUseList);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("Flags: \t\t\t%x"), pRestArea->Flags);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("SeqNumberBits: \t\t%x"), pRestArea->SeqNumberBits);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RestartAreaLength: \t%x"), pRestArea->RestartAreaLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("ClientArrayOffset: \t%x"), pRestArea->ClientArrayOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("FileSize: \t\t%x"), pRestArea->FileSize);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LastLsnDataLength: \t%x"), pRestArea->LastLsnDataLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("RecordHeaderLength: \t%x"), pRestArea->RecordHeaderLength);
    WriteLine(DeviceContext, CurrentLine++, buf);

    swprintf(buf, TEXT("LogPageDataOffset: \t%x"), pRestArea->LogPageDataOffset);
    WriteLine(DeviceContext, CurrentLine++, buf);

    for (INT i = 0; i < pRestArea->LogClients; ++i) {

        CurrentLine++;

        swprintf(buf, TEXT("CLIENT \t%d"), i);
        WriteLine(DeviceContext, CurrentLine++, buf);

        pClientRecord = &pRestArea->LogClientArray[i];

        swprintf(buf, TEXT("    OldestLsn: \t\t%x:%x"),
            pClientRecord->OldestLsn.HighPart,
            pClientRecord->OldestLsn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    ClientRestartLsn: \t%x:%x"),
            pClientRecord->ClientRestartLsn.HighPart,
            pClientRecord->ClientRestartLsn.LowPart);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    PrevClient: \t%x"), pClientRecord->PrevClient);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    NextClient: \t%x"), pClientRecord->NextClient);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    SeqNumber: \t\t%x"), pClientRecord->SeqNumber);
        WriteLine(DeviceContext, CurrentLine++, buf);

        swprintf(buf, TEXT("    ClientName: \t"));
        INT x = wcslen(buf);

        for (ULONG j = 0; j < pClientRecord->ClientNameLength; ++j) {
            buf[j + x] = (TCHAR)pClientRecord->ClientName[j];
        }
        WriteLine(DeviceContext, CurrentLine++, buf);
    }
}

VOID
RESTART_AREA_EDIT::KeyUp(
    IN HWND WindowHandle
    )
{
    ScrollUp(WindowHandle);
}

VOID
RESTART_AREA_EDIT::KeyDown(
    IN HWND WindowHandle
    )
{
    ScrollDown(WindowHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\doskey\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=doskey
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\doskey.cxx ..\doskey.rc

INCLUDES=..\..\ulib\inc;\
    $(WINDOWS_INC_PATH)

C_DEFINES=/DUNICODE=1

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\kernl32p.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\diskedit\vscroll.cxx ===
#include "ulib.hxx"
#include "vscroll.hxx"

BOOLEAN
VERTICAL_TEXT_SCROLL::Initialize(
    IN  HWND    WindowHandle,
    IN  INT     NumLines,
    IN  INT     ClientHeight,
    IN  INT     ClientWidth,
    IN  INT     CharHeight,
    IN  INT     CharWidth
    )
{
    _client_height = ClientHeight;
    _client_width = ClientWidth;
    _char_height = CharHeight;
    _char_width = CharWidth;
    _scroll_position = 0;
    return TRUE;
}


VOID
VERTICAL_TEXT_SCROLL::SetRange(
    IN  HWND    WindowHandle,
    IN  INT     NumLines
    )
{
    _num_lines = NumLines - _client_height/_char_height;
    SetScrollRange(WindowHandle, SB_VERT, 0, _num_lines, FALSE);
}


VOID
VERTICAL_TEXT_SCROLL::ClientSize(
    IN  INT Height,
    IN  INT Width
    )
{
    _client_height = Height;
    _client_width = Width;
}


VOID
VERTICAL_TEXT_SCROLL::ScrollUp(
    IN  HWND    WindowHandle
    )
{
    _scroll_position--;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::ScrollDown(
    IN  HWND    WindowHandle
    )
{
    _scroll_position++;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::PageUp(
    IN  HWND    WindowHandle
    )
{
    _scroll_position -= _client_height/_char_height;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::PageDown(
    IN  HWND    WindowHandle
    )
{
    _scroll_position += _client_height/_char_height;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::ThumbPosition(
    IN  HWND    WindowHandle,
    IN  INT     NewThumbPosition
    )
{
    _scroll_position = NewThumbPosition;
    UpdateScrollPosition(WindowHandle);
}


VOID
VERTICAL_TEXT_SCROLL::UpdateScrollPosition(
    IN  HWND    WindowHandle
    )
{
    INT current_pos;

    current_pos = GetScrollPos(WindowHandle, SB_VERT);
    _scroll_position = max(0, min(_scroll_position, _num_lines));

    if (_scroll_position != current_pos) {
        SetScrollPos(WindowHandle, SB_VERT, _scroll_position, TRUE);
        ScrollWindow(WindowHandle, 0,
                     QueryCharHeight()*(current_pos - _scroll_position),
                     NULL, NULL);
        UpdateWindow(WindowHandle);
    }
}

STATIC TCHAR buf[1024];

VOID
VERTICAL_TEXT_SCROLL::WriteLine(
    IN      HDC     DeviceContext,
    IN      INT     LineNumber,
    IN      PTCHAR   String
    )
{
    if( LineNumber >= QueryScrollPosition() &&
        LineNumber <= QueryScrollPosition() + QueryClientHeight()/QueryCharHeight() + 1) {

        CONST INT tabstop = 8;
        INT pos, bufpos;
    
        //
        // Copy string into buf, expanding tabs into spaces as we go.  This
        // is because the window to which we are displaying does not do tabs.
        //
    
        for (pos = 0, bufpos = 0; String[pos] != '\0'; ++pos) {
            if ('\t' == String[pos]) {
                do {
                    buf[bufpos++] = ' ';
                } while (0 != bufpos % tabstop);
    
                continue;
            }
    
            buf[bufpos++] = String[pos];
        }
        buf[bufpos++] = '\0';
    
        TextOut( DeviceContext,
                 0,
                 (LineNumber - QueryScrollPosition())*QueryCharHeight(),
                 buf,
                 wcslen( buf ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\driverquery\connectwmi.cpp ===
//**********************************************************************************
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//      CONNECTWMI.cpp
//
//  Abstract:
//      Contains functions to connect to wmi.
//
//  Author:
//      J.S.Vasu
//
//  Revision History:
//      J.S.Vasu  26-sep-2k : Created It.
// *********************************************************************************

// Include files
#include "pch.h"
#include "resource.h"
#include "driverquery.h"

// error constants
#define E_SERVER_NOTFOUND           0x800706ba

// function prototypes
BOOL IsValidServerEx( LPCWSTR pwszServer,
                      BOOL    &bLocalSystem );

HRESULT GetSecurityArguments( IUnknown *pInterface,
                              DWORD&   dwAuthorization,
                              DWORD&   dwAuthentication );

HRESULT SetInterfaceSecurity( IUnknown       *pInterface,
                              LPCWSTR        pwszServer,
                              LPCWSTR        pwszUser,
                              LPCWSTR        pwszPassword,
                              COAUTHIDENTITY **ppAuthIdentity );

HRESULT WINAPI SetProxyBlanket( IUnknown  *pInterface,
                                DWORD     dwAuthnSvc,
                                DWORD     dwAuthzSvc,
                                LPWSTR    pwszPrincipal,
                                DWORD     dwAuthLevel,
                                DWORD     dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
                                DWORD     dwCapabilities );

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser,
                                      LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain,
                                      COAUTHIDENTITY **ppAuthIdent );

BOOL ConnectWmi( IWbemLocator   *pLocator,
                 IWbemServices  ** ppServices,
                 LPCWSTR        pwszServer,
                 LPCWSTR        pwszUser,
                 LPCWSTR        pwszPassword,
                 COAUTHIDENTITY **ppAuthIdentity,
                 BOOL           bCheckWithNullPwd = FALSE,
                 LPCWSTR        pwszNamespace = CIMV2_NAME_SPACE,
                 HRESULT        *phr = NULL,
                 BOOL           *pbLocalSystem = NULL );

VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY  **ppAuthIdentity );

// ***************************************************************************
// Routine Description:
//      Checks whether the server name is a valid server name or not.
//
// Arguments:
//      pwszServer [in]       - Server name to be validated.
//      bLocalSystem [in/out] - Set to TRUE if server specified is local system.
//
// Return Value:
//      TRUE if server is valid else FALSE.
//
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL &bLocalSystem )
{
    // local variables
    CHString strTemp;

    if( pwszServer == NULL )
    {
        return FALSE;
    }

    bLocalSystem = FALSE;

    // get a local copy
    strTemp = pwszServer;

    // remove the forward slashes (UNC) if exist in the begining of the server name
    if ( IsUNCFormat( strTemp ) == TRUE )
    {
        strTemp = strTemp.Mid( 2 );
        if ( strTemp.GetLength() == 0 )
            return FALSE;
    }

    // now check if any '\' character appears in the server name. If so error
    if ( strTemp.Find( L'\\' ) != -1 )
        return FALSE;

    // now check if server name is '.' only which represent local system in WMI
    // else determine whether this is a local system or not
    bLocalSystem = TRUE;
    if ( strTemp.CompareNoCase( L"." ) != 0 )
    {
        // validate the server
        if ( IsValidServer( strTemp ) == FALSE )
            return FALSE;

        // check whether this is a local system or not
        bLocalSystem = IsLocalSystem( strTemp );
    }

    // valid server name
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//      Connects to wmi.
//
// Arguments:
//      pLocator [in]           - Pointer to the IWbemLocator object.
//      ppServices [out]        - Pointer to IWbemServices object.
//      pwszServer [in]         - Holds the server name to connect to.
//      pwszUser [in/out]       - Holds the user name.
//      pwszPassword [in/out]   - Holds the password.
//      ppAuthIdentity [in/out] - Pointer to authentication structure.
//      bCheckWithNullPwd [in]  - Specifies whether to connect through null password.
//      pwszNamespace [in]      - Specifies the namespace to connect to.
//      phRes [in/out]          - Holds the error value.
//      pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//                                name is local or not.
// Return Value:
//      TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator *pLocator, IWbemServices **ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY **ppAuthIdentity,
                 BOOL bCheckWithNullPwd, LPCWSTR pwszNamespace, HRESULT *phRes,
                 BOOL *pbLocalSystem )
{
    // local variables
    HRESULT hRes = 0;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser;
    _bstr_t bstrPassword;

    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = FALSE;
    }

    if ( phRes != NULL )
    {
        *phRes = NO_ERROR;
    }

    try
    {
        // clear the error
        SetLastError( WBEM_S_NO_ERROR );

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // check whether locator object exists or not if not return FALSE
        if ( pLocator == NULL )
        {
            if ( phRes != NULL )
            {
                *phRes = WBEM_E_INVALID_PARAMETER;
            }

            // return failure
            return FALSE;
        }

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( ERROR_BAD_NETPATH );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( pwszServer != NULL && bLocalSystem == FALSE )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( pwszUser != NULL && StringLengthW( pwszUser, 0 ) != 0 )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }

        // release the existing services object ( to be in safer side )
        SAFE_RELEASE( *ppServices );

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hRes = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
        if ( FAILED( hRes ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'

            if ( hRes == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hRes = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
                }
            }
            else if ( hRes == WBEM_E_LOCAL_CREDENTIALS )
            {
                // credentials were passed to the local system.
                // So ignore the credentials and try to reconnect
                bLocalSystem = TRUE;
                bstrUser = (LPWSTR) NULL;
                bstrPassword = (LPWSTR) NULL;
                bstrNamespace = pwszNamespace;              // name space
                hRes = pLocator->ConnectServer( bstrNamespace,
                    NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
                // now check the result again .. if failed
            }
            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hRes ) )
            {
                _com_issue_error( hRes );
            }

            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

        // connection to WMI is successful
        bResult = TRUE;

        // save the hr value if needed by the caller
        if ( phRes != NULL )
        {
            *phRes = WBEM_S_NO_ERROR;
        }
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( phRes != NULL )
        {
            *phRes = e.Error();
        }
    }

    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = bLocalSystem;
    }

    // return the result
    return bResult;
}

// ***************************************************************************
// Routine Description:
//      Connects to wmi.
//
// Arguments:
//      pLocator [in]           - Pointer to the IWbemLocator object.
//      ppServices [out]        - Pointer to IWbemServices object.
//      strServer [in]          - Holds the server name to connect to.
//      strUserName [in/out]    - Holds the user name.
//      strPassword [in/out]    - Holds the password.
//      ppAuthIdentity [in/out] - Pointer to authentication structure.
//      bNeedPassword [in]      - Specifies whether to prompt for password.
//      pwszNamespace [in]      - Specifies the namespace to connect to.
//      pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//                                name is local or not.
// Return Value:
//      TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator  *pLocator,
                   IWbemServices **ppServices,
                   const CHString &strServer, CHString &strUserName, CHString &strPassword,
                   COAUTHIDENTITY **ppAuthIdentity, BOOL bNeedPassword, LPCWSTR pwszNamespace,
                   BOOL* pbLocalSystem )
{
    // local variables
    HRESULT hRes = 0;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer = NULL_STRING;
    __MAX_SIZE_STRING szBuffer = NULL_STRING;



    // clear the error .. if any
    SetLastError( WBEM_S_NO_ERROR );

    // sometime users want the utility to prompt for the password
    // check what user wants the utility to do
    if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
    {
        // user wants the utility to prompt for the password
        // so skip this part and let the flow directly jump the password acceptance part
    }
    else
    {
        // try to establish connection to the remote system with the credentials supplied
        if ( strUserName.GetLength() == 0 )
        {
            // user name is empty
            // so, it is obvious that password will also be empty
            // even if password is specified, we have to ignore that
            bResult = ConnectWmi( pLocator, ppServices,
                (LPCWSTR)strServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );
        }
        else
        {
            // credentials were supplied
            // but password might not be specified ... so check and act accordingly
            LPCWSTR pwszTemp = NULL;
            if ( bNeedPassword == FALSE )
                pwszTemp = strPassword;

            // ...
            bResult = ConnectWmi( pLocator, ppServices, (LPCWSTR)strServer,
                (LPCWSTR)strUserName, pwszTemp, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );
        }

        // check the result ... if successful in establishing connection ... return
        if ( bResult == TRUE )
            return TRUE;

        // now check the kind of error occurred
        switch( hRes )
        {
            case 0x80040154:
                //the wmi is not registered on remote machine
                ShowMessage( stderr, ERROR_TAG );
                ShowMessage( stderr, GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE));
                return FALSE;
            case E_ACCESSDENIED:
                break;

            case WBEM_E_LOCAL_CREDENTIALS:
                 // needs to do special processing
                 break;

            case WBEM_E_ACCESS_DENIED:


            default:
                 GetWbemErrorText( hRes );
                 ShowMessage( stderr, ERROR_TAG );
                 ShowMessage( stderr, GetReason() );
                 return( FALSE );       // no use of accepting the password .. return failure


        }

        // if failed in establishing connection to the remote terminal
        // even if the password is specifed, then there is nothing to do ... simply return failure
        if ( bNeedPassword == FALSE )
        {
            GetWbemErrorText( hRes );
            ShowMessage( stderr, ERROR_TAG );
            ShowMessage( stderr, GetReason() );
            return FALSE;
        }
    }

    // check whether user name is specified or not
    // if not, get the local system's current user name under whose credentials, the process
    // is running
    if ( strUserName.GetLength() == 0 )
    {
        // sub-local variables
        LPWSTR pwszUserName = NULL;

        try
        {
            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
        }
        catch( ... )
        {
            SetLastError( E_OUTOFMEMORY );
            SaveLastError();
            ShowMessage( stderr, ERROR_TAG );
            ShowLastError( stderr );
            return FALSE;
        }

        // get the user name

            _TCHAR  szUserName[MAX_RES_STRING];
        ULONG ulLong = MAX_RES_STRING;
        if ( GetUserNameEx ( NameSamCompatible, szUserName , &ulLong)== FALSE )
        {
            // error occured while trying to get the current user info
            SaveLastError();
            ShowMessage( stderr, ERROR_TAG );
            ShowLastError( stderr );
            return FALSE;
        }

        StringCopy(pwszUserName,szUserName, MAX_STRING_LENGTH );
        // format the user name
        if ( _tcschr( pwszUserName, _T( '\\' ) ) == NULL )
        {
            // server not present in user name ... prepare ... this is only for display purpose
            StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer),  _T( "%s\\%s" ), (LPCWSTR)strServer, szUserName );
            StringCopy( pwszUserName, szBuffer, MAX_STRING_LENGTH );
        }

        // release the extra buffer allocated
        strUserName.ReleaseBuffer();
    }

    try
    {
        // get the required buffer
        pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, ERROR_TAG );
        ShowLastError( stderr );
        return FALSE;
    }

    // accept the password from the user
    strBuffer.Format( INPUT_PASSWORD, strUserName );
    WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ),
                   strBuffer, strBuffer.GetLength(), &dwSize, NULL );
    GetPassword( pwszPassword, MAX_STRING_LENGTH );

    // release the buffer allocated for password
    strPassword.ReleaseBuffer();

    // now again try to establish the connection using the currently
    // supplied credentials
    bResult = ConnectWmi( pLocator, ppServices, (LPCWSTR)strServer,
        (LPCWSTR)strUserName, (LPCWSTR)strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );

    if( bResult == FALSE )
    {
        if( 0x80040154 == hRes )
        {
            //the wmi is not registered on remote machine
            ShowMessage( stderr, ERROR_TAG );
            ShowMessage( stderr, GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE));
        }
        else
        {
         GetWbemErrorText( hRes );
         ShowMessage( stderr, ERROR_TAG );
         ShowMessage( stderr, GetReason() );
        }
         return( FALSE );       // no use of accepting the password .. return failure
    }
    // return the success
    return bResult;
}

// ***************************************************************************
// Routine Description:
//      Gets the security arguments for an interface.
//
// Arguments:
//      pInterface [in]           - Pointer to interface stucture.
//      dwAuthorization [in/out]  - Holds Authorization value.
//      dwAuthentication [in/out] - Holds the Authentication value.
//
// Return Value:
//      Returns HRESULT value.
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown *pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication )
{
    // local variables
    HRESULT hRes = 0;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity *pClientSecurity = NULL;

    if(pInterface == NULL)
    {
        return  WBEM_E_INVALID_PARAMETER; ;
    }
    // try to get the client security services values if possible
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hRes ) )
    {
        // got the client security interface
        // now try to get the security services values
        hRes = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hRes ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFEIRELEASE( pClientSecurity );
    }

    // return always success
    return S_OK;
}


// ***************************************************************************
// Routine Description:
//      Sets the interface security for the interface.
//
// Arguments:
//      pInterface [in]  - pointer to the interface.
//      pAuthIdentity [in] - pointer to authentication structure.
//
// Return Value:
//      returns HRESULT value.
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown *pInterface, COAUTHIDENTITY *pAuthIdentity )
{
    // local variables
    HRESULT hRes;
    LPWSTR pwszDomain = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    // GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // set the security information to the interface
    hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hRes;
}

// ***************************************************************************
// Routine Description:
//      Sets proxy blanket for the interface.
//
// Arguments:
//      pInterface [in]     - pointer to the inteface.
//      dwAuthnsvc [in]     - Authentication service to use.
//      dwAuthzSvc [in]     - Authorization service to use.
//      pwszPricipal [in]   - Server principal name to use with the authentication service.
//      dwAuthLevel [in]    - Authentication level to use.
//      dwImpLevel [in]     - Impersonation level to use.
//      pAuthInfo   [in]    - Identity of the client.
//      dwCapabilities [in] - Capability flags.
//
// Return Value:
//      Return HRESULT value.
//
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown *pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
    // local variables
    HRESULT hRes;
    IUnknown *pUnknown = NULL;
    IClientSecurity *pClientSecurity = NULL;

    if( pInterface == NULL )
    {
        return  WBEM_E_INVALID_PARAMETER;
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hRes = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hRes != S_OK )
    {
        return hRes;
    }

    // now get the client security interface
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hRes != S_OK )
    {
        SAFEIRELEASE( pUnknown );
        return hRes;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

    // now set the security
    hRes = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

    // release the security interface
    SAFEIRELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hRes = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hRes == S_OK )
        {
            // set security authentication
            hRes = pClientSecurity->SetBlanket(
                pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFEIRELEASE( pClientSecurity );
        }
        else if ( hRes == E_NOINTERFACE )
            hRes = S_OK;        // ignore no interface errors
    }

    // release the IUnknown
    SAFEIRELEASE( pUnknown );

    // return the result
    return hRes;
}

// ***************************************************************************
// Routine Description:
//      Allocate memory for authentication variables.
//
// Arguments:
//      pwszUser [in/out]     - User name.
//      pwszPassword [in/out] - Password.
//      pwszDomain [in/out]   - Domain name.
//      ppAuthIdent [in/out]  - Poointer to authentication structure.
//
// Return Value:
//      Returns HRESULT value.
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY **ppAuthIdent )
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( pwszUser != NULL )
    {
        // allocate memory for user
        LONG lLength = StringLengthW( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->User == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, lLength+1 );
    }

    // domain
    if ( pwszDomain != NULL )
    {
        // allocate memory for domain
        LONG lLength = StringLengthW( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, lLength+1 );
    }

    // passsord
    if ( pwszPassword != NULL )
    {
        // allocate memory for passsord
        LONG lLength = StringLengthW( pwszPassword, 0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, lLength+1 );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//      Frees the memory of authentication stucture variable.
//
// Arguments:
//      ppAuthIdentity [in] - Pointer to authentication structure.
//
// Return Value:
//      none.
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

        // free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

        // free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
    }

    // set to NULL
    *ppAuthIdentity = NULL;
}


// ***************************************************************************
// Routine Description: checks if a user name is valid.
//
// Arguments: UserName
//
// Return Value: BOOL
//
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
    // local variables
    CHString strUser;

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
            return FALSE;

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
            return FALSE;
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}




// ***************************************************************************
// Routine Description:
//      Sets interface security.
//
// Arguments:
//      pInterface [in]         - Pointer to the interface to which security has to be set.
//      pwszServer [in]         - Holds the server name of the interface.
//      pwszUser [in]           - Holds the user name of the server.
//      pwszPassword [in]       - Hold the password of the user.
//      ppAuthIdentity [in/out] - Pointer to authentication structure.
//
// Return Value:
//      returns HRESULT value.
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszServer, LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
    // local variables
    HRESULT hr=0;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // check the authentity strcuture ... if authentity structure is already ready
    // simply invoke the 2nd version of SetInterfaceSecurity
    if ( *ppAuthIdentity != NULL )
    {
        return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
    }

    // get the current security argument value
    // GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure
    // for which the current logged in user's credentials will be considered
    if ( pwszUser == NULL && pwszPassword == NULL )
    {
        // set the security
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
            NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

        // return the result
        return hr;
    }

    // parse and find out if the user name contains the domain name
    // if contains, extract the domain value from it
    LONG lPos = -1;
    strDomain = L"";
    strUser = pwszUser;
    if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
    {
        // user name contains domain name ... domain\user format
        strDomain = strUser.Left( lPos );
        strUser = strUser.Mid( lPos + 1 );
    }

    // get the domain info if it exists only
    if ( strDomain.GetLength() != 0 )
    {
        pwszDomainArg = strDomain;
    }

    // get the user info if it exists only
    if ( strUser.GetLength() != 0 )
    {
        pwszUserArg = strUser;
    }

    // check if authentication info is available or not ...
    // initialize the security authenication information ... UNICODE VERSION STRUCTURE
    if ( ppAuthIdentity == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( *ppAuthIdentity == NULL )
    {
        hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
        if ( hr != S_OK )
        {
            return hr;
        }
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}

VOID
WMISaveError(
    HRESULT hrError
    )
/*++

Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemStatusCodeText* pWbemStatus = NULL;
    _bstr_t bstrErrorString;

    try
    {
        // Set error to different value.
        if ( E_ACCESSDENIED == hrError )
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            hrError = ERROR_LOGON_FAILURE;
        }

        //Set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            bstrErrorString = _bstr_t( GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE) );
            SetReason( bstrErrorString );
            return;
        }
        else
        {   // Get error string.
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IWbemStatusCodeText,
                                   (LPVOID*) &pWbemStatus );
            if( SUCCEEDED( hr ) )
            {
                BSTR bstrString = NULL;
                // Get error string from error code.
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0,
                                                    &bstrString );
                if( NULL != bstrString )
                {
                    bstrErrorString = _bstr_t( bstrString );
                    SysFreeString( bstrString );
                }
                if( FAILED( hr ) )
                {
                    _com_issue_error( hrError );
                }
				SAFE_RELEASE(pWbemStatus);
            }
            else
            {
                _com_issue_error( hrError );
            }
        }
    }
    catch( _com_error& e )
    {   // We have got the error. Needs to handle carefully.
        LPWSTR lpwszGetString = NULL;
		SAFE_RELEASE(pWbemStatus);
        try
        {   // ErrorMessage() can throw an exception.
            DWORD dwLength = StringLength( e.ErrorMessage(), 0 ) + 5 ;
            lpwszGetString = ( LPWSTR )AllocateMemory( dwLength * sizeof( WCHAR ) );
            if( NULL != lpwszGetString )
            {
                StringCopy( lpwszGetString, e.ErrorMessage(), dwLength );
                StringConcat( lpwszGetString, L"\n", dwLength );
                SetReason( ( LPCWSTR )lpwszGetString );
                FreeMemory( (LPVOID*) &lpwszGetString );
            }
            else
            {   // Failed to know the exact error occured
                // due to insufficient memory.
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
            }
        }
        catch( ... )
        {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
        }
        return;
    }

    SetReason( (LPCWSTR) bstrErrorString );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\driverquery\driverquery.h ===
// *********************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//    DriverQuery.h
//
//  Abstract:
//
//    This module contains all necessary header files required by DriverQuery.cpp module.
//
//
//  Author:
//
//    J.S.Vasu   31-Oct-2000
//
//  Revision History:
//    Created  on 31-0ct-2000 by J.S.Vasu
//
// *********************************************************************************


#ifndef _DRIVERQUERY
#define _DRIVERQUERY

#include <wbemidl.h>
#include <comdef.h>
#include <CHSTRING.h>
#include <time.h>
#include <tchar.h>
#include <lm.h>
#include <Oleauto.h>
#include <strsafe.h>

#define ID_HELP_START 1

#define ID_USAGE_START      IDS_USAGE_COPYRIGHT1
#define ID_USAGE_END        IDS_USAGE_EXAMPLE32

#define ID_USAGE_BEGIN      IDS_USAGEBEGIN1
#define ID_USAGE_ENDING     IDS_USAGEEND1

#define OI_HELP             0
#define OI_SERVER           1
#define OI_USERNAME         2
#define OI_PASSWORD         3
#define OI_FORMAT           4
#define OI_HEADER           5
#define OI_VERBOSE          6
#define OI_SIGNED           7

#define MAX_OPTIONS         8

// supported options ( do not localize )
#define OPTION_HELP         _T( "?" )
#define OPTION_SERVER       _T( "s" )
#define OPTION_USERNAME     _T( "u" )
#define OPTION_PASSWORD     _T( "p" )
#define OPTION_FORMAT       _T( "fo")
#define OPTION_HEADER       _T( "nh")
#define OPTION_VERBOSE      _T( "v" )
#define OPTION_SIGNED       _T( "si")

//localized error messages.
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_COM_INTIALIZE             GetResString(IDS_ERROR_COM_INTIALIZE)
#define ERROR_SECURITY_INTIALIZE        GetResString(IDS_ERROR_COM_SECURITY_INITIALIZE)
#define ERROR_ENUMERATE_INSTANCE        GetResString(IDS_ERROR_COM_ENUMERATE_INSTANCE)
#define ERROR_CONNECT                   GetResString(IDS_ERROR_CONNECT)
#define ERROR_SYNTAX                    GetResString(IDS_INVALID_SYNTAX)
#define ERROR_RETREIVE_INFO             GetResString(IDS_ERROR_RETREIVE_INFO)
#define ERROR_INVALID_CREDENTIALS       GetResString(IDS_INVALID_CREDENTIALS)
#define ERROR_INVALID_FORMAT            GetResString(IDS_ERROR_INVALID_FORMAT)
#define ERROR_TAG                       GetResString(IDS_ERROR_TAG)
#define ERROR_GET_VALUE                 GetResString(IDS_ERROR_GET)
#define WARNING_TAG                     GetResString(IDS_WARNING_TAG)

#define LIST_FORMAT                     GetResString(IDS_FORMAT_LIST)
#define TABLE_FORMAT                    GetResString(IDS_FORMAT_TABLE)
#define CSV_FORMAT                      GetResString(IDS_FORMAT_CSV)
#define DRIVER_TAG                      GetResString(IDS_DRIVER_TAG)

#define ERROR_AUTHENTICATION_FAILURE    GetResString(IDS_ERROR_AUTHENTICATION_FAILURE)
#define ERROR_LOCAL_CREDENTIALS         GetResString(IDS_ERROR_LOCAL_CRED)
#define ERROR_WMI_FAILURE               GetResString(IDS_ERROR_WMI_FAILURE)

#define IGNORE_LOCALCREDENTIALS         GetResString(IDS_IGNORE_LOCAL_CRED)
#define INPUT_PASSWORD                  GetResString( IDS_INPUT_PASSWORD )

#define COL_HOSTNAME                    GetResString(IDS_COL_HOSTNAME)
#define COL_FILENAME                    GetResString(IDS_COL_FILENAME)
#define COL_SIGNED                      GetResString(IDS_SIGNED)
#define COL_DISPLAYNAME                 GetResString(IDS_COL_DISPLAYNAME)
#define COL_DESCRIPTION                 GetResString(IDS_COL_DESCRIPTION)
#define COL_DRIVERTYPE                  GetResString(IDS_COL_DRIVERTYPE)
#define COL_STARTMODE                   GetResString(IDS_COL_STARTMODE)
#define COL_STATE                       GetResString(IDS_COL_STATE)
#define COL_STATUS                      GetResString(IDS_COL_STATUS)
#define COL_ACCEPTSTOP                  GetResString(IDS_COL_ACCEPTSTOP)
#define COL_ACCEPTPAUSE                 GetResString(IDS_COL_ACCEPTPAUSE)
#define COL_MEMORYUSAGE                 GetResString(IDS_COL_MEMORYUSAGE)
#define COL_PAGEDPOOL                   GetResString(IDS_COL_PAGEDPOOL)
#define COL_NONPAGEDPOOL                GetResString(IDS_COL_NONPAGEDPOOL)
#define COL_EXECCODE                    GetResString(IDS_COL_EXECCODE)
#define COL_NBSS                        GetResString(IDS_COL_NBSS)
#define COL_BSS                         GetResString(IDS_COL_BSS)
#define COL_LINKDATE                    GetResString(IDS_COL_LINKDATE)
#define COL_LOCATION                    GetResString(IDS_COL_LOCATION)
#define COL_LINKDATE                    GetResString(IDS_COL_LINKDATE)
#define COL_LOCATION                    GetResString(IDS_COL_LOCATION)
#define COL_INITSIZE                    GetResString(IDS_COL_INITSIZE)
#define COL_PAGESIZE                    GetResString(IDS_COL_PAGESIZE)
#define ERROR_ALLOC_FAILURE             GetResString(IDS_ALLOC_FAILURE)
#define ERROR_NO_HEADERS                GetResString(IDS_NO_HEADERS)
#define ERROR_INVALID_SERVER                GetResString(IDS_INVALID_SERVER)
#define ERROR_INVALID_USER              GetResString(IDS_INVALID_USER)
#define INVALID_SIGNED_SYNTAX           GetResString(IDS_INVALID_SIGNED_SYNTAX)

#define COL_HOSTNAME_WIDTH              AsLong(GetResString(IDS_COL_HOSTNAME_SIZE),10)
#define COL_FILENAME_WIDTH              AsLong(GetResString(IDS_COL_FILENAME_SIZE),10)
#define COL_SIGNED_WIDTH                AsLong(GetResString(IDS_SIGNED_SIZE),10)
#define COL_DISPLAYNAME_WIDTH           AsLong(GetResString(IDS_COL_DISPLAYNAME_SIZE),10)
#define COL_DESCRIPTION_WIDTH           AsLong(GetResString(IDS_COL_DESCRIPTION_SIZE),10)
#define COL_DRIVERTYPE_WIDTH            AsLong(GetResString(IDS_COL_DRIVERTYPE_SIZE),10)
#define COL_STARTMODE_WIDTH             AsLong(GetResString(IDS_COL_STARTMODE_SIZE),10)
#define COL_STATE_WIDTH                 AsLong(GetResString(IDS_COL_STATE_SIZE),10)
#define COL_STATUS_WIDTH                AsLong(GetResString(IDS_COL_STATUS_SIZE),10)
#define COL_ACCEPTSTOP_WIDTH            AsLong(GetResString(IDS_COL_ACCEPTSTOP_SIZE),10)
#define COL_ACCEPTPAUSE_WIDTH           AsLong(GetResString(IDS_COL_ACCEPTPAUSE_SIZE),10)
#define COL_MEMORYUSAGE_WIDTH           AsLong(GetResString(IDS_COL_MEMORYUSAGE_SIZE),10)
#define COL_PAGEDPOOL_WIDTH             AsLong(GetResString(IDS_COL_PAGEDPOOL_SIZE),10)
#define COL_NONPAGEDPOOL_WIDTH          AsLong(GetResString(IDS_COL_NONPAGEDPOOL_SIZE),10)
#define COL_EXECCODE_WIDTH              AsLong(GetResString(IDS_COL_EXECCODE_SIZE),10)
#define COL_NBSS_WIDTH                  AsLong(GetResString(IDS_COL_NBSS_SIZE),10)
#define COL_BSS_WIDTH                   AsLong(GetResString(IDS_COL_BSS_SIZE),10)
#define COL_LINKDATE_WIDTH              AsLong(GetResString(IDS_COL_LINKDATE_SIZE),10)
#define COL_LOCATION_WIDTH              AsLong(GetResString(IDS_COL_LOCATION_SIZE),10)

#define COL_INITSIZE_WIDTH              AsLong(GetResString(IDS_COL_INITSIZE_SIZE),10)
#define COL_PAGESIZE_WIDTH              AsLong(GetResString(IDS_COL_PAGESIZE_SIZE),10)

#define COL_DEVICE_WIDTH                AsLong(GetResString(IDS_COL_DEVICE_WIDTH),10)
#define COL_INF_WIDTH                   AsLong(GetResString(IDS_COL_INF_WIDTH),10)
#define COL_ISSIGNED_WIDTH              AsLong(GetResString(IDS_COL_ISSIGNED_WIDTH),10)
#define COL_MANUFACTURER_WIDTH          AsLong(GetResString(IDS_COL_MANUFACTURER_WIDTH),10)
#define FORMAT_VALUES                   L"List|Table|Csv"

#define MAX_COLUMNS  16
#define MAX_SIGNED_COLUMNS 4

#define COL0                        0
#define COL1                        1
#define COL2                        2
#define COL3                        3
#define COL4                        4
#define COL5                        5
#define COL6                        6
#define COL7                        7
#define COL8                        8
#define COL9                        9
#define COL10                       10
#define COL11                       11
#define COL12                       12
#define COL13                       13
#define COL14                       14
#define COL15                       15
#define COL16                       16
#define COL17                       17
#define COL18                       18

#define SUCCESS 0
#define FAILURE 1

#define EXTN_BSS  ".bss"
#define EXTN_PAGE "PAGE"
#define EXTN_EDATA ".edata"
#define EXTN_IDATA ".idata"
#define EXTN_RSRC  ".rsrc"
#define EXTN_INIT "INIT"

#define TOKEN_DOLLAR      _T('$')
#define COLON_SYMBOL      _T(":")
#define TOKEN_BACKSLASH   _T("\\")
#define TOKEN_BACKSLASH2  _T("\\\\")
#define TOKEN_BACKSLASH3  _T("\\\\\\")
#define CIMV2_NAMESPACE   _T("ROOT\\CIMV2")

#define DEFAULT_NAMESPACE _T("ROOT\\DEFAULT")
#define CIMV2_NAME_SPACE _T("ROOT\\CIMV2")

#define NO_DATA_AVAILABLE _T("N/A")
#define FALSE_VALUE       _T("FALSE")
#define TRUE_VALUE        _T("TRUE")
#define IDENTIFIER_VALUE  _T("Identifier")
#define X86_MACHINE       _T("x86")
#define TOKEN_EMPTYSTRING _T("")
#define LANGUAGE_WQL       _T("WQL")
#define NEWLINE          _T("\n")

#define WQL_QUERY      _T("select * from Win32_PnpSignedDriver where DeviceName != NULL")

#define TOKEN_CONSTANT    11
#define GROUP_FORMAT_32   L"3;2;0"
#define GROUP_32_VALUE    32
#define EXIT_SUCCESSFUL   3
#define EXIT_FAILURE_MALLOC   1
#define EXIT_FAILURE_FORMAT   2
#define EXIT_FAILURE_RESULTS  4
#define VERSION_MISMATCH_ERROR 8

#define PROPERTY_NAME   L"Name"
#define PROPERTY_SYSTEMNAME L"SystemName"
#define PROPERTY_STARTMODE  L"StartMode"
#define PROPERTY_DISPLAYNAME  L"DisplayName"
#define PROPERTY_DESCRIPTION  L"Description"
#define PROPERTY_STATUS L"Status"
#define PROPERTY_STATE L"State"
#define PROPERTY_ACCEPTPAUSE  L"AcceptPause"
#define PROPERTY_ACCEPTSTOP L"AcceptStop"
#define PROPERTY_SERVICETYPE L"ServiceType"
#define PROPERTY_PATHNAME L"PathName"
#define PROPERTY_SYSTEM_TYPE L"SystemType"

#define PROPERTY_GETSTRINGVAL L"GetStringValue"
#define PROPERTY_RETURNVAL L"ReturnValue"

#define STD_REG_CLASS                   L"StdRegProv"
#define REG_METHOD                      L"GetStringValue"
#define HKEY_VALUE                      L"hDefKey"
#define REG_SUB_KEY_VALUE               L"sSubKeyName"
#define REG_VALUE_NAME                  L"sValueName"
#define REG_RETURN_VALUE                L"sValue"
#define REG_PATH                        L"HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0"
#define REG_SVALUE                     L"Identifier"
#define HEF_KEY_VALUE                   2147483650
#define DRIVERQUERY_MUTEX               L"Global\\SignedDriversMutex"

#define ERROR_WMI_VALUES 1
#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3
#define ERROR_RETREIVE_REGISTRY 4
#define ERROR_WMI_CONNECT 5
#define ERROR_GET 6
#define CLASS_SYSTEMDRIVER L"Win32_SystemDriver"
#define CLASS_COMPUTERSYSTEM L"Win32_ComputerSystem"
#define CLASS_PNPSIGNEDDRIVER L"Win32_PnpSignedDriver"

#define PROPERTY_PNP_DEVICENAME L"DeviceName"
#define PROPERTY_PNP_INFNAME L"InfName"
#define PROPERTY_PNP_ISSIGNED L"IsSigned"

//#define PROPERTY_PNP_MFG L"Mfg"
#define PROPERTY_PNP_MFG L"Manufacturer"

// Registry key information
#define HKEY_MACHINE_INFO   2147483650  // registry value for HKEY_LOCAL_MACHINE
#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0")

// User Defined Macros
#define SAFEDELETE(pObj) \
    if (pObj) \
    {   \
        delete[] pObj; \
        pObj = NULL; \
    }

// SAFEIRELEASE
#define SAFEIRELEASE(pIObj) \
    if (pIObj)  \
    {   \
        pIObj->Release();   \
        pIObj = NULL;   \
    }

//SAFEBSTRFREE
#define SAFEBSTRFREE(bstrVal) \
    if (bstrVal) \
    {   \
        SysFreeString(bstrVal); \
        bstrVal = NULL; \
    }

#define ONFAILTHROWERROR(hResult) \
    if (FAILED(hResult)) \
    {   \
        _com_issue_error(hResult); \
    }

#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \

#define SAFE_EXECUTE( statement )               \
    hRes = statement;       \
    if ( FAILED( hRes ) )   \
    {   \
        _com_issue_error( hRes );   \
    }   \

#define EMPTY_LINE _T("\n")

#define SIZE_OF_ARRAY_IN_BYTES(x) \
                GetBufferSize(x)

#define SIZE_OF_ARRAY_IN_CHARS(x) \
                GetBufferSize(x)/sizeof(WCHAR)

// structure to store the data fetched using the API's
typedef struct _MODULE_DATA
{
    ULONG ulCodeSize;
    ULONG ulDataSize;
    ULONG ulBssSize;
    ULONG ulPagedSize;

    ULONG ulInitSize;
    ULONG ulImportDataSize ;
    ULONG ulExportDataSize ;
    ULONG ulResourceDataSize;

    __MAX_SIZE_STRING szTimeDateStamp ;

} MODULE_DATA, *PMODULE_DATA;

// function prototypes

DWORD 
QueryDriverInfo(LPTSTR szServer,
                LPTSTR szUserName,
                LPTSTR szPassword,
                LPTSTR szFormat,
                BOOL bHeader,
                BOOL bVerbose,
                IWbemLocator* pIWbemLocator,
                COAUTHIDENTITY* pAuthIdentity,
                IWbemServices* pIWbemServReg ,
                BOOL bSigned 
               );

DWORD 
ProcessCompSysEnum(CHString szHostName,
                   IEnumWbemClassObject *pSystemSet,
                   LPTSTR szFormat,
                   BOOL bHeader,
                   DWORD dwSystemType,
                   BOOL bVerbose
                   );

BOOL 
ProcessOptions(LONG argc,
               LPCTSTR argv[],
               PBOOL pbShowUsage,
               LPTSTR *pszServer,
               LPTSTR *pszUserName,
               LPTSTR pszPassword,
               LPTSTR pszFormat,
               PBOOL pbHeader, 
               PBOOL bNeedPassword,
               PBOOL pbVerbose,
               PBOOL pbSigned
               );

VOID ShowUsage() ;

BOOL GetApiInfo(LPTSTR szHostName,LPCTSTR szPath,PMODULE_DATA Mod,DWORD dwSystemType);

VOID PrintModuleLine(PMODULE_DATA Current);

VOID FormHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose);

SCODE ParseAuthorityUserArgs1(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User);

BOOL bIsNT();

BOOL 
FormatAccToLocale( NUMBERFMT  *pNumberFmt,
                  LPTSTR* pszGroupSep,
                  LPTSTR* pszDecimalSep,
                  LPTSTR* pszGroupThousSep
                  );

BOOL GetInfo( LCTYPE lctype, LPTSTR* pszData );

BOOL InitialiseCom(IWbemLocator** ppIWbemLocator);

DWORD GetSystemType(COAUTHIDENTITY* pAuthIdentity,IWbemServices* pIWbemServReg);

HRESULT PropertyGet(IWbemClassObject* pWmiObject,LPCTSTR pszInputVal,CHString &szOutPutVal);

SCODE ParseAuthorityUserArgs( BSTR& bstrAuthArg,
                              BSTR& bstrUserArg,
                              BSTR& bstrUser ) ;

HRESULT SetSecurity( IUnknown *pIUnknown,
                     LPCTSTR lpDomain,
                     LPCTSTR lpUser,
                     LPCTSTR lpPassword,
                     BOOL  bLocCred );

HRESULT 
FreeMemoryAll(IWbemClassObject *pInClass,
              IWbemClassObject * pClass,
              IWbemClassObject * pOutInst ,
              IWbemClassObject * pInInst,
              IWbemServices *pIWbemServReg,
              VARIANT *varConnectName,
              VARIANT *varSvalue,
              VARIANT *varHkey,
              VARIANT *varRetVal,
              VARIANT *varVaue,
              LPTSTR szSysName 
              );

BOOL IsValidUserEx( LPCWSTR pwszUser );

#define GetWbemErrorText( hr )          WMISaveError( hr )

HRESULT SetInterfaceSecurity( IUnknown *pInterface, COAUTHIDENTITY *pAuthIdentity );

BOOL ConnectWmiEx( IWbemLocator   *pLocator,
                   IWbemServices  **ppServices,
                   const CHString &strServer,
                   CHString       &strUserName,
                   CHString       &strPassword,
                   COAUTHIDENTITY **ppAuthIdentity,
                   BOOL           bNeedPassword = FALSE,
                   LPCWSTR        pszNamespace = CIMV2_NAME_SPACE,
                   BOOL          *pbLocalSystem = NULL );


DWORD 
ProcessSignedDriverInfo(CHString szHost, 
                        IEnumWbemClassObject *pSystemSet,
                        LPTSTR szFormat,
                        BOOL bHeader,
                        DWORD dwSystemType,
                        BOOL bVerbose
                        );

HRESULT 
PropertyGet_Bool(IWbemClassObject* pWmiObject, 
                 LPCTSTR pszInputVal, 
                 PBOOL pIsSigned
                 );

VOID FormSignedHeader(DWORD dwFormatType,BOOL bHeader,TCOLUMNS *ResultHeader);

VOID WMISaveError( HRESULT hResError );

LCID GetSupportedUserLocale( BOOL& bLocaleChanged ) ;

VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY  **ppAuthIdentity );

#define COL_DEVICENAME              GetResString(IDS_COL_DEVICENAME)
#define COL_INF_NAME                GetResString(IDS_COL_INF_NAME)
#define COL_ISSIGNED                GetResString(IDS_COL_ISSIGNED)
#define COL_MANUFACTURER            GetResString(IDS_COL_MANUFACTURER)

// inline functions
inline VOID WMISaveError( _com_error  &e )
{
    WMISaveError( e.Error() );
}
VOID WMISaveError( HRESULT hResError );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\driverquery\driverquery.cpp ===
// *********************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//    DriverQuery.cpp
//
//  Abstract:
//
//    This modules Queries the information of the various drivers present in the
//    system .
//
//    Syntax:
//    ------
//    DriverQuery [-s server ] [-u [domain\]username [-p password]]
//                [-fo format ] [-n|noheader  ] [-v]
//
//  Author:
//
//    J.S.Vasu (vasu.julakanti@wipro.com)
//
//  Revision History:
//
//    Created  on 31-0ct-2000 by J.S.Vasu
//    Modified on 9-Dec-2000 by Santhosh Brahmappa Added a new function IsWin64()
//
//
// *********************************************************************************
//
#include "pch.h"
#include "Resource.h"
#include "LOCALE.H"
#include "shlwapi.h"
#include "DriverQuery.h"


#ifndef _WIN64
    BOOL IsWin64(void);
    #define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif

// function prototypes
LCID GetSupportedUserLocale( BOOL& bLocaleChanged );
#define MAX_ENUM_DRIVERS 10

DWORD
 _cdecl wmain( 
              IN DWORD argc,
              IN LPCTSTR argv[]
             )
/*++
 Routine Description:
      This the entry point to this utility.

 Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

 Return Value:
      0       : If the utility successfully displayed the driver information.
      1       : If the utility completely failed to display the driver information

--*/
{
    BOOL bResult = FALSE ;
    BOOL bNeedPassword = FALSE ;
    BOOL bUsage = FALSE ;
    BOOL bHeader= FALSE ;
    LPTSTR szUserName  = NULL ;
    LPTSTR szPassword  = NULL;
    LPTSTR szServer    = NULL ;

    WCHAR szTmpPassword[MAX_RES_STRING]= NULL_STRING;
    
    __MAX_SIZE_STRING szFormat = NULL_STRING ;
    DWORD dwSystemType = 0;
    HRESULT hQueryResult = S_OK ;
    DWORD dwExitCode = 0;
    DWORD dwErrCode = 0;
    BOOL bLocalFlag = TRUE ;
    BOOL bLocalSystem = TRUE;
    BOOL bVerbose = FALSE ;
    BOOL bComInitFlag = FALSE ;
    IWbemLocator* pIWbemLocator = NULL ;
    IWbemServices* pIWbemServReg = NULL ;
    LPCTSTR szToken = NULL ;
    COAUTHIDENTITY  *pAuthIdentity = NULL;
    BOOL bFlag = FALSE ;
    BOOL bSigned = FALSE ;
    
    CHString        strUserName = NULL_STRING;
    CHString        strPassword = NULL_STRING;
    CHString        strMachineName = NULL_STRING;

    _tsetlocale( LC_ALL, _T(""));

     bResult = ProcessOptions(argc,argv,&bUsage,&szServer,&szUserName,szTmpPassword,szFormat,
                            &bHeader,&bNeedPassword,&bVerbose,&bSigned);

    if(bResult == FALSE)
    {
        ShowMessage(stderr,GetReason());
        ReleaseGlobals();
        FreeMemory((LPVOID*)  &szUserName );
        FreeMemory((LPVOID*)  &szServer );
        WbemFreeAuthIdentity( &pAuthIdentity );
        return(EXIT_FAILURE);
    }

    // check if the help option has been specified.
    if(bUsage==TRUE)
    {
        ShowUsage() ;
        ReleaseGlobals();
        FreeMemory((LPVOID*)  &szUserName );
        FreeMemory((LPVOID*)  &szServer );
        WbemFreeAuthIdentity( &pAuthIdentity );
        return(EXIT_SUCCESS);
    }

    bComInitFlag = InitialiseCom(&pIWbemLocator);
    if(bComInitFlag == FALSE )
    {
        CloseConnection(szServer);
        ReleaseGlobals();
        FreeMemory((LPVOID*)  &szUserName );
        FreeMemory((LPVOID*)  &szServer );
        WbemFreeAuthIdentity( &pAuthIdentity );
        return(EXIT_FAILURE);
    }

    try
    {
            strUserName = (LPCWSTR) szUserName ;
            strMachineName = (LPCWSTR) szServer ;
            strPassword = (LPCWSTR)szTmpPassword ;
            


        bFlag = ConnectWmiEx( pIWbemLocator, &pIWbemServReg, strMachineName,
                strUserName, strPassword, &pAuthIdentity, bNeedPassword, DEFAULT_NAMESPACE, &bLocalSystem );

        //if unable to connect to wmi exit failure
        if( bFlag == FALSE )
        {
            SAFEIRELEASE( pIWbemLocator);
            WbemFreeAuthIdentity( &pAuthIdentity );
            FreeMemory((LPVOID*)  &szUserName );
            FreeMemory((LPVOID*)  &szServer );
            CoUninitialize();
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }
        
        //free the memory of these variables
        FreeMemory((LPVOID*)  &szUserName );
        FreeMemory((LPVOID*)  &szServer );
        
        //get the changed server name, user name, password back
        szUserName = strUserName.GetBuffer(strUserName.GetLength());
        szPassword = strPassword.GetBuffer(strPassword.GetLength()) ;
        szServer = strMachineName.GetBuffer(strPassword.GetLength());

    }
    catch(CHeap_Exception)
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
        WbemFreeAuthIdentity( &pAuthIdentity );
        CoUninitialize();
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    //display warning message if local credentials supplied
    if( ( IsLocalSystem( szServer ) == TRUE )&&(StringLengthW(szUserName, 0)!=0) )
    {
        ShowMessage(stderr,GetResString(IDS_IGNORE_LOCAL_CRED));
    }

    // establish connection to remote system by using win32api function
    if ( bLocalSystem == FALSE )
    {
        LPCWSTR pwszUser = NULL;
        LPCWSTR pwszPassword = NULL;

        // identify the password to connect to the remote system
        if ( pAuthIdentity != NULL )
        {
            pwszPassword = pAuthIdentity->Password;
            if ( strUserName.GetLength() != 0 )
                pwszUser =(LPCWSTR) strUserName;
        }

        DWORD dwConnect = 0 ;
        dwConnect = ConnectServer( (LPCWSTR)strMachineName, pwszUser, pwszPassword );
        if(dwConnect !=NO_ERROR )
        {
            dwErrCode = GetLastError();
            if(dwErrCode == ERROR_SESSION_CREDENTIAL_CONFLICT)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_WARNING | SLE_INTERNAL );
            }
            else if( dwConnect == ERROR_EXTENDED_ERROR )
            {
                ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                WbemFreeAuthIdentity( &pAuthIdentity );
                strMachineName.ReleaseBuffer();
                 strUserName.ReleaseBuffer();
                strPassword.ReleaseBuffer();
                CoUninitialize();
                ReleaseGlobals();
                return( EXIT_FAILURE );
            }
            else
            {
                SetLastError( dwConnect );
                SaveLastError();
                ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                WbemFreeAuthIdentity( &pAuthIdentity );
                strMachineName.ReleaseBuffer();
                strUserName.ReleaseBuffer();
                strPassword.ReleaseBuffer();
                CoUninitialize();
                ReleaseGlobals();
                return( EXIT_FAILURE );
            }
        }
        else
        {
            bLocalFlag = FALSE ;
        }
    }
    else
    {
        StringCopy( szServer, _T( "" ), StringLengthW(szServer, 0) );
    }

    hQueryResult = QueryDriverInfo(szServer, szUserName,szPassword,szFormat,bHeader,bVerbose,pIWbemLocator,pAuthIdentity,pIWbemServReg,bSigned);
    if((DWORD)hQueryResult == FAILURE)
    {
        // close connection to the specified system and exit with failure.
        if (bLocalFlag == FALSE )
        {
            CloseConnection(szServer);
        }
        WbemFreeAuthIdentity( &pAuthIdentity );
        strMachineName.ReleaseBuffer();
        strUserName.ReleaseBuffer();
        strPassword.ReleaseBuffer();
        CoUninitialize();
        ReleaseGlobals();
        return(EXIT_FAILURE);
    }

    // close connection to the specified system and exit

    if (bLocalFlag == FALSE )
    {
        CloseConnection(szServer);
    }

    strMachineName.ReleaseBuffer();
    strUserName.ReleaseBuffer();
    strPassword.ReleaseBuffer();
    WbemFreeAuthIdentity( &pAuthIdentity );
    SAFEIRELEASE( pIWbemLocator);
    CoUninitialize();
    ReleaseGlobals();
    return (EXIT_SUCCESS);
 }

void ShowUsage()
/*++
 Routine Description:
      This function fetches usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      None
--*/

{
    DWORD dwIndex  = ID_USAGE_BEGIN;

    for(;dwIndex<=ID_USAGE_ENDING; dwIndex++)
    {
        ShowMessage(stdout,GetResString( dwIndex ));
    }
}

DWORD 
QueryDriverInfo(
                IN LPWSTR szServer,
                IN LPWSTR szUserName,
                IN LPWSTR szPassword,
                IN LPWSTR szFormat,
                IN BOOL bHeader,
                IN BOOL bVerbose,
                IN IWbemLocator* pIWbemLocator,
                IN COAUTHIDENTITY* pAuthIdentity,
                IN IWbemServices* pIWbemServReg,
                IN BOOL bSigned 
               )
/**+
 Routine Description:
      This function queries the driverinfo of the specified system by connecting to WMI

 Arguments:
      [ in ] szServer         : server name on which DriverInformation has to be queried.
      [ in ] szUserName       : User name for whom  DriverInformation has to be queried.
      [ in ] szPassword       : Password for the user
      [ in ] szFormat         : Format in which the results are to be displayed.
      [ in ] bHeader          : Boolean indicating if the header is required.
      [ in ] bVerbose         : Boolean indicating if the output is to be in verbose mode or not.
      [ in ] IWbemLocater     : Pointer to IWbemLocater.
      [ in ] pAuthIdentity    : Pointer to AuthIdentity structure.
      [ in ] IWbemServReg     : Pointer to IWbemServices object
      [ in ] bSigned          : Boolean variable indicating if signed drivers to show or not

 Return Value:
      SUCCESS : if the function is successful in querying
      FAILURE : if the function is unsuccessful in querying.
--*/
{

    HRESULT hRes = S_OK ;
    HRESULT hConnect = S_OK;
    _bstr_t bstrUserName ;
    _bstr_t bstrPassword ;
    _bstr_t bstrNamespace ;
    _bstr_t bstrServer ;
    
    DWORD dwProcessResult = 0;
    DWORD dwSystemType = 0 ;
    LPTSTR lpMsgBuf = NULL;
    
    IWbemServices *pIWbemServices = NULL;
    IEnumWbemClassObject *pSystemSet = NULL;

    HRESULT hISecurity = S_FALSE;
    HANDLE h_Mutex = 0;



    try
    {
        bstrNamespace = CIMV2_NAMESPACE ;
        bstrServer = szServer ;
    }
    catch(...)
    {
        ShowMessage( stderr,ERROR_RETREIVE_INFO);
        return FAILURE;
    }

    if ( IsLocalSystem( szServer ) == FALSE )
    {

        try
        {
            //appending UNC paths to form the complete path.
            bstrNamespace = TOKEN_BACKSLASH2 + _bstr_t( szServer ) + TOKEN_BACKSLASH + CIMV2_NAMESPACE;

            // if user name is specified then only take user name and password
            if ( StringLengthW( szUserName, 0 ) != 0 )
            {
                bstrUserName = szUserName;
                if (StringLengthW(szPassword, 0)==0)
                {
                    bstrPassword = L"";
                }
                else
                {
                    bstrPassword = szPassword ;
                }

            }
        }
        catch(...)
        {
            ShowMessage( stderr,ERROR_RETREIVE_INFO);
            return FAILURE;
        }
    }

    dwSystemType = GetSystemType(pAuthIdentity,pIWbemServReg);
    if (dwSystemType == ERROR_WMI_VALUES)
    {
        ShowMessage( stderr,ERROR_RETREIVE_INFO);
        return FAILURE;
    }

    // Connect to the Root\Cimv2 namespace of the specified system with the current user.
    // If no system is specified then connect to the local system.
    // To pass the appropriate Username to connectserver
    // depending upon whether the user has entered domain\user or only username at the command prompt.

    // connect to the server with the credentials supplied.

        hConnect = pIWbemLocator->ConnectServer(bstrNamespace,
                                                bstrUserName,
                                                bstrPassword,
                                                0L,
                                                0L,
                                                NULL,
                                                NULL,
                                                &pIWbemServices );

        if((StringLengthW(szUserName, 0)!=0) && FAILED(hConnect) &&  (hConnect == E_ACCESSDENIED))
        {
            hConnect = pIWbemLocator->ConnectServer(bstrNamespace,
                                                    bstrUserName,
                                                    NULL,
                                                    0L,
                                                    0L,
                                                    NULL,
                                                    NULL,
                                                    &pIWbemServices );

        }
        if(hConnect == WBEM_S_NO_ERROR)
        {
            // Set the proxy so that impersonation of the client occurs.

            hISecurity = SetInterfaceSecurity(pIWbemServices,pAuthIdentity);

            if(FAILED(hISecurity))
            {
                GetWbemErrorText(hISecurity);
                ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                SAFEIRELEASE(pIWbemServices);
                return FAILURE ;
            }

            // Use the IWbemServices pointer to make requests of WMI.
            // Create enumeration of Win32_Systemdriver class
            if(bSigned == FALSE)
            {
                hRes = pIWbemServices->CreateInstanceEnum(_bstr_t(CLASS_SYSTEMDRIVER),
                                                      WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                                      NULL,
                                                      &pSystemSet);
            }
            else
            {
                  h_Mutex = CreateMutex( NULL, FALSE, DRIVERQUERY_MUTEX );
                  if( h_Mutex !=  NULL  && GetLastError() == ERROR_ALREADY_EXISTS )
                  {
                      ShowMessage(stdout, GetResString(IDS_MORE_INSTANCES_SIGNEDDRIVERS));
                      SAFEIRELEASE(pIWbemServices);
                      return SUCCESS ;
                  }
                  hRes = pIWbemServices->ExecQuery(_bstr_t(LANGUAGE_WQL),_bstr_t(WQL_QUERY),WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY,NULL,&pSystemSet);
            }

            //if ( hRes == S_OK)
            if ( SUCCEEDED(hRes ))
            {

                hISecurity = SetInterfaceSecurity(pSystemSet,pAuthIdentity);

                if(FAILED(hISecurity))
                {
                    GetWbemErrorText(hISecurity);
                    ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                    SAFEIRELEASE(pSystemSet);
                    return FAILURE ;
                }

                if(bSigned == FALSE)
                {
                    dwProcessResult = ProcessCompSysEnum(szServer,pSystemSet,szFormat,bHeader,dwSystemType,bVerbose);
                }
                else
                {
                    dwProcessResult = ProcessSignedDriverInfo(szServer,pSystemSet,szFormat,bHeader,dwSystemType,bVerbose);
                }

                switch(dwProcessResult)
                {
                    case EXIT_FAILURE_MALLOC :
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        SaveLastError();
                        ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                        SAFEIRELEASE(pSystemSet);
                        SAFEIRELEASE(pIWbemServices);
                        return FAILURE ;

                    case EXIT_FAILURE_FORMAT:
                        ShowMessage(stderr, ERROR_ENUMERATE_INSTANCE);
                        SAFEIRELEASE(pSystemSet);
                        SAFEIRELEASE(pIWbemServices);
                        return FAILURE ;

                    case VERSION_MISMATCH_ERROR:
                        SAFEIRELEASE(pSystemSet);
                        SAFEIRELEASE(pIWbemServices);
                        return FAILURE ;

                    case EXIT_SUCCESSFUL:
                        SAFEIRELEASE(pSystemSet);
                        SAFEIRELEASE(pIWbemServices);
                        return SUCCESS ;
                        break ;

                    case EXIT_FAILURE_RESULTS:
                        ShowMessage(stdout, NEWLINE );
                        ShowMessage(stdout,GetResString(IDS_NO_DRIVERS_FOUND));
                        SAFEIRELEASE(pSystemSet);
                        SAFEIRELEASE(pIWbemServices);
                        return SUCCESS ;
 
                    default :
                         break;
                }

            }
            else
            {
                ShowMessage( stderr, ERROR_ENUMERATE_INSTANCE);
                SAFEIRELEASE(pIWbemServices);
                return FAILURE;
            }
        }
        else
        {
            //display the error if connect server fails
            //unauthorized user
                if(hRes == WBEM_E_ACCESS_DENIED)
                {
                    ShowMessage( stderr, ERROR_AUTHENTICATION_FAILURE);
                }
                //local system credentials
                else if(hRes == WBEM_E_LOCAL_CREDENTIALS)
                {
                    ShowMessage( stderr, ERROR_LOCAL_CREDENTIALS);
                }
                //some error
                else
                {
                    ShowMessage( stderr, ERROR_WMI_FAILURE );
                }
                return (FAILURE);
        }

   	SAFEIRELEASE(pIWbemServices);
	SAFEIRELEASE(pSystemSet); 	
    return (hRes);
}

DWORD 
ProcessCompSysEnum(
                   IN CHString szHost, 
                   IN IEnumWbemClassObject *pSystemSet,
                   IN LPTSTR szFormat,
                   IN BOOL bHeader,
                   IN DWORD dwSystemType,
                   IN BOOL bVerbose
                  )
/*++
 Routine Description:
      Processes enumeration of Win32_SystemDirver instances

 Arguments:
      [ in ]  szHost                  : HostName to connect to
      [ in ]  pSystemSet              : pointer to the structure containing system properties.
      [ in ]  szFormat                : specifies the format
      [ in ]  bHeader                 : specifies if the header is required or not.
      [ in ]  dwSystemType            : specifies the sytem type.
      [ in ]  bVerbose                : Boolean varibale tells whether verbose mode is on or not.

 Return Value:
       0   no error
       1   error occured while allocating memory.
--*/
{
    HRESULT hRes = S_OK;
    ULONG ulReturned = 1;


    // declare variant type variables

    VARIANT vtPathName;

    //declaration  of normal variables
    CHString szPathName ;
    DWORD dwLength = 0;
    LPCTSTR szPath = NULL;
    LPTSTR szHostName = NULL ;
    CHString szAcceptPauseVal ;
    CHString szAcceptStopVal ;
    LPTSTR szSysManfact = NULL;
    TARRAY arrResults  = NULL ;
    TCHAR szPrintPath[MAX_STRING_LENGTH+1] =TOKEN_EMPTYSTRING ;
    DWORD dwRow = 0 ;
    BOOL bValue = FALSE ;
    DWORD dwValue = 0 ;

    TCHAR szDelimiter[MAX_RES_STRING+1] = NULL_STRING  ;

    DWORD dwPosn1 = 0;
    DWORD dwStrlen = 0;


    DWORD dwFormatType = SR_FORMAT_TABLE ;

    MODULE_DATA Current ;

    BOOL bResult = FALSE ;
    NUMBERFMT  *pNumberFmt = NULL;
    TCOLUMNS ResultHeader[ MAX_COLUMNS ];
    IWbemClassObject *pSystem = NULL;
    LPTSTR szCodeSize = NULL;
    LPTSTR szInitSize = NULL;
    LPTSTR szBssSize = NULL ;
    LPTSTR szAcceptStop = NULL ;
    int iLen = 0;
    LPTSTR szAcceptPause = NULL;
    LPTSTR szPagedSize = NULL ;
    TCHAR szDriverTypeVal[MAX_RES_STRING+1] = NULL_STRING;

    DWORD dwLocale = 0 ;
    WCHAR wszStrVal[MAX_RES_STRING+1] = NULL_STRING;

    CHString szValue ;
    CHString szSysName ;
    CHString szStartMode ;
    CHString szDispName ;
    CHString szDescription ;
    CHString szStatus ;
    CHString szState ;
    CHString szDriverType ;
    BOOL bBlankLine = FALSE;
    BOOL bFirstTime = TRUE;

    //get the paged pool acc to the Locale
    BOOL bFValue = FALSE ;

    // Fill up the NUMBERFMT structure acc to the locale specific information
    LPTSTR szGroupSep = NULL;
    LPTSTR szDecimalSep = NULL ;
    LPTSTR szGroupThousSep = NULL ;


    pNumberFmt = (NUMBERFMT *) AllocateMemory(sizeof(NUMBERFMT));
    if(pNumberFmt == NULL)
    {
        return EXIT_FAILURE_MALLOC ;

    }


    // Initialise the structure to Zero.
    SecureZeroMemory(&Current,sizeof(Current));

    // assign the appropriate format type to the dwFormattype flag

    if( StringCompare(szFormat,TABLE_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_TABLE;
    }
    else if( StringCompare(szFormat,LIST_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_LIST;
    }
    else if( StringCompare(szFormat,CSV_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_CSV;
    }

    // formulate the Column headers and show results appropriately
    FormHeader(dwFormatType,bHeader,ResultHeader,bVerbose);

    // loop till there are results.
    bFirstTime = TRUE;
    while ( ulReturned == 1 )
    {
        // Create new Dynamic Array to hold the result
        arrResults = CreateDynamicArray();

        if(arrResults == NULL)
        {
            FreeMemory((LPVOID*) &pNumberFmt);
            return EXIT_FAILURE_MALLOC ;
        }

        // Enumerate through the resultset.
        hRes = pSystemSet->Next(WBEM_INFINITE,
                                1,              // return just one system
                                &pSystem,       // pointer to system
                                &ulReturned );  // number obtained: one or zero

        if ( SUCCEEDED( hRes ) && (ulReturned == 1) )
        {

            // initialise the variant variables to empty
            VariantInit(&vtPathName);
            szValue = NO_DATA_AVAILABLE;
            szSysName = NO_DATA_AVAILABLE ;
            szStartMode = NO_DATA_AVAILABLE ;
            szDispName = NO_DATA_AVAILABLE ;
            szDescription = NO_DATA_AVAILABLE ;
            szStatus = NO_DATA_AVAILABLE ;
            szState = NO_DATA_AVAILABLE ;
            szDriverType = NO_DATA_AVAILABLE ;

            try
            {
                hRes = PropertyGet(pSystem,PROPERTY_NAME,szValue);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_SYSTEMNAME,szSysName);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_STARTMODE,szStartMode);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_DISPLAYNAME,szDispName);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_DESCRIPTION,szDescription);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_STATUS,szStatus);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_STATE,szState);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_ACCEPTPAUSE,szAcceptPauseVal);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_ACCEPTSTOP,szAcceptStopVal);
                ONFAILTHROWERROR(hRes);
                hRes = PropertyGet(pSystem,PROPERTY_SERVICETYPE,szDriverType);
                ONFAILTHROWERROR(hRes);
            }
            catch(_com_error)
            {
                ShowMessage(stderr,ERROR_GET_VALUE);
                SAFEIRELEASE(pSystem);
                DestroyDynamicArray(&arrResults);
                FreeMemory((LPVOID*) &pNumberFmt);
                return FAILURE;
            }

            // retreive the PathName property
            szPath = NULL;
            try
            {
                hRes = pSystem->Get( PROPERTY_PATHNAME, 0,&vtPathName,0,NULL );
                if (( hRes == WBEM_S_NO_ERROR) && (vtPathName.vt != VT_NULL) && (vtPathName.vt != VT_EMPTY))
                {
                        szPathName = ( LPWSTR ) _bstr_t(vtPathName);
                        szSysManfact = (LPTSTR) AllocateMemory ((MAX_RES_STRING) * sizeof(TCHAR));
                        if (szSysManfact == NULL)
                        {
                            SAFEIRELEASE(pSystem);
                            DestroyDynamicArray(&arrResults);
                            FreeMemory((LPVOID *) &pNumberFmt);
                            return EXIT_FAILURE_MALLOC;
                        }

                        dwLength = szPathName.GetLength();
                        GetCompatibleStringFromUnicode( szPathName, szSysManfact, dwLength+2 );
                        szPath = szSysManfact ;

                        // Initialise the structure to Zero.
                        SecureZeroMemory(&Current,sizeof(Current));

                        // convert the szHost variable (containing hostname) into LPCTSTR and pass it to the GETAPI function
                        szHostName = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR)));
                        if (szHostName == NULL)
                        {
                            SAFEIRELEASE(pSystem);
                            DestroyDynamicArray(&arrResults);
                            FreeMemory((LPVOID *) &pNumberFmt);
                            FreeMemory((LPVOID *) &szSysManfact);
                            return EXIT_FAILURE_MALLOC;
                        }

                        GetCompatibleStringFromUnicode( szHost, szHostName,dwLength+2 );

                        StringCopy(szPrintPath,szPath, SIZE_OF_ARRAY(szPrintPath));
                        BOOL bApiInfo = GetApiInfo(szHostName,szPath,&Current, dwSystemType);
                        if(bApiInfo == FAILURE)
                        {
                            DestroyDynamicArray(&arrResults);
                            FreeMemory((LPVOID*) &szHostName);
                            FreeMemory((LPVOID*) &szSysManfact);
                            continue ;
                        }


                }
                else
                {
                        DestroyDynamicArray(&arrResults);
                        FreeMemory((LPVOID*) &szHostName);
                        FreeMemory((LPVOID*) &szSysManfact);
                        continue ;  // ignore exception
                }
            }
            catch(...)
            {
                // If the path is empty then ignore the present continue with next iteration
                DestroyDynamicArray(&arrResults);
                FreeMemory((LPVOID*) &szHostName);
                FreeMemory((LPVOID*) &szSysManfact);
                continue ;  // ignore exception

            }


            //create a new empty row with required no of  columns
            dwRow = DynArrayAppendRow(arrResults,MAX_COLUMNS) ;

            // Insert  the results into the Dynamic Array

            DynArraySetString2( arrResults,dwRow,COL0,szSysName,0 );
            DynArraySetString2( arrResults,dwRow,COL1,szValue,0 );
            DynArraySetString2( arrResults,dwRow,COL2,szDispName,0 );
            DynArraySetString2( arrResults,dwRow,COL3,szDescription,0 );

            // strip off the word Driver from the display.


            dwLength = StringLengthW(szDriverType, 0) ;
            GetCompatibleStringFromUnicode( szDriverType, szDriverTypeVal,dwLength+2 );

            StringCopy(szDelimiter,DRIVER_TAG, SIZE_OF_ARRAY(szDelimiter));
            dwPosn1 = _tcslen(szDelimiter);
            dwStrlen = _tcslen(szDriverTypeVal);
            szDriverTypeVal[dwStrlen-dwPosn1] = _T('\0');


            DynArraySetString2( arrResults,dwRow,COL4,szDriverTypeVal,0 );
            DynArraySetString2( arrResults,dwRow,COL5,szStartMode,0 );
            DynArraySetString2( arrResults,dwRow,COL6,szState,0 );
            DynArraySetString2( arrResults,dwRow,COL7,szStatus,0 );

            iLen = StringLengthW(szAcceptStopVal, 0);
            szAcceptStop = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szAcceptStop == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC;
            }

            GetCompatibleStringFromUnicode(szAcceptStopVal,szAcceptStop,iLen + 2 );
            szAcceptStop[iLen] = '\0';
            if (StringCompare(szAcceptStop,_T("0"), TRUE, 0)==0)
            {
                StringCopy(szAcceptStop,FALSE_VALUE, SIZE_OF_ARRAY_IN_CHARS(szAcceptStop));

            }
            else
            {
                StringCopy(szAcceptStop,TRUE_VALUE, SIZE_OF_ARRAY_IN_CHARS(szAcceptStop));
            }

            DynArraySetString2( arrResults,dwRow,COL8,szAcceptStop,0 );


            iLen = StringLengthW(szAcceptPauseVal, 0);
            szAcceptPause = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szAcceptPause == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC;
            }

            GetCompatibleStringFromUnicode(szAcceptPauseVal,szAcceptPause,iLen + 2 );
            szAcceptPause[iLen] = '\0';
            if (StringCompare(szAcceptPause,_T("0"), TRUE, 0)==0)
            {
                StringCopy(szAcceptPause,FALSE_VALUE, SIZE_OF_ARRAY_IN_CHARS(szAcceptPause));
            }
            else
            {
                StringCopy(szAcceptPause,TRUE_VALUE,  SIZE_OF_ARRAY_IN_CHARS(szAcceptPause));
            }


            DynArraySetString2( arrResults,dwRow,COL9,szAcceptPause,0 );

            bFValue = FormatAccToLocale(pNumberFmt, &szGroupSep,&szDecimalSep,&szGroupThousSep);
            if (bFValue == FALSE)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_FORMAT ;
            }

            szPagedSize = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szPagedSize == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC;
            }

            _ltow(Current.ulPagedSize, wszStrVal,10);
            dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
                               szPagedSize,(MAX_RES_STRING + 1));
            if(dwLocale == 0)
            {
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szPagedSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_FORMAT;
            }

            DynArraySetString2( arrResults,dwRow,COL10, szPagedSize,0 );

            // get the CodeSize info acc to the locale


            szCodeSize = (LPTSTR) AllocateMemory ((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szCodeSize == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szPagedSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC;
            }


            _ltow(Current.ulCodeSize, wszStrVal,10);
            dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,szCodeSize,(MAX_RES_STRING + 1));
            if(dwLocale == 0)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szCodeSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_FORMAT ;
            }
            DynArraySetString2( arrResults,dwRow,COL11, szCodeSize,0 );

            // retreive the bss info acc to the locale

            szBssSize = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szBssSize == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szCodeSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC ;
            }

            _ltow(Current.ulBssSize, wszStrVal,10);
            dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
                               szBssSize,(MAX_RES_STRING + 1));
            if(dwLocale == 0)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szCodeSize);
                FreeMemory((LPVOID *) &szBssSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_FORMAT ;
            }
            DynArraySetString2( arrResults,dwRow,COL12, szBssSize,0 );


            //link date
            DynArraySetString2(arrResults,dwRow,COL13,(LPTSTR)(Current.szTimeDateStamp),0);

            //Path of the File
            if(szPath != NULL)
            {
                DynArraySetString2(arrResults,dwRow,COL14,(LPTSTR)szPrintPath,0);  //
            }
            else
            {
                szPath= NO_DATA_AVAILABLE;
                DynArraySetString2(arrResults,dwRow,COL14,(LPTSTR)szPath,0);  //
            }


            // get the initsize info acc to the locale
            szInitSize = (LPTSTR) AllocateMemory((MAX_RES_STRING) * (sizeof(TCHAR )));
            if (szInitSize == NULL)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szCodeSize);
                FreeMemory((LPVOID *) &szBssSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_MALLOC ;
            }

            _ltow(Current.ulInitSize, wszStrVal,10);
            dwLocale = GetNumberFormat(LOCALE_USER_DEFAULT,0,wszStrVal,pNumberFmt,
                           szInitSize,(MAX_RES_STRING + 1));
            if(dwLocale == 0)
            {
                SAFEIRELEASE(pSystem);
                FreeMemory((LPVOID *) &pNumberFmt);
                FreeMemory((LPVOID *) &szHostName);
                FreeMemory((LPVOID *) &szSysManfact);
                FreeMemory((LPVOID *) &szAcceptStop);
                FreeMemory((LPVOID *) &szAcceptPause);
                FreeMemory((LPVOID *) &szCodeSize);
                FreeMemory((LPVOID *) &szBssSize);;
                FreeMemory((LPVOID *) &szInitSize);
                FreeMemory((LPVOID *) &szGroupThousSep);
                FreeMemory((LPVOID *) &szDecimalSep);
                FreeMemory((LPVOID *) &szGroupSep);
                DestroyDynamicArray(&arrResults);
                return EXIT_FAILURE_FORMAT ;
            }

            DynArraySetString2( arrResults,dwRow,COL15, szInitSize,0 );

            if ( bBlankLine == TRUE && (dwFormatType & SR_FORMAT_MASK) == SR_FORMAT_LIST )
                ShowMessage( stdout, _T( "\n" ) );

            if ( bFirstTime == TRUE && (dwFormatType & SR_FORMAT_MASK) != SR_FORMAT_CSV)
            {
                ShowMessage( stdout, _T( "\n" ) );
                bFirstTime = FALSE;
            }

            if(bHeader)
            {
                ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType|SR_NOHEADER,arrResults ) ;
            }
            else
            {
                ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType,arrResults ) ;
            }

            //set the header flag to true
            bHeader = TRUE ;
            bBlankLine = TRUE;
            //set the bResult to true indicating that driver information has been displyed.
            bResult = TRUE ;

            // free the allocated memory
            FreeMemory((LPVOID *) &szSysManfact);
            FreeMemory((LPVOID *) &szHostName);
            FreeMemory((LPVOID *) &szAcceptStop);
            FreeMemory((LPVOID *) &szAcceptPause);
            FreeMemory((LPVOID *) &szPagedSize);
            FreeMemory((LPVOID *) &szBssSize);
            FreeMemory((LPVOID *) &szInitSize);
            FreeMemory((LPVOID *) &szCodeSize);
            FreeMemory((LPVOID *) &szGroupThousSep);
            FreeMemory((LPVOID *) &szDecimalSep);
            FreeMemory((LPVOID *) &szGroupSep);
            SAFEIRELEASE(pSystem);

        } // If System Succeeded

        // Destroy the Dynamic arrays
        DestroyDynamicArray(&arrResults);

    }// While SystemSet returning objects

    FreeMemory((LPVOID *) &pNumberFmt);
    FreeMemory((LPVOID *) &szSysManfact);
    FreeMemory((LPVOID *) &szHostName);
    FreeMemory((LPVOID *) &szAcceptStop);
    FreeMemory((LPVOID *) &szAcceptPause);
    FreeMemory((LPVOID *) &szPagedSize);
    FreeMemory((LPVOID *) &szBssSize);
    FreeMemory((LPVOID *) &szInitSize);
    FreeMemory((LPVOID *) &szCodeSize);
    FreeMemory((LPVOID *) &szGroupThousSep);
    FreeMemory((LPVOID *) &szDecimalSep);
    FreeMemory((LPVOID *) &szGroupSep);

    // return the error value or success value
    if (bResult == TRUE)
    {
        return SUCCESS ;
    }
    else
    {
        return EXIT_FAILURE_RESULTS ;
    }
}

BOOL GetApiInfo( IN  LPTSTR szHostName,
                 IN  LPCTSTR pszPath,
                 OUT PMODULE_DATA Mod,
                 IN  DWORD dwSystemType
               )
/*++
 Routine Description:
      This function queries the system properties using API's .

 Arguments:
      [ in ]  szHostName      : HostName to connect to
      [ in ]  pszPath         : pointer to the string containing the Path of the  file.
      [ out]  Mod             : pointer to the structure containing system properties.
      [ in ]  dwSystemType    : variable specifies the system type

 Return Value:
      SUCCESS : If successful in getting the information using API's.
      FAILURE : If unable to get the information using API's.
--*/
               
{

    HANDLE hMappedFile = NULL;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG ulSectionAlignment = 0;
    PIMAGE_SECTION_HEADER Section;
    DWORD dwI = 0;
    ULONG ulSize = 0;
    TCHAR szTmpServer[ MAX_STRING_LENGTH + 1 ] = NULL_STRING;
    HANDLE hFile = NULL ;
    PTCHAR pszToken = NULL;
    StringCopy(szTmpServer,TOKEN_BACKSLASH2, SIZE_OF_ARRAY(szTmpServer));
    TCHAR szFinalPath[MAX_STRING_LENGTH+1] =TOKEN_EMPTYSTRING ;
    PTCHAR pdest = NULL ;

#ifndef _WIN64
    BOOL bIsWin64;
#endif

    //copy the path into a variable
    StringCopy(szFinalPath,pszPath, SIZE_OF_ARRAY(szFinalPath));


    //get the token upto the delimiter ":"
    pszToken = _tcstok(szFinalPath, COLON_SYMBOL );


    //form the string for getting the absolute path in the required format if it is a remote system.
    if(_tcslen(szHostName) != 0)
    {
        pdest = (PTCHAR)FindString(pszPath,COLON_SYMBOL, 0);

        if(pdest== NULL)
        {
            return FAILURE ;
        }

        _tcsnset(pdest,TOKEN_DOLLAR,1);
        StringConcat(szTmpServer,szHostName, SIZE_OF_ARRAY(szTmpServer));
        StringConcat(szTmpServer,TOKEN_BACKSLASH, SIZE_OF_ARRAY(szTmpServer));
        StringConcat(szTmpServer,pszToken, SIZE_OF_ARRAY(szTmpServer));
        StringConcat(szTmpServer,pdest, SIZE_OF_ARRAY(szTmpServer));
    }
    else
    {
        StringCopy(szTmpServer,pszPath, SIZE_OF_ARRAY(szTmpServer)) ;
    }


#ifndef _WIN64
    bIsWin64 = IsWin64();

    if(bIsWin64)
        Wow64DisableFilesystemRedirector((LPCTSTR)szTmpServer);
#endif

    // create a file on the specified system and return a handle to it.
    hFile = CreateFile(szTmpServer,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);



    //if the filehandle is invalid then return a error
    if(hFile == INVALID_HANDLE_VALUE)
    {
        return FAILURE ;
    }



#ifndef _WIN64
    if(bIsWin64)
        Wow64EnableFilesystemRedirector();
#endif

    // create a mapping to the specified file
    hMappedFile = CreateFileMapping(hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    0,
                                    NULL);
     if (hMappedFile == NULL)
    {
        CloseHandle(hFile);
        return FAILURE ;
    }

    LoadedImage.MappedAddress = (PUCHAR)MapViewOfFile(hMappedFile,
                                                      FILE_MAP_READ,
                                                      0,
                                                      0,
                                                      0);

    // close the opened file handles
    CloseHandle(hMappedFile);
    CloseHandle(hFile);

    if ( !LoadedImage.MappedAddress )
    {
        return FAILURE ;
    }


    // check the image and find nt image headers

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    //exit if the DOS header does not match
    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE )
    {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return FAILURE ;
    }


    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE )
    {
        UnmapViewOfFile(LoadedImage.MappedAddress);

        return FAILURE ;
    }

    //get the number of sections present
    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;

    if(dwSystemType == SYSTEM_64_BIT )
    {
        LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS64));
    }
    else
    {
        LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS32));
    }

    LoadedImage.LastRvaSection = LoadedImage.Sections;

    // Walk through the sections and tally the dater

    ulSectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for(Section = LoadedImage.Sections,dwI=0;dwI < LoadedImage.NumberOfSections; dwI++,Section++)
    {
        ulSize = Section->Misc.VirtualSize;

        if (ulSize == 0)
        {
            ulSize = Section->SizeOfRawData;
        }

        ulSize = (ulSize + ulSectionAlignment - 1) & ~(ulSectionAlignment - 1);


        if (!_strnicmp((char *)(Section->Name),EXTN_PAGE, 4 ))
        {
            Mod->ulPagedSize += ulSize;
        }


        else if (!_stricmp((char *)(Section->Name),EXTN_INIT ))
        {
            Mod->ulInitSize += ulSize;
        }

        else if(!_stricmp((char *)(Section->Name),EXTN_BSS))
        {
            Mod->ulBssSize = ulSize;
        }
        else if (!_stricmp((char *)(Section->Name),EXTN_EDATA))
        {
            Mod->ulExportDataSize = ulSize ;
        }
        else if (!_stricmp((char *)(Section->Name),EXTN_IDATA ))
        {
            Mod->ulImportDataSize = ulSize;
        }
        else if (!_stricmp((char *)(Section->Name),EXTN_RSRC))
        {
            Mod->ulResourceDataSize = ulSize;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE)
        {
            Mod->ulCodeSize += ulSize;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE)
        {
            Mod->ulDataSize += ulSize;
        }
        else
        {
            Mod->ulDataSize += ulSize;
        }
     }

    #ifndef _WIN64
    LONG lTimeVal ;

    #else
    LONG64 lTimeVal;
    #endif

    lTimeVal = LoadedImage.FileHeader->FileHeader.TimeDateStamp ;

    struct tm *tmVal = NULL;
    tmVal = localtime(&lTimeVal);

    // proceed furthur only if we successfully got the localtime
    if ( tmVal != NULL )
    {
        LCID lcid;
        SYSTEMTIME systime;
        __STRING_64 szBuffer;
        BOOL bLocaleChanged = FALSE;

        systime.wYear = (WORD) (DWORD_PTR)( tmVal->tm_year + 1900 );    // tm -> Year - 1900   SYSTEMTIME -> Year = Year
        systime.wMonth = (WORD) (DWORD_PTR) tmVal->tm_mon + 1;          // tm -> Jan = 0       SYSTEMTIME -> Jan = 1
        systime.wDayOfWeek = (WORD) (DWORD_PTR) tmVal->tm_wday;
        systime.wDay = (WORD) (DWORD_PTR) tmVal->tm_mday;
        systime.wHour = (WORD) (DWORD_PTR) tmVal->tm_hour;
        systime.wMinute = (WORD) (DWORD_PTR) tmVal->tm_min;
        systime.wSecond = (WORD) (DWORD_PTR) tmVal->tm_sec;
        systime.wMilliseconds = 0;

        // verify whether console supports the current locale 100% or not
        lcid = GetSupportedUserLocale( bLocaleChanged );

        // get the formatted date
        GetDateFormat( lcid, 0, &systime,
            ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), szBuffer, SIZE_OF_ARRAY( szBuffer ) );

        // copy the date info
        StringCopy( Mod->szTimeDateStamp, szBuffer, MAX_STRING_LENGTH+1 );

        // now format the date
        GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime,
            ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), szBuffer, SIZE_OF_ARRAY( szBuffer ) );

        // now copy time info
        StringConcat( Mod->szTimeDateStamp, _T( " " ), MAX_STRING_LENGTH );
        StringConcat( Mod->szTimeDateStamp, szBuffer, MAX_STRING_LENGTH );
    }

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return SUCCESS;
}


BOOL 
ProcessOptions(
               IN  LONG argc,
               IN  LPCTSTR argv[],
               OUT PBOOL pbShowUsage,
               OUT LPTSTR *pszServer,
               OUT LPTSTR *pszUserName,
               OUT LPTSTR pszPassword,
               OUT LPTSTR pszFormat,
               OUT PBOOL pbHeader, 
               OUT PBOOL bNeedPassword,
               OUT PBOOL pbVerbose,
               OUT PBOOL pbSigned
              )
/*++
 Routine Description:
      This function parses the options specified at the command prompt

 Arguments:
      [ in  ] argc            : count of elements in argv
      [ in  ] argv            : command-line parameterd specified by the user
      [ out ] pbShowUsage     : set to TRUE if -? exists in 'argv'
      [ out ] pszServer       : value(s) specified with -s ( server ) option in 'argv'
      [ out ] pszUserName     : value of -u ( username ) option in 'argv'
      [ out ] pszPassword     : value of -p ( password ) option in 'argv'
      [ out ] pszFormat       : Display format
      [ out ] bHeader         : specifies whether to display a header or not.
      [ in  ] bNeedPassword   : specifies if the password is required or not.
      [ in  ] pbVerbose       : Boolean variable returns back if Verbose option specified
      [ in  ] pbSigned        : Boolean variable returns back if /si switch is specified.

 Return Value:
      TRUE    : if the parsing is successful
      FALSE   : if errors occured in parsing
--*/

{

    PTCMDPARSER2 pcmdOption = NULL; //pointer to the structure
    TCMDPARSER2 cmdOptions[MAX_OPTIONS] ;
    BOOL bval = TRUE ;
    LPCTSTR szToken = NULL ;

    // init the password
    if ( pszPassword != NULL )
    {
        StringCopy( pszPassword, _T( "*" ), MAX_RES_STRING );
    }

    // help option
    pcmdOption  = &cmdOptions[OI_HELP] ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_USAGE ;
    pcmdOption->pValue = pbShowUsage ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_HELP;
    StringCopyA(cmdOptions[OI_HELP].szSignature, "PARSER2", 8 );



    //server name option
    pcmdOption  = &cmdOptions[OI_SERVER] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->pValue = NULL ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = 0;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=OPTION_SERVER; // _T("s")
    StringCopyA(cmdOptions[OI_SERVER].szSignature, "PARSER2", 8 );

    //domain\user option
    pcmdOption  = &cmdOptions[OI_USERNAME] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL ;
    pcmdOption->pValue = NULL;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_USERNAME; // _T("u")
    StringCopyA(cmdOptions[OI_USERNAME].szSignature, "PARSER2", 8 );
    
    //password option
    pcmdOption  = &cmdOptions[OI_PASSWORD] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->pValue = pszPassword;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = MAX_RES_STRING;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=OPTION_PASSWORD;  // _T("p")
    StringCopyA(cmdOptions[OI_PASSWORD].szSignature, "PARSER2", 8 );

    //format option.
    pcmdOption  = &cmdOptions[OI_FORMAT] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_MODE_VALUES | CP_VALUE_MANDATORY;
    pcmdOption->pValue = pszFormat ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = MAX_RES_STRING;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=FORMAT_VALUES;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=OPTION_FORMAT; // _T("fo")
    StringCopyA(cmdOptions[OI_FORMAT].szSignature, "PARSER2", 8 );


    //no header option
    pcmdOption  = &cmdOptions[OI_HEADER] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags =  0;
    pcmdOption->pValue = pbHeader;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwLength = 0;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL_STRING;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=OPTION_HEADER; // _T("nh")
    StringCopyA(cmdOptions[OI_HEADER].szSignature, "PARSER2", 8 );


    //verbose option..
    pcmdOption  = &cmdOptions[OI_VERBOSE] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags =  0 ;
    pcmdOption->pValue = pbVerbose;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwLength = 0;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL_STRING;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=OPTION_VERBOSE; // _T("v")
    StringCopyA(cmdOptions[OI_VERBOSE].szSignature, "PARSER2", 8 );


    pcmdOption  = &cmdOptions[OI_SIGNED] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags =  0 ;
    pcmdOption->pValue = pbSigned;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwLength = 0;
    pcmdOption->dwReserved = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL_STRING;
    pcmdOption->pwszOptions=OPTION_SIGNED; // _T("di")
    StringCopyA(cmdOptions[OI_SIGNED].szSignature, "PARSER2", 8 );


    bval = DoParseParam2(argc,argv,-1, MAX_OPTIONS,cmdOptions, 0) ;

    if( bval== FALSE)
    {
       ShowMessage(stderr,ERROR_TAG);
       return FALSE ;
    }

    if((*pbShowUsage == TRUE)&&(argc > 2))
    {
            SetReason(ERROR_SYNTAX);
            return FALSE ;
    }
    *pszServer = (LPTSTR) cmdOptions[OI_SERVER].pValue;
    *pszUserName = (LPTSTR) cmdOptions[OI_USERNAME].pValue;
     
    // checking if -u is specified when -s options is not specified and display error msg .
    if ((cmdOptions[OI_SERVER].dwActuals == 0) && (cmdOptions[OI_USERNAME].dwActuals !=0 ))
    {
        SetReason(ERROR_USERNAME_BUT_NOMACHINE);
        return FALSE ;
    }

    // checking if -u is specified when -p options is not specified and display error msg .
    if ((cmdOptions[OI_USERNAME].dwActuals == 0) && (cmdOptions[OI_PASSWORD].dwActuals !=0 ))
    {
        SetReason(ERROR_PASSWORD_BUT_NOUSERNAME);
        return FALSE ;
    }

    // checking if -p is specified when -u options is not specified and display error msg .
    if ((cmdOptions[OI_SERVER].dwActuals != 0) && (StringLengthW(*pszServer, 0)==0 ))
    {
        SetReason(ERROR_INVALID_SERVER);
        return FALSE ;
    }

    // checking if -p is specified when -u options is not specified and display error msg .
    if ((cmdOptions[OI_USERNAME].dwActuals != 0) && (StringLengthW(*pszUserName, 0)==0 ))
    {
        SetReason(ERROR_INVALID_USER);
        return FALSE ;
    }

    if((cmdOptions[OI_FORMAT].dwActuals != 0)&&(StringCompare((LPCTSTR)cmdOptions[OI_FORMAT].pValue,LIST_FORMAT, TRUE, 0) == 0)&&(cmdOptions[OI_HEADER].dwActuals != 0))
    {
        SetReason(ERROR_NO_HEADERS);
        return FALSE ;
    }

    if((cmdOptions[OI_SIGNED].dwActuals != 0)&&(cmdOptions[OI_VERBOSE].dwActuals != 0))
    {
        SetReason(INVALID_SIGNED_SYNTAX);
        return FALSE ;
    }

    if(StrCmpN(*pszServer,TOKEN_BACKSLASH2,2)==0)
    {
        if(!StrCmpN(*pszServer,TOKEN_BACKSLASH3,3)==0)
        {
            szToken = *pszServer+2;
            StringCopy( *pszServer, szToken, SIZE_OF_ARRAY_IN_CHARS(*pszServer) );
//            szToken = _tcstok(*pszServer,TOKEN_BACKSLASH2);
//            StringCopy(*pszServer,szToken, MAX_STRING_LENGTH);
        }
    }

    if(IsLocalSystem( *pszServer ) == FALSE )
    {
        // set the bNeedPassword to True or False .
        if ( cmdOptions[ OI_PASSWORD ].dwActuals != 0 &&
             pszPassword != NULL && pszPassword != NULL && StringCompare( pszPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            *bNeedPassword = TRUE;
        }
        else if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 &&
                ( cmdOptions[ OI_SERVER ].dwActuals != 0 || cmdOptions[ OI_USERNAME ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            *bNeedPassword = TRUE;
            if ( pszPassword != NULL && pszPassword != NULL )
            {
                StringCopy( pszPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }
    return TRUE ;
}

VOID 
FormHeader(
          IN  DWORD dwFormatType,
          IN  BOOL bHeader,
          OUT TCOLUMNS *ResultHeader,
          IN  BOOL bVerbose
          )
/*++
 Routine Description:
      This function is used to build the header and also display the
       result in the required format as specified by  the user.

 Arguments:
      [ in ] arrResults     : argument(s) count specified at the command prompt
      [ in ] dwFormatType   : format flags
      [ in ] bHeader        : Boolean for specifying if the header is required or not.

 Return Value:
      none
--*/
{

    // host name
    ResultHeader[COL0].dwWidth = COL_HOSTNAME_WIDTH;
    ResultHeader[COL0].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    ResultHeader[COL0].pFunction = NULL;
    ResultHeader[COL0].pFunctionData = NULL;
    StringCopy( ResultHeader[COL0].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL0].szColumn,COL_HOSTNAME, MAX_STRING_LENGTH );


    //File Name header
    ResultHeader[COL1].dwWidth = COL_FILENAME_WIDTH  ;
    ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL1].pFunction = NULL;
    ResultHeader[COL1].pFunctionData = NULL;
    StringCopy( ResultHeader[COL1].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL1].szColumn,COL_FILENAME, MAX_STRING_LENGTH );


    // Forming the DisplayName header Column
    ResultHeader[COL2].dwWidth = COL_DISPLAYNAME_WIDTH  ;
    ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL2].pFunction = NULL;
    ResultHeader[COL2].pFunctionData = NULL;
    StringCopy( ResultHeader[COL2].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL2].szColumn,COL_DISPLAYNAME, MAX_STRING_LENGTH );


    // Forming the Description header Column
    ResultHeader[COL3].dwWidth = COL_DESCRIPTION_WIDTH;
    if(!bVerbose)
    {
        ResultHeader[COL3].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL3].pFunction = NULL;
    ResultHeader[COL3].pFunctionData = NULL;
    StringCopy( ResultHeader[COL3].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL3].szColumn,COL_DESCRIPTION, MAX_STRING_LENGTH );


    // Forming the Drivertype header Column

    ResultHeader[COL4].dwWidth = COL_DRIVERTYPE_WIDTH  ;
    ResultHeader[COL4].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL4].pFunction = NULL;
    ResultHeader[COL4].pFunctionData = NULL;
    StringCopy( ResultHeader[COL4].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL4].szColumn,COL_DRIVERTYPE, MAX_STRING_LENGTH );


    // Forming the StartMode header Column
    ResultHeader[COL5].dwWidth = COL_STARTMODE_WIDTH;
    if(!bVerbose)
    {
        ResultHeader[COL5].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL5].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL5].pFunction = NULL;
    ResultHeader[COL5].pFunctionData = NULL;
    StringCopy( ResultHeader[COL5].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL5].szColumn,COL_STARTMODE, MAX_STRING_LENGTH );


    // Forming the State header Column
    ResultHeader[COL6].dwWidth = COL_STATE_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL6].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL6].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL6].pFunction = NULL;
    ResultHeader[COL6].pFunctionData = NULL;
    StringCopy( ResultHeader[COL6].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL6].szColumn,COL_STATE, MAX_STRING_LENGTH );

    // Forming the Status header Column
    ResultHeader[COL7].dwWidth = COL_STATUS_WIDTH;
    if(!bVerbose)
    {
        ResultHeader[COL7].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL7].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL7].pFunction = NULL;
    ResultHeader[COL7].pFunctionData = NULL;
    StringCopy( ResultHeader[COL7].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL7].szColumn,COL_STATUS, MAX_STRING_LENGTH );

    // Forming the AcceptStop header Column
    ResultHeader[COL8].dwWidth = COL_ACCEPTSTOP_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL8].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL8].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL8].pFunction = NULL;
    ResultHeader[COL8].pFunctionData = NULL;
    StringCopy( ResultHeader[COL8].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL8].szColumn,COL_ACCEPTSTOP, MAX_STRING_LENGTH );

    // Forming the AcceptPause header Column
    ResultHeader[COL9].dwWidth = COL_ACCEPTPAUSE_WIDTH;
    if(!bVerbose)
    {
        ResultHeader[COL9].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL9].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL9].pFunction = NULL;
    ResultHeader[COL9].pFunctionData = NULL;
    StringCopy( ResultHeader[COL9].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL9].szColumn,COL_ACCEPTPAUSE, MAX_STRING_LENGTH );

    // Forming the PagedPool header Column
    ResultHeader[COL10].dwWidth = COL_PAGEDPOOL_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL10].dwFlags =  SR_TYPE_STRING|SR_HIDECOLUMN ;
    }
    else
    {
        ResultHeader[COL10].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL10].pFunction = NULL;
    ResultHeader[COL10].pFunctionData = NULL;
    StringCopy( ResultHeader[COL10].szFormat, NULL_STRING, 65 );
    StringCopy(ResultHeader[COL10].szColumn,COL_PAGEDPOOL, MAX_STRING_LENGTH) ;



    // Forming the Executable Code header Column
    ResultHeader[COL11].dwWidth = COL_EXECCODE_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL11].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN ;
    }
    else
    {
        ResultHeader[COL11].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL11].pFunction = NULL;
    ResultHeader[COL11].pFunctionData = NULL;
    StringCopy( ResultHeader[COL11].szFormat, NULL_STRING, 65 );
    StringCopy(ResultHeader[COL11].szColumn ,COL_EXECCODE, MAX_STRING_LENGTH) ;


    // Forming the BlockStorage Segment header Column
    ResultHeader[COL12].dwWidth = COL_BSS_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL12].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL12].dwFlags =  SR_TYPE_STRING ;
    }
    ResultHeader[COL12].pFunction = NULL;
    ResultHeader[COL12].pFunctionData = NULL;
    StringCopy( ResultHeader[COL12].szFormat, NULL_STRING, 65 );
    StringCopy(ResultHeader[COL12].szColumn ,COL_BSS, MAX_STRING_LENGTH );

    // Forming the LinkDate header Column
    ResultHeader[COL13].dwWidth = COL_LINKDATE_WIDTH;
    ResultHeader[COL13].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL13].pFunction = NULL;
    ResultHeader[COL13].pFunctionData = NULL;
    StringCopy( ResultHeader[COL13].szFormat, NULL_STRING, 65 );
    StringCopy( ResultHeader[COL13].szColumn,COL_LINKDATE, MAX_STRING_LENGTH );

    // Forming the Location header Column
    ResultHeader[COL14].dwWidth = COL_LOCATION_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL14].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL14].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL14].pFunction = NULL;
    ResultHeader[COL14].pFunctionData = NULL;
    StringCopy( ResultHeader[COL14].szFormat, NULL_STRING, 65 );
    StringCopy(ResultHeader[COL14].szColumn,COL_LOCATION, MAX_STRING_LENGTH);

    // Forming the Init Code header Column
    ResultHeader[COL15].dwWidth = COL_INITSIZE_WIDTH  ;
    if(!bVerbose)
    {
        ResultHeader[COL15].dwFlags = SR_TYPE_STRING|SR_HIDECOLUMN;
    }
    else
    {
        ResultHeader[COL15].dwFlags = SR_TYPE_STRING;
    }
    ResultHeader[COL15].pFunction = NULL;
    ResultHeader[COL15].pFunctionData = NULL;
    StringCopy( ResultHeader[COL15].szFormat, NULL_STRING, 65 );
    StringCopy(ResultHeader[COL15].szColumn,COL_INITSIZE, MAX_STRING_LENGTH);
}


#ifndef _WIN64

/*-------------------------------------------------------------------------*
 // IsWin64
 //
 //  Arguments                      :
 //      none
 // Returns true if we're running on Win64, false otherwise.
 *--------------------------------------------------------------------------*/

BOOL IsWin64(void)
{
#ifdef UNICODE

    // get a pointer to kernel32!GetSystemWow64Directory

    HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));

    if (hmod == NULL)
        return (FALSE);

    UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
    (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

    if (pfnGetSystemWow64Directory == NULL)
        return (FALSE);

    /*
     * if GetSystemWow64Directory fails and sets the last error to
     * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
     */
    TCHAR szWow64Dir[MAX_PATH];

    if (((pfnGetSystemWow64Directory)(szWow64Dir, countof(szWow64Dir)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
    {
        return (FALSE);
    }

    // we're on Win64

    return (TRUE);
#else
    // non-Unicode platforms cannot be Win64

    return (FALSE);
#endif  // UNICODE
}

#endif // _WIN64


BOOL
FormatAccToLocale( 
                   OUT NUMBERFMT  *pNumberFmt,
                   OUT LPTSTR* pszGroupSep,
                   OUT LPTSTR* pszDecimalSep,
                   OUT LPTSTR* pszGroupThousSep
                 )
/*++
  Routine Description:
       Formats the Number to the locale with thousands position

  Arguments:
    NUMBERFMT  *pNumberFmt[in]  - NUMBERFMT Structure to  be filled with .

  Return Value:
    VOID
--*/
{

    TCHAR   szFormatedString[MAX_RES_STRING + 1] = NULL_STRING;

    HRESULT hResult = 0;
    DWORD   dwLocale = 0;

    if( GetInfo( LOCALE_SGROUPING, pszGroupSep ) == FALSE)
    {
        pNumberFmt = NULL;
        return FALSE ;
    }
    if( GetInfo( LOCALE_SDECIMAL, pszDecimalSep ) == FALSE)
    {
        pNumberFmt = NULL;
        return FALSE ;
    }
    if( GetInfo( LOCALE_STHOUSAND, pszGroupThousSep ) == FALSE)
    {
        pNumberFmt = NULL;
        return FALSE ;
    }

    if(pNumberFmt != NULL)
    {
        pNumberFmt->LeadingZero = 0;
        pNumberFmt->NegativeOrder = 0;
        pNumberFmt->NumDigits = 0;

        if(StringCompare(*pszGroupSep, GROUP_FORMAT_32, TRUE, 0) == 0)
        {
            pNumberFmt->Grouping = GROUP_32_VALUE;
        }
        else
        {
            pNumberFmt->Grouping = UINT( _ttoi( *pszGroupSep ) );
        }
        pNumberFmt->lpDecimalSep = *pszDecimalSep;
        pNumberFmt->lpThousandSep = *pszGroupThousSep;
    }

    return TRUE ;
}

BOOL 
GetInfo( 
        IN LCTYPE lctype, 
        OUT LPTSTR* pszData 
        )
/*++

  Routine Description:

  Gets the Locale information

  Arguments:

    [ in  ] lctype   -- Locale Information to get
    [ out ] pszData  -- Locale value corresponding to the given information

  Return Value:
      BOOL
--*/
{
    LONG lSize = 0;

 // get the locale specific info
 lSize = GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, NULL, 0 );
 if ( lSize != 0 )
 {

    *pszData = (LPTSTR)AllocateMemory((lSize + 1)*sizeof(TCHAR));
  if ( *pszData != NULL )
  {
   // get the locale specific time seperator
    GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, *pszData, lSize );
    return TRUE;
  }
 }
 return FALSE;
}//end of GetInfo


DWORD 
GetSystemType(
              IN COAUTHIDENTITY* pAuthIdentity,
              IN IWbemServices* pIWbemServReg
             )
/*++

  Routine Description:

  Gets the type os the specified System ( 32 bit or 64 bit)

  Arguments:

    IWbemLocator *pLocator[in] -- Pointer to the locator interface.
    _bstr_t bstrServer[in]     -- Server Name
    _bstr_t bstrUserName[in]   -- User Name
    _bstr_t bstrPassword [in]  -- Password information

  Return Value:
      DWORD : SYSTEM_32_BIT    -- If the system is 32 bit system.
              SYSTEM_64_BIT    -- If the system is 32 bit system.
              ERROR_WMI_VALUES -- If error occured while retreiving values from WMI.
--*/
{

    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInInst = NULL;
    VARIANT varConnectName;
    VARIANT varSvalue ;
    VARIANT varHkey;
    VARIANT varVaue ;
    VARIANT varRetVal ;

    HRESULT hRes = S_OK;
    LPTSTR szSysName = NULL ;
    CHString      szSystemName ;
    DWORD dwSysType = 0 ;


    VariantInit(&varConnectName) ;
    VariantInit(&varSvalue) ;
    VariantInit(&varHkey) ;
    VariantInit(&varVaue) ;
    VariantInit(&varRetVal) ;
    
    
    try
    {
        hRes = pIWbemServReg->GetObject(bstr_t(STD_REG_CLASS), 0, NULL, &pClass, NULL);
        ONFAILTHROWERROR(hRes);
        if(hRes != WBEM_S_NO_ERROR)
        {
            hRes = FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }

        // Get the input argument and set the property
        hRes = pClass->GetMethod(_bstr_t(PROPERTY_GETSTRINGVAL), 0, &pInClass, NULL);
        ONFAILTHROWERROR(hRes);
        if(hRes != WBEM_S_NO_ERROR)
        {
            FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }

        hRes = pInClass->SpawnInstance(0, &pInInst);
        ONFAILTHROWERROR(hRes);
        if(hRes != WBEM_S_NO_ERROR)
        {
            FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }


        //the registry path to get the connection name

        varConnectName.vt = VT_BSTR;
        varConnectName.bstrVal= SysAllocString(REG_PATH);
        hRes = pInInst->Put(REG_SUB_KEY_VALUE, 0, &varConnectName, 0);
        ONFAILTHROWERROR(hRes);

        //set the svalue name
        varSvalue.vt = VT_BSTR;
        varSvalue.bstrVal= SysAllocString(REG_SVALUE);
        hRes = pInInst->Put(REG_VALUE_NAME, 0, &varSvalue, 0);
        ONFAILTHROWERROR(hRes);

        varHkey.vt = VT_I4 ;
        varHkey.lVal = HEF_KEY_VALUE;
        hRes = pInInst->Put(HKEY_VALUE, 0, &varHkey, 0);
        ONFAILTHROWERROR(hRes);
        // Call the method
        hRes = pIWbemServReg->ExecMethod(_bstr_t(STD_REG_CLASS), _bstr_t(REG_METHOD), 0, NULL, pInInst, &pOutInst, NULL);
        ONFAILTHROWERROR(hRes);

        if(pOutInst == NULL)
        {
            FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }

        hRes = pOutInst->Get(PROPERTY_RETURNVAL,0,&varRetVal,NULL,NULL);
        ONFAILTHROWERROR(hRes);

        if(varRetVal.lVal != 0)
        {
            FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }

        hRes = pOutInst->Get(REG_RETURN_VALUE,0,&varVaue,NULL,NULL);
        ONFAILTHROWERROR(hRes);
        if(hRes != WBEM_S_NO_ERROR)
        {
            FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
            return (ERROR_WMI_VALUES);
        }
    }
    catch(_com_error& e)
    {
        ShowMessage(stderr,ERROR_GET_VALUE);
        FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
        return (ERROR_WMI_VALUES);
    }

    szSystemName =  V_BSTR(&varVaue);

    szSysName = (LPTSTR)AllocateMemory((MAX_RES_STRING)*sizeof(TCHAR));

    if(szSysName == NULL)
    {
        FreeMemoryAll(pInClass,pClass,pOutInst,pInInst,pIWbemServReg,&varConnectName,&varSvalue,&varHkey,&varRetVal,&varVaue,szSysName );
        return (ERROR_WMI_VALUES);
    }

    GetCompatibleStringFromUnicode( szSystemName, szSysName, StringLengthW( szSystemName, 0 )+2 );

    dwSysType = FindString(szSysName,X86_MACHINE, 0) ? SYSTEM_32_BIT:SYSTEM_64_BIT  ;

    FreeMemoryAll(pInClass, pClass, pOutInst, pInInst, pIWbemServReg, &varConnectName, &varSvalue, &varHkey, &varRetVal, &varVaue, szSysName );
    return (dwSysType);

}

BOOL 
InitialiseCom(
              IN IWbemLocator** ppIWbemLocator
             )
/*++

  Routine Description:

  Gets the type os the specified System ( 32 bit or 64 bit)
 
  Arguments:

    IWbemLocator** pLocator[in] -- Pointer to the locator interface.

  Return Value:
      BOOL : TRUE  on Successfully initialising COM.
             FALSE on Failure to initialise COM.
--*/

{

    HRESULT hRes = S_OK ;

    try
    {
        // To initialize the COM library.
        hRes = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED );
        ONFAILTHROWERROR(hRes);


        // Initialize COM security for DCOM services, Adjust security to
        // allow client impersonation

        hRes =  CoInitializeSecurity( NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL,
                                EOAC_NONE, 0 );

        ONFAILTHROWERROR(hRes);

        // get a pointer to the Interface IWbemLocator
        hRes = CoCreateInstance(CLSID_WbemLocator, NULL,
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) ppIWbemLocator);
        ONFAILTHROWERROR(hRes);

    }
    catch(_com_error& e )
    {
        GetWbemErrorText( e.Error() );
        ShowMessage( stderr, ERROR_TAG  );
        ShowMessage( stderr, GetReason() );
        return( FALSE );
    }

    // if successfully initialised COM then return true
    return TRUE ;
}

HRESULT 
PropertyGet( 
            IN IWbemClassObject* pWmiObject,
            IN LPCTSTR pszInputVal,
            OUT CHString &szOutPutVal
           )
/*++

  Routine Description:
             This routine extract the value of the property into szOutputVal from given wmi class object

  Arguments:

    [ in ]  pWmiObject -- Pointer to the locator interface.
    [ in ]  pszInputVal -- Input string containing the desired value.
    [ in ]  szOutPutVal-- String containing the retreived value.

  Return Value:
      BOOL : TRUE  on Successfully initialising COM.
             FALSE on Failure to initialise COM.

--*/
{

    HRESULT hRes = S_FALSE ;
    VARIANT vtValue ;
    VariantInit(&vtValue);
    hRes = pWmiObject->Get(pszInputVal,0,&vtValue,NULL,NULL);

    if (hRes != WBEM_S_NO_ERROR)
    {
        hRes = VariantClear(&vtValue);
        return (hRes);
    }
    if ((hRes == WBEM_S_NO_ERROR)&&(vtValue.vt != VT_NULL) && (vtValue.vt != VT_EMPTY))
    {
        szOutPutVal = (LPCWSTR)_bstr_t(vtValue);
    }

    hRes = VariantClear(&vtValue);
    if(hRes != S_OK)
    {
        return hRes ;
    }
    return TRUE ;


}


HRESULT 
FreeMemoryAll(
             IN IWbemClassObject *pInClass,
             IN IWbemClassObject * pClass,
             IN IWbemClassObject * pOutInst ,
             IN IWbemClassObject * pInInst,
             IN IWbemServices *pIWbemServReg,
             IN VARIANT *varConnectName,
             IN VARIANT *varSvalue,
             IN VARIANT *varHkey,
             IN VARIANT *varRetVal,
             IN VARIANT *varVaue,
             IN LPTSTR szSysName 
             )
/*++
 Routine Description:
      This function frees the memory allocated in the function.

 Arguments:
      [ in ] pInClass            - Interface ptr pointing to the IWbemClassObject interface
      [ in ] pClass              - Interface ptr pointing to the IWbemClassObject interface
      [ in ] pOutInst            - Interface ptr pointing to the IWbemClassObject interface
      [ in ] pInInst             - Interface ptr pointing to the IWbemClassObject interface
      [ in ] pIWbemServReg       - Interface ptr pointing to the IWbemServices interface
      [ in ] varConnectName      - variant to be cleared 
      [ in ] varSvalue           - variant to be cleared
      [ in ] varHkey             - variant to be cleared
      [ in ] varRetVal           - variant to be cleared
      [ in ] varVaue             - variant to be cleared
      [ in ] szSysName           - LPTSTR varaible containing the system name.

 Return Value:
      None
--*/
{

    HRESULT hRes = S_OK ;
    SAFEIRELEASE(pInInst);
    SAFEIRELEASE(pInClass);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pIWbemServReg);
    FreeMemory((LPVOID *) &szSysName);
    hRes = VariantClear(varConnectName);
    if(hRes != S_OK)
    {
        return hRes ;
    }
    hRes = VariantClear(varSvalue);
    if(hRes != S_OK)
    {
        return hRes ;
    }
    hRes = VariantClear(varHkey);
    if(hRes != S_OK)
    {
        return hRes ;
    }
    hRes = VariantClear(varVaue);
    if(hRes != S_OK)
    {
        return hRes ;
    }
    hRes = VariantClear(varRetVal);
    if(hRes != S_OK)
    {
        return hRes ;
    }

    return S_OK ;
}

HRESULT 
PropertyGet_Bool(
                 IN  IWbemClassObject* pWmiObject, 
                 IN  LPCTSTR pszInputVal, 
                 OUT PBOOL pIsSigned
                )
/*++

  Routine Description:
            This routine will get the property of boolean type from the class object 

  Arguments:

    [ in ]  pWmiObject[in]   -- Pointer to the locator interface.
    [ in ]  pszInputVal[in]  -- Input string containing the desired value.
    [ in ]  pIsSigned[out]   -- String containing the retreived value.

  Return Value:
      HRESULT : hRes  on Successfully retreiving the value.
                S_FALSE on Failure in retreiving the value.
--*/
{

    HRESULT hRes = S_FALSE ;
    VARIANT vtValue ;
    VariantInit(&vtValue);
    hRes = pWmiObject->Get(pszInputVal,0,&vtValue,NULL,NULL);

    if (hRes != WBEM_S_NO_ERROR)
    {
        hRes = VariantClear(&vtValue);
        return (hRes);
    }
    if ((hRes == WBEM_S_NO_ERROR)&&(vtValue.vt != VT_NULL) && (vtValue.vt != VT_EMPTY))
    {
        if(vtValue.vt == VT_BOOL)
            if(vtValue.boolVal == -1)
                *pIsSigned = 1;
            else
                *pIsSigned = 0;

        hRes = VariantClear(&vtValue);
        if(hRes != S_OK)
        {
            return hRes ;
        }

        return hRes ;
    }
    else if ((hRes == WBEM_S_NO_ERROR)&&(vtValue.vt == VT_NULL) ) 
    {
        *pIsSigned = FALSE;
    }

    hRes = VariantClear(&vtValue);
    return S_FALSE ;

}

VOID 
FormSignedHeader(
                 IN DWORD dwFormatType,
                 IN BOOL bHeader,
                 OUT TCOLUMNS *ResultHeader)
/*++
 Routine Description:
      This function is used to build the header and also display the
       result in the required format as specified by  the user.

 Arguments:
      [ in  ] dwFormatType   : format flags
      [ in  ] bHeader        : Boolean for specifying if the header is required or not.
      [ out ] ResultHeader   : The result header of tcolumns.

 Return Value:
      none
--*/
{

    // Device name
    ResultHeader[COL0].dwWidth = COL_DEVICE_WIDTH ;
    ResultHeader[COL0].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL0].pFunction = NULL;
    ResultHeader[COL0].pFunctionData = NULL;
    STRING_COPY_STATIC( ResultHeader[COL0].szFormat, NULL_STRING );
    STRING_COPY_STATIC( ResultHeader[COL0].szColumn,COL_DEVICENAME );


    //Inf header
    ResultHeader[COL1].dwWidth = COL_INF_WIDTH  ;
    ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL1].pFunction = NULL;
    ResultHeader[COL1].pFunctionData = NULL;
    STRING_COPY_STATIC( ResultHeader[COL1].szFormat, NULL_STRING );
    STRING_COPY_STATIC( ResultHeader[COL1].szColumn,COL_INF_NAME);


    // Forming the IsSigned header Column
    ResultHeader[COL2].dwWidth = COL_ISSIGNED_WIDTH  ;
    ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL2].pFunction = NULL;
    ResultHeader[COL2].pFunctionData = NULL;
    STRING_COPY_STATIC( ResultHeader[COL2].szFormat, NULL_STRING );
    STRING_COPY_STATIC( ResultHeader[COL2].szColumn,COL_ISSIGNED);


    // Forming the Manufacturer header Column
    ResultHeader[COL3].dwWidth = COL_MANUFACTURER_WIDTH  ;
    ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL3].pFunction = NULL;
    ResultHeader[COL3].pFunctionData = NULL;
    STRING_COPY_STATIC( ResultHeader[COL3].szFormat, NULL_STRING );
    STRING_COPY_STATIC( ResultHeader[COL3].szColumn,COL_MANUFACTURER);
}

LCID 
GetSupportedUserLocale( 
                       OUT BOOL& bLocaleChanged 
                      )
/*++
 Routine Description: This function checks if the current locale is supported or not.

 Arguments: 
       [ out ] bLocaleChanged : returns back if the current locale is supported or not.

 Return Value: LCID of the current locale.
--*/
{
    // local variables
    LCID lcid;

    // get the current locale
    lcid = GetUserDefaultLCID();

    // check whether the current locale is supported by our tool or not
    // if not change the locale to the english which is our default locale
    bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
        bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

    // return the locale
    return lcid;
}

DWORD 
ProcessSignedDriverInfo(
                       IN CHString szHost, 
                       IN IEnumWbemClassObject *pSystemSet,
                       IN LPTSTR szFormat,
                       IN BOOL bNoHeader,
                       IN DWORD dwSystemType,
                       IN BOOL bVerbose
                      )
/*++
 Routine Description:
      Processes enumeration of Win32_PnpSignedDriver instances

 Arguments:
      [ in ]  szHost                  : HostName to connect to
      [ in ]  pSystemSet              : pointer to the structure containing system properties.
      [ in ]  szFormat                : specifies the format
      [ in ]  bHeader                 : specifies if the header is required or not.

 Return Value:
       0   no error
       1   error occured while allocating memory.
-*/
{
    HRESULT hRes = S_OK;
    ULONG ulReturned = 1;
    DWORD dwCount = 0;

    //declaration  of normal variables
    IWbemClassObject* pDriverObjects[ MAX_ENUM_DRIVERS ];

    CHString szPnpDeviceName ;
    CHString szPnpInfName ;
    CHString szPnpMfg ;
    CHString szSigned ;

    BOOL bIsSigned = FALSE;

    TCOLUMNS ResultHeader[ MAX_SIGNED_COLUMNS ];
    TARRAY arrResults = NULL;
    DWORD dwRow = 0;
    DWORD dwFormatType = SR_FORMAT_TABLE ;

    BOOL bHasNewResults = FALSE ;

    // Create new Dynamic Array to hold the result
    arrResults = CreateDynamicArray();
    if(arrResults == NULL)
    {
        return EXIT_FAILURE_MALLOC ;
    }

    // determine the format of the output
    if( StringCompare(szFormat,TABLE_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_TABLE;
    }
    else if( StringCompare(szFormat,LIST_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_LIST;
    }
    else if( StringCompare(szFormat,CSV_FORMAT, TRUE, 0) == 0 )
    {
        dwFormatType = SR_FORMAT_CSV;
    }

    // prepare the header structure
    FormSignedHeader(dwFormatType,bNoHeader,ResultHeader);


    // determine whether to show the header row or not
    if ( bNoHeader == TRUE )
    {
        dwFormatType |= SR_NOHEADER;
    }

    // initialize all the objects to NULL
    for(DWORD dw = 0 ;dw< MAX_ENUM_DRIVERS;dw++ )
    {
        pDriverObjects[ dw ] = NULL;
    }

    // loop till there are results.
    bHasNewResults = FALSE;
    while ( ulReturned > 0 )
    {
        // loop thru the object list and release them
        for( DWORD dw = 0; dw < MAX_ENUM_DRIVERS; dw++ )
        {
            SAFEIRELEASE( pDriverObjects[ dw ] );
        }

        // delete all the information in the data array
        szPnpDeviceName = NO_DATA_AVAILABLE;
        szPnpInfName = NO_DATA_AVAILABLE;
        szSigned = NO_DATA_AVAILABLE ;
        szPnpMfg = NO_DATA_AVAILABLE ;

        // Enumerate through the resultset.
        hRes = pSystemSet->Next(WBEM_INFINITE,
                                MAX_ENUM_DRIVERS,               // return just one system
                                pDriverObjects,     // pointer to system
                                &ulReturned );  // number obtained: one or zero

        // update the count of records we retrived so far
        dwCount++;

        if ( SUCCEEDED( hRes ) )
        {
            for(ULONG ul=0;ul< ulReturned;ul++)
            {
                // initialise the variant variables to empty
                //create a new empty row with required no of  columns
                dwRow = DynArrayAppendRow(arrResults,MAX_COLUMNS) ;

                try
                {
                    hRes = PropertyGet(pDriverObjects[ul],PROPERTY_PNP_DEVICENAME,szPnpDeviceName);
                    ONFAILTHROWERROR(hRes);
                    hRes = PropertyGet(pDriverObjects[ul],PROPERTY_PNP_INFNAME,szPnpInfName);
                    ONFAILTHROWERROR(hRes);
                    hRes = PropertyGet_Bool(pDriverObjects[ul],PROPERTY_PNP_ISSIGNED,&bIsSigned);
                    ONFAILTHROWERROR(hRes);
                    hRes = PropertyGet(pDriverObjects[ul],PROPERTY_PNP_MFG,szPnpMfg);
                    ONFAILTHROWERROR(hRes);

                }
                catch(_com_error)
                {
                    ShowMessage(stderr,ERROR_GET_VALUE);
                    SAFEIRELEASE(pDriverObjects[ul]);
                    return FAILURE;
                }

                // free the allocated memory
                SAFEIRELEASE(pDriverObjects[ul]);

                if(bIsSigned)
                {
                    szSigned = TRUE_VALUE;
                }
                else
                {
                    szSigned = FALSE_VALUE;
                }

                DynArraySetString2( arrResults,dwRow,COL0,szPnpDeviceName,0 );
                DynArraySetString2( arrResults,dwRow,COL1,szPnpInfName,0 );
                DynArraySetString2( arrResults,dwRow,COL2,szSigned,0 );
                DynArraySetString2( arrResults,dwRow,COL3,szPnpMfg,0 );

                //display one blank line for first time
                if( FALSE == bHasNewResults && (dwFormatType & SR_FORMAT_MASK) != SR_FORMAT_CSV)
                {
                    ShowMessage(stdout, L"\n" );
                }

                // this flag is to check if there are any results
                // else display an error message.
                bHasNewResults = TRUE ;
                
                // delete all the information in the data array
                szPnpDeviceName = NO_DATA_AVAILABLE;
                szPnpInfName = NO_DATA_AVAILABLE;
                szSigned = NO_DATA_AVAILABLE ;
                szPnpMfg = NO_DATA_AVAILABLE ;
            }

            //display results
            if( TRUE == bHasNewResults )
            {
                // show the results enumerated in this loop
                ShowResults( MAX_SIGNED_COLUMNS, ResultHeader, dwFormatType, arrResults );

                // clear the reuslts that we enumerated so far
                DynArrayRemoveAll( arrResults );

                // from next time onwards, we should not display the columns header
                dwFormatType |= SR_NOHEADER;

                if ( (dwFormatType | SR_FORMAT_LIST) == (SR_NOHEADER | SR_FORMAT_LIST) )
                {
                    bHasNewResults = FALSE;
                }
            }
        }
        else
        {
            if( 0x80041010 == hRes )
            {
                ShowMessage( stderr, GetResString(IDS_VERSION_MISMATCH_ERROR) );
                DestroyDynamicArray( &arrResults );
                return VERSION_MISMATCH_ERROR;
            }
            else
            {
                WMISaveError( hRes );
                ShowLastErrorEx( stderr, SLE_INTERNAL | SLE_TYPE_ERROR );
                DestroyDynamicArray( &arrResults );
                return VERSION_MISMATCH_ERROR;
            }        
        }
    }

    if (dwCount == 0)
    {
        ShowMessage(stderr,GetResString(IDS_VERSION_MISMATCH_ERROR));

        // free the allocated memory
        for(DWORD dw = 0 ;dw< MAX_ENUM_DRIVERS;dw++ )
        {
            SAFEIRELEASE(pDriverObjects[dw]);
        }
        return VERSION_MISMATCH_ERROR ;
    }

    DestroyDynamicArray( &arrResults );
    return SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\driverquery\pch.h ===
// *********************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//    pch.h
//
//  Abstract:
//
//    This module contains all necessary header files required by DriverQuery.cpp module.
//
//
//  Author:
//
//    J.S.Vasu   31-Oct-2000
//
//  Revision History:
//   Created  on 31-0ct-2000 by J.S.Vasu
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>

#ifndef _WIN64
    #include <Wow64t.h>
#endif

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <crtdbg.h>


//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\driverquery\resource.h ===
#define IDS_ERROR_USERNAME_BUT_NOMACHINE        101
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME       102
#define IDS_ERROR_COM_INTIALIZE                 103
#define IDS_ERROR_COM_SECURITY_INITIALIZE       104
#define IDS_ERROR_COM_ENUMERATE_INSTANCE        105
#define IDS_ERROR_CONNECT                       106
#define IDS_INVALID_SYNTAX                      107
#define IDS_ERROR_RETREIVE_INFO                 108
#define IDS_WMI_CREDENTIALS                     109
#define IDS_INVALID_CREDENTIALS                 110
#define IDS_ERROR_INVALID_FORMAT                111
#define IDS_ALLOC_FAILURE                       112
#define IDS_ERROR_AUTHENTICATION_FAILURE        113
#define IDS_ERROR_LOCAL_CRED                    114
#define IDS_ERROR_WMI_FAILURE                   115
#define IDS_INVALID_SIGNED_SYNTAX               116
#define IDS_ERROR_GET                           117
#define IDS_NO_HEADERS                          118
#define IDS_INVALID_SERVER                      119
#define IDS_INVALID_USER                        120

#define IDS_IGNORE_LOCAL_CRED                   151

#define IDS_DRIVER_TAG                          201
#define IDS_ERROR_TAG                           202
#define IDS_WARNING_TAG                         203
#define IDS_INPUT_PASSWORD                      204

#define IDS_NO_DRIVERS_FOUND                    251

#define IDS_FORMAT_LIST                         301
#define IDS_FORMAT_TABLE                        302
#define IDS_FORMAT_CSV                          303


#define IDS_COL_HOSTNAME                        351
#define IDS_COL_FILENAME                        352
#define IDS_COL_SIGNED                          353
#define IDS_COL_DISPLAYNAME                     354
#define IDS_COL_DESCRIPTION                     355
#define IDS_COL_DRIVERTYPE                      356
#define IDS_COL_STARTMODE                       357
#define IDS_COL_STATE                           358
#define IDS_COL_STATUS                          359
#define IDS_COL_ACCEPTSTOP                      360
#define IDS_COL_ACCEPTPAUSE                     361
#define IDS_COL_MEMORYUSAGE                     362
#define IDS_COL_PAGEDPOOL                       363
#define IDS_COL_NONPAGEDPOOL                    364
#define IDS_COL_EXECCODE                        365
#define IDS_COL_NBSS                            366
#define IDS_COL_BSS                             367
#define IDS_COL_LINKDATE                        368
#define IDS_COL_INITSIZE                        369
#define IDS_COL_PAGESIZE                        370
#define IDS_COL_LOCATION                        371
#define IDS_COL_DEVICENAME                      372
#define IDS_COL_INF_NAME                        373
#define IDS_COL_ISSIGNED                        374
#define IDS_COL_MANUFACTURER                    375

#define IDS_COL_HOSTNAME_SIZE                   401
#define IDS_COL_FILENAME_SIZE                   402
#define IDS_SIGNED_SIZE                         403
#define IDS_COL_DISPLAYNAME_SIZE                404
#define IDS_COL_DESCRIPTION_SIZE                405
#define IDS_COL_DRIVERTYPE_SIZE                 406
#define IDS_COL_STARTMODE_SIZE                  407
#define IDS_COL_STATE_SIZE                      408
#define IDS_COL_STATUS_SIZE                     409
#define IDS_COL_ACCEPTSTOP_SIZE                 410
#define IDS_COL_ACCEPTPAUSE_SIZE                411
#define IDS_COL_MEMORYUSAGE_SIZE                412
#define IDS_COL_PAGEDPOOL_SIZE                  413
#define IDS_COL_NONPAGEDPOOL_SIZE               414
#define IDS_COL_EXECCODE_SIZE                   415
#define IDS_COL_NBSS_SIZE                       416
#define IDS_COL_BSS_SIZE                        417
#define IDS_COL_LINKDATE_SIZE                   418
#define IDS_COL_LOCATION_SIZE                   419
#define IDS_COL_INITSIZE_SIZE                   420
#define IDS_COL_PAGESIZE_SIZE                   421
#define IDS_COL_DEVICE_WIDTH                    422
#define IDS_COL_INF_WIDTH                       423
#define IDS_COL_ISSIGNED_WIDTH                  424
#define IDS_COL_MANUFACTURER_WIDTH              425
#define IDS_MORE_INSTANCES_SIGNEDDRIVERS        426

#define IDS_USAGEBEGIN1                         501
#define IDS_STRING81                            502
#define IDS_STRING82                            503
#define IDS_STRING83                            504
#define IDS_STRING84                            505
#define IDS_STRING85                            506
#define IDS_STRING86                            507
#define IDS_STRING87                            508
#define IDS_STRING88                            509
#define IDS_STRING89                            510
#define IDS_STRING90                            511
#define IDS_STRING91                            512
#define IDS_STRING92                            513
#define IDS_STRING93                            514
#define IDS_STRING94                            515
#define IDS_STRING95                            516
#define IDS_STRING96                            517
#define IDS_STRING97                            518
#define IDS_STRING98                            519
#define IDS_STRING99                            520
#define IDS_STRING100                           521
#define IDS_STRING101                           522
#define IDS_STRING102                           523
#define IDS_STRING103                           524
#define IDS_STRING104                           525
#define IDS_STRING105                           526
#define IDS_USAGEEND1                           527

#define IDS_VERSION_MISMATCH_ERROR              530
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\doskey\doskey.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        doskey.cxx

Abstract:

        Edits command lines, recalls Windows 2000 commands, and creates macros.

Author:

        Norbert P. Kusters (norbertk) 02-April-1992

Revision History:

--*/

#include "ulib.hxx"
#include "error.hxx"

#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "filestrm.hxx"
#include "system.hxx"
#include "file.hxx"

#include "ulibcl.hxx"

extern "C" {
#include "conapi.h"
#include <ctype.h>
#ifdef FE_SB // isspace patch
// isspace() causes access violation when x is Unicode char
// that is not included in ASCII charset.
#define isspace(x)     ( (x) == ' ' ) ? TRUE : FALSE
#endif
};

VOID
StripQuotesFromString(
    IN  PWSTRING String
    )
/*++

Routine Description:

    This routine removes leading and trailing quote marks (if
    present) from a quoted string.  If the string is not a quoted
    string, it is left unchanged.

--*/
{
    if( String->QueryChCount() >= 2    &&
        String->QueryChAt( 0 ) == '\"' &&
        String->QueryChAt( String->QueryChCount() - 1 ) == '\"' ) {

        String->DeleteChAt( String->QueryChCount() - 1 );
        String->DeleteChAt( 0 );
    }
}


BOOLEAN
DisplayPackedString(
    IN      PCWSTR      PackedStrings,
    IN      ULONG       PackedStringsLength,
    IN      BOOLEAN     IndentStrings,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine outputs the given strings.  One line per string.

Arguments:

    PackedStrings       - Supplies the null-separated strings to output.
    PackedStringsLength - Supplies the number of characters in the strings.
    NumIndentSpaces     - Supplies whether or not to indent the strings.
    Message             - Supplies the outlet for the strings.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING display_string;
    DSTRING raw_string;
    ULONG   i;
    PCWSTR  p;

    p = PackedStrings;

    for (i = 0; i < PackedStringsLength; i++) {

        if (i > 0 && p[i - 1]) {
            continue;
        }

        if (IndentStrings) {

            if (!display_string.Initialize("    ")) {
                return FALSE;
            }
        } else {

            if (!display_string.Initialize("")) {
                return FALSE;
            }
        }


        if (!raw_string.Initialize(&p[i]) ||
            !display_string.Strcat(&raw_string)) {

            return FALSE;
        }

        Message->Set(MSG_ONE_STRING_NEWLINE);
        Message->Display("%W", &display_string);
    }

    return TRUE;
}


BOOLEAN
QuerySourceAndTarget(
    IN  PCWSTRING   MacroLine,
    OUT PWSTR*      Source,
    OUT PWSTR*      Target
    )
/*++

Routine Description:

    This routine computes the sources and target string from the given macro line
    by isolating the '=' and then making sure that the source is a single token.

Arguments:

    MacroLine   - Supplies the macro.
    Source      - Returns the source part of the macro.
    Target      - Returns the target part of the macro.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG    src_start, src_end, dst_start;
    ULONG   i, n;
    WCHAR   w;

    *Source = NULL;
    *Target = NULL;

    i = 0;
    n = MacroLine->QueryChCount();

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    src_start = i;

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (isspace(w) || w == '=') {
            break;
        }
    }

    src_end = i;

    if (src_start == src_end) {
        return FALSE;
    }

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    if (w != '=') {
        return FALSE;
    }

    i++;

    for (; i < n; i++) {
        w = MacroLine->QueryChAt(i);
        if (!isspace(w)) {
            break;
        }
    }

    dst_start = i;

    *Source = MacroLine->QueryWSTR(src_start, src_end - src_start);
    *Target = MacroLine->QueryWSTR(dst_start);

    if (!*Source || !*Target) {
        DELETE(*Source);
        DELETE(*Target);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
DisplayMacros(
    IN      PWSTR       TargetExe,
    IN      BOOLEAN     IndentString,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the macros for the given exe.

Arguments:

    TargetExe       - Supplies the exe for which to display the macros.
    IndentStrings   - Supplies whether or not to indent the macro strings.
    Message         - Supplies an outlet for the macro strings.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   buffer_length = 0;
    PWSTR   buffer;

    buffer_length = GetConsoleAliasesLength(TargetExe);
    if (!(buffer = (PWCHAR) MALLOC(buffer_length + 1))) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (buffer_length) {
        buffer_length = GetConsoleAliases(buffer, buffer_length, TargetExe);
    }

    if (!DisplayPackedString(buffer, buffer_length/sizeof(WCHAR),
                             IndentString, Message)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    FREE(buffer);

    return TRUE;
}


BOOLEAN
DisplayAllMacros(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays all of the macros for all of the exes which have macros
    defined for them.

Arguments:

    Message - Supplies an outlet for the macros.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   exes_buffer;
    ULONG   exes_length;
    ULONG   i;
    DSTRING exe_name;
    DSTRING display_name;

    exes_length = GetConsoleAliasExesLength();
    if (!(exes_buffer = (PWSTR) MALLOC(exes_length + 1))) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (exes_length) {
        exes_length = GetConsoleAliasExes(exes_buffer, exes_length);
    }

    exes_length /= sizeof(WCHAR);

    for (i = 0; i < exes_length; i++) {

        if (i > 0 && exes_buffer[i - 1]) {
            continue;
        }

        if (!exe_name.Initialize(&exes_buffer[i]) ||
            !display_name.Initialize("[") ||
            !display_name.Strcat(&exe_name) ||
            !exe_name.Initialize("]") ||
            !display_name.Strcat(&exe_name)) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        Message->Set(MSG_ONE_STRING_NEWLINE);
        Message->Display("%W", &display_name);

        if (!DisplayMacros(&exes_buffer[i], TRUE, Message)) {
            return FALSE;
        }

        Message->Set(MSG_BLANK_LINE);
        Message->Display();
    }

    return TRUE;
}


BOOLEAN
ReadInMacrosFromFile(
    IN      PPATH       FilePath,
    IN      PWSTR       TargetExe,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads in the macros in the given file.  The file must have the same
    format as the output from DOSKEY /macros or DOSKEY /macros:all.

Arguments:

    FilePath    - Supplies the file with the macros.
    TargetExe   - Supplies the exe for which the unclaimed macros are.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PFSN_FILE       file;
    PFILE_STREAM    file_stream;
    DSTRING         line;
    PWSTR           target_exe;
    DSTRING         target_string;
    PWSTR           source, target;

    if (!(file = SYSTEM::QueryFile(FilePath)) ||
        !(file_stream = file->QueryStream(READ_ACCESS))) {

        DELETE(file);

        Message->Set(MSG_ATTRIB_FILE_NOT_FOUND);
        Message->Display("%W", FilePath->GetPathString());
        return FALSE;
    }


    // Set up the target exe.

    if (!line.Initialize("") ||
        !target_string.Initialize(TargetExe) ||
        !(target_exe = target_string.QueryWSTR())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    while (!file_stream->IsAtEnd() && file_stream->ReadLine(&line)) {

        // First see if the current line will define a new exe name.

        if (!line.QueryChCount()) {
            continue;
        }

        if (line.QueryChAt(0) == '[' &&
            line.Strchr(']') != INVALID_CHNUM &&
            line.Strchr(']') > 1) {

            DELETE(target_exe);
            if (!target_string.Initialize(&line, 1, line.Strchr(']') - 1) ||
                !(target_exe = target_string.QueryWSTR())) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            continue;
        }


        if (!QuerySourceAndTarget(&line, &source, &target) ||
            !AddConsoleAlias(source, *target ? target : NULL, target_exe)) {

            Message->Set(MSG_DOSKEY_INVALID_MACRO_DEFINITION);
            Message->Display();

            continue;
        }
    }

    DELETE(file_stream);
    DELETE(file);

    return TRUE;
}

int __cdecl
main(
        )
/*++

Routine Description:

    This routine provides equivalent functionality to DOS 5's DOSKEY utility.

Arguments:

    None.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    STREAM_MESSAGE          msg;
    ARGUMENT_LEXEMIZER      arglex;
    ARRAY                   lex_array;
    ARRAY                   arg_array;
    STRING_ARGUMENT         progname;
    FLAG_ARGUMENT           help;
    FLAG_ARGUMENT           reinstall;
    LONG_ARGUMENT           bufsize;
    LONG_ARGUMENT           listsize;
    STRING_ARGUMENT         m_plus;
    FLAG_ARGUMENT           m;
    STRING_ARGUMENT         macros_plus;
    FLAG_ARGUMENT           macros;
    FLAG_ARGUMENT           history;
    FLAG_ARGUMENT           h;
    FLAG_ARGUMENT           insert;
    FLAG_ARGUMENT           overstrike;
    STRING_ARGUMENT         exename;
    PATH_ARGUMENT           filename;
    REST_OF_LINE_ARGUMENT   macro;
    PWSTRING                pwstring;
    PWSTR                   target_exe;
    PWSTR                   source, target;
    PWSTR                   buffer;
    ULONG                   buffer_length;
    DSTRING                 all_string;


    //
    // DOSKEY /INSERT | /OVERSTRIKE changes the keyboard mode
    // and we do not want the keyboard mode to be restored on exit
    //
    Get_Standard_Input_Stream()->DoNotRestoreConsoleMode();

    // Initialize the error stack and the stream message object.

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {

                return 1;
    }


    // Initialize the parsing machinery.

    if (!lex_array.Initialize() ||
        !arg_array.Initialize() ||
        !arglex.Initialize(&lex_array)) {

        return 1;
    }

    arglex.SetCaseSensitive(FALSE);
    arglex.PutStartQuotes( "\"" );
    arglex.PutEndQuotes( "\"" );
    arglex.PutSeparators( " \t" );


    // Tokenize the command line.

    if (!arglex.PrepareToParse()) {

        return 1;
    }


    // Initialize the argument patterns to be accepted.

    if (!progname.Initialize("*") ||
        !help.Initialize("/?") ||
        !reinstall.Initialize("/reinstall") ||
        !bufsize.Initialize("/bufsize=*") ||
        !listsize.Initialize("/listsize=*") ||
        !macros_plus.Initialize("/macros:*") ||
        !m_plus.Initialize("/m:*") ||
        !macros.Initialize("/macros") ||
        !m.Initialize("/m") ||
        !history.Initialize("/history") ||
        !h.Initialize("/h") ||
        !insert.Initialize("/insert") ||
        !overstrike.Initialize("/overstrike") ||
        !exename.Initialize("/exename=*") ||
        !filename.Initialize("/macrofile=*") ||
        !macro.Initialize()) {

        return 1;
    }


    // Feed the arguments into the argument array.

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help) ||
        !arg_array.Put(&reinstall) ||
        !arg_array.Put(&bufsize) ||
        !arg_array.Put(&listsize) ||
        !arg_array.Put(&macros_plus) ||
        !arg_array.Put(&m_plus) ||
        !arg_array.Put(&macros) ||
        !arg_array.Put(&m) ||
        !arg_array.Put(&history) ||
        !arg_array.Put(&h) ||
        !arg_array.Put(&insert) ||
        !arg_array.Put(&overstrike) ||
        !arg_array.Put(&exename) ||
        !arg_array.Put(&filename) ||
        !arg_array.Put(&macro)) {

        return 1;
    }


    // Parse the command line.

    if (!arglex.DoParsing(&arg_array)) {

        msg.Set(MSG_INVALID_PARAMETER);
        msg.Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 1;
    }


    // Interpret the command line.

    if (bufsize.IsValueSet()) {

        msg.Set(MSG_DOSKEY_CANT_DO_BUFSIZE);
        msg.Display();
    }


    if (help.QueryFlag()) {

        msg.Set(MSG_DOSKEY_HELP);
        msg.Display();
        return 0;
    }


    if ((m.QueryFlag() || macros.QueryFlag()) &&
        (macros_plus.IsValueSet() || m_plus.IsValueSet()) ||
        (macros_plus.IsValueSet() && m_plus.IsValueSet())) {

        msg.Set(MSG_INCOMPATIBLE_PARAMETERS);
        msg.Display();
        return 1;
    }


    // Compute the target exe name.

    if (exename.IsValueSet()) {

        StripQuotesFromString( (PWSTRING)exename.GetString() );
        if (!(target_exe = exename.GetString()->QueryWSTR())) {
            return 1;
        }

    } else {

        target_exe = (PWSTR) L"cmd.exe";
    }


    // Interpret reinstall switch.

    if (reinstall.QueryFlag()) {

        ExpungeConsoleCommandHistory(target_exe);
    }


    // Interpret list size switch.

    if (listsize.IsValueSet()) {
        if (!SetConsoleNumberOfCommands(listsize.QueryLong(), target_exe)) {
            msg.Set(MSG_DOSKEY_CANT_SIZE_LIST);
            msg.Display();
            return 1;
        }
    }


    // Interpret insert and overstrike switches.

    if (insert.QueryFlag()) {
        SetConsoleCommandHistoryMode(0);
    }

    if (overstrike.QueryFlag()) {
        SetConsoleCommandHistoryMode(CONSOLE_OVERSTRIKE);
    }


    // Interpret the macro if any.

    if (macro.IsValueSet()) {

        if (!QuerySourceAndTarget(macro.GetRestOfLine(), &source, &target) ||
            !AddConsoleAlias(source, *target ? target : NULL, target_exe)) {

            msg.Set(MSG_DOSKEY_INVALID_MACRO_DEFINITION);
            msg.Display();
        }

        DELETE(source);
        DELETE(target);
    }


    // pull the stuff out from the file if provided.

    if (filename.IsValueSet()) {

        StripQuotesFromString((PWSTRING)filename.GetPath()->GetPathString());
        if (!ReadInMacrosFromFile(filename.GetPath(), target_exe, &msg)) {
            return 1;
        }
    }


    // Print out history buffer.

    if (history.QueryFlag() || h.QueryFlag()) {

        buffer_length = GetConsoleCommandHistoryLength(target_exe);
        if (!(buffer = (PWSTR) MALLOC(buffer_length))) {
            msg.Set(MSG_CHK_NO_MEMORY);
            msg.Display();
            return 1;
        }

        if (buffer_length) {
            buffer_length = GetConsoleCommandHistory(buffer,
                                                     buffer_length,
                                                     target_exe);
        }

        if (!DisplayPackedString(buffer, buffer_length/sizeof(WCHAR),
                                 FALSE, &msg)) {

            msg.Set(MSG_CHK_NO_MEMORY);
            msg.Display();
            return 1;
        }

        FREE(buffer);
    }


    // Echo macros for target_exe.

    if (macros.QueryFlag() || m.QueryFlag()) {
        if (!DisplayMacros(target_exe, FALSE, &msg)) {
            return 1;
        }
    }


    // Echo macros for specific exe.

    if (macros_plus.IsValueSet()) {

        StripQuotesFromString(macros_plus.GetString());
        if (!all_string.Initialize("all")) {
            return 1;
        }

        if (!macros_plus.GetString()->Stricmp(&all_string)) {

            if (!DisplayAllMacros(&msg)) {
                return 1;
            }

        } else {

            target_exe = macros_plus.GetString()->QueryWSTR();

            if (!DisplayMacros(target_exe, FALSE, &msg)) {
                return 1;
            }

            DELETE(target_exe);
        }
    }


    // Echo macros for specific exe.

    if (m_plus.IsValueSet()) {

        StripQuotesFromString(m_plus.GetString());
        if (!all_string.Initialize("all")) {
            return 1;
        }

        if (!m_plus.GetString()->Stricmp(&all_string)) {

            if (!DisplayAllMacros(&msg)) {
                return 1;
            }

        } else {

            target_exe = m_plus.GetString()->QueryWSTR();

            if (!DisplayMacros(target_exe, FALSE, &msg)) {
                return 1;
            }

            DELETE(target_exe);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fc\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=fc
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\fc.cxx ..\fc.rc

INCLUDES=..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\commit.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    commit.c

Abstract:

    This module contains the set of routines that support the commitment
    of changes to disk without  rebooting.

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <winbase.h>
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include "scsi.h"
#include <ntddcdrm.h>
#include <ntddscsi.h>

// Lock list chain head for deleted partitions.

PDRIVE_LOCKLIST DriveLockListHead = NULL;

// Commit flag for case where a partition is deleted that has not drive letter

extern BOOLEAN CommitDueToDelete;
extern BOOLEAN CommitDueToMirror;
extern BOOLEAN CommitDueToExtended;
extern ULONG   UpdateMbrOnDisk;

extern HWND    InitDlg;

// List head for new drive letter assignment on commit.

typedef struct _ASSIGN_LIST {
    struct _ASSIGN_LIST *Next;
    ULONG                DiskNumber;
    BOOLEAN              MoveLetter;
    UCHAR                OriginalLetter;
    UCHAR                DriveLetter;
} ASSIGN_LIST, *PASSIGN_LIST;

PASSIGN_LIST    AssignDriveLetterListHead = NULL;

VOID
CommitToAssignLetterList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               MoveLetter
    )

/*++

Routine Description:

    Remember this region for assigning a drive letter to it upon
    commit.

Arguments:

    RegionDescriptor - the region to watch
    MoveLetter       - indicate that the region letter is already
                       assigned to a different partition, therefore
                       it must be "moved".

Return Value:

    None

--*/

{
    PASSIGN_LIST            newListEntry;
    PPERSISTENT_REGION_DATA regionData;

    newListEntry = (PASSIGN_LIST) Malloc(sizeof(ASSIGN_LIST));

    if (newListEntry) {

        // Save this region

        regionData = PERSISTENT_DATA(RegionDescriptor);
        newListEntry->OriginalLetter =
            newListEntry->DriveLetter = regionData->DriveLetter;
        newListEntry->DiskNumber = RegionDescriptor->Disk;
        newListEntry->MoveLetter = MoveLetter;

        // place it at the front of the chain.

        newListEntry->Next = AssignDriveLetterListHead;
        AssignDriveLetterListHead = newListEntry;
    }
}

VOID
CommitAssignLetterList(
    VOID
    )

/*++

Routine Description:

    Walk the assign drive letter list and make all drive letter assignments
    expected.  The regions data structures are moved around, so no pointer
    can be maintained to look at them.  To determine the partition number
    for a new partition in this list, the Disks[] structure must be searched
    to find a match on the partition for the drive letter.  Then the partition
    number will be known.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR      regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    PDISKSTATE   diskp;
    PASSIGN_LIST assignList,
                 prevEntry;
    TCHAR        newName[4];
    WCHAR        targetPath[100];
    LONG         partitionNumber;
    ULONG        index;

    assignList = AssignDriveLetterListHead;
    while (assignList) {

        if ((assignList->DriveLetter != NO_DRIVE_LETTER_YET) && (assignList->DriveLetter != NO_DRIVE_LETTER_EVER)) {

            diskp = Disks[assignList->DiskNumber];
            partitionNumber = 0;
            for (index = 0; index < diskp->RegionCount; index++) {

                regionDescriptor = &diskp->RegionArray[index];

                if (DmSignificantRegion(regionDescriptor)) {

                    // If the region has a drive letter, use the drive letter
                    // to get the info via the Windows API.  Otherwise we'll
                    // have to use the NT API.

                    regionData = PERSISTENT_DATA(regionDescriptor);

                    if (regionData) {
                        if (regionData->DriveLetter == assignList->DriveLetter) {
                            partitionNumber = regionDescriptor->Reserved->Partition->PartitionNumber;
                            regionDescriptor->PartitionNumber = partitionNumber;
                            break;
                        }
                    }
                }
            }

            if (partitionNumber) {
                HANDLE handle;
                ULONG  status;

                // set up the new NT path.

                wsprintf((LPTSTR) targetPath,
                         "%s\\Partition%d",
                         GetDiskName(assignList->DiskNumber),
                         partitionNumber);

                // Set up the DOS name.

                newName[1] = (TCHAR)':';
                newName[2] = 0;

                if (assignList->MoveLetter) {

                    // The letter must be removed before it
                    // can be assigned.

                    newName[0] = (TCHAR)assignList->OriginalLetter;
                    NetworkRemoveShare((LPCTSTR) newName);
                    DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) newName, (LPCTSTR) NULL);
                    newName[0] = (TCHAR)assignList->DriveLetter;

                } else {
                    newName[0] = (TCHAR)assignList->DriveLetter;
                }

                // Assign the name - don't worry about errors for now.

                DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) newName, (LPCTSTR) targetPath);
                NetworkShare((LPCTSTR) newName);

                // Some of the file systems do not actually dismount
                // when requested.  Instead, they set a verification
                // bit in the device object.  Due to dynamic partitioning
                // this bit may get cleared by the process of the
                // repartitioning and the file system will then
                // assume it is still mounted on a new access.
                // To get around this problem, new drive letters
                // are always locked and dismounted on creation.

                status = LowOpenDriveLetter(assignList->DriveLetter,
                                            &handle);

                if (NT_SUCCESS(status)) {

                    // Lock the drive to insure that no other access is occurring
                    // to the volume.

                    status = LowLockDrive(handle);

                    if (NT_SUCCESS(status)) {
                        LowUnlockDrive(handle);
                    }
                    LowCloseDisk(handle);
                }

            } else {
                ErrorDialog(MSG_INTERNAL_LETTER_ASSIGN_ERROR);
            }
        }

        prevEntry = assignList;
        assignList = assignList->Next;
        Free(prevEntry);
    }
    AssignDriveLetterListHead = NULL;
}

LONG
CommitInternalLockDriveLetter(
    IN PDRIVE_LOCKLIST LockListEntry
    )

/*++

Routine Description:

    Support routine to perform the locking of a drive letter based on
    the locklist entry given.

Arguments:

    LockListEntry - The information about what to lock.

Return Values:

    zero - success
    non-zero failure

--*/

{
    ULONG           status;

    // Lock the disk and save the handle.

    status = LowOpenDriveLetter(LockListEntry->DriveLetter,
                                &LockListEntry->LockHandle);

    if (!NT_SUCCESS(status)) {
        return 1;
    }


    // Lock the drive to insure that no other access is occurring
    // to the volume.

    status = LowLockDrive(LockListEntry->LockHandle);

    if (!NT_SUCCESS(status)) {
        LowCloseDisk(LockListEntry->LockHandle);
        return 1;
    }

    LockListEntry->CurrentlyLocked = TRUE;
    return 0;
}

LONG
CommitToLockList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               RemoveDriveLetter,
    IN BOOL               LockNow,
    IN BOOL               FailOk
    )

/*++

Routine Description:

    This routine adds the given drive into the lock list for processing
    when a commit occurs.  If the LockNow flag is set it indicates that
    the drive letter is to be immediately locked if it is to go in the
    lock letter list.  If this locking fails an error is returned.

Arguments:

    RegionDescriptor  - the region for the drive to lock.
    RemoveDriveLetter - remove the letter when performing the unlock.
    LockNow           - If the letter is inserted in the list - lock it now.
    FailOk            - It is ok to fail the lock - used for disabled FT sets.

Return Values:

    non-zero - failure to add to list.

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDRIVE_LOCKLIST         lockListEntry;
    UCHAR                   driveLetter;
    ULONG                   diskNumber;

    if (!regionData) {

        // without region data there is no need to be on the lock list.

        return 0;
    }

    // See if this drive letter is already in the lock list.

    driveLetter = regionData->DriveLetter;

    if ((driveLetter == NO_DRIVE_LETTER_YET) || (driveLetter == NO_DRIVE_LETTER_EVER)) {

        // There is no drive letter to lock.

        CommitDueToDelete = RemoveDriveLetter;
        return 0;
    }

    if (!regionData->VolumeExists) {
        PASSIGN_LIST assignList,
                     prevEntry;

        // This item has never been created so no need to put it in the
        // lock list.  But it does need to be removed from the assign
        // letter list.

        prevEntry = NULL;
        assignList = AssignDriveLetterListHead;
        while (assignList) {

            // If a match is found remove it from the list.

            if (assignList->DriveLetter == driveLetter) {
                if (prevEntry) {
                    prevEntry->Next = assignList->Next;
                } else {
                    AssignDriveLetterListHead = assignList->Next;
                }

                Free(assignList);
                assignList = NULL;
            } else {

                prevEntry = assignList;
                assignList = assignList->Next;
            }
        }
        return 0;
    }

    diskNumber = RegionDescriptor->Disk;
    lockListEntry = DriveLockListHead;
    while (lockListEntry) {
        if (lockListEntry->DriveLetter == driveLetter) {

            // Already in the list -- update when to lock and unlock

            if (diskNumber < lockListEntry->LockOnDiskNumber) {
                lockListEntry->LockOnDiskNumber = diskNumber;
            }

            if (diskNumber > lockListEntry->UnlockOnDiskNumber) {
                lockListEntry->UnlockOnDiskNumber = diskNumber;
            }

            // Already in the lock list and information for locking set up.
            // Check to see if this should be a LockNow request.

            if (LockNow) {
               if (!lockListEntry->CurrentlyLocked) {

                    // Need to perform the lock.

                    if (CommitInternalLockDriveLetter(lockListEntry)) {

                        // Leave the element in the list

                        return 1;
                    }
                }
            }
            return 0;

        }
        lockListEntry = lockListEntry->Next;
    }

    lockListEntry = (PDRIVE_LOCKLIST) Malloc(sizeof(DRIVE_LOCKLIST));

    if (!lockListEntry) {
        return 1;
    }

    // set up the lock list entry.

    lockListEntry->LockHandle = NULL;
    lockListEntry->PartitionNumber = RegionDescriptor->PartitionNumber;
    lockListEntry->DriveLetter = driveLetter;
    lockListEntry->RemoveOnUnlock = RemoveDriveLetter;
    lockListEntry->CurrentlyLocked = FALSE;
    lockListEntry->FailOk = FailOk;
    lockListEntry->DiskNumber = lockListEntry->UnlockOnDiskNumber =
                                lockListEntry->LockOnDiskNumber = diskNumber;

    if (LockNow) {
        if (CommitInternalLockDriveLetter(lockListEntry)) {

            // Do not add this to the list.

            Free(lockListEntry);
            return 1;
        }
    }

    // place it at the front of the chain.

    lockListEntry->Next = DriveLockListHead;
    DriveLockListHead = lockListEntry;
    return 0;
}

LONG
CommitLockVolumes(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine will go through any drive letters inserted in the lock list
    for the given disk number and attempt to lock the volumes.  Currently,
    this routine locks all of the drives letters in the lock list when
    called the first time (i.e. when Disk == 0).

Arguments:

    Disk - the index into the disk table.

Return Values:

    non-zero - failure to lock the items in the list.

--*/

{
    PDRIVE_LOCKLIST lockListEntry;

    if (Disk) {
        return 0;
    }


    for (lockListEntry = DriveLockListHead; lockListEntry; lockListEntry = lockListEntry->Next) {

        // Lock the disk.  Return on any failure if that is the
        // requested action for the entry.  It is the responsibility
        // of the caller to release any successful locks.

        if (!lockListEntry->CurrentlyLocked) {
            if (CommitInternalLockDriveLetter(lockListEntry)) {
                if (!lockListEntry->FailOk) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

LONG
CommitUnlockVolumes(
    IN ULONG   Disk,
    IN BOOLEAN FreeList
    )

/*++

Routine Description:

    Go through and unlock any locked volumes in the locked list for the
    given disk.  Currently this routine waits until the last disk has
    been processed, then unlocks all disks.

Arguments:

    Disk - the index into the disk table.
    FreeList - Clean up the list as unlocks are performed or don't

Return Values:

    non-zero - failure to lock the items in the list.

--*/

{
    PDRIVE_LOCKLIST lockListEntry,
                    previousLockListEntry;
    TCHAR           name[4];

    if (Disk != GetDiskCount()) {
        return 0;
    }

    lockListEntry = DriveLockListHead;
    if (FreeList) {
        DriveLockListHead = NULL;
    }
    while (lockListEntry) {

        // Unlock the disk.

        if (lockListEntry->CurrentlyLocked) {

            if (FreeList && lockListEntry->RemoveOnUnlock) {

                // set up the new dos name and NT path.

                name[0] = (TCHAR)lockListEntry->DriveLetter;
                name[1] = (TCHAR)':';
                name[2] = 0;

                NetworkRemoveShare((LPCTSTR) name);
                if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) name, (LPCTSTR) NULL)) {

                    // could not remove name!!?

                }
            }
            LowUnlockDrive(lockListEntry->LockHandle);
            LowCloseDisk(lockListEntry->LockHandle);
        }

        // Move to the next entry.  If requested free this entry.

        previousLockListEntry = lockListEntry;
        lockListEntry = lockListEntry->Next;
        if (FreeList) {
            Free(previousLockListEntry);
        }
    }
    return 0;
}

LETTER_ASSIGNMENT_RESULT
CommitDriveLetter(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN CHAR OldDrive,
    IN CHAR NewDrive
    )

/*++

Routine Description:

    This routine will update the drive letter information in the registry and
    (if the update works) it will attempt to move the current drive letter
    to the new one via DefineDosDevice()

Arguments:

    RegionDescriptor - the region that should get the letter.
    NewDrive         - the new drive letter for the volume.

Return Value:

    0 - the assignment failed.
    1 - if the assigning of the letter occurred interactively.
    2 - must reboot to do the letter.

--*/

{
    PPERSISTENT_REGION_DATA regionData;
    PDRIVE_LOCKLIST         lockListEntry;
    PASSIGN_LIST            assignList;
    HANDLE                  handle;
    TCHAR                   newName[4];
    WCHAR                   targetPath[100];
    int                     doIt;
    STATUS_CODE             status = ERROR_SEVERITY_ERROR;
    LETTER_ASSIGNMENT_RESULT result = Failure;

    regionData = PERSISTENT_DATA(RegionDescriptor);

    // check the assign letter list for a match.
    // If the letter is there, then just update the list
    // otherwise continue on with the action.

    assignList = AssignDriveLetterListHead;
    while (assignList) {

        if (assignList->DriveLetter == (UCHAR)OldDrive) {
            assignList->DriveLetter = (UCHAR)NewDrive;
            return Complete;
        }
        assignList = assignList->Next;
    }

    // Search to see if the drive is currently locked.

    for (lockListEntry = DriveLockListHead;
         lockListEntry;
         lockListEntry = lockListEntry->Next) {

        if ((lockListEntry->DiskNumber == RegionDescriptor->Disk) &&
            (lockListEntry->PartitionNumber == RegionDescriptor->PartitionNumber)) {

            if (lockListEntry->CurrentlyLocked) {
                status = 0;
            }

            // found the match no need to continue searching.

            break;
        }
    }

    if (!NT_SUCCESS(status)) {

        // See if the drive can be locked.

        status = LowOpenPartition(GetDiskName(RegionDescriptor->Disk),
                                  RegionDescriptor->PartitionNumber,
                                  &handle);

        if (!NT_SUCCESS(status)) {
            return Failure;
        }

        // Lock the drive to insure that no other access is occurring
        // to the volume.

        status = LowLockDrive(handle);

        if (!NT_SUCCESS(status)) {

            if (IsPagefileOnDrive(OldDrive)) {

                ErrorDialog(MSG_CANNOT_LOCK_PAGEFILE);
            } else {

                ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            }
            doIt = ConfirmationDialog(MSG_SCHEDULE_REBOOT, MB_ICONQUESTION | MB_YESNO);

            LowCloseDisk(handle);
            if (doIt == IDYES) {
                RegistryChanged = TRUE;
                RestartRequired = TRUE;
                return MustReboot;
            }
            return Failure;
        }
    } else {

        // This drive was found in the lock list and is already
        // in the locked state.  It is safe to continue with
        // the drive letter assignment.

    }

    doIt = ConfirmationDialog(MSG_DRIVE_RENAME_WARNING, MB_ICONQUESTION | MB_YESNOCANCEL);

    if (doIt != IDYES) {

        LowUnlockDrive(handle);
        LowCloseDisk(handle);
        return Failure;
    }

    // Update the registry first.  This way if something goes wrong
    // the new letter will arrive on reboot.

    if (!DiskRegistryAssignDriveLetter(Disks[RegionDescriptor->Disk]->Signature,
                                      FdGetExactOffset(RegionDescriptor),
                                      FdGetExactSize(RegionDescriptor, FALSE),
                                      (UCHAR)((NewDrive == NO_DRIVE_LETTER_EVER) ? (UCHAR)' ' : (UCHAR)NewDrive))) {

        // Registry update failed.

        return Failure;
    }

    // It is safe to change the drive letter.  First, remove the
    // existing letter.

    newName[0] = (TCHAR)OldDrive;
    newName[1] = (TCHAR)':';
    newName[2] = 0;

    NetworkRemoveShare((LPCTSTR) newName);
    if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) newName, (LPCTSTR) NULL)) {

        LowUnlockDrive(handle);
        LowCloseDisk(handle);
        RegistryChanged = TRUE;
        return Failure;
    }

    if (NewDrive != NO_DRIVE_LETTER_EVER) {

        // set up the new dos name and NT path.

        newName[0] = (TCHAR)NewDrive;
        newName[1] = (TCHAR)':';
        newName[2] = 0;

        wsprintf((LPTSTR) targetPath,
                 "%s\\Partition%d",
                 GetDiskName(RegionDescriptor->Disk),
                 RegionDescriptor->PartitionNumber);

        if (DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) newName, (LPCTSTR) targetPath)) {
            result = Complete;
        } else {
            RegistryChanged = TRUE;
        }
        NetworkShare((LPCTSTR) newName);
    } else {
        result = Complete;
    }

    // Force the file system to dismount

    LowUnlockDrive(handle);
    LowCloseDisk(handle);
    return result;
}

VOID
CommitUpdateRegionStructures(
    VOID
    )

/*++

Routine Description:

    This routine is called ONLY after a successful commit of a new partitioning
    scheme for the system.  Its is responsible for walking through the
    region arrays for each of the disks and updating the regions to indicate
    their transition from being "desired" to being actually committed
    to disk

Arguments:

    None

Return Values:

    None

--*/

{
    PDISKSTATE              diskState;
    PREGION_DESCRIPTOR      regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    ULONG                   regionNumber,
                            diskNumber;

    // search through all disks in the system.

    for (diskNumber = 0, diskState = Disks[0]; diskNumber < DiskCount; diskState = Disks[++diskNumber]) {

        // Look at every region array entry and update the values
        // to indicate that this region now exists.

        for (regionNumber = 0; regionNumber < diskState->RegionCount; regionNumber++) {

            regionDescriptor = &diskState->RegionArray[regionNumber];
            if (regionDescriptor->Reserved) {
                if (regionDescriptor->Reserved->Partition) {
                    regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded = FALSE;
                }
            }
            regionData = PERSISTENT_DATA(regionDescriptor);
            if ((regionData) && (!regionData->VolumeExists)) {

                // By definition and assumption of this routine,
                // this region has just been committed to disk.

                regionData->VolumeExists = TRUE;

                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                }
                regionData->TypeName = Malloc((lstrlenW(wszUnformatted)+1)*sizeof(WCHAR));
                lstrcpyW(regionData->TypeName, wszUnformatted);
            }
        }
    }
}

VOID
CommitAllChanges(
    IN PVOID Param
    )

/*++

Routine Description:

    This routine will go through all of the region descriptors and commit
    any changes that have occurred to disk.  Then it "re-initializes"
    Disk Administrator and start the display/work process over again.

Arguments:

    Param - undefined for now

Return Value:

    None

--*/

{
    DWORD                   action,
                            errorCode;
    ULONG                   diskCount,
                            temp;
    BOOL                    profileWritten,
                            changesMade,
                            mustReboot,
                            configureFt;

    SetCursor(hcurWait);
    diskCount = GetDiskCount();

    // Determine whether any disks have been changed, and whether
    // the system must be rebooted.  The system must be rebooted
    // if the registry has changed, if any non-removable disk has
    // changed, or if any removable disk that was not originally
    // unpartitioned has changed.

    changesMade = configureFt = FALSE;
    mustReboot = RestartRequired;

    for (temp=0; temp<diskCount; temp++) {
        if (HavePartitionsBeenChanged(temp)) {

            changesMade = TRUE;
            break;
        }
    }

    profileWritten = FALSE;

    // Determine if the commit can be done without a reboot.
    // If FT is in the system then it must be notified to
    // reconfigure if a reboot is not performed.  If it is
    // not in the system, but the new disk information requires
    // it, then a reboot must be forced.

    if (FtInstalled()) {
        configureFt = TRUE;
    }
    if (NewConfigurationRequiresFt()) {
        if (!configureFt) {

            // The FT driver is not loaded currently.

            mustReboot = TRUE;
        } else {

            // If the system is going to be rebooted, don't
            // have FT reconfigure prior to shutdown.

            if (mustReboot) {
                configureFt = FALSE;
            }
        }
    }

    if (RegistryChanged | changesMade | RestartRequired) {

        if (RestartRequired) {
            action = IDYES;
        } else {
            action = ConfirmationDialog(MSG_CONFIRM_EXIT, MB_ICONQUESTION | MB_YESNOCANCEL);
        }

        if (action == IDYES) {
            errorCode = CommitLockVolumes(0);
            if (errorCode) {

                // could not lock all volumes

                SetCursor(hcurNormal);
                ErrorDialog(MSG_CANNOT_LOCK_FOR_COMMIT);
                CommitUnlockVolumes(diskCount, FALSE);
                return;
            }

            if (mustReboot) {

                SetCursor(hcurNormal);
                if (RestartRequired) {
                    action = IDYES;
                } else {
                    action = ConfirmationDialog(MSG_REQUIRE_REBOOT, MB_ICONQUESTION | MB_YESNO);
                }

                if (action != IDYES) {

                    CommitUnlockVolumes(diskCount, FALSE);
                    return;
                }
            }

            SetCursor(hcurWait);
            errorCode = CommitChanges();
            CommitUnlockVolumes(diskCount, TRUE);
            SetCursor(hcurNormal);

            if (errorCode != NO_ERROR) {
                ErrorDialog(MSG_BAD_CONFIG_SET);
                PostQuitMessage(0);
            } else {
                ULONG OldBootPartitionNumber,
                      NewBootPartitionNumber;
                CHAR  OldNumberString[8],
                      NewNumberString[8];
                DWORD MsgCode;

                // Update the configuration registry

                errorCode = SaveFt();

                // Check if FTDISK drive should reconfigure.

                if (configureFt) {

                    // Issue device control to ftdisk driver to reconfigure.

                    FtConfigure();
                }

                // Register autochk to fix up file systems
                // in newly extended volume sets, if necessary

                if (RegisterFileSystemExtend()) {
                    mustReboot = TRUE;
                }

                // Determine if the FT driver must be enabled.

                if (DiskRegistryRequiresFt() == TRUE) {
                    if (!FtInstalled()) {
                        mustReboot = TRUE;
                    }
                    DiskRegistryEnableFt();
                } else {
                    DiskRegistryDisableFt();
                }

                if (errorCode == NO_ERROR) {
                    InfoDialog(MSG_OK_COMMIT);
                } else {
                    ErrorDialog(MSG_BAD_CONFIG_SET);
                }

                // Has the partition number of the boot
                // partition changed?

                if (BootPartitionNumberChanged( &OldBootPartitionNumber,&NewBootPartitionNumber)) {
#if i386
                    MsgCode = MSG_BOOT_PARTITION_CHANGED_X86;
#else
                    MsgCode = MSG_BOOT_PARTITION_CHANGED_ARC;
#endif
                    sprintf(OldNumberString, "%d", OldBootPartitionNumber);
                    sprintf(NewNumberString, "%d", NewBootPartitionNumber);
                    InfoDialog(MsgCode, OldNumberString, NewNumberString);
                }

                ClearCommittedDiskInformation();

                if (UpdateMbrOnDisk) {

                    UpdateMasterBootCode(UpdateMbrOnDisk);
                    UpdateMbrOnDisk = 0;
                }

                // Reboot if necessary.

                if (mustReboot) {

                    SetCursor(hcurWait);
                    Sleep(5000);
                    SetCursor(hcurNormal);
                    FdShutdownTheSystem();
                    profileWritten = TRUE;
                }
                CommitAssignLetterList();
                CommitUpdateRegionStructures();
                RegistryChanged = FALSE;
                CommitDueToDelete = CommitDueToMirror = FALSE;
                TotalRedrawAndRepaint();
                AdjustMenuAndStatus();
            }
        } else if (action == IDCANCEL) {
            return;      // don't exit
        } else {
            FDASSERT(action == IDNO);
        }
    }
}

VOID
FtConfigure(
    VOID
    )

/*++

Routine Description:

    This routine calls the FTDISK driver to ask it to reconfigure as changes
    have been made in the registry.

Arguments:

    None

Return Value:

    None

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    STRING            ntFtName;
    IO_STATUS_BLOCK   statusBlock;
    UNICODE_STRING    unicodeDeviceName;
    NTSTATUS          status;
    HANDLE            handle;

    // Open ft control object.

    RtlInitString(&ntFtName,
                  "\\Device\\FtControl");
    RtlAnsiStringToUnicodeString(&unicodeDeviceName,
                                 &ntFtName,
                                 TRUE);
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = DmOpenFile(&handle,
                        SYNCHRONIZE | FILE_ANY_ACCESS,
                        &objectAttributes,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT );
    RtlFreeUnicodeString(&unicodeDeviceName);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Issue device control to reconfigure FT.

    NtDeviceIoControlFile(handle,
                          NULL,
                          NULL,
                          NULL,
                          &statusBlock,
                          FT_CONFIGURE,
                          NULL,
                          0L,
                          NULL,
                          0L);

    DmClose(handle);
    return;
}

BOOL
CommitAllowed(
    VOID
    )

/*++

Routine Description:

    Determine if it is ok to perform a commit.

Arguments:

    None

Return Value:

    TRUE if it is ok to commit and there is something to commit
    FALSE otherwise

--*/

{
    if (DriveLockListHead ||
        AssignDriveLetterListHead ||
        CommitDueToDelete ||
        CommitDueToMirror ||
        CommitDueToExtended) {
        return TRUE;
    }
    return FALSE;
}

VOID
RescanDevices(
    VOID
    )

/*++

Routine Description:

    This routine performs all actions necessary to dynamically rescan
    device buses (i.e. SCSI) and get the appropriate driver support loaded.

Arguments:

    None

Return Value:

    None

--*/

{
    PSCSI_ADAPTER_BUS_INFO adapterInfo;
    PSCSI_BUS_DATA         busData;
    PSCSI_INQUIRY_DATA     inquiryData;
    TCHAR                  physicalName[32];
    TCHAR                  driveName[32];
    BYTE                   driveBuffer[32];
    BYTE                   physicalBuffer[32];
    HANDLE                 volumeHandle;
    STRING                 string;
    UNICODE_STRING         unicodeString;
    UNICODE_STRING         physicalString;
    OBJECT_ATTRIBUTES      objectAttributes;
    NTSTATUS               ntStatus;
    IO_STATUS_BLOCK        statusBlock;
    BOOLEAN                diskFound,
                           cdromFound;
    ULONG                  bytesTransferred,
                           i,
                           j,
                           deviceNumber,
                           currentPort,
                           numberOfPorts,
                           percentComplete,
                           portNumber;

    diskFound = FALSE;
    cdromFound = FALSE;

    // Determine how many buses there are

    portNumber = numberOfPorts = percentComplete = 0;
    while (TRUE) {

        memset(driveBuffer, 0, sizeof(driveBuffer));
        sprintf(driveBuffer, "\\\\.\\Scsi%d:", portNumber);

        // Open the SCSI port with the DOS name.

        volumeHandle = CreateFile(driveBuffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if (volumeHandle == INVALID_HANDLE_VALUE) {
            break;
        }

        CloseHandle(volumeHandle);
        numberOfPorts++;
        portNumber++;
    }

    currentPort = 1;
    portNumber = 0;

    // Perform the scsi bus rescan.

    while (TRUE) {

        memset(driveBuffer, 0, sizeof(driveBuffer));
        sprintf(driveBuffer, "\\\\.\\Scsi%d:", portNumber);

        // Open the SCSI port with the DOS name.

        volumeHandle = CreateFile(driveBuffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if (volumeHandle == INVALID_HANDLE_VALUE) {
            break;
        }

        // Issue rescan device control.

        if (!DeviceIoControl(volumeHandle,
                             IOCTL_SCSI_RESCAN_BUS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesTransferred,
                             NULL)) {

            CloseHandle(volumeHandle);
            break;
        }

        percentComplete = (currentPort * 100) / numberOfPorts;

        if (percentComplete < 100) {
            PostMessage(InitDlg,
                        WM_USER,
                        percentComplete,
                        0);
        }

        currentPort++;

        // Get a big chuck of memory to store the SCSI bus data.

        adapterInfo = malloc(0x4000);

        if (adapterInfo == NULL) {
            CloseHandle(volumeHandle);
            goto finish;
        }

        // Issue device control to get configuration information.

        if (!DeviceIoControl(volumeHandle,
                             IOCTL_SCSI_GET_INQUIRY_DATA,
                             NULL,
                             0,
                             adapterInfo,
                             0x4000,
                             &bytesTransferred,
                             NULL)) {

            CloseHandle(volumeHandle);
            goto finish;
        }


        for (i = 0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];
            inquiryData =
                (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            for (j = 0; j < busData->NumberOfLogicalUnits; j++) {

                // Check if device is claimed.

                if (!inquiryData->DeviceClaimed) {

                        // Determine the perpherial type.

                        switch (inquiryData->InquiryData[0] & 0x1f) {
                        case DIRECT_ACCESS_DEVICE:
                            diskFound = TRUE;
                            break;

                        case READ_ONLY_DIRECT_ACCESS_DEVICE:
                            cdromFound = TRUE;
                            break;

                        case OPTICAL_DEVICE:
                            diskFound = TRUE;
                            break;
                        }
                }

                // Get next device data.

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);
            }
        }

        free(adapterInfo);
        CloseHandle(volumeHandle);

        portNumber++;
    }

    if (diskFound) {

        // Send IOCTL_DISK_FIND_NEW_DEVICES commands to each existing disk.

        deviceNumber = 0;
        while (TRUE) {

            memset(driveBuffer, 0, sizeof(driveBuffer));
            sprintf(driveBuffer, "\\Device\\Harddisk%d\\Partition0", deviceNumber);

            RtlInitString(&string, driveBuffer);
            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);
            if (!NT_SUCCESS(ntStatus)) {
                break;
            }
            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);
            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                RtlFreeUnicodeString(&unicodeString);
                break;
            }

            // Issue find device device control.

            if (!DeviceIoControl(volumeHandle,
                                 IOCTL_DISK_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL)) {

            }
            DmClose(volumeHandle);

            // see if the physicaldrive# symbolic link is present

            sprintf(physicalBuffer, "\\DosDevices\\PhysicalDrive%d", deviceNumber);
            deviceNumber++;

            RtlInitString(&string, physicalBuffer);
            ntStatus = RtlAnsiStringToUnicodeString(&physicalString,
                                                    &string,
                                                    TRUE);
            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }
            InitializeObjectAttributes(&objectAttributes,
                                       &physicalString,
                                       0,
                                       NULL,
                                       NULL);
            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                ULONG index;
                ULONG dest;

                // Name is not there - create it.  This copying
                // is done in case this code should ever become
                // unicode and the types for the two strings would
                // actually be different.
                //
                // Copy only the portion of the physical name
                // that is in the \dosdevices\ directory

                for (dest = 0, index = 12; TRUE; index++, dest++) {

                    physicalName[dest] = (TCHAR)physicalBuffer[index];
                    if (!physicalName[dest]) {
                        break;
                    }
                }

                // Copy all of the NT namespace name.

                for (index = 0; TRUE; index++) {

                    driveName[index] = (TCHAR) driveBuffer[index];
                    if (!driveName[index]) {
                        break;
                    }
                }

                DefineDosDevice(DDD_RAW_TARGET_PATH,
                                (LPCTSTR) physicalName,
                                (LPCTSTR) driveName);

            } else {
                DmClose(volumeHandle);
            }

            // free allocated memory for unicode string.

            RtlFreeUnicodeString(&unicodeString);
            RtlFreeUnicodeString(&physicalString);
        }
    }

    if (cdromFound) {

        // Send IOCTL_CDROM_FIND_NEW_DEVICES commands to each existing cdrom.

        deviceNumber = 0;
        while (TRUE) {

            memset(driveBuffer, 0, sizeof(driveBuffer));
            sprintf(driveBuffer, "\\Device\\Cdrom%d", deviceNumber);
            RtlInitString(&string, driveBuffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = DmOpenFile(&volumeHandle,
                                  FILE_READ_DATA  | FILE_WRITE_DATA | SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  | FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            // Issue find device device control.

            if (!DeviceIoControl(volumeHandle,
                                 IOCTL_CDROM_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL)) {
            }

            CloseHandle(volumeHandle);
            deviceNumber++;
        }
    }
finish:
    PostMessage(InitDlg,
                WM_USER,
                100,
                0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\arrowin.c ===
/** FILE: arrowin.c ******** Module Header ********************************
 *
 *      Control panel arrow window class routines. This file contains the
 *      window procedure and utility functions for managing the "cpArrow"
 *  window class/spinner control for use by Control Panel applet dialogs.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *              Took base code from Win 3.1 source
 *
 *  Copyright (C) 1990-1991 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                                                              Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Windows SDK
/* cut out unnec stuff from windows.h */
#define NOCLIPBOARD
#define NOMETAFILE
#define NOREGION
#define NOSYSCOMMANDS
#define NOATOM
#define NOGDICAPMASKS

#include <windows.h>

//==========================================================================
//                                                      Local Definitions
//==========================================================================
#define SHIFT_TO_DOUBLE 1
#define DOUBLECLICK     0
#define PRESSINVERT     1
#define POINTSPERARROW  3
#define ARROWXAXIS      15
#define ARROWYAXIS      15


//==========================================================================
//                                                      External Declarations
//==========================================================================
extern HANDLE hModule;


//==========================================================================
//                                                      Local Data Declarations
//==========================================================================
#if 0
POINT Arrow[11] = {     16, 1, 2, 14, 12, 14, 12, 20, 2, 20, 16, 33,
            29, 20, 20, 20, 20, 14, 29, 14/*, 16,1*/};
#endif

#if 0
POINT ArrowUp[7] = {5, 2, 8, 5, 6, 5, 6, 7, 4, 7, 4, 5, 2, 5};

POINT ArrowDown[7] = {  4, 10, 6, 10, 6, 12, 8, 12, 5, 15, 2, 12, 4, 12};

#endif

POINT ArrowUp[POINTSPERARROW] = {7, 1, 3, 5, 11, 5};

POINT ArrowDown[POINTSPERARROW] = {7, 13, 3, 9, 11, 9};

BOOL    bRight;
RECT    rUp, rDown;
LPRECT  lpUpDown;
FARPROC lpArrowProc;
HANDLE  hParent;

//==========================================================================
//                                                      Local Function Prototypes
//==========================================================================


//==========================================================================
//                                                              Functions
//==========================================================================

WORD UpOrDown()
{
        LONG  l;
        WORD  retval;
        POINT pt;

        l = GetMessagePos();

        pt.y = (int) HIWORD(l);
        pt.x = (int) LOWORD(l);

        if (PtInRect((LPRECT) &rUp, pt))
                retval = SB_LINEUP;
        else if (PtInRect((LPRECT) &rDown, pt))
                retval = SB_LINEDOWN;
        else
                retval = (WORD)-1;      /* -1, because SB_LINEUP == 0 */
        return(retval);
}


WORD ArrowTimerProc(hWnd, wMsg, nID, dwTime)
HANDLE hWnd;
WORD   wMsg;
short  nID;
DWORD  dwTime;
{
        WORD wScroll;

        if ((wScroll = UpOrDown()) != -1)
        {
                if (bRight == WM_RBUTTONDOWN)
                        wScroll += SB_PAGEUP - SB_LINEUP;
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                GetWindowLong(hWnd, GWL_ID)), (LONG) hWnd);
        }
/* Don't need to call KillTimer(), because SetTimer will reset the right one */
        SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc);
        return(0);
#if 0
        wMsg = wMsg;
        dwTime = dwTime;
#endif
}


#if PRESSINVERT
void InvertArrow(HANDLE hArrow, WORD wScroll)
{
        HDC hDC;

        lpUpDown = (wScroll == SB_LINEUP) ? &rUp : &rDown;
        hDC = GetDC(hArrow);
        ScreenToClient(hArrow, (LPPOINT) &(lpUpDown->left));
        ScreenToClient(hArrow, (LPPOINT) &(lpUpDown->right));
        InvertRect(hDC, lpUpDown);
        ClientToScreen(hArrow, (LPPOINT) &(lpUpDown->left));
        ClientToScreen(hArrow, (LPPOINT) &(lpUpDown->right));
        ReleaseDC(hArrow, hDC);
        ValidateRect(hArrow, lpUpDown);
        return;
}


#endif

LONG ArrowControlProc(HWND hArrow, UINT message, UINT wParam, LONG lParam)
{
        PAINTSTRUCT ps;
        RECT    rArrow;
        HBRUSH  hbr;
        short   fUpDownOut;
        WORD    wScroll;
        POINT   tPoint;
        SIZE    tSize;

        switch (message)
        {
/*
      case WM_CREATE:
        break;

      case WM_DESTROY:
        break;
*/

        case WM_MOUSEMOVE:
                if (!bRight)  /* If not captured, don't worry about it */
                        break;

                if (lpUpDown == &rUp)
                        fUpDownOut = SB_LINEUP;
                else if (lpUpDown == &rDown)
                        fUpDownOut = SB_LINEDOWN;
                else
                        fUpDownOut = -1;

                switch (wScroll = UpOrDown())
                {
                case SB_LINEUP:
                        if (fUpDownOut == SB_LINEDOWN)
                                InvertArrow(hArrow, SB_LINEDOWN);
                        if (fUpDownOut != SB_LINEUP)
                                InvertArrow(hArrow, wScroll);
                        break;

                case SB_LINEDOWN:
                        if (fUpDownOut == SB_LINEUP)
                                InvertArrow(hArrow, SB_LINEUP);
                        if (fUpDownOut != SB_LINEDOWN)
                                InvertArrow(hArrow, wScroll);
                        break;

                default:
                        if (lpUpDown)
                        {
                                InvertArrow(hArrow, fUpDownOut);
                                lpUpDown = 0;
                        }
                }
                break;

        case WM_RBUTTONDOWN:
        case WM_LBUTTONDOWN:
                if (bRight)
                        break;
                bRight = message;
                SetCapture(hArrow);
                hParent = GetParent(hArrow);
                GetWindowRect(hArrow, (LPRECT) &rUp);
                CopyRect((LPRECT) &rDown, (LPRECT) &rUp);
                rUp.bottom = (rUp.top + rUp.bottom) / 2;
                rDown.top = rUp.bottom + 1;
                wScroll = UpOrDown();
#if PRESSINVERT
                InvertArrow(hArrow, wScroll);
#endif
#if SHIFT_TO_DOUBLE
                if (wParam & MK_SHIFT)
                {
                        if (message != WM_RBUTTONDOWN)
                                goto ShiftLClick;
                        else
                                goto ShiftRClick;
                }
#endif
                if (message == WM_RBUTTONDOWN)
                        wScroll += SB_PAGEUP - SB_LINEUP;
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc, hModule);
                SetTimer(hArrow, GetWindowLong(hArrow, GWL_ID), 200, (TIMERPROC)lpArrowProc);
                break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
                if ((UINT) (bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == message)
                {
                        bRight = 0;
                        ReleaseCapture();
#if PRESSINVERT
                        if (lpUpDown)
                                InvertArrow(hArrow, (WORD)((lpUpDown == &rUp) ? SB_LINEUP : SB_LINEDOWN));
#endif
                        if (lpArrowProc)
                        {
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                                SendMessage(hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                                KillTimer(hArrow, GetWindowLong(hArrow, GWL_ID));
                                FreeProcInstance(lpArrowProc);
                                ReleaseCapture();
                                lpArrowProc = 0;
                        }
                }
                break;

        case WM_LBUTTONDBLCLK:
ShiftLClick:
                wScroll = UpOrDown() + (WORD) (SB_TOP - SB_LINEUP);
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                break;

        case WM_RBUTTONDBLCLK:
ShiftRClick:
                wScroll = UpOrDown() + (WORD) (SB_THUMBPOSITION - SB_LINEUP);
// [stevecat] - changed WM_VSCROLL message parameter ordering for WIN32
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
                SendMessage(hParent, WM_VSCROLL, MAKELONG(wScroll,
                                                                 GetWindowLong(hArrow, GWL_ID)), (LONG) hArrow);
/*
        hDC = GetDC(hArrow);
        InvertRect(hDC, (LPRECT) &rArrow);
        ReleaseDC(hArrow, hDC);
        ValidateRect(hArrow, (LPRECT) &rArrow);
*/
                break;

        case WM_PAINT:
                BeginPaint(hArrow, &ps);
                GetClientRect(hArrow, (LPRECT) &rArrow);
                if (hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)))
                {
                        FillRect(ps.hdc, (LPRECT) &rArrow, hbr);
                        DeleteObject(hbr);
                }
                hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH));
                SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME));
                SetMapMode(ps.hdc, MM_ANISOTROPIC);

                SetViewportOrgEx(ps.hdc, rArrow.left, rArrow.top, &tPoint);
                SetViewportExtEx(ps.hdc, rArrow.right - rArrow.left,
                    rArrow.bottom - rArrow.top, &tSize);
                SetWindowOrgEx(ps.hdc, 0, 0, &tPoint);
                SetWindowExtEx(ps.hdc, ARROWXAXIS, ARROWYAXIS, &tSize);
                MoveToEx(ps.hdc, 0, (ARROWYAXIS / 2), &tPoint);
                LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2));
/*
        Polygon(ps.hdc, (LPPOINT) Arrow, 10);
*/
                Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW);
                Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW);
                SelectObject(ps.hdc, hbr);
                EndPaint(hArrow, &ps);
                break;

        default:
                return(DefWindowProc(hArrow, message, wParam, lParam));
                break;
        }
        return(0L);
}


BOOL RegisterArrowClass (HANDLE hModule)
{
        WNDCLASS wcArrow;

        wcArrow.lpszClassName = "cpArrow";
        wcArrow.hInstance     = hModule;
        wcArrow.lpfnWndProc   = ArrowControlProc;
        wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcArrow.hIcon         = NULL;
        wcArrow.lpszMenuName  = NULL;
        wcArrow.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
#if DOUBLECLICK
        wcArrow.style         |= CS_DBLCLKS;
#endif
        wcArrow.cbClsExtra    = 0;
        wcArrow.cbWndExtra    = 0;

        return(RegisterClass((LPWNDCLASS) &wcArrow));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\dblspace.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dblspace.c

Abstract:

    This module contains the set of routines that deal with double space
    dialogs and support.

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "fmifs.h"
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <string.h>

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED

PREGION_DESCRIPTOR RegionForDblSpaceVolume;

ULONG DblSpaceThresholdSizes[] = { 10, 40, 100, (ULONG) -1 };

#define NUMBER_PARSEFORMAT_ITEMS 4
char *DblSpaceIniFileName = "%c:\\dblspace.ini";
char *DblSpaceWildCardFileName = "%c:\\dblspace.*";
char *DblSpaceParseFormat = "%s %s %d %d";

// All double space structures are chained into the base chain
// this allows for ease in initialization to determine which are
// mounted.  This chain is only used for initialization.

PDBLSPACE_DESCRIPTOR DblChainBase = NULL;
PDBLSPACE_DESCRIPTOR DblChainLast = NULL;

extern BOOLEAN DoubleSpaceSupported;

#define DblSpaceMountDrive(REGDESC, DBLSPACE) \
                                     DblSpaceChangeState(REGDESC, DBLSPACE, TRUE)
#define DblSpaceDismountDrive(REGDESC, DBLSPACE) \
                                     DblSpaceChangeState(REGDESC, DBLSPACE, FALSE)

VOID
DblSpaceUpdateIniFile(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    This routine is left around in case this code must update DOS
    based .ini files.  Currently it does nothing.

Arguments:

    The region with the double space volumes.

Return Value

    None

--*/

{
}

ULONG
DblSpaceChangeState(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpacePtr,
    IN BOOL                 Mount
    )

/*++

Routine Description:

    Based on the value of Mount, either mount the volume or
    dismount the Double Space volume

Arguments:

    RegionDescriptor - The region containing the double space volume
    DriveLetter      - The drive letter of the double space volume involved.
    Mount            - TRUE == perform a mount function
                       FALSE == dismount the volume

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    WCHAR dblSpaceUniqueName[32];
    ULONG index;
    ULONG result = 0;

    SetCursor(hcurWait);

    if (Mount) {

        // Call fmifs mount routine.

        result = FmIfsMountDblspace(DblSpacePtr->FileName,
                                    regionData->DriveLetter,
                                    DblSpacePtr->NewDriveLetter);

    } else {

        // Call fmifs dismount routine.

        result = FmIfsDismountDblspace(DblSpacePtr->DriveLetter);
    }

    if (!result) {
        DblSpacePtr->Mounted = Mount;
        if (Mount) {
            DblSpacePtr->DriveLetter = DblSpacePtr->NewDriveLetter;
            MarkDriveLetterUsed(DblSpacePtr->DriveLetter);
        } else {
            TCHAR name[4];

            // remove the drive letter.

            name[0] = (TCHAR)DblSpacePtr->DriveLetter;
            name[1] = (TCHAR)':';
            name[2] = 0;

            DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) name, (LPCTSTR) NULL);

            // Now update the internal structures.

            MarkDriveLetterFree(DblSpacePtr->DriveLetter);
            DblSpacePtr->DriveLetter = ' ';
        }

        if (!IsDiskRemovable[RegionDescriptor->Disk]) {

            dblSpaceUniqueName[0] = (WCHAR) regionData->DriveLetter;
            dblSpaceUniqueName[1] = (WCHAR) ':';
            dblSpaceUniqueName[2] = (WCHAR) '\\';

            index = 0;
            while (dblSpaceUniqueName[index + 3] = DblSpacePtr->FileName[index]) {
                index++;
            }

            result = DiskRegistryAssignDblSpaceLetter(dblSpaceUniqueName,
                                                      (WCHAR) DblSpacePtr->DriveLetter);
        }
    }
    SetCursor(hcurNormal);
    return result;
}

PDBLSPACE_DESCRIPTOR
DblSpaceCreateInternalStructure(
    IN CHAR  DriveLetter,
    IN ULONG Size,
    IN PCHAR Name,
    IN BOOLEAN ChainIt
    )

/*++

Routine Description:

    This routine constructs the internal data structure that represents a
    double space volume.

Arguments:

    DriveLetter - drive letter for new internal structure
    Size        - size of the actual volume
    Name        - name of the containing double space file (i.e. dblspace.xxx)

Return Value:

    Pointer to the new structure if created.
    NULL if it couldn't be created.

--*/

{
    PDBLSPACE_DESCRIPTOR dblSpace;

    dblSpace = malloc(sizeof(DBLSPACE_DESCRIPTOR));
    if (dblSpace) {
        if (DriveLetter != ' ') {
            MarkDriveLetterUsed(DriveLetter);
        }
        dblSpace->DriveLetter = DriveLetter;
        dblSpace->DriveLetterEOS = 0;
        dblSpace->NewDriveLetter = 0;
        dblSpace->NewDriveLetterEOS = 0;
        dblSpace->ChangeDriveLetter = FALSE;
        dblSpace->Next = dblSpace->DblChainNext = NULL;
        dblSpace->Mounted = FALSE;
        dblSpace->ChangeMountState = FALSE;
        dblSpace->AllocatedSize = Size;
        dblSpace->FileName = malloc(strlen(Name) + 4);
        if (dblSpace->FileName) {

            // Copy the name.

            strcpy(dblSpace->FileName, Name);
            if (ChainIt) {
                if (DblChainBase) {
                    DblChainLast->DblChainNext = dblSpace;
                } else {
                    DblChainBase = dblSpace;
                }
                DblChainLast = dblSpace;
            }
        } else {

            // no memory - free what is allocated and give up.

            free(dblSpace);
            dblSpace = NULL;
        }
    }
    return dblSpace;
}

#define MAX_IFS_NAME_LENGTH 200
VOID
DblSpaceDetermineMounted(
    VOID
    )

/*++

Routine Description:

    This routine walks through all of the system drive letters to see
    if any are mounted double space volumes.  If a mounted double space
    volume is located it updates the state of that volume in the internal
    data structures for the double space volumes.

Arguments:

    None

Return Value:

    None

--*/

{
    PDBLSPACE_DESCRIPTOR dblSpace;
    ULONG                index;
    WCHAR                driveLetter[4],
                         ntDriveName[MAX_IFS_NAME_LENGTH],
                         cvfName[MAX_IFS_NAME_LENGTH],
                         hostDriveName[MAX_IFS_NAME_LENGTH],
                         compareName[MAX_IFS_NAME_LENGTH];
    UINT                 errorMode;
    BOOLEAN              removable,
                         floppy,
                         compressed,
                         error;

    driveLetter[1] = (WCHAR) ':';
    driveLetter[2] = 0;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    for (driveLetter[0] = (WCHAR) 'C'; driveLetter[0] < (WCHAR) 'Z'; driveLetter[0]++) {

        if (DriveLetterIsAvailable((CHAR)driveLetter[0])) {

            // No sense calling this stuff for something that doesn't exist

            continue;
        }

        compressed = FALSE;
        if (FmIfsQueryInformation(&driveLetter[0],
                                  &removable,
                                  &floppy,
                                  &compressed,
                                  &error,
                                  &ntDriveName[0],
                                  MAX_IFS_NAME_LENGTH,
                                  &cvfName[0],
                                  MAX_IFS_NAME_LENGTH,
                                  &hostDriveName[0],
                                  MAX_IFS_NAME_LENGTH)) {
            // call worked, see if it is a double space volume

            if (compressed) {

                // now need to find this volume in the chain and
                // update it mounted state.

                for (dblSpace = DblChainBase;
                     dblSpace;
                     dblSpace = dblSpace->DblChainNext) {

                    for (index = 0;
                        compareName[index] = (WCHAR) dblSpace->FileName[index];
                        index++)  {
                        // Everything in for loop
                    }

                    if (!wcscmp(compareName, cvfName)) {

                        // found a match.

                        dblSpace->Mounted = TRUE;
                        dblSpace->DriveLetter = (UCHAR) driveLetter[0];
                    }
                }
            }
        }
    }
    SetErrorMode(errorMode);
}

VOID
DblSpaceInitialize(
    VOID
    )

/*++

Routine Description:

    This routine goes through the disk table and searches for FAT format
    partitions.  When one is found, it checks for the presense of DoubleSpace
    volumes and initializes the DoubleSpace support structures inside
    Disk Administrator.

Arguments:

    None

Return Value:

    None

--*/

{
    PDISKSTATE              diskState;
    PREGION_DESCRIPTOR      regionDesc;
    PPERSISTENT_REGION_DATA regionData;
    PDBLSPACE_DESCRIPTOR    dblSpace,
                            prevDblSpace;
    FILE                   *dblSpaceIniFile,
                           *dblSpaceFile;
    CHAR                    driveLetter[10];
    CHAR                    fileName[50];
    ULONG                   size,
                            mounted;
    int                     items;
    unsigned                diskIndex,
                            regionIndex;

    for (diskIndex = 0; diskIndex < DiskCount; diskIndex++) {

        diskState = Disks[diskIndex];
        regionDesc = diskState->RegionArray;
        for (regionIndex = 0; regionIndex < diskState->RegionCount; regionIndex++) {

            regionData = PERSISTENT_DATA(&regionDesc[regionIndex]);

            // region may be free or something that isn't recognized by NT

            if (!regionData) {
                continue;
            }

            // region may not be formatted yet.

            if (!regionData->TypeName) {
                continue;
            }

            // Double space volumes are only allowed on FAT non-FT partitions.

            if (regionData->FtObject) {
                continue;
            }

            if (wcscmp(regionData->TypeName, L"FAT") == 0) {
                WIN32_FIND_DATA findInformation;
                HANDLE          findHandle;

                // it is possible to have a double space volume here.
                // Search the root directory of the driver for files with
                // the name "dblspace.xxx".  These are potentially dblspace
                // volumes.

                prevDblSpace = NULL;
                sprintf(fileName, DblSpaceWildCardFileName, regionData->DriveLetter);
                findHandle = FindFirstFile(fileName, &findInformation);
                while (findHandle != INVALID_HANDLE_VALUE) {
                    char *cp;
                    int  i;
                    int  save;

                    // There is at least one dblspace volume.  Insure that
                    // the name is of the proper form.

                    save = TRUE;
                    cp = &findInformation.cFileName[0];

                    while (*cp) {
                        if (*cp == '.') {
                            break;
                        }
                        cp++;
                    }

                    if (*cp != '.') {

                        // not a proper dblspace volume name.

                        save = FALSE;
                    } else {

                        cp++;

                        for (i = 0; i < 3; i++, cp++) {
                            if ((*cp < '0') || (*cp > '9')) {
                                break;
                            }
                        }

                        if (i != 3) {

                            // not a proper dblspace volume name.

                            save = FALSE;
                        }
                    }

                    if (save) {

                        // save the information and search for more.

                        dblSpace =
                            DblSpaceCreateInternalStructure(' ',
                                                            ((findInformation.nFileSizeHigh << 16) |
                                                             (findInformation.nFileSizeLow)
                                                             / (1024 * 1024)),
                                                            &findInformation.cFileName[0],
                                                            TRUE);
                        if (dblSpace) {

                            // Assume volume is not mounted.

                            dblSpace->Mounted = FALSE;
                            dblSpace->ChangeMountState = FALSE;

                            // Chain in this description.

                            if (prevDblSpace) {
                                prevDblSpace->Next = dblSpace;
                            } else {
                                regionData->DblSpace = dblSpace;
                            }

                            // Keep the pointer to this one for the chain.

                            prevDblSpace = dblSpace;
                        } else {

                            // no memory

                            break;
                        }
                    }

                    if (!FindNextFile(findHandle, &findInformation)) {

                        // Technically this should double check and call
                        // GetLastError to see that it is ERROR_NO_MORE_FILES
                        // but this code doesn't do that.

                        FindClose(findHandle);

                        // Get out of the search loop.

                        findHandle = INVALID_HANDLE_VALUE;
                    }
                }
            }
        }
    }

    // Now that all volumes have been located determine which volumes
    // are mounted by chasing down the drive letters.

    LoadIfsDll();
    DblSpaceDetermineMounted();
}

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    This routine will check the RegionDescriptor to walk the DoubleSpace volume chain
    located from the persistent data.

Arguments:

    RegionDescriptor - pointer to the region on the disk that is to be searched for
                       a DoubleSpace volume.

    DblSpace - pointer to the last DoubleSpace volume located on the region.

Return Value:

    pointer to the next DoubleSpace volume if found
    NULL if no volume found.

--*/

{
    PPERSISTENT_REGION_DATA regionData;

    // If a previous DoubleSpace location was past, simply walk the chain to the next.

    if (DblSpace) {
        return DblSpace->Next;
    }

    // no previous DoubleSpace location, just get the first one and return it.
    // Could get a NULL RegionDescriptor.  If so, return NULL.

    if (RegionDescriptor) {
        regionData = PERSISTENT_DATA(RegionDescriptor);
        if (!regionData) {
            return NULL;
        }
    } else {
        return NULL;
    }
    return regionData->DblSpace;
}

VOID
DblSpaceLinkNewVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Chain the new double space volume on the list of double space volumes
    for the region.

Arguments:

    RegionDescriptor - the region the double space volume has been added to.
    DblSpace         - the new volume internal data structure.

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    prevDblSpace;

    // if this is the first one, chain it first

    if (!regionData->DblSpace) {
        regionData->DblSpace = DblSpace;
        return;
    }

    for (prevDblSpace = regionData->DblSpace;
        prevDblSpace->Next;
        prevDblSpace = prevDblSpace->Next) {

        // all the work is in the for
    }

    // found the last one.  Add the new one to the chain

    prevDblSpace->Next = DblSpace;
}

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Indicate to the caller if the input region contains a DoubleSpace volume.

Arguments:

    RegionDescriptor - a pointer to the region in question.

Return Value:

    TRUE if this region contains DoubleSpace volume(s).
    FALSE if not

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);

    if (regionData) {
        return(regionData->DblSpace ? TRUE : FALSE);
    }
    return FALSE;
}

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Indicate to the caller if the input region contains a DoubleSpace volume
    that is not mounted.

Arguments:

    RegionDescriptor - a pointer to the region in question.

Return Value:

    TRUE if this region contains DoubleSpace volume(s).
    FALSE if not

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;

    if (regionData) {
        if (dblSpace = regionData->DblSpace) {
            while (dblSpace) {
                if (!dblSpace->Mounted) {
                    return TRUE;
                }
                dblSpace = dblSpace->Next;
            }
        }
    }
    return FALSE;
}

PDBLSPACE_DESCRIPTOR
DblSpaceFindVolume(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN PCHAR Name
    )

/*++

Routine Description:

    Given a region and a name, locate the double space data structure.

Arguments:

    RegionDescriptor - the region to search
    Name - the filename wanted.

Return Value:

    A pointer to a double space descriptor if found.
    NULL if not found.

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace = NULL;
    PCHAR string[50];

    if (regionData) {
        for (dblSpace = regionData->DblSpace; dblSpace; dblSpace = dblSpace->Next) {
            if (strcmp(Name, dblSpace->FileName) == 0) {

                // found the desired double space volume

                break;
            }
        }
    }
    return dblSpace;
}


BOOL
DblSpaceDetermineUniqueFileName(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN PUCHAR             FileName
    )

/*++

Routine Description:

    This routine will search the actual partition to determine what
    valid double space file name to use (i.e. dblspace.xxx where xxx
    is a unique number).

Arguments:

    RegionDescriptor - the region to search and determine what double space
                       file names are in use.
    FileName   - a pointer to a character buffer for the name.

Return Value:

    None

--*/

{
    DWORD uniqueNumber = 0;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;

    do {
        sprintf(FileName, "dblspace.%03d", uniqueNumber++);
        if (uniqueNumber > 999) {
            return FALSE;
        }
    } while (DblSpaceFindVolume(RegionDescriptor, FileName));
    return TRUE;
}

VOID
DblSpaceRemoveVolume(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN UCHAR              DriveLetter
    )

/*++

Routine Description:

    Find the drive letter provided and unlink it from the chain.
    Currently this also removes the volume for the scaffolding file.

Arguments:

    RegionDescriptor - region containing the double space volume.
    DriveLetter - the drive letter to remove.

Return Value:

    None

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(RegionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace,
                            prevDblSpace = NULL;

    // Clean up the internal structures.

    if (regionData) {
        for (dblSpace = regionData->DblSpace; dblSpace; dblSpace = dblSpace->Next) {
            if (dblSpace->DriveLetter == DriveLetter) {

                // This is the one to delete

                if (prevDblSpace) {
                    prevDblSpace->Next = dblSpace->Next;
                } else {
                    regionData->DblSpace = dblSpace->Next;
                }
                free(dblSpace);
                break;
            }
            prevDblSpace = dblSpace;
        }
    }
}


BOOL CALLBACK
CreateDblSpaceDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This routine manages the dialog for the creation of a new double
    space volume.

Arguments:

    hDlg - the dialog box handle.
    wMsg - the message.
    wParam - the windows parameter.
    lParam - depends on message type.

Return Value:

    TRUE is returned back through windows if the create is successful
    FALSE otherwise

--*/
{
    PREGION_DESCRIPTOR      regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(regionDescriptor);
    PDBLSPACE_DESCRIPTOR    dblSpace;
    static FORMAT_PARAMS    formatParams;  // this is passed to other threads
                                           // it cannot be located on the stack
    static HWND             hwndCombo;
    static DWORD            sizeMB = 0,
                            maxSizeMB = 600,
                            minSizeMB = 10;
    TCHAR   outputString[50],
            driveLetterString[4], // big enough for "x:" string.
            sizeString[20],       // must be big enough for an 8.3 name
            letter;
    FILE   *dblspaceIniFile;
    DWORD   compressedSize,
            selection;
    BOOL    validNumber;
    CHAR    fileName[50];

    switch (wMsg) {
    case WM_INITDIALOG:

        // limit the size of string that may be entered for the label

        hwndCombo = GetDlgItem(hDlg, IDC_NAME);
        SendMessage(hwndCombo, EM_LIMITTEXT, 11, 0);

        // set up to watch all characters that go thru the size dialog
        // to allow only decimal numbers.

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_SIZE);
        OldSizeDlgProc = SetWindowLong(hwndCombo,
                                       GWL_WNDPROC,
                                       (LONG)&SizeDlgProc);

        // Add each available drive letter to the list of available
        // drive letters and set the default letter to the first available.

        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (letter='C'; letter <= 'Z'; letter++) {
            if (DriveLetterIsAvailable((CHAR)letter)) {
                *driveLetterString = letter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }
        SendMessage(hwndCombo,CB_SETCURSEL,0,0);

        // Setup the min/max values and the size box.

        wsprintf(outputString, TEXT("%u"), 0);
        SetDlgItemText(hDlg, IDC_DBLSPACE_SIZE, outputString);
        wsprintf(outputString, TEXT("%u"), minSizeMB);
        SetDlgItemText(hDlg, IDC_MINMAX_MIN, outputString);
        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hDlg, IDC_MINMAX_MAX, outputString);
        CenterDialog(hDlg);
        return TRUE;

    case WM_VSCROLL:
    {
        switch (LOWORD(wParam)) {
        case SB_LINEDOWN:
        case SB_LINEUP:

            // user is pressing one of the scroll buttons.

            sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
            if (sizeMB < minSizeMB) {
                sizeMB = minSizeMB + 1;
            }

            if (sizeMB > maxSizeMB) {
                sizeMB = maxSizeMB - 1;
            }

            if (((sizeMB > minSizeMB) && (LOWORD(wParam) == SB_LINEDOWN))
             || ((sizeMB < maxSizeMB) && (LOWORD(wParam) == SB_LINEUP  ))) {
                if (sizeMB > maxSizeMB) {
                    sizeMB = maxSizeMB;
                } else if (LOWORD(wParam) == SB_LINEUP) {
                    sizeMB++;
                } else {
                    sizeMB--;
                }
                SetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, sizeMB, FALSE);
                SendDlgItemMessage(hDlg, IDC_DBLSPACE_SIZE, EM_SETSEL, 0, -1);
#if 0
                compressedSize = sizeMB * 2;
                wsprintf(outputString, TEXT("%u"), compressedSize);
                SetDlgItemText(hDlg, IDC_DBLSPACE_COMPRESSED, outputString);
#endif
            } else {
                Beep(500,100);
            }
        }
        break;
    }

    case WM_COMMAND:
        switch (wParam) {
        case FD_IDHELP:
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // can only do this if the fmifs dll supports double space.

            if (!DoubleSpaceSupported) {

                // could not load the dll

                ErrorDialog(MSG_CANT_LOAD_FMIFS);
                EndDialog(hDlg, FALSE);
                break;
            }

            // Get the current size for this volume.

            sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
            if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
                ErrorDialog(MSG_INVALID_SIZE);
                EndDialog(hDlg, FALSE);
                break;
            }

            // Get the currently selected item in the listbox for drive letter

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo, CB_GETLBTEXT, selection, (LONG)driveLetterString);

            formatParams.RegionDescriptor = regionDescriptor;
            formatParams.RegionData       = regionData;
            formatParams.FileSystem       = NULL;
            formatParams.DblspaceFileName = NULL;
            formatParams.QuickFormat      = formatParams.Cancel = FALSE;
            formatParams.DoubleSpace      = TRUE;
            formatParams.TotalSpace       = 0;
            formatParams.SpaceAvailable   = sizeMB;
            formatParams.NewLetter        = driveLetterString[0];

            // get the label

            formatParams.Label = (PUCHAR) malloc(100);
            GetDlgItemText(hDlg, IDC_NAME, (LPTSTR)formatParams.Label, 100);

            DialogBoxParam(hModule,
                           MAKEINTRESOURCE(IDD_DBLSPACE_CANCEL),
                           hwndFrame,
                           CancelDlgProc,
                           (ULONG) &formatParams);
            if (formatParams.Result) {

                // the format failed.

                ErrorDialog(formatParams.Result);
                EndDialog(hDlg, FALSE);
            } else {
                ULONG index;
                TCHAR message[300],
                      msgProto[300],
                      title[200];

                // save the name

                if (formatParams.DblspaceFileName) {
                    for (index = 0;
                         message[index] = (TCHAR) formatParams.DblspaceFileName[index];
                         index++) {
                    }
                } else {
                    sprintf(message, "DIDNTWORK");
                }
                free(formatParams.DblspaceFileName);

                dblSpace = DblSpaceCreateInternalStructure(*driveLetterString,
                                                           sizeMB,
                                                           message,
                                                           FALSE);
                if (dblSpace) {
                    DblSpaceLinkNewVolume(regionDescriptor, dblSpace);
                    MarkDriveLetterUsed(dblSpace->DriveLetter);
                    dblSpace->Mounted = TRUE;
                }

                LoadString(hModule,
                           IDS_DBLSPACECOMPLETE,
                           title,
                           sizeof(title)/sizeof(TCHAR));
                LoadString(hModule,
                           IDS_FORMATSTATS,
                           msgProto,
                           sizeof(msgProto)/sizeof(TCHAR));
                wsprintf(message,
                         msgProto,
                         formatParams.TotalSpace,
                         formatParams.SpaceAvailable);
                MessageBox(GetActiveWindow(),
                           message,
                           title,
                           MB_ICONINFORMATION | MB_OK);

                EndDialog(hDlg, TRUE);
            }

            break;

        default:

            if (HIWORD(wParam) == EN_CHANGE) {

                // The size value has changed.  Update the compressed
                // size value displayed to the user.

                sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
                if (!validNumber) {
                    sizeMB = 0;
                }

            }
            break;
        }
        break;

    case WM_DESTROY:

        // restore original subclass to window.

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_SIZE);
        SetWindowLong(hwndCombo, GWL_WNDPROC, (LONG) OldSizeDlgProc);
        break;

    case WM_PAINT:

        // This may be dead code that really isn't needed.

        sizeMB = GetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, &validNumber, FALSE);
        if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
            return FALSE;
        }

        SetDlgItemInt(hDlg, IDC_DBLSPACE_SIZE, sizeMB, FALSE);
        SendDlgItemMessage(hDlg, IDC_DBLSPACE_SIZE, EM_SETSEL, 0, -1);
        break;
    }
    return FALSE;
}

VOID
DblSpaceDelete(
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Start the dialog box for the deletion of a double space volume.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR      regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(regionDescriptor);

    if (ConfirmationDialog(MSG_CONFIRM_DBLSPACE_DELETE, MB_ICONQUESTION | MB_YESNOCANCEL) == IDYES) {

        // Delete the drive from view

        DblSpaceRemoveVolume(regionDescriptor, DblSpace->DriveLetter);
        DblSpaceUpdateIniFile(regionDescriptor);
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
}

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the dialog box for the creation of a double space volume.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    BOOLEAN result = 0;

    result = DialogBoxParam(hModule,
                            MAKEINTRESOURCE(IDD_DBLSPACE_CREATE),
                            Dialog,
                            CreateDblSpaceDlgProc,
                            (ULONG) NULL);
    if (result) {
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
    return result;
}

BOOL CALLBACK
DblSpaceMountDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle the dialog for double space.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    static PDBLSPACE_DESCRIPTOR dblSpace;
    HWND                        hwndCombo;
    DWORD                       selection;
    CHAR                        driveLetter;
    TCHAR                       driveLetterString[20];

    switch (wMsg) {
    case WM_INITDIALOG:

        dblSpace = (PDBLSPACE_DESCRIPTOR) lParam;

        // Update the drive letter selections.

        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);

        // Add all other available letters.  Keep track of current
        // letters offset to set the cursor correctly

        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
            if (DriveLetterIsAvailable((CHAR)driveLetter) ||
                (driveLetter == dblSpace->DriveLetter)) {

                *driveLetterString = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }

        // set the current selection to the appropriate index

        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DOUBLESPACE_MOUNT);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // User has selected the drive letter and wants the mount to occur.

            hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)driveLetterString);
            dblSpace->NewDriveLetter = (UCHAR) driveLetterString[0];
            EndDialog(hDlg, TRUE);
            break;
        }
    }

    return FALSE;
}

VOID
DblSpaceSetDialogState(
    IN HWND                 hDlg,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )

/*++

Routine Description:

    Given a double space volume this routine will update the buttons
    in the dialog box to reflect they meaning.

Arguments:

    hDlg - dialog handle
    DblSpace - The double space volume selection for determining dialog state.

Return Value

    None

--*/

{
    TCHAR outputString[200];

    if (DblSpace->Mounted) {

        LoadString(hModule,
                   IDS_DBLSPACE_MOUNTED,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, IDC_MOUNT_STATE, outputString);
        LoadString(hModule,
                   IDS_DISMOUNT,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);

        outputString[1] = TEXT(':');
        outputString[2] = 0;
        outputString[0] = DblSpace->DriveLetter;
        SetDlgItemText(hDlg, IDC_DBLSPACE_LETTER, outputString);
    } else {
        LoadString(hModule,
                   IDS_DBLSPACE_DISMOUNTED,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, IDC_MOUNT_STATE, outputString);
        LoadString(hModule,
                   IDS_MOUNT,
                   outputString,
                   sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);

        outputString[1] = TEXT(' ');
        outputString[2] = 0;
        outputString[0] = TEXT(' ');
        SetDlgItemText(hDlg, IDC_DBLSPACE_LETTER, outputString);
    }
}

BOOL CALLBACK
DblSpaceDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle the dialog for double space.

Arguments:

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    static HWND hwndCombo,
                mountButtonHwnd,
                deleteButtonHwnd;
    static PREGION_DESCRIPTOR      regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    static PDBLSPACE_DESCRIPTOR    firstDblSpace;
    CHAR                           driveLetter;
    PDBLSPACE_DESCRIPTOR           dblSpace;
    TCHAR                          outputString[200];
    DWORD                          selection;
    BOOLEAN                        result;
    ULONG                          errorMessage;
    DRAWITEMSTRUCT                 drawItem;

    switch (wMsg) {
    case WM_INITDIALOG:

        regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
        regionData = PERSISTENT_DATA(regionDescriptor);

        hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
        mountButtonHwnd = GetDlgItem(hDlg, ID_MOUNT_OR_DISMOUNT);
        deleteButtonHwnd = GetDlgItem(hDlg, IDDELETE);

        // place all double space file names in the selection
        // box and remember the first name.

        firstDblSpace = dblSpace = DblSpaceGetNextVolume(regionDescriptor, NULL);
        for (; dblSpace;
               dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {
            wsprintf(outputString, TEXT("%s"), dblSpace->FileName);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)outputString);
        }
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

        // add the drive letter

        if (firstDblSpace) {

            // update the allocated size.

            wsprintf(outputString, TEXT("%u"), firstDblSpace->AllocatedSize);
            SetDlgItemText(hDlg, IDC_DBLSPACE_ALLOCATED, outputString);

            // update mount state

            DblSpaceSetDialogState(hDlg, firstDblSpace);
            EnableWindow(mountButtonHwnd, TRUE);
            EnableWindow(deleteButtonHwnd, TRUE);
        } else {

            // update the Mount/Dismount button to say mount and grey it

            LoadString(hModule,
                       IDS_MOUNT,
                       outputString,
                       sizeof(outputString)/sizeof(TCHAR));
            SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);
            EnableWindow(mountButtonHwnd, FALSE);
            EnableWindow(deleteButtonHwnd, FALSE);
        }
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DOUBLESPACE);
            break;

        case IDCANCEL:

            // Run the dblspace change and forget about any changes.

            for (dblSpace = firstDblSpace;
                 dblSpace;
                 dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {
                 dblSpace->ChangeMountState = FALSE;
                 dblSpace->NewDriveLetter = 0;
            }
            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            EndDialog(hDlg, TRUE);
            break;

        case IDADD:

            DblSpaceCreate(hDlg, NULL);
            break;

        case IDDELETE:

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {
                break;
            }

            DblSpaceDelete(dblSpace);
            break;

        case ID_MOUNT_OR_DISMOUNT:

            // The state of something in the dialog changed.
            // Determine which double space volume is involved.

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {
                break;
            }

            if (dblSpace->Mounted) {

                // dismount the volume

                errorMessage = DblSpaceDismountDrive(regionDescriptor,
                                                     dblSpace);

                if (errorMessage) {
                    ErrorDialog(errorMessage);
                } else {

                    // Update the dialog

                    DblSpaceSetDialogState(hDlg, dblSpace);
                    DblSpaceUpdateIniFile(regionDescriptor);
                }

            } else {

                // mount the volume unless the user cancels out

                result = DialogBoxParam(hModule,
                                        MAKEINTRESOURCE(IDD_DBLSPACE_DRIVELET),
                                        hwndFrame,
                                        DblSpaceMountDlgProc,
                                        (ULONG) dblSpace);
                if (result) {

                    errorMessage = DblSpaceMountDrive(regionDescriptor, dblSpace);

                    if (errorMessage) {
                        ErrorDialog(errorMessage);
                    } else {

                        // Update the dialog

                        DblSpaceSetDialogState(hDlg, dblSpace);
                        DblSpaceUpdateIniFile(regionDescriptor);
                    }
                }
            }
            DrawDiskBar(SingleSel);
            ForceLBRedraw();
            break;

        default:

            // The state of something in the dialog changed.
            // Determine which double space volume is involved.

            hwndCombo = GetDlgItem(hDlg, IDC_DBLSPACE_VOLUME);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)outputString);

            // relate the name to a double space volume

            dblSpace = DblSpaceFindVolume(regionDescriptor, (PCHAR)outputString);
            if (!dblSpace) {

                // update the Mount/Dismount button to say mount and grey it

                LoadString(hModule,
                           IDS_MOUNT,
                           outputString,
                           sizeof(outputString)/sizeof(TCHAR));
                SetDlgItemText(hDlg, ID_MOUNT_OR_DISMOUNT, outputString);
                EnableWindow(mountButtonHwnd, FALSE);
                EnableWindow(deleteButtonHwnd, FALSE);
                break;
            } else {
                EnableWindow(mountButtonHwnd, TRUE);
                EnableWindow(deleteButtonHwnd, TRUE);
            }
            if (HIWORD(wParam) == LBN_SELCHANGE) {

                // update the allocated/compressed size items

                wsprintf(outputString, TEXT("%u"), dblSpace->AllocatedSize);
                SetDlgItemText(hDlg, IDC_DBLSPACE_ALLOCATED, outputString);
#if 0
                wsprintf(outputString, TEXT("%u"), dblSpace->AllocatedSize * 2);
                SetDlgItemText(hDlg, IDC_DBLSPACE_COMPRESSED, outputString);
                wsprintf(outputString, TEXT("%u.%u"), 2, 0);
                SetDlgItemText(hDlg, IDC_DBLSPACE_RATIO, outputString);
#endif

                // update mount state

                DblSpaceSetDialogState(hDlg, dblSpace);
            }

            break;
        }
        break;
    }
    return FALSE;
}

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the dialog box for double space.

Arguments:

    Param - not currently used.

Return Value:

    None

--*/

{
    BOOLEAN result;

    if (IsFullDoubleSpace) {
        result = DialogBoxParam(hModule,
                                MAKEINTRESOURCE(IDD_DBLSPACE_FULL),
                                Dialog,
                                DblSpaceDlgProc,
                                (ULONG) NULL);

    } else {
        result = DialogBoxParam(hModule,
                                MAKEINTRESOURCE(IDD_DBLSPACE),
                                Dialog,
                                DblSpaceDlgProc,
                                (ULONG) NULL);
    }
    if (result) {
        DrawDiskBar(SingleSel);
        ForceLBRedraw();
    }
}
#else

// STUBS for easy removal of DoubleSpace support.

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )
{
    return FALSE;
}

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    )
{
    return FALSE;
}

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    )
{
    return FALSE;
}

VOID
DblSpaceDelete(
    IN PVOID Param
    )
{
}

VOID
DblSpaceMount(
    IN PVOID Param
    )
{
}

VOID
DblSpaceDismount(
    IN PVOID Param
    )
{
}

VOID
DblSpaceInitialize(
    VOID
    )
{
}

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    )
{
}

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    )
{
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\cdrom.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    cdrom.c

Abstract:

    This module contains the set of routines that display and control the
    drive letters for CdRom devices.

Author:

    Bob Rinne (bobri)  12/9/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <string.h>
#include <stdio.h>
#include <wchar.h>
#include <malloc.h>

PCDROM_DESCRIPTOR CdRomChainBase = NULL;
PCDROM_DESCRIPTOR CdRomChainLast = NULL;
PCDROM_DESCRIPTOR CdRomChanged = NULL;

static BOOLEAN CdRomFirstCall = TRUE;
static TCHAR   SourcePathLetter = (TCHAR) '\0';
static TCHAR   SourcePathKeyName[80];
static TCHAR   SourcePathValueName[30];

VOID
CdRomAddDevice(
    IN PWSTR NtName,
    IN WCHAR DriveLetter
    )

/*++

Routine Description:

    Build a cdrom description structure for this and fill it in.

Arguments:

    NtName - The unicode name for the device.
    DriveLetter - The DosDevice name.

Return Value:

    None

--*/

{
    PCDROM_DESCRIPTOR cdrom;
    PWCHAR            cp;
    LONG              error;
    HKEY              keyHandle;
    DWORD             valueType;
    ULONG             size;
    TCHAR            *string;

    if (CdRomFirstCall) {
        CdRomFirstCall = FALSE;

        // Get the registry path and value name.

        LoadString(hModule,
                   IDS_SOURCE_PATH,
                   SourcePathKeyName,
                   sizeof(SourcePathKeyName)/sizeof(TCHAR));
        LoadString(hModule,
                   IDS_SOURCE_PATH_NAME,
                   SourcePathValueName,
                   sizeof(SourcePathValueName)/sizeof(TCHAR));

        error = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SourcePathKeyName,
                             &keyHandle);
        if (error == NO_ERROR) {
            error = RegQueryValueEx(keyHandle,
                                    SourcePathValueName,
                                    NULL,
                                    &valueType,
                                    (PUCHAR)NULL,
                                    &size);

            if (error == NO_ERROR) {
                string = (PUCHAR) LocalAlloc(LMEM_FIXED, size);
                if (string) {
                    error = RegQueryValueEx(keyHandle,
                                            SourcePathValueName,
                                            NULL,
                                            &valueType,
                                            string,
                                            &size);
                    if (error == NO_ERROR) {
                        SourcePathLetter = *string;
                    }
                }
                LocalFree(string);
            }
            RegCloseKey(keyHandle);
        }
    }

    cdrom = (PCDROM_DESCRIPTOR) malloc(sizeof(CDROM_DESCRIPTOR));
    if (cdrom) {
        cdrom->DeviceName = (PWSTR) malloc((wcslen(NtName)+1)*sizeof(WCHAR));
        if (cdrom->DeviceName) {
            wcscpy(cdrom->DeviceName, NtName);
            cp = cdrom->DeviceName;
            while (*cp) {
                if (iswdigit(*cp)) {
                    break;
                }
                cp++;
            }

            if (*cp) {
                cdrom->DeviceNumber = wcstoul(cp, (WCHAR) 0, 10);
            }
            cdrom->DriveLetter = DriveLetter;
            cdrom->Next = NULL;
            cdrom->NewDriveLetter = (WCHAR) 0;
            if (CdRomChainBase) {
                CdRomChainLast->Next = cdrom;
            } else {
                AllowCdRom = TRUE;
                CdRomChainBase = cdrom;
            }
            CdRomChainLast = cdrom;
        } else {
            free(cdrom);
        }
    }
}


BOOL CALLBACK
CdRomDlgProc(
    IN HWND hDlg,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle the dialog for CD-ROMS

Arguments:

    Standard Windows dialog procedure

Return Value:

    TRUE if something was deleted.
    FALSE otherwise.

--*/

{
    HWND   hwndCombo;
    DWORD  selection;
    DWORD  index;
    CHAR   driveLetter;
    TCHAR  string[40];
    PCDROM_DESCRIPTOR cdrom;
    static PCDROM_DESCRIPTOR currentCdrom;
    static CHAR              currentSelectionLetter;

    switch (wMsg) {
    cas