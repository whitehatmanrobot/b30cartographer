-------------------------------------------------------------

SYNC_COUNTER::SYNC_COUNTER () {

	CounterValue = 0;
	ZeroEvent =  NULL;
}

SYNC_COUNTER::~SYNC_COUNTER () {

}

HRESULT SYNC_COUNTER::Start (void)
{
	HRESULT Result = S_OK;

	assert (ZeroEvent == NULL);

	CounterValue = 1;

	ZeroEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

	if (!ZeroEvent) {

		Result = GetLastError ();

		DebugLastError (_T("SYNC_COUNTER::SYNC_COUNTER: failed to create zero event\n"));
	}

#if ENABLE_REFERENCE_HISTORY
	Lock ();

	InitializeListHead (&ActiveLifetimeControllers);

	Unlock ();
#endif // ENABLE_REFERENCE_HISTORY

	return Result;
}

void SYNC_COUNTER::Stop () {

	if (ZeroEvent) {
		CloseHandle (ZeroEvent);
		ZeroEvent = NULL;
	}
}

DWORD SYNC_COUNTER::Wait (DWORD Timeout)
{
	if (!ZeroEvent) {
		Debug (_T("SYNC_COUNTER::Wait: cannot wait because zero event could not be created\n"));
		return ERROR_GEN_FAILURE;
	}

	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	}

	Unlock ();

#if	DBG

	if (Timeout == INFINITE) {

		DWORD	Status;

		for (;;) {

			Status = WaitForSingleObject (ZeroEvent, 5000);

			if (Status == WAIT_OBJECT_0)
				return ERROR_SUCCESS;

            assert (Status == WAIT_TIMEOUT);

			DebugF (_T("SYNC_COUNTER::Wait: thread %08XH is taking a long time to wait for sync counter, counter value (%d)\n"),
				GetCurrentThreadId(), CounterValue);
		}
	}
	else
		return WaitForSingleObject (ZeroEvent, Timeout);


#else

	return WaitForSingleObject (ZeroEvent, Timeout);

#endif
}

void SYNC_COUNTER::Increment (void)
{
	Lock();

	CounterValue++;

	Unlock();
}

void SYNC_COUNTER::Decrement (void)
{
	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	} 

	Unlock();
}



EXTERN_C void MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source)
{
	PLIST_ENTRY		Entry;

	// for now, we do a poor algorithm -- remove and insert every single object

	AssertListIntegrity (Source);
	AssertListIntegrity (Result);

	while (!IsListEmpty (Source)) {
		Entry = RemoveHeadList (Source);
		assert (!IsInList (Result, Entry));
		InsertTailList (Result, Entry);
	}
}

// check to see if entry is in list
EXTERN_C BOOL IsInList (LIST_ENTRY * List, LIST_ENTRY * Entry)
{
	LIST_ENTRY *	Pos;

	AssertListIntegrity (List);

	for (Pos = List -> Flink; Pos != List; Pos = Pos -> Flink)
		if (Pos == Entry)
			return TRUE;

	return FALSE;
}

EXTERN_C void ExtractList (LIST_ENTRY * Destination, LIST_ENTRY * Source)
{
	AssertListIntegrity (Source);

	InsertTailList (Source, Destination);
	RemoveEntryList (Source);
	InitializeListHead (Source);
}

EXTERN_C DWORD CountListLength (LIST_ENTRY * ListHead)
{
	LIST_ENTRY *	ListEntry;
	DWORD			Count;

	assert (ListHead);
	AssertListIntegrity (ListHead);

	Count = 0;

	for (ListEntry = ListHead -> Flink; ListEntry != ListHead; ListEntry++)
		Count++;

	return Count;
}

void AssertListIntegrity (LIST_ENTRY * list)
{
	LIST_ENTRY *	entry;

	assert (list);
	assert (list -> Flink -> Blink == list);
	assert (list -> Blink -> Flink == list);

	for (entry = list -> Flink; entry != list; entry = entry -> Flink) {
		assert (entry);
		assert (entry -> Flink -> Blink == entry);
		assert (entry -> Blink -> Flink == entry);
	}
}

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString)
{
//	assert (SourceString);
//	assert (SourceString -> Buffer);
	assert (DestString);

	if (SourceString) {

		// it's really SourceString -> Length, not * sizeof (CHAR), so don't change it
		DestString -> Buffer = (LPSTR) HeapAlloc (GetProcessHeap(), 0, SourceString -> Length);

		if (DestString -> Buffer) {

			memcpy (DestString -> Buffer, SourceString -> Buffer, SourceString -> Length);

			// yes, maxlen = len, not maxlen = maxlen
			DestString -> MaximumLength = SourceString -> Length;
			DestString -> Length = SourceString -> Length;

			return STATUS_SUCCESS;
		}
		else {
			ZeroMemory (DestString, sizeof (ANSI_STRING));

			return STATUS_NO_MEMORY;
		}
	}
	else {
		DestString -> Buffer = NULL;
		DestString -> MaximumLength = 0;
		DestString -> Length = 0;
		
		return STATUS_SUCCESS;
	}
}

void FreeAnsiString (
	IN	ANSI_STRING *	String)
{
	assert (String);

	if (String -> Buffer) {
		HeapFree (GetProcessHeap(), 0, String -> Buffer);
		String -> Buffer = NULL;
	}
}


#if DBG

void ExposeTimingWindow (void) 
{
#if 0
	// this is here mostly to catch bug #393393, a/v on shutdown (race condition) -- arlied

	Debug (_T("H323: waiting for 10s to expose race condition... (expect assertion failure on NatHandle)\n"));

	DWORD Count;

	for (Count = 0; Count < 10; Count++) {
		assert (NatHandle);
		Sleep (1000);

	}

	Debug (_T("H323: finished waiting for race condition, looks normal...\n"));
#endif
}
#endif

/*++

Routine Description:
    Get the address of the best interface that
    will be used to connect to the address specified.
    
Arguments:
    DestinationAddress (IN) - address to be connected to, host order
    InterfaceAddress  (OUT) - address of the interface that
                              will be used for connection, host order
    
Return Values:
    Win32 error specifying the outcome of the request
    
Notes:

    Tries to use UDP-connect procedure to find the address of the interface
    If the procedure fails, then tries an alternative way of consulting
    the routing table, with GetBestInterface.

--*/
ULONG GetBestInterfaceAddress (
    IN DWORD DestinationAddress, // host order
    OUT DWORD * InterfaceAddress)  // host order
{

    SOCKET UDP_Socket;
    ULONG Error; 
    SOCKADDR_IN         ClientAddress;
    SOCKADDR_IN         LocalToClientAddress;
    INT                 LocalToClientAddrSize = sizeof (SOCKADDR_IN);

    Error = S_OK;

    ClientAddress.sin_addr.s_addr = htonl (DestinationAddress); 
    ClientAddress.sin_port        = htons (0);
    ClientAddress.sin_family      = AF_INET;

    UDP_Socket = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (UDP_Socket == INVALID_SOCKET){

        Error = WSAGetLastError ();
         
        DebugLastError (_T("GetBestInterfaceAddress: failed to create UDP socket.\n"));

    } else {

        if (SOCKET_ERROR != connect (UDP_Socket, (PSOCKADDR)&ClientAddress, sizeof (SOCKADDR_IN))) {

            LocalToClientAddrSize = sizeof (SOCKADDR_IN);

            if (!getsockname (UDP_Socket, (struct sockaddr *)&LocalToClientAddress, &LocalToClientAddrSize)) {

                *InterfaceAddress = ntohl (LocalToClientAddress.sin_addr.s_addr);

                Error = ERROR_SUCCESS;

            } else {

                Error = WSAGetLastError ();

                DebugLastError (_T("GetBestInterfaceAddress: failed to get name of UDP socket.\n"));
            }

        } else {

            Error = WSAGetLastError ();

            DebugLastError (_T("GetBestInterfaceAddress: failed to connect UDP socket."));
        }

        closesocket (UDP_Socket);
        UDP_Socket = INVALID_SOCKET;
    } 

    return Error; 
}


DWORD
H323MapAdapterToAddress (
    IN DWORD AdapterIndex
    )

/*++

Routine Description:

    This routine is invoked to map an adapter index to an IP address.
    It does so by obtaining the stack's address table, and then linearly
    searching through it trying to find an entry with matching adapter
    index. If found, the entry is then used to obtain the IP address
    corresponding to the adapter index.

Arguments:

    AdapterIndex - Index of a local adapter for which an IP address is requested

Return Value:

    DWORD - IP address (in host order)

    If the routine succeeds, the return value will be a valid IP address
    If the routine fails, the return value will be INADDR_NONE

--*/

{
    DWORD Address = htonl (INADDR_NONE);
    ULONG Index;
    PMIB_IPADDRTABLE Table;

    if (AllocateAndGetIpAddrTableFromStack (
            &Table, FALSE, GetProcessHeap (), 0
            ) == NO_ERROR) {

        for (Index = 0; Index < Table -> dwNumEntries; Index++) {

            if (Table -> table[Index].dwIndex != AdapterIndex) {

                 continue;

            }

            Address = Table -> table [Index].dwAddr;

            break;
        }

        HeapFree (GetProcessHeap (), 0, Table);
    }

    return ntohl (Address);
} // H323MapAddressToAdapter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\algif.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    AlgIF.c

Abstract:

    This module contains code for the ALG transparent proxy's interface
    management.

Author:

    Qiang Wang  (qiangw)        10-April-2000

Revision History:

    Savasg      22-Aug-2001 Added RRAS Support

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

#include <atlbase.h>
#include <MyTrace.h>


extern HRESULT
GetAlgControllerInterface(
    IAlgController** ppAlgController
    );


//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY AlgInterfaceList;
CRITICAL_SECTION AlgInterfaceLock;
ULONG AlgFirewallIfCount;



ULONG
AlgBindInterface(
                ULONG Index,
                PIP_ADAPTER_BINDING_INFO BindingInfo
                )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    ULONG i;
    ULONG Error = NO_ERROR;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgBindInterface");

    EnterCriticalSection(&AlgInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgBindInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (ALG_INTERFACE_BOUND(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgBindInterface: interface %d is already bound",
               Index
               );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgBindInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= ALG_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&AlgInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount)
    {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    } else
    {
        Interfacep->BindingArray =
        reinterpret_cast<PALG_BINDING>(
                                      NH_ALLOCATE(BindingInfo->AddressCount * sizeof(ALG_BINDING))
                                      );
        if (!Interfacep->BindingArray)
        {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                   TRACE_FLAG_IF,
                   "AlgBindInterface: allocation failed for interface %d binding",
                   Index
                   );
            NhErrorLog(
                      IP_ALG_LOG_ALLOCATION_FAILED,
                      0,
                      "%d",
                      BindingInfo->AddressCount * sizeof(ALG_BINDING)
                      );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(
                  Interfacep->BindingArray,
                  BindingInfo->AddressCount * sizeof(ALG_BINDING)
                  );
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++)
    {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
    }

    //
    // Figure out our IP Adapter Index, if we have a valid binding
    //

    if (Interfacep->BindingCount)
    {
        Interfacep->AdapterIndex =
        NhMapAddressToAdapter(BindingInfo->Address[0].Address);
    }

    if (ALG_INTERFACE_ACTIVE( Interfacep ))
    {
        Error = AlgActivateInterface( Interfacep );
    }

    RELEASE_LOCK(Interfacep);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgBindInterface



VOID
AlgCleanupInterface(
                   PALG_INTERFACE Interfacep
                   )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Notes:

    Invoked internally from an arbitrary context, with no references
    to the interface.

--*/
{
    PROFILE("AlgCleanupInterface");

    if (Interfacep->BindingArray)
    {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // AlgCleanupInterface


ULONG
AlgConfigureInterface(
                     ULONG Index,
                     PIP_ALG_INTERFACE_INFO InterfaceInfo
                     )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.
    Since we're  tracking the interfaces as is, not for any other purpose,
    we're not enabling/disabling and/or activating them like the other modules
    do.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Notes:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    ULONG Error;
    PALG_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("AlgConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgConfigureInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgConfigureInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags = (InterfaceInfo ? 
                (InterfaceInfo->Flags|ALG_INTERFACE_FLAG_CONFIGURED) : 
                 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo)
    {
        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled...
        //

        if ( OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED )
        {
            //
            // Activate the interface if necessary.
            // 
            if ( ALG_INTERFACE_ACTIVE( Interfacep ) )
            {
                RELEASE_LOCK( Interfacep );

                Error = AlgActivateInterface( Interfacep );

                ACQUIRE_LOCK( Interfacep );
            }
        }

    } 
    else
    {
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //
        if (( OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_ALG_INTERFACE_FLAG_DISABLED)
           )
        {
            //
            // Activate the interface
            //
            if (ALG_INTERFACE_ACTIVE(Interfacep))
            {
                RELEASE_LOCK(Interfacep);
                Error = AlgActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        } 
        else if (!(OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED) &&
                  (NewFlags & IP_ALG_INTERFACE_FLAG_DISABLED)
                )
        {
            //
            // Deactivate the interface if necessary
            //
            if (ALG_INTERFACE_ACTIVE(Interfacep))
            {
                AlgDeactivateInterface(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgConfigureInterface


ULONG
AlgCreateInterface(
                  ULONG Index,
                  NET_INTERFACE_TYPE Type,
                  PIP_ALG_INTERFACE_INFO InterfaceInfo,
                  OUT PALG_INTERFACE* InterfaceCreated
                  )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the ALG transparent proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    PLIST_ENTRY InsertionPoint;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgCreateInterface");

    EnterCriticalSection(&AlgInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (AlgLookupInterface(Index, &InsertionPoint))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgCreateInterface: duplicate index found for %d",
               Index
               );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep =
    reinterpret_cast<PALG_INTERFACE>(NH_ALLOCATE(sizeof(ALG_INTERFACE)));

    if (!Interfacep)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF, "AlgCreateInterface: error allocating interface"
               );
        NhErrorLog(
                  IP_ALG_LOG_ALLOCATION_FAILED,
                  0,
                  "%d",
                  sizeof(ALG_INTERFACE)
                  );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo)
    {
        Interfacep->Flags = InterfaceInfo->Flags|ALG_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InitializeListHead(&Interfacep->ConnectionList);
    InitializeListHead(&Interfacep->EndpointList);
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&AlgInterfaceLock);

    if (InterfaceCreated)
    {
        *InterfaceCreated = Interfacep;
    }

    return NO_ERROR;

} // AlgCreateInterface



ULONG
AlgDeleteInterface(
                  ULONG Index
                  )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgDeleteInterface");


    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&AlgInterfaceLock);


    Interfacep = AlgLookupInterface(Index, NULL);


    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);

        NhTrace(
               TRACE_FLAG_IF,
               "AlgDeleteInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Mark the interface as deleted and take it off the interface list
    //
    Interfacep->Flags |= ALG_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~ALG_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Deactivate the Interface
    //
    AlgDeactivateInterface( Interfacep );

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //
    if (--Interfacep->ReferenceCount)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgDeleteInterface: interface %d deletion pending",
               Index
               );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //
    AlgCleanupInterface(Interfacep);

    LeaveCriticalSection(&AlgInterfaceLock);

    return NO_ERROR;

} // AlgDeleteInterface


ULONG
AlgDisableInterface(
                   ULONG Index
                   )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgDisableInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!ALG_INTERFACE_ENABLED(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgDisableInterface: interface %d already disabled",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgDisableInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~ALG_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the Interface, if necessary
    //
    if ( ALG_INTERFACE_BOUND(Interfacep) )
    {
        AlgDeactivateInterface( Interfacep );
    }


    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // AlgDisableInterface


ULONG
AlgEnableInterface(
                  ULONG Index
                  )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    ULONG Error = NO_ERROR;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgEnableInterface");


    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgEnableInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (ALG_INTERFACE_ENABLED(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgEnableInterface: interface %d already enabled",
               Index
               );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgEnableInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= ALG_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //
    if ( ALG_INTERFACE_ACTIVE( Interfacep ) )
    {
        Error = AlgActivateInterface( Interfacep );
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgEnableInterface


ULONG
AlgInitializeInterfaceManagement(
                                VOID
                                )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    ULONG Error = NO_ERROR;
    PROFILE("AlgInitializeInterfaceManagement");

    InitializeListHead(&AlgInterfaceList);
    __try {
        InitializeCriticalSection(&AlgInterfaceLock);
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NhTrace(
               TRACE_FLAG_IF,
               "AlgInitializeInterfaceManagement: exception %d creating lock",
               Error = GetExceptionCode()
               );
    }
    AlgFirewallIfCount = 0;

    return Error;

} // AlgInitializeInterfaceManagement


PALG_INTERFACE
AlgLookupInterface(
                  ULONG Index,
                  OUT PLIST_ENTRY* InsertionPoint OPTIONAL
                  )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PALG_INTERFACE - the interface, if found; otherwise, NULL.

Notes:

    Invoked internally from an arbitrary context, with 'AlgInterfaceLock'
    held by caller.

--*/
{
    PALG_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("AlgLookupInterface");
    for (Link = AlgInterfaceList.Flink; Link != &AlgInterfaceList;
        Link = Link->Flink)
    {
        Interfacep = CONTAINING_RECORD(Link, ALG_INTERFACE, Link);
        if (Index > Interfacep->Index)
        {
            continue;
        } else if (Index < Interfacep->Index)
        {
            break;
        }
        return Interfacep;
    }
    if (InsertionPoint)
    {
        *InsertionPoint = Link;
    }
    return NULL;

} // AlgLookupInterface


ULONG
AlgQueryInterface(
                 ULONG Index,
                 PVOID InterfaceInfo,
                 PULONG InterfaceInfoSize
                 )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/
{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgQueryInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgQueryInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!ALG_INTERFACE_CONFIGURED(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgQueryInterface: interface %d has no configuration",
               Index
               );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_ALG_INTERFACE_INFO))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_ALG_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
              InterfaceInfo,
              &Interfacep->Info,
              sizeof(IP_ALG_INTERFACE_INFO)
              );
    *InterfaceInfoSize = sizeof(IP_ALG_INTERFACE_INFO);

    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // AlgQueryInterface


VOID
AlgShutdownInterfaceManagement(
                              VOID
                              )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Notes:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/
{
    PALG_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("AlgShutdownInterfaceManagement");
    while (!IsListEmpty(&AlgInterfaceList))
    {
        Link = RemoveHeadList(&AlgInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, ALG_INTERFACE, Link);

        if ( ALG_INTERFACE_ACTIVE( Interfacep ) )
        {
            AlgDeactivateInterface( Interfacep );
        }

        AlgCleanupInterface(Interfacep);
    }
    DeleteCriticalSection(&AlgInterfaceLock);

} // AlgShutdownInterfaceManagement




ULONG
AlgUnbindInterface(
                  ULONG Index
                  )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/
{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgUnbindInterface: interface %d not found",
               Index
               );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!ALG_INTERFACE_BOUND(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgUnbindInterface: interface %d already unbound",
               Index
               );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep))
    {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
               TRACE_FLAG_IF,
               "AlgUnbindInterface: interface %d cannot be referenced",
               Index
               );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' and 'mapped' flag
    //

    Interfacep->Flags &=
    ~(ALG_INTERFACE_FLAG_BOUND | ALG_INTERFACE_FLAG_MAPPED);

    //
    // Deactivate the interface, if necessary
    //
    if ( ALG_INTERFACE_ENABLED( Interfacep ) )
    {
        AlgDeactivateInterface( Interfacep );
    }


    LeaveCriticalSection(&AlgInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingArray);
    Interfacep->BindingArray = NULL;
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // AlgUnbindInterface


VOID
AlgSignalNatInterface(
                      ULONG Index,
                      BOOLEAN Boundary
                      )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the ALG transparent
    proxy is neither installed nor running; it operates as expected,
    since the global information and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Notes:

    Invoked from an arbitrary context.

--*/
{
    MYTRACE_ENTER("AlgSignalNatInterface");

    PROFILE("AlgSignalNatInterface");

    MYTRACE("Index (%d): Boolean(%d-%s)", 
            Index,        
            Boundary,
            Boundary?"TRUE":"FALSE");

    PALG_INTERFACE Interfacep;
    
    EnterCriticalSection(&AlgGlobalInfoLock);

    if (!AlgGlobalInfo)
    {
        LeaveCriticalSection(&AlgGlobalInfoLock);

        return;
    }

    LeaveCriticalSection(&AlgGlobalInfoLock);

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);

    if (Interfacep == NULL)
    {
        LeaveCriticalSection(&AlgInterfaceLock);

        return;
    }

    AlgDeactivateInterface(Interfacep);

    if (ALG_INTERFACE_ACTIVE(Interfacep))
    {
        AlgActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&AlgInterfaceLock);
} // AlgSignalNatInterface

ULONG
AlgActivateInterface(
                     PALG_INTERFACE Interfacep
                     )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating connection-acceptance on each created socket
    (c) initiating session-redirection for the ALG port, if necessary.

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Notes:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'AlgInterfaceLock' held by caller.

--*/
{
    PROFILE("AlgActivateInterface");

    ULONG   Error = NO_ERROR;
    HRESULT hr;
    ULONG   Index  = Interfacep->Index;


    //
    // If the NAT has no idea what this is, do not Activate the interface.
    // Nat will signal us through AlgSignalNatInterface 
    // when it detects an interface, causing us to activate this interface
    //
    ULONG   nInterfaceCharacteristics = 
                 NatGetInterfaceCharacteristics( Index );

    if (0 == nInterfaceCharacteristics )
    {
        return NO_ERROR; // Should succeed
    }
    

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {
        //
        // Notify ALG.EXE of the Addition of a new interface
        //
        IAlgController* pIAlgController = NULL;
        hr = GetAlgControllerInterface( &pIAlgController );

        if ( SUCCEEDED(hr) )
        {
            short   nTypeOfAdapter = 0;
        
            if ( NAT_IFC_BOUNDARY( nInterfaceCharacteristics ))
                nTypeOfAdapter |= eALG_BOUNDARY;
        
            if ( NAT_IFC_FW( nInterfaceCharacteristics ))
                nTypeOfAdapter |= eALG_FIREWALLED;
        
            if ( NAT_IFC_PRIVATE( nInterfaceCharacteristics )) 
                nTypeOfAdapter |= eALG_PRIVATE;

        
            hr = pIAlgController->Adapter_Add( Index,
                                               (short)nTypeOfAdapter );

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmAddInterface: Error (0x%08x) returned from pIalgController->Adapter_Add()",
                    hr
                    );
            }
            else
            {
 
                //
                // Build a simple array of address(DWORD) to send over RPC
                //
                DWORD* apdwAddress = new DWORD[ Interfacep->BindingCount ];
                
                if(NULL != apdwAddress)
                {
                    for ( ULONG nAddress=0; 
                          nAddress < Interfacep->BindingCount; 
                          nAddress++ )
                    {
                        apdwAddress[nAddress] = Interfacep->BindingArray[nAddress].Address;
                    }
            
                    ULONG nRealAdapterIndex = NhMapAddressToAdapter(apdwAddress[0]);
            
                    hr = pIAlgController->Adapter_Bind(Index,            
                                                       nRealAdapterIndex,
                                                       Interfacep->BindingCount,
                                                       apdwAddress );
            
                    if ( FAILED(hr) )
                    {
                        NhTrace(
                            TRACE_FLAG_INIT,
                            "AlgRmBinInterface: Error (0x%08x) returned from pIalgController->Adapter_Bind()",
                            hr
                            );
                    }
            
                    delete [] apdwAddress;
                }
            }


            pIAlgController->Release();
        }
    }

    COMINIT_END;

    Error = WIN32_FROM_HRESULT(hr);

    return Error;
}


VOID
AlgDeactivateInterface(
                       PALG_INTERFACE Interfacep
                       )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Notes:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'AlgInterfaceLock' held by caller.

--*/
{
    //
    // Also notify the ALG.exe manager
    //
    HRESULT hr;

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {
        IAlgController* pIAlgController=NULL;
        HRESULT hr = GetAlgControllerInterface(&pIAlgController);

        if ( SUCCEEDED(hr) )
        {
            hr = pIAlgController->Adapter_Remove( Interfacep->Index );
            
               if ( FAILED(hr) )
               {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmAddInterface: Error (0x%08x) returned from pIalgController->Adapter_Remove()",
                    hr
                    );
               }

            pIAlgController->Release();
        }
    }

    COMINIT_END;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\algif.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    AlgIF.h

Abstract:

    This module contains declarations for the ALG transparent proxy's
    interface management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

    Savas Guven (savasg)      22-Aug-2001 Added RRAS Support

--*/

#pragma once


//
// Structure:   ALG_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
//

typedef struct _ALG_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET ListeningSocket;
    HANDLE ListeningRedirectHandle[2];
} ALG_BINDING, *PALG_BINDING;


//
// Structure:   ALG_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of ALG transparent proxy
// interfaces, sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('AlgInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _ALG_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    ULONG AdapterIndex; // read-only
    ULONG Characteristics; //read-only after activation
    NET_INTERFACE_TYPE Type; // read-only
    IP_ALG_INTERFACE_INFO Info;
    IP_NAT_PORT_MAPPING PortMapping;
    ULONG Flags;
    ULONG BindingCount;
    PALG_BINDING BindingArray;
    LIST_ENTRY ConnectionList;
    LIST_ENTRY EndpointList;
} ALG_INTERFACE, *PALG_INTERFACE;

//
// Flags
//

#define ALG_INTERFACE_FLAG_DELETED      0x80000000
#define ALG_INTERFACE_DELETED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_DELETED)

#define ALG_INTERFACE_FLAG_BOUND        0x40000000
#define ALG_INTERFACE_BOUND(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_BOUND)

#define ALG_INTERFACE_FLAG_ENABLED      0x20000000
#define ALG_INTERFACE_ENABLED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_ENABLED)

#define ALG_INTERFACE_FLAG_CONFIGURED   0x10000000
#define ALG_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_CONFIGURED)

#define ALG_INTERFACE_FLAG_MAPPED       0x01000000
#define ALG_INTERFACE_MAPPED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_MAPPED)

#define ALG_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (ALG_INTERFACE_FLAG_BOUND|ALG_INTERFACE_FLAG_ENABLED)) \
        == (ALG_INTERFACE_FLAG_BOUND|ALG_INTERFACE_FLAG_ENABLED))

#define ALG_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_ALG_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define ALG_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, ALG_INTERFACE_DELETED)

#define ALG_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, AlgCleanupInterface)
    
#define COMINIT_BEGIN \
    bool bComInitialized = true; \
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE ); \
    if ( FAILED(hr) ) \
    { \
        bComInitialized = FALSE; \
        if (RPC_E_CHANGED_MODE == hr) \
            hr = S_OK; \
    } \

#define COMINIT_END if (TRUE == bComInitialized) { CoUninitialize(); }


#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))

#define WIN32_FROM_HRESULT(hr)         (0x0000FFFF & (hr))


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY AlgInterfaceList;
extern CRITICAL_SECTION AlgInterfaceLock;
extern ULONG AlgFirewallIfCount;


//
// FUNCTION DECLARATIONS
//


ULONG
AlgActivateInterface(
    PALG_INTERFACE Interfacep
    );

VOID
AlgDeactivateInterface(
    PALG_INTERFACE Interfacep
    );

ULONG
AlgBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
AlgCleanupInterface(
    PALG_INTERFACE Interfacep
    );

ULONG
AlgConfigureInterface(
    ULONG Index,
    PIP_ALG_INTERFACE_INFO InterfaceInfo
    );

ULONG
AlgCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_ALG_INTERFACE_INFO InterfaceInfo,
    PALG_INTERFACE* InterfaceCreated
    );


ULONG
AlgDeleteInterface(
    ULONG Index
    );

ULONG
AlgDisableInterface(
    ULONG Index
    );

ULONG
AlgEnableInterface(
    ULONG Index
    );

ULONG
AlgInitializeInterfaceManagement(
    VOID
    );

PALG_INTERFACE
AlgLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
AlgQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
AlgShutdownInterfaceManagement(
    VOID
    );


ULONG
AlgUnbindInterface(
    ULONG Index
    );

VOID
AlgSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\util.h ===
#ifndef	__h323ics_util_h
#define	__h323ics_util_h

extern  "C" DWORD   DebugLevel;

EXTERN_C	BOOL	IsInList		(LIST_ENTRY * ListHead, LIST_ENTRY * ListEntry);
EXTERN_C	void	ExtractList		(LIST_ENTRY * DestinationListHead, LIST_ENTRY * SourceListHead);
EXTERN_C	DWORD	CountListLength		(LIST_ENTRY * ListHead);
EXTERN_C	void 	MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source);
EXTERN_C	void	AssertListIntegrity	(LIST_ENTRY * ListHead);

#define INET_NTOA(a) inet_ntoa(*(struct in_addr*)&(a))

typedef HANDLE TIMER_HANDLE;

__inline
LPWSTR AnsiToUnicode (LPCSTR string, LPWSTR buffer, DWORD buffer_len)
{
    int x;

    x = MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);
    buffer [x] = 0;

    return buffer;
}

__inline
LPSTR UnicodeToAnsi (LPCWSTR string, LPSTR buffer, DWORD buffer_len)
{
    int x;

    x = WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len,
                             NULL, FALSE);
    buffer [x] = 0;

    return buffer;
}

class	TIMER_PROCESSOR;
class   OVERLAPPED_PROCESSOR;

class	Q931_INFO;
class	SOURCE_Q931_INFO;
class	DEST_Q931_INFO;

class	LOGICAL_CHANNEL;
class	H245_INFO;
class	SOURCE_H245_INFO;
class	DEST_H245_INFO;

class	H323_STATE;
class	SOURCE_H323_STATE;
class	DEST_H323_STATE;

class	CALL_BRIDGE;

#ifdef __cplusplus
template <class T>
inline BOOL BadReadPtr(T* p, DWORD dwSize = 1)
{
    return IsBadReadPtr(p, dwSize * sizeof(T));
}

template <class T>
inline BOOL BadWritePtr(T* p, DWORD dwSize = 1)
{
    return IsBadWritePtr(p, dwSize * sizeof(T));
}
#endif


#if defined(DBG)

void	Debug	(LPCTSTR);
void	DebugF	(LPCTSTR, ...);
void	DebugError	(DWORD, LPCTSTR);
void	DebugErrorF	(DWORD, LPCTSTR, ...);
void	DebugLastError	(LPCTSTR);
void	DebugLastErrorF	(LPCTSTR, ...);

void	DumpMemory (const UCHAR * Data, ULONG Length);
void	DumpError	(DWORD);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#else // !defined(DBG)

static	__inline	void	Debug	(LPCTSTR)					{}
static	__inline	void	DebugF	(LPCTSTR, ...)				{}
static	__inline	void	DebugError	(DWORD, LPCTSTR)		{}
static	__inline	void	DebugErrorF	(DWORD, LPCTSTR, ...)	{}
static	__inline	void	DebugLastError	(LPCTSTR)	{}
static	__inline	void	DebugLastErrorF	(LPCTSTR, ...)	{}

static	__inline	void	DumpMemory (const UCHAR * Data, ULONG Length)		{}
static	__inline	void	DumpError	(DWORD) {}

#endif // defined(DBG)


#ifdef _ASSERTE
#undef _ASSERTE
#endif // _ASSERTE

#ifdef	assert
#undef	assert
#endif

#if	DBG

// The latest and greatest Proxy assert
__inline void PxAssert(LPCTSTR file, DWORD line, LPCTSTR condition)
{
	DebugF (_T("%s(%d) : Assertion failed, condition: %s\n"),
            file, line, condition);
	DebugBreak();
}

#define	_ASSERTE(condition)	if(condition);else\
	{ PxAssert(_T(__FILE__), __LINE__, _T(#condition)); }

#define	assert	_ASSERTE

__inline void PxAssertNeverReached (LPCTSTR File, DWORD Line)
{
	DebugF (_T("%s(%d) : Assertion failure, code path should never be executed\n"),
		File, Line);
	DebugBreak();
}

#define	AssertNeverReached() PxAssertNeverReached (_T(__FILE__), __LINE__);

#else // !DBG

#define	_ASSERTE(condition)			NOP_FUNCTION
#define	assert						NOP_FUNCTION
#define	AssertNeverReached()		NOP_FUNCTION

#endif // DBG




// 0,1,2,3 : count of bytes from MSB to LSB in host order
#define BYTE0(l) ((BYTE)((DWORD)(l) >> 24))
#define BYTE1(l) ((BYTE)((DWORD)(l) >> 16))
#define BYTE2(l) ((BYTE)((DWORD)(l) >> 8))
#define BYTE3(l) ((BYTE)((DWORD)(l)))

// Handy macro to use in printf statements
#define BYTES0123(l) BYTE0(l), BYTE1(l), BYTE2(l), BYTE3(l)

// 0,1,2,3 : count of bytes from MSB to LSB in network order
#define NETORDER_BYTE0(l) ((BYTE)((BYTE *) &l)[0])
#define NETORDER_BYTE1(l) ((BYTE)((BYTE *) &l)[1])
#define NETORDER_BYTE2(l) ((BYTE)((BYTE *) &l)[2])
#define NETORDER_BYTE3(l) ((BYTE)((BYTE *) &l)[3])

#define	SOCKADDR_IN_PRINTF(SocketAddress) \
	ntohl ((SocketAddress) -> sin_addr.s_addr), \
	ntohs ((SocketAddress) -> sin_port)

// Handy macro to use in printf statements
#define NETORDER_BYTES0123(l) NETORDER_BYTE0(l), NETORDER_BYTE1(l), \
                             NETORDER_BYTE2(l), NETORDER_BYTE3(l)

static __inline LONG RegQueryValueString (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	LPTSTR	ReturnString,
	IN	DWORD	StringMax)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (TCHAR) * StringMax;
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnString, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_SZ)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}

static __inline LONG RegQueryValueDWORD (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	DWORD *	ReturnValue)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (DWORD);
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnValue, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_DWORD)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}


class	SIMPLE_CRITICAL_SECTION_BASE
{
protected:

	CRITICAL_SECTION		CriticalSection;

protected:

	void	Lock			(void)	{ EnterCriticalSection (&CriticalSection); }
	void	Unlock			(void)	{ LeaveCriticalSection (&CriticalSection); }
	void	AssertLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) == GetCurrentThreadId()); }
	void	AssertNotLocked	(void)	{ assert (!CriticalSection.OwningThread); }
	void	AssertThreadNotLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) != GetCurrentThreadId()); }

protected:

	SIMPLE_CRITICAL_SECTION_BASE	(void) {
		InitializeCriticalSection (&CriticalSection);
	}

	~SIMPLE_CRITICAL_SECTION_BASE	(void)	{
		if (CriticalSection.OwningThread) {
			DebugF (_T("SIMPLE_CRITICAL_SECTION_BASE::~SIMPLE_CRITICAL_SECTION_BASE: thread %08XH stills holds this critical section (this %p)\n"),
				PtrToUlong(CriticalSection.OwningThread), this);
		}

		AssertNotLocked();
		DeleteCriticalSection (&CriticalSection);
	}
};

#if ENABLE_REFERENCE_HISTORY
#include "dynarray.h"
#endif // ENABLE_REFERENCE_HISTORY

class SYNC_COUNTER;

class LIFETIME_CONTROLLER 
{
#if ENABLE_REFERENCE_HISTORY
public:
	LIST_ENTRY ListEntry;

	struct REFERENCE_HISTORY {
		LONG CurrentReferenceCount;
		PVOID CallersAddress;
	};

	DYNAMIC_ARRAY <REFERENCE_HISTORY> ReferenceHistory;
	CRITICAL_SECTION ReferenceHistoryLock;

#define MAKE_REFERENCE_HISTORY_ENTRY() {                                           \
		PVOID CallersAddress, CallersCallersAddress;							   \
		RtlGetCallersAddress (&CallersAddress, &CallersCallersAddress);            \
		EnterCriticalSection (&ReferenceHistoryLock);                              \
		REFERENCE_HISTORY * ReferenceHistoryNode = ReferenceHistory.AllocAtEnd (); \
		ReferenceHistoryNode -> CallersAddress = CallersAddress;                   \
		ReferenceHistoryNode -> CurrentReferenceCount = Count;                     \
		LeaveCriticalSection (&ReferenceHistoryLock);                              \
	}

#endif //ENABLE_REFERENCE_HISTORY

private:

	LONG ReferenceCount;
	SYNC_COUNTER * AssociatedSyncCounter;

protected: 

	LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter = NULL);
	virtual	~LIFETIME_CONTROLLER ();

public:

	void AddRef (void);

	void Release (void);
};


template <DWORD SampleHistorySize>
class SAMPLE_PREDICTOR {
public:

    SAMPLE_PREDICTOR (void) {
        
        ZeroMemory ((PVOID) &Samples[0],       sizeof (Samples));

        FirstSampleIndex    = 0;
        SamplesArraySize    = 0;
    }

    HRESULT AddSample (LONG Sample) {

        DWORD    ThisSampleIndex;

        if (0UL == SampleHistorySize)
            return E_ABORT;

        if (SamplesArraySize < SampleHistorySize) {

            ThisSampleIndex = SamplesArraySize;

            SamplesArraySize++;

        } else {

            ThisSampleIndex = FirstSampleIndex; // Overwrite the least recent sample

            FirstSampleIndex++;

            FirstSampleIndex %= SampleHistorySize;
        }
        
        Samples [ThisSampleIndex] = Sample; 

        return S_OK;
    }

    LONG PredictNextSample (void) {

        DWORD  Index;
        DWORD  CurrentSampleIndex;

        LONG   Coefficient = 0;
        LONG   Prediction  = 0;

        if (0 == SampleHistorySize)
            return 0;

        for (Index = 0; Index < SamplesArraySize; Index++) {

            if (0 == Index) {

               Coefficient = (LONG)((SamplesArraySize & 1) << 1) - 1; // 1 or -1

            } else {

               Coefficient *= (LONG) Index - (LONG) SamplesArraySize - 1;
               Coefficient /= (LONG) Index;
            }

            CurrentSampleIndex = (FirstSampleIndex + Index) % SamplesArraySize;

            Prediction += Coefficient * Samples [CurrentSampleIndex];

        }

        return Prediction;
    }

#if DBG
    void PrintSamples (void) {
        DWORD Index;

        if (SamplesArraySize) {
            DebugF (_T("Samples in predictor %p are: \n"), this);

            for (Index = 0; Index < SamplesArraySize; Index++) 
                DebugF (_T("\t@%d(%d)-- %d\n"), Index, Index < FirstSampleIndex ? SamplesArraySize - (FirstSampleIndex - Index) : Index - FirstSampleIndex, Samples[Index]);
        } else {
            DebugF (_T("There are no samples in predictor %p.\n"), this);
        }
    }
#endif 

    HRESULT RetrieveOldSample (
            IN DWORD StepsInThePast, // 0 -- most recent sample 
            OUT LONG * OldSample) {

        DWORD SampleIndex;

        if (0 == SampleHistorySize)
            return E_ABORT;

        if (StepsInThePast < SamplesArraySize) {
            // Valid request

            _ASSERTE (SamplesArraySize);

            SampleIndex = (SamplesArraySize + FirstSampleIndex - StepsInThePast - 1) % SamplesArraySize;

            *OldSample = Samples [SampleIndex];

            return S_OK;
        }

        return ERROR_INVALID_DATA;
    }

private:

    LONG    Samples       [SampleHistorySize];           // This is where samples are kept
    LONG    PositiveTerms [SampleHistorySize];  
    LONG    NegativeTerms [SampleHistorySize];  
    DWORD   SamplesArraySize;
    DWORD   FirstSampleIndex;                            // Index of the least recent sample
};

static __inline HRESULT GetLastErrorAsResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

static __inline HRESULT GetLastResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

// A sync counter is an integer counter.
// It is kind of the opposite of a semaphore.
// When the counter is zero, the sync counter is signaled.
// When the counter is nonzero, the sync counter is not signaled.

class	SYNC_COUNTER :
public	SIMPLE_CRITICAL_SECTION_BASE
{
	friend class LIFETIME_CONTROLLER;

private:

	LONG		CounterValue;			// the current value of the counter
	HANDLE		ZeroEvent;				// signaled when CounterValue = 0

public:
#if ENABLE_REFERENCE_HISTORY
	LIST_ENTRY ActiveLifetimeControllers;
#endif // ENABLE_REFERENCE_HISTORY


	SYNC_COUNTER ();
	~SYNC_COUNTER ();

	HRESULT	Start (void);
    void Stop (void);

	void	Increment	(void);
	void	Decrement	(void);

	DWORD	Wait		(DWORD Timeout);
};



#define	HRESULT_FROM_WIN32_ERROR_CODE		HRESULT_FROM_WIN32
#define	HRESULT_FROM_WINSOCK_ERROR_CODE		HRESULT_FROM_WINSOCK_ERROR_CODE

// ASN.1 utility functions

// Setup_UUIE&
// SetupMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define SetupMember(pH323UserInfo)                          \
    (pH323UserInfo)->h323_uu_pdu.h323_message_body.u.setup

// Returns a non-zero value only. So don't try comparing it with TRUE/FALSE
// BOOL
// IsDestCallSignalAddressPresent(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define IsDestCallSignalAddressPresent(pH323UserInfo) \
    (SetupMember(pH323UserInfo).bit_mask & Setup_UUIE_destCallSignalAddress_present)

// Get the destCallSignalAddress member
// TransportAddress&
// DCSAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DCSAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destCallSignalAddress

// Get the destCallSignalAddress member
// DESTINATION_ADDRESS *&
// DestAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DestAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destinationAddress
    
// BOOL
// IsTransportAddressTypeIP(
//     IN TransportAddress Addr
//     );
#define IsTransportAddressTypeIP(Addr) \
    (Addr.choice == ipAddress_chosen)
    
// BOOL
// IPAddrMember(
//     IN TransportAddress Addr
//     );
#define IPAddrMember(Addr) \
    Addr.u.ipAddress

typedef struct Setup_UUIE_destinationAddress DESTINATION_ADDRESS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for filling and extracting from structures used to               //
// store Transport addresses in Q.931 and H.245 ASN                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// fills the TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
__inline void
FillTransportAddress(
    IN DWORD                IPv4Address,		// host order
    IN WORD                 Port,				// host order
    OUT TransportAddress    &TransportAddress
    )
{
	// we are filling in an IP address
    TransportAddress.choice = ipAddress_chosen;

    // fill in the port
    TransportAddress.u.ipAddress.port = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != TransportAddress.u.ipAddress.ip.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    TransportAddress.u.ipAddress.ip.length = 4;
	*((DWORD *)TransportAddress.u.ipAddress.ip.value) = 
		htonl(IPv4Address);
}

static __inline void FillTransportAddress (
	IN	const SOCKADDR_IN &	SocketAddress,
	OUT	TransportAddress &	ReturnTransportAddress)
{
	FillTransportAddress (
		ntohl (SocketAddress.sin_addr.s_addr),
		ntohs (SocketAddress.sin_port),
		ReturnTransportAddress);
}

// returns E_INVALIDARG for PDUs which can not be handled.
__inline HRESULT
GetTransportInfo(
    IN const TransportAddress	&TransportAddress,
    OUT DWORD			&IPv4Address,				// host order
    OUT WORD			&Port						// host order
    )
{
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(ipAddress_chosen & TransportAddress.choice))
	{
		DebugF( _T("GetTransportInfo(&H245Address, &0x%x, &%u), ")
            _T("non unicast address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, TransportAddress.choice);
		return E_INVALIDARG;
	}

	// fill in the port
    Port = TransportAddress.u.ipAddress.port;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != TransportAddress.u.ipAddress.ip.length)
	{
		DebugF( _T("GetTransportInfo: bogus address length (%d) in TransportAddress\n"),
			TransportAddress.u.ipAddress.ip.length);
		return E_INVALIDARG;
	}

	IPv4Address = ntohl(*((DWORD *)TransportAddress.u.ipAddress.ip.value));

	return S_OK;
}

static __inline HRESULT GetTransportInfo (
	IN	const TransportAddress &	TransportAddress,
	OUT	SOCKADDR_IN &		ReturnSocketAddress)
{
	HRESULT		Result;

	ReturnSocketAddress.sin_family = AF_INET;

	Result = GetTransportInfo (TransportAddress,
		ReturnSocketAddress.sin_addr.s_addr,
		ReturnSocketAddress.sin_port);

	ReturnSocketAddress.sin_addr.s_addr = htonl (ReturnSocketAddress.sin_addr.s_addr);
	ReturnSocketAddress.sin_port = htons (ReturnSocketAddress.sin_port);

	return Result;
}


// fills the H245TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
inline void
FillH245TransportAddress(
    IN DWORD					IPv4Address,
    IN WORD						Port,
    OUT H245TransportAddress	&H245Address
    )
{
	// we are filling in an unicast IP address
	H245Address.choice = unicastAddress_chosen;

	// alias for the unicast address
	UnicastAddress &UnicastIPAddress = H245Address.u.unicastAddress;

	// its an IP address
	UnicastIPAddress.choice = UnicastAddress_iPAddress_chosen;

    // fill in the port
    UnicastIPAddress.u.iPAddress.tsapIdentifier = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    UnicastIPAddress.u.iPAddress.network.length = 4;
	*((DWORD *)UnicastIPAddress.u.iPAddress.network.value) = 
		htonl(IPv4Address);
}

// Returned IPaddress and port are in host order
inline HRESULT
GetH245TransportInfo(
    IN const H245TransportAddress &H245Address,
    OUT DWORD			    &IPv4Address,
    OUT WORD			    &Port
    )
{
	// we proceed only if the transport address has a unicast address
    if (!(unicastAddress_chosen & H245Address.choice))
	{
		DebugF( _T("GetH245TransportInfo(&H245Address, &0x%x, &%u), ")
            _T("non unicast address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, H245Address.choice);
		return E_INVALIDARG;
	}
    
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(UnicastAddress_iPAddress_chosen & 
            H245Address.u.unicastAddress.choice))
	{
		DebugF( _T("GetH245TransportInfo(&TransportAddress, &0x%x, &%u), ")
            _T("non ip address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, H245Address.u.unicastAddress.choice);
		return E_INVALIDARG;
	}

    const UnicastAddress & UnicastIPAddress = H245Address.u.unicastAddress;

	// fill in the port
    Port = UnicastIPAddress.u.iPAddress.tsapIdentifier;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != UnicastIPAddress.u.iPAddress.network.length)
	{
		DebugF( _T("GetH245TransportInfo: bogus ip address length (%d), failing\n"),
			UnicastIPAddress.u.iPAddress.network.length);

		return E_INVALIDARG;
	}

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);
	IPv4Address = ntohl(*((DWORD *)UnicastIPAddress.u.iPAddress.network.value));

	return S_OK;
}

static __inline HRESULT GetH245TransportInfo (
	IN	const H245TransportAddress & H245Address,
	OUT	SOCKADDR_IN *		ReturnSocketAddress)
{
	DWORD	IPAddress;
	WORD	Port;
	HRESULT	Result;

	Result = GetH245TransportInfo (H245Address, IPAddress, Port);
	if (Result == S_OK) {
		ReturnSocketAddress -> sin_family = AF_INET;
		ReturnSocketAddress -> sin_addr.s_addr = htonl (IPAddress);
		ReturnSocketAddress -> sin_port = htons (Port);
	}

	return Result;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines dealing with the T.120 Parameters in H.245 PDUs                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// In case of failure the routine returns 
// INADDR_NONE for the T120ConnectToIPAddr
inline HRESULT
GetT120ConnectToAddress(
    IN  NetworkAccessParameters  separateStack,
    OUT DWORD                   &T120ConnectToIPAddr,
    OUT WORD                    &T120ConnectToPort
    )
{
    // These are the return values in case of a failure.
    T120ConnectToIPAddr = INADDR_NONE;
    T120ConnectToPort   = 0;
    
    // CODEWORK: should we require the distribution member
    // to be present always ?
    
    if ((separateStack.bit_mask & distribution_present) &&
        (separateStack.distribution.choice != unicast_chosen))
    {
        // We support Unicast only
        return E_INVALIDARG;
    }
    
    // Deal with t120SetupProcedure
    
    if (separateStack.networkAddress.choice != localAreaAddress_chosen)
    {
        // Support only local area addresses
        return E_INVALIDARG;
    }
    
    GetH245TransportInfo(
        separateStack.networkAddress.u.localAreaAddress,
        T120ConnectToIPAddr,
        T120ConnectToPort
        );
    
    DebugF (_T ("T120: Endpoint is listening on: %08X:%04X.\n"),
            T120ConnectToIPAddr,
            T120ConnectToPort
            );

    return S_OK;
}



#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3


inline DWORD GetPktLenFromTPKTHdr(BYTE *pbTpktHdr)
/*++

Routine Description:

	Compute the length of the packet from the TPKT header.
	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns the length of the PDU which follows the TPKT header.

--*/
{
	_ASSERTE(pbTpktHdr[0] == TPKT_VERSION);
    return ((pbTpktHdr[2] << 8) + pbTpktHdr[3]  - TPKT_HEADER_SIZE);
}

inline void SetupTPKTHeader(
     OUT BYTE *  pbTpktHdr,
     IN  DWORD   dwLength
     )
/*++

Routine Description:

	Setup the TPKT header based on the length.

	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns S_OK if the version is right and E_FAIL otherwise.

--*/
{
    _ASSERTE(pbTpktHdr);

    dwLength += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    _ASSERTE(dwLength < (1L << 16));

    pbTpktHdr[0] = TPKT_VERSION;
    pbTpktHdr[1] = 0;
    pbTpktHdr[2] = HIBYTE(dwLength); //(BYTE)(dwLength >> 8);
    pbTpktHdr[3] = LOBYTE(dwLength); //(BYTE)dwLength;
}

static __inline BOOLEAN RtlEqualStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlEqualString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline INT RtlCompareStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlCompareString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline void InitializeAnsiString (
	OUT	ANSI_STRING *		AnsiString,
	IN	ASN1octetstring_t *	AsnString)
{
	assert (AnsiString);
	assert (AsnString);

	AnsiString -> Buffer = (PSTR) AsnString -> value;
	AnsiString -> Length = (USHORT) AsnString -> length / sizeof (CHAR);
}

static __inline void InitializeUnicodeString (
	OUT	UNICODE_STRING *		UnicodeString,
	IN	ASN1char16string_t *	AsnString)
{
	assert (UnicodeString);
	assert (AsnString);

	UnicodeString -> Buffer = (PWSTR)AsnString -> value;
	UnicodeString -> Length = (USHORT) AsnString -> length / sizeof (WCHAR);
}

// use with "%.*s" or "%.*S"
#define	ANSI_STRING_PRINTF(AnsiString) (AnsiString) -> Length, (AnsiString) -> Buffer


// { Length, MaximumLength, Buffer }
#define	ANSI_STRING_INIT(Text) { sizeof (Text) - sizeof (CHAR), 0, (Text) } // account for NUL

void FreeAnsiString (
	IN	ANSI_STRING *	String);

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString);

static __inline ULONG ByteSwap (
	IN	ULONG	Value)
{
	union	ULONG_SWAP	{
		BYTE	Bytes	[sizeof (ULONG)];
		ULONG	Integer;
	};
	
	ULONG_SWAP *	SwapValue;
	ULONG_SWAP		SwapResult;

	SwapValue = (ULONG_SWAP *) &Value;
	SwapResult.Bytes [0] = SwapValue -> Bytes [3];
	SwapResult.Bytes [1] = SwapValue -> Bytes [2];
	SwapResult.Bytes [2] = SwapValue -> Bytes [1];
	SwapResult.Bytes [3] = SwapValue -> Bytes [0];

	return SwapResult.Integer;
}

// does NOT convert to host order first
static __inline INT Compare_SOCKADDR_IN (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);

	if (AddressA -> sin_addr.s_addr < AddressB -> sin_addr.s_addr) return -1;
	if (AddressA -> sin_addr.s_addr > AddressB -> sin_addr.s_addr) return 1;

	return 0;
}

static __inline BOOL IsEqualSocketAddress (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);
	assert (AddressA -> sin_family == AF_INET);
	assert (AddressB -> sin_family == AF_INET);

	return AddressA -> sin_addr.s_addr == AddressB -> sin_addr.s_addr
		&& AddressA -> sin_port == AddressB -> sin_port;
}

#if DBG

void ExposeTimingWindow (void);

#endif

// Get the address of the best interface that will
// be used to connect to the DestinationAddress
ULONG GetBestInterfaceAddress (
    IN DWORD DestinationAddress,   // host order
    OUT DWORD * InterfaceAddress); // host order

DWORD
H323MapAdapterToAddress (
    IN DWORD AdapterIndex
    );
#endif // __h323ics_util_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\alglog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    alglog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once

#define IP_ALG_LOG_BASE                       35000

#define IP_ALG_LOG_NAT_INTERFACE_IGNORED      (IP_ALG_LOG_BASE+1)
/*
 * The ALG transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_ALG_LOG_ACTIVATE_FAILED            (IP_ALG_LOG_BASE+2)
/*
 * The ALG transparent proxy was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_ALG_LOG_RECEIVE_FAILED             (IP_ALG_LOG_BASE+3)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_ALLOCATION_FAILED          (IP_ALG_LOG_BASE+4)
/*
 * The ALG transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_ALG_LOG_ACCEPT_FAILED              (IP_ALG_LOG_BASE+5)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to accept connections on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_SEND_FAILED                (IP_ALG_LOG_BASE+7)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to send messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_END                        (IP_ALG_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmALG.h"

#include "algif.h"
#include "alglog.h"

#include "Alg.h"
#include "Alg_Private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\rmalg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmALG.cpp

Abstract:

    This module contains routines for the ALG Manager module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    JPDup		10-Nov-2000
    

Revision History:
    
    Savasg      22-Aug-2001 Added RRAS Support

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

#include <initguid.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>



#include "Alg_private.h"
#include "NatPrivateAPI_Imp.h"

#include <MyTrace.h>


MYTRACE_ENABLE



//
// Globals
//



COMPONENT_REFERENCE	    AlgComponentReference;
PIP_ALG_GLOBAL_INFO	    AlgGlobalInfo = NULL;
CRITICAL_SECTION	    AlgGlobalInfoLock;

HANDLE                  AlgNotificationEvent;
HANDLE                  AlgTimerQueueHandle = NULL;
HANDLE                  AlgPortReservationHandle = NULL;
HANDLE                  AlgTranslatorHandle = NULL;
ULONG                   AlgProtocolStopped = 0;
IP_ALG_STATISTICS 	    AlgStatistics;
SUPPORT_FUNCTIONS 	    AlgSupportFunctions;

//
// GIT cookie for the IHNetCfgMgr instance
//
DWORD                   AlgGITcookie = 0;
IGlobalInterfaceTable*  AlgGITp = NULL;






const MPR_ROUTING_CHARACTERISTICS AlgRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_ALG,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    AlgRmStartProtocol,
    AlgRmStartComplete,
    AlgRmStopProtocol,
    AlgRmGetGlobalInfo,
    AlgRmSetGlobalInfo,
    NULL,
    NULL,
    AlgRmAddInterface,
    AlgRmDeleteInterface,
    AlgRmInterfaceStatus,
    AlgRmGetInterfaceInfo,
    AlgRmSetInterfaceInfo,
    AlgRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    AlgRmMibCreate,
    AlgRmMibDelete,
    AlgRmMibGet,
    AlgRmMibSet,
    AlgRmMibGetFirst,
    AlgRmMibGetNext,
    NULL,
    NULL
};






//
//
//
HRESULT
GetAlgControllerInterface(
    IAlgController** ppAlgController
    )

/*++

Routine Description:

    This routine obtains a pointer to the home networking configuration
    manager.

Arguments:

    ppAlgController - receives the IAlgController pointer. The caller must release this pointer.

Return Value:

    standard HRESULT

Environment:

COM must be initialized on the calling thread

--*/

{

    HRESULT hr = S_OK;
    
    if ( NULL == AlgGITp )
    {
        IAlgController* pIAlgController;
        
        //
        // Create the global interface table
        //
        
        hr = CoCreateInstance(
            CLSID_StdGlobalInterfaceTable,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IGlobalInterfaceTable, &AlgGITp)
            );

        if ( SUCCEEDED(hr) )
        {
            //
            // Create the ALG Interface (ALG.exe will start as a service by COM)
            //

            hr = CoCreateInstance(
                    CLSID_AlgController,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    IID_PPV_ARG(IAlgController, &pIAlgController)
                    );

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "GetAlgControllerInterface: Unable to create pIAlgController (0x%08x)",
                    hr
                    );
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "GetAlgControllerInterface: Unable to create GIT (0x%08x)",
                hr
                );
        }

        if (SUCCEEDED(hr))
        {
            //
            // Store the CfgMgr pointer in the GIT
            //

            hr = AlgGITp->RegisterInterfaceInGlobal(
                pIAlgController,
                IID_IAlgController,
                &AlgGITcookie
                );
                
            pIAlgController->Release();

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "GetAlgControllerInterface: Unable to register pIAlgController (0x%08x)",
                    hr
                    );
            }
        }
    }
            
    if ( SUCCEEDED(hr) )
    {
        hr = AlgGITp->GetInterfaceFromGlobal(
                AlgGITcookie,
                IID_PPV_ARG(IAlgController, ppAlgController)
                );
    }

    return hr;
    
} // GetAlgControllerInterface



//
//
//
void
FreeAlgControllerInterface()
{
    //
    // Free up HNetCfgMgr pointers
    //

    if ( !AlgGITp )
        return; // nothing to free

    //
    // Make sure COM is initialized
    //
    HRESULT hr;

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {
        //
        // Release the ALG.exe private interface from the GIT
        //

        AlgGITp->RevokeInterfaceFromGlobal(AlgGITcookie);
        AlgGITcookie = 0;

        //
        // Release the GIT
        //

        AlgGITp->Release();
        AlgGITp = NULL;
    }

    COMINIT_END;

}


VOID
AlgCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the ALG transparent proxy module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    AlgShutdownInterfaceManagement();
    DeleteCriticalSection(&AlgGlobalInfoLock);
    DeleteComponentReference(&AlgComponentReference);

} // AlgCleanupModule


VOID
AlgCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the ALG transparent proxy
    protocol-component after a 'StopProtocol'. It runs when the last reference
    to the component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("AlgCleanupProtocol");
    if (AlgGlobalInfo) { NH_FREE(AlgGlobalInfo); AlgGlobalInfo = NULL; }
    if (AlgTimerQueueHandle) {
        DeleteTimerQueueEx(AlgTimerQueueHandle, INVALID_HANDLE_VALUE);
        AlgTimerQueueHandle = NULL;
    }

    if (AlgPortReservationHandle) {
        NatShutdownPortReservation(AlgPortReservationHandle);
        AlgPortReservationHandle = NULL;
    }

    if (AlgTranslatorHandle) {
        NatShutdownTranslator(AlgTranslatorHandle); AlgTranslatorHandle = NULL;
    }

    InterlockedExchange(reinterpret_cast<LPLONG>(&AlgProtocolStopped), 1);
    SetEvent(AlgNotificationEvent);
    ResetComponentReference(&AlgComponentReference);

    //
    // Free the GIT and AlgController interface
    //
    FreeAlgControllerInterface();

    NhStopEventLog();

} // AlgCleanupProtocol


BOOLEAN
AlgInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the FnP module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{

    if (InitializeComponentReference(
            &AlgComponentReference, AlgCleanupProtocol
            )) 
	{
	    return FALSE;
    }
    __try 
    {
        InitializeCriticalSection(&AlgGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        DeleteComponentReference(&AlgComponentReference);
        return FALSE;
    }

    if ( AlgInitializeInterfaceManagement() )
    {
        DeleteCriticalSection( &AlgGlobalInfoLock );

        DeleteComponentReference( &AlgComponentReference );

        return FALSE;
    }

    return TRUE;

} // AlgInitializeModule




//
// Get ALG COM Interface to Start the ALG and give call back Interface
//
HRESULT 
Initialise_ALG()
{
    HRESULT hr;

    COMINIT_BEGIN;
    
    if ( FAILED(hr) )
        return hr;

    //
    // Get COM to load the ALG.exe 
    // The ALG will be launch using a LOCAL_SERVICE priviledge
    // See the RunAs entry under the AppID of the ALG.exe
    //
    
    IAlgController* pIAlgController=NULL;
    
    hr = GetAlgControllerInterface(&pIAlgController);
    if ( SUCCEEDED(hr) )
    {
        //
        // We create our Private COM interface to the NAT api
        //
        CComObject<CNat>*	pComponentNat;
        hr = CComObject<CNat>::CreateInstance(&pComponentNat);
        
        if ( SUCCEEDED(hr) )
        {
            pComponentNat->AddRef();
            
            //
            // Make sure we pass a INat interface 
            //
            INat* pINat=NULL;
            hr = pComponentNat->QueryInterface(IID_INat, (void**)&pINat);
            
            if ( SUCCEEDED(hr) )
            {
                
                //
                // Let the ALG manager start the loading of all the ALG modules
                //
                hr = pIAlgController->Start(pINat);
                
                if ( FAILED(hr) )
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "Initialise_ALG: Error (0x%08x)  on pIAlgController->Start(pINat)",
                        hr
                        );
                }

                //
                // ALG manager will have AddRef this INat so we can release
                //
                pINat->Release();

            }

            pComponentNat->Release();
        }
    }    
    else
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "Initialise_ALG: Error (0x%08x)  Getting the IAlgController interface",
            hr
            );
        
        return hr;
    }


    if ( pIAlgController )
        pIAlgController->Release();

    COMINIT_END;
    
    return S_OK;

}




ULONG
APIENTRY
AlgRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    MYTRACE_START(L"rmALG");
    MYTRACE_ENTER("AlgRmStartProtocol");
    PROFILE("AlgRmStartProtocol");

    ULONG Error = NO_ERROR;
    ULONG Size;

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER); }

    NhStartEventLog();

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&AlgGlobalInfoLock);

        Size = sizeof(*AlgGlobalInfo);

        AlgGlobalInfo =
            reinterpret_cast<PIP_ALG_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!AlgGlobalInfo) {
            LeaveCriticalSection(&AlgGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_ALG_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(AlgGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        AlgNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&AlgSupportFunctions, sizeof(AlgSupportFunctions));
        } else {
            CopyMemory(
                &AlgSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        //
        // Obtain a handle to the kernel-mode translation module.
        //

        Error = NatInitializeTranslator(&AlgTranslatorHandle);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing translator",
                Error
                );
            break;
        }

        //
        // Obtain a port-reservation handle
        //

        Error = NatInitializePortReservation(
            ALG_PORT_RESERVATION_BLOCK_SIZE, 
            &AlgPortReservationHandle
            );


        if (Error) 
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing port-reservation",
                Error
                );
            break;
        }

        AlgTimerQueueHandle = CreateTimerQueue();
        if (AlgTimerQueueHandle == NULL) {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing timer queue",
                Error
                );
            break;
        }



        //
        // Start the ALG.exe
        //
        Initialise_ALG();
        


        LeaveCriticalSection(&AlgGlobalInfoLock);
        InterlockedExchange(reinterpret_cast<LPLONG>(&AlgProtocolStopped), 0);

    } while (FALSE);

    if (NO_ERROR != Error) {
        NhStopEventLog();
    }

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmStartProtocol


ULONG
APIENTRY
AlgRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{

    return NO_ERROR;

} // AlgRmStartComplete


ULONG
APIENTRY
AlgRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    MYTRACE_ENTER("AlgRmStopProtocol");
    PROFILE("AlgRmStopProtocol");
    
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
  

	//
	// Stop all ALG
	//
    HRESULT hr;

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {

        IAlgController* pIAlgController=NULL;

        hr = GetAlgControllerInterface(&pIAlgController);

        if ( SUCCEEDED(hr) )
        {
            hr = pIAlgController->Stop();
            
            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmStopProtocol: Error (0x%08x) returned from pIalgController->Stop()",
                    hr
                    );
            }

            ULONG nRef = pIAlgController->Release();

            //
            // We are done with the ALG 
            // Free the GIT and AlgController interface
            //
            FreeAlgControllerInterface();
        }
    }

    COMINIT_END;



    //
    // Drop the initial reference to cause a cleanup
    //
    ReleaseInitialComponentReference(&AlgComponentReference);


    MYTRACE_STOP;

    return DEREFERENCE_ALG() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // AlgRmStopProtocol




ULONG
APIENTRY
AlgRmAddInterface(
    PWCHAR              Name,
    ULONG               Index,
    NET_INTERFACE_TYPE  Type,
    ULONG               MediaType,
    USHORT              AccessType,
    USHORT              ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("AlgRmAddInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);


    ULONG Error = NO_ERROR;
    //
    // Also notify the ALG.exe manager
    //
    HRESULT hr = S_OK;
    
    Error = AlgCreateInterface(Index,
                               Type,
                               (PIP_ALG_INTERFACE_INFO) InterfaceInfo,
                               NULL);

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmAddInterface


ULONG
APIENTRY
AlgRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = S_OK;
    PROFILE("AlgRmDeleteInterface");


    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = AlgDeleteInterface(Index);

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmDeleteInterface





ULONG
APIENTRY
AlgRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = AlgRmBindInterface(Index, StatusInfo);
            } else {
                Error = AlgRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = AlgRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = AlgRmDisableInterface(Index);
            break;
        }
    }

    return Error;

} // AlgRmInterfaceStatus


ULONG
AlgRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmBindInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = AlgBindInterface(Index, (PIP_ADAPTER_BINDING_INFO)BindingInfo);
    
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmBindInterface


ULONG
AlgRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmUnbindInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
    
    Error = AlgUnbindInterface( Index );

    
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmUnbindInterface


ULONG
AlgRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmEnableInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
    
    
    Error = AlgEnableInterface( Index );

    
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmEnableInterface


ULONG
AlgRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmDisableInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    
    Error = AlgDisableInterface( Index );


    DEREFERENCE_ALG_AND_RETURN(Error);
} // AlgRmDisableInterface


ULONG
APIENTRY
AlgRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("AlgRmGetGlobalInfo");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&AlgGlobalInfoLock);
    Size = sizeof(*AlgGlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&AlgGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_ALG_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, AlgGlobalInfo, Size);
    LeaveCriticalSection(&AlgGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}

    DEREFERENCE_ALG_AND_RETURN(NO_ERROR);
} // AlgRmGetGlobalInfo


ULONG
APIENTRY
AlgRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_ALG_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("AlgRmSetGlobalInfo");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*AlgGlobalInfo);
    NewInfo = reinterpret_cast<PIP_ALG_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "AlgRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_ALG_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_ALG_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&AlgGlobalInfoLock);
    OldFlags = AlgGlobalInfo->Flags;
    NH_FREE(AlgGlobalInfo);
    AlgGlobalInfo = NewInfo;
    NewFlags = AlgGlobalInfo->Flags;
    LeaveCriticalSection(&AlgGlobalInfoLock);

    DEREFERENCE_ALG_AND_RETURN(NO_ERROR);
} // AlgRmSetGlobalInfo

ULONG
AlgRmPortMappingChanged(
    ULONG Index,
    UCHAR Protocol,
    USHORT Port
    )

/*++

Routine Description:

    This routine is invoked when a port mapping has changed for
    an interface.

Arguments:

    Index - the index of the interface on which the port mapping 
        changed.

    Protcol - the IP protocol for the port mapping

    Port - the port for the port mapping
    
Return Value:

    ULONG - Win32 status code

Environment:

    This method must be called by a COM-initialized thread.

--*/

{
    ULONG Error = NO_ERROR;
    HRESULT hr;
    IAlgController* pIAlgController;
    
    PROFILE("AlgRmPortMappingChanged");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    hr = GetAlgControllerInterface(&pIAlgController);
    if (SUCCEEDED(hr))
    {
        hr = pIAlgController->Adapter_PortMappingChanged(
                Index,
                Protocol,
                Port
                );
        
        pIAlgController->Release();
    }

    if (FAILED(hr))
    {
        Error = ERROR_CAN_NOT_COMPLETE;
    }

    DEREFERENCE_ALG_AND_RETURN(Error);
} // AlgRmPortMappingChanged






//
// Added for RRAS support
//


ULONG
APIENTRY
AlgRmGetEventMessage(
                     OUT ROUTING_PROTOCOL_EVENTS* Event,
                     OUT MESSAGE* Result
                     )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/
{
    if (InterlockedExchange((LPLONG)&AlgProtocolStopped, 0))
    {
        if ( NULL != Event ) 
            *Event = ROUTER_STOPPED;

        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // AlgRmGetEventMessage


ULONG
APIENTRY
AlgRmGetInterfaceInfo(
                      ULONG Index,
                      PVOID InterfaceInfo,
                      IN OUT PULONG InterfaceInfoSize,
                      IN OUT PULONG StructureVersion,
                      IN OUT PULONG StructureSize,
                      IN OUT PULONG StructureCount
                      )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/
{
    ULONG Error;

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = AlgQueryInterface(Index,
                              (PIP_ALG_INTERFACE_INFO)InterfaceInfo,
                              InterfaceInfoSize);

    *StructureSize = *InterfaceInfoSize;

    if (StructureCount)
    {
        *StructureCount = 1;
    }

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmGetInterfaceInfo


ULONG
APIENTRY
AlgRmSetInterfaceInfo(
                      ULONG Index,
                      PVOID InterfaceInfo,
                      ULONG StructureVersion,
                      ULONG StructureSize,
                      ULONG StructureCount
                      )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/
{
    ULONG Error;
    
    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = AlgConfigureInterface(Index,
                                   (PIP_ALG_INTERFACE_INFO)InterfaceInfo);

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmSetInterfaceInfo

ULONG
APIENTRY
AlgRmMibCreate(
               ULONG InputDataSize,
               PVOID InputData
               )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
AlgRmMibDelete(
               ULONG InputDataSize,
               PVOID InputData
               )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
AlgRmMibGet(
            ULONG InputDataSize,
            PVOID InputData,
            OUT PULONG OutputDataSize,
            OUT PVOID OutputData
            )

/*++

Routine Description:

    The transparent proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/
{
    ULONG Error;
    PIP_ALG_MIB_QUERY Oidp;

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize)
    {
        Error = ERROR_INVALID_PARAMETER;
    } 
    else
    {
        Oidp = (PIP_ALG_MIB_QUERY)InputData;
        switch (Oidp->Oid)
        {
        case IP_ALG_STATISTICS_OID: 
            {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(AlgStatistics))
                {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(AlgStatistics);

                    Error = ERROR_INSUFFICIENT_BUFFER;
                } 
                else
                {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(AlgStatistics);

                    Oidp = (PIP_ALG_MIB_QUERY)OutputData;

                    Oidp->Oid = IP_ALG_STATISTICS_OID;

                    CopyMemory(Oidp->Data,
                               &AlgStatistics,
                               sizeof(AlgStatistics));

                    Error = NO_ERROR;
                }
                break;
            }
        default: 
            {
                NhTrace(TRACE_FLAG_ALG,
                        "AlgRmMibGet: oid %d invalid",
                        Oidp->Oid);

                Error = ERROR_INVALID_PARAMETER;

                break;
            }
        }
    }

    DEREFERENCE_ALG_AND_RETURN(Error);
}


ULONG
APIENTRY
AlgRmMibSet(
            ULONG InputDataSize,
            PVOID InputData
            )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
AlgRmMibGetFirst(
                 ULONG InputDataSize,
                 PVOID InputData,
                 OUT PULONG OutputDataSize,
                 OUT PVOID OutputData
                 )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
AlgRmMibGetNext(
                ULONG InputDataSize,
                PVOID InputData,
                OUT PULONG OutputDataSize,
                OUT PVOID OutputData
                )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpauto.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpauto.h

Abstract:

    This module contains declarations for generation of a client address
    from a given scope of addresses.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPAUTO_H_
#define _NATHLP_DHCPAUTO_H_

#define MAX_HARDWARE_ADDRESS_LENGTH 32

ULONG
DhcpAcquireUniqueAddress(
    PCHAR Name,
    ULONG NameLength,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    );

ULONG
DhcpGenerateAddress(
    PULONG Seed,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength,
    ULONG ScopeNetwork,
    ULONG ScopeMask
    );

BOOLEAN
DhcpIsReservedAddress(
    ULONG Address,
    PCHAR Name OPTIONAL,
    ULONG NameLength OPTIONAL
    );

BOOLEAN
DhcpIsUniqueAddress(
    ULONG Address,
    PBOOLEAN IsLocal,
    PUCHAR ConflictAddress OPTIONAL,
    PULONG ConflictAddressLength OPTIONAL
    );

ULONG
DhcpQueryReservedAddress(
    PCHAR Name,
    ULONG NameLength
    );

ULONG
DhcpConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pHostName,
    ULONG  HostNameLength,
    PWCHAR *ppszUnicode
    );

extern
BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    );

extern
BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    );

BOOL
DhcpGetLocalMacAddr(
    ULONG Address,
    PUCHAR MacAddr,
    PULONG MacAddrLength
    );

#endif // _NATHLP_DHCPAUTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\natprivateapi_imp.h ===
#pragma once

#include <ipnatapi.h>
#include <rasuip.h>

/////////////////////////////////////////////////////////////////////////////
// CNat
class ATL_NO_VTABLE CNat : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public INat
{


public:
    CNat()
    {
        m_hTranslatorHandle = NULL;
        m_pSidLocalService  = NULL;
        m_pSidLocalSystem   = NULL;
    }


    virtual ~CNat();


DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNat)


BEGIN_COM_MAP(CNat)
    COM_INTERFACE_ENTRY(INat)
END_COM_MAP()




//
// INat
//
public:
   

    STDMETHODIMP CreateDynamicRedirect(
        IN  ULONG       Flags, 
        IN  ULONG       AdapterIndex,
        IN  UCHAR       Protocol, 
        IN  ULONG       DestinationAddress, 
        IN  USHORT      DestinationPort, 
        IN  ULONG       SourceAddress, 
        IN  USHORT      SourcePort, 
        IN  ULONG       NewDestinationAddress, 
        IN  USHORT      NewDestinationPort, 
        IN  ULONG       NewSourceAddress,
        IN  USHORT      NewSourcePort,
        OUT HANDLE_PTR* DynamicRedirectHandle
        );

    STDMETHOD(CancelDynamicRedirect)(
        HANDLE_PTR      DynamicRedirectHandle
        );


    STDMETHODIMP CreateRedirect(
        IN  ULONG       nFlags, 
        IN  UCHAR       Protocol, 
        IN  ULONG       nDestinationAddress, 
        IN  USHORT      nDestinationPort, 
        IN  ULONG       nSourceAddress,
        IN  USHORT      nSourcePort,
        IN  ULONG       nNewDestinationAddress,
        IN  USHORT      nNewDestinationPort,
        IN  ULONG       nNewSourceAddress,
        IN  USHORT      nNewSourcePort,
        IN  ULONG       nRestrictAdapterIndex, 
        IN  DWORD_PTR   dwAlgProcessId,
        IN  HANDLE_PTR  hEventForCreate, 
        IN  HANDLE_PTR  hEventForDelete
        );

    STDMETHODIMP CancelRedirect(
        IN  UCHAR       Protocol, 
        IN  ULONG       nDestinationAddress, 
        IN  USHORT      nDestinationPort, 
        IN  ULONG       nSourceAddress,  
        IN  USHORT      nSourcePort,  
        IN  ULONG       nNewDestinationAddress,   
        IN  USHORT      nNewDestinationPort,   
        IN  ULONG       nNewSourceAddress,   
        IN  USHORT      nNewSourcePort
        );

    STDMETHODIMP 
    GetBestSourceAddressForDestinationAddress(
        IN  ULONG       ulDestinationAddress, 
        IN  BOOL        fDemandDial, 
        OUT ULONG*      pulBestSrcAddress
        );

    STDMETHODIMP CNat::LookupAdapterPortMapping(
        IN  ULONG       ulAdapterIndex,
        IN  UCHAR       Protocol,
        IN  ULONG       ulDestinationAddress,
        IN  USHORT      usDestinationPort,
        OUT ULONG*      pulRemapAddress,
        OUT USHORT*     pusRemapPort
        );

    STDMETHODIMP GetOriginalDestinationInformation(
        IN  UCHAR       Protocol,
        IN  ULONG       nDestinationAddress,
        IN  USHORT      nDestinationPort,
        IN  ULONG       nSourceAddress,
        IN  USHORT      nSourcePort,
        OUT ULONG*      pnOriginalDestinationAddress,
        OUT USHORT*     pnOriginalDestinationPort,
        OUT ULONG*      pulAdapterIndex
        );

    STDMETHODIMP ReleasePort(
        IN  USHORT      ReservedPortBase,  
        IN  USHORT      PortCount
        );

    STDMETHODIMP ReservePort(
        IN  USHORT      PortCount,   
        OUT PUSHORT     ReservedPortBase
        );

private:
    
    //
    // ALG expose publicly eAGL_TCP=1 and eALG_UP=2 and intenaly UDP is 0x11 and TCP is 0x06
    //
    inline UCHAR
    ProtocolConvertToNT(
        UCHAR  Protocol
        )
    {
        if ( Protocol== eALG_TCP )
            return NAT_PROTOCOL_TCP;

        if ( Protocol== eALG_UDP )
            return NAT_PROTOCOL_UDP;

        return Protocol;
    }

//
// Properties
//
private:

    HANDLE                      m_hTranslatorHandle;

    CComAutoCriticalSection     m_AutoCS_SIDAllocation;
    PSID                        m_pSidLocalService;
    PSID                        m_pSidLocalSystem;

    CComAutoCriticalSection     m_AutoCS_DynamicRedirect;
    CSimpleArray<HANDLE_PTR>    m_ListOfOutstandingRedirects;

//
// Helper private Methods
//
    inline HANDLE GetTranslatorHandle()
    {
        if ( !m_hTranslatorHandle )
        {
            LRESULT lRet = NatInitializeTranslator(&m_hTranslatorHandle);
            if ( ERROR_SUCCESS != lRet ) 
                return NULL;
        }

        return m_hTranslatorHandle;
    }

    bool
    IsTokenPartOfWellKnowSid(
        HANDLE              pTokenToCheck,
        WELL_KNOWN_SID_TYPE WellKnownSidToCheckAgainst,
        PSID&               pSidToCache
        );

    bool IsClientAllowedToCallUs();


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpif.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpif.c

Abstract:

    This module contains code for the DHCP allocator's interface management.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            15-Dec-2000
    Added DhcpGetPrivateInterfaceAddress()
    
--*/

#include "precomp.h"
#pragma hdrstop
#include <ipinfo.h>

extern "C" {
#include <iphlpstk.h>
}

//
// LOCAL TYPE DECLARATIONS
//

typedef struct _DHCP_DEFER_READ_CONTEXT {
    ULONG Index;
    SOCKET Socket;
    ULONG DeferralCount;
} DHCP_DEFER_READ_CONTEXT, *PDHCP_DEFER_READ_CONTEXT;

#define DHCP_DEFER_READ_TIMEOUT     (5 * 1000)

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY DhcpInterfaceList;
CRITICAL_SECTION DhcpInterfaceLock;

//
// Forward declarations
//

VOID NTAPI
DhcpDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DhcpDeferReadWorkerRoutine(
    PVOID Context
    );


ULONG
DhcpActivateInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating datagram-reads on each created socket

Arguments:

    Context - the index of the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'DhcpInterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    ULONG InterfaceCharacteristics;
    DHCP_INTERFACE_TYPE dhcpIfType;


    PROFILE("DhcpActivateInterface");

    //
    // Read the scope-network from which addresses are to be assigned
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);
    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask = DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    //
    // (re)take the interface lock for the duration of the routine
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (DHCP_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        return NO_ERROR;
    }

    InterfaceCharacteristics =
        NatGetInterfaceCharacteristics(
                Interfacep->Index
                );

    if (!InterfaceCharacteristics) {
        ACQUIRE_LOCK(Interfacep);
        Interfacep->DhcpInterfaceType = DhcpInterfaceInvalid;
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    if (NAT_IFC_BOUNDARY(InterfaceCharacteristics))
    {
        if (NAT_IFC_FW(InterfaceCharacteristics))
        {
            dhcpIfType = DhcpInterfaceBoundaryFirewalled;
        }
        else
        {
            dhcpIfType = DhcpInterfaceBoundary;
        }
    }
    else
    if (NAT_IFC_FW(InterfaceCharacteristics))
    {
        dhcpIfType = DhcpInterfaceFirewalled;
    }
    else
    {
        dhcpIfType = DhcpInterfacePrivate;
    }

    //
    // Create datagram sockets for receiving data on each logical network;
    // N.B. We exclude networks other than the scope network.
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    Interfacep->DhcpInterfaceType = dhcpIfType;

    if (DhcpInterfacePrivate != dhcpIfType)
    {
        //
        // DHCP should be active only on Private interfaces
        //
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpActivateInterface: ignoring NAT interface %d",
            Interfacep->Index
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_NAT_INTERFACE_IGNORED,
            0,
            "%d",
            Interfacep->Index
            );
        RELEASE_LOCK(Interfacep);            
        LeaveCriticalSection(&DhcpInterfaceLock);
        return NO_ERROR;
    }

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if ((Interfacep->BindingArray[i].Address & ScopeMask) !=
            (ScopeNetwork & ScopeMask)
            ) {
            NhErrorLog(
                IP_AUTO_DHCP_LOG_NON_SCOPE_ADDRESS,
                0,
                "%I%I%I",
                Interfacep->BindingArray[i].Address,
                ScopeNetwork,
                ScopeMask
                );
            continue;
        }
        Error =
            NhCreateDatagramSocket(
                Interfacep->BindingArray[i].Address,
                DHCP_PORT_SERVER,
                &Interfacep->BindingArray[i].Socket
                );
        if (Error) { break; }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (; (LONG)i >= 0; i--) {
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket
                );
            Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DhcpInterfaceLock);
        return Error;
    }

    //
    // Initiate read-operations on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if ((Interfacep->BindingArray[i].Address & ScopeMask) !=
            (ScopeNetwork & ScopeMask)
            ) { continue; }

        //
        // Make a reference to the interface;
        // this reference is released in the completion routine
        //

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        //
        // Initiate the read-operation
        //

        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Interfacep->BindingArray[i].Socket,
                NULL,
                DhcpReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Mask)
                );

        //
        // Drop the reference if a failure occurred
        //

        if (Error) {

            NhErrorLog(
                IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                Interfacep->BindingArray[i].Address
                );

            DHCP_DEREFERENCE_INTERFACE(Interfacep);

            //
            // Reissue the read-operation later
            //

            DhcpDeferReadInterface(
                Interfacep,
                Interfacep->BindingArray[i].Socket
                );

            Error = NO_ERROR;
        }

        //
        // Now make another reference for the client-request
        // with which we detect servers on the network.
        //

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        Error =
            DhcpWriteClientRequestMessage(
                Interfacep,
                &Interfacep->BindingArray[i]
                );

        //
        // Drop the reference if a failure occurred
        //

        if (Error) { DHCP_DEREFERENCE_INTERFACE(Interfacep); Error = NO_ERROR; }
    }

    //
    // cache that this particular interface is a non boundary NAT interface
    //
    Interfacep->Flags |= DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY;

    RELEASE_LOCK(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    return NO_ERROR;

} // DhcpActivateInterface


ULONG
DhcpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpBindInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (DHCP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    }
    else {
        Interfacep->BindingArray =
            reinterpret_cast<PDHCP_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(DHCP_BINDING))
                );
                
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "DhcpBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(DHCP_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        Interfacep->BindingArray[i].ClientSocket = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending = FALSE;
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        Error = DhcpActivateInterface(Interfacep);
    }

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpBindInterface


VOID
DhcpCleanupInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context.

--*/

{
    PROFILE("DhcpCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }
    
    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // DhcpCleanupInterface


ULONG
DhcpConfigureInterface(
    ULONG Index,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error;
    PDHCP_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("DhcpConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|DHCP_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(IP_AUTO_DHCP_INTERFACE_INFO));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DhcpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }
    else {

        CopyMemory(
            &Interfacep->Info,
            InterfaceInfo,
            sizeof(IP_AUTO_DHCP_INTERFACE_INFO)
            );

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DhcpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
        else
        if (!(OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) &&
            (NewFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                DhcpDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpConfigureInterface


ULONG
DhcpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo,
    OUT PDHCP_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the DHCP allocator.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpCreateInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (DhcpLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PDHCP_INTERFACE>(
                    NH_ALLOCATE(sizeof(DHCP_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "DhcpCreateInterface: error allocating interface"
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DHCP_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|DHCP_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&DhcpInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // DhcpCreateInterface


VOID
DhcpDeactivateInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'DhcpInterfaceLock' held by caller.

--*/

{
    ULONG i;

    PROFILE("DhcpDeactivateInterface");

    //
    // Stop all network I/O on the interface's logical networks
    //

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (Interfacep->BindingArray[i].Socket != INVALID_SOCKET) {
            NhDeleteDatagramSocket(Interfacep->BindingArray[i].Socket);
            Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        }
        if (Interfacep->BindingArray[i].ClientSocket != INVALID_SOCKET) {
            NhDeleteDatagramSocket(Interfacep->BindingArray[i].ClientSocket);
            Interfacep->BindingArray[i].ClientSocket = INVALID_SOCKET;
        }
    }

    //
    // clear interface status as a non boundary NAT interface
    //
    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY;

    RELEASE_LOCK(Interfacep);

} // DhcpDeactivateInterface


VOID NTAPI
DhcpDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to re-issue a deferred read when the countdown
    for the deferral completes.

Arguments:

    Context - holds information identifying the interface and socket

    TimedOut - indicates whether the countdown completed

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the component on our behalf.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG Error;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    NTSTATUS status;

    PROFILE("DhcpDeferReadCallbackRoutine");

    Contextp = (PDHCP_DEFER_READ_CONTEXT)Context;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    Interfacep = DhcpLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DHCP_INTERFACE_ACTIVE(Interfacep) ||
        !DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DHCP();
        return;
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the socket on which to reissue the read
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Contextp->Socket) {continue;}
    
        //
        // This is the binding on which to reissue the read.
        // If no pending timer is recorded, assume a rebind occurred, and quit.
        //

        if (!Interfacep->BindingArray[i].TimerPending) { break; }

        Interfacep->BindingArray[i].TimerPending = FALSE;

        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Interfacep->BindingArray[i].Socket,
                NULL,
                DhcpReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Mask)
                );

        RELEASE_LOCK(Interfacep);

        if (!Error) {
            NH_FREE(Contextp);
            DEREFERENCE_DHCP();
            return;
        }

        //
        // An error occurred; we'll have to retry later.
        // we queue a work item which sets the timer.
        //

        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpDeferReadCallbackRoutine: error %d reading interface %d",
            Error,
            Interfacep->Index
            );

        //
        // Reference the component on behalf of the work-item
        //

        if (REFERENCE_DHCP()) {
    
            //
            // Queue a work-item, reusing the deferral context
            //
    
            status =
                RtlQueueWorkItem(
                    DhcpDeferReadWorkerRoutine,
                    Contextp, 
                    WT_EXECUTEINIOTHREAD
                    );
    
            if (NT_SUCCESS(status)) {
                Contextp = NULL;
            }
            else {
                NH_FREE(Contextp);
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpDeferReadCallbackRoutine: error %d deferring %d",
                    Error,
                    Interfacep->Index
                    );
                DEREFERENCE_DHCP();
            }
        }

        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    //
    // The interface was not found; never mind.
    //

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    NH_FREE(Contextp);
    DEREFERENCE_DHCP();

} // DhcpDeferReadCallbackRoutine


VOID
DhcpDeferReadInterface(
    PDHCP_INTERFACE Interfacep,
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to defer a read-request on an interface,
    typically if an attempt to post a read failed.

Arguments:

    Interfacep - the interface on which to defer the request

    Socket - the socket on which to defer the request

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced and locked by the caller.
    The caller may release the reference upon return.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    NTSTATUS status;

    PROFILE("DhcpDeferReadInterface");

    //
    // Find the binding for the given socket.
    //

    status = STATUS_SUCCESS;

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Socket) { continue; }
    
        //
        // This is the binding. If there is already a timer for it,
        // then just return silently.
        //

        if (Interfacep->BindingArray[i].TimerPending) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }
    
        //
        // Allocate a context block for the deferral.
        //

        Contextp =
            (PDHCP_DEFER_READ_CONTEXT)
                NH_ALLOCATE(sizeof(DHCP_DEFER_READ_CONTEXT));

        if (!Contextp) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadInterface: cannot allocate deferral context"
                );
            status = STATUS_NO_MEMORY;
            break;
        }

        Contextp->Index = Interfacep->Index;
        Contextp->Socket = Socket;
        Contextp->DeferralCount = 1;
    
        //
        // Install a timer to re-issue the read request
        //

        status =
            NhSetTimer(
                &DhcpComponentReference,
                NULL,
                DhcpDeferReadCallbackRoutine,
                Contextp,
                DHCP_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Interfacep->BindingArray[i].TimerPending = TRUE;
        }
        else {
            NH_FREE(Contextp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadInterface: status %08x setting deferral timer",
                status
                );
        }

        break;
    }

    if (i >= Interfacep->BindingCount) { status = STATUS_UNSUCCESSFUL; }

} // DhcpDeferReadInterface


VOID APIENTRY
DhcpDeferReadWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to set a timer for reissuing a deferred read.

Arguments:

    Context - contains the context for the timer.

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the module made on our behalf.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    NTSTATUS status;

    PROFILE("DhcpDeferReadWorkerRoutine");

    Contextp = (PDHCP_DEFER_READ_CONTEXT)Context;
    ++Contextp->DeferralCount;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    Interfacep = DhcpLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DHCP_INTERFACE_ACTIVE(Interfacep) ||
        !DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DHCP();
        return;
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the binding on which to set the timer
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Contextp->Socket) {continue;}
    
        //
        // This is the binding on which to reissue the read.
        // If a timer is already pending, assume a rebind occurred, and quit.
        //

        if (Interfacep->BindingArray[i].TimerPending) { break; }

        //
        // Install a timer to re-issue the read request,
        // reusing the deferral context.
        //

        status =
            NhSetTimer(
                &DhcpComponentReference,
                NULL,
                DhcpDeferReadCallbackRoutine,
                Contextp,
                DHCP_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Contextp = NULL;
            Interfacep->BindingArray[i].TimerPending = TRUE;
        }
        else {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadWorkerRoutine: status %08x setting timer",
                status
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    if (Contextp) { NH_FREE(Contextp); }
    DEREFERENCE_DHCP();

} // DhcpDeferReadWorkerRoutine


ULONG
DhcpDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpDeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure it isn't already deleted
    //

    if (DHCP_INTERFACE_DELETED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d already deleted",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    DhcpDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    DhcpCleanupInterface(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    return NO_ERROR;

} // DhcpDeleteInterface


ULONG
DhcpDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!DHCP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (DHCP_INTERFACE_BOUND(Interfacep)) {
        DhcpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DhcpDisableInterface


ULONG
DhcpEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (DHCP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        Error = DhcpActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpEnableInterface


ULONG
DhcpInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DhcpInitializeInterfaceManagement");

    InitializeListHead(&DhcpInterfaceList);
    __try {
        InitializeCriticalSection(&DhcpInterfaceLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // DhcpInitializeInterfaceManagement


BOOLEAN
DhcpIsLocalHardwareAddress(
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given hardware address
    is for a local interface.

Arguments:

    HardwareAddress - the hardware address to find

    HardwareAddressLength - the length of the hardware address in bytes

Return Value:

    BOOLEAN - TRUE if the address is found, FALSE otherwise

--*/

{
    ULONG Error;
    ULONG i;
    PMIB_IFTABLE Table;

    //
    // if the hardware address length is zero, assume external address
    //
    if (!HardwareAddressLength || !HardwareAddress)
    {
        return FALSE;
    }

    Error =
        AllocateAndGetIfTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0, FALSE
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpIsLocalHardwareAddress: GetIfTableFromStack=%d", Error
            );
        return FALSE;
    }
    for (i = 0; i < Table->dwNumEntries; i++) {
        if (Table->table[i].dwPhysAddrLen == HardwareAddressLength &&
            memcmp(
                Table->table[i].bPhysAddr,
                HardwareAddress,
                HardwareAddressLength
                ) == 0) {
            HeapFree(GetProcessHeap(), 0, Table);
            return TRUE;
        }
    }
    HeapFree(GetProcessHeap(), 0, Table);
    return FALSE;

} // DhcpIsLocalHardwareAddress


PDHCP_INTERFACE
DhcpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PDHCP_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'DhcpInterfaceLock'
    held by caller.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpLookupInterface");

    for (Link = DhcpInterfaceList.Flink;
         Link != &DhcpInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (Index > Interfacep->Index) { continue; }
        else
        if (Index < Interfacep->Index) { break; }

        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // DhcpLookupInterface


ULONG
DhcpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!DHCP_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    if (*InterfaceInfoSize < sizeof(IP_AUTO_DHCP_INTERFACE_INFO)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_AUTO_DHCP_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (!InterfaceInfo) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);    
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_AUTO_DHCP_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_AUTO_DHCP_INTERFACE_INFO);

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DhcpQueryInterface


VOID
DhcpReactivateEveryInterface(
    VOID
    )

/*++

Routine Description:

    This routine is called to reactivate all activate interfaces
    when a change occurs to the global DHCP configuration.
    Thus if, for instance, the scope network has been changed and is now 
    either valid or invalid, during deactivation all sockets are closed,
    and during reactivation they are or are not reopened as appropriate.
    depending on the validity or invalidity of the new configuration.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from a router-manager thread with no locks held.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpReactivateEveryInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    for (Link = DhcpInterfaceList.Flink; Link != &DhcpInterfaceList;
         Link = Link->Flink) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
            DhcpDeactivateInterface(Interfacep);
            DhcpActivateInterface(Interfacep);
        }

        DHCP_DEREFERENCE_INTERFACE(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

} // DhcpReactivateEveryInterface


VOID
DhcpShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked internally in an arbitrary thread context,
    after all references to all interfaces have been released.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpShutdownInterfaceManagement");

    while (!IsListEmpty(&DhcpInterfaceList)) {
        Link = RemoveHeadList(&DhcpInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);
        if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
            DhcpDeactivateInterface(Interfacep);
        }
        DhcpCleanupInterface(Interfacep);
    }

    DeleteCriticalSection(&DhcpInterfaceLock);

} // DhcpShutdownInterfaceManagement


VOID
DhcpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the DHCP allocator
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpSignalNatInterface");

    EnterCriticalSection(&DhcpGlobalInfoLock);
    if (!DhcpGlobalInfo) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&DhcpGlobalInfoLock);
    EnterCriticalSection(&DhcpInterfaceLock);
    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        return;
    }
    DhcpDeactivateInterface(Interfacep);
    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        DhcpActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

} // DhcpSignalNatInterface


ULONG
DhcpUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!DHCP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (DHCP_INTERFACE_ENABLED(Interfacep)) {
        DhcpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    if (Interfacep->BindingArray)
    {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // DhcpUnbindInterface


ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to return the IP address on which DHCP
    has been enabled (and which matches the scope net and mask).

Arguments:

    none.

Return Value:

    Bound IP address if an address is found (else 0).

Environment:

    Invoked from an arbitrary context.
    
--*/
{
    PROFILE("DhcpGetPrivateInterfaceAddress");

    ULONG   ipAddr = 0;
    ULONG   ulRet  = NO_ERROR;

    //
    // Find out the interface on which we are enabled and
    // return the primary IP address to which we are bound.
    // (Try to match the scope to the IP address.)
    //

    PDHCP_INTERFACE Interfacep = NULL;
    PLIST_ENTRY     Link;
    ULONG           i;
    BOOLEAN         IsNatInterface;
   
    //
    // Get Scope information from DHCP Global Info
    //    
    ULONG ScopeNetwork          = 0;
    ULONG ScopeMask             = 0;

    EnterCriticalSection(&DhcpGlobalInfoLock);

    //
    // Check to see if we have been initialized
    //
    if (!DhcpGlobalInfo)
    {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return ipAddr;
    }

    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask    = DhcpGlobalInfo->ScopeMask;

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    EnterCriticalSection(&DhcpInterfaceLock);

    if (ScopeNetwork && ScopeMask)
    {
        ULONG NetAddress = ScopeNetwork & ScopeMask;
        
        //
        // Search & Retrieve the interface to be configured
        //
        for (Link = DhcpInterfaceList.Flink;
             Link != &DhcpInterfaceList;
             Link = Link->Flink
             )
        {
            Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

            ACQUIRE_LOCK(Interfacep);

            if (DhcpInterfacePrivate != Interfacep->DhcpInterfaceType)
            {
                RELEASE_LOCK(Interfacep);
                continue;
            }

            for (i = 0; i < Interfacep->BindingCount; i++)
            {
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpGetPrivateInterfaceAddress: IP address %s (Index %d)",
                    INET_NTOA(Interfacep->BindingArray[i].Address),
                    Interfacep->Index
                    );
                    
                if (NetAddress == (Interfacep->BindingArray[i].Address &
                                   Interfacep->BindingArray[i].Mask))
                {
                    ipAddr = Interfacep->BindingArray[i].Address;
                    break;
                }
            }
            
            RELEASE_LOCK(Interfacep);

            if (ipAddr)
            {
                LeaveCriticalSection(&DhcpInterfaceLock);

                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpGetPrivateInterfaceAddress: Dhcp private interface IP address %s (Index %d)",
                    INET_NTOA(ipAddr),
                    Interfacep->Index
                    );
                
                return ipAddr;
            }
        }
    }

    // default to trying interface 0
    
    if (!(Interfacep = DhcpLookupInterface(0, NULL)))
    {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpGetPrivateInterfaceAddress: interface index 0 (default) not found"
            );
        return 0;
    }

    ACQUIRE_LOCK(Interfacep);

    if (DhcpInterfacePrivate != Interfacep->DhcpInterfaceType)
    {
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DhcpInterfaceLock);
        return 0;
    }

    if (Interfacep->BindingCount)
    {
        //
        // simply take the first address available
        //
        ipAddr = Interfacep->BindingArray[0].Address;
    }
    
    RELEASE_LOCK(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    NhTrace(
        TRACE_FLAG_DHCP,
        "DhcpGetPrivateInterfaceAddress: Dhcp private interface IP address %s (Index 0)",
        INET_NTOA(ipAddr)
        );

    return ipAddr;
} // DhcpGetPrivateInterfaceAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpauto.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpauto.c

Abstract:

    This module contains code for automatic selection of a client address
    from a given scope of addresses.
    It makes use of a hashing function which accounts for the client's
    hardware address.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            5-Jul-2001
    +Changed DhcpIsReservedAddress & DhcpQueryReservedAddress to
    handle variable length name strings.
    +Added DhcpConvertHostNametoUnicode (mimics DhcpServer effect)
    Raghu Gatta (rgatta)            17-Jul-2001
    +Added DhcpGetLocalMacAddr
--*/

#include "precomp.h"
#pragma hdrstop

ULONG
DhcpAcquireUniqueAddress(
    PCHAR Name,
    ULONG NameLength,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    )

/*++

Routine Description:

    This routine is invoked to acquire a unique address for a client
    using the given hardware address to decrease the likelihood of collision.

Arguments:

    Name - the name of the host for whom the address is being requested.
        If this matches the name of a server in the shared-access server-list,
        the address reserved for the server is returned.

    NameLength - length of 'Name', excluding any terminating 'nul'.

    HardwareAddress - the hardware address to be used

    HardwareAddressLength - the length of the hardware address

Return Value:

    ULONG - the generated IP address

Environment:

    Invoked from an arbitrary context.

--*/

{
    ULONG AssignedAddress;
    ULONG i = 0;
    PLIST_ENTRY Link;
    ULONG ScopeMask;
    ULONG ScopeNetwork;
    ULONG Seed = GetTickCount();
    BOOLEAN bUnused;

    PROFILE("DhcpAcquireUniqueAddress");

    EnterCriticalSection(&DhcpGlobalInfoLock);
    if (Name &&
        (AssignedAddress = DhcpQueryReservedAddress(Name, NameLength))) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpAcquireUniqueAddress: returning mapping to %s",
            INET_NTOA(AssignedAddress)
            );
        return AssignedAddress;
    }
    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask = DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    do {

        if (++i > 4) { AssignedAddress = 0; break; }

        //
        // Generate an address
        //

        do {
            AssignedAddress = 
                DhcpGenerateAddress(
                    &Seed,
                    HardwareAddress,
                    HardwareAddressLength,
                    ScopeNetwork,
                    ScopeMask
                    );
        } while(
            (AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask
            );
    
    } while(!DhcpIsUniqueAddress(AssignedAddress, &bUnused, NULL, NULL));

    return AssignedAddress;

} // DhcpAcquireUniqueAddress


ULONG
DhcpGenerateAddress(
    PULONG Seed,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength,
    ULONG ScopeNetwork,
    ULONG ScopeMask
    )

/*++

Routine Description:

    This routine is invoked to compute a randomized hash value 
    for a client IP address using a hardware-address.

Arguments:

    Seed - contains (and receives) the seed to 'RtlRandom'

    HardwareAddress - the hardware address to be used

    HardwareAddressLength - the length of the hardware address

    ScopeNetwork - the network into which the generated address
        will be constrained

    ScopeMask - the mask for the scope network

Return Value:

    ULONG - the generated IP address

Environment:

    Invoked from an arbitrary context.

Revision History:

    Based on 'GrandHashing' from net\sockets\tcpcmd\dhcpm\client\dhcp
    by RameshV.

--*/

{
    ULONG Hash;
    ULONG Shift;

#if 1
    Hash = RtlRandom(Seed) & 0xffff0000;
    Hash |= RtlRandom(Seed) >> 16;
#else
    Seed = GetTickCount();

    Seed = Seed * 1103515245 + 12345;
    Hash = (Seed) >> 16;
    Hash <<= 16;
    Seed = Seed * 1103515245 + 12345;
    Hash += Seed >> 16;
#endif

    Shift = Hash % sizeof(ULONG);

    while(HardwareAddressLength--) {
        Hash += (*HardwareAddress++) << (8 * Shift);
        Shift = (Shift + 1) % sizeof(ULONG);
    }

    return (Hash & ~ScopeMask) | ScopeNetwork;

} // DnsGenerateAddress


BOOLEAN
DhcpIsReservedAddress(
    ULONG Address,
    PCHAR Name OPTIONAL,
    ULONG NameLength OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given IP address
    is reserved for another client.

Arguments:

    Address - the IP address to be determined

    Name - optionally specifies the client on whose behalf the call is made

    NameLength - specifies the length of 'Name' excluding the terminating nul

Return Value:

    BOOLEAN - TRUE if the address is reserved for another client,
        FALSE otherwise.

Environment:

    Invoked with 'DhcpGlobalInfoLock' held by the caller.

--*/

{
    ULONG Error = NO_ERROR;
    PLIST_ENTRY Link;
    PNAT_DHCP_RESERVATION Reservation;
    PWCHAR pszUnicodeHostName = NULL;
    
    EnterCriticalSection(&NhLock);
    if (IsListEmpty(&NhDhcpReservationList)) {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    }
    if (Name) {
        Error = DhcpConvertHostNametoUnicode(
                    CP_OEMCP,       // atleast Windows clients send it this way
                    Name,
                    NameLength,
                    &pszUnicodeHostName
                    );
        if (NO_ERROR != Error) {
            LeaveCriticalSection(&NhLock);
            if (pszUnicodeHostName) {
                NH_FREE(pszUnicodeHostName);
            }
            //
            // we can return true or false on failure
            // better we return false - otherwise the client will be in a continuous
            // loop trying to get another address when we NACK its request
            //
            return FALSE;
        }
    }
    for (Link = NhDhcpReservationList.Flink;
         Link != &NhDhcpReservationList; Link = Link->Flink) {
        Reservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);
        if (Address == Reservation->Address) {
            //
            // Address matches but Name does not (regular case)
            // we return TRUE since address reserved for someone else
            //
            if (!pszUnicodeHostName ||
                !Reservation->Name  ||
                lstrcmpiW(pszUnicodeHostName, Reservation->Name)) {
                LeaveCriticalSection(&NhLock);
                if (pszUnicodeHostName) {
                    NH_FREE(pszUnicodeHostName);
                }
                return TRUE;
            }
            //
            // Address and Name BOTH match
            // we fall through and return FALSE since we want this address to be selected
            //
            else
                break;
        } else {
            //
            // Name matches but Address does not (irregular case)
            // we return TRUE since another address has been reserved for this name
            //
            if (pszUnicodeHostName &&
                Reservation->Name  &&
                lstrcmpiW(pszUnicodeHostName, Reservation->Name) == 0) {
                LeaveCriticalSection(&NhLock);
                if (pszUnicodeHostName) {
                    NH_FREE(pszUnicodeHostName);
                }
                return TRUE;
            }
            //
            // Neither Address nor Name match
            // continue searching
            //            
        }
    }
    LeaveCriticalSection(&NhLock);

    if (pszUnicodeHostName) {
        NH_FREE(pszUnicodeHostName);
    }
    return FALSE;
} // DhcpIsReservedAddress


BOOLEAN
DhcpIsUniqueAddress(
    ULONG Address,
    PBOOLEAN IsLocal,
    PUCHAR ConflictAddress OPTIONAL,
    PULONG ConflictAddressLength OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given address
    is unique on the directly connected subnetworks.

    The determination accounts for any configured static addresses
    included in the global information.

Arguments:

    Address - the address whose uniqueness is to be determined

    IsLocal - pointer to BOOLEAN which receives info about whether
        the requested address is one of the local interfaces' address

    ConflictAddress - optionally receives a copy of the conflicting
        hardware address if a conflict is found

    ConflictAddressLength - if 'ConflictAddress' is set, receives
        the length of the conflicting address.

Return Value:

    BOOLEAN - TRUE if unique, FALSE otherwise.

--*/

{
    BOOLEAN ConflictFound = FALSE;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    BOOLEAN IsNatInterface;
    PLIST_ENTRY Link;
    ULONG SourceAddress;

    PROFILE("DhcpIsUniqueAddress");

    *IsLocal = FALSE;

    //
    // See if this is a static address
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);

    if (DhcpGlobalInfo && DhcpGlobalInfo->ExclusionCount) {
        for (i = 0; i < DhcpGlobalInfo->ExclusionCount; i++) {
            if (Address == DhcpGlobalInfo->ExclusionArray[i]) {
                LeaveCriticalSection(&DhcpGlobalInfoLock);
                if (ConflictAddressLength) { *ConflictAddressLength = 0; }
                return FALSE;
            }
        }
    }

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    //
    // Try to detect collisions
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    for (Link = DhcpInterfaceList.Flink;
         Link != &DhcpInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (DHCP_INTERFACE_DELETED(Interfacep)) { continue; }

        ACQUIRE_LOCK(Interfacep);

        //
        // We send out an ARP request unless
        //  (a) the interface is a boundary interface
        //  (b) the interface is not NAT-enabled
        //  (c) the allocator is not active on the interface
        //  (d) the interface is not a LAN adapter
        //  (e) the interface has no bindings.
        //

        if (!DHCP_INTERFACE_NAT_NONBOUNDARY(Interfacep) ||
            !DHCP_INTERFACE_ACTIVE(Interfacep) ||
            (Interfacep->Type != PERMANENT) ||
            !Interfacep->BindingCount) {
            RELEASE_LOCK(Interfacep);
            continue;
        }

        for (i = 0; i < Interfacep->BindingCount; i++) {

            SourceAddress = Interfacep->BindingArray[i].Address;
            ExistingAddressLength = sizeof(ExistingAddress);

            if (SourceAddress == Address)
            {
                //
                // check to see that requested address is not same as
                // one of the local addresses on the NAT box
                //
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpIsUniqueAddress: %s is in use locally",
                    INET_NTOA(Address)
                    );

                if (ConflictAddress && ConflictAddressLength) {
                    if (DhcpGetLocalMacAddr(
                            Address,
                            ExistingAddress,
                            &ExistingAddressLength
                            ))
                    {
                        if (ExistingAddressLength > MAX_HARDWARE_ADDRESS_LENGTH) {
                            ExistingAddressLength = MAX_HARDWARE_ADDRESS_LENGTH;
                        }
                        CopyMemory(
                            ConflictAddress,
                            ExistingAddress,
                            ExistingAddressLength
                            );
                        *ConflictAddressLength = ExistingAddressLength;                
                    }
                    else
                    {
                        *ConflictAddressLength = 0;
                    }
                }
                *IsLocal = TRUE;
                ConflictFound = TRUE;
                break;
            }

            RELEASE_LOCK(Interfacep);

            Error =
                SendARP(
                    Address,
                    SourceAddress,
                    (PULONG)ExistingAddress,
                    &ExistingAddressLength
                    );

            ACQUIRE_LOCK(Interfacep);

            if (Error) {
                NhWarningLog(
                    IP_AUTO_DHCP_LOG_SENDARP_FAILED,
                    Error,
                    "%I%I",
                    Address,
                    SourceAddress
                    );
            } else if (ExistingAddressLength &&
                       ExistingAddressLength <= sizeof(ExistingAddress)) {
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpIsUniqueAddress: %s is in use",
                    INET_NTOA(Address)
                    );
#if DBG
                NhDump(
                    TRACE_FLAG_DHCP,
                    ExistingAddress,
                    ExistingAddressLength,
                    1
                    );
#endif
                if (ConflictAddress && ConflictAddressLength) {
                    if (ExistingAddressLength > MAX_HARDWARE_ADDRESS_LENGTH) {
                        ExistingAddressLength = MAX_HARDWARE_ADDRESS_LENGTH;
                    }
                    CopyMemory(
                        ConflictAddress,
                        ExistingAddress,
                        ExistingAddressLength
                        );
                    *ConflictAddressLength = ExistingAddressLength;
                }
                ConflictFound = TRUE;
                break;
            }
        }

        RELEASE_LOCK(Interfacep);

        if (ConflictFound) { break; }
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    return ConflictFound ? FALSE : TRUE;

} // DhcpIsUniqueAddress


ULONG
DhcpQueryReservedAddress(
    PCHAR Name,
    ULONG NameLength
    )

/*++

Routine Description:

    This routine is called to determine whether the given machine name
    corresponds to an entry in the list of reserved addresses.

Arguments:

    Name - specifies the machine name, which might not be nul-terminated.

    NameLength - specifies the length of the given machine name,
        not including any terminating nul character.

Return Value:

    ULONG - the IP address of the machine, if any.

Environment:

    Invoked with 'DhcpGlobalInfoLock' held by the caller.

--*/

{
    ULONG Error = NO_ERROR;
    PLIST_ENTRY Link;
    ULONG ReservedAddress;
    PNAT_DHCP_RESERVATION Reservation;
    PWCHAR pszUnicodeHostName = NULL;

    EnterCriticalSection(&NhLock);
    if (IsListEmpty(&NhDhcpReservationList))
    {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    }
    if (Name) {
        Error = DhcpConvertHostNametoUnicode(
                    CP_OEMCP,       // atleast Windows clients send it this way
                    Name,
                    NameLength,
                    &pszUnicodeHostName
                    );
        if (NO_ERROR != Error) {
            LeaveCriticalSection(&NhLock);
            if (pszUnicodeHostName) {
                NH_FREE(pszUnicodeHostName);
            }
            return FALSE;
        }
    }
    for (Link = NhDhcpReservationList.Flink;
         Link != &NhDhcpReservationList; Link = Link->Flink)
    {
        Reservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);
        if (!pszUnicodeHostName || !Reservation->Name) { continue; }
        if (lstrcmpiW(pszUnicodeHostName, Reservation->Name)) { continue; }
        ReservedAddress = Reservation->Address;
        LeaveCriticalSection(&NhLock);
        if (pszUnicodeHostName) {
            NH_FREE(pszUnicodeHostName);
        }
        return ReservedAddress;
    }
    LeaveCriticalSection(&NhLock);

    if (pszUnicodeHostName) {
        NH_FREE(pszUnicodeHostName);
    }
    return 0;
} // DhcpQueryReservedAddress


//
// Utility routines
//

ULONG
DhcpConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pHostName,
    ULONG  HostNameLength,
    PWCHAR *ppszUnicode
    )
{
    //
    // make sure to free the returned Unicode hostname
    //
    
    DWORD  dwSize = 0;
    ULONG  Error = NO_ERROR;
    PCHAR  pszHostName = NULL;
    LPBYTE pszUtf8HostName = NULL;  // copy of pszHostName in Utf8 format
    PWCHAR pszUnicodeHostName = NULL;

    if (ppszUnicode)
    {
        *ppszUnicode = NULL;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        //
        // create a null terminated copy
        //
        dwSize = HostNameLength + 4;
        pszHostName = reinterpret_cast<PCHAR>(NH_ALLOCATE(dwSize));
        if (!pszHostName)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DhcpConvertHostNametoUnicode: allocation failed for "
                "hostname copy buffer"
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pszHostName, dwSize);
        memcpy(pszHostName, pHostName, HostNameLength);
        pszHostName[HostNameLength] = '\0';

        //
        // convert the given hostname to a Unicode string
        //
        
        if (CP_UTF8 == CodePage)
        {
            pszUtf8HostName = (LPBYTE)pszHostName;
        }
        else
        {
            //
            // now convert this into UTF8 format
            //
            if (!ConvertToUtf8(
                     CodePage,
                     (LPSTR)pszHostName,
                     (PCHAR *)&pszUtf8HostName,
                     &dwSize))
            {
                Error = GetLastError();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DhcpConvertHostNametoUnicode: conversion from "
                    "CodePage %d to UTF8 for hostname failed "
                    "with error %ld (0x%08x)",
                    CodePage,
                    Error,
                    Error
                    );
                break;
            }
        }

        //
        // now convert UTF8 string into Unicode format
        //
        if (!ConvertUTF8ToUnicode(
                     pszUtf8HostName,
                     (LPWSTR *)&pszUnicodeHostName,
                     &dwSize))
        {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_DNS,
                "DhcpConvertHostNametoUnicode: conversion from "
                "UTF8 to Unicode for hostname failed "
                "with error %ld (0x%08x)",
                Error,
                Error
                );
            if (pszUnicodeHostName)
            {
                NH_FREE(pszUnicodeHostName);
            }
            break;
        }

        *ppszUnicode = pszUnicodeHostName;

        NhTrace(
            TRACE_FLAG_DNS,
            "DhcpConvertHostNametoUnicode: succeeded! %S",
            pszUnicodeHostName
            );
            
    } while (FALSE);

    if (pszHostName)
    {
        NH_FREE(pszHostName);
    }
    
    if ((CP_UTF8 != CodePage) && pszUtf8HostName)
    {
        NH_FREE(pszUtf8HostName);
    }

    return Error;

} // DhcpConvertHostNametoUnicode

BOOL
DhcpGetLocalMacAddr(
    ULONG Address,
    PUCHAR MacAddr,
    PULONG MacAddrLength
    )

/*++

Routine Description:

    This routine is invoked to determine the local physical MAC address
    for the given local IP address.

Arguments:

    Address - the local IP address

    MacAddr - buffer for holding the MAC addr (upto MAX_HARDWARE_ADDRESS_LENGTH)

    MacAddrLength - specifies the length of 'MacAddr'

Return Value:

    BOOLEAN - TRUE if we are able to get the MAC address,
        FALSE otherwise.

Environment:

    Invoked from DhcpIsUniqueAddress().

--*/

{
    BOOL            bRet = FALSE;
    DWORD           Error = NO_ERROR;
    PMIB_IPNETTABLE IpNetTable = NULL;
    PMIB_IPNETROW   IpNetRow = NULL;
    DWORD           dwPhysAddrLen = 0, i;
    ULONG           dwSize = 0;
    
    do
    {
        //
        // retrieve size of address mapping table
        //
        Error = GetIpNetTable(
                    IpNetTable,
                    &dwSize,
                    FALSE
                    );

        if (!Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: should NOT have returned %d",
                Error
                );
            break;
        }
        else
        if (ERROR_INSUFFICIENT_BUFFER != Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: GetIpNetTable=%d",
                Error
                );
            break;
        }

        //
        // allocate a buffer
        //
        IpNetTable = (PMIB_IPNETTABLE)NH_ALLOCATE(dwSize);

        if (!IpNetTable)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: error allocating %d bytes",
                dwSize
                );
            break;
        }

        //
        // retrieve the address mapping table
        //
        Error = GetIpNetTable(
                    IpNetTable,
                    &dwSize,
                    FALSE
                    );

        if (NO_ERROR != Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: GetIpNetTable=%d size=%d",
                Error,
                dwSize
                );
            break;
        }

        for (i = 0; i < IpNetTable->dwNumEntries; i++)
        {
            IpNetRow = &IpNetTable->table[i];

            if (IpNetRow->dwAddr == Address)
            {
                dwPhysAddrLen = IpNetRow->dwPhysAddrLen;
                if (dwPhysAddrLen > MAX_HARDWARE_ADDRESS_LENGTH)
                {
                    dwPhysAddrLen = MAX_HARDWARE_ADDRESS_LENGTH;
                }
                CopyMemory(
                    MacAddr,
                    IpNetRow->bPhysAddr,
                    dwPhysAddrLen
                    );
                *MacAddrLength = dwPhysAddrLen;
                bRet = TRUE;
                break;
            }
        }

    } while (FALSE);

    if (IpNetTable)
    {
        NH_FREE(IpNetTable);
    }

    return bRet;
} // DhcpGetLocalMacAddr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpif.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpif.h

Abstract:

    This module contains declarations for the DHCP allocator's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:
    
--*/

#ifndef _NATHLP_DHCPIF_H_
#define _NATHLP_DHCPIF_H_


//
// Enumeration: DHCP_INTERFACE_TYPE
// 4 Types of Interfaces possible:
//      (1) Private
//      (2) Boundary
//      (3) Firewalled
//      (4) Boundary + Firewalled
// DHCP should be active only on the Private Interface
// (A Public interface is simply a non-Private interface.)
//

typedef enum {
    DhcpInterfaceInvalid,
    DhcpInterfacePrivate,
    DhcpInterfaceBoundary,
    DhcpInterfaceFirewalled,
    DhcpInterfaceBoundaryFirewalled
} DHCP_INTERFACE_TYPE;



//
// Structure:   DHCP_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
// The 'TimerPending' field is set when a receive-attempt fails on an interface
// and a timer is queued to reattempt the receive later.
//

typedef struct _DHCP_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET Socket;
    SOCKET ClientSocket;
    BOOLEAN TimerPending;
} DHCP_BINDING, *PDHCP_BINDING;


//
// Structure:   DHCP_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of DHCP interfaces,
// sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('DhcpInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _DHCP_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index;
    NET_INTERFACE_TYPE Type;
    DHCP_INTERFACE_TYPE DhcpInterfaceType;
    IP_AUTO_DHCP_INTERFACE_INFO Info;
    ULONG Flags;
    ULONG BindingCount;
    PDHCP_BINDING BindingArray;
} DHCP_INTERFACE, *PDHCP_INTERFACE;

//
// Flags
//

#define DHCP_INTERFACE_FLAG_DELETED         0x80000000
#define DHCP_INTERFACE_DELETED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_DELETED)

#define DHCP_INTERFACE_FLAG_BOUND           0x40000000
#define DHCP_INTERFACE_BOUND(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_BOUND)

#define DHCP_INTERFACE_FLAG_ENABLED         0x20000000
#define DHCP_INTERFACE_ENABLED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_ENABLED)

#define DHCP_INTERFACE_FLAG_CONFIGURED      0x10000000
#define DHCP_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_CONFIGURED)

#define DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY 0x08000000
#define DHCP_INTERFACE_NAT_NONBOUNDARY(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY)

#define DHCP_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (DHCP_INTERFACE_FLAG_BOUND|DHCP_INTERFACE_FLAG_ENABLED)) \
        == (DHCP_INTERFACE_FLAG_BOUND|DHCP_INTERFACE_FLAG_ENABLED))

#define DHCP_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define DHCP_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, DHCP_INTERFACE_DELETED)

#define DHCP_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, DhcpCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY DhcpInterfaceList;
extern CRITICAL_SECTION DhcpInterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
DhcpActivateInterface(
    PDHCP_INTERFACE Interfacep
    );

ULONG
DhcpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
DhcpCleanupInterface(
    PDHCP_INTERFACE Interfacep
    );

ULONG
DhcpConfigureInterface(
    ULONG Index,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo
    );

ULONG
DhcpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo,
    PDHCP_INTERFACE* InterfaceCreated
    );

VOID
DhcpDeactivateInterface(
    PDHCP_INTERFACE Interfacep
    );

VOID
DhcpDeferReadInterface(
    PDHCP_INTERFACE Interfacep,
    SOCKET Socket
    );

ULONG
DhcpDeleteInterface(
    ULONG Index
    );

ULONG
DhcpDisableInterface(
    ULONG Index
    );

ULONG
DhcpEnableInterface(
    ULONG Index
    );

ULONG
DhcpInitializeInterfaceManagement(
    VOID
    );

BOOLEAN
DhcpIsLocalHardwareAddress(
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    );

PDHCP_INTERFACE
DhcpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
DhcpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
DhcpReactivateEveryInterface(
    VOID
    );

VOID
DhcpShutdownInterfaceManagement(
    VOID
    );

VOID
DhcpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
DhcpUnbindInterface(
    ULONG Index
    );

ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    );


#endif // _NATHLP_DHCPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\alg\natprivateapi_imp.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rmALG.cpp

Abstract:

    This module contains routines for the ALG Manager module's 
    private interface to be used only by the ALG.exe manager.

Author:

    JPDup		10-Nov-2000

Revision History:

--*/


#include "precomp.h"

#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>

#include "Alg.h"
#include "NatPrivateAPI_Imp.h"

#include <MyTrace.h>

#include <Rtutils.h>




extern HANDLE                   AlgPortReservationHandle;   // see rmALG.CPP




/////////////////////////////////////////////////////////////////////////////
// CNat






//
// Standard destructor
//
CNat::~CNat(void)
{
    MYTRACE_ENTER("CNat::~CNat(void)");

    if ( m_hTranslatorHandle )
        NatShutdownTranslator(m_hTranslatorHandle);

    if ( m_pSidLocalService )
    {
        MYTRACE("Free m_pSidLocalService");
        LocalFree(m_pSidLocalService);
    }

    if ( m_pSidLocalSystem )
    {
        MYTRACE("Free m_pSidLocalSystem");
        LocalFree(m_pSidLocalSystem);
    }


}






bool 
GetSecuritySID(
    WELL_KNOWN_SID_TYPE WellKnownSidToCreate,
    PSID&               pSidToReturn
    )
/*++

Routine Description:

    Creates a SID from a specified well know SID

Arguments:

    WellKnownSidToCreate    - Specify the well know SID to create from
    pSidToReturn            - pointer that will be allocated and populated with the SID attributes

Return Value:

    bool                    - true is the SID was successfully created
                            - false one or more error occurred

Environment:

    The routine will allocate the side so the caller is responsible for doing a LocalFree on the returned pSidToReturn pointer

--*/
{
    MYTRACE_ENTER("CNat::GetSecuritySID()");


    //
    // If theasked SID is not already cached then create it
    //
    if ( NULL == pSidToReturn )
    {
        DWORD dwSizeOfSid = SECURITY_MAX_SID_SIZE;

        // Allocate enough memory for the largest possible SID.
        if ( !(pSidToReturn = LocalAlloc(LMEM_FIXED, dwSizeOfSid)) )
        {    
            MYTRACE_ERROR("LocalAlloc got get LocalService", GetLastError());

            return false;
        }

        BOOL bRet = CreateWellKnownSid(
            WellKnownSidToCreate,
            NULL,
            pSidToReturn,
            &dwSizeOfSid
            );

            
        if ( !bRet )
        {
            MYTRACE_ERROR("From CreateWellKnownSid(LocalService)", GetLastError());
            LocalFree(pSidToReturn);
            pSidToReturn = NULL;

            return false;
        }
    }

    return true;
}





bool
CNat::IsTokenPartOfWellKnowSid(
    HANDLE              pTokenToCheck,
    WELL_KNOWN_SID_TYPE WellKnownSidToCheckAgainst,
    PSID&               pSidToCache
    )
/*++

Routine Description:

    Helper function that create/gets a well know sid and verify that the supplied token is a member of that SID

Arguments:

    pTokenToCheck           - Token that will be inspected
    WellKnownSidToCreate    - Specify the well know SID to check against
    pSidToCache             - pointer to a SID that you will need to LocalFree when done

Return Value:

    bool                    - true if the supplied token is member of the WellKnowSID
                            - false one or more error occurred

Environment:

    The caller of the 

--*/
{
    MYTRACE_ENTER("IsTokenPartOfWellKnowSid()");

    BOOL bRet;

    m_AutoCS_SIDAllocation.Lock();

    bRet = GetSecuritySID(
        WellKnownSidToCheckAgainst,
        pSidToCache
        );

    m_AutoCS_SIDAllocation.Unlock();

    if ( !bRet )
    {
        MYTRACE("GetSecuritySID failed");
        return false;
    }

    BOOL bIsMember;

    bRet = CheckTokenMembership(
            pTokenToCheck,
            pSidToCache,
            &bIsMember
            );

    if ( !bRet )
    {
        MYTRACE_ERROR("Call to CheckTokenMembership failed", GetLastError());
        return false;
    }

    if ( FALSE == bIsMember )
    {
        MYTRACE("Token %d is not a member of SID %d", pTokenToCheck, pSidToCache);
        return false;
    }

    return true;
}


bool 
CNat::IsClientAllowedToCallUs()
/*++

Routine Description:

    Verify that the current caller is part of the LocalService or LocalSystem group

Arguments:

    none


Return Value:

    bool            - true  = Part of one or the group
                    - false = access should be denied

Environment:

    The routine runs will allocate 2 sid and they must be freed when the CNat object is released
    see member variables m_pSidLocalService and m_pSidLocalSystem;

--*/
{
    MYTRACE_ENTER("CNat::IsClientAllowedToCallUs()");


    HRESULT hr;

    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("CoImpersonateClient() failed", hr);
        return false;
    }

    HANDLE  hClientToken = NULL;

    bool bClientIsAllowedAccess = false;

    if ( OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hClientToken) )
    {
        //
        // Try with LocalService, this is the normal expected scenario
        // 
        bClientIsAllowedAccess = IsTokenPartOfWellKnowSid(
            hClientToken,
            WinLocalServiceSid,
            m_pSidLocalService
            );

        if ( bClientIsAllowedAccess )
        {
            MYTRACE("Client is member of the LOCAL_SERVICE group");
        }
        else
        {
            //
            // For debugging purpose sometime you need to set the ALG service to LocalSystem
            // in this case we need to grant access also to LocalSystem account
            //
            bClientIsAllowedAccess = IsTokenPartOfWellKnowSid(
                hClientToken,
                WinLocalSystemSid,
                m_pSidLocalSystem
                );

            if ( bClientIsAllowedAccess )
            {
                MYTRACE("Client is member of the LOCAL_SYSTEM group");
            }
            else
            {
                MYTRACE("Client is NOT member of LOCAL_SERVICE or LOCAL_SYSTEM group");
            }
        }

        //
        // No need for this handle anymore
        //
        CloseHandle( hClientToken );
    }
    else
    {
        MYTRACE_ERROR("Could not OpenThreadToken", GetLastError());
    }



    //
    // Set security context back 
    //
    hr = CoRevertToSelf();

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("from CoRevertToSelf()", hr);
        return  false;;
    }

    return bClientIsAllowedAccess;

}

#define RETURN_IF_CLIENT_NOT_LOCAL_SERVICE  if ( !IsClientAllowedToCallUs() ) { return E_ACCESSDENIED; };



STDMETHODIMP 
CNat::CreateRedirect(
    IN  ULONG       Flags, 
    IN  UCHAR       Protocol, 

    IN  ULONG       DestinationAddress, 
    IN  USHORT      DestinationPort, 

    IN  ULONG       SourceAddress, 
    IN  USHORT      SourcePort, 

    IN  ULONG       NewDestinationAddress, 
    IN  USHORT      NewDestinationPort, 

    IN  ULONG       NewSourceAddress, 
    IN  USHORT      NewSourcePort, 

    IN  ULONG       RestrictAdapterIndex, 

    IN  DWORD_PTR   dwAlgProcessId,
    IN  HANDLE_PTR  hCreateEvent, 
    IN  HANDLE_PTR  hDeleteEvent
    )
{
/*++

Routine Description:

    Creates a Redirect PORT

Arguments:

    Flags                   - Specifies options for the redirect
    Protocol                - IP protocol of the session to be redirected

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    RestrictAdapterIndex    - optionally specifies the adapter index that this redirect should be restricted to 

    hCreateEvent            - optionally specifies an event to be signalled when a session matches the redirect.

    hDeleteEvent            - optionally specifies an event to be signalled when a session is delete.


Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE

--*/

    MYTRACE_ENTER("CNat::CreateRedirect");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    MYTRACE("ProtocolPublic %d, ProtocolInternal %d", Protocol, ProtocolConvertToNT(Protocol));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(DestinationAddress),      ntohs(DestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(SourceAddress),           ntohs(SourcePort));
    MYTRACE("NewDestination %s:%d", MYTRACE_IP(NewDestinationAddress),   ntohs(NewDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(NewSourceAddress),        ntohs(NewSourcePort));

    HANDLE  hThisEventForCreate=NULL;
    HANDLE  hThisEventForDelete=NULL;


    //
    // Duplicate the requested Event handles
    //
    if ( dwAlgProcessId )
    {

        HANDLE hAlgProcess = OpenProcess(
            PROCESS_DUP_HANDLE,     // access flag
            false,                  // handle inheritance option
            (DWORD)dwAlgProcessId   // process identifier
            );

        if ( !hAlgProcess )
        {
            MYTRACE_ERROR("Could not open the Process ID of ALG.exe", 0);
            return HRESULT_FROM_WIN32(GetLastError());
        }



        if ( hCreateEvent )
        {
        
            //
            // a create event was requested 
            //
            if ( !DuplicateHandle(
                    hAlgProcess,
                    (HANDLE)hCreateEvent,
                    GetCurrentProcess(),
                    &hThisEventForCreate,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )
                )
            {
                MYTRACE_ERROR("DuplicateHandle on the CREATE handle", 0);
                CloseHandle(hAlgProcess);
                return HRESULT_FROM_WIN32(GetLastError());
            }

            MYTRACE("New DuplicateHandle 'CREATE'=%d base on=%d", hThisEventForCreate, hCreateEvent);
        }
        else
        {
            MYTRACE("No event for Creation requested");
        }



        if ( hDeleteEvent )
        {
            //
            // a delete event was requested
            //
            if ( !DuplicateHandle(
                    hAlgProcess,
                    (HANDLE)hDeleteEvent,
                    GetCurrentProcess(),
                    &hThisEventForDelete,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )
                )
            {
                MYTRACE_ERROR("DuplicateHandle on the DELETE handle", 0);

                if ( hThisEventForCreate )
	            CloseHandle(hThisEventForCreate);

                CloseHandle(hAlgProcess);

                return HRESULT_FROM_WIN32(GetLastError());
            }

            MYTRACE("New DuplicateHandle 'DELETE'=%d base on=%d", hThisEventForDelete, hDeleteEvent);

        }
        else
        {
            MYTRACE("No event for Delete requested");
        }

        CloseHandle(hAlgProcess);
    }
    else
    {
        MYTRACE("NO EVENT Requested");
    }


    ULONG Error = NatCreateRedirectEx(
        GetTranslatorHandle(),
        Flags,
        ProtocolConvertToNT(Protocol),

        DestinationAddress,
        DestinationPort,

        SourceAddress,      
        SourcePort,

        NewDestinationAddress,
        NewDestinationPort,

        NewSourceAddress,
        NewSourcePort,

        RestrictAdapterIndex,
        IPNATAPI_SET_EVENT_ON_COMPLETION, // Special constant to use Event vs. a callback to a CompletionRoutine
        (PVOID)hThisEventForDelete,       //HANDLE for DELETE sessions
        (HANDLE)hThisEventForCreate       //HANDLE                    NotifyEvent         OPTIONAL
        ); 

    if ( hThisEventForCreate )
        CloseHandle(hThisEventForCreate);

    if ( hThisEventForDelete )
        CloseHandle(hThisEventForDelete);

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("From NatCreateRedirectEx", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


//
//
//

STDMETHODIMP 
CNat::CancelRedirect(
    IN  UCHAR    Protocol, 

    IN  ULONG    DestinationAddress, 
    IN  USHORT   DestinationPort, 

    IN  ULONG    SourceAddress, 
    IN  USHORT   SourcePort, 

    IN  ULONG    NewDestinationAddress, 
    IN  USHORT   NewDestinationPort, 

    IN  ULONG    NewSourceAddress, 
    IN  USHORT   NewSourcePort
    )
/*++

Routine Description:

    Cancel a Redirect

Arguments:

    Protocol                - IP protocol of the session to be redirected eALG_TCP || eALG_UDP

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "


Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE

--*/
{
    MYTRACE_ENTER("CNat::CancelRedirect");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE

    MYTRACE("Protocol Public %d, Internal %d", Protocol, ProtocolConvertToNT(Protocol));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(DestinationAddress),     ntohs(DestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(SourceAddress),          ntohs(SourcePort));
    MYTRACE("NewDestination %s:%d", MYTRACE_IP(NewDestinationAddress),  ntohs(NewDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(NewSourceAddress),       ntohs(NewSourcePort));

    ULONG Error = NatCancelRedirect(
        GetTranslatorHandle(),
        ProtocolConvertToNT(Protocol),
        DestinationAddress,
        DestinationPort,
        SourceAddress,
        SourcePort,
        NewDestinationAddress,
        NewDestinationPort,
        NewSourceAddress,
        NewSourcePort
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("From NatCancelRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}






STDMETHODIMP 
CNat::CreateDynamicRedirect(
    IN  ULONG       Flags, 
    IN  ULONG       nAdapterIndex,
    IN  UCHAR       Protocol, 

    IN  ULONG       DestinationAddress, 
    IN  USHORT      DestinationPort, 

    IN  ULONG       SourceAddress, 
    IN  USHORT      SourcePort, 

    IN  ULONG       NewDestinationAddress, 
    IN  USHORT      NewDestinationPort, 

    IN  ULONG       NewSourceAddress,
    IN  USHORT      NewSourcePort,

    OUT HANDLE_PTR* pDynamicRedirectHandle
    )
/*++

Routine Description:

    Cancel a dynamic Redirect, by seting up a dynamic redirection any time a adapter is created the redirection will be
    applied to that new adapter.

Arguments:

    Flags                   - Specifies options for the redirect
    nAdapterIndex           - Index of the IP adapter (Same as the index found using the cmd line "ROUTE PRINT")
    Protocol                - IP protocol of the session to be redirected

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    pDynamicRedirectHandle  - This routine will populate this field with the handle (Cookie) for the purpose of canceling
                              this DynamicRedirect

Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE
    and is use via the public api CreatePrimaryControlChannel (See ALG.EXE)

--*/
{
    MYTRACE_ENTER("CNat::CreateDynamicRedirect");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;


    ASSERT(pDynamicRedirectHandle!=NULL);

#if defined(DBG) || defined(_DEBUG)

    MYTRACE("Flags          %d", Flags);


    MYTRACE("Protocol Public %d Internal %d", Protocol, ProtocolConvertToNT(Protocol));

    if ( Flags & NatRedirectFlagNoTimeout )
        MYTRACE("    NatRedirectFlagNoTimeout");

    if ( Flags & NatRedirectFlagUnidirectional )
        MYTRACE("    NatRedirectFlagUnidirectional");

    if ( Flags & NatRedirectFlagRestrictSource )
        MYTRACE("    NatRedirectFlagRestrictSource");

    if ( Flags & NatRedirectFlagPortRedirect )
        MYTRACE("    NatRedirectFlagPortRedirect");

    if ( Flags & NatRedirectFlagReceiveOnly )
        MYTRACE("    NatRedirectFlagReceiveOnly");

    if ( Flags & NatRedirectFlagLoopback )
        MYTRACE("    NatRedirectFlagLoopback");

    if ( Flags & NatRedirectFlagSendOnly )
        MYTRACE("    NatRedirectFlagSendOnly");

    if ( Flags & NatRedirectFlagRestrictAdapter )
        MYTRACE("    NatRedirectFlagRestrictAdapter");

    if ( Flags & NatRedirectFlagSourceRedirect )
        MYTRACE("    NatRedirectFlagSourceRedirect");


    MYTRACE("AdapterIndex   %d", nAdapterIndex);
    
    in_addr tmpAddr;
    tmpAddr.s_addr = DestinationAddress;
    MYTRACE("Destination    %s:%d", inet_ntoa(tmpAddr),    ntohs(DestinationPort));
    tmpAddr.s_addr = SourceAddress;
    MYTRACE("Source         %s:%d", inet_ntoa(tmpAddr),    ntohs(SourcePort));
    tmpAddr.s_addr = NewDestinationAddress;
    MYTRACE("NewDestination %s:%d", inet_ntoa(tmpAddr),    ntohs(NewDestinationPort));
    tmpAddr.s_addr = NewSourceAddress;
    MYTRACE("NewSource      %s:%d", inet_ntoa(tmpAddr),    ntohs(NewSourcePort));
#endif





    MYTRACE("About to call NatCreateDynamicFullRedirect");

    ULONG nRestrictSourceAddress = 0;

    if ( NatRedirectFlagRestrictSource & Flags )
    {
        MYTRACE("NatRedirectFlagRestrictSource flags is set");
        nRestrictSourceAddress = SourceAddress;
        SourceAddress = 0;
    }

    ULONG Error = NatCreateDynamicFullRedirect(
        Flags|NatRedirectFlagLoopback,
        ProtocolConvertToNT(Protocol),

        DestinationAddress,
        DestinationPort,

        SourceAddress,
        SourcePort,

        NewDestinationAddress,
        NewDestinationPort,

        NewSourceAddress,
        NewSourcePort,

        nRestrictSourceAddress,         //ULONG RestrictSourceAddress OPTIONAL,
        nAdapterIndex,                  //ULONG RestrictAdapterIndex OPTIONAL,
        0,                              //MinimumBacklog OPTIONAL,
        (PHANDLE)pDynamicRedirectHandle
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Failed NatCreateDynamicFullRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    //
    // Cache the DynamicRedirect cookie before we hand it out to the caller
    // this list of cache cookie will be used to validate when a caller ask 
    // us to Cancel a redirect
    //
    m_AutoCS_DynamicRedirect.Lock();
    BOOL bAddedToListOFOutstandingRedirectHandle = m_ListOfOutstandingRedirects.Add(*pDynamicRedirectHandle);
    m_AutoCS_DynamicRedirect.Unlock();

    if ( bAddedToListOFOutstandingRedirectHandle )
    {
        MYTRACE("Added %d to the list of outstanding redirects for a total of %d redirects", *pDynamicRedirectHandle, m_ListOfOutstandingRedirects.GetSize());
    }
    else
    {
        MYTRACE_ERROR("Could add to list of Outstanding Redirect handle", GetLastError());
    }


    MYTRACE("Call to NatCreateDynamicFullRedirect worked");

    return S_OK;;
}




STDMETHODIMP 
CNat::CancelDynamicRedirect(
    IN  HANDLE_PTR DynamicRedirectHandle
    )
/*++

Routine Description:

    This routine is called to cancel the given dynamic redirect.
    by calling the NatApi version of this function

Arguments:

    DynamicRedirectHandle   - the handle to the dynamic redirect to be cancelled

Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

--*/

{
    MYTRACE_ENTER("CNat::CancelDynamicRedirect");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;


    //
    // Is the caller passing a valid DynamicRedirect handle 
    //
    m_AutoCS_DynamicRedirect.Lock();
    MYTRACE("Remove %d from the outstanding list of redirects, the before size is %d", DynamicRedirectHandle, m_ListOfOutstandingRedirects.GetSize());
    BOOL bFoundAndRemoved = m_ListOfOutstandingRedirects.Remove(DynamicRedirectHandle);
    m_AutoCS_DynamicRedirect.Unlock();

    if ( bFoundAndRemoved )
    {
        MYTRACE("Removed succesfull");
    }
    else
    {
        MYTRACE_ERROR("pDynamicRedirectHandle is not valid", GetLastError());
        return E_INVALIDARG;
    }


    //
    // We are good to go release this redirect
    //
    ULONG Error = NatCancelDynamicRedirect((PHANDLE)DynamicRedirectHandle);

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Failed NatCancelDynamicRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}




STDMETHODIMP 
CNat::GetBestSourceAddressForDestinationAddress(
    IN  ULONG       ulDestinationAddress, 
    IN  BOOL        fDemandDial, 
    OUT ULONG*      pulBestSrcAddress
    )
/*++

Routine Description:

    We create a temporary UDP socket, connect the socket to the
    actual client's IP address, extract the IP address to which
    the socket is implicitly bound by the TCP/IP driver, and
    discard the socket. This leaves us with the exact IP address
    that we need to use to contact the client.

Arguments:

    ulDestinationAddress, 
    fDemandDial, 
    pulBestSrcAddress


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/

{
    MYTRACE_ENTER("CNat::GetBestSourceAddressForDestinationAddress");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    if ( !pulBestSrcAddress )
    {
        MYTRACE_ERROR("pulBestSrcAddress not supplied",0);
        return E_INVALIDARG;
    }


    SOCKADDR_IN SockAddr;

    SockAddr.sin_family         = AF_INET;
    SockAddr.sin_port           = 0;
    SockAddr.sin_addr.s_addr    = ulDestinationAddress;

    
    ULONG Length = sizeof(SockAddr);


    SOCKET UdpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if  (   INVALID_SOCKET == UdpSocket
        ||  SOCKET_ERROR   == connect(UdpSocket, (PSOCKADDR)&SockAddr, sizeof(SockAddr))
        ||  SOCKET_ERROR   == getsockname(UdpSocket, (PSOCKADDR)&SockAddr, (int*)&Length)
        )   
    {
        ULONG nError = WSAGetLastError();

        if ( nError == WSAEHOSTUNREACH )
        {
            if ( fDemandDial )
                nError = RasAutoDialSharedConnection(); 

            if ( ERROR_SUCCESS != nError ) 
            {
                MYTRACE_ERROR(" RasAutoDialSharedConnection failed [%d]", nError);

                if ( UdpSocket != INVALID_SOCKET ) 
                { 
                    closesocket(UdpSocket); 
                }

                return HRESULT_FROM_WIN32(nError);
            }
        } 
        else 
        {
            MYTRACE_ERROR("error %d routing endpoint %d using UDP", nError);

            if (UdpSocket != INVALID_SOCKET) 
            { 
                closesocket(UdpSocket); 
            }

            return HRESULT_FROM_WIN32(nError);
        }
    }

    *pulBestSrcAddress = SockAddr.sin_addr.s_addr;

    closesocket(UdpSocket);

    return S_OK;
}



STDMETHODIMP CNat::LookupAdapterPortMapping(
    IN  ULONG   ulAdapterIndex,
    IN  UCHAR   Protocol,
    IN  ULONG   ulDestinationAddress,
    IN  USHORT  usDestinationPort,
    OUT ULONG*  pulRemapAddress,
    OUT USHORT* pusRemapPort
    )
/*++

Routine Description:

    Call NAT port maping to ge the real destination for the port
    This ofcourse is the use has set some maping in the SharedConnection or Firewalled adapter on the Service Tab.

Arguments:

    ulAdapterIndex          - Index of the IP adapter of the session.

    Protocol                - eALG_PROTOCOL_UDP, eALG_PROTOCOL_TCP
    DestinationAddress      - the edge public adapter address
    DestinationPort         - the edge public adapter port

    RemapAddres             - The address where that the user itended this port to go to (Private computer on the private lan)
    SourcePort              - Should be the same as the DestinationPort for future it may be different.


Return Value:

    HRESULT - S_OK if it worked or E_FAIL if no maping was found

--*/
{
    MYTRACE_ENTER("LookupAdapterPortMapping");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    MYTRACE("AdapterIndex %d Protocol %d DestAddress %s:%d", ulAdapterIndex, ProtocolConvertToNT(Protocol), MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));

    IP_NAT_PORT_MAPPING PortMapping;

    ULONG Error = NatLookupPortMappingAdapter(
                    ulAdapterIndex,
                    ProtocolConvertToNT(Protocol),
                    ulDestinationAddress,
                    usDestinationPort,
                    &PortMapping
                    );
                        
    if ( Error ) 
    {
        MYTRACE_ERROR("from NatLookupPortMappingAdapter", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    *pulRemapAddress   = PortMapping.PrivateAddress;
    *pusRemapPort      = PortMapping.PrivatePort;

    return S_OK;
}




STDMETHODIMP CNat::GetOriginalDestinationInformation(
    IN  UCHAR   Protocol,

    IN  ULONG   ulDestinationAddress,
    IN  USHORT  usDestinationPort,

    IN  ULONG   ulSourceAddress,
    IN  USHORT  usSourcePort,

    OUT ULONG*  pulOriginalDestinationAddress,
    OUT USHORT* pusOriginalDestinationPort,

    OUT ULONG*  pulAdapterIndex
    )
/*++

Routine Description:

    Determine the original destination endpoint of a session that is redirected to.

Arguments:


    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    pulOriginalDestinationAddress   - Returns the original address of the destination (Where the caller realy wanted to go)
    pusOriginalDestinationPort      - Returns the original port of the destination

    pulAdapterIndex                 - Index of the IP adapter of the session.

Return Value:

    HRESULT - S_OK if it worked or E_FAIL

--*/
{
    MYTRACE_ENTER("CNat::GetOriginalDestinationInformation");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    MYTRACE("Destination  %s:%d", MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));
    MYTRACE("Address      %s:%d", MYTRACE_IP(ulSourceAddress),      ntohs(usSourcePort));

    ASSERT(pulOriginalDestinationAddress!=NULL);
    ASSERT(pusOriginalDestinationPort!=NULL);
    ASSERT(pulAdapterIndex!=NULL);


    IP_NAT_SESSION_MAPPING_KEY_EX  Information;
    ULONG   ulSizeOfInformation = sizeof(IP_NAT_SESSION_MAPPING_KEY_EX);

    ULONG Error = NatLookupAndQueryInformationSessionMapping(
        GetTranslatorHandle(),
        ProtocolConvertToNT(Protocol),

        ulDestinationAddress,
        usDestinationPort,

        ulSourceAddress,
        usSourcePort,

        &Information,
        &ulSizeOfInformation,
        NatKeySessionMappingExInformation
        );


    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Call to NatLookupAndQueryInformationMapping", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("Original Index %d Address:Port %s:%d", Information.AdapterIndex, MYTRACE_IP(Information.DestinationAddress), ntohs(Information.DestinationPort));

    *pulOriginalDestinationAddress  = Information.DestinationAddress;
    *pusOriginalDestinationPort     = Information.DestinationPort;
    *pulAdapterIndex                = Information.AdapterIndex;

    return S_OK;

}





STDMETHODIMP CNat::ReservePort(
    IN  USHORT      PortCount, 
    OUT PUSHORT     pReservedPortBase
    )
/*++

Routine Description:

    Call the into the NAP api to reserve the required port on behave of the ALG module.

Arguments:

    PortCount           -   Number of port to reserve
    pReservedPortBase   -   Starting number of the range of port reserved. example  ReserePort(3, &) would save 5000,5001,5002 and return 5000 as base

Return Value:

    HRESULT - S_OK if it worked or E_FAIL


Environment:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

--*/
{
    MYTRACE_ENTER("CNat::ReservePort");

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    ASSERT(pReservedPortBase!=NULL);

    if ( !AlgPortReservationHandle )
        return E_FAIL;                  // AlgPortReservationHandle should already have been done


    ULONG Error = NatAcquirePortReservation(
        AlgPortReservationHandle,
        PortCount,
        pReservedPortBase
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("from NatAcquirePortReservation", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("PortBase %d count %d", *pReservedPortBase, PortCount);

    return S_OK;
}





STDMETHODIMP CNat::ReleasePort(
    IN  USHORT  ReservedPortBase, 
    IN  USHORT  PortCount
    )
/*++

Routine Description:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

    This routine will call the Nat api to release the previously reserved ports

Arguments:

    PortCount           -   Number of port to reserve
    pReservedPortBase   -   Starting number of the range of port reserved. example  ReserePort(3, &) would save 5000,5001,5002 and return 5000 as base

Return Value:

    HRESULT - S_OK if it worked or E_FAIL

Environment:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

--*/
{

    MYTRACE_ENTER("CNat::ReleasePort");    

    RETURN_IF_CLIENT_NOT_LOCAL_SERVICE;

    if ( !AlgPortReservationHandle )
        return E_FAIL;                  // AlgPortReservationHandle should already have been done

    ULONG Error = NatReleasePortReservation(
        AlgPortReservationHandle,
        ReservedPortBase,
        PortCount
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("from NatReleasePortReservation", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("PortBase=%d, Count=%d", ntohs(ReservedPortBase), PortCount);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <windns.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmdhcp.h"
#include "rmdns.h"

#include "dhcpauto.h"
#include "dhcpif.h"
#include "dhcpio.h"
#include "dhcplog.h"
#include "dhcpmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpmsg.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpmsg.c

Abstract:

    This module contains declarations related to the DHCP allocator's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            15-Dec-2000
    + Changed manner in which the option DHCP_TAG_DOMAIN_NAME is
    added in DhcpBuildReplyMessage().
    + Inform DNS component via DnsUpdate() in DhcpProcessRequestMessage().

    Raghu Gatta (rgatta)            20-Apr-2001
    + IP/1394 support changes

--*/

#include "precomp.h"
#pragma hdrstop

//
// EXTERNAL DECLARATIONS
//
extern PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo;
extern PWCHAR DnsICSDomainSuffix;
extern CRITICAL_SECTION DnsGlobalInfoLock;

//
// FORWARD DECLARATIONS
//

VOID
DhcpAppendOptionToMessage(
    DHCP_OPTION UNALIGNED** Optionp,
    UCHAR Tag,
    UCHAR Length,
    UCHAR Option[]
    );

VOID
DhcpBuildReplyMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED** Option,
    UCHAR MessageType,
    BOOLEAN DynamicDns,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DnsUpdate(
    CHAR *pszName,
    ULONG len,
    ULONG ulAddress
    );


VOID
DhcpAppendOptionToMessage(
    DHCP_OPTION UNALIGNED** Optionp,
    UCHAR Tag,
    UCHAR Length,
    UCHAR Option[]
    )
/*++

Routine Description:

    This routine is invoked to append an option to a DHCP message.

Arguments:

    Optionp - on input, the point at which to append the option;
        on output, the point at which to append the next option.

    Tag - the option tag

    Length - the option length

    Option - the option's data

Return Value:

    none.

--*/

{
    PROFILE("DhcpAppendOptionToMessage");

    (*Optionp)->Tag = Tag;

    if (!Length) {
        *Optionp = (DHCP_OPTION UNALIGNED *)((PUCHAR)*Optionp + 1);
    } else {
        (*Optionp)->Length = Length;
        CopyMemory((*Optionp)->Option, Option, Length);
        *Optionp = (DHCP_OPTION UNALIGNED *)((PUCHAR)*Optionp + Length + 2);
    }

} // DhcpAppendOptionToMessage


VOID
DhcpBuildReplyMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED** Option,
    UCHAR MessageType,
    BOOLEAN DynamicDns,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to construct the options portion
    of a reply message.

Arguments:

    Interfacep - the interface on which the reply will be sent

    Bufferp - the buffer containing the reply

    Option - the start of the options portion on input;
        on output, the end of the message

    MessageType - the type of message to be sent

    DynamicDns - indicates whether to include the 'dynamic-dns' option.

    OptionArray - options extracted from message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG Address;
    ULONG SubnetMask;
    ULONG i;

    //
    // Obtain the address and mask for the endpoint
    //

    Address = NhQueryAddressSocket(Bufferp->Socket);
    SubnetMask = PtrToUlong(Bufferp->Context2);

    if (MessageType == DHCP_MESSAGE_BOOTP) {
        ((PDHCP_HEADER)Bufferp->Buffer)->BootstrapServerAddress = Address;
    } else {

        //
        // Always begin with the 'message-type' option.
        //

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_MESSAGE_TYPE,
            1,
            &MessageType
            );

        //
        // Provide our address as the server-identifier
        //

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_SERVER_IDENTIFIER,
            4,
            (PUCHAR)&Address
            );
    }

    if (MessageType != DHCP_MESSAGE_NAK) {

        PCHAR DomainName;
        ULONG dnSize;
        ULONG LeaseTime;
        UCHAR NbtNodeType = DHCP_NBT_NODE_TYPE_M;
        ULONG RebindingTime;
        ULONG RenewalTime;

        EnterCriticalSection(&DhcpGlobalInfoLock);
        LeaseTime = DhcpGlobalInfo->LeaseTime * 60;
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        RebindingTime = (LeaseTime * 3) / 4;
        RenewalTime = LeaseTime / 2;
        if (RenewalTime > DHCP_MAXIMUM_RENEWAL_TIME) {
            RenewalTime = DHCP_MAXIMUM_RENEWAL_TIME;
        }

        LeaseTime = htonl(LeaseTime);
        RebindingTime = htonl(RebindingTime);
        RenewalTime = htonl(RenewalTime);

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_SUBNET_MASK,
            4,
            (PUCHAR)&SubnetMask
            );

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_ROUTER,
            4,
            (PUCHAR)&Address
            );

        ////
        //// RFC 2132 9.14 : server treats client identifier as an opaque object
        //// append the client identifier if present in received message
        ////
        //if (OptionArray[DhcpOptionClientIdentifier])
        //{
        //    DhcpAppendOptionToMessage(
        //        Option,
        //        DHCP_TAG_CLIENT_IDENTIFIER,
        //        OptionArray[DhcpOptionClientIdentifier]->Length,
        //        (PUCHAR)OptionArray[DhcpOptionClientIdentifier]->Option
        //        );
        //}

        if (MessageType != DHCP_MESSAGE_BOOTP) {

            //specify the DNS server in the message if DNS proxy is enabled 
            //or DNS server is running on local host
            if (NhIsDnsProxyEnabled() || !NoLocalDns) {
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DNS_SERVER,
                    4,
                    (PUCHAR)&Address
                    );
            }
    
            if (NhIsWinsProxyEnabled()) {
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_WINS_SERVER,
                    4,
                    (PUCHAR)&Address
                    );
            }
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_RENEWAL_TIME,
                4,
                (PUCHAR)&RenewalTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_REBINDING_TIME,
                4,
                (PUCHAR)&RebindingTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_LEASE_TIME,
                4,
                (PUCHAR)&LeaseTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_NBT_NODE_TYPE,
                1,
                &NbtNodeType
                );
    
            if (DynamicDns) {
                UCHAR DynamicDns[3] = { 0x03, 0, 0 };
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DYNAMIC_DNS,
                    sizeof(DynamicDns),
                    DynamicDns
                    );
            }

            //if (NhpStopDnsEvent && DnsICSDomainSuffix)
            if (DnsGlobalInfo && DnsICSDomainSuffix)
            {
                EnterCriticalSection(&DnsGlobalInfoLock);
            
                dnSize = wcstombs(NULL, DnsICSDomainSuffix, 0);
                DomainName = reinterpret_cast<PCHAR>(NH_ALLOCATE(dnSize + 1));
                if (DomainName)
                {
                    wcstombs(DomainName, DnsICSDomainSuffix, (dnSize + 1));
                }

                LeaveCriticalSection(&DnsGlobalInfoLock);
            }
            else
            //
            // at this point we have no DNS enabled
            // so we default to old behaviour
            //
            {
                DomainName = NhQuerySharedConnectionDomainName();
            }

            if (DomainName)
            {
                //
                // We include the terminating nul in the domain name
                // even though the RFC says we should not, because
                // the DHCP server does so.
                //
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DOMAIN_NAME,
                    (UCHAR)(lstrlenA(DomainName) + 1),
                    (PUCHAR)DomainName
                    );
                NH_FREE(DomainName);
            }

        }
    }

    DhcpAppendOptionToMessage(
        Option,
        DHCP_TAG_END,
        0,
        NULL
        );

} // DhcpBuildReplyMessage


ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is invoked to parse the options contained in a DHCP message.
    Pointers to each option are stored in the given option array.

Arguments:

    Headerp - the header of the DHCP message to be parsed

    MessageSize - the size of the message to be parsed

    OptionArray - receives the parsed options

Return Value:

    ULONG - Win32 status code.

--*/

{
    DHCP_OPTION UNALIGNED* Index;
    DHCP_OPTION UNALIGNED* End;

    PROFILE("DhcpExtractOptionsFromMessage");

    //
    // Initialize the option array to be empty
    //

    ZeroMemory(OptionArray, DhcpOptionCount * sizeof(PDHCP_OPTION));

    //
    // Check that the message is large enough to hold options
    //

    if (MessageSize < sizeof(DHCP_HEADER)) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpExtractOptionsFromMessage: message size %d too small",
            MessageSize
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_MESSAGE_TOO_SMALL,
            0,
            ""
            );
        return ERROR_INVALID_DATA;
    }

    //
    // Ensure that the magic cookie is present; if not, there are no options.
    //

    if (MessageSize < (sizeof(DHCP_HEADER) + sizeof(DHCP_FOOTER)) ||
        *(ULONG UNALIGNED*)Headerp->Footer[0].Cookie != DHCP_MAGIC_COOKIE) {
        return NO_ERROR;
    }

    //
    // Parse the message's options, if any
    //

    End = (PDHCP_OPTION)((PUCHAR)Headerp + MessageSize);

    Index = (PDHCP_OPTION)&Headerp->Footer[1];
    
    while (Index < End && Index->Tag != DHCP_TAG_END) {

        if ((DHCP_TAG_PAD != Index->Tag) &&
            (End < (PDHCP_OPTION)(Index->Option + Index->Length))) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpExtractOptionsFromMessage: option truncated at %d bytes",
                MessageSize
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_INVALID_FORMAT,
                0,
                ""
                );
            return ERROR_INVALID_DATA;
        }

        switch (Index->Tag) {
            case DHCP_TAG_PAD:
                NhTrace(TRACE_FLAG_DHCP, "Pad");
                break;
            case DHCP_TAG_CLIENT_IDENTIFIER:
                NhTrace(TRACE_FLAG_DHCP, "ClientIdentifier");
                OptionArray[DhcpOptionClientIdentifier] = Index; break;
            case DHCP_TAG_MESSAGE_TYPE:
                NhTrace(TRACE_FLAG_DHCP, "MessageType");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionMessageType] = Index; break;
            case DHCP_TAG_REQUESTED_ADDRESS:
                NhTrace(TRACE_FLAG_DHCP, "RequestedAddress");
                if (Index->Length < 4) { break; }
                OptionArray[DhcpOptionRequestedAddress] = Index; break;
            case DHCP_TAG_PARAMETER_REQUEST_LIST:
                NhTrace(TRACE_FLAG_DHCP, "ParameterRequestList");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionParameterRequestList] = Index; break;
            case DHCP_TAG_ERROR_MESSAGE:
                NhTrace(TRACE_FLAG_DHCP, "ErrorMessage");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionErrorMessage] = Index; break;
            case DHCP_TAG_DYNAMIC_DNS:
                NhTrace(TRACE_FLAG_DHCP, "DynamicDns");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionDynamicDns] = Index; break;
            case DHCP_TAG_HOST_NAME:
                NhTrace(TRACE_FLAG_DHCP, "HostName");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionHostName] = Index; break;
        }

        if (DHCP_TAG_PAD != Index->Tag) {
            Index = (PDHCP_OPTION)(Index->Option + Index->Length);
        }
        else {
            Index = (PDHCP_OPTION)((PUCHAR)Index + 1);
        }
    }

    if (Index->Tag != DHCP_TAG_END) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpExtractOptionsFromMessage: message truncated to %d bytes",
            MessageSize
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_INVALID_FORMAT,
            0,
            ""
            );
        return ERROR_INVALID_DATA;
    }

    return NO_ERROR;

} // DhcpExtractOptionsFromMessage


VOID
DhcpProcessBootpMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received BOOTP message.

Arguments:

    Interfacep - the interface on which the message was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessBootpMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    if (!Headerp->ClientAddress) {
        AssignedAddress = 0;
    } else {
    
        //
        // Validate the address requested by the client
        //

        AssignedAddress = Headerp->ClientAddress;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-zeros
            // or all-ones address on the subnet.
            // Select a different address for the client.
            //
    
            AssignedAddress = 0;
        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //

            AssignedAddress = 0;

        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            AssignedAddress = 0;
        }
    }

    if (!AssignedAddress &&
        !(AssignedAddress =
            DhcpAcquireUniqueAddress(
                NULL,
                0,
                Headerp->HardwareAddress,
                Headerp->HardwareAddressLength
                ))) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessBootpMessage: address-allocation failed"
            );
        return;
    }

    //  
    // Acquire a buffer for the reply we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessBootpMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original buffer;
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original header
    //

    *Offerp = *Headerp;

    //
    // Set up the offer-header fields
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_BOOTP,
        FALSE,
        OptionArray
        );

    //
    // Send the offer to the BOOTP client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }

        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.BootpOffersSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessBootpMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessBootpMessage


VOID
DhcpProcessDiscoverMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received DHCPDISCOVER message.

Arguments:

    Interfacep - the interface on which the discover was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessDiscoverMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //
    // See if the client is renewing or requesting
    //

    if (!OptionArray[DhcpOptionRequestedAddress]) {

        AssignedAddress = 0;
    } else {

        //
        // Validate the address requested by the client
        //

        AssignedAddress =
            *(ULONG UNALIGNED*)OptionArray[DhcpOptionRequestedAddress]->Option;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-zeroes
            // or all-ones address on the subnet.
            // Select a different address for the client.
            //
    
            AssignedAddress = 0;
        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //

            AssignedAddress = 0;
        } else if (OptionArray[DhcpOptionHostName]) {
            if (DhcpIsReservedAddress(
                    AssignedAddress,
                    reinterpret_cast<PCHAR>(
                        OptionArray[DhcpOptionHostName]->Option
                        ),
                    OptionArray[DhcpOptionHostName]->Length
                    )) {

                //
                // The address is reserved for someone else,
                // or the client has a different address reserved.
                //

                AssignedAddress = 0;
            }
        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            AssignedAddress = 0;
        }
    }

    //
    // Generate an address for the client if necessary
    //

    if (!AssignedAddress) {
        if (!OptionArray[DhcpOptionHostName]) {
            AssignedAddress =
                DhcpAcquireUniqueAddress(
                    NULL,
                    0,
                    Headerp->HardwareAddress,
                    Headerp->HardwareAddressLength
                    );
        } else {
            AssignedAddress =
                DhcpAcquireUniqueAddress(
                    reinterpret_cast<PCHAR>(
                        OptionArray[DhcpOptionHostName]->Option
                        ),
                    OptionArray[DhcpOptionHostName]->Length,
                    Headerp->HardwareAddress,
                    Headerp->HardwareAddressLength
                    );
        }
        if (!AssignedAddress) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessDiscoverMessage: address-allocation failed"
                );
            return;
        }
    }

    //  
    // Acquire a buffer for the offer we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessDiscoverMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original message
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original discover header
    //

    *Offerp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Offerp->HardwareAddressType) &&
        (0 == Offerp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Offerp->HardwareAddress, sizeof(Offerp->HardwareAddress));
    }

    //
    // Set up the offer-header fieldds
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_OFFER,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // Send the offer to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.OffersSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessDiscoverMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessDiscoverMessage



VOID
DhcpProcessInformMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received DHCPINFORM message.

Arguments:

    Interfacep - the interface on which the inform was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    PDHCP_HEADER Ackp;
    ULONG Error;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;

    PROFILE("DhcpProcessInformMessage");

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //  
    // Acquire a buffer for the ack we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessInformMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original message
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Ackp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original header
    //

    *Ackp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Ackp->HardwareAddressType) &&
        (0 == Ackp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Ackp->HardwareAddress, sizeof(Ackp->HardwareAddress));
    }
    
    //
    // Set up the ack-header fieldds
    //

    Ackp->Operation = BOOTP_OPERATION_REPLY;
    Ackp->AssignedAddress = 0;
    Ackp->ServerHostName[0] = 0;
    Ackp->BootFile[0] = 0;
    Ackp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Ackp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Ackp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_ACK,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // Send the offer to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.AcksSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessInformMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessInformMessage


VOID
DhcpProcessMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DHCP client message.

Arguments:

    Interfacep - the interface on which the request was received

    Bufferp - the buffer containing the message received

Return Value:

    none.

Environment:

    Invoked internally with 'Interfacep' referenced by the caller.

--*/

{
    ULONG Error;
    PDHCP_HEADER Headerp;
    UCHAR MessageType;
    PDHCP_OPTION OptionArray[DhcpOptionCount];

    PROFILE("DhcpProcessMessage");

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

#if DBG
    NhDump(
        TRACE_FLAG_DHCP,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );
#endif

    //
    // Extract pointers to each option in the message
    //

    Error =
        DhcpExtractOptionsFromMessage(
            Headerp,
            Bufferp->BytesTransferred,
            OptionArray
            );

    if (Error) {
        InterlockedIncrement(
            reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
            );
    }
    else
    //
    // Look for the message-type;
    // This distinguishes BOOTP from DHCP clients.
    //
    if (!OptionArray[DhcpOptionMessageType]) {
        DhcpProcessBootpMessage(
            Interfacep,
            Bufferp,
            OptionArray
            );
    } else if (Headerp->HardwareAddressLength >
               sizeof(Headerp->HardwareAddress)) {

        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessMessage: ignoring message since HWAddrLength "
            "is too long"
            );

        InterlockedIncrement(
            reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
            );

    } else if (DhcpIsLocalHardwareAddress(
                Headerp->HardwareAddress, Headerp->HardwareAddressLength)) {

        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessMessage: ignoring message, from self"
            );

        InterlockedIncrement(
            reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
            );

    } else switch(MessageType = OptionArray[DhcpOptionMessageType]->Option[0]) {
        case DHCP_MESSAGE_DISCOVER: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.DiscoversReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received DISCOVER message"
                );
            DhcpProcessDiscoverMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_REQUEST: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.RequestsReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received REQUEST message"
                );
            DhcpProcessRequestMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_INFORM: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.InformsReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received INFORM message"
                );
            DhcpProcessInformMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_DECLINE: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.DeclinesReceived)
                );
            // log message
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received DECLINE message"
                );
            break;
        }
        case DHCP_MESSAGE_RELEASE: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.ReleasesReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received RELEASE message"
                );
            break;
        }
        default: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: message type %d invalid",
                MessageType
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_INVALID_DHCP_MESSAGE_TYPE,
                0,
                "%d",
                MessageType
                );
            break;
        }
    }

    //
    // Post the buffer for another read
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Bufferp);
    } else {
        LeaveCriticalSection(&DhcpInterfaceLock);
        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                Bufferp,
                DhcpReadCompletionRoutine,
                Bufferp->Context,
                Bufferp->Context2
                );
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
            RELEASE_LOCK(Interfacep);
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: error %d reposting read",
                Error
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
            NhReleaseBuffer(Bufferp);
        }
    }

} // DhcpProcessMessage


VOID
DhcpProcessRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a request message.

Arguments:

    Interfacep - the interface on which the request was received

    Bufferp - the buffer containing the message received

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked internally with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress = 0;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    UCHAR ReplyType = DHCP_MESSAGE_ACK;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessRequestMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //
    // Validate the address requested by the client
    //

    if (!Headerp->ClientAddress && !OptionArray[DhcpOptionRequestedAddress]) {

        //
        // The client left out the address being requested
        //

        ReplyType = DHCP_MESSAGE_NAK;
    } else {

        //
        // Try to see if the address is in use.
        //

        AssignedAddress =
            Headerp->ClientAddress
                ? Headerp->ClientAddress
                : *(ULONG UNALIGNED*)
                        OptionArray[DhcpOptionRequestedAddress]->Option;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-ones
            // or all-zeroes address.
            //

            ReplyType = DHCP_MESSAGE_NAK;

        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //
            
            ReplyType = DHCP_MESSAGE_NAK;

        } else if (OptionArray[DhcpOptionHostName]) {
            if (DhcpIsReservedAddress(
                AssignedAddress,
                reinterpret_cast<PCHAR>(
                    OptionArray[DhcpOptionHostName]->Option
                    ),
                OptionArray[DhcpOptionHostName]->Length
                )) {

                //
                // The address is reserved for someone else,
                // or the client has a different address reserved.
                //

                ReplyType = DHCP_MESSAGE_NAK;
            } 
        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            ReplyType = DHCP_MESSAGE_NAK;
        }
    }

    //  
    // Acquire a buffer for the reply we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessRequestMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields to be used in the reply-buffer
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original discover header
    //

    *Offerp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Offerp->HardwareAddressType) &&
        (0 == Offerp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Offerp->HardwareAddress, sizeof(Offerp->HardwareAddress));
    }

    //
    // Set up the offer-header fieldds
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        ReplyType,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // NEW LOGIC HERE => tied to DNS
    //
    if (DHCP_MESSAGE_ACK == ReplyType)
    {
        //
        // We perform the equivalent of Dynamic DNS here
        // by informing the DNS component that this client exists
        //
        if (OptionArray[DhcpOptionHostName])
        {
            //
            // check if DNS component is active
            //
            if (REFERENCE_DNS())
            {
                DnsUpdate(
                    reinterpret_cast<PCHAR>(OptionArray[DhcpOptionHostName]->Option),
                    (ULONG) OptionArray[DhcpOptionHostName]->Length,
                    AssignedAddress
                    );

                DEREFERENCE_DNS();
            }
        }
    }

    //
    // Send the reply to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                (ReplyType == DHCP_MESSAGE_ACK)
                    ? reinterpret_cast<LPLONG>(&DhcpStatistics.AcksSent)
                    : reinterpret_cast<LPLONG>(&DhcpStatistics.NaksSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessRequestMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessRequestMessage


ULONG
DhcpWriteClientRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PDHCP_BINDING Binding
    )

/*++

Routine Description:

    This routine is invoked to check for the existence of a DHCP server
    on the given interface and address. It generates a BOOTP request
    on a socket bound to the DHCP client port.

Arguments:

    Interfacep - the interface on which the client request is to be sent

    Binding - the binding on which the request is to be sent

Return Value:

    ULONG - status code.

Environment:

    Invoked with 'Interfacep' locked and with a reference made to 'Interfacep'
    for the send which occurs here.
    If the routine fails, it is the caller's responsibility to release
    the reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    PDHCP_HEADER Headerp;
    SOCKET Socket;

    PROFILE("DhcpWriteClientRequestMessage");

    //
    // Create a socket using the given address
    //

    Error =
        NhCreateDatagramSocket(
            Binding->Address,
            DHCP_PORT_CLIENT,
            &Binding->ClientSocket
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error %d creating socket for %s",
            Error,
            INET_NTOA(Binding->Address)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Binding->Address
            );
        return Error;
    }

    //
    // Allocate a buffer for the BOOTP request
    //

    Bufferp = NhAcquireBuffer();
    if (!Bufferp) {
        NhDeleteDatagramSocket(Binding->ClientSocket);
        Binding->ClientSocket = INVALID_SOCKET;
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error allocating buffer for %s",
            INET_NTOA(Binding->Address)
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the BOOTP request
    //

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    ZeroMemory(Headerp, sizeof(*Headerp));

    Headerp->Operation = BOOTP_OPERATION_REQUEST;
    Headerp->HardwareAddressType = 1;
    Headerp->HardwareAddressLength = 6;
    Headerp->TransactionId = DHCP_DETECTION_TRANSACTION_ID;
    Headerp->SecondsSinceBoot = 10;
    Headerp->Flags |= BOOTP_FLAG_BROADCAST;
    Headerp->ClientAddress = Binding->Address;
    Headerp->HardwareAddress[1] = 0xab;
    *(PULONG)(Headerp->Footer[0].Cookie) = DHCP_MAGIC_COOKIE;
    *(PUCHAR)(Headerp->Footer + 1) = DHCP_TAG_END;

    //
    // Send the BOOTP request on the socket
    //

    Error =
        NhWriteDatagramSocket(
            &DhcpComponentReference,
            Binding->ClientSocket,
            INADDR_BROADCAST,
            DHCP_PORT_SERVER,
            Bufferp,
            sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH,
            DhcpWriteClientRequestCompletionRoutine,
            (PVOID)Interfacep,
            UlongToPtr(Binding->Address)
            );

    if (Error) {
        NhReleaseBuffer(Bufferp);
        NhDeleteDatagramSocket(Binding->ClientSocket);
        Binding->ClientSocket = INVALID_SOCKET;
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error %d writing request for %s",
            Error,
            INET_NTOA(Binding->Address)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Binding->Address
            );
        return Error;
    }

    return NO_ERROR;

} // DhcpWriteClientRequestMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\buffer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains code for buffer-management.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LIST_ENTRY NhpBufferQueue;
LONG NhpBufferQueueLength;
CRITICAL_SECTION NhpBufferQueueLock;

PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer.
    If no buffer is available on the buffer queue, a new one is obtained.

Arguments:

    none.

Return Value:

    PNH_BUFFER - the buffer allocated

--*/

{
    PNH_BUFFER Buffer;
    PLIST_ENTRY Link;
    EnterCriticalSection(&NhpBufferQueueLock);
    if (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedDecrement(&NhpBufferQueueLength);
        Buffer = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        Buffer->Type = NhFixedLengthBufferType;
        return Buffer;
    }
    LeaveCriticalSection(&NhpBufferQueueLock);
    Buffer = NH_ALLOCATE_BUFFER();
    if (Buffer) {
        Buffer->Type = NhFixedLengthBufferType;
    }
    return Buffer;
} // NhAcquireFixedLengthBuffer


PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer of non-standard size.
    If the length requested is less than or equal to 'NH_BUFFER_SIZE',
    a buffer from the shared buffer-queue is returned.
    Otherwise, a buffer is especially allocated for the caller.

Arguments:

    Length - the length of the buffer required.

Return Value:

    PNH_BUFFER - the buffer allocated.

--*/

{
    PNH_BUFFER Buffer;
    if (Length <= NH_BUFFER_SIZE) {
        return NhAcquireFixedLengthBuffer();
    }
    Buffer = reinterpret_cast<PNH_BUFFER>(
                NH_ALLOCATE(FIELD_OFFSET(NH_BUFFER, Buffer[Length]))
                );
                
    if (Buffer) { Buffer->Type = NhVariableLengthBufferType; }
    return Buffer;
} // NhAcquireVariableLengthBuffer


PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine creates a duplicate of the given buffer,
    including both its data and its control information.

    N.B. Variable-length buffers cannot be duplicated by this routine.

Arguments:

    Bufferp - the buffer to be duplicated

Return Value:

    PNH_BUFFER - a pointer to the duplicate

--*/

{
    PNH_BUFFER Duplicatep;
    ASSERT(Bufferp->Type == NhFixedLengthBufferType);
    if (!(Duplicatep = NhAcquireBuffer())) { return NULL; }
    *Duplicatep = *Bufferp;
    return Duplicatep;
} // NhDuplicateBuffer


ULONG
NhInitializeBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine readies the buffer-management for operation.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    InitializeListHead(&NhpBufferQueue);
    NhpBufferQueueLength = 0;
    __try {
        InitializeCriticalSection(&NhpBufferQueueLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_BUFFER,
            "NhInitializeBufferManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // NhInitializeBufferManagement


VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to release a buffer to the buffer queue.
    It attempts to place the buffer on the queue for re-use, unless
    the queue is full in which case the buffer is immediately freed.

Arguments:

    Bufferp - the buffer to be released

Return Value:

    none.

--*/

{
    if (NhpBufferQueueLength > NH_MAX_BUFFER_QUEUE_LENGTH ||
        Bufferp->Type != NhFixedLengthBufferType) {
        NH_FREE_BUFFER(Bufferp);
    } else {
        EnterCriticalSection(&NhpBufferQueueLock);
        InsertHeadList(&NhpBufferQueue, &Bufferp->Link);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedIncrement(&NhpBufferQueueLength);
    }
} // NhReleaseBuffer



VOID
NhShutdownBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up resources used by the buffer-management module.
    It assumes the list will not be accessed while the clean up is in progress.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNH_BUFFER Bufferp;

    while (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        Bufferp = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        NH_FREE_BUFFER(Bufferp);
    }

    DeleteCriticalSection(&NhpBufferQueueLock);
    NhpBufferQueueLength = 0;

} // NhShutdownBufferManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpio.c

Abstract:

    This module contains code for the DHCP allocator's network I/O.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
DhcpReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a datagram socket bound to the DHCP server UDP port.

    The message read is validated and processed, and if necessary,
    a reply is generated and sent to the client.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDHCP_HEADER Headerp;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpReadCompletionRoutine");

    do {

        //
        // There are two cases where we don't process the message;
        // (a) the I/O operation failed
        // (b) the interface is no longer active
        // In cases (a) we repost the buffer; in case (b) we do not.
        //

        Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

        //
        // First look for an error code
        //
    
        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "DhcpReadCompletionRoutine: error %d for read-context %x",
                ErrorCode,
                Bufferp->Context
                );
            //
            // See if the interface is still active
            //
            ACQUIRE_LOCK(Interfacep);
            if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                NhReleaseBuffer(Bufferp);
            }
            else {
                RELEASE_LOCK(Interfacep);
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    //
                    // Repost the buffer for another read operation
                    //
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                LeaveCriticalSection(&DhcpInterfaceLock);
            }
            break;
        }

        //
        // Now see if the interface is operational
        //

        ACQUIRE_LOCK(Interfacep);
        if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "DhcpReadCompletionRoutine: interface %x inactive",
                Interfacep
                );
            break;
        }
        RELEASE_LOCK(Interfacep);

        //
        // Ensure minimum DHCP_HEADER size
        //

        if (BytesTransferred < sizeof(DHCP_HEADER)) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpReadCompletionRoutine: message size %d too small",
                BytesTransferred
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_MESSAGE_TOO_SMALL,
                0,
                ""
                );
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                );

            //
            // Repost read
            //

            EnterCriticalSection(&DhcpInterfaceLock);
            if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                LeaveCriticalSection(&DhcpInterfaceLock);
                NhReleaseBuffer(Bufferp);
            }
            else {
                LeaveCriticalSection(&DhcpInterfaceLock);
                Error =
                    NhReadDatagramSocket(
                        &DhcpComponentReference,
                        Bufferp->Socket,
                        Bufferp,
                        DhcpReadCompletionRoutine,
                        Bufferp->Context,
                        Bufferp->Context2
                        );
                if (Error) {
                    ACQUIRE_LOCK(Interfacep);
                    DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                    RELEASE_LOCK(Interfacep);
                    DHCP_DEREFERENCE_INTERFACE(Interfacep);
                    NhWarningLog(
                        IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                    NhReleaseBuffer(Bufferp);
                }
            }

            break;
        }

        //
        // Now look at the message
        //

        Headerp = (PDHCP_HEADER)Bufferp->Buffer;

        switch (Headerp->Operation) {

            case BOOTP_OPERATION_REQUEST: {
                DhcpProcessMessage(
                    Interfacep,
                    Bufferp
                    );
                break;
            }

            case BOOTP_OPERATION_REPLY: {
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                    );
                    
                NhTrace(
                    TRACE_FLAG_IO,
                    "DhcpReadCompletionRoutine: ignoring BOOTPREPLY"
                    );
                //
                // Repost the buffer for another read operation.
                //
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                break;
            }

            default: {
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                    )
                    ;
                NhTrace(
                    TRACE_FLAG_IO,
                    "DhcpReadCompletionRoutine: ignoring invalid BOOTP operation %d",
                    Headerp->Operation
                    );
                NhInformationLog(
                    IP_AUTO_DHCP_LOG_INVALID_BOOTP_OPERATION,
                    0,
                    "%d",
                    Headerp->Operation
                    );
                //
                // Repost the buffer for another read operation.
                //
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                break;
            }
        }

    } while(FALSE);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_DHCP();

} // DhcpReadCompletionRoutine


VOID
DhcpReadServerReplyCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a receive-operation
    on a socket bound to the DHCP client port, when the component
    is attempting to detect the presence of a DHCP server.

Arguments:

    ErrorCode - system-supplied status code

    BytesTransferred - system-supplied byte count

    Bufferp - send buffer

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread upon removal
    of an I/O completion packet.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Address;
    ULONG Error;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpReadServerReplyCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

    if (ErrorCode) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: error %d receiving %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    ACQUIRE_LOCK(Interfacep);
    if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
        RELEASE_LOCK(Interfacep);
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }
    RELEASE_LOCK(Interfacep);

    //
    // Inspect the message read
    //

    Address = NhQueryAddressSocket(Bufferp->Socket);

    if (NhIsLocalAddress(Bufferp->ReadAddress.sin_addr.s_addr)) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: ignoring, from self (%s)",
            INET_NTOA(Address)
            );
    } else {
        CHAR LocalAddress[16];

        lstrcpyA(LocalAddress, INET_NTOA(Address));
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: %s found, disabling %d (%s)",
            INET_NTOA(Bufferp->ReadAddress.sin_addr),
            Interfacep->Index,
            LocalAddress
            );

        //
        // We received this from another server.
        // We'll need to disable this interface.
        //

        DhcpDisableInterface(Interfacep->Index);
        NhErrorLog(
            IP_AUTO_DHCP_LOG_DUPLICATE_SERVER,
            0,
            "%I%I",
            Bufferp->ReadAddress.sin_addr.s_addr,
            Address
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    //
    // We received it from ourselves.
    // Look for another server.
    //

    Error =
        NhReadDatagramSocket(
            &DhcpComponentReference,
            Bufferp->Socket,
            Bufferp,
            DhcpReadServerReplyCompletionRoutine,
            Bufferp->Context,
            Bufferp->Context2
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: error %d reposting %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhReleaseBuffer(Bufferp);
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Address
            );
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    DEREFERENCE_DHCP();

} // DhcpReadServerReplyCompletionRoutine


VOID
DhcpWriteClientRequestCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a send-operation
    on a socket bound to the DHCP client port, when the component
    is attempting to detect the presence of a DHCP server.

Arguments:

    ErrorCode - system-supplied status code

    BytesTransferred - system-supplied byte count

    Bufferp - send buffer

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread upon removal
    of an I/O completion packet.
    A reference to the interface will have been made on our behalf
    by 'DhcpWriteClientRequestMessage'.
    A reference to the component will have been made on our behalf
    by 'NhWriteDatagramSocket'.

--*/

{
    PDHCP_INTERFACE Interfacep;
    ULONG Error;

    PROFILE("DhcpWriteClientRequestCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

    if (ErrorCode) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpWriteClientRequestCompletionRoutine: error %d broadcast %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            ErrorCode,
            "%I",
            NhQueryAddressSocket(Bufferp->Socket)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    ACQUIRE_LOCK(Interfacep);
    if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
        RELEASE_LOCK(Interfacep);
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }
    RELEASE_LOCK(Interfacep);

    //
    // Reuse the send buffer to listen for a response from the server
    //

    Error =
        NhReadDatagramSocket(
            &DhcpComponentReference,
            Bufferp->Socket,
            Bufferp,
            DhcpReadServerReplyCompletionRoutine,
            Bufferp->Context,
            Bufferp->Context2
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpWriteClientRequestCompletionRoutine: error %d receiving %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            NhQueryAddressSocket(Bufferp->Socket)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    DEREFERENCE_DHCP();

} // DhcpWriteClientRequestCompletionRoutine



VOID
DhcpWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a datagram socket bound to the DHCP server UDP port.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the interface will have been made on our behalf
    by the code which invoked 'NhWriteDatagramSocket'.
    A reference to the component will have been made on our behalf
    within 'NhWriteDatagramSocket'.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpWriteCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    NhReleaseBuffer(Bufferp);
    DEREFERENCE_DHCP();

} // DhcpWriteCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpio.h

Abstract:

    This module contains declarations for the DHCP allocator's network I/O
    completion routines.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPIO_H_
#define _NATHLP_DHCPIO_H_


//
// CONSTANT DECLARATIONS
//

#define DHCP_ADDRESS_BROADCAST  0xffffffff


//
// FUNCTION DECLARATIONS
//

VOID
DhcpReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpReadServerReplyCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpWriteClientRequestCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DHCPIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcplog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcplog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   14-Mar-1998

Revision History:

--*/

#define IP_AUTO_DHCP_LOG_BASE                       30000

#define IP_AUTO_DHCP_LOG_SENDARP_FAILED             (IP_AUTO_DHCP_LOG_BASE+1)
/*
 * The DHCP allocator was unable to check whether the IP address %1
 * is in use on the network for local IP address %2.
 * This error may indicate lack of support for address-resolution on the
 * network, or an error condition on the local machine.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_ACTIVATE_FAILED            (IP_AUTO_DHCP_LOG_BASE+2)
/*
 * The DHCP allocator was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_ALLOCATION_FAILED          (IP_AUTO_DHCP_LOG_BASE+3)
/*
 * The DHCP allocator was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_AUTO_DHCP_LOG_INVALID_BOOTP_OPERATION    (IP_AUTO_DHCP_LOG_BASE+4)
/*
 * The DHCP allocator received a message containing an unrecognized code (%1).
 * The message was neither a BOOTP request nor a BOOTP reply, and was ignored.
 */

#define IP_AUTO_DHCP_LOG_DUPLICATE_SERVER           (IP_AUTO_DHCP_LOG_BASE+5)
/*
 * The DHCP allocator has detected a DHCP server with IP address %1
 * on the same network as the interface with IP address %2.
 * The allocator has disabled itself on the interface in order to avoid
 * confusing DHCP clients.
 */

#define IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE      (IP_AUTO_DHCP_LOG_BASE+6)
/*
 * The DHCP allocator encountered a network error while attempting to detect
 * existing DHCP servers on the network of the interface with IP address %1.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_MESSAGE_TOO_SMALL          (IP_AUTO_DHCP_LOG_BASE+7)
/*
 * The DHCP allocator received a message smaller than the minimum message size.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_INVALID_FORMAT             (IP_AUTO_DHCP_LOG_BASE+8)
/*
 * The DHCP allocator received a message whose format was invalid.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_REPLY_FAILED               (IP_AUTO_DHCP_LOG_BASE+9)
/*
 * The DHCP allocator encountered a network error while attempting to reply
 * on IP address %1 to a request from a client.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_INVALID_DHCP_MESSAGE_TYPE  (IP_AUTO_DHCP_LOG_BASE+10)
/*
 * The DHCP allocator received a DHCP message containing an unrecognized
 * message type (%1) in the DHCP message type option field.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_RECEIVE_FAILED             (IP_AUTO_DHCP_LOG_BASE+11)
/*
 * The DHCP allocator encountered a network error while attempting to
 * receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_NAT_INTERFACE_IGNORED      (IP_AUTO_DHCP_LOG_BASE+12)
/*
 * The DHCP allocator detected network address translation (NAT) enabled
 * on the interface with index '%1'.
 * The allocator has disabled itself on the interface in order to avoid
 * confusing DHCP clients.
 */

#define IP_AUTO_DHCP_LOG_NON_SCOPE_ADDRESS          (IP_AUTO_DHCP_LOG_BASE+13)
/*
 * The DHCP allocator has disabled itself on IP address %1,
 * since the IP address is outside the %2/%3 scope
 * from which addresses are being allocated to DHCP clients.
 * To enable the DHCP allocator on this IP address,
 * please change the scope to include the IP address,
 * or change the IP address to fall within the scope.
 */

#define IP_AUTO_DHCP_LOG_END                        (IP_AUTO_DHCP_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\dhcpmsg.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpmsg.h

Abstract:

    This module contains declarations related to the DHCP allocator's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPMSG_H_
#define _NATHLP_DHCPMSG_H_

//
// CONSTANT DECLARATIONS
//

#define DHCP_MAXIMUM_RENEWAL_TIME   (5 * 60)

#define DHCP_NBT_NODE_TYPE_B        1
#define DHCP_NBT_NODE_TYPE_P        2
#define DHCP_NBT_NODE_TYPE_M        4
#define DHCP_NBT_NODE_TYPE_H        8

//
// DHCP message format
//

#include <pshpack1.h>

//
// Disable "zero-sized array in struct/union" warning
//

#pragma warning(push)
#pragma warning(disable : 4200)

typedef struct _DHCP_OPTION {
    UCHAR Tag;
    UCHAR Length;
    UCHAR Option[];
} DHCP_OPTION, *PDHCP_OPTION;

typedef struct _DHCP_FOOTER {
    UCHAR Cookie[4];
} DHCP_FOOTER, *PDHCP_FOOTER;

typedef struct _DHCP_HEADER {
    UCHAR Operation;
    UCHAR HardwareAddressType;
    UCHAR HardwareAddressLength;
    UCHAR HopCount;
    ULONG TransactionId;
    USHORT SecondsSinceBoot;
    USHORT Flags;
    ULONG ClientAddress;
    ULONG AssignedAddress;
    ULONG BootstrapServerAddress;
    ULONG RelayAgentAddress;
    UCHAR HardwareAddress[16];
    UCHAR ServerHostName[64];
    UCHAR BootFile[128];
    DHCP_FOOTER Footer[];
} DHCP_HEADER, *PDHCP_HEADER;

#pragma warning(pop)

#include <poppack.h>


//
// MACRO DECLARATIONS
//

//
// BOOTP operation codes
//

#define BOOTP_OPERATION_REQUEST 1
#define BOOTP_OPERATION_REPLY   2

//
// BOOTP flags
//

#define BOOTP_FLAG_BROADCAST    0x0080

//
// BOOTP maximum option-area size
//

#define BOOTP_VENDOR_LENGTH     64

//
// Internal transaction ID for DHCP server detection
//

#define DHCP_DETECTION_TRANSACTION_ID   'MSFT'

//
// DHCP magic cookie
//

#define DHCP_MAGIC_COOKIE       ((99 << 24) | (83 << 16) | (130 << 8) | (99))
#define DHCP_MAGIC_COOKIE_SIZE  4

//
// DHCP option tag values
//

#define DHCP_TAG_PAD                    0
#define DHCP_TAG_SUBNET_MASK            1
#define DHCP_TAG_ROUTER                 3
#define DHCP_TAG_DNS_SERVER             6
#define DHCP_TAG_HOST_NAME              12
#define DHCP_TAG_DOMAIN_NAME            15
#define DHCP_TAG_STATIC_ROUTE           33
#define DHCP_TAG_WINS_SERVER            44
#define DHCP_TAG_NBT_NODE_TYPE          46
#define DHCP_TAG_NBT_SCOPE              47
#define DHCP_TAG_REQUESTED_ADDRESS      50
#define DHCP_TAG_LEASE_TIME             51
#define DHCP_TAG_OPTION_OVERLOAD        52
#define DHCP_TAG_MESSAGE_TYPE           53
#define DHCP_TAG_SERVER_IDENTIFIER      54
#define DHCP_TAG_PARAMETER_REQUEST_LIST 55
#define DHCP_TAG_ERROR_MESSAGE          56
#define DHCP_TAG_MAXIMUM_MESSAGE_SIZE   57
#define DHCP_TAG_RENEWAL_TIME           58
#define DHCP_TAG_REBINDING_TIME         59
#define DHCP_TAG_VENDOR_CLASS           60
#define DHCP_TAG_CLIENT_IDENTIFIER      61
#define DHCP_TAG_DYNAMIC_DNS            81
#define DHCP_TAG_END                    255

//
// Enumeration: DHCP_OPTION_INDEX
//
// The following enumerates the options of interest to the DHCP allocator.
// The enumeration aids in the processing of the options.
// (See 'DhcpExtractOptionsFromMessage').
//

typedef enum {
    DhcpOptionClientIdentifier,
    DhcpOptionMessageType,
    DhcpOptionRequestedAddress,
    DhcpOptionParameterRequestList,
    DhcpOptionErrorMessage,
    DhcpOptionDynamicDns,
    DhcpOptionHostName,
    DhcpOptionCount
} DHCP_OPTION_INDEX;

//
// DHCP message type values
//

#define DHCP_MESSAGE_BOOTP              0
#define DHCP_MESSAGE_DISCOVER           1
#define DHCP_MESSAGE_OFFER              2
#define DHCP_MESSAGE_REQUEST            3
#define DHCP_MESSAGE_DECLINE            4
#define DHCP_MESSAGE_ACK                5
#define DHCP_MESSAGE_NAK                6
#define DHCP_MESSAGE_RELEASE            7
#define DHCP_MESSAGE_INFORM             8


//
// IP/1394 support (RFC 2855)
//
#define IP1394_HTYPE                    0x18


//
// FUNCTION DECLARATIONS
//

ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessBootpMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessDiscoverMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessInformMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

VOID
DhcpProcessRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

ULONG
DhcpWriteClientRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PDHCP_BINDING Binding
    );

#endif // _NATHLP_DHCPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dhcp\rmdhcp.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdhcp.c

Abstract:

    This module contains routines for the DHCP allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

COMPONENT_REFERENCE DhcpComponentReference;

PCHAR DhcpDomainName = NULL;

PIP_AUTO_DHCP_GLOBAL_INFO DhcpGlobalInfo;

CRITICAL_SECTION DhcpGlobalInfoLock;

HANDLE DhcpNotificationEvent;

ULONG DhcpProtocolStopped = 0;

const MPR_ROUTING_CHARACTERISTICS DhcpRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_DHCP_ALLOCATOR,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    DhcpRmStartProtocol,
    DhcpRmStartComplete,
    DhcpRmStopProtocol,
    DhcpRmGetGlobalInfo,
    DhcpRmSetGlobalInfo,
    NULL,
    NULL,
    DhcpRmAddInterface,
    DhcpRmDeleteInterface,
    DhcpRmInterfaceStatus,
    DhcpRmGetInterfaceInfo,
    DhcpRmSetInterfaceInfo,
    DhcpRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    DhcpRmMibCreate,
    DhcpRmMibDelete,
    DhcpRmMibGet,
    DhcpRmMibSet,
    DhcpRmMibGetFirst,
    DhcpRmMibGetNext,
    NULL,
    NULL
};

IP_AUTO_DHCP_STATISTICS DhcpStatistics;
SUPPORT_FUNCTIONS DhcpSupportFunctions;

extern "C"
LPSTR WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    );


VOID
DhcpCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DHCP module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DeleteCriticalSection(&DhcpGlobalInfoLock);
    DhcpShutdownInterfaceManagement();
    DeleteComponentReference(&DhcpComponentReference);

} // DhcpCleanupModule


VOID
DhcpCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DHCP protocol-component
    after a 'StopProtocol'. It runs when the last reference to the  
    DHCP component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("DhcpCleanupProtocol");

#if 1
    if (DhcpDomainName) {
        DnsFree(DhcpDomainName, DnsFreeFlat);
        DhcpDomainName = NULL;
    }
#else
    if (DhcpDomainName) {
        NH_FREE(DhcpDomainName);
        DhcpDomainName = NULL;
    }
#endif
    if (DhcpGlobalInfo) { NH_FREE(DhcpGlobalInfo); DhcpGlobalInfo = NULL; }
    InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 1);
    SetEvent(DhcpNotificationEvent);
    ResetComponentReference(&DhcpComponentReference);

    NhStopEventLog();
} // DhcpCleanupProtocol


BOOLEAN
DhcpInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the DHCP module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &DhcpComponentReference, DhcpCleanupProtocol
            )) {
        return FALSE;
    } else if (DhcpInitializeInterfaceManagement()) {
        DeleteComponentReference(&DhcpComponentReference);
        return FALSE;
    } else {
        __try {
            InitializeCriticalSection(&DhcpGlobalInfoLock);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DeleteComponentReference(&DhcpComponentReference);
            return FALSE;
        }
    }

    return TRUE;

} // DhcpInitializeModule


ULONG
APIENTRY
DhcpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("DhcpRmStartProtocol");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    NhStartEventLog();
    
    do {

        //
        // Create a copy of the global configuration
        //

        Size =
            sizeof(*DhcpGlobalInfo) +
            ((PIP_AUTO_DHCP_GLOBAL_INFO)GlobalInfo)->ExclusionCount *
            sizeof(ULONG);
    
        DhcpGlobalInfo =
            reinterpret_cast<PIP_AUTO_DHCP_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!DhcpGlobalInfo) {
            NhTrace(
                TRACE_FLAG_INIT,
                "DhcpRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(DhcpGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        DhcpNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&DhcpSupportFunctions, sizeof(DhcpSupportFunctions));
        }
        else {
            CopyMemory(
                &DhcpSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 0);

    } while (FALSE);

    if (NO_ERROR != Error) {
        NhStopEventLog();
    }

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmStartProtocol


ULONG
APIENTRY
DhcpRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // DhcpRmStartComplete


ULONG
APIENTRY
DhcpRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("DhcpStopProtocol");

    //
    // Reference the module to make sure it's running
    //

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&DhcpComponentReference);

    return DEREFERENCE_DHCP() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // DhcpRmStopProtocol


ULONG
APIENTRY
DhcpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmAddInterface");

    if (Type != PERMANENT) { return NO_ERROR; }

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpCreateInterface(
            Index,
            Type,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmAddInterface


ULONG
APIENTRY
DhcpRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmDeleteInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpDeleteInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmDeleteInterface


ULONG
APIENTRY
DhcpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("DhcpRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // DhcpRmGetEventMessage


ULONG
APIENTRY
DhcpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmGetInterfaceInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpQueryInterface(
            Index,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );

    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmGetInterfaceInfo


ULONG
APIENTRY
DhcpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmSetInterfaceInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        DhcpConfigureInterface(
            Index,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmSetInterfaceInfo


ULONG
APIENTRY
DhcpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = DhcpRmBindInterface(Index, StatusInfo);
            } else {
                Error = DhcpRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = DhcpRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = DhcpRmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // DhcpRmInterfaceStatus


ULONG
DhcpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PCHAR DomainName;
    ULONG Error;
    NTSTATUS status;

    PROFILE("DhcpRmBindInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpBindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    //
    // Re-read the domain name in case it changed
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);

#if 1
    DomainName = DnsGetPrimaryDomainName_A();
    if (DomainName) {
        if (DhcpDomainName && lstrcmpiA(DomainName, DhcpDomainName) == 0) {
            DnsFree(DomainName, DnsFreeFlat);
        } else {
            if (DhcpDomainName) { DnsFree(DhcpDomainName, DnsFreeFlat); }
            DhcpDomainName = DomainName;
        }
    }
#else
    status = NhQueryDomainName(&DomainName);

    if (NT_SUCCESS(status)) {
        if (DhcpDomainName && lstrcmpiA(DomainName, DhcpDomainName) == 0) {
            NH_FREE(DomainName);
        } else {
            NH_FREE(DhcpDomainName);
            if (DhcpDomainName) { NH_FREE(DhcpDomainName); }
            DhcpDomainName = DomainName;
        }
    }
#endif

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmBindInterface


ULONG
DhcpRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmUnbindInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpUnbindInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmUnbindInterface


ULONG
DhcpRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmEnableInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpEnableInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmEnableInterface


ULONG
DhcpRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmDisableInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpDisableInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmDisableInterface


ULONG
APIENTRY
DhcpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("DhcpRmGetGlobalInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&DhcpGlobalInfoLock);
    Size =
        sizeof(*DhcpGlobalInfo) +
        DhcpGlobalInfo->ExclusionCount * sizeof(ULONG);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_DHCP_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, DhcpGlobalInfo, Size);
    LeaveCriticalSection(&DhcpGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DHCP_AND_RETURN(NO_ERROR);
    
} // DhcpRmGetGlobalInfo


ULONG
APIENTRY
DhcpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PIP_AUTO_DHCP_GLOBAL_INFO NewInfo;
    ULONG NewScope;
    ULONG OldScope;
    ULONG Size;
    PROFILE("DhcpRmSetGlobalInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size =
        sizeof(*DhcpGlobalInfo) +
        ((PIP_AUTO_DHCP_GLOBAL_INFO)GlobalInfo)->ExclusionCount * sizeof(ULONG);
    NewInfo = reinterpret_cast<PIP_AUTO_DHCP_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "DhcpRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_DHCP_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&DhcpGlobalInfoLock);
    OldScope = DhcpGlobalInfo->ScopeNetwork & DhcpGlobalInfo->ScopeMask;
    NH_FREE(DhcpGlobalInfo);
    DhcpGlobalInfo = NewInfo;
    NewScope = DhcpGlobalInfo->ScopeNetwork & DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    if (OldScope != NewScope) {
        DhcpReactivateEveryInterface();
    }

    DEREFERENCE_DHCP_AND_RETURN(NO_ERROR);
    
} // DhcpRmSetGlobalInfo


ULONG
APIENTRY
DhcpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
DhcpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The DHCP allocator only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_AUTO_DHCP_MIB_QUERY Oidp;

    PROFILE("DhcpRmMibGet");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !InputData|| !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        Oidp = (PIP_AUTO_DHCP_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_AUTO_DHCP_STATISTICS_OID: {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(DhcpStatistics)) {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DhcpStatistics);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
                else if (!OutputData) {
                    Error = ERROR_INVALID_PARAMETER;
                }
                else {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DhcpStatistics);
                    Oidp = (PIP_AUTO_DHCP_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_AUTO_DHCP_STATISTICS_OID;
                    CopyMemory(
                        Oidp->Data,
                        &DhcpStatistics,
                        sizeof(DhcpStatistics)
                        );
                    Error = NO_ERROR;
                }
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_DHCP_AND_RETURN(Error);
}


ULONG
APIENTRY
DhcpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\debug.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains declarations for debugging-support.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG NhpEventLogCount;
HANDLE NhEventLogHandle = NULL;
CRITICAL_SECTION NhpEventLogLock;
ULONG NhpTraceId = INVALID_TRACEID;

//
// FORWARD DECLARATIONS
//

BOOLEAN
NhpIsAllowedLog(
    ULONG MessageId,
    ULONG Level
    );

//
// TRACING ROUTINES (alphabetically)
//

VOID
NhDump(
    ULONG Flags,
    PUCHAR Buffer,
    ULONG BufferLength,
    ULONG Width
    )
{
    TraceDumpEx(
        NhpTraceId,
        Flags,
        Buffer,
        BufferLength,
        Width,
        FALSE,
        NULL
        );
}

VOID
NhInitializeTraceManagement(
    VOID
    )
{
    NhpTraceId = TraceRegisterA("IPNATHLP");
}

VOID
NhShutdownTraceManagement(
    VOID
    )
{
    TraceDeregister(NhpTraceId);
    NhpTraceId = INVALID_TRACEID;
}

VOID
NhTrace(
    ULONG Flags,
    PCHAR Format,
    ...
    )
{
    va_list VaList;

    va_start(VaList, Format);
    TraceVprintfExA(NhpTraceId, Flags, Format, VaList);
    va_end(VaList);
}


//
// EVENTLOGGING ROUTINES (alphabetically)
//

VOID
NhErrorLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    HANDLE EventLogHandle;

    EnterCriticalSection(&NhpEventLogLock);
    ASSERT(NhpEventLogCount > 0);
    EventLogHandle = NhEventLogHandle;
    LeaveCriticalSection(&NhpEventLogLock);

    if (NULL != EventLogHandle) {
        va_list arglist;
        if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_ERROR)) { return; }
        va_start(arglist, Format);
        RouterLogEventValistExA(
            EventLogHandle,
            EVENTLOG_ERROR_TYPE,
            ErrorCode,
            MessageId,
            Format,
            arglist
            );
        va_end(arglist);
    }
}

VOID
NhInformationLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    HANDLE EventLogHandle;

    EnterCriticalSection(&NhpEventLogLock);
    ASSERT(NhpEventLogCount > 0);
    EventLogHandle = NhEventLogHandle;
    LeaveCriticalSection(&NhpEventLogLock);

    if (NULL != EventLogHandle) {
        va_list arglist;
        if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_INFO)) { return; }
        va_start(arglist, Format);
        RouterLogEventValistExA(
            EventLogHandle,
            EVENTLOG_INFORMATION_TYPE,
            ErrorCode,
            MessageId,
            Format,
            arglist
            );
        va_end(arglist);
    }
}

BOOLEAN
NhInitializeEventLogManagement(
    VOID
    )
{
    BOOLEAN Succeeded = TRUE;
    
    NhpEventLogCount = 0;

    __try {
        InitializeCriticalSection(&NhpEventLogLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Succeeded = FALSE;
    }

    return Succeeded;
}

BOOLEAN
NhpIsAllowedLog(
    ULONG MessageId,
    ULONG Level
    )
{
    if (MessageId > IP_AUTO_DHCP_LOG_BASE && MessageId < IP_AUTO_DHCP_LOG_END) {
        EnterCriticalSection(&DhcpGlobalInfoLock);
        if (!DhcpGlobalInfo) {
            LeaveCriticalSection(&DhcpGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (DhcpGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&DhcpGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return TRUE;
    } else if (MessageId > IP_DNS_PROXY_LOG_BASE &&
                MessageId < IP_DNS_PROXY_LOG_END) {
        EnterCriticalSection(&DnsGlobalInfoLock);
        if (!DnsGlobalInfo) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (DnsGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&DnsGlobalInfoLock);
        return TRUE;
    } else if (MessageId > IP_H323_LOG_BASE && MessageId < IP_H323_LOG_END) {
        EnterCriticalSection(&H323GlobalInfoLock);
        if (!H323GlobalInfo) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (H323GlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&H323GlobalInfoLock);
        return TRUE;
    } else if (MessageId > IP_NAT_LOG_BASE && MessageId < IP_NAT_LOG_END) {
        EnterCriticalSection(&NatGlobalInfoLock);
        if (!NatGlobalInfo) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (NatGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&NatGlobalInfoLock);
        return TRUE;
    }
    return TRUE;
}

VOID
NhWarningLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    HANDLE EventLogHandle;

    EnterCriticalSection(&NhpEventLogLock);
    ASSERT(NhpEventLogCount > 0);
    EventLogHandle = NhEventLogHandle;
    LeaveCriticalSection(&NhpEventLogLock);

    if (NULL != EventLogHandle) {
        va_list arglist;
        if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_WARN)) { return; }
        va_start(arglist, Format);
        RouterLogEventValistExA(
            EventLogHandle,
            EVENTLOG_WARNING_TYPE,
            ErrorCode,
            MessageId,
            Format,
            arglist
            );
        va_end(arglist);
    }
}

VOID
NhStartEventLog(
    VOID
    )
{
    EnterCriticalSection(&NhpEventLogLock);

    NhpEventLogCount += 1;
    if (NULL == NhEventLogHandle) {
        NhEventLogHandle = RouterLogRegisterA(TARGETNAME);
    }

    LeaveCriticalSection(&NhpEventLogLock);
}

VOID
NhStopEventLog(
    VOID
    )
{
    EnterCriticalSection(&NhpEventLogLock);

    ASSERT(NhpEventLogCount > 0);
    NhpEventLogCount -= 1;

    if (0 == NhpEventLogCount && NULL != NhEventLogHandle) {
        RouterLogDeregister(NhEventLogHandle);
        NhEventLogHandle = NULL;
    }

    LeaveCriticalSection(&NhpEventLogLock);
}

VOID
NhShutdownEventLogManagement(
    VOID
    )
{
    DeleteCriticalSection(&NhpEventLogLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\makefile.inc ===
$(O)\nathlpmc.mc: $(IPNAT_PROJECT_PATH)\dhcp\dhcplog.h $(IPNAT_PROJECT_PATH)\dns\dnslog.h $(IPNAT_PROJECT_PATH)\inc\natlog.h $(IPNAT_PROJECT_PATH)\h323\h323log.h
    mapmsg NET IP_AUTO_DHCP_LOG_BASE $(IPNAT_PROJECT_PATH)\dhcp\dhcplog.h > $(O)\nathlpmc.mc
    mapmsg NET IP_DNS_PROXY_LOG_BASE $(IPNAT_PROJECT_PATH)\dns\dnslog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_NAT_LOG_BASE $(IPNAT_PROJECT_PATH)\inc\natlog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_FTP_LOG_BASE $(IPNAT_PROJECT_PATH)\ftp\ftplog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_H323_LOG_BASE $(IPNAT_PROJECT_PATH)\h323\h323log.h >> $(O)\nathlpmc.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\resource.h ===
#pragma once

// beacon reserves XML 1-100
// this is in the net\homenet\beacon\idl directory

#include "beaconrc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <windns.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "rmapi.h"
#include "rmdhcp.h"
#include "rmdns.h"
#include "rmh323.h"
#include "rmnat.h"
#include "rmALG.h"

#include "dhcpif.h"
#include "dhcplog.h"

#include "dnsif.h"
#include "dnslog.h"

#include "Algif.h"
#include "Alglog.h"

#include "h323if.h"
#include "h323log.h"

#include "natapip.h"
#include "natlog.h"
#include "svcmain.h"
#include "timer.h"
#include "csaupdate.h"

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\range.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    range.c

Abstract:

    This module implements an efficient mapping from an arbitrary range of
    IP addresses to a minimal set of IP address-mask pairs covering the range.

    The key to the approach is to regard the set of all possible IP addresses
    as a full 32-bit deep binary tree. Then a single IP address is a path
    through that tree, and a range of addresses is the area between two paths
    through the tree. We then describe such a path-delineated area by pruning
    full subtrees of the area recursively from left to right.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
DecomposeRange(
    ULONG StartAddress,
    ULONG EndAddress,
    ULONG Mask,
    PDECOMPOSE_RANGE_CALLBACK Callback,
    PVOID CallbackContext
    )

/*++

Routine Description:

    This routine decomposes the range StartAddress-EndAddress into
    a minimal set of address-mask pairs, passing the generated
    pairs to the given callback routine.

Arguments:

    StartAddress - the start of the range

    EndAddress - the end of the range

    Mask - the most general mask covering the range

    Callback - routine invoked for each generated address-mask pair

    CallbackContext - context passed to 'Callback'.

Return Value:

    none.

--*/

{
    ULONG temp;

    //
    // Step 1:
    // Check for the first base case: the root of a full tree.
    //

    if ((StartAddress & ~Mask) == 0 && (EndAddress & ~Mask) == ~Mask) {

        if (Callback) { Callback(StartAddress, Mask, CallbackContext); }

        return;
    }

    //
    // Step 2.
    // Extend the mask by one bit to cover the first different position
    // between the start and end address, essentially moving down in the tree
    // to the node where the paths branch.
    //
    //      . <- Most general mask
    //      |
    //      * <- branching point
    //     / \
    //

    Mask = ntohl(Mask);
    Mask >>= 1; Mask |= (1<<31);
    Mask = htonl(Mask);

    //
    // Step 3.
    // Split the range, with the new right edge being a fully-rightward path
    // (no left turns) starting below and to the left of the branching point.
    //
    //      . <- branching point
    //     / \
    //    *
    //     \ <- new right edge
    //

    temp = StartAddress | ~Mask;

    //
    // Step 4.
    // Check for the second base case:
    // the left edge is a fully-leftward path (all-zeroes).
    //

    if ((StartAddress & ~Mask) == 0) {

        if (Callback) { Callback(StartAddress, Mask, CallbackContext); }
    }
    else {

        //
        // Not a base case, so take the left branch.
        //
    
        DecomposeRange(
            StartAddress,
            temp,
            Mask,
            Callback,
            CallbackContext
            );
    }

    //
    // we may be done, if the right edge is also fully rightward
    //

    if ((StartAddress | ~Mask) == EndAddress) { return; }

    //
    // Step 5.
    // Decompose the remaining portion of the range,
    // with the new left edge being the fully-leftward path which starts
    // below and to the right of the original branching point.
    //
    //      . <- branching point
    //     / \
    //        *
    //       / <- new left edge
    //

    temp = EndAddress & Mask;

    //
    // Step 6.
    // Check for the third base case:
    // the right edge is fully-rightward (all-ones).
    //

    if (EndAddress == (temp | ~Mask)) {

        if (Callback) { Callback(EndAddress, Mask, CallbackContext); }
    }
    else {

        //
        // Not a base case; take the right branch.
        //

        DecomposeRange(
            temp,
            EndAddress,
            MostGeneralMask(temp, EndAddress),
            Callback,
            CallbackContext
            );
    }
}


ULONG
MostGeneralMask(
    ULONG StartAddress,
    ULONG EndAddress
    )

/*++

Routine Description:

    This routine generates the most general mask covering the range
    'StartAddress' - 'EndAddress'.

Arguments:

    StartAddress - beginning of range, in network order

    EndAddress - end of range, in network order

Return Value:

    ULONG - the most general mask

--*/

{
    ULONG CommonBits, Mask;
    StartAddress = ntohl(StartAddress);
    EndAddress = ntohl(EndAddress);

    //
    // find the bits common to the start address and end address
    //

    CommonBits = ~(StartAddress ^ EndAddress);

    //
    // CommonBits now has a 1 in each position where StartAddress and
    // EndAddress are the same.
    // We want to reduce this to only include the longest contiguous
    // most significant bits
    // e.g. 11101110 becomes 11100000 and 11111101 becomes 11111100
    //

    for (Mask = 0xffffffff; Mask && ((CommonBits & Mask) != Mask); Mask<<=1) { }
    
    return htonl(Mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\socket.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains code for socket-management.
    The routines provided generally follow the same asynchronous model
    using a completion routine that is invoked in the context of
    a callback thread.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

    Jonathan Burstein (jonburs)     12-April-2001

    Added support for raw datagram sockets.

--*/

#include "precomp.h"
#pragma hdrstop
#include <ws2tcpip.h>
#include <mstcpip.h>
#include <mswsock.h>

#if DBG
ULONG NhpReadCount = 0;
#endif
ULONG UnusedBytesTransferred;

typedef struct _NH_CLOSE_BUFFER {
    HANDLE Event OPTIONAL;
    HANDLE WaitHandle OPTIONAL;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine;
} NH_CLOSE_BUFFER, *PNH_CLOSE_BUFFER;

typedef struct _NH_CONNECT_BUFFER {
    HANDLE Event;
    HANDLE WaitHandle;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL;
    BOOLEAN CloseNotificationReceived;
} NH_CONNECT_BUFFER, *PNH_CONNECT_BUFFER;

//
// FORWARD DECLARATIONS
//

VOID NTAPI
NhpCloseNotificationCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID NTAPI
NhpConnectOrCloseCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID WINAPI
NhpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    );

VOID APIENTRY
NhpIoWorkerRoutine(
    PVOID Context
    );


ULONG
NhAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to accept an incoming connection-request
    on a listening stream socket using 'AcceptEx'. The I/O system invokes
    the provided 'CompletionRoutine' upon completion of the read.

    It is the completion-routine's responsibility to use 'setsockopt' to
    set the SO_UPDATE_ACCEPT_CONTEXT option on the accepted socket before
    the accepted socket can be used with Winsock2 routines.

    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    ListeningSocket - the endpoint that is listening for connection-requests

    AcceptedSocket - the endpoint to be assigned a connection-request,
        or INVALID_SOCKET to create a new endpoint

    Bufferp - the buffer to be used for asynchronous completion
        or NULL to acquire a new buffer

    AcceptCompletionRoutine - the routine to be invoked upon completion

    Context - the context to be associated with the accept-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the accept-completion routine
    will be invoked.
    Conversely, a failure code is a guarantee that the routine will not
    be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    SOCKET LocalSocket = INVALID_SOCKET;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(TRACE_FLAG_SOCKET, "error allocating buffer for accept");
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (AcceptedSocket == INVALID_SOCKET) {
        Error = NhCreateStreamSocket(INADDR_NONE, 0, &LocalSocket);
        if (Error) {
            NhTrace(
                TRACE_FLAG_SOCKET, "error %d creating socket for accept", Error
                );
            if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        AcceptedSocket = LocalSocket;
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = AcceptedSocket;
    Bufferp->CompletionRoutine = AcceptCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;

    if (AcceptEx(
            ListeningSocket,
            AcceptedSocket,
            Bufferp->Buffer,
            0,
            sizeof(SOCKADDR_IN) + 16,
            sizeof(SOCKADDR_IN) + 16,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            )) {
        Error = NO_ERROR;
    } else {
        if ((Error = WSAGetLastError()) == ERROR_IO_PENDING) {
            Error = NO_ERROR;
        } else if (Error) {
            if (LocalSocket != INVALID_SOCKET) {
                NhDeleteStreamSocket(LocalSocket);
            }
            if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            NhTrace(
                TRACE_FLAG_SOCKET, "error %d returned by 'AcceptEx'", Error
                );
        }
    }

    return Error;

} // NhAcceptStreamSocket


ULONG
NhConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to establish a connection using a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

    Since Windows Sockets does not deliver connect-notifications to
    I/O completion ports, we need to make some special arrangements in order
    to notify the caller's completion routine the way we do for send-requests
    and receive-requests. Specifically, we create an event-handle and
    request connect-notification on it by calling 'WSAEventSelect'.
    We then register a wait on the event-handle, specifying a private
    completion routine. (See 'NhpConnectOrCloseCallbackRoutine'.)
    When this completion routine runs, it extracts the status code of the
    connection-attempt using 'WSAEnumNetworkEvents'. It then passes the status
    along with the usual parameters to the caller's completion routine.

    The caller may optionally receive notification when the remote endpoint
    closes the socket after a successful connection. We use the same
    'WSAEventSelect' mechanism to detect that condition and invoke the
    caller's notification routine.

    N.B. The buffer supplied to this routine may not be released by either
    the connect-completion routine or the close-notification routine.
    (See 'NhpConnectOrCloseCallbackRoutine' for more information.)

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket with which to establish a connection

    Address - the IP address of the remote endpoint

    Port - the port number of the remote endpoint

    Bufferp - optionally supplies the buffer to be used to hold context
        during the connection-attempt

    ConnectCompletionRoutine - a routine to be invoked upon completion 
        of the connect-attempt

    CloseNotificationRoutine - optionally specifies a routine to be invoked
        upon notification of the resulting socket's closure by the remote
        endpoint

    Context - passed to the 'ConnectCompletionRoutine' and
        'CloseNotificationRoutine'

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code

    A success code is a guarantee that both the connect-completion routine
    and the close-notification routine, if any, will be invoked.
    Conversely, a failure code is a guarantee that the neither routine will
    be invoked.

--*/

{
    PNH_CONNECT_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhConnectStreamSocket: error allocating buffer for connect"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = ConnectingSocket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = ConnectCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->ConnectAddress.sin_family = AF_INET;
    Bufferp->ConnectAddress.sin_addr.s_addr = Address;
    Bufferp->ConnectAddress.sin_port = Port;

    Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationReceived = FALSE;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            NhpConnectOrCloseCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        ULONG EventsSelected = FD_CONNECT;
        if (CloseNotificationRoutine) { EventsSelected |= FD_CLOSE; }
        Error =
            WSAEventSelect(
                ConnectingSocket, Contextp->Event, EventsSelected
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
        } else {
            Error =
                WSAConnect(
                    ConnectingSocket,
                    (PSOCKADDR)&Bufferp->ConnectAddress,
                    sizeof(Bufferp->ConnectAddress),
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        }
    }

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSAEWOULDBLOCK) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhConnectStreamSocket


ULONG
NhCreateDatagramSocket(
    ULONG Address,
    USHORT Port,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is called to initialize a datagram socket.

Arguments:

    Address - the IP address to which the socket should be bound (network-order)

    Port - the UDP port to which the socket should be bound (network-order)

    Socketp - receives the created socket

Return Value:

    ULONG - Win32/Winsock2 error code

--*/

{
    ULONG Error;
    ULONG Option;
    ULONG OutputBufferLength;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new socket
        //
    
        Socket =
            WSASocket(
                AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateDatagramSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        if (FALSE == BindIoCompletionCallback(
                        (HANDLE)Socket,
                        NhpIoCompletionRoutine,
                        0)) {

            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateDatagramSocket: error %d binding callback", Error
                );
            break;
        }

        //
        // Attempt to enable endpoint-reuse on the socket
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                SOL_SOCKET,
                SO_REUSEADDR,
                (PCHAR)&Option,
                sizeof(Option)
                );

        //
        // Attempt to enable broadcasting on the socket
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                SOL_SOCKET,
                SO_BROADCAST,
                (PCHAR)&Option,
                sizeof(Option)
                );

        //
        // Limit broadcasts to the outgoing network
        // (the default is to send broadcasts on all interfaces).
        //

        Option = 1;
        WSAIoctl(
            Socket,
            SIO_LIMIT_BROADCASTS,
            &Option,
            sizeof(Option),
            NULL,
            0,
            &OutputBufferLength,
            NULL,
            NULL
            );

        //
        // Bind the socket
        //

        SocketAddress.sin_family = AF_INET;
        SocketAddress.sin_port = Port;
        SocketAddress.sin_addr.s_addr = Address;

        Error = bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));

        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateDatagramSocket: error %d binding socket", Error
                );
            break;
        }

        //
        // Save the socket and return
        //

        *Socketp = Socket;

        return NO_ERROR;

    } while (FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
    
} // NhCreateDatagramSocket


ULONG
NhCreateRawDatagramSocket(
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is called to initialize a raw, header-include
    datagram socket.

Arguments:

    Socketp - receives the created socket

Return Value:

    ULONG - Win32/Winsock2 error code

--*/

{
    ULONG Error;
    ULONG Option;
    ULONG OutputBufferLength;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new socket
        //
    
        Socket =
            WSASocket(
                AF_INET, SOCK_RAW, IPPROTO_UDP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateRawDatagramSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        if (FALSE == BindIoCompletionCallback(
                        (HANDLE)Socket,
                        NhpIoCompletionRoutine,
                        0)) {

            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateRawDatagramSocket: error %d binding callback", Error
                );
            break;
        }

        //
        // Turn on header-include mode
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                IPPROTO_IP,
                IP_HDRINCL,
                (PCHAR)&Option,
                sizeof(Option)
                );
        if (SOCKET_ERROR == Error) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateRawDatagramSocket: error %d setting IP_HDRINCL", Error
                );
            break;
        }

        //
        // Limit broadcasts to the outgoing network
        // (the default is to send broadcasts on all interfaces).
        //

        Option = 1;
        WSAIoctl(
            Socket,
            SIO_LIMIT_BROADCASTS,
            &Option,
            sizeof(Option),
            NULL,
            0,
            &OutputBufferLength,
            NULL,
            NULL
            );

        //
        // Save the socket and return
        //

        *Socketp = Socket;

        return NO_ERROR;

    } while (FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;

} // NhCreateRawDatagramSocket



ULONG
NhCreateStreamSocket(
    ULONG Address OPTIONAL,
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is invoked to create and initialize a stream socket.
    The socket will also be bound to a local IP address and port,
    unless none is specified.

Arguments:

    Address - the local IP address to which the new socket should be bound,
        or INADDR_ANY to allow the system to leave the IP address unspecified,
        or INADDR_NONE if the socket should not be bound at all.

    Port - the port number to which the new socket should be bound,
        or 0 if to allow the system to select a port number.

    Socketp - receives initialized socket

Return Value:

    ULONG - Win32/Winsock2 status code.

--*/

{
    ULONG Error;
    ULONG Option;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new stream socket.
        //

        Socket =
            WSASocket(
                AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateStreamSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        if (FALSE == BindIoCompletionCallback(
                        (HANDLE)Socket,
                        NhpIoCompletionRoutine,
                        0)) {

            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateStreamSocket: error %d binding callback", Error
                );
            break;
        }

        //
        // Disable send and receive buffering in AFD,
        // since we will be operating asynchronously with a receive-buffer
        // (almost) always outstanding, and since in any case we want
        // TCP/IP's flow-control to limit the sender's sending rate properly.
        //

        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );

        //
        // If the caller has requested that the socket be bound by specifying
        // a local IP address, bind the socket now.
        //

        if (Address != INADDR_NONE) {
            SocketAddress.sin_family = AF_INET;
            SocketAddress.sin_port = Port;
            SocketAddress.sin_addr.s_addr = Address;
            Error =
                bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));
            if (Error == SOCKET_ERROR) {
                Error = WSAGetLastError();
                NhTrace(
                    TRACE_FLAG_SOCKET,
                    "NhCreateStreamSocket: error %d binding socket", Error
                    );
                break;
            }
        }

        //
        // Store the new socket in the caller's output-parameter, and return.
        //

        *Socketp = Socket;
        return NO_ERROR;

    } while(FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
} // NhCreateStreamSocket


VOID
NhDeleteSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine releases network resources for a socket.

Arguments:

    Socket - the socket to be deleted

Return Value:

    none.

--*/

{
    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
} // NhDeleteSocket


ULONG
NhNotifyOnCloseStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to request notification of a socket's closure.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the notification routine runs.

Arguments:

    Component - the component to be referenced for the notification routine

    Socket - the endpoint for which close-notification is requested

    Bufferp - the buffer to be used to hold context-informatio for the request,
        or NULL to acquire a new buffer.

    CloseNotificationRoutine - the routine to be invoked upon closure of the
        socket

    Context - the context to be associated with the notification-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the notification routine will be invoked.
    Conversely, a failure code is a guarantee that the notification routine
    will not be invoked.

--*/

{
    PNH_CLOSE_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = NULL;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;

    Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            NhpCloseNotificationCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        Error = WSAEventSelect(Socket, Contextp->Event, FD_CLOSE);
        if (Error == SOCKET_ERROR) { Error = WSAGetLastError(); }
    }

    if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhNotifyOnCloseStreamSocket


VOID NTAPI
NhpCloseNotificationCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked upon closure of an accepted connection by the
    remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when connection-acceptance is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CLOSE_BUFFER Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CLOSE', we unregister the wait since there's
    // nothing left to wait for.
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;
    Error =
        WSAEnumNetworkEvents(
            Bufferp->Socket, Contextp->Event, &NetworkEvents
            );
    if (Error || !(NetworkEvents.lNetworkEvents & FD_CLOSE)) {

        //
        // We couldn't determine which events occurred on the socket,
        // so call the notification routine with an error, and fall through
        // to the cleanup code below.
        //

        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(
                ERROR_OPERATION_ABORTED, 0, Bufferp
                );
        }

    } else {

        //
        // A close occurred on the socket, so retrieve the error code,
        // invoke the close-notification routine if any, and fall through
        // to the cleanup code below.
        //

        Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];
        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
        }
    }

    UnregisterWait(Contextp->WaitHandle);
    CloseHandle(Contextp->Event);
    NhReleaseBuffer(Bufferp);

} // NhpCloseNotificationCallbackRoutine


VOID NTAPI
NhpConnectOrCloseCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked by upon completion of a connect-operation
    or upon closure of the connection by the remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when a connection-attempt is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CONNECT_BUFFER Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CONNECT', we unregister the wait if an error
    // occurred. When invoked for 'FD_CLOSE', we unregister the wait
    // since there's nothing left to wait for.
    //
    // In essence, our goal is to guarantee that whatever the success
    // or failure or sequence of events on the socket, the connect-completion
    // and close-notification routines will both be called for the socket,
    // in that order.
    //
    // N.B. Neither routine is allowed to release the connect-buffer,
    // since we may need to preserve it on behalf of the close-notification
    // routine, if any.
    //
    // N.B. We may be invoked with both the 'FD_CONNECT' and 'FD_CLOSE' bits
    // set, for instance when the socket is closed. In that case we call
    // both routines here.
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;
    Error =
        WSAEnumNetworkEvents(
            Bufferp->Socket, Contextp->Event, &NetworkEvents
            );
    if (Error) {

        //
        // We couldn't determine which events occurred on the socket,
        // so call the routines with errors, and fall through
        // to the cleanup code below.
        //

        if (Bufferp->CompletionRoutine) {
            Bufferp->CompletionRoutine(ERROR_OPERATION_ABORTED, 0, Bufferp);
            Bufferp->CompletionRoutine = NULL;
        }
        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(
                ERROR_OPERATION_ABORTED, 0, Bufferp
                );
        }
        Contextp->CloseNotificationReceived = TRUE;

    } else {
        if (NetworkEvents.lNetworkEvents & FD_CONNECT) {
    
            //
            // The connect completed, so retrieve the error code and invoke
            // the connect-completion routine. If the connect failed,
            // we may never receive close-notification (unless the bit
            // is already set) so we need to simulate close-notification
            // here so that the cleanup code below executes.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
            if (Bufferp->CompletionRoutine) {
                Bufferp->CompletionRoutine(Error, 0, Bufferp);
                Bufferp->CompletionRoutine = NULL;
            }
            if (Error && !(NetworkEvents.lNetworkEvents & FD_CLOSE)) {
                if (Contextp->CloseNotificationRoutine) {
                    Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
                }
                Contextp->CloseNotificationReceived = TRUE;
            }
        }
        if (NetworkEvents.lNetworkEvents & FD_CLOSE) {
    
            //
            // A close occurred on the socket, so retrieve the error code,
            // invoke the close-notification routine if any, and fall through
            // to the cleanup code below.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];
            if (Contextp->CloseNotificationRoutine) {
                Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
            }
            Contextp->CloseNotificationReceived = TRUE;
        }
    }

    //
    // If both the connect-completion and close-notification routines have run,
    // we are done with this wait-handle and buffer.
    //

    if (!Bufferp->CompletionRoutine && Contextp->CloseNotificationReceived) {
        UnregisterWait(Contextp->WaitHandle);
        CloseHandle(Contextp->Event);
        NhReleaseBuffer(Bufferp);
    }
} // NhpConnectOrCloseCallbackRoutine


VOID
NhpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    )

/*++

Routine Description:

    This routine is invoked by the I/O system upon completion of an operation.

Arguments:

    ErrorCode - system-supplied error code

    BytesTransferred - system-supplied byte-count

    Overlapped - caller-supplied context area

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread.

--*/

{
    PNH_BUFFER Bufferp = CONTAINING_RECORD(Overlapped, NH_BUFFER, Overlapped);
    NTSTATUS status;
    Bufferp->ErrorCode = ErrorCode;
    Bufferp->BytesTransferred = BytesTransferred;
    Bufferp->CompletionRoutine(
        Bufferp->ErrorCode,
        Bufferp->BytesTransferred,
        Bufferp
        );
} // NhpIoCompletionRoutine


VOID APIENTRY
NhpIoWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to continue processing of completed I/O
    in the context of an alertably waiting thread which does not exit idly.

Arguments:

    Context - holds the buffer associated with the completed I/O operation.

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL alertable worker thread.

--*/

{
    ((PNH_BUFFER)Context)->CompletionRoutine(
        ((PNH_BUFFER)Context)->ErrorCode,
        ((PNH_BUFFER)Context)->BytesTransferred,
        ((PNH_BUFFER)Context)
        );

} // NhpIoWorkerRoutine


VOID
NhQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    )
{
    PSOCKADDR_IN LocalSockAddr = NULL;
    ULONG LocalLength = sizeof(LocalSockAddr);
    PSOCKADDR_IN RemoteSockAddr = NULL;
    ULONG RemoteLength = sizeof(RemoteSockAddr);
    GetAcceptExSockaddrs(
        AcceptBuffer,
        0,
        sizeof(SOCKADDR_IN) + 16,
        sizeof(SOCKADDR_IN) + 16,
        (PSOCKADDR*)&LocalSockAddr,
        reinterpret_cast<LPINT>(&LocalLength),
        (PSOCKADDR*)&RemoteSockAddr,
        (LPINT)&RemoteLength
        );

    if (LocalAddress && LocalSockAddr) {
        *LocalAddress = LocalSockAddr->sin_addr.s_addr; 
    }
    if (LocalPort && LocalSockAddr) { 
        *LocalPort = LocalSockAddr->sin_port; 
    }
    if (RemoteAddress && RemoteSockAddr) { 
        *RemoteAddress = RemoteSockAddr->sin_addr.s_addr; 
    }
    if (RemotePort && RemoteSockAddr) { 
        *RemotePort = RemoteSockAddr->sin_port; 
    }
} // NhQueryAcceptEndpoints


ULONG
NhQueryAddressSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address associated with
    a socket.

Arguments:

    Socket - the socket to be queried

Return Value:

    ULONG - the IP address retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_addr.s_addr;
} // NhQueryAddressSocket


ULONG
NhQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getsockname(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // NhQueryEndpointSocket


USHORT
NhQueryPortSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine retrieves the port number to which a socket is bound.

Arguments:

    Socket - the socket to be queried

Return Value:

    USHORT - the port number retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_port;
} // NhQueryPortSocket


ULONG
NhQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getpeername(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // NhQueryRemoteEndpointSocket


ULONG
NhReadDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a datagram socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer. If no buffer is supplied,
        the resulting message is assumed to fit inside a fixed-length buffer

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadDatagramSocket: error allocating buffer for receive"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->AddressLength = sizeof(Bufferp->ReadAddress);
    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = NH_BUFFER_SIZE;

    Error =
        WSARecvFrom(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            (PSOCKADDR)&Bufferp->ReadAddress,
            (LPINT)&Bufferp->AddressLength,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadDatagramSocket: error %d returned by 'WSARecvFrom'", Error
            );
    }

    return Error;

} // NhReadDatagramSocket


ULONG
NhReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a stream socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer

    Length - the maximum number of bytes to be read

    Offset - the offset into the buffer at which the read should begin,
        valid only if 'Bufferp' is provided.

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Offset = 0;
        Bufferp = LocalBufferp = NhAcquireVariableLengthBuffer(Length);
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadStreamSocket: error allocating buffer for receive"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (ReadFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadStreamSocket: error %d returned by 'ReadFile'", Error
            );
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSARecv(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadStreamSocket: error %d returned by 'WSARecv'", Error
            );
    }
#endif

    return Error;

} // NhReadStreamSocket


ULONG
NhWriteDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp,
    ULONG Length,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a datagram socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Address - the address of the message's destination

    Port - the port of the message's destination

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    LONG AddressLength;
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->WriteAddress.sin_family = AF_INET;
    Bufferp->WriteAddress.sin_addr.s_addr = Address;
    Bufferp->WriteAddress.sin_port = Port;
    AddressLength = sizeof(Bufferp->WriteAddress);
    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = Length;

    Error =
        WSASendTo(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            (PSOCKADDR)&Bufferp->WriteAddress,
            AddressLength,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteDatagramSocket: error %d returned by 'WSASendTo'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhWriteDatagramSocket


ULONG
NhWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    Offset - the offset into the buffer at which the data to be sent begins

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (WriteFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WriteFile'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSASend(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WSASend'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#endif

    return Error;

} // NhWriteStreamSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\udpbcast_i_stub.c ===
#include "udpbcast_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\timer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains routines for manipulating the timer-queue
    which is shared by all the components in this module.

Author:

    Abolade Gbadegesin (aboladeg)   1-April-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE NhpTimerQueueHandle = NULL;
CRITICAL_SECTION NhpTimerQueueLock;

typedef struct _NH_TIMER_CONTEXT {
    WAITORTIMERCALLBACKFUNC TimerRoutine;
    PVOID Context;
    HANDLE Handle;
} NH_TIMER_CONTEXT, *PNH_TIMER_CONTEXT;


ULONG
NhInitializeTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the timer-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    __try {
        InitializeCriticalSection(&NhpTimerQueueLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_TIMER,
            "NhInitializeTimerManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }
    return Error;

} // NhInitializeTimerManagement


VOID NTAPI
NhpTimerCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )
{
    ((PNH_TIMER_CONTEXT)Context)->TimerRoutine(
        ((PNH_TIMER_CONTEXT)Context)->Context, TimedOut
        );
    EnterCriticalSection(&NhpTimerQueueLock);
    if (NhpTimerQueueHandle) {
        LeaveCriticalSection(&NhpTimerQueueLock);
        RtlDeleteTimer(
            NhpTimerQueueHandle, ((PNH_TIMER_CONTEXT)Context)->Handle, NULL
            );
    } else {
        LeaveCriticalSection(&NhpTimerQueueLock);
    }
    NH_FREE(Context);
} // NhpTimerCallbackRoutine


NTSTATUS
NhSetTimer(
    PCOMPONENT_REFERENCE Component OPTIONAL,
    OUT HANDLE* Handlep OPTIONAL,
    WAITORTIMERCALLBACKFUNC TimerRoutine,
    PVOID Context,
    ULONG DueTime
    )

/*++

Routine Description:

    This routine is called to install a timer.

Arguments:

    Component - optionally supplies a component to be referenced

    Handlep - optionally receives the handle of the timer created

    TimerRoutine - invoked upon completion of the countdown

    Context - supplied to 'TimerRoutine' upon completion of the countdown

    DueTime - countdown time in milliseconds

Return Value:

    NTSTATUS - status code.

--*/

{
    HANDLE Handle;
    NTSTATUS status;
    PNH_TIMER_CONTEXT TimerContext;

    EnterCriticalSection(&NhpTimerQueueLock);
    if (!NhpTimerQueueHandle) {
        status = RtlCreateTimerQueue(&NhpTimerQueueHandle);
        if (!NT_SUCCESS(status)) {
            NhpTimerQueueHandle = NULL;
            LeaveCriticalSection(&NhpTimerQueueLock);
            NhTrace(
                TRACE_FLAG_TIMER,
                "NhSetTimer: RtlCreateTimerQueue=%x", status
                );
            return status;
        }
    }
    LeaveCriticalSection(&NhpTimerQueueLock);

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, STATUS_UNSUCCESSFUL);
    }
    TimerContext =
        reinterpret_cast<PNH_TIMER_CONTEXT>(NH_ALLOCATE(sizeof(*TimerContext)));
    if (!TimerContext) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        return STATUS_NO_MEMORY;
    }

    TimerContext->TimerRoutine = TimerRoutine;
    TimerContext->Context = Context;

    status =
        RtlCreateTimer(
            NhpTimerQueueHandle,
            &TimerContext->Handle,
            NhpTimerCallbackRoutine,
            TimerContext,
            DueTime,
            0,
            0
            );

    if (!NT_SUCCESS(status)) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    } else if (Handlep) {
        *Handlep = TimerContext->Handle;
    }
    return status;

} // NhSetTimer


VOID
NhShutdownTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to clean up the timer-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhpTimerQueueLock);
    if (NhpTimerQueueHandle) { RtlDeleteTimerQueue(NhpTimerQueueHandle); }
    NhpTimerQueueHandle = NULL;
    LeaveCriticalSection(&NhpTimerQueueLock);
    DeleteCriticalSection(&NhpTimerQueueLock);

} // NhShutdownTimerManagement


NTSTATUS
NhUpdateTimer(
    HANDLE Handle,
    ULONG DueTime
    )

/*++

Routine Description:

    This routine modifies the countdown for a timer.

Arguments:

    Handle - the handle of the timer to be modified

    DueTime - the new countdown in milliseconds

Return Value:

    NTSTATUS - status code.

--*/

{
    EnterCriticalSection(&NhpTimerQueueLock);
    if (!NhpTimerQueueHandle) {
        LeaveCriticalSection(&NhpTimerQueueLock);
        return STATUS_INVALID_PARAMETER;
    }
    LeaveCriticalSection(&NhpTimerQueueLock);

    return
        RtlUpdateTimer(
            NhpTimerQueueHandle,
            Handle,
            DueTime,
            0
            );

} // NhUpdateTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsfile.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dnsfile.h

Abstract:

    This module contains declarations for the DNS proxy's file
    management.

Author:

    Raghu Gatta (rgatta)   21-Nov-2000

Revision History:
    
--*/

#ifndef _NATHLP_DNSFILE_H_
#define _NATHLP_DNSFILE_H_


//
//  Sockets hosts.ics file stuff
//  NOTE: The hosts.ics file will reside in the same directory as the hosts file
//

#define HOSTS_FILE_DIRECTORY    L"\\drivers\\etc"
#define HOSTDB_SIZE             (MAX_PATH + 12)   // 12 == strlen("\\hosts.ics") + 1
#define HOSTSICSFILE            "hosts.ics"

#define HOSTSICSFILE_HEADER     \
"# Copyright (c) 1993-2001 Microsoft Corp.\n"                                   \
"#\n"                                                                           \
"# This file has been automatically generated for use by Microsoft Internet\n"  \
"# Connection Sharing. It contains the mappings of IP addresses to host names\n"\
"# for the home network. Please do not make changes to the HOSTS.ICS file.\n"   \
"# Any changes may result in a loss of connectivity between machines on the\n"  \
"# local network.\n"                                                            \
"#\n"                                                                           \
"\n"



typedef struct _IP_DNS_PROXY_FILE_INFO
{
    CRITICAL_SECTION  Lock;
    FILE             *HostFile;
    CHAR              HostFileName[HOSTDB_SIZE];
    CHAR              HostLineBuf[BUFSIZ + 1];

    // temp values in the context of current file processing
    SYSTEMTIME        HostTime;
    PCHAR             pHostName;
    ULONG             Ip4Address;

} IP_DNS_PROXY_FILE_INFO, *PIP_DNS_PROXY_FILE_INFO;


//
// FUNCTION DECLARATIONS
//

ULONG
DnsInitializeFileManagement(
    VOID
    );

VOID
DnsShutdownFileManagement(
    VOID
    );

BOOL
DnsEndHostsIcsFile(
    VOID
    );

BOOL
DnsSetHostsIcsFile(
    BOOL fOverwrite
    );

BOOL
GetHostFromHostsIcsFile(
    BOOL fStartup
    );

VOID
LoadHostsIcsFile(
    BOOL fStartup
    );

VOID
SaveHostsIcsFile(
    BOOL fShutdown
    );

BOOL
IsFileTimeExpired(
    FILETIME *ftTime
    );

BOOL
IsSuffixValid(
    WCHAR *pszName,
    WCHAR *pszSuffix
    );


#endif // _NATHLP_DNSFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsif.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsif.c

Abstract:

    This module contains code for the DNS proxy's interface management.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop

//
// LOCAL TYPE DECLARATIONS
//

typedef struct _DNS_DEFER_READ_CONTEXT {
    ULONG Index;
    SOCKET Socket;
    ULONG DeferralCount;
} DNS_DEFER_READ_CONTEXT, *PDNS_DEFER_READ_CONTEXT;

#define DNS_DEFER_READ_INITIAL_TIMEOUT (1 * 1000)
#define DNS_DEFER_READ_TIMEOUT (5 * 1000)
#define DNS_CONNECT_TIMEOUT (60 * 1000)

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY DnsInterfaceList;
CRITICAL_SECTION DnsInterfaceLock;
ULONG DnspLastConnectAttemptTickCount;

//
// Forward declarations
//

VOID NTAPI
DnspDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DnspDeferReadWorkerRoutine(
    PVOID Context
    );

ULONG NTAPI
DnspSaveFileWorkerRoutine(
    PVOID Context
    );


ULONG
DnsActivateInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating datagram-reads on each created socket

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'DnsInterfaceLock' held by caller.

--*/

{
    BOOLEAN EnableDns;
    BOOLEAN EnableWins = FALSE;
    ULONG Error;
    ULONG i;
    ULONG InterfaceCharacteristics;
    DNS_INTERFACE_TYPE dnsIfType;

    PROFILE("DnsActivateInterface");

    EnterCriticalSection(&DnsGlobalInfoLock);
    EnableDns =
        (DnsGlobalInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS) ? TRUE : FALSE;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // (re)take the interface lock for the duration of the routine
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!(EnableDns || EnableWins) ||
        DNS_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        return NO_ERROR;
    }

    InterfaceCharacteristics =
        NatGetInterfaceCharacteristics(
                Interfacep->Index
                );

    if (!InterfaceCharacteristics) {
        ACQUIRE_LOCK(Interfacep);
        Interfacep->DnsInterfaceType = DnsInterfaceInvalid;
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    if (NAT_IFC_BOUNDARY(InterfaceCharacteristics))
    {
        if (NAT_IFC_FW(InterfaceCharacteristics))
        {
            dnsIfType = DnsInterfaceBoundaryFirewalled;
        }
        else
        {
            dnsIfType = DnsInterfaceBoundary;
        }
    }
    else
    if (NAT_IFC_FW(InterfaceCharacteristics))
    {
        dnsIfType = DnsInterfaceFirewalled;
    }
    else
    {
        dnsIfType = DnsInterfacePrivate;
    }

    //
    // Create datagram sockets for receiving data on each logical network
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    Interfacep->DnsInterfaceType = dnsIfType;

    if (DnsInterfacePrivate != dnsIfType)
    {
        //
        // DNS should be active only on Private interfaces
        //
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: ignoring NAT interface %d",
            Interfacep->Index
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_NAT_INTERFACE_IGNORED,
            0,
            "%d",
            Interfacep->Index
            );
        RELEASE_LOCK(Interfacep);            
        LeaveCriticalSection(&DnsInterfaceLock);
        return NO_ERROR;
    }

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (EnableDns) {
            Error =
                NhCreateDatagramSocket(
                    Interfacep->BindingArray[i].Address,
                    DNS_PORT_SERVER,
                    &Interfacep->BindingArray[i].Socket[DnsProxyDns]
                    );
            if (Error) { break; }
        }

        if (EnableWins) {
            Error =
                NhCreateDatagramSocket(
                    Interfacep->BindingArray[i].Address,
                    WINS_PORT_SERVER,
                    &Interfacep->BindingArray[i].Socket[DnsProxyWins]
                    );
            if (Error) { break; }
        }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (; (LONG)i >= 0; i--) {
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket[DnsProxyDns]
                );
            Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket[DnsProxyWins]
                );
            Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_DNS_PROXY_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DnsInterfaceLock);
        return Error;
    }

    if (EnableWins && DNS_REFERENCE_INTERFACE(Interfacep)) {
        Error =
            NhReadDatagramSocket(
                &DnsComponentReference,
                DnsGlobalSocket,
                NULL,
                DnsReadCompletionRoutine,
                Interfacep,
                NULL
                );
        if (Error) { DNS_DEREFERENCE_INTERFACE(Interfacep); }
    }

    //
    // Initiate read-operations on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (EnableDns) {

            //
            // Make a reference to the interface;
            // this reference is released in the completion routine
            //
    
            if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }
    
            //
            // Initiate the read-operation
            //
    
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Interfacep->BindingArray[i].Socket[DnsProxyDns],
                    NULL,
                    DnsReadCompletionRoutine,
                    Interfacep,
                    UlongToPtr(Interfacep->BindingArray[i].Address)
                    );
    
            //
            // Drop the reference if a failure occurred
            //
    
            if (Error) {
    
                NhErrorLog(
                    IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    Interfacep->BindingArray[i].Address
                    );
    
                DNS_DEREFERENCE_INTERFACE(Interfacep);
    
                //
                // Reissue the read-operation later
                //
    
                DnsDeferReadInterface(
                    Interfacep,
                    Interfacep->BindingArray[i].Socket[DnsProxyDns]
                    );
    
                Error = NO_ERROR;
            }
        }

        if (EnableWins) {

            //
            // Reference the interface for the WINS socket receive
            //
    
            if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }
    
            //
            // Initiate the read-operation
            //
    
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Interfacep->BindingArray[i].Socket[DnsProxyWins],
                    NULL,
                    DnsReadCompletionRoutine,
                    Interfacep,
                    UlongToPtr(Interfacep->BindingArray[i].Address)
                    );
    
            //
            // Drop the reference if a failure occurred
            //
    
            if (Error) {
    
                NhErrorLog(
                    IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    Interfacep->BindingArray[i].Address
                    );
    
                DNS_DEREFERENCE_INTERFACE(Interfacep);
    
                //
                // Reissue the read-operation later
                //
    
                DnsDeferReadInterface(
                    Interfacep,
                    Interfacep->BindingArray[i].Socket[DnsProxyWins]
                    );
    
                Error = NO_ERROR;
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // queue a write to disk (ip address may have changed)
    // (necessary to do this to prevent possible deadlock)
    //
    if (REFERENCE_DNS())
    {
        if (!QueueUserWorkItem(DnspSaveFileWorkerRoutine, NULL, WT_EXECUTEDEFAULT))
        {
            Error = GetLastError();
            NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: QueueUserWorkItem failed with error %d (0x%08x)",
            Error,
            Error
            );
            DEREFERENCE_DNS();
        }
        else
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsActivateInterface: queued a write of %s file",
                HOSTSICSFILE
                );
        }
    }

    return NO_ERROR;

} // DnsActivateInterface


ULONG
DnsBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsBindInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (DNS_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    }
    else {
        Interfacep->BindingArray =
            reinterpret_cast<PDNS_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(DNS_BINDING))
                );
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "DnsBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(DNS_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending[DnsProxyDns] = FALSE;
        Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending[DnsProxyWins] = FALSE;
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        Error = DnsActivateInterface(Interfacep);
    }

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsBindInterface


VOID
DnsCleanupInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context.

--*/

{
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }

    while (!IsListEmpty(&Interfacep->QueryList)) {
        Link = Interfacep->QueryList.Flink;
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        DnsDeleteQuery(Interfacep, Queryp);
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // DnsCleanupInterface


VOID
DnsConnectDefaultInterface(
    PVOID Unused
    )

/*++

Routine Description:

    This routine is invoked to attempt to initiate a demand-dial connection
    on the interface marked as 'default' for DNS requests.
    If no such interface is found, no operation is performed.

Arguments:

    none used.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine is invoked from the context of an RTUTILS work item.

--*/

{
    ULONG Error;
    ULONG Index;
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    ULONG TickCount;
    ROUTER_INTERFACE_TYPE Type;

    PROFILE("DnsConnectDefaultInterface");

    //
    // To avoid repeated autodial dialogs, we record the last time
    // we attempted to connect the default interface.
    // If we did so recently, return silently.
    // N.B. If the tick-count wrapped, we reset the last-attempt counter.
    //

    EnterCriticalSection(&DnsGlobalInfoLock);
    TickCount = NtGetTickCount();
    if (TickCount > DnspLastConnectAttemptTickCount &&
        TickCount <= (DnspLastConnectAttemptTickCount + DNS_CONNECT_TIMEOUT)
        ) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }
    DnspLastConnectAttemptTickCount = TickCount;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // Look through the interface list for one which is marked as default
    //

    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (!DNS_INTERFACE_ADMIN_DEFAULT(Interfacep)) { continue; }

        //
        // We've found the default interface.
        //

        Index = Interfacep->Index;

        LeaveCriticalSection(&DnsInterfaceLock);

        //
        // Attempt to connect it.
        //

        EnterCriticalSection(&DnsGlobalInfoLock);
        Error = 
            DnsSupportFunctions.DemandDialRequest ?
            DnsSupportFunctions.DemandDialRequest(MS_IP_DNS_PROXY, Index) :
            NO_ERROR;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // No interface is marked as the default.
    //

    LeaveCriticalSection(&DnsInterfaceLock);
    NhDialSharedConnection();
    NhWarningLog(
        IP_DNS_PROXY_LOG_NO_DEFAULT_INTERFACE,
        0,
        ""
        );
    DEREFERENCE_DNS();

} // DnsConnectDefaultInterface


ULONG
DnsConfigureInterface(
    ULONG Index,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("DnsConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|DNS_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DnsActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }
    else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DnsActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
        else
        if (!(OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) &&
            (NewFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                DnsDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsConfigureInterface


ULONG
DnsCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo,
    OUT PDNS_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the DNS proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsCreateInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (DnsLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PDNS_INTERFACE>(
                    NH_ALLOCATE(sizeof(DNS_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "DnsCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DNS_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|DNS_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InitializeListHead(&Interfacep->QueryList);
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&DnsInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // DnsCreateInterface


VOID
DnsDeactivateInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'DnsInterfaceLock' held by caller.

--*/

{
    ULONG i;
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsDeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    //
    // Stop all network I/O on the interface's logical networks
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        NhDeleteDatagramSocket(
            Interfacep->BindingArray[i].Socket[DnsProxyDns]
            );
        Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
        NhDeleteDatagramSocket(
            Interfacep->BindingArray[i].Socket[DnsProxyWins]
            );
        Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
    }

    //
    // Eliminate all pending queries
    //

    while (!IsListEmpty(&Interfacep->QueryList)) {
        Link = RemoveHeadList(&Interfacep->QueryList);
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        NH_FREE(Queryp);
    }

    RELEASE_LOCK(Interfacep);

} // DnsDeactivateInterface


VOID NTAPI
DnspDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to re-issue a deferred read when the countdown
    for the deferral completes.

Arguments:

    Context - holds information identifying the interface and socket

    TimedOut - indicates whether the countdown completed

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the component on our behalf.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG Error;
    ULONG i;
    PDNS_INTERFACE Interfacep;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnspDeferReadCallbackRoutine");

    Contextp = (PDNS_DEFER_READ_CONTEXT)Context;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DNS_INTERFACE_ACTIVE(Interfacep) ||
        !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the socket on which to reissue the read
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns]
                != Contextp->Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins]
                != Contextp->Socket) {
            continue;
        }

        //
        // This is the binding on which to reissue the read.
        // If no pending timer is recorded, assume a rebind occurred, and quit.
        //

        if (!Interfacep->BindingArray[i].TimerPending[Type]) { break; }

        Interfacep->BindingArray[i].TimerPending[Type] = FALSE;

        Error =
            NhReadDatagramSocket(
                &DnsComponentReference,
                Contextp->Socket,
                NULL,
                DnsReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Address)
                );

        RELEASE_LOCK(Interfacep);

        if (!Error) {
            NH_FREE(Contextp);
            DEREFERENCE_DNS();
            return;
        }

        //
        // An error occurred; we'll have to retry later.
        // we queue a work item which sets the timer.
        //

        NhTrace(
            TRACE_FLAG_DNS,
            "DnspDeferReadCallbackRoutine: error %d reading interface %d",
            Error,
            Interfacep->Index
            );

        //
        // Reference the component on behalf of the work-item
        //

        if (REFERENCE_DNS()) {
    
            //
            // Queue a work-item, reusing the deferral context
            //
    
            status =
                RtlQueueWorkItem(
                    DnspDeferReadWorkerRoutine,
                    Contextp, 
                    WT_EXECUTEINIOTHREAD
                    );
    
            if (NT_SUCCESS(status)) {
                Contextp = NULL;
            }
            else {
                NH_FREE(Contextp);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnspDeferReadCallbackRoutine: error %d deferring %d",
                    Error,
                    Interfacep->Index
                    );
                DEREFERENCE_DNS();
            }
        }

        DNS_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DNS();
        return;
    }

    //
    // The interface was not found; never mind.
    //

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    NH_FREE(Contextp);
    DEREFERENCE_DNS();

} // DnspDeferReadCallbackRoutine


VOID
DnsDeferReadInterface(
    PDNS_INTERFACE Interfacep,
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to defer a read-request on an interface,
    typically if an attempt to post a read failed.

Arguments:

    Interfacep - the interface on which to defer the request

    Socket - the socket on which to defer the request

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnsDeferReadInterface");

    //
    // Find the binding for the given socket.
    //

    status = STATUS_SUCCESS;

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns] != Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins] != Socket) {
            continue;
        }

        //
        // This is the binding. If there is already a timer for it,
        // then just return silently.
        //

        if (Interfacep->BindingArray[i].TimerPending[Type]) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Allocate a context block for the deferral.
        //

        Contextp =
            (PDNS_DEFER_READ_CONTEXT)
                NH_ALLOCATE(sizeof(DNS_DEFER_READ_CONTEXT));

        if (!Contextp) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsDeferReadInterface: cannot allocate deferral context"
                );
            status = STATUS_NO_MEMORY;
            break;
        }

        Contextp->Index = Interfacep->Index;
        Contextp->Socket = Socket;
        Contextp->DeferralCount = 1;
    
        //
        // Install a timer to re-issue the read request
        //

        status =
            NhSetTimer(
                &DnsComponentReference,
                NULL,
                DnspDeferReadCallbackRoutine,
                Contextp,
                DNS_DEFER_READ_INITIAL_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Interfacep->BindingArray[i].TimerPending[Type] = TRUE;
        }
        else {
            NH_FREE(Contextp);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsDeferReadInterface: status %08x setting deferral timer",
                status
                );
        }

        break;
    }

    if (i >= Interfacep->BindingCount) { status = STATUS_UNSUCCESSFUL; }

} // DnsDeferReadInterface


VOID APIENTRY
DnspDeferReadWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to set a timer for reissuing a deferred read.

Arguments:

    Context - contains the context for the timer.

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the module made on our behalf.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    PDNS_INTERFACE Interfacep;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnspDeferReadWorkerRoutine");

    Contextp = (PDNS_DEFER_READ_CONTEXT)Context;
    ++Contextp->DeferralCount;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DNS_INTERFACE_ACTIVE(Interfacep) ||
        !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the binding on which to set the timer
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns]
                != Contextp->Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins]
                != Contextp->Socket) {
            continue;
        }
    
        //
        // This is the binding on which to reissue the read.
        // If a timer is already pending, assume a rebind occurred, and quit.
        //

        if (Interfacep->BindingArray[i].TimerPending[Type]) { break; }

        //
        // Install a timer to re-issue the read request,
        // reusing the deferral context.
        //

        status =
            NhSetTimer(
                &DnsComponentReference,
                NULL,
                DnspDeferReadCallbackRoutine,
                Contextp,
                DNS_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Contextp = NULL;
            Interfacep->BindingArray[i].TimerPending[Type] = TRUE;
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnspDeferReadWorkerRoutine: status %08x setting timer",
                status
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    if (Contextp) { NH_FREE(Contextp); }
    DEREFERENCE_DNS();

} // DnspDeferReadWorkerRoutine


ULONG
DnsDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsDeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    DnsDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    DnsCleanupInterface(Interfacep);

    LeaveCriticalSection(&DnsInterfaceLock);

    return NO_ERROR;

} // DnsDeleteInterface


ULONG
DnsDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!DNS_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (DNS_INTERFACE_BOUND(Interfacep)) {
        DnsDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsDisableInterface


ULONG
DnsEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (DNS_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        Error = DnsActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsEnableInterface


ULONG
DnsInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsInitializeInterfaceManagement");

    InitializeListHead(&DnsInterfaceList);
    __try {
        InitializeCriticalSection(&DnsInterfaceLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DnsInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    DnspLastConnectAttemptTickCount = NtGetTickCount();

    return Error;

} // DnsInitializeInterfaceManagement


PDNS_INTERFACE
DnsLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PDNS_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'DnsInterfaceLock'
    held by caller.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsLookupInterface");

    if (InsertionPoint) 
    {
        *InsertionPoint = NULL;
    }

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (Index > Interfacep->Index) { continue; }
        else
        if (Index < Interfacep->Index) { break; }
        
        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // DnsLookupInterface


ULONG
DnsQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!DNS_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_DNS_PROXY_INTERFACE_INFO)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_DNS_PROXY_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (!InterfaceInfo) {
        LeaveCriticalSection(&DnsInterfaceLock);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_DNS_PROXY_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_DNS_PROXY_INTERFACE_INFO);

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsQueryInterface


VOID
DnsReactivateEveryInterface(
    VOID
    )

/*++

Routine Description:

    This routine is called to reactivate all activate interfaces
    when a change occurs to the global DNS or WINS proxy setting.
    Thus if, for instance, WINS proxy is disabled, during deactivation
    all such sockets are closed, and during reactivation they are
    not reopened.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from a router-manager thread with no locks held.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsReactivateEveryInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }

        if (DNS_INTERFACE_ACTIVE(Interfacep)) {
            DnsDeactivateInterface(Interfacep);
            DnsActivateInterface(Interfacep);
        }

        DNS_DEREFERENCE_INTERFACE(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

} // DnsReactivateEveryInterface


ULONG NTAPI
DnspSaveFileWorkerRoutine(
    PVOID Context
    )
{
    //
    // Context unused
    //
    
    PROFILE("DnspSaveFileWorkerRoutine");

    SaveHostsIcsFile(FALSE);

    DEREFERENCE_DNS();
    return NO_ERROR;
} // DnspSaveFileWorkerRoutine


VOID
DnsShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsShutdownInterfaceManagement");

    while (!IsListEmpty(&DnsInterfaceList)) {
        Link = RemoveHeadList(&DnsInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);
        if (DNS_INTERFACE_ACTIVE(Interfacep)) {
            DnsDeactivateInterface(Interfacep);
        }
        DnsCleanupInterface(Interfacep);
    }

    DeleteCriticalSection(&DnsInterfaceLock);

} // DnsShutdownInterfaceManagement


VOID
DnsSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the DNS proxy
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsSignalNatInterface");

    EnterCriticalSection(&DnsGlobalInfoLock);
    if (!DnsGlobalInfo) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);
    EnterCriticalSection(&DnsInterfaceLock);
    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        return;
    }
    DnsDeactivateInterface(Interfacep);
    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        DnsActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&DnsInterfaceLock);

} // DnsSignalNatInterface


ULONG
DnsUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!DNS_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (DNS_INTERFACE_ENABLED(Interfacep)) {
        DnsDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    if (Interfacep->BindingArray)
    {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    DNS_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // DnsUnbindInterface


ULONG
DnsGetPrivateInterfaceAddress(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to return the IP address on which DNS
    has been enabled.

Arguments:

    none.

Return Value:

    Bound IP address if an address is found (else 0).

Environment:

    Invoked from an arbitrary context.
    
--*/
{
    PROFILE("DnsGetPrivateInterfaceAddress");

    ULONG   ipAddr = 0;
    ULONG   ulRet  = NO_ERROR;

    //
    // Find out the first available interface on which we are enabled and
    // return the primary IP address to which we are bound.
    //

    PDNS_INTERFACE Interfacep = NULL;
    PLIST_ENTRY    Link;
    ULONG          i;
    BOOLEAN        IsNatInterface;
   
    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         )
    {
        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        ACQUIRE_LOCK(Interfacep);
        
        if (DnsInterfacePrivate != Interfacep->DnsInterfaceType)
        {
            RELEASE_LOCK(Interfacep);
            continue;
        }
        
        for (i = 0; i < Interfacep->BindingCount; i++)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsGetPrivateInterfaceAddress: IP address %s (Index %d)",
                INET_NTOA(Interfacep->BindingArray[i].Address),
                Interfacep->Index
                );
                
            if (Interfacep->BindingArray[i].Address &
                Interfacep->BindingArray[i].Mask)
            {
                ipAddr = Interfacep->BindingArray[i].Address;
                break;
            }
        }
        
        RELEASE_LOCK(Interfacep);

        if (ipAddr)
        {
            LeaveCriticalSection(&DnsInterfaceLock);

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsGetPrivateInterfaceAddress: Dns private interface IP address %s (Index %d)",
                INET_NTOA(ipAddr),
                Interfacep->Index
                );
            
            return ipAddr;
        }
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    return ipAddr;
} // DnsGetPrivateInterfaceAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsfile.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dnsfile.c

Abstract:

    This module contains code for the Simple DNS Server (formerly the DNS Proxy)
    to operate on the Hosts.ics file. Abridged from the DS tree.

Author:

    Raghu Gatta (rgatta)   15-Nov-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// EXTERNAL DECLARATIONS
//

extern "C"
FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    );


//
// Locking Order:
//      (1) DnsFileInfo.Lock
//      (2) DnsTableLock
// OR
//      (1) DnsGlobalInfoLock
//      (2) DnsTableLock



//
// Globals
//

IP_DNS_PROXY_FILE_INFO DnsFileInfo;


ULONG
DnsInitializeFileManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the file management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsInitializeFileManagement");

    ZeroMemory(&DnsFileInfo, sizeof(IP_DNS_PROXY_FILE_INFO));

    __try {
        InitializeCriticalSection(&DnsFileInfo.Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DnsInitializeFileManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // DnsInitializeFileManagement



VOID
DnsShutdownFileManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the file management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/

{
    PROFILE("DnsShutdownFileManagement");

    DnsEndHostsIcsFile();

    DeleteCriticalSection(&DnsFileInfo.Lock);

} // DnsShutdownFileManagement



BOOL
DnsEndHostsIcsFile(
    VOID
    )
/*++

Routine Description:

    Close hosts file.

Arguments:

    None.

Globals:

    DnsFileInfo.HostFile -- host file ptr, tested and cleared

Return Value:

    None.

--*/
{
    if (DnsFileInfo.HostFile)
    {
        fclose(DnsFileInfo.HostFile);
        DnsFileInfo.HostFile = NULL;
    }

    return TRUE;
} // DnsEndHostsIcsFile



BOOL
DnsSetHostsIcsFile(
    BOOL fOverwrite
    )
/*++

Routine Description:

    Open hosts.ics file. If we write, we overwrite, else we read

Arguments:

    None.

Globals:

    DnsFileInfo.HostFile -- host file ptr, tested and set

Return Value:

    None.

--*/
{
    LPVOID lpMsgBuf;
    UINT   len;
    WCHAR  hostDirectory[MAX_PATH*2];
    PCHAR  mode = fOverwrite ? "w+t" : "rt";
    

    DnsEndHostsIcsFile();

    //
    // reset the host file name to hosts.ics
    //
    ZeroMemory(DnsFileInfo.HostFileName, HOSTDB_SIZE);

    DnsFileInfo.HostFile = SockOpenNetworkDataBase(
                               HOSTSICSFILE,
                               DnsFileInfo.HostFileName,
                               HOSTDB_SIZE,
                               mode
                               );
                     
    if(DnsFileInfo.HostFile == NULL)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSetHostsIcsFile: Unable to open %s file",
            HOSTSICSFILE
            );
            
        return FALSE;
    }
    else
    {
        /*
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSetHostsIcsFile: Successfully opened %s file",
            DnsFileInfo.HostFileName
            );
        */
    }

    return TRUE;
} // DnsSetHostsIcsFile



BOOL
GetHostFromHostsIcsFile(
    BOOL fStartup
    )
/*++

Routine Description:

    Reads an entry from hosts.ics file.

Arguments:

    fStartup set to TRUE if called on startup of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is set
    DnsFileInfo.Ip4Address    -- IP4 address is set


Return Value:

    TRUE if we were able to successfully able to read a line.
    FALSE if on EOF or no hosts file found.

--*/
{
    char *p, *ep;
    register char *cp, **q;

    //
    // we assume the hosts.ics file has already been opened
    //

    if (DnsFileInfo.HostFile == NULL)
    {
        return FALSE;
    }

    DnsFileInfo.HostLineBuf[BUFSIZ] = NULL;
    DnsFileInfo.pHostName  = NULL;
    DnsFileInfo.Ip4Address = 0;
    ZeroMemory(&DnsFileInfo.HostTime, sizeof(SYSTEMTIME));

    //
    // loop until successfully read IP address
    // IP address starts on column 1 
    //

    while( 1 )
    {
        // quit on EOF

        if ((p = fgets(DnsFileInfo.HostLineBuf, BUFSIZ, DnsFileInfo.HostFile)) == NULL)
        {
            if (!feof(DnsFileInfo.HostFile))
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "GetHostFromHostsIcsFile: Error reading line"
                    );
            }
            return FALSE;
        }

        // comment line -- skip

        if (*p == '#')
        {
            p++;

            //
            // if in startup mode, we skip first comment sign;
            // if there are more comment signs -- skip
            //
            if ((fStartup && *p == '#') || !fStartup)
            {
                continue;
            }
        }

        // null address terminate at EOL

        cp = strpbrk(p, "\n");
        if (cp != NULL)
        {
            *cp = '\0';
        }

        // whole line is characters - no whitespace -- skip

        cp = strpbrk(p, " \t");
        if ( cp == NULL )
        {
            continue;
        }

        // NULL terminate address string

        *cp++ = '\0';

        //
        // read address
        //  - try IP4
        //  - ignore IP6 for now
        //  - otherwise skip
        //
    
        DnsFileInfo.Ip4Address = inet_addr(p);

        if (DnsFileInfo.Ip4Address != INADDR_NONE ||
            _strnicmp("255.255.255.255", p, 15) == 0)
        {
            break;
        }

        // invalid address, ignore line

        //
        // debug tracing
        //
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host file address %s",
            p
            );
            
        continue;
    }

    // find the end of the string which was read
    
    ep = cp;
    while( *ep ) ep++;

    //
    // find name
    //  - skip leading whitespace
    //  - set global name ptr
    //
    
    while( *cp == ' ' || *cp == '\t' ) cp++;
    DnsFileInfo.pHostName = cp;

    // stop at trailing whitespace, NULL terminate

    cp = strpbrk(cp, " \t");
    if ( cp != NULL )
    {
        *cp++ = '\0';
    }
    else
    {
        // we have a name - but no timestamp
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp",
            DnsFileInfo.pHostName
            );
        goto Failed;
    }

    // we dont have any support for aliases

    //
    // find the timestamp
    //  - skip leading whitespace
    //  - read the time values
    //
    while( *cp == ' ' || *cp == '\t' ) cp++;

    if ((cp >= ep) || (*cp != '#'))
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp",
            DnsFileInfo.pHostName
            );
        goto Failed;
    }
    
    cp++;

    while( *cp == ' ' || *cp == '\t' ) cp++;    // now at first system time value
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 1",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wYear         = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;
    
    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 2",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMonth        = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 3",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wDayOfWeek    = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 4",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wDay          = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 5",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wHour         = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 6",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMinute       = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 7",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wSecond       = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == '\0'))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 8",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMilliseconds = (WORD) atoi(cp);

    //
    // successful entry read
    //
    /*
    NhTrace(
        TRACE_FLAG_DNS,
        "%s (%s) has timestamp: %04u-%02u-%02u %02u:%02u:%02u",
        DnsFileInfo.pHostName,
        inet_ntoa(*(PIN_ADDR)&DnsFileInfo.Ip4Address),
        DnsFileInfo.HostTime.wYear,
        DnsFileInfo.HostTime.wMonth,
        DnsFileInfo.HostTime.wDay,
        DnsFileInfo.HostTime.wHour,
        DnsFileInfo.HostTime.wMinute,
        DnsFileInfo.HostTime.wSecond
        );
    */
    return TRUE;

Failed:

    // reset entries
    
    DnsFileInfo.HostLineBuf[0] = NULL;
    DnsFileInfo.pHostName  = NULL;
    DnsFileInfo.Ip4Address = 0;
    ZeroMemory(&DnsFileInfo.HostTime, sizeof(SYSTEMTIME));

    return TRUE;
    
} // GetHostFromHostsIcsFile



VOID
LoadHostsIcsFile(
    BOOL fStartup
    )
/*++

Routine Description:

    Read hosts file into our local cache.

Arguments:

    fStartup set to TRUE if called on startup of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set then cleared
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is read
    DnsFileInfo.Ip4Address    -- IP4 address is read

Return Value:

    None.

--*/
{
    register PCHAR * cp;
    FILETIME ftExpires;
    PWCHAR pszName;
    LPVOID lpMsgBuf;

    NhTrace(
        TRACE_FLAG_DNS,
        "LoadHostsIcsFile: Entering..."
        );

    ACQUIRE_LOCK(&DnsFileInfo);

    //
    //  read entries from host file until exhausted
    //

    DnsSetHostsIcsFile(FALSE);  // read only

    while (GetHostFromHostsIcsFile(fStartup))
    {
        if (DnsFileInfo.pHostName)
        {
            if (!SystemTimeToFileTime(&DnsFileInfo.HostTime, &ftExpires))
            {
                DWORD dwLastError = GetLastError();
                
                NhTrace(
                    TRACE_FLAG_DNS,
                    "LoadHostsIcsFile: SystemTimeToFileTime() failed"
                    );

                lpMsgBuf = NULL;
                
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwLastError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                    );
                    
                NhTrace(
                    TRACE_FLAG_DNS,
                    "LoadHostsIcsFile: with message (0x%08x) %S",
                    dwLastError,
                    lpMsgBuf
                    );
                
                if (lpMsgBuf) LocalFree(lpMsgBuf);

                // skip entry
                continue;
            }

            pszName = (PWCHAR) NH_ALLOCATE((strlen(DnsFileInfo.pHostName) + 1) * sizeof(WCHAR));

            mbstowcs(pszName, DnsFileInfo.pHostName, (strlen(DnsFileInfo.pHostName) + 1));

            NhTrace(
                TRACE_FLAG_DNS,
                "%S (%s) has timestamp: %04u-%02u-%02u %02u:%02u:%02u",
                pszName,
                inet_ntoa(*(PIN_ADDR)&DnsFileInfo.Ip4Address),
                DnsFileInfo.HostTime.wYear,
                DnsFileInfo.HostTime.wMonth,
                DnsFileInfo.HostTime.wDay,
                DnsFileInfo.HostTime.wHour,
                DnsFileInfo.HostTime.wMinute,
                DnsFileInfo.HostTime.wSecond
                );

            DnsAddAddressForName(
                pszName,
                DnsFileInfo.Ip4Address,
                ftExpires
                );

            NH_FREE(pszName);
        }

    }

    DnsEndHostsIcsFile();

    RELEASE_LOCK(&DnsFileInfo);

    //
    // now that we have everything in our table format,
    // write back a clean version to disk
    //
    SaveHostsIcsFile(FALSE);

    NhTrace(
        TRACE_FLAG_DNS,
        "LoadHostsIcsFile: ...Leaving."
        );

} // LoadHostsIcsFile



VOID
SaveHostsIcsFile(
    BOOL fShutdown
    )
/*++

Routine Description:

    Write hosts file from our local cache.

Arguments:

    fShutdown set to TRUE if called on shutdown of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set then cleared
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is read
    DnsFileInfo.Ip4Address    -- IP4 address is read

Return Value:

    None.

--*/
{
    //DWORD       dwSize = 0;
    //PWCHAR      pszSuffix = NULL;
    UINT        i;
    SYSTEMTIME  stTime;
    LPVOID      lpMsgBuf;
    
    NhTrace(
        TRACE_FLAG_DNS,
        "SaveHostsIcsFile: Entering..."
        );

    //
    // adding ourself as a special case
    //
    DnsAddSelf();

    //
    // get a copy of current ICS Domain suffix (used later on)
    // we dont play with it directly from the global copy
    // due to locking problems
    //
    /*
    EnterCriticalSection(&DnsGlobalInfoLock);

    if (DnsICSDomainSuffix)
    {
        dwSize = wcslen(DnsICSDomainSuffix) + 1;

        pszSuffix = reinterpret_cast<PWCHAR>(
                        NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                        );
        if (!pszSuffix)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "SaveHostsIcsFile: allocation failed for "
                "DnsICSDomainSuffix copy"
                );
        }
        else
        {
            wcscpy(pszSuffix, DnsICSDomainSuffix);
        }
    }
    
    LeaveCriticalSection(&DnsGlobalInfoLock);
    */

    ACQUIRE_LOCK(&DnsFileInfo);

    //
    // write entries into host file
    //

    DnsSetHostsIcsFile(TRUE);  // overwrite existing file if any

    if (DnsFileInfo.HostFile != NULL)
    {
        //
        // write default header string
        //
        if (fShutdown)
        {
            // add extra # at front
            fputc('#', DnsFileInfo.HostFile);
            
        }
        fputs(HOSTSICSFILE_HEADER, DnsFileInfo.HostFile);

        PDNS_ENTRY pDnsEntry;

        EnterCriticalSection(&DnsTableLock);

        pDnsEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, TRUE);

        while (pDnsEntry != NULL)
        {

            for (i = 0; i < pDnsEntry->cAddresses; i++)
            {
                //
                // dont add entries with invalid suffixes
                // (this could happen for example because the suffix
                //  was changed in the registry)
                //
                //if (!IsSuffixValid(pDnsEntry->pszName, pszSuffix))
                //{
                //    continue;
                //}
                
                //
                // dont add expired entries to the hosts.ics file
                //
                if (IsFileTimeExpired(&pDnsEntry->aAddressInfo[i].ftExpires))
                {
                    continue;
                }

                if (!FileTimeToSystemTime(
                         &pDnsEntry->aAddressInfo[i].ftExpires,
                         &stTime))
                {
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "SaveHostsIcsFile: FileTimeToSystemTime() failed"
                        );

                    lpMsgBuf = NULL;
                    
                    FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                        );
                        
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "SaveHostsIcsFile: with message %S",
                        lpMsgBuf
                        );
                    
                    if (lpMsgBuf) LocalFree(lpMsgBuf);

                    // skip entry
                    continue;
                }

                if (fShutdown)
                {
                    // add extra # at front
                    fputc('#', DnsFileInfo.HostFile);
                    
                }
                
                fprintf(
                    DnsFileInfo.HostFile,
                    "%s %S # %u %u %u %u %u %u %u %u\n",
                    inet_ntoa(*(PIN_ADDR)&pDnsEntry->aAddressInfo[i].ulAddress),
                    pDnsEntry->pszName,
                    stTime.wYear,
                    stTime.wMonth,
                    stTime.wDayOfWeek,
                    stTime.wDay,
                    stTime.wHour,
                    stTime.wMinute,
                    stTime.wSecond,
                    stTime.wMilliseconds
                    );

                NhTrace(
                    TRACE_FLAG_DNS,
                    "adding entry: %s %S # %u %u %u %u %u %u %u %u\n",
                    inet_ntoa(*(PIN_ADDR)&pDnsEntry->aAddressInfo[i].ulAddress),
                    pDnsEntry->pszName,
                    stTime.wYear,
                    stTime.wMonth,
                    stTime.wDayOfWeek,
                    stTime.wDay,
                    stTime.wHour,
                    stTime.wMinute,
                    stTime.wSecond,
                    stTime.wMilliseconds
                    );
            }

            pDnsEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, FALSE);

        }

        LeaveCriticalSection(&DnsTableLock);
    }

    DnsEndHostsIcsFile();

    RELEASE_LOCK(&DnsFileInfo);

    /*
    if (pszSuffix)
    {
        NH_FREE(pszSuffix);
        pszSuffix = NULL;
    }
    */

    NhTrace(
        TRACE_FLAG_DNS,
        "SaveHostsIcsFile: ...Leaving."
        );

} // SaveHostsIcsFile



BOOL
IsFileTimeExpired(
    FILETIME *ftTime
    )
{
    ULARGE_INTEGER  uliTime, uliNow;
    FILETIME        ftNow;

    GetSystemTimeAsFileTime(&ftNow);
    memcpy(&uliNow, &ftNow, sizeof(ULARGE_INTEGER));
    memcpy(&uliTime, ftTime, sizeof(ULARGE_INTEGER));

    return (uliTime.QuadPart < uliNow.QuadPart);
} // IsFileTimeExpired
    


BOOL
IsSuffixValid(
    WCHAR *pszName,
    WCHAR *pszSuffix
    )

/*++

Routine Description:

    This routine is invoked to compare suffix on the end of the name
    with what the DNS component thinks of as the current suffix.

Arguments:

    none.

Return Value:

    TRUE or FALSE.

Environment:

    Invoked in an arbitrary context.

--*/

{
    BOOL ret;
    PWCHAR start = pszName;
    size_t lenName   = 0,
           lenSuffix = 0;

    if (!start)
    {
        return FALSE;
    }

    lenName   = wcslen(pszName);
    lenSuffix = wcslen(pszSuffix);

    if (!lenName || !lenSuffix)
    {
        return FALSE;
    }

    if (lenName < lenSuffix)
    {
        return FALSE;
    }

    lenName -= lenSuffix;

    while (lenName--) start++;

    ret = _wcsicmp(start, pszSuffix);

    return (!ret);
} // IsSuffixValid
    


//
//  End dnsfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsif.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsif.h

Abstract:

    This module contains declarations for the DNS proxy's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:
    
--*/

#ifndef _NATHLP_DNSIF_H_
#define _NATHLP_DNSIF_H_

//
// Enumeration: DNS_PROXY_TYPE
//

typedef enum {
    DnsProxyDns = 0,
    DnsProxyWins,
    DnsProxyCount
} DNS_PROXY_TYPE;

#define DNS_PROXY_TYPE_TO_PORT(t) \
    (USHORT)(((t) == DnsProxyDns) ? DNS_PORT_SERVER : WINS_PORT_SERVER)

#define DNS_PROXY_PORT_TO_TYPE(p) \
    (DNS_PROXY_TYPE)(((p) == DNS_PORT_SERVER) ? DnsProxyDns : DnsProxyWins)


//
// Enumeration: DNS_INTERFACE_TYPE
// 4 Types of Interfaces possible:
//      (1) Private
//      (2) Boundary
//      (3) Firewalled
//      (4) Boundary + Firewalled
// DNS should be active only on the Private Interface
// (A Public interface is simply a non-Private interface.)
//

typedef enum {
    DnsInterfaceInvalid,
    DnsInterfacePrivate,
    DnsInterfaceBoundary,
    DnsInterfaceFirewalled,
    DnsInterfaceBoundaryFirewalled
} DNS_INTERFACE_TYPE;


//
// Structure:   DNS_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
// The 'TimerPending' field is set when a receive-attempt fails on an interface
// and a timer is queued to reattempt the receive later.
//

typedef struct _DNS_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET Socket[DnsProxyCount];
    BOOLEAN TimerPending[DnsProxyCount];
} DNS_BINDING, *PDNS_BINDING;


//
// Structure:   DNS_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of DNS interfaces,
// sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('DnsInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _DNS_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    NET_INTERFACE_TYPE Type; // read-only
    DNS_INTERFACE_TYPE DnsInterfaceType;
    IP_DNS_PROXY_INTERFACE_INFO Info;
    ULONG Flags;
    ULONG BindingCount;
    PDNS_BINDING BindingArray;
    LIST_ENTRY QueryList;
} DNS_INTERFACE, *PDNS_INTERFACE;

//
// Flags
//

#define DNS_INTERFACE_FLAG_DELETED      0x80000000
#define DNS_INTERFACE_DELETED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_DELETED)

#define DNS_INTERFACE_FLAG_BOUND        0x40000000
#define DNS_INTERFACE_BOUND(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_BOUND)

#define DNS_INTERFACE_FLAG_ENABLED      0x20000000
#define DNS_INTERFACE_ENABLED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_ENABLED)

#define DNS_INTERFACE_FLAG_CONFIGURED   0x10000000
#define DNS_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_CONFIGURED)

#define DNS_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (DNS_INTERFACE_FLAG_BOUND|DNS_INTERFACE_FLAG_ENABLED)) \
        == (DNS_INTERFACE_FLAG_BOUND|DNS_INTERFACE_FLAG_ENABLED))

#define DNS_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)

#define DNS_INTERFACE_ADMIN_DEFAULT(i) \
    ((i)->Flags & IP_DNS_PROXY_INTERFACE_FLAG_DEFAULT)

//
// Synchronization
//

#define DNS_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, DNS_INTERFACE_DELETED)

#define DNS_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, DnsCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY DnsInterfaceList;
extern CRITICAL_SECTION DnsInterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
DnsActivateInterface(
    PDNS_INTERFACE Interfacep
    );

ULONG
DnsBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
DnsCleanupInterface(
    PDNS_INTERFACE Interfacep
    );

VOID APIENTRY
DnsConnectDefaultInterface(
    PVOID Unused
    );

ULONG
DnsConfigureInterface(
    ULONG Index,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo
    );

ULONG
DnsCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo,
    PDNS_INTERFACE* InterfaceCreated
    );

VOID
DnsDeactivateInterface(
    PDNS_INTERFACE Interfacep
    );

VOID
DnsDeferReadInterface(
    PDNS_INTERFACE Interfacep,
    SOCKET Socket
    );

ULONG
DnsDeleteInterface(
    ULONG Index
    );

ULONG
DnsDisableInterface(
    ULONG Index
    );

ULONG
DnsEnableInterface(
    ULONG Index
    );

ULONG
DnsInitializeInterfaceManagement(
    VOID
    );

PDNS_INTERFACE
DnsLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
DnsQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
DnsReactivateEveryInterface(
    VOID
    );

VOID
DnsShutdownInterfaceManagement(
    VOID
    );

VOID
DnsSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
DnsUnbindInterface(
    ULONG Index
    );

ULONG
DnsGetPrivateInterfaceAddress(
    VOID
    );

#endif // _NATHLP_DNSIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dll\rmapi.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmapi.c

Abstract:

    This module contains code for the part of the router-manager interface
    which is common to all the protocols in this component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <ipinfo.h>
#include "beacon.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include "nathlp_i.c"

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_SAUpdate, CSharedAccessUpdate)
END_OBJECT_MAP()


extern "C" {
#include <iphlpstk.h>
}

HANDLE NhpComponentEvent = NULL;
NH_COMPONENT_MODE NhComponentMode = NhUninitializedMode;
const WCHAR NhpDhcpDomainString[] = L"DhcpDomain";
const WCHAR NhpDomainString[] = L"Domain";
BOOLEAN NhpDllProcessAttachSucceeded;
const WCHAR NhpEnableProxy[] = L"EnableProxy";
const WCHAR NhpICSDomainString[] = L"ICSDomain";
LONG NhpIsWinsProxyEnabled = -1;
CRITICAL_SECTION NhLock;
HMODULE NhpRtrmgrDll = NULL;
LIST_ENTRY NhApplicationSettingsList;
LIST_ENTRY NhDhcpReservationList;
DWORD NhDhcpScopeAddress = 0;
DWORD NhDhcpScopeMask = 0;
HANDLE NhFileHandle = INVALID_HANDLE_VALUE;
const WCHAR NhTcpipParametersString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters";

//
// EXTERNAL DECLARATIONS
//

BOOL
APIENTRY
DllMain(
    HINSTANCE Instance,
    ULONG Reason,
    PVOID Unused
    )

/*++

Routine Description:

    Standard DLL entry/exit routine.
    Initializes/shuts-down the modules implemented in the DLL.
    The initialization performed is sufficient that all the modules'
    interface lists can be searched, whether or not the protocols are
    installed or operational.

Arguments:

    Instance - the instance of this DLL in this process

    Reason - the reason for invocation

    Unused - unused.

Return Value:

    BOOL - indicates success or failure.

--*/

{
    switch (Reason) {
        case DLL_PROCESS_ATTACH: {
            WSADATA wd;
            NhpDllProcessAttachSucceeded = FALSE;
            DisableThreadLibraryCalls(Instance);
            __try {
                InitializeCriticalSection(&NhLock);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }


            WSAStartup(MAKEWORD(2,2), &wd);
            NhInitializeTraceManagement();
            if (!NhInitializeEventLogManagement()) {return FALSE; }
            InitializeListHead(&NhApplicationSettingsList);
            InitializeListHead(&NhDhcpReservationList);
            if (NhInitializeBufferManagement()) { return FALSE; }
            if (NhInitializeTimerManagement()) { return FALSE; }
            if (!NatInitializeModule()) { return FALSE; }
            if (!DhcpInitializeModule()) { return FALSE; }
            if (!DnsInitializeModule()) { return FALSE; }
            if (!AlgInitializeModule()) { return FALSE; }
            if (!H323InitializeModule()) { return FALSE; }
            if(FAILED(InitializeBeaconSvr())) { return FALSE; }

            _Module.Init(ObjectMap, Instance, &LIBID_IPNATHelperLib);
            _Module.RegisterTypeLib();
            NhpDllProcessAttachSucceeded = TRUE;
            break;
        }
        case DLL_PROCESS_DETACH: {
            if (TRUE == NhpDllProcessAttachSucceeded) {
                NhResetComponentMode();
                TerminateBeaconSvr();
                H323CleanupModule();
                AlgCleanupModule();
                DnsCleanupModule();
                DhcpCleanupModule();
                NatCleanupModule();
                NhShutdownTimerManagement();
                NhShutdownBufferManagement();
                NhShutdownEventLogManagement();
                NhShutdownTraceManagement();
                WSACleanup();
                if (NhpRtrmgrDll) {
                    FreeLibrary(NhpRtrmgrDll); NhpRtrmgrDll = NULL;
                }
                DeleteCriticalSection(&NhLock);

                _Module.Term();
            }

            break;
        }
    }

    return TRUE;

} // DllMain


VOID
NhBuildDhcpReservations(
    VOID
    )

/*++

Routine Description:

    Builds the list of DHCP reservations

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held on a COM-initialized thread.

--*/

{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr = NULL;
    IEnumHNetPortMappingBindings *pEnumBindings;
    IHNetIcsSettings *pIcsSettings;
    PNAT_DHCP_RESERVATION pReservation;
    ULONG ulCount;

    hr = NhGetHNetCfgMgr(&pCfgMgr);
    
    if (SUCCEEDED(hr))
    {
        //
        // Get the ICS settings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings)
                );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get DHCP scope information
        //

        hr = pIcsSettings->GetDhcpScopeSettings(
                &NhDhcpScopeAddress,
                &NhDhcpScopeMask
                );
        
        //
        // Get enumeration of DHCP reservered addresses
        //

        if (SUCCEEDED(hr))
        {
            hr = pIcsSettings->EnumDhcpReservedAddresses(&pEnumBindings);
        }
        
        pIcsSettings->Release();
    }

    if (SUCCEEDED(hr))
    {   
        //
        // Process the items in the enum
        //
        
        do
        {    
            IHNetPortMappingBinding *pBinding;
            
            hr = pEnumBindings->Next(1, &pBinding, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Allocate a new reservation entry
                //

                pReservation = reinterpret_cast<PNAT_DHCP_RESERVATION>(
                                    NH_ALLOCATE(sizeof(*pReservation))
                                    );

                if (NULL != pReservation)
                {
                    ZeroMemory(pReservation, sizeof(*pReservation));

                    //
                    // Get computer name
                    //

                    hr = pBinding->GetTargetComputerName(
                            &pReservation->Name
                            );

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get reserved address
                        //

                        hr = pBinding->GetTargetComputerAddress(
                                &pReservation->Address
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add entry to list
                        //

                        InsertTailList(
                            &NhDhcpReservationList,
                            &pReservation->Link)
                            ;
                    }
                    else
                    {
                        //
                        // Free entry
                        //

                        NH_FREE(pReservation);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pBinding->Release();
            }
        } while (SUCCEEDED(hr) && 1 == ulCount);

        pEnumBindings->Release();
    }

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }
} // NhBuildDhcpReservations


ULONG
NhDialSharedConnection(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to connect a home-router interface.
    The connection is established by invoking the RAS autodial process
    with the appropriate phonebook and entry-name in the security context
    of the logged-on user.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    return RasAutoDialSharedConnection();
} // NhDialSharedConnection


VOID
NhFreeApplicationSettings(
    VOID
    )

/*++

Routine Description:

    Frees the list of application settings

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held.

--*/

{
    PLIST_ENTRY Link;
    PNAT_APP_ENTRY pAppEntry;

    PROFILE("NhFreeApplicationSettings");
    
    while (!IsListEmpty(&NhApplicationSettingsList))
    {
        Link = RemoveHeadList(&NhApplicationSettingsList);
        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);

        CoTaskMemFree(pAppEntry->ResponseArray);
        NH_FREE(pAppEntry);
    }
} // NhFreeApplicationSettings


VOID
NhFreeDhcpReservations(
    VOID
    )

/*++

Routine Description:

    Frees the list of DHCP reservations

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held.

--*/

{
    PLIST_ENTRY Link;
    PNAT_DHCP_RESERVATION pReservation;

    PROFILE("NhFreeDhcpReservations");
    
    while (!IsListEmpty(&NhDhcpReservationList))
    {
        Link = RemoveHeadList(&NhDhcpReservationList);
        pReservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);

        CoTaskMemFree(pReservation->Name);
        NH_FREE(pReservation);
    }
} // NhFreeDhcpReservations


BOOLEAN
NhIsDnsProxyEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to discover whether the DNS proxy is enabled.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if DNS proxy is enabled, FALSE otherwise

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhIsDnsProxyEnabled");

    return DnsIsDnsEnabled();

} // NhIsDnsProxyEnabled


BOOLEAN
NhIsLocalAddress(
    ULONG Address
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given IP address
    is for a local interface.

Arguments:

    Address - the IP address to find

Return Value:

    BOOLEAN - TRUE if the address is found, FALSE otherwise

--*/

{
    ULONG Error;
    ULONG i;
    PMIB_IPADDRTABLE Table;

    Error =
        AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "NhIsLocalAddress: GetIpAddrTableFromStack=%d", Error
            );
        return FALSE;
    }
    for (i = 0; i < Table->dwNumEntries; i++) {
        if (Table->table[i].dwAddr == Address) {
            HeapFree(GetProcessHeap(), 0, Table);
            return TRUE;
        }
    }
    HeapFree(GetProcessHeap(), 0, Table);
    return FALSE;

} // NhIsLocalAddress


BOOLEAN
NhIsWinsProxyEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to discover whether the WINS proxy is enabled.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if WINS proxy is enabled, FALSE otherwise

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhIsWinsProxyEnabled");

    return DnsIsWinsEnabled();

} // NhIsWinsProxyEnabled


PIP_ADAPTER_BINDING_INFO
NhQueryBindingInformation(
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is called to obtain the binding information
    for the adapter with the given index.
    It does this by obtaining a table of IP addresses from the stack,
    and determining which addresses correspond to the given index.

Arguments:

    AdapterIndex - the adapter for which binding information is required

Return Value:

    PIP_ADAPTER_BINDING_INFO - the allocated binding information

--*/

{
    PIP_ADAPTER_BINDING_INFO BindingInfo = NULL;
    ULONG Count = 0;
    ULONG i;
    PMIB_IPADDRTABLE Table;
    if (AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            ) == NO_ERROR) {
        //
        // Count the adapter's addresses
        //
        for (i = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwIndex == AdapterIndex) { ++Count; }
        }
        //
        // Allocate space for the binding info
        //
        BindingInfo = reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
                        NH_ALLOCATE(SIZEOF_IP_BINDING(Count))
                        );
        if (BindingInfo) {
            //
            // Fill in the binding info
            //
            BindingInfo->AddressCount = Count;
            BindingInfo->RemoteAddress = 0;
            Count = 0;
            for (i = 0; i < Table->dwNumEntries; i++) {
                if (Table->table[i].dwIndex != AdapterIndex) { continue; }
                BindingInfo->Address[Count].Address = Table->table[i].dwAddr;
                BindingInfo->Address[Count].Mask = Table->table[i].dwMask;
                ++Count;
            }
        }
        HeapFree(GetProcessHeap(), 0, Table);
    }
    return BindingInfo;
} // NhQueryBindingInformation


NTSTATUS
NhQueryDomainName(
    PCHAR* DomainName
    )

/*++

Routine Description:

    This routine is invoked to obtain the local domain name.

Arguments:

    DomainName - receives the allocated string containing the domain name

Return Value:

    NTSTATUS - NT status code.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    IO_STATUS_BLOCK IoStatus;
    HANDLE Key;
    ULONG Length;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("NhQueryDomainName");

    *DomainName = NULL;

    RtlInitUnicodeString(&UnicodeString, NhTcpipParametersString);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the 'Tcpip' registry key
    //

    status =
        NtOpenKey(
            &Key,
            KEY_ALL_ACCESS,
            &ObjectAttributes
            );

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error %x opening registry key",
            status
            );
        return status;
    }

    //
    // Read the 'Domain' value
    //

    status =
        NhQueryValueKey(
            Key,
            NhpDomainString,
            &Information
            );

    if (!NT_SUCCESS(status)) {
        status =
            NhQueryValueKey(
                Key,
                NhpDhcpDomainString,
                &Information
                );
    }

    NtClose(Key);

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error %x querying domain name",
            status
            );
        return status;
    }

    if (REG_SZ != Information->Type
        || L'\0' != *(PWCHAR) (Information->Data +
                                (Information->DataLength - sizeof(WCHAR)))) {

        NH_FREE(Information);
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: Registry contains invalid data"
            );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Copy the domain name
    //

    Length = lstrlenW((PWCHAR)Information->Data) + 1;

    *DomainName = reinterpret_cast<PCHAR>(NH_ALLOCATE(Length));

    if (!*DomainName) {
        NH_FREE(Information);
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error allocating domain name"
            );
        return STATUS_NO_MEMORY;
    }

    status = 
        RtlUnicodeToMultiByteN(
            *DomainName,
            Length,
            NULL,
            (PWCHAR)Information->Data,
            Length * sizeof(WCHAR)
            );

    NH_FREE(Information);

    return status;

} // NhQueryDomainName


ULONG
NhQueryHostByName(
    PWCHAR pszHostName,
    PWCHAR pszDomainName,
    ULONG  ScopeNetwork,
    ULONG  ScopeMask
    )

/*++

Routine Description:

    This is a helper routine. It queries the local DNS Client (resident resolver)
    to see if it already knows the IP address of the desired hostname. This
    may have happened by our DHCP module adding it to the hosts.ics file.

Arguments:

    Pointer to the host name and domain suffix name. Scope net and mask.

Return Value:

    IP address of the host; if we dont find it we return 0.

Environment:

    Invoked from an arbitrary context.

--*/

{
    ULONG       retIP = 0;
    PWCHAR      pszFQDN = NULL;
    DNS_STATUS  dnsStatus;
    PDNS_RECORD pQueryResultsSet = NULL;
    DWORD       dwQueryOptions, dwSize;

    if (!pszHostName    ||
        !pszDomainName  ||
        !*pszHostName   ||
        !*pszDomainName)
    {
        return 0;
    }

    //
    // create a FQDN hostname
    // total length = hostname length + dot length + domainname length + null
    //
    dwSize = wcslen(pszHostName) + 1 + wcslen(pszDomainName) + 1;

    pszFQDN = reinterpret_cast<PWCHAR>(NH_ALLOCATE(sizeof(WCHAR) * dwSize));

    if (!pszFQDN)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "NhQueryHostByName: allocation failed for client name"
            );
        return 0;
    }
    ZeroMemory(pszFQDN, (sizeof(WCHAR) * dwSize));

    wcscpy(pszFQDN, pszHostName);   // copy the hostname
    wcscat(pszFQDN, L".");          // add the dot
    wcscat(pszFQDN, pszDomainName); // add the suffix

    dwQueryOptions =
        (
         DNS_QUERY_STANDARD      |
         DNS_QUERY_CACHE_ONLY    |
         DNS_QUERY_TREAT_AS_FQDN
        );

    dnsStatus = DnsQuery_W(
                    (PWSTR) pszFQDN,
                    DNS_TYPE_A,
                    dwQueryOptions,
                    NULL,
                    &pQueryResultsSet,
                    NULL
                    );
    
    if ((NO_ERROR == dnsStatus) && (pQueryResultsSet))
    {
        PDNS_RECORD pRR = pQueryResultsSet;

        while (pRR)
        {
            if (pRR->Flags.S.Section == DNSREC_ANSWER &&
                pRR->wType == DNS_TYPE_A)
            {
                if (((pRR->Data.A.IpAddress & ~ScopeMask) != 0) &&
                    ((pRR->Data.A.IpAddress & ~ScopeMask) != ~ScopeMask) &&
                    ((pRR->Data.A.IpAddress & ScopeMask) == ScopeNetwork))
                {
                    retIP = pRR->Data.A.IpAddress;
                    break;
                }
            }

            pRR = pRR->pNext;
        }
    }

    if (pQueryResultsSet)
    {
        DnsRecordListFree(
            pQueryResultsSet,
            DnsFreeRecordListDeep
            );
    }
        
    if (pszFQDN)
    {
        NH_FREE(pszFQDN);
    }

    return retIP;
} // NhQueryHostByName


NTSTATUS
NhQueryICSDomainSuffix(
    PWCHAR *ppszDomain
    )

/*++

Routine Description:

    This is a helper routine. It queries the registry to see if there
    is a setting for the ICSDomain string - if not, it returns the default
    suffix used for ICS.

Arguments:

    Pointer to a suffix string. Caller MUST release using NH_FREE.

Return Value:

    NTSTATUS - NT status code.

Environment:

    Invoked from an arbitrary context.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    IO_STATUS_BLOCK IoStatus;
    HANDLE Key;
    ULONG Length;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;

    if (!ppszDomain)
    {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryICSDomainSuffix: invalid (null pointer) parameter"
            );
        return STATUS_INVALID_PARAMETER;
    }

    *ppszDomain = NULL;

    //
    // retrieve current suffix string (if any)
    //

    RtlInitUnicodeString(&UnicodeString, NhTcpipParametersString);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the 'Tcpip' registry key
    //

    status =
        NtOpenKey(
            &Key,
            KEY_READ,
            &ObjectAttributes
            );

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryICSDomainSuffix: error %x opening registry key",
            status
            );
        return status;
    }

    //
    // Read the 'Domain' value
    //

    status =
        NhQueryValueKey(
            Key,
            NhpICSDomainString,
            &Information
            );

    NtClose(Key);

    if (!NT_SUCCESS(status) || !Information) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryICSDomainSuffix: error %x querying ICSDomain name - "
            "using default instead",
            status
            );
            
        //
        // Copy default domain name instead
        //
        
        Length = wcslen(DNS_HOMENET_SUFFIX) + 1;

        *ppszDomain = reinterpret_cast<PWCHAR>(
                          NH_ALLOCATE(sizeof(WCHAR) * Length)
                          );

        if (!*ppszDomain) {
            NhTrace(
                TRACE_FLAG_REG,
                "NhQueryICSDomainSuffix: error allocating domain name"
                );
            return STATUS_NO_MEMORY;
        }

        wcscpy(*ppszDomain, DNS_HOMENET_SUFFIX);

    }
    else
    {

        if (REG_SZ != Information->Type
            || L'\0' != *(PWCHAR) (Information->Data +
                                    (Information->DataLength - sizeof(WCHAR)))) {

            NH_FREE(Information);
            NhTrace(
                TRACE_FLAG_REG,
                "NhQueryICSDomainSuffix: Registry contains invalid data"
                );
            return STATUS_UNSUCCESSFUL;
        }
    
        //
        // Copy the domain name
        //

        Length = wcslen((PWCHAR)Information->Data) + 1;

        *ppszDomain = reinterpret_cast<PWCHAR>(
                          NH_ALLOCATE(sizeof(WCHAR) * Length)
                          );

        if (!*ppszDomain) {
            NH_FREE(Information);
            NhTrace(
                TRACE_FLAG_REG,
                "NhQueryICSDomainSuffix: error allocating domain name"
                );
            return STATUS_NO_MEMORY;
        }

        wcscpy(*ppszDomain, (PWCHAR)Information->Data);

        NH_FREE(Information);

    }

    return STATUS_SUCCESS;
} // NhQueryICSDomainSuffix



NTSTATUS
NhQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    )

/*++

Routine Description:

    This routine is called to obtain the value of a registry key.

Arguments:

    Key - the key to be queried

    ValueName - the value to be queried

    Information - receives a pointer to the information read

Return Value:

    NTSTATUS - NT status code.

--*/

{
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    ULONG InformationLength;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("NhQueryValueKey");

    RtlInitUnicodeString(&UnicodeString, ValueName);

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    InformationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    //
    // Read the value's size
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status) &&
        status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL
        ) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: status %08x obtaining value size",
            status
            );
        *Information = NULL;
        return status;
    }

    //
    // Allocate space for the value's size
    //

    *Information =
        (PKEY_VALUE_PARTIAL_INFORMATION)NH_ALLOCATE(InformationLength + 2);

    if (!*Information) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: error allocating %d bytes",
            InformationLength + 2
            );
        return STATUS_NO_MEMORY;
    }

    //
    // Read the value's data
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: status %08x obtaining value data",
            status
            );
        NH_FREE(*Information);
        *Information = NULL;
    }

    return status;

} // NhQueryValueKey


ULONG
NhMapAddressToAdapter(
    ULONG Address
    )

/*++

Routine Description:

    This routine is invoked to map an IP address to an adapter index.
    It does so by obtaining the stack's address-table, which contains
    valid adapter-indices rather than IP router-manager indices.
    This table is then used to obtain the IP address's adapter-index.

Arguments:

    Address - the local address for which an adapter-index is required

Return Value:

    ULONG - adapter index.

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG i;
    PMIB_IPADDRTABLE Table;
    PROFILE("NhMapAddressToAdapter");
    if (AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            ) == NO_ERROR) {
        for (i = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwAddr != Address) { continue; }
            AdapterIndex = Table->table[i].dwIndex;
            break;
        }
        HeapFree(GetProcessHeap(), 0, Table);
    }
    return AdapterIndex;
} // NhMapAddressToAdapter


ULONG
NhMapInterfaceToAdapter(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to map an interface to an adapter index.
    It does so by invoking the appropriate IP router-manager entry-point.

Arguments:

    Index - the index of the interface to be mapped

Return Value:

    ULONG - adapter index.

--*/

{
    MAPINTERFACETOADAPTER FarProc;
    PROFILE("NhMapInterfaceToAdapter");
    EnterCriticalSection(&NhLock);
    if (!NhpRtrmgrDll) { NhpRtrmgrDll = LoadLibraryA("IPRTRMGR.DLL"); }
    LeaveCriticalSection(&NhLock);
    if (!NhpRtrmgrDll) { return (ULONG)-1; }
    FarProc = (MAPINTERFACETOADAPTER)GetProcAddress(NhpRtrmgrDll, "MapInterfaceToAdapter");
    return (ULONG)(FarProc ? (*FarProc)(Index) : -1);
} // NhMapInterfaceToAdapter


VOID
NhResetComponentMode(
    VOID
    )

/*++

Routine Description:

    This routine relinquishes control of the kernel-mode translation module,
    and returns this module to an uninitialized state.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhLock);
    if (NhpComponentEvent) {
        CloseHandle(NhpComponentEvent); NhpComponentEvent = NULL;
    }
    if (INVALID_HANDLE_VALUE != NhFileHandle) {
        NatUnloadDriver(NhFileHandle); NhFileHandle = INVALID_HANDLE_VALUE;
    }
    NhComponentMode = NhUninitializedMode;
    LeaveCriticalSection(&NhLock);
} // NhResetComponentMode


BOOLEAN
NhSetComponentMode(
    NH_COMPONENT_MODE ComponentMode
    )

/*++

Routine Description:

    This routine is invoked to atomically set the module into a particular mode
    in order to prevent conflict between shared-access and connection-sharing,
    both of which are implemented in this module, and both of which run
    in the 'netsvcs' instance of SVCHOST.EXE.

    In setting either mode, the routine first determines whether it is already
    executing in the alternate mode, in which case it fails.

    Otherwise, it attempts to open a handle to ipnat.sys to claim exclusive
    control of the kernel-mode translation module. The kernel-mode translation
    module enforces exclusive ownership -- it will fail the open w/ 
    ERROR_ACCESS_DENIED if another process has claimed control of the driver.

    Otherwise, the kernel-mode translation module is claimed for this module
    and the module is set into the required mode.

    This routine will also attempt to create a named event. This event
    was previously used to enforce exclusive ownership in the past, when
    the driver was unable to do so. We will not fail if the event already
    exists (or if we are unable to create it). We still create the event,
    though, so that other modules that choose to use this mechanism will
    still be able to correctly report the cause of the error.

Arguments:

    ComponentMode - the mode into which the module is to be set.

Return Value:

    BOOLEAN - TRUE if successful, FALSE if the module could not be set
        or if the kernel-mode translation module has already been claimed.

--*/

{
    EnterCriticalSection(&NhLock);
    
    if (NhUninitializedMode != NhComponentMode
        && NhComponentMode != ComponentMode) {

        //
        // The module has been set to a different mode.
        //
        
        LeaveCriticalSection(&NhLock);
        NhStartEventLog();
        NhErrorLog(
            (ComponentMode == NhRoutingProtocolMode)
                ? IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT
                : IP_NAT_LOG_SHARED_ACCESS_CONFLICT,
            0,
            ""
            );
        NhStopEventLog();
        return FALSE;
    }

    //
    // Attempt to load and open a handle to the NAT driver, if we have not
    // already done so. This is needed to detect if another process has already
    // taken control of the driver.
    //

    if (INVALID_HANDLE_VALUE == NhFileHandle) {
        ULONG Error;
        IP_NAT_GLOBAL_INFO GlobalInfo;
    
        ZeroMemory(&GlobalInfo, sizeof(GlobalInfo));
        GlobalInfo.Header.Version = IP_NAT_VERSION;
        GlobalInfo.Header.Size = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);

        Error = NatLoadDriver(&NhFileHandle, &GlobalInfo);

        if (ERROR_ACCESS_DENIED == Error) {

            //
            // An access denied error signifies a conflict.
            //

            NhFileHandle = INVALID_HANDLE_VALUE;
            LeaveCriticalSection(&NhLock);
            NhStartEventLog();
            NhErrorLog(
                (ComponentMode == NhRoutingProtocolMode)
                    ? IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT
                    : IP_NAT_LOG_SHARED_ACCESS_CONFLICT,
                0,
                ""
                );
            NhStopEventLog();
            return FALSE;

        } else if (NO_ERROR != Error) {

            //
            // We weren't able to load the driver for some other reason.
            //

            NhFileHandle = INVALID_HANDLE_VALUE;
            LeaveCriticalSection(&NhLock);
            NhStartEventLog();
            NhErrorLog(
                IP_NAT_LOG_LOAD_DRIVER_FAILED,
                Error,
                ""
                );
            NhStopEventLog();
            return FALSE;
        }    
    }

    if (NULL == NhpComponentEvent) {
        NhpComponentEvent =
            CreateEventA(NULL, FALSE, FALSE, IP_NAT_SERVICE_NAME);

        //
        // We will continue executing even if we are not able to create
        // the named event, or if the event already exists. This is mainly
        // for other users of the NAT who follow the old access control
        // system, instead of letting the driver enforce single-ownership
        // requirements.
        //
    }

    NhComponentMode = ComponentMode;
    LeaveCriticalSection(&NhLock);
    return TRUE;
} // NhSetComponentMode


VOID
NhSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    It invokes the reconfiguration for the DHCP allocator and DNS proxy,
    neither of which are expected to operate on a NAT boundary interface.
    This notification gives either (or both) an opportunity to deactivate
    itself on NAT interfaces or reactivate itself on non-NAT interfaces.

Arguments:

    Index - the interface whose configuration has changed

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhSignalNatInterface");

    //
    // Attempt to obtain the corresponding DHCP and DNS interfaces.
    // It is important that this works regardless of whether DHCP allocation,
    // DNS proxying or DirectPlay transparent proxying is enabled;
    // the interface lists are initialized minimally in 'DllMain' above.
    //

    DhcpSignalNatInterface(Index, Boundary);
    DnsSignalNatInterface(Index, Boundary);
    AlgSignalNatInterface(Index, Boundary);
    H323SignalNatInterface(Index, Boundary);

} // NhSignalNatInterface


VOID
NhUpdateApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to (re)load the advanced application settings.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr;
    PNAT_APP_ENTRY pAppEntry;
    IHNetCfgMgr *pCfgMgr = NULL;
    IHNetProtocolSettings *pProtocolSettings;
    IEnumHNetApplicationProtocols *pEnumApps;
    BOOLEAN ComInitialized = FALSE;
    ULONG ulCount;
    PROFILE("NhUpdateApplicationSettings");

    EnterCriticalSection(&NhLock);

    //
    // Free old settings list
    //

    NhFreeApplicationSettings();

    //
    // Free DHCP reservation list
    //

    NhFreeDhcpReservations();

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (SUCCEEDED(hr))
    {
        ComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetCfgMgr pointer out of the GIT 
        //

        hr = NhGetHNetCfgMgr(&pCfgMgr);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetProtocolSettings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetProtocolSettings, &pProtocolSettings)
                );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumeration of enabled application protocols
        //

        hr = pProtocolSettings->EnumApplicationProtocols(TRUE, &pEnumApps);
        pProtocolSettings->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Process the items in the enum
        //

        do
        {
            IHNetApplicationProtocol *pAppProtocol;
            
            hr = pEnumApps->Next(1, &pAppProtocol, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Allocate a new app entry
                //

                pAppEntry = reinterpret_cast<PNAT_APP_ENTRY>(
                                NH_ALLOCATE(sizeof(*pAppEntry))
                                );

                if (NULL != pAppEntry)
                {
                    ZeroMemory(pAppEntry, sizeof(*pAppEntry));

                    //
                    // Get protocol
                    //

                    hr = pAppProtocol->GetOutgoingIPProtocol(
                            &pAppEntry->Protocol
                            );

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get port
                        //

                        hr = pAppProtocol->GetOutgoingPort(
                                &pAppEntry->Port
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get responses
                        //

                        hr = pAppProtocol->GetResponseRanges(
                                &pAppEntry->ResponseCount,
                                &pAppEntry->ResponseArray
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add entry to list
                        //

                        InsertTailList(&NhApplicationSettingsList, &pAppEntry->Link);
                    }
                    else
                    {
                        //
                        // Free entry
                        //

                        NH_FREE(pAppEntry);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pAppProtocol->Release();
            }
        } while (SUCCEEDED(hr) && 1 == ulCount);

        pEnumApps->Release();
    }

    //
    // Build the DHCP reservation list
    //

    NhBuildDhcpReservations();
    
    LeaveCriticalSection(&NhLock);

    //
    // Free config manager
    //

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }

    //
    // Uninitialize COM
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

} // NhUpdateApplicationSettings


ULONG
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingCharacteristics,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceCharacteristics
    )

/*++

Routine Description:

    This routine is invoked once for each protocol implemented in this module.
    On each invocation, the supplied 'RoutingCharacteristics' indicates
    the protocol to be registered in its 'dwProtocolId' field.

Arguments:

    RoutingCharacteristics - on input, the protocol to be registered
        and the router-manager's supported functionality.

    ServiceCharacteristics - unused.

Return Value:

    ULONG - status code.

--*/

{
    if (RoutingCharacteristics->dwVersion < MS_ROUTER_VERSION) {
        return ERROR_NOT_SUPPORTED;
    }

    if ((RoutingCharacteristics->fSupportedFunctionality &
            (RF_ROUTING|RF_ADD_ALL_INTERFACES)) != 
            (RF_ROUTING|RF_ADD_ALL_INTERFACES)) {
        return ERROR_NOT_SUPPORTED;
    }

    switch (RoutingCharacteristics->dwProtocolId) {

        case MS_IP_NAT: {
            //
            // Attempt to set the component into 'Connection Sharing' mode.
            // This module implements both shared-access and connection-sharing
            // which are mutually exclusive, so we need to ensure that
            // shared-access is not operational before proceeding.
            //
            if (!NhSetComponentMode(NhRoutingProtocolMode)) {
                return ERROR_CAN_NOT_COMPLETE;
            }
            CopyMemory(
                RoutingCharacteristics,
                &NatRoutingCharacteristics,
                sizeof(NatRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality = RF_ROUTING;
            break;
        }

        case MS_IP_DNS_PROXY: {
            CopyMemory(
                RoutingCharacteristics,
                &DnsRoutingCharacteristics,
                sizeof(DnsRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

        case MS_IP_DHCP_ALLOCATOR: {
            CopyMemory( 
                RoutingCharacteristics,
                &DhcpRoutingCharacteristics,
                sizeof(DhcpRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

        case MS_IP_ALG: {
            CopyMemory( 
                RoutingCharacteristics,
                &AlgRoutingCharacteristics,
                sizeof(AlgRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }
        
        case MS_IP_H323: {
            CopyMemory( 
                RoutingCharacteristics,
                &H323RoutingCharacteristics,
                sizeof(H323RoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

        default: {
            return ERROR_NOT_SUPPORTED;
        }
    }

    ServiceCharacteristics->mscMpr40ServiceChars.fSupportedFunctionality = 0;

    return NO_ERROR;

} // RegisterProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsio.h

Abstract:

    This module contains declarations for the DNS allocator's network I/O
    completion routines.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DNSIO_H_
#define _NATHLP_DNSIO_H_

VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DnsWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DNSIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsio.c

Abstract:

    This module contains code for the DNS allocator's network I/O completion
    routines.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            28-Mar-2002
    Note: bunch of reposts - due to accumulated patching - need to cleanup.

--*/

#include "precomp.h"
#pragma hdrstop
#include "dnsmsg.h"


VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a datagram socket bound to the DNS server UDP port.

    The message read is validated and processed; the processing may involve
    creating a query-record and forwarding the query to a server, or
    matching a response to an existing query-record and forwarding the
    response to the appropriate client.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsReadCompletionRoutine");

    do {

        //
        // There are two cases where we don't process the message;
        // (a) the I/O operation failed
        // (b) the interface is no longer active
        // In case (a), we repost the buffer; in case (b), we do not.
        //

        Interfacep = (PDNS_INTERFACE)Bufferp->Context;

        //
        // First look for an error code
        //
    
        if (ErrorCode) {

            NhTrace(
                TRACE_FLAG_IO,
                "DnsReadCompletionRoutine: error %d for read-context %x",
                ErrorCode,
                Bufferp->Context
                );

            //
            // See if the interface is still active
            //

            ACQUIRE_LOCK(Interfacep);
            if (!DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else {
                RELEASE_LOCK(Interfacep);
                EnterCriticalSection(&DnsInterfaceLock);
                if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                } else {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    //
                    // Repost the buffer for another read operation
                    //
                    do {
                        Error =
                            NhReadDatagramSocket(
                                &DnsComponentReference,
                                Bufferp->Socket,
                                Bufferp,
                                DnsReadCompletionRoutine,
                                Bufferp->Context,
                                Bufferp->Context2
                                );
                        //
                        // A connection-reset error indicates that our last
                        // *send* could not be delivered at its destination.
                        // We could hardly care less; so issue the read again,
                        // immediately.
                        //
                    } while (Error == WSAECONNRESET);
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DnsDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DNS_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
            }

            break;
        }

        //
        // Now see if the interface is operational
        //

        ACQUIRE_LOCK(Interfacep);
        if (!DNS_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "DnsReadCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        }
        RELEASE_LOCK(Interfacep);

        //
        // Ensure minimum DNS_HEADER size
        //

        if (BytesTransferred < sizeof(DNS_HEADER)) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsReadCompletionRoutine: message size %d too small",
                BytesTransferred
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_MESSAGE_TOO_SMALL,
                0,
                ""
                );
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DnsStatistics.MessagesIgnored)
                );

            //
            // Repost read
            //

            EnterCriticalSection(&DnsInterfaceLock);
            if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
                LeaveCriticalSection(&DnsInterfaceLock);
                NhReleaseBuffer(Bufferp);
            } else {
                LeaveCriticalSection(&DnsInterfaceLock);
                do {
                    Error =
                        NhReadDatagramSocket(
                            &DnsComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DnsReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    //
                    // A connection-reset error indicates that our last
                    // *send* could not be delivered at its destination.
                    // We could hardly care less; so issue the read again,
                    // immediately.
                    //
                } while (Error == WSAECONNRESET);
                if (Error) {
                    ACQUIRE_LOCK(Interfacep);
                    DnsDeferReadInterface(Interfacep, Bufferp->Socket);
                    RELEASE_LOCK(Interfacep);
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                    NhReleaseBuffer(Bufferp);
                }
            }

            break;
        }

        //
        // Now look at the message
        //

        Headerp = (PDNS_HEADER)Bufferp->Buffer;

        if (Headerp->IsResponse == DNS_MESSAGE_QUERY) {
            DnsProcessQueryMessage(
                Interfacep,
                Bufferp
                );
        } else {
            DnsProcessResponseMessage(
                Interfacep,
                Bufferp
                );
        }

    } while(FALSE);

    DNS_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_DNS();

} // DnsReadCompletionRoutine


VOID
DnsWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a datagram socket bound to the DNS server UDP port.

    The write-context for all writes is a 'DNS_QUERY'. Our handling
    is dependent on whether the message written was a query or a response.

    Upon completion of a query, we may need to do a resend if there was
    an error. Upon completion of a response, we delete the query-record.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_INTERFACE Interfacep;
    USHORT QueryId;
    PDNS_QUERY Queryp;
    PULONG Server;

    PROFILE("DnsWriteCompletionRoutine");

    Interfacep = (PDNS_INTERFACE)Bufferp->Context;
    QueryId = (USHORT)Bufferp->Context2;
    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    ACQUIRE_LOCK(Interfacep);

    //
    // Obtain the query associated with the send.
    //

    Queryp = DnsMapResponseToQuery(Interfacep, QueryId);

    if (Headerp->IsResponse == DNS_MESSAGE_RESPONSE) {

        if (ErrorCode) {

            //
            // An error occurred sending the message to the client
            //

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: error %d response %d interface %d",
                ErrorCode,
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                ErrorCode,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );

        } else if (Queryp && Headerp->ResponseCode == DNS_RCODE_NOERROR) {

            //
            // We're done with this query since it succeeded; remove it.
            //

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: removing query %d interface %d",
                Queryp->QueryId,
                Interfacep->Index
                );

            DnsDeleteQuery(Interfacep, Queryp);
        }
    } else {

        if (!ErrorCode) {
    
            //
            // No errors, so just return.
            //
    
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: sent query %d interface %d",
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
        } else {
    
            //
            // The query just went out and it failed.
            //
    
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: error %d for query %d interface %d",
                ErrorCode,
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_QUERY_FAILED,
                ErrorCode,
                "%I%I%I",
                Queryp ? Queryp->SourceAddress : -1,
                Bufferp->WriteAddress.sin_addr.s_addr,
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    NhReleaseBuffer(Bufferp);
    DEREFERENCE_DNS();

} // DnsWriteCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsmsg.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsmsg.c

Abstract:

    This module contains code for the DNS proxy's message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Rewrite + Cleanup + New Functions

--*/

#include "precomp.h"
#pragma hdrstop


//
// EXTERNAL DECLARATIONS
//
extern "C" DWORD G_UseEdns;


VOID
DnsProcessQueryMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DNS query message.

Arguments:

    Interfacep - the interface on which the query was received

    Bufferp - the buffer containing the query

Return Value:

    none.

Environment:

    Invoked internally in the context of a worker-thread completion routine,
    with an outstanding reference to 'Interfacep' from the time the
    read-operation was begun.

--*/

{
    PVOID Context;
    PVOID Context2;
    ULONG Error;
    PDNS_QUERY Queryp;
    PDNS_HEADER Headerp;
    BOOLEAN Referenced = TRUE;
    SOCKET Socket;
    LPVOID lpMsgBuf;

    PROFILE("DnsProcessQueryMessage");

#if DBG

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsProcessQueryMessage: dumping %d bytes",
        Bufferp->BytesTransferred
        );

    NhDump(
        TRACE_FLAG_DNS,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );

#endif

    InterlockedIncrement(
        reinterpret_cast<LPLONG>(&DnsStatistics.QueriesReceived)
        );

    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    Socket = Bufferp->Socket;
    Context = Bufferp->Context;
    Context2 = Bufferp->Context2;

    //
    // if the Broadcast bit (9) was set, we leave it as is
    // instead of zeroing it
    //
    //if (Headerp->Broadcast) {
    //    Headerp->Broadcast = 0;
    //}

    ASSERT(Headerp->Opcode != DNS_OPCODE_IQUERY);
    ASSERT(Headerp->Opcode != DNS_OPCODE_SERVER_STATUS);

    if (Headerp->Opcode == DNS_OPCODE_QUERY) {

        //
        // Query the local DNS Resolver cache before proxying
        //

        //
        // Unpack
        //
        DNS_STATUS          dnsStatus;
        DNS_PARSED_MESSAGE  dnsParsedMsg;
        PDNS_MESSAGE_BUFFER pDnsBuffer = NULL;
        PDNS_MSG_BUF        pDnsMsgBuf = NULL;
        PDNS_RECORD         pQueryResultsSet = NULL;
        WORD                wMessageLength;
        DWORD               dwFlags, dwQueryOptions;
        DNS_CHARSET         CharSet;
        BOOL                fQ4DefaultSuffix = FALSE;

        ZeroMemory(&dnsParsedMsg, sizeof(DNS_PARSED_MESSAGE));
        
        pDnsBuffer     = (PDNS_MESSAGE_BUFFER) Headerp;        
        wMessageLength = (WORD) Bufferp->BytesTransferred;
        dwFlags        = DNS_PARSE_FLAG_ONLY_QUESTION;
        CharSet        = DnsCharSetUtf8;

        //
        // Dns* functions require byte flipping
        //
        DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);
        
        dnsStatus = Dns_ParseMessage(
                        &dnsParsedMsg,
                        pDnsBuffer,
                        wMessageLength,
                        dwFlags,
                        CharSet
                        );

        if (NO_ERROR == dnsStatus)
        {        
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: Dns_ParseMessage succeeded!!"
                );

            //
            // Make a note of whether this question was for our private
            // default domain (ie mshome.net)
            //
            {
                //
                // the question name is in UTF_8 form
                //
            
                PWCHAR pszQName = NULL;
                DWORD  dwSize;

                dwSize = DnsGetBufferLengthForStringCopy(
                             (char *)dnsParsedMsg.pQuestionName,
                             0,                     // the function calculates it
                             FALSE,                 // DnsCharSetUtf8
                             TRUE                   // DnsCharSetUnicode
                             );
                if (!dwSize)
                {
                    //
                    // invalid input string
                    //
                    DWORD dwRet = GetLastError();

                    lpMsgBuf = NULL;
                    
                    FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        dwRet,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                        );
                        
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsProcessQueryMessage: DnsGetBufferLengthForStringCopy"
                        " returned (0x%08x) %S",
                        dwRet,
                        lpMsgBuf
                        );
                    
                    if (lpMsgBuf) LocalFree(lpMsgBuf);
                }
                else
                {
                    pszQName = reinterpret_cast<PWCHAR>(NH_ALLOCATE(dwSize));
                    
                    if (!pszQName)
                    {
                        NhTrace(
                            TRACE_FLAG_DNS,
                            "DnsProcessQueryMessage: allocation "
                            "failed for pszQName"
                            );
                    }
                    else
                    {
                        DWORD dwUtf8Size = strlen((char *)dnsParsedMsg.pQuestionName);

                        ZeroMemory(pszQName, dwSize);
                        DnsUtf8ToUnicode(
                            (char *)dnsParsedMsg.pQuestionName,
                            dwUtf8Size,
                            pszQName,
                            dwSize
                            );
                    
                        fQ4DefaultSuffix = IsSuffixValid(
                                                      pszQName,
                                                      DNS_HOMENET_SUFFIX
                                                      );
                        NhTrace(
                            TRACE_FLAG_DNS,
                            "DnsProcessQueryMessage: %S (%s)",
                            pszQName,
                            (fQ4DefaultSuffix?"TRUE":"FALSE")
                            );

                        NH_FREE(pszQName);
                    }
                }
            }
            
            //
            // Query
            //
            dwQueryOptions = (
                              DNS_QUERY_STANDARD              |
                              DNS_QUERY_CACHE_ONLY            |
                              DNS_QUERY_TREAT_AS_FQDN         |
                              //DNS_QUERY_ALLOW_EMPTY_AUTH_RESP |
                              0
                             );

            dnsStatus = DnsQuery_UTF8(
                            (LPSTR) dnsParsedMsg.pQuestionName,
                            dnsParsedMsg.QuestionType,
                            dwQueryOptions,
                            NULL,
                            &pQueryResultsSet,
                            NULL
                            );
        }

        if (dnsStatus)
        {
            lpMsgBuf = NULL;

            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                dnsStatus,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &lpMsgBuf,
                0,
                NULL
                );
                
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: (0x%08x) %S",
                dnsStatus,
                lpMsgBuf
                );
            
            if (lpMsgBuf) LocalFree(lpMsgBuf);
        }
        
        if ((NO_ERROR == dnsStatus) &&
            (pQueryResultsSet)          // ??? what do i check to see if 
                                        // there was actually something useful
                                        // returned from the cache
           )
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: results found in the local DNS Resolver Cache"
                );

            //
            // Pack & Send back answer; return
            //

            // set response bit
            dnsParsedMsg.Header.IsResponse = 1;

            // set the section field of every DNS_RECORD given to us
            // *** NEED TO CHANGE THIS LATER ***
            PDNS_RECORD pRR = pQueryResultsSet;
            DWORD       cnt = 0;
            while (pRR)
            {
                pRR->Flags.S.Section = 1;
                cnt++;
                pRR = pRR->pNext;
            }
            
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: %d records",
                cnt
                );
            
            // set global EDNS OPT field to 0 every time
            // *** NEED TO CHANGE THIS LATER ***
            //G_UseEdns = 0;

            pDnsMsgBuf = Dns_BuildPacket(
                             &dnsParsedMsg.Header,   // ??? parsed message header should be OK
                             TRUE,                   // ??? no header count copy - counts done automatically?
                             dnsParsedMsg.pQuestionName,
                             dnsParsedMsg.QuestionType,
                             pQueryResultsSet,
                             dwQueryOptions,
                             TRUE                    // set to update because of G_UseEdns workaround
                             );

            if (NULL == pDnsMsgBuf)
            {
                lpMsgBuf = NULL;
                
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                    );
                    
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: Dns_BuildPacket failed (%S)",
                    lpMsgBuf
                    );
                
                if (lpMsgBuf) LocalFree(lpMsgBuf);
            }
            else
            {
                DWORD dwDnsPktSize = (DWORD)(sizeof(DNS_HEADER) +
                                             ((PCHAR)pDnsMsgBuf->pCurrent - 
                                              (PCHAR)pDnsMsgBuf->MessageBody));
            
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: Dns_BuildPacket returned pkt of size %d (%d) bytes",
                    dwDnsPktSize,
                    DNS_MESSAGE_OFFSET(pDnsMsgBuf, pDnsMsgBuf->pCurrent)
                    );
            
                //
                // send back the answer retrieved from the cache
                //
                PNH_BUFFER NewBufferp = NhAcquireVariableLengthBuffer(
                                            dwDnsPktSize
                                            );

                if (!NewBufferp)
                {
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsProcessQueryMessage: could not acquire buffer"
                        );
                }
                else
                {
                    //
                    // Dns* functions return in host order ???
                    //
                    DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsMsgBuf->MessageHead);
                    
                    //
                    // Reference the interface now since we are replying
                    // to the query
                    //
                    
                    EnterCriticalSection(&DnsInterfaceLock);
                    if (!DNS_REFERENCE_INTERFACE(Interfacep))
                    {
                        LeaveCriticalSection(&DnsInterfaceLock);
                        Referenced = FALSE;
                    }
                    else
                    {
                        LeaveCriticalSection(&DnsInterfaceLock);
                    
                        ACQUIRE_LOCK(Interfacep);

                        memcpy(
                            NewBufferp->Buffer,
                            &pDnsMsgBuf->MessageHead,
                            dwDnsPktSize
                            );
                        
                        Error =
                            NhWriteDatagramSocket(
                                &DnsComponentReference,
                                Bufferp->Socket,
                                Bufferp->ReadAddress.sin_addr.s_addr,
                                Bufferp->ReadAddress.sin_port,
                                NewBufferp,
                                dwDnsPktSize,
                                DnsWriteCompletionRoutine,
                                Interfacep,
                                NULL
                                );

                        RELEASE_LOCK(Interfacep);
                        
                        if (!Error)
                        {
                            InterlockedIncrement(
                                reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                                );
                        }
                        else
                        {
                            NhReleaseBuffer(NewBufferp);
                            DNS_DEREFERENCE_INTERFACE(Interfacep);
                            NhWarningLog(
                                IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                                Error,
                                "%I",
                                NhQueryAddressSocket(Socket)
                                );
                        }
                    }
                }
                
                DnsFree(pDnsMsgBuf, DnsFreeFlat);
                
            }
            
            // buffer is reposted below

        }
        else
        if (//(DNS_ERROR_RECORD_DOES_NOT_EXIST == dnsStatus) &&
            (fQ4DefaultSuffix))
        {
            //
            // this was a question for our default suffix
            // we send a name error reply back to the client
            // - note however that we dont publish an SOA
            //   record for our default suffix domain
            //

            //
            // Undoing Flip above
            //
            DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);
            
            DWORD dwDnsPktSize = Bufferp->BytesTransferred;
        
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: returning error message"
                );
        
            //
            // send back the negative answer
            //
            PNH_BUFFER NewBufferp = NhAcquireVariableLengthBuffer(
                                        dwDnsPktSize
                                        );

            if (!NewBufferp)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: could not acquire buffer"
                    );
            }
            else
            {
                //
                // Reference the interface now since we are replying
                // to the query
                //
                
                EnterCriticalSection(&DnsInterfaceLock);
                if (!DNS_REFERENCE_INTERFACE(Interfacep))
                {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    Referenced = FALSE;
                }
                else
                {
                    LeaveCriticalSection(&DnsInterfaceLock);
                
                    ACQUIRE_LOCK(Interfacep);

                    memcpy(
                        NewBufferp->Buffer,
                        Bufferp->Buffer,
                        dwDnsPktSize
                        );

                    PDNS_HEADER NewHeaderp = (PDNS_HEADER)NewBufferp->Buffer;

                    //
                    // set response bit
                    //
                    NewHeaderp->IsResponse = 1;

                    //
                    // set "Name does not exist" error in the RCode field
                    //
                    NewHeaderp->ResponseCode = DNS_RCODE_NXDOMAIN;

                    
                    Error =
                        NhWriteDatagramSocket(
                            &DnsComponentReference,
                            Bufferp->Socket,
                            Bufferp->ReadAddress.sin_addr.s_addr,
                            Bufferp->ReadAddress.sin_port,
                            NewBufferp,
                            dwDnsPktSize,
                            DnsWriteCompletionRoutine,
                            Interfacep,
                            NULL
                            );

                    RELEASE_LOCK(Interfacep);
                    
                    if (!Error)
                    {
                        InterlockedIncrement(
                            reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                            );
                    }
                    else
                    {
                        NhReleaseBuffer(NewBufferp);
                        DNS_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Socket)
                            );
                    }
                }
            }

            // buffer is reposted below
            
        }
        else
        {
            //
            // Undoing Flip above
            //
            DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);

            //
            // Reference the interface now in case we need to forward the query
            //
        
            EnterCriticalSection(&DnsInterfaceLock);
            if (DNS_REFERENCE_INTERFACE(Interfacep))
            {
                LeaveCriticalSection(&DnsInterfaceLock);
            }
            else
            {
                LeaveCriticalSection(&DnsInterfaceLock);
                Referenced = FALSE;
            }
        
            ACQUIRE_LOCK(Interfacep);
        
            //
            // See if this query is already pending;
            // if not, create a record for it on the receiving interface.
            //
        
            if (DnsIsPendingQuery(Interfacep, Bufferp))
            {
                RELEASE_LOCK(Interfacep);

                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: query already pending"
                    );

                if (Referenced)
                { 
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                } 
            }
            else
            if (!Referenced ||
                !(Queryp = DnsRecordQuery(Interfacep, Bufferp)))
            {
                RELEASE_LOCK(Interfacep);

                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: query could not be created"
                    );

                if (Referenced)
                {
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                }
            }
            else
            {
        
                //
                // Write the new ID in the query
                //
        
                Headerp->Xid = Queryp->QueryId;
        
                //
                // Send the query to our servers
                //
        
                Error =
                    DnsSendQuery(
                        Interfacep,
                        Queryp,
                        FALSE
                        );
        
                //
                // This buffer is now associated with an outstanding query,
                // so don't repost it below.
                //
        
                if (!Error)
                {
                    Bufferp = NULL;
                    RELEASE_LOCK(Interfacep);
                }
                else
                {
                    //
                    // Delete the query, but not the buffer, which we repost below
                    //
                    Queryp->Bufferp = NULL;
                    DnsDeleteQuery(Interfacep, Queryp);
                    RELEASE_LOCK(Interfacep);
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                }
            }
        }

        //
        // Cleanup
        //

        if (pQueryResultsSet)
        {
            DnsFree(pQueryResultsSet, DnsFreeRecordList);
        }

        if (dnsParsedMsg.pQuestionName)
        {
            DnsFree(dnsParsedMsg.pQuestionName, DnsFreeFlat);
        }
    }

    //
    // Post another read
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        if (Bufferp) { NhReleaseBuffer(Bufferp); }
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);
        do {
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Socket,
                    Bufferp,
                    DnsReadCompletionRoutine,
                    Context,
                    Context2
                    );
            //
            // A connection-reset error indicates that our last *send*
            // could not be delivered at its destination.
            // We could hardly care less; so issue the read again,
            // immediately.
            //
        } while (Error == WSAECONNRESET);
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DnsDeferReadInterface(Interfacep, Socket);
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            NhErrorLog(
                IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Socket)
                );
            if (Bufferp) { NhReleaseBuffer(Bufferp); }
        }
    }

} // DnsProcessQueryMessage


VOID
DnsProcessResponseMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DNS response message.

Arguments:

    Interfacep - the interface on which the query was received

    Bufferp - the buffer containing the query

Return Value:

    none.

Environment:

    Invoked internally in the context of a worker-thread completion routine,
    with an outstanding reference to 'Interfacep' from the time the
    read-operation was begun.

--*/

{
    PVOID Context;
    PVOID Context2;
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_QUERY Queryp;
    SOCKET Socket;

    PROFILE("DnsProcessResponseMessage");

#if DBG
    NhDump(
        TRACE_FLAG_DNS,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );
#endif

    InterlockedIncrement(
        reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesReceived)
        );

    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    Socket = Bufferp->Socket;
    Context = Bufferp->Context;
    Context2 = Bufferp->Context2;

    //
    // Reference the interface and attempt to forward the response
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);

        ACQUIRE_LOCK(Interfacep);
    
        //
        // See if the response is for a pending query
        //
    
        if (!(Queryp = DnsMapResponseToQuery(Interfacep, Headerp->Xid))) {
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DnsStatistics.MessagesIgnored)
                );
        } else {
    
            //
            // We have the corresponding query.
            // Send the response back to the client.
            //
    
            Headerp->Xid = Queryp->SourceId;
    
            Error =
                NhWriteDatagramSocket(
                    &DnsComponentReference,
                    Bufferp->Socket,
                    Queryp->SourceAddress,
                    Queryp->SourcePort,
                    Bufferp,
                    Bufferp->BytesTransferred,
                    DnsWriteCompletionRoutine,
                    Interfacep,
                    (PVOID)Queryp->QueryId
                    );
    
            RELEASE_LOCK(Interfacep);
    
            //
            // This buffer is in use for a send-operation,
            // so don't repost it below.
            //
    
            if (!Error) {
                Bufferp = NULL;
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                    );
            } else {
                DNS_DEREFERENCE_INTERFACE(Interfacep);
                NhWarningLog(
                    IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Socket)
                    );
            }
        }
    }

    //
    // Post another read buffer
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        if (Bufferp) { NhReleaseBuffer(Bufferp); }
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);
        do {
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Socket,
                    Bufferp,
                    DnsReadCompletionRoutine,
                    Context,
                    Context2
                    );
            //
            // A connection-reset error indicates that our last *send*
            // could not be delivered at its destination.
            // We could hardly care less; so issue the read again,
            // immediately.
            //
        } while (Error == WSAECONNRESET);
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DnsDeferReadInterface(Interfacep, Socket);
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            if (Bufferp) { NhReleaseBuffer(Bufferp); }
            NhErrorLog(
                IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Socket)
                );
        }
    }

} // DnsProcessResponseMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsmsg.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsmsg.h

Abstract:

    This module contains declarations related to the DNS proxy's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            17-Nov-2000
    Cleanup

--*/

#ifndef _NATHLP_DNSMSG_H_
#define _NATHLP_DNSMSG_H_

//
// DNS message format, opcodes and response codes in sdk\inc\windns.h
//

//
// DNS message types
//

#define DNS_MESSAGE_QUERY           0
#define DNS_MESSAGE_RESPONSE        1


VOID
DnsProcessQueryMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

VOID
DnsProcessResponseMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DNSMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnslookup.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnslookup.h

Abstract:

    This module contains declarations related to the DNS server's
    lookup table.

Author:

    Tom Brown (tbrown)      25-Oct-1999

Revision History:

    Raghu Gatta (rgatta)    21-Oct-2000
    Time macros + New Functions

--*/

#ifndef _NATHLP_DNSLOOKUP_H_
#define _NATHLP_DNSLOOKUP_H_

#define LOCAL_DOMAIN L"local"
#define LOCAL_DOMAIN_ANSI "local"

//
// move to somewhere else if necessary
//

//
// Time conversion constants and macros
//

#define SYSTIME_UNITS_IN_1_MSEC  (1000 * 10)
#define SYSTIME_UNITS_IN_1_SEC   (1000 * SYSTIME_UNITS_IN_1_MSEC)


//
// macro to get system time in 100-nanosecond units
//

#define DnsQuerySystemTime(p)   NtQuerySystemTime((p))


//
// macros to convert time between 100-nanosecond, 1millsec, and 1 sec units
//

#define DnsSystemTimeToMillisecs(p) {                                       \
    DWORD _r;                                                               \
    *(p) = RtlExtendedLargeIntegerDivide(*(p), SYSTIME_UNITS_IN_1_MSEC, &_r);\
}

#define DnsMillisecsToSystemTime(p)                                         \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_IN_1_MSEC)

#define DnsSecsToSystemTime(p)                                              \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_IN_1_SEC)

#define CACHE_ENTRY_EXPIRY  (7 * 24 * 60 * 60)  // (matches DHCP lease time)



typedef ULONG DNS_ADDRESS;

typedef struct
{
    DNS_ADDRESS ulAddress;
    FILETIME    ftExpires;
    //ULONG       ulExpires;
} ADDRESS_INFO, *PADDRESS_INFO;

typedef struct
{
    WCHAR           *pszName;
    UINT            cAddresses;
    DWORD           cAddressesAllocated;
    PADDRESS_INFO   aAddressInfo;
} DNS_ENTRY, *PDNS_ENTRY;

typedef struct
{
    DNS_ADDRESS     ulAddress;           
    WCHAR           *pszName; // do not free this! It is the same pointer as used in the
                              // forward lookup table.
} REVERSE_DNS_ENTRY, *PREVERSE_DNS_ENTRY;


extern CRITICAL_SECTION    DnsTableLock;   // protects both tables
extern RTL_GENERIC_TABLE   g_DnsTable,
                           g_ReverseDnsTable;


ULONG
DnsInitializeTableManagement(
    VOID
    );


VOID
DnsShutdownTableManagement(
    VOID
    );


VOID
DnsEmptyTables(
    VOID
    );


BOOL
DnsRegisterName(
    WCHAR *pszName,
    UINT cAddresses,
    ADDRESS_INFO aAddressInfo[]
    );


VOID
DnsAddAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress,
    FILETIME    ftExpires
    //ULONG ulExpires
    );


VOID
DnsDeleteAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    );


PDNS_ENTRY
DnsLookupAddress(
    WCHAR *pszName
    );


PREVERSE_DNS_ENTRY
DnsLookupName(
    DNS_ADDRESS ulAddress
    );


VOID
DnsDeleteName(
    WCHAR *pszName
    );


VOID
DnsUpdateName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    );


VOID
DnsUpdate(
    CHAR *pszName,
    ULONG len,
    ULONG ulAddress
    );


VOID
DnsAddSelf(
    VOID
    );


VOID
DnsCleanupTables(
    VOID
    );

DWORD
DnsConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pszHostName,
    PWCHAR DnsICSDomainSuffix,
    PWCHAR *ppszUnicodeFQDN
    );

BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    );

BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnslookup.cpp ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    dnslookup.c

Abstract:

    This module contains code for the DNS component's name-lookup mechanism.

Author:

    Tom Brown (tbrown)      10/21/99

Revision History:

    Raghu Gatta (rgatta)    21-Oct-2000
    Rewrite + Cleanup + New Functions

--*/

#include "precomp.h"
#pragma hdrstop

#define DNS_HOMENET_DOT         L"."

ULONG               g_PrivateIPAddr = 0;
CRITICAL_SECTION    DnsTableLock;   // protects both tables
RTL_GENERIC_TABLE   g_DnsTable,
                    g_ReverseDnsTable;


//
// FORWARD DECLARATIONS
//

ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    );


RTL_GENERIC_COMPARE_RESULTS 
TableNameCompareRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine Description:

    This is a callback routine to compare two DNS_ENTRY structures.
    It is used by the RTL table implementation.

Arguments:

    Table - pointer to the RTL table. Not used.

    FirstStruct - the first DNS_ENTRY structure

    SecondStruct - the second DNS_ENTRY structure

Return Value:

    One of GenericLessThan, GenericGreaterThan, or GenericEqual,
    depending on the relative values of the parameters.

Environment:

    Called back by the Rtl table lookup routines.

--*/

{
    INT     iCompareResults;
    BOOL    fNamesAreEqual;
    WCHAR   *pszFirstName, *pszSecondName;

    PROFILE("TableNameCompareRoutine");

    pszFirstName = ((PDNS_ENTRY)FirstStruct)->pszName;
    pszSecondName = ((PDNS_ENTRY)SecondStruct)->pszName;

    fNamesAreEqual = DnsNameCompare_W(pszFirstName, pszSecondName);

    if (fNamesAreEqual)
    {
        iCompareResults = 0;
    }
    else
    {
        iCompareResults = _wcsicmp(pszFirstName, pszSecondName);
    }

    if (iCompareResults < 0)
    {
        return GenericLessThan;
    }
    else if (iCompareResults > 0)
    {
        return GenericGreaterThan;
    }
    else
    {
        return GenericEqual;
    }
}

RTL_GENERIC_COMPARE_RESULTS 
TableAddressCompareRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine Description:

    This is a callback routine to compare two REVERSE_DNS_ENTRY structures.
    It is used by the RTL table implementation.

Arguments:

    Table - pointer to the RTL table. Not used.

    FirstStruct - the first REVERSE_DNS_ENTRY structure

    SecondStruct - the second REVERSE_DNS_ENTRY structure

Return Value:

    One of GenericLessThan, GenericGreaterThan, or GenericEqual,
    depending on the relative values of the parameters.

Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    DNS_ADDRESS Address1, Address2;

    PROFILE("TableAddressCompareRoutine");

    Address1 = ((PREVERSE_DNS_ENTRY)FirstStruct)->ulAddress;
    Address2 = ((PREVERSE_DNS_ENTRY)SecondStruct)->ulAddress;

    if (Address1 > Address2)
    {
        return GenericGreaterThan;
    }
    else if (Address1 < Address2)
    {
        return GenericLessThan;
    }
    else
    {
        return GenericEqual;
    }
}


PVOID
TableAllocateRoutine(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )
/*++

Routine Description:

    This is a callback routine to allocate memory for an Rtl table.

Arguments:

    Table - pointer to the RTL table. Not used.

    ByteSize - the number of bytes to allocate

    SecondStruct - the second DNS_ENTRY structure

Return Value:

    A pointer to the allocated memory.

Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    return NH_ALLOCATE(ByteSize);
}

VOID
TableFreeRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID pBuffer
    )
/*++

Routine Description:

    This is a callback routine to free memory allocated by TableAllocateRoutine.

Arguments:

    Table - pointer to the RTL table. Not used.

    pBuffer - pointer to the buffer to free

Return Value:

    None
    
Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    NH_FREE(pBuffer);
}



ULONG
DnsInitializeTableManagement(
    VOID
    )
/*++

Routine Description:

    This is a public function that must be called before any of the other Dns
    table functions. It initializes the various tables used by the server.

Arguments:

    None

Return Value:

    None
    
Environment:

    Arbitrary.

--*/
{
    ULONG Error = NO_ERROR;

    PROFILE("DnsInitializeTableManagement");

    __try {
        InitializeCriticalSection(&DnsTableLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsInitializeTableManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    RtlInitializeGenericTable(
        &g_DnsTable,
        TableNameCompareRoutine,
        TableAllocateRoutine,
        TableFreeRoutine,
        NULL
        );

    RtlInitializeGenericTable(
        &g_ReverseDnsTable,
        TableAddressCompareRoutine,
        TableAllocateRoutine,
        TableFreeRoutine,
        NULL
        );

    return Error;
} // DnsInitializeTableManagement



VOID
DnsShutdownTableManagement(
    VOID
    )
/*++

Routine Description:

    This routine is called to shutdown the table management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/
{
    PROFILE("DnsShutdownTableManagement");

    DnsEmptyTables();

    DeleteCriticalSection(&DnsTableLock);

} // DnsShutdownTableManagement



VOID
DnsEmptyTables(
    VOID
    )
/*++

Routine Description:

    This routine is called to empty the DNS tables.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/
{
    ULONG               i, count;
    PDNS_ENTRY          pDnsEntry;
    REVERSE_DNS_ENTRY   reverseEntry;
    PREVERSE_DNS_ENTRY  pRDnsEntry;
    WCHAR              *pszNameCopy;
    
    PROFILE("DnsEmptyTables");

    //
    // for each entry in the forward table, delete all the entries in the
    // reverse table
    //

    //
    // emptying table in LIFO order
    //

    EnterCriticalSection(&DnsTableLock);

    count = RtlNumberGenericTableElements(&g_DnsTable);

    while (count)
    {
        pDnsEntry = (PDNS_ENTRY) RtlGetElementGenericTable(
                                     &g_DnsTable,
                                     --count
                                     );

        reverseEntry.pszName = NULL;

        for (i = 0; i < pDnsEntry->cAddresses; i++)
        {
            reverseEntry.ulAddress = pDnsEntry->aAddressInfo[i].ulAddress;
            RtlDeleteElementGenericTable(
                &g_ReverseDnsTable,
                &reverseEntry
                );
        }

        pszNameCopy = pDnsEntry->pszName;

        NH_FREE(pDnsEntry->aAddressInfo);
        pDnsEntry->aAddressInfo = NULL;
    
        RtlDeleteElementGenericTable(
            &g_DnsTable,
            pDnsEntry
            );

        NH_FREE(pszNameCopy);
    }
    
    //
    // the forward table should be empty by now
    //

    ASSERT(RtlIsGenericTableEmpty(&g_DnsTable));

    //
    // ensure that the reverse table is also empty
    //

    count = RtlNumberGenericTableElements(&g_ReverseDnsTable);

    while (count)
    {
        pRDnsEntry = (PREVERSE_DNS_ENTRY) RtlGetElementGenericTable(
                                              &g_ReverseDnsTable,
                                              --count
                                              );

        RtlDeleteElementGenericTable(
            &g_ReverseDnsTable,
            pRDnsEntry
            );
    }

    LeaveCriticalSection(&DnsTableLock);

} // DnsEmptyTables



BOOL
DnsRegisterName(
    WCHAR *pszName,
    UINT cAddresses,
    ADDRESS_INFO aAddressInfo[]
    )
/*++

Routine Description:

    Public function to register a DNS name in the server's table.

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    cAddresses - Number of addresses associated with this name

    aAddressInfo - Array of address information (addresses in network order)

Return Value:

    TRUE if the registration was for a new name (the name did not already exist
    in the table); FALSE if the name already existed and was replaced.
    FALSE also if there was an error condition.
    
Environment:

    Arbitrary

--*/
{
    DNS_ENTRY           dnsEntry;
    DWORD               cAddressesAllocated = 0;
    REVERSE_DNS_ENTRY   reverseDnsEntry;
    BOOLEAN             fNewElement = TRUE,
                        fNameIsNew = FALSE,
                        fDoCleanupTables = FALSE;
    UINT                i;
    
    PROFILE("DnsRegisterName");
    ASSERT(pszName); ASSERT(cAddresses); ASSERT(aAddressInfo);
    NhTrace(
        TRACE_FLAG_DNS,
        "DnsRegisterName: Registering name %S, with %d addresses",
        pszName,
        cAddresses
        );

    for (i = 0; i < cAddresses; i++)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsRegisterName: Address %d = %lx",
            i,
            aAddressInfo[i].ulAddress
            );
    }
    
    dnsEntry.pszName = (PWCHAR) NH_ALLOCATE((wcslen(pszName) + 1) * sizeof(WCHAR));

    if (!dnsEntry.pszName)
    {
        return fNameIsNew; // currently set to FALSE
    }
    
    wcscpy(dnsEntry.pszName, pszName);

    if (cAddresses == 1)
    {
        // In general, all names will have one address; so if we're just registering
        // one name, then only allocate enough space for one name.
        cAddressesAllocated = 1;
    }
    else
    {
        // If we have more than one address, then allocate in increments of 5.
        cAddressesAllocated = ((cAddresses + 4) / 5) * 5;
    }

    dnsEntry.aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(cAddressesAllocated * sizeof(ADDRESS_INFO));

    if (!dnsEntry.aAddressInfo)
    {
        NH_FREE(dnsEntry.pszName);
        return fNameIsNew; // currently set to FALSE
    }

    memcpy(dnsEntry.aAddressInfo, aAddressInfo, cAddresses * sizeof(ADDRESS_INFO));

    dnsEntry.cAddresses = cAddresses;
    dnsEntry.cAddressesAllocated = cAddressesAllocated;

    EnterCriticalSection(&DnsTableLock);

    RtlInsertElementGenericTable(
        &g_DnsTable,
        &dnsEntry,
        sizeof(dnsEntry),
        &fNameIsNew
        );

    reverseDnsEntry.pszName = dnsEntry.pszName;
    for (i = 0; i < cAddresses; i++)
    {
        PREVERSE_DNS_ENTRY  pEntry;

        reverseDnsEntry.ulAddress = dnsEntry.aAddressInfo[i].ulAddress;
        pEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                          &g_ReverseDnsTable,
                                          &reverseDnsEntry,
                                          sizeof(reverseDnsEntry),
                                          &fNewElement
                                          );
        // If this IP address is already in the reverse table, then replace it.
        if (pEntry && !fNewElement)
        {
            fDoCleanupTables = TRUE;
            pEntry->pszName = dnsEntry.pszName;
        }
    }

    LeaveCriticalSection(&DnsTableLock);

    if (fDoCleanupTables)
    {
        DnsCleanupTables();
    }

    return fNameIsNew;
} // DnsRegisterName



VOID
DnsAddAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress,
    FILETIME    ftExpires
    )
/*++

Routine Description:

    Public function to add an IP address for a name that potentially
    already exists.

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    ulAddress - New IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY  pEntry;

    PROFILE("DnsAddAddressForName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry == NULL)
    {
        ADDRESS_INFO    info;

        info.ulAddress = ulAddress;
        info.ftExpires = ftExpires;
        //info.ulExpires = ulExpires;
        DnsRegisterName(pszName, 1, &info);
    }
    else
    {
        UINT     i;
        REVERSE_DNS_ENTRY   reverseDnsEntry;
        PREVERSE_DNS_ENTRY  pReverseEntry;
        BOOLEAN             fNewElement;
        
        // first, let's make sure that this IP address isn't already associated with
        // this name.

        for (i = 0; i < pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                //
                // simply update the expiry time
                //
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsAddAddressForName: Refresh expiry time for %S",
                    pszName
                    );
                pEntry->aAddressInfo[i].ftExpires = ftExpires;
                return; 
            }
        }

        //
        // we limit the number of addresses per machine name to one only
        //
        
        //
        // guard against zero allocation
        //
        if (!pEntry->cAddressesAllocated)
        {
            pEntry->aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(1 * sizeof(ADDRESS_INFO));

            if (pEntry->aAddressInfo)
            {
                pEntry->cAddressesAllocated = 1;
            }
            else
            {
                // no memory - return quitely
                return;
            }
        }

        //
        // at least 1 block has been allocated
        //
        pEntry->cAddresses = 1;
        pEntry->aAddressInfo[0].ulAddress = ulAddress;
        pEntry->aAddressInfo[0].ftExpires = ftExpires;

        
        reverseDnsEntry.ulAddress = ulAddress;
        reverseDnsEntry.pszName = pEntry->pszName;

        EnterCriticalSection(&DnsTableLock);
        
        pReverseEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &reverseDnsEntry,
                                                 sizeof(reverseDnsEntry),
                                                 &fNewElement
                                                 );
        // If this IP address is already in the reverse table, then replace it.
        if (pReverseEntry && !fNewElement)
        {
            pReverseEntry->pszName = pEntry->pszName;
        }

        LeaveCriticalSection(&DnsTableLock);

        if (!fNewElement)
        {
            DnsCleanupTables();
        }
    }
} // DnsAddAddressForName



VOID
DnsDeleteAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to un-associate an IP address from a given name,
    and potentially delete the record from the table if there are no more
    IP addresses associated with the name.

Arguments:

    pszName - Name, in Unicode, dotted-name format.

    ulAddress - IP address to un-associate with the given name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY  pEntry;
    REVERSE_DNS_ENTRY   reverseEntry;

    PROFILE("DnsDeleteAddressForName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry != NULL)
    {
        INT i, iLocation = -1;

        // Find the index of the requested address
        for (i = 0; i < (INT)pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                iLocation = i;
                break;
            }
        }

        if (iLocation > -1)
        {
            if (pEntry->cAddresses > 1)
            {
                // Move the rest of the array backwards
                memcpy(&pEntry->aAddressInfo[iLocation], 
                        &pEntry->aAddressInfo[iLocation + 1],
                        (pEntry->cAddresses - 1 - iLocation) * sizeof(ADDRESS_INFO));
                pEntry->cAddresses--;
            }
            else
            {
                // Delete the whole entry - it no longer has any IP addresses associated
                // with it.
                DnsDeleteName(pszName);
            }
        }
    }

    reverseEntry.pszName = NULL;
    reverseEntry.ulAddress = ulAddress;

    EnterCriticalSection(&DnsTableLock);

    RtlDeleteElementGenericTable(
        &g_ReverseDnsTable,
        &reverseEntry
        );

    LeaveCriticalSection(&DnsTableLock);
} // DnsDeleteAddressForName



PDNS_ENTRY
DnsPurgeExpiredNames(
    PDNS_ENTRY pEntry
    )
/*++

Routine Description:

    TODO.

Arguments:

    TODO
    
Return Value:

    TODO
    

Environment:

    TODO.

--*/
{
    UINT i, j;
    FILETIME ftTime;
    REVERSE_DNS_ENTRY  reverseEntry;

    PROFILE("DnsPurgeExpiredNames");

    GetSystemTimeAsFileTime(&ftTime);
    reverseEntry.pszName = NULL;

    for (j = 1; j < pEntry->cAddresses + 1; j++)
    {
        // j is 1-based so that we can safely subtract 1 from it below (it's unsigned).
        // we really want the 0-based number, so we translate that to i immediately.
        
        i = j - 1;
        if (IsFileTimeExpired(&pEntry->aAddressInfo[i].ftExpires))
        {
            NhTrace(TRACE_FLAG_DNS, "DnsPurgeExpiredNames: Deleting address %lx for name %ls",
                        pEntry->aAddressInfo[i].ulAddress,
                        pEntry->pszName);
            reverseEntry.ulAddress = pEntry->aAddressInfo[i].ulAddress;
            RtlDeleteElementGenericTable(
                &g_ReverseDnsTable,
                &reverseEntry
                );
            
            memcpy(&pEntry->aAddressInfo[i], &pEntry->aAddressInfo[i+1],
                    (pEntry->cAddresses - i - 1) * sizeof(ADDRESS_INFO));
            pEntry->cAddresses--;
            j--;
        }
    }

    if (pEntry->cAddresses == 0)
    {
        WCHAR   *pszName;

        pszName = pEntry->pszName;
        NH_FREE(pEntry->aAddressInfo);
        pEntry->aAddressInfo = NULL;
        
        RtlDeleteElementGenericTable(
            &g_DnsTable,
            pEntry
            );

        NH_FREE(pszName);

        pEntry = NULL;
    }

    return pEntry;
} // DnsPurgeExpiredNames



PDNS_ENTRY
DnsLookupAddress(
    WCHAR *pszName
    )
/*++

Routine Description:

    Public function to look up the address of a given name.

Arguments:

    pszName - Name to look up, in Unicode, dotted name format.

Return Value:

    A pointer to the DNS_ENTRY value that is in the table. Note that 
    this is not a copy, so a) it should not be freed by the caller, and
    b) any modifications made to the data will be reflected in the table.

    If the name is not found, the function will return NULL.

    Addresses are stored in network order.

Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY      pEntry;
    DNS_ENTRY       dnsSearch;

    PROFILE("DnsLookupAddress");

    dnsSearch.pszName = pszName;
    dnsSearch.cAddresses = 0;

    EnterCriticalSection(&DnsTableLock);

    pEntry = (PDNS_ENTRY) RtlLookupElementGenericTable(
                              &g_DnsTable,
                              &dnsSearch
                              );

    if (pEntry)
    {
        pEntry = DnsPurgeExpiredNames(pEntry);
    }

    LeaveCriticalSection(&DnsTableLock);

    return pEntry;
} // DnsLookupAddress



PREVERSE_DNS_ENTRY
DnsLookupName(
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to look up the name of a given address.

Arguments:

    ulAddress - network order address.

Return Value:

    A pointer to the REVERSE_DNS_ENTRY value that is in the table. Note that 
    this is not a copy, so a) it should not be freed by the caller, and
    b) any modifications made to the data will be reflected in the table.

    If the address is not found, the function will return NULL.

Environment:

    Arbitrary.

--*/
{
    PREVERSE_DNS_ENTRY  pEntry;
    REVERSE_DNS_ENTRY   dnsSearch;

    PROFILE("DnsLookupName");

    dnsSearch.ulAddress = ulAddress;
    dnsSearch.pszName = NULL;

    EnterCriticalSection(&DnsTableLock);

    pEntry = (PREVERSE_DNS_ENTRY) RtlLookupElementGenericTable(
                                      &g_ReverseDnsTable,
                                      &dnsSearch
                                      );

    LeaveCriticalSection(&DnsTableLock);

    return pEntry;
} // DnsLookupName



VOID
DnsDeleteName(
    WCHAR *pszName
    )
/*++

Routine Description:

    Public function to delete a given name from the DNS table.

Arguments:

    pszName - Name to delete.

Return Value:

    None.

Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY          pEntry;
    REVERSE_DNS_ENTRY   reverseEntry;
    UINT                i;
    WCHAR               *pszNameCopy;

    PROFILE("DnsDeleteName");

    pEntry = DnsLookupAddress(pszName);

    reverseEntry.pszName = NULL;

    EnterCriticalSection(&DnsTableLock);

    for (i = 0; i < pEntry->cAddresses; i++)
    {
        reverseEntry.ulAddress = pEntry->aAddressInfo[i].ulAddress;
        RtlDeleteElementGenericTable(
            &g_ReverseDnsTable,
            &reverseEntry
            );
    }

    pszNameCopy = pEntry->pszName;
    NH_FREE(pEntry->aAddressInfo);
    pEntry->aAddressInfo = NULL;
    
    RtlDeleteElementGenericTable(
        &g_DnsTable,
        pEntry
        );

    LeaveCriticalSection(&DnsTableLock);

    NH_FREE(pszNameCopy);
} // DnsDeleteName



VOID
DnsUpdateName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to add an IP address for a name that potentially
    already exists. If both name and address exist, we update the time
    in the table for a fresh lease

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    ulAddress - (possibly new) IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY      pEntry;
    FILETIME        ftExpires;
    LARGE_INTEGER   liExpires, liTime, liNow;
    BOOL            fWriteToStore = FALSE;
    BOOLEAN         fNewElement = TRUE; // refers to reverse table entry

    GetSystemTimeAsFileTime(&ftExpires);    // current UTC time
    memcpy(&liNow, &ftExpires, sizeof(LARGE_INTEGER));
    //
    // current cache table expiry time is fixed - put in registry afterwards
    //
    liTime = RtlEnlargedIntegerMultiply(CACHE_ENTRY_EXPIRY, SYSTIME_UNITS_IN_1_SEC);
    liExpires = RtlLargeIntegerAdd(liTime, liNow);;
    memcpy(&ftExpires, &liExpires, sizeof(LARGE_INTEGER));

    PROFILE("DnsUpdateName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry == NULL)
    {
        ADDRESS_INFO    info;

        info.ulAddress = ulAddress;
        info.ftExpires = ftExpires;
        DnsRegisterName(pszName, 1, &info);

        fWriteToStore = TRUE;
    }
    else
    {
        UINT     i;
        REVERSE_DNS_ENTRY   reverseDnsEntry;
        PREVERSE_DNS_ENTRY  pReverseEntry;
        
        // first, let's make sure that this IP address isn't already associated with
        // this name.

        for (i = 0; i < pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                //
                // simply update the expiry time
                //
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdateName: Refresh expiry time for %S",
                    pszName
                    );
                pEntry->aAddressInfo[i].ftExpires = ftExpires;
                return;
            }
        }

        //
        // we limit the number of addresses per machine name to one only
        //

        //
        // guard against zero allocation
        //
        if (!pEntry->cAddressesAllocated)
        {
            pEntry->aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(1 * sizeof(ADDRESS_INFO));

            if (pEntry->aAddressInfo)
            {
                pEntry->cAddressesAllocated = 1;
            }
            else
            {
                // no memory - return quitely
                return;
            }
        }

        //
        // at least 1 block has been allocated
        //
        pEntry->cAddresses = 1;
        pEntry->aAddressInfo[0].ulAddress = ulAddress;
        pEntry->aAddressInfo[0].ftExpires = ftExpires;
        
        reverseDnsEntry.ulAddress = ulAddress;
        reverseDnsEntry.pszName = pEntry->pszName;

        EnterCriticalSection(&DnsTableLock);
        
        pReverseEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &reverseDnsEntry,
                                                 sizeof(reverseDnsEntry),
                                                 &fNewElement
                                                 );
        // If this IP address is already in the reverse table, then replace it.
        if (pReverseEntry && !fNewElement)
        {
            pReverseEntry->pszName = pEntry->pszName;
        }

        LeaveCriticalSection(&DnsTableLock);

        if (!fNewElement)
        {
            DnsCleanupTables();
        }

        fWriteToStore = TRUE;
    }

    if (fWriteToStore)
    {
        SaveHostsIcsFile(FALSE);
    }
} // DnsUpdateName



VOID
DnsUpdate(
    CHAR *pName,
    ULONG len,
    ULONG ulAddress
    )
/*++

Routine Description:

    Called from the DHCP component to simulate Dynamic DNS.

Arguments:

    pName - hostname to register, in wire format.

    len - length of hostname

    ulAddress - (possibly new) IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PROFILE("DnsUpdate");

    //
    // convert string to a Unicode string and update table
    //

    DWORD  dwSize = 0;
    DWORD  Error = NO_ERROR;
    LPVOID lpMsgBuf = NULL;
    LPBYTE pszName = NULL;
    PWCHAR pszUnicodeFQDN = NULL;

    if (NULL == pName || 0 == len || '\0' == *pName)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsUpdate: No Name present - discard DNS Update"
            );
        return;
    }

    do
    {
        EnterCriticalSection(&DnsGlobalInfoLock);

        if (!DnsICSDomainSuffix)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: DnsICSDomainSuffix string not present - update failed!"
                );
            break;
        }

        //
        // create a null terminated copy
        //
        dwSize = len + 4;
        pszName = reinterpret_cast<LPBYTE>(NH_ALLOCATE(dwSize));
        if (!pszName)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: allocation failed for hostname copy buffer"
                );
            break;
        }
        ZeroMemory(pszName, dwSize);
        memcpy(pszName, pName, len);
        pszName[len] = '\0';

        //
        // NOTE: the RFCs are unclear about how to handle hostname option.
        // try out different codepage conversions to unicode in order of:
        // OEM, ANSI, MAC and finally give UTF8 a try
        // our default conversion is to use mbstowcs()
        //

        //
        // try OEM to Unicode conversion
        //
        Error = DnsConvertHostNametoUnicode(
                    CP_OEMCP,
                    (PCHAR)pszName,
                    DnsICSDomainSuffix,
                    &pszUnicodeFQDN
                    );
        if (Error)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: DnsConvertHostName(OEM)toUnicode failed with "
                "Error %ld (0x%08x)",
                Error,
                Error
                );

            if (pszUnicodeFQDN)
            {
                NH_FREE(pszUnicodeFQDN);
                pszUnicodeFQDN = NULL;
            }
        }

        //
        // try ANSI to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_ACP,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(ANSI)toUnicode failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }

        //
        // try MAC to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_MACCP,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(MAC)toUnicode() failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }
        
        //
        // try UTF8 to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_UTF8,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(UTF8)toUnicode() failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }
        
        //
        // default conversion
        //
        if (!pszUnicodeFQDN)
        {
            dwSize = len                        +
                     wcslen(DNS_HOMENET_DOT)    +
                     wcslen(DnsICSDomainSuffix) +
                     1;
            pszUnicodeFQDN = reinterpret_cast<PWCHAR>(NH_ALLOCATE(sizeof(WCHAR) * dwSize));
            if (!pszUnicodeFQDN)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: allocation failed for client name"
                    );
                break;
            }
            ZeroMemory(pszUnicodeFQDN, (sizeof(WCHAR) * dwSize));

            mbstowcs(pszUnicodeFQDN, (char *)pszName, len);
            wcscat(pszUnicodeFQDN, DNS_HOMENET_DOT);    // add the dot
            wcscat(pszUnicodeFQDN, DnsICSDomainSuffix); // add the suffix
        }

        LeaveCriticalSection(&DnsGlobalInfoLock);

        DnsUpdateName(
            pszUnicodeFQDN,
            ulAddress
            );

        NH_FREE(pszName);
        NH_FREE(pszUnicodeFQDN);
        return;

    } while (FALSE);

    LeaveCriticalSection(&DnsGlobalInfoLock);

    if (pszName)
    {
        NH_FREE(pszName);
    }

    if (pszUnicodeFQDN)
    {
        NH_FREE(pszUnicodeFQDN);
    }
    
    return;
} // DnsUpdate



VOID
DnsAddSelf(
    VOID
    )
/*++

Routine Description:

    Called each time we do a load of the hosts.ics file

Arguments:

    none.
    
Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PROFILE("DnsAddSelf");

    DWORD           len = 512, dwSize = 0;
    WCHAR           pszCompNameBuf[512];
    PWCHAR          pszBuf = NULL;
    LPVOID          lpMsgBuf;
    ULONG           ulAddress = 0;
    FILETIME        ftExpires;
    LARGE_INTEGER   liExpires, liTime, liNow;
    
    ZeroMemory(pszCompNameBuf, (sizeof(WCHAR) * len));

    if (!GetComputerNameExW(
            ComputerNameDnsHostname,//ComputerNameNetBIOS,
            pszCompNameBuf,
            &len
            )
       )
    {
        lpMsgBuf = NULL;
        
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
            );
            
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsAddSelf: GetComputerNameExW failed with message: %S",
            lpMsgBuf
            );
        
        if (lpMsgBuf) LocalFree(lpMsgBuf);
    }
    else
    {
        //
        // we query the DHCP component if it is active for an IP address
        // because it has scope information also. if this fails, we revert
        // to the DNS component's list of interface addresses
        //
        
        //
        // check if DHCP component is active
        //
        if (REFERENCE_DHCP())
        {
            ulAddress = DhcpGetPrivateInterfaceAddress();

            DEREFERENCE_DHCP();
        }

        if (!ulAddress)
        {
            ulAddress = DnsGetPrivateInterfaceAddress();
        }

        if (!ulAddress)
        {
            //
            // could not retreive correct IP address - use cached address
            //
            ulAddress = g_PrivateIPAddr;
        }
        else
        {
            //
            // got some valid address
            //
            g_PrivateIPAddr = ulAddress;
        }
    
        if (ulAddress)
        {
            if (DnsICSDomainSuffix)
            {
                EnterCriticalSection(&DnsGlobalInfoLock);

                dwSize = len                        +
                         wcslen(DNS_HOMENET_DOT)    +
                         wcslen(DnsICSDomainSuffix) +
                         1;

                pszBuf = reinterpret_cast<PWCHAR>(
                             NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                             );

                if (!pszBuf)
                {
                    LeaveCriticalSection(&DnsGlobalInfoLock);
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsAddSelf: allocation failed for client name"
                        );

                    return;
                }

                ZeroMemory(pszBuf, (sizeof(WCHAR) * dwSize));

                wcscpy(pszBuf, pszCompNameBuf);     // copy the name
                wcscat(pszBuf, DNS_HOMENET_DOT);    // add the dot
                wcscat(pszBuf, DnsICSDomainSuffix); // add the suffix

                LeaveCriticalSection(&DnsGlobalInfoLock);

                GetSystemTimeAsFileTime(&ftExpires);    // current UTC time
                memcpy(&liNow, &ftExpires, sizeof(LARGE_INTEGER));
                liTime = RtlEnlargedIntegerMultiply((5 * 365 * 24 * 60 * 60), SYSTIME_UNITS_IN_1_SEC);
                liExpires = RtlLargeIntegerAdd(liTime, liNow);;
                memcpy(&ftExpires, &liExpires, sizeof(LARGE_INTEGER));

                DnsAddAddressForName(
                    pszBuf,
                    ulAddress,
                    ftExpires
                    );

                NH_FREE(pszBuf);
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsAddSelf: DnsICSDomainSuffix string not present - update failed!"
                    );
            }
        }
    }

    return;
} // DnsAddSelf



VOID
DnsCleanupTables(
    VOID
    )
/*++

Routine Description:

    Called each time we detect that there could be atleast one entry with
    an IP address not belonging to it anymore.

Arguments:

    none.
    
Return Value:

    None.
    
Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY          pFwdEntry;
    PREVERSE_DNS_ENTRY  pRevEntry;
    DNS_ENTRY           dnsFwdSearch;
    REVERSE_DNS_ENTRY   dnsRevSearch;
    BOOL                fDelEntry;
    UINT                i;
    PWCHAR              *GCArray = NULL;
    DWORD               GCCount  = 0,
                        GCSize   = 0;

    

    //
    // Enumerate through the forward DNS table - if the IP address(es)
    // for each forward entry have an entry in the reverse DNS table
    // and this reverse entry's name pointer does not point to us, then
    // delete this IP address from this forward entry
    //
    EnterCriticalSection(&DnsTableLock);

    pFwdEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, TRUE);

    while (pFwdEntry != NULL)
    {

        for (i = 0; i < pFwdEntry->cAddresses; i++)
        {
            pRevEntry = NULL;

            dnsRevSearch.ulAddress = pFwdEntry->aAddressInfo[i].ulAddress;
            dnsRevSearch.pszName = NULL;

            pRevEntry = (PREVERSE_DNS_ENTRY) RtlLookupElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &dnsRevSearch
                                                 );
            if ((!pRevEntry) ||
                ((pRevEntry) && 
                 (pRevEntry->pszName != pFwdEntry->pszName)))
            {
                //
                // Remove this IP address from the forward entry address list
                //
                if (pFwdEntry->cAddresses > 1)
                {
                    memcpy(&pFwdEntry->aAddressInfo[i], 
                           &pFwdEntry->aAddressInfo[i + 1],
                          (pFwdEntry->cAddresses - 1 - i) * sizeof(ADDRESS_INFO));
                    pFwdEntry->cAddresses--;
                }
                else
                {
                    //
                    // Single "invalid" IP address - zero the count
                    //
                    pFwdEntry->cAddresses = 0;
                    NH_FREE(pFwdEntry->aAddressInfo);
                    pFwdEntry->aAddressInfo = NULL;
                    break;
                }
            }
        }

        if (0 == pFwdEntry->cAddresses)
        {
            //
            // Remember this entry name
            //
            if (GCSize <= GCCount)
            {
                PWCHAR *tmpGCArray = NULL;
                DWORD   tmpGCSize = 0;

                // Allocate in increments of five
                tmpGCSize = ((GCCount + 5) / 5) * 5;
                tmpGCArray = (PWCHAR *) NH_ALLOCATE(tmpGCSize * sizeof(PWCHAR));

                if (tmpGCArray)
                {
                    if (GCArray)
                    {
                        memcpy(tmpGCArray, GCArray, (GCCount * sizeof(PWCHAR)));

                        NH_FREE(GCArray);
                    }

                    GCSize = tmpGCSize;
                    GCArray = tmpGCArray;

                    //
                    // add it to our array
                    //
                    GCArray[GCCount++] = pFwdEntry->pszName;
                }
            }
            else
            {
                //
                // add it to our array
                //
                GCArray[GCCount++] = pFwdEntry->pszName;
            }
        }

        pFwdEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, FALSE);

    }

    //
    // Garbage collect after complete enumeration
    //
    for (i = 0; i < GCCount; i++)
    {
        dnsFwdSearch.pszName = GCArray[i];
        dnsFwdSearch.cAddresses = 0;

        pFwdEntry = (PDNS_ENTRY) RtlLookupElementGenericTable(
                                  &g_DnsTable,
                                  &dnsFwdSearch
                                  );

        if (pFwdEntry)
        {
            //
            // (1) we have a copy of pointer to name as in GCArray[i]
            // (2) aAddressInfo has already been taken care of above
            // (3) only need to get rid of FwdEntry struct from table
            //
            RtlDeleteElementGenericTable(
                &g_DnsTable,
                pFwdEntry
                );

            //
            // done after the fwd entry was deleted from fwd DNS table
            //
            NH_FREE(GCArray[i]);
        }
        GCArray[i] = NULL;
    }

    LeaveCriticalSection(&DnsTableLock);

    if (GCArray)
    {
        NH_FREE(GCArray);
    }

    return;
} // DnsCleanupTables


//
// Utility conversion routines
//

DWORD
DnsConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pszHostName,
    PWCHAR DnsICSDomainSuffix,
    PWCHAR *ppszUnicodeFQDN
    )
{

    PROFILE("DnsConvertHostNametoUnicode");

    //
    // make sure to free the returned UnicodeFQDN
    // caller holds DnsGlobalInfoLock
    //
    
    DWORD  dwSize = 0;
    DWORD  Error = NO_ERROR;
    LPBYTE pszUtf8HostName = NULL;  // copy of pszHostName in Utf8 format
    PWCHAR pszUnicodeHostName = NULL;
    PWCHAR pszUnicodeFQDN = NULL;
    
    //
    // convert the given hostname to a Unicode string
    //

    if (CP_UTF8 == CodePage)
    {
        pszUtf8HostName = (LPBYTE)pszHostName;
    }
    else
    {
        //
        // now convert this into UTF8 format
        //
        if (!ConvertToUtf8(
                 CodePage,
                 (LPSTR)pszHostName,
                 (PCHAR *)&pszUtf8HostName,
                 &dwSize))
        {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsConvertHostNametoUnicode: conversion from "
                "CodePage %d to UTF8 for hostname failed "
                "with error %ld (0x%08x)",
                CodePage,
                Error,
                Error
                );
            if (pszUtf8HostName)
            {
                NH_FREE(pszUtf8HostName);
            }
            return Error;
        }
    }

    //
    // now convert this into Unicode format
    //
    if (!ConvertUTF8ToUnicode(
                 pszUtf8HostName,
                 (LPWSTR *)&pszUnicodeHostName,
                 &dwSize))
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsConvertHostNametoUnicode: conversion from "
            "UTF8 to Unicode for hostname failed "
            "with error %ld (0x%08x)",
            Error,
            Error
            );
        if (CP_UTF8 != CodePage)
        {
            NH_FREE(pszUtf8HostName);
        }
        if (pszUnicodeHostName)
        {
            NH_FREE(pszUnicodeHostName);
        }
        return Error;
    }

    dwSize += sizeof(WCHAR)*(wcslen(DNS_HOMENET_DOT)+wcslen(DnsICSDomainSuffix)+1);
    pszUnicodeFQDN = reinterpret_cast<PWCHAR>(NH_ALLOCATE(dwSize));
    if (!pszUnicodeFQDN)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsConvertHostNametoUnicode: allocation failed "
            "for Unicode FQDN"
            );
        if (CP_UTF8 != CodePage)
        {
            NH_FREE(pszUtf8HostName);
        }
        NH_FREE(pszUnicodeHostName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(pszUnicodeFQDN, dwSize);

    wcscpy(pszUnicodeFQDN, pszUnicodeHostName); // copy the name
    wcscat(pszUnicodeFQDN, DNS_HOMENET_DOT);    // add the dot
    wcscat(pszUnicodeFQDN, DnsICSDomainSuffix); // add the suffix

    *ppszUnicodeFQDN = pszUnicodeFQDN;
    if (CP_UTF8 != CodePage)
    {
        NH_FREE(pszUtf8HostName);
    }
    NH_FREE(pszUnicodeHostName);

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsConvertHostNametoUnicode: succeeded! %S",
        pszUnicodeFQDN
        );

    return Error;

} // DnsConvertHostNametoUnicode


BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    )
/*++

Routine Description:

    This functions converts an specified CodePage string to Utf8 format.

Arguments:

    pszName - Buffer to the hostname string which is null terminated.

    ppszUtf8Name - receives Pointer to the buffer receiving Utf8 string.

    BufSize - receives Length of the above buffer in bytes.
    
Return Value:

    TRUE on successful conversion.

--*/
{
    DWORD Error = NO_ERROR;
    DWORD dwSize = 0;
    PCHAR pszUtf8Name = NULL;
    LPWSTR pBuf = NULL;

    DWORD Count;

    Count = MultiByteToWideChar(
                CodePage,
                MB_ERR_INVALID_CHARS,
                pszName,
                -1,
                pBuf,
                0
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        return FALSE;
    }
    dwSize = Count * sizeof(WCHAR);
    pBuf = reinterpret_cast<LPWSTR>(NH_ALLOCATE(dwSize));
    if (!pBuf)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: allocation failed for temporary wide char buffer"
            );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pBuf, dwSize);

    Count = MultiByteToWideChar(
                CodePage,
                MB_ERR_INVALID_CHARS,
                pszName,
                -1,
                pBuf,
                Count
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        NH_FREE(pBuf);
        return FALSE;
    }

    Count = WideCharToMultiByte(
                CP_UTF8,
                0,
                pBuf,
                -1,
                pszUtf8Name,
                0,
                NULL,
                NULL
                );
    dwSize = Count;
    pszUtf8Name = reinterpret_cast<PCHAR>(NH_ALLOCATE(dwSize));
    if (!pszUtf8Name)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: allocation failed for Utf8 char buffer"
            );
            NH_FREE(pBuf);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pszUtf8Name, dwSize);

    Count = WideCharToMultiByte(
                CP_UTF8,
                0,
                pBuf,
                -1,
                pszUtf8Name,
                Count,
                NULL,
                NULL
                );

    //
    // N.B. Looks like there is no such thing as a default
    // character for UTF8 - so we have to assume this
    // succeeded..
    // if any default characters were used, then it can't be
    // converted actually.. so don't allow this
    //

    NH_FREE(pBuf);

    *ppszUtf8Name = pszUtf8Name;
    *pUtf8NameSize = dwSize;

    return (Count != 0);

} // ConvertToUtf8



BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    )
/*++

Routine Description:

    This functions converts Utf8 format to Unicodestring.

Arguments:

    UTF8String - Buffer to UTFString which is null terminated.

    ppszUnicodeName - receives Pointer to the buffer receiving Unicode string.

    pUnicodeLength - receives Length of the above buffer in bytes.

Return Value:

    TRUE on successful conversion.

--*/
{

    DWORD Count, dwSize = 0, Error = NO_ERROR;
    LPWSTR pBuf = NULL;

    Count = MultiByteToWideChar(
                CP_UTF8,
                0,
                (LPCSTR)UTF8String,
                -1,
                pBuf,
                0
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        return FALSE;
    }
    dwSize = Count * sizeof(WCHAR);
    pBuf = reinterpret_cast<LPWSTR>(NH_ALLOCATE(dwSize));
    if (!pBuf)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: allocation failed for unicode string buffer"
            );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pBuf, dwSize);

    Count = MultiByteToWideChar(
                CP_UTF8,
                0,
                (LPCSTR)UTF8String,
                -1,
                pBuf,
                Count
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        NH_FREE(pBuf);
        return FALSE;
    }

    *ppszUnicodeName = pBuf;
    *pUnicodeNameSize = dwSize;

    return (Count != 0);
    
} // ConvertUTF8ToUnicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <winsock2.h>
#include <windns.h>
#include <dnsapi.h>
#include <dnslib.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmdns.h"
#include "rmdhcp.h"

#include "dnsfile.h"
#include "dnsif.h"
#include "dnsio.h"
#include "dnslog.h"
#include "dnslookup.h"
#include "dnsmsg.h"
#include "dnsquery.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnslog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnslog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   25-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            02-Jan-2001
    Added IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED
        & IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX

--*/

#define IP_DNS_PROXY_LOG_BASE                       31000

#define IP_DNS_PROXY_LOG_NAT_INTERFACE_IGNORED      (IP_DNS_PROXY_LOG_BASE+1)
/*
 * The DNS proxy agent detected network address translation (NAT) enabled
 * on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_DNS_PROXY_LOG_ACTIVATE_FAILED            (IP_DNS_PROXY_LOG_BASE+2)
/*
 * The DNS proxy agent was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_RECEIVE_FAILED             (IP_DNS_PROXY_LOG_BASE+3)
/*
 * The DNS proxy agent encountered a network error while attempting to
 * receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_ALLOCATION_FAILED          (IP_DNS_PROXY_LOG_BASE+4)
/*
 * The DNS proxy agent was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_DNS_PROXY_LOG_RESPONSE_FAILED            (IP_DNS_PROXY_LOG_BASE+5)
/*
 * The DNS proxy agent encountered a network error while attempting
 * to forward a response to a client from a name-resolution server
 * on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_QUERY_FAILED               (IP_DNS_PROXY_LOG_BASE+6)
/*
 * The DNS proxy agent encountered a network error while attempting
 * to forward a query from the client %1 to the server %2
 * on the interface with IP address %3.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED       (IP_DNS_PROXY_LOG_BASE+7)
/*
 * The DNS proxy agent was unable to register for notification of changes
 * to the local list of DNS and WINS servers.
 * This may indicate that system resources are low.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_SERVER_LIST             (IP_DNS_PROXY_LOG_BASE+8)
/*
 * The DNS proxy agent was unable to read the local list of name-resolution
 * servers from the registry.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_SERVERS_LEFT            (IP_DNS_PROXY_LOG_BASE+9)
/*
 * The DNS proxy agent was unable to resolve a query from %1
 * after consulting all entries in the local list of name-resolution servers.
 */

#define IP_DNS_PROXY_LOG_DEMAND_DIAL_FAILED         (IP_DNS_PROXY_LOG_BASE+10)
/*
 * The DNS proxy agent was unable to initiate a demand-dial connection
 * on the default interface while trying to resolve a query from %1.
 */

#define IP_DNS_PROXY_LOG_NO_DEFAULT_INTERFACE       (IP_DNS_PROXY_LOG_BASE+11)
/*
 * The DNS proxy agent was unable to resolve a query
 * because no list of name-resolution servers is configured locally
 * and no interface is configured as the default for name-resolution.
 * Please configure one or more name-resolution server addresses,
 * or configure an interface to be automatically dialed when a request
 * is received by the DNS proxy agent.
 */

#define IP_DNS_PROXY_LOG_ERROR_SERVER_LIST          (IP_DNS_PROXY_LOG_BASE+12)
/*
 * The DNS proxy agent encountered an error while obtaining the local list
 * of name-resolution servers.
 * Some DNS or WINS servers may be inaccessible to clients on the local network.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED  (IP_DNS_PROXY_LOG_BASE+13)
/*
 * The DNS proxy agent was unable to register for notification of changes
 * to the ICS Domain suffix string.
 * This may indicate that system resources are low.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX             (IP_DNS_PROXY_LOG_BASE+14)
/*
 * The DNS proxy agent was unable to read the ICS Domain suffix string
 * from the registry.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_MESSAGE_TOO_SMALL          (IP_DNS_PROXY_LOG_BASE+15)
/*
 * The DNS proxy agent received a message smaller than the
 * minimum message size.
 * The message has been discarded.
 */

#define IP_DNS_PROXY_LOG_END                        (IP_DNS_PROXY_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsquery.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsquery.h

Abstract:

    This module contains declarations for the DNS proxy's query-management.

Author:

    Abolade Gbadegesin (aboladeg)   11-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Added ICSDomain registry key change notify functions.

--*/

#ifndef _NATHLP_DNSQUERY_H_
#define _NATHLP_DNSQUERY_H_

//
// CONSTANT DECLARATIONS
//

#define DNS_QUERY_TIMEOUT   (4 * 1000)
#define DNS_QUERY_RETRY     3


//
// STRUCTURE DECLARATIONS
//

//
// Structure:   DNS_QUERY
//
// This structure holds information about a single pending DNS query.
// Each such entry is on an interface's list of pending queries,
// sorted on the 'QueryId' field.
// Access to the list is synchronized using the interface's lock.
//

typedef struct _DNS_QUERY {
    LIST_ENTRY Link;
    USHORT QueryId;
    USHORT SourceId;
    ULONG SourceAddress;
    USHORT SourcePort;
    DNS_PROXY_TYPE Type;
    ULONG QueryLength;
    PNH_BUFFER Bufferp;
    PDNS_INTERFACE Interfacep;
    HANDLE TimerHandle;
    ULONG RetryCount;
} DNS_QUERY, *PDNS_QUERY;

//
// GLOBAL VARIABLE DECLARATIONS
//

extern HANDLE DnsNotifyChangeKeyEvent;
extern HANDLE DnsNotifyChangeKeyWaitHandle;
extern PULONG DnsServerList[DnsProxyCount];
extern HANDLE DnsTcpipInterfacesKey;

extern HANDLE DnsNotifyChangeAddressEvent;
extern HANDLE DnsNotifyChangeAddressWaitHandle;
extern OVERLAPPED DnsNotifyChangeAddressOverlapped;

extern HANDLE DnsNotifyChangeKeyICSDomainEvent;
extern HANDLE DnsNotifyChangeKeyICSDomainWaitHandle;
extern HANDLE DnsTcpipParametersKey;
extern PWCHAR DnsICSDomainSuffix;



//
// ROUTINE DECLARATIONS
//

VOID
DnsDeleteQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp
    );

BOOLEAN
DnsIsPendingQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    );

PDNS_QUERY
DnsMapResponseToQuery(
    PDNS_INTERFACE Interfacep,
    USHORT ResponseId
    );

VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnsNotifyChangeKeyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnsNotifyChangeKeyICSDomainCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

ULONG
DnsQueryServerList(
    VOID
    );

ULONG
DnsQueryICSDomainSuffix(
    VOID
    );

PDNS_QUERY
DnsRecordQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    );

ULONG
DnsSendQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp,
    BOOLEAN Resend
    );

#endif // _NATHLP_DNSQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\dnsquery.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsquery.c

Abstract:

    This module contains code for the DNS proxy's query-management.

Author:

    Abolade Gbadegesin (aboladeg)   11-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Added ICSDomain registry key change notify code.
    
--*/

#include "precomp.h"
#pragma hdrstop
#include "dnsmsg.h"

//
// Structure:   DNS_QUERY_TIMEOUT_CONTEXT
//
// This structure is used to pass context information
// to the timeout callback-routine for DNS queries.
//

typedef struct _DNS_QUERY_TIMEOUT_CONTEXT {
    ULONG Index;
    USHORT QueryId;
} DNS_QUERY_TIMEOUT_CONTEXT, *PDNS_QUERY_TIMEOUT_CONTEXT;


//
// GLOBAL DATA DEFINITIONS
//

const WCHAR DnsDhcpNameServerString[] = L"DhcpNameServer";
const WCHAR DnsNameServerString[] = L"NameServer";
HANDLE DnsNotifyChangeKeyEvent = NULL;
IO_STATUS_BLOCK DnsNotifyChangeKeyIoStatus;
HANDLE DnsNotifyChangeKeyWaitHandle = NULL;
HANDLE DnsNotifyChangeAddressEvent = NULL;
OVERLAPPED DnsNotifyChangeAddressOverlapped;
HANDLE DnsNotifyChangeAddressWaitHandle = NULL;
PULONG DnsServerList[DnsProxyCount] = { NULL, NULL };
HANDLE DnsTcpipInterfacesKey = NULL;
const WCHAR DnsTcpipInterfacesString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters\\Interfaces";

HANDLE DnsNotifyChangeKeyICSDomainEvent = NULL;
IO_STATUS_BLOCK DnsNotifyChangeKeyICSDomainIoStatus;
HANDLE DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
HANDLE DnsTcpipParametersKey = NULL;
const WCHAR DnsTcpipParametersString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters";
const WCHAR DnsICSDomainValueName[] =
    L"ICSDomain";
PWCHAR DnsICSDomainSuffix = NULL;



//
// FORWARD DECLARATIONS
//

VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnspQueryTimeoutCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DnspQueryTimeoutWorkerRoutine(
    PVOID Context
    );

VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );


VOID
DnsDeleteQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp
    )

/*++

Routine Description:

    This routine is called to delete a pending query.

Arguments:

    Interfacep - the query's interface

    Queryp - the query to be deleted

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    PROFILE("DnsDeleteQuery");

    if (Queryp->Bufferp) { NhReleaseBuffer(Queryp->Bufferp); }
    if (Queryp->TimerHandle) {
        //
        // This query is associated with a timer;
        // Rather than cancel the timeout-routine, we let it run,
        // so that it can release any references it has on the component.
        // When it does run, though, the routine won't find this query.
        //
        Queryp->TimerHandle = NULL;
    }
    RemoveEntryList(&Queryp->Link);
    NH_FREE(Queryp);

} // DnsDeleteQuery


BOOLEAN
DnsIsPendingQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    )

/*++

Routine Description:

    This routine is invoked to determine whether a query is already pending
    for the client-request in the given buffer.

    The list of queries is sorted on 'QueryId', but we will be searching
    on 'SourceId' and 'SourceAddress' and 'SourcePort'; hence, we must do
    an exhaustive search of the pending-query list.

Arguments:

    Interfacep - the interface on which to look

    QueryBuffer - the query to be searched for

Return Value:

    BOOLEAN - TRUE if the query is already pending, FALSE otherwise.

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    BOOLEAN Exists;
    PDNS_HEADER Headerp;
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsIsPendingQuery");

    Exists = FALSE;
    Headerp = (PDNS_HEADER)QueryBuffer->Buffer;

    for (Link = Interfacep->QueryList.Flink;
         Link != &Interfacep->QueryList;
         Link = Link->Flink
         ) {

        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);

        if (Queryp->SourceId != Headerp->Xid ||
            Queryp->SourceAddress != QueryBuffer->ReadAddress.sin_addr.s_addr ||
            Queryp->SourcePort != QueryBuffer->ReadAddress.sin_port
            ) {
            continue;
        }

        Exists = TRUE;
        break;
    }

    return Exists;

} // DnsIsPendingQuery


PDNS_QUERY
DnsMapResponseToQuery(
    PDNS_INTERFACE Interfacep,
    USHORT ResponseId
    )

/*++

Routine Description:

    This routine is invoked to map an incoming response from a DNS server
    to a pending query for a DNS client.

Arguments:

    Interfacep - the interface holding the pending query, if any

    ResponseId - the ID in the response received from the server

Return Value:

    PDNS_QUERY - the pending query, if any

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsMapResponseToQuery");

    for (Link = Interfacep->QueryList.Flink;
         Link != &Interfacep->QueryList;
         Link = Link->Flink
         ) {
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        if (ResponseId > Queryp->QueryId) {
            continue;
        } else if (ResponseId < Queryp->QueryId) {
            break;
        }
        return Queryp;
    }

    return NULL;

} // DnsMapResponseToQuery



VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of when changes occur
    in the (system) table that maps IP addresses to interfaces.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    ULONG Error;
    HANDLE UnusedTcpipHandle;

    PROFILE("DnsNotifyChangeAddressCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeAddressEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Rebuild the list of DNS servers
    //

    DnsQueryServerList();

    //
    // Repost the address change-notification
    //

    ZeroMemory(&DnsNotifyChangeAddressOverlapped, sizeof(OVERLAPPED));

    DnsNotifyChangeAddressOverlapped.hEvent = DnsNotifyChangeAddressEvent;

    Error =
        NotifyAddrChange(
            &UnusedTcpipHandle,
            &DnsNotifyChangeAddressOverlapped
            );

    if (Error != ERROR_IO_PENDING) {
        if (DnsNotifyChangeAddressWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
            DnsNotifyChangeAddressWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeAddressEvent);
        DnsNotifyChangeAddressEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeAddressCallbackRoutine: error %08x "
            "for change address",
            Error
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
            Error,
            ""
            );
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeAddressCallbackRoutine



VOID NTAPI
DnsNotifyChangeKeyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of a change to the
    TCP/IP parameters subkey containing the DNS adapter information.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    NTSTATUS status;

    PROFILE("DnsNotifyChangeKeyCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeKeyEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Rebuild the list of DNS servers
    //

    DnsQueryServerList();

    //
    // Repost the change-notification
    //

    status =
        NtNotifyChangeKey(
            DnsTcpipInterfacesKey,
            DnsNotifyChangeKeyEvent,
            NULL,
            NULL,
            &DnsNotifyChangeKeyIoStatus,
            REG_NOTIFY_CHANGE_LAST_SET,
            TRUE,
            NULL,
            0,
            TRUE
            );

    if (!NT_SUCCESS(status)) {
        if (DnsNotifyChangeKeyWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
            DnsNotifyChangeKeyWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeKeyEvent);
        DnsNotifyChangeKeyEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeKeyCallbackRoutine: status %08x "
            "enabling change notify",
            status
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
            RtlNtStatusToDosError(status),
            ""
            );
        DEREFERENCE_DNS();
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeKeyCallbackRoutine



VOID NTAPI
DnsNotifyChangeKeyICSDomainCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of a change to the TCP/IP
    parameters subkey containing the ICS Domain suffix string information.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    NTSTATUS status;

    PROFILE("DnsNotifyChangeKeyICSDomainCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeKeyICSDomainEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Check to see if the domain string changed;
    // if it doesnt exist - create one.
    //

    DnsQueryICSDomainSuffix();

    //
    // Repost the change-notification
    //

    status =
        NtNotifyChangeKey(
            DnsTcpipParametersKey,
            DnsNotifyChangeKeyICSDomainEvent,
            NULL,
            NULL,
            &DnsNotifyChangeKeyICSDomainIoStatus,
            REG_NOTIFY_CHANGE_LAST_SET,
            FALSE,                          // not interested in the subtree
            NULL,
            0,
            TRUE
            );

    if (!NT_SUCCESS(status)) {
        if (DnsNotifyChangeKeyICSDomainWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
            DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeKeyICSDomainEvent);
        DnsNotifyChangeKeyICSDomainEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeKeyICSDomainCallbackRoutine: status %08x "
            "enabling change notify",
            status
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
            RtlNtStatusToDosError(status),
            ""
            );
        DEREFERENCE_DNS();
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeKeyICSDomainCallbackRoutine


VOID NTAPI
DnspQueryTimeoutCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is called when the timeout for a query expires.
    We may need to resubmit the query and install a new timer,
    but we cannot do this in the context of an Rtl timer-routine.
    Therefore, queue an RTUTILS.DLL work-item to handle the timeout.

Arguments:

    Context - holds the timer context

    TimedOut - unused.

Return Value:

    none.

Environment:

    Invoked in the context of an Rtl timer-thread with a reference made
    to the component on our behalf at the time 'RtlCreateTimer' was invoked.

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    PDNS_QUERY Queryp;
    NTSTATUS status;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;

    PROFILE("DnspQueryTimeoutCallbackRoutine");

    TimeoutContext = (PDNS_QUERY_TIMEOUT_CONTEXT)Context;

    //
    // Look up the interface for the timeout
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(TimeoutContext->Index, NULL);
    if (!Interfacep || !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: interface %d not found",
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Look up the query which timed out
    //

    ACQUIRE_LOCK(Interfacep);
    Queryp = DnsMapResponseToQuery(Interfacep, TimeoutContext->QueryId);
    if (!Queryp) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: query %d interface %d not found",
            TimeoutContext->QueryId,
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }

    Queryp->TimerHandle = NULL;

    //
    // Try to queue a work-item for the timeout;
    // if this succeeds, keep the reference on the component.
    // Otherwise, we have to drop the reference here.
    //

    status =
        RtlQueueWorkItem(
            DnspQueryTimeoutWorkerRoutine,
            Context, 
            WT_EXECUTEINIOTHREAD
            );

    if (NT_SUCCESS(status)) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
    } else {
        NH_FREE(TimeoutContext);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: RtlQueueWorkItem=%d, aborting",
            status
            );
        DnsDeleteQuery(Interfacep, Queryp);
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DNS();
    }

} // DnspQueryTimeoutCallbackRoutine


VOID APIENTRY
DnspQueryTimeoutWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the timeout for a query expires.
    It is queued by the query's timer-handler.

Arguments:

    Context - holds the timer context

Return Value:

    none.

Environment:

    Invoked in the context of an RTUTILS worker-thread with a reference made
    to the component on our behalf at the time 'RtlCreateTimer' was invoked.

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    PDNS_QUERY Queryp;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;

    PROFILE("DnspQueryTimeoutWorkerRoutine");

    TimeoutContext = (PDNS_QUERY_TIMEOUT_CONTEXT)Context;

    //
    // Look up the interface for the timeout
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(TimeoutContext->Index, NULL);
    if (!Interfacep || !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutWorkerRoutine: interface %d not found",
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Look up the query which timed out
    //

    ACQUIRE_LOCK(Interfacep);
    Queryp = DnsMapResponseToQuery(Interfacep, TimeoutContext->QueryId);
    if (!Queryp) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutWorkerRoutine: query %d interface %d not found",
            TimeoutContext->QueryId,
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }

    NH_FREE(TimeoutContext);

    //
    // Have 'DnsSendQuery' repost the timed-out query.
    // Note that we retain our reference to the interface
    // on behalf of the send to be initiated in 'DnsSendQuery'.
    //

    Error =
        DnsSendQuery(
            Interfacep,
            Queryp,
            TRUE
            );

    if (!Error) {
        RELEASE_LOCK(Interfacep);
    } else {
        DnsDeleteQuery(Interfacep, Queryp);
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
    }

    DEREFERENCE_DNS();

} // DnspQueryTimeoutWorkerRoutine


ULONG
DnsQueryServerList(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to read the list of DNS servers from the registry.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    PUCHAR Buffer;
    ULONG Error;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    PDNS_INTERFACE Interfacep;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("DnsQueryServerList");

    if (!DnsTcpipInterfacesKey) {

        RtlInitUnicodeString(&UnicodeString, DnsTcpipInterfacesString);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    
        //
        // Open the 'Tcpip\Parameters\Interfaces' registry key
        //
    
        status =
            NtOpenKey(
                &DnsTcpipInterfacesKey,
                KEY_READ,
                &ObjectAttributes
                );
    
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error %x opening registry key",
                status
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                Error,
                ""
                );
            return Error;
        }
    }

    //
    // See if we need to install change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the change-notification routine
    // which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeKeyEvent && REFERENCE_DNS()) {

        //
        // Attempt to set up change notification on the key
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeKeyEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: status %08x creating notify-change event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        } else {
    
            //
            // Register a wait on the notify-change event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeKeyWaitHandle,
                    DnsNotifyChangeKeyEvent,
                    DnsNotifyChangeKeyCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status)) {
                NtClose(DnsNotifyChangeKeyEvent);
                DnsNotifyChangeKeyEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: status %08x registering wait",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            } else {
        
                //
                // Register for change-notification on the key
                //
        
                status =
                    NtNotifyChangeKey(
                        DnsTcpipInterfacesKey,
                        DnsNotifyChangeKeyEvent,
                        NULL,
                        NULL,
                        &DnsNotifyChangeKeyIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
        
                if (!NT_SUCCESS(status)) {
                    RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
                    DnsNotifyChangeKeyWaitHandle = NULL;
                    NtClose(DnsNotifyChangeKeyEvent);
                    DnsNotifyChangeKeyEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryServerList: status %08x (%08x) "
                        "enabling change notify",
                        status
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                        RtlNtStatusToDosError(status),
                        ""
                        );
                }
            }
        }
    }

    //
    // See if we need to install address-change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the address-change-notification
    // routine which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeAddressEvent && REFERENCE_DNS()) {

        //
        // Attempt to set up address change notification
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeAddressEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: status %08x creating "
                "notify-change address event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        } else {
    
            //
            // Register a wait on the notify-change address event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeAddressWaitHandle,
                    DnsNotifyChangeAddressEvent,
                    DnsNotifyChangeAddressCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status)) {
                NtClose(DnsNotifyChangeAddressEvent);
                DnsNotifyChangeAddressEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: status %08x registering wait"
                    "for change address",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            } else {

                HANDLE UnusedTcpipHandle;

                //
                // Register for change-notification
                //

                ZeroMemory(
                    &DnsNotifyChangeAddressOverlapped,
                    sizeof(OVERLAPPED)
                    );

                DnsNotifyChangeAddressOverlapped.hEvent =
                                                DnsNotifyChangeAddressEvent;

                Error =
                    NotifyAddrChange(
                        &UnusedTcpipHandle,
                        &DnsNotifyChangeAddressOverlapped
                        );

                if (Error != ERROR_IO_PENDING) {
                    RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
                    DnsNotifyChangeAddressWaitHandle = NULL;
                    NtClose(DnsNotifyChangeAddressEvent);
                    DnsNotifyChangeAddressEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryServerList: error %08x"
                        "for change address",
                        Error
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                        Error,
                        ""
                        );
                }
            }
        }
    }


    {
    PIP_ADAPTER_INFO AdapterInfo;
    PIP_ADAPTER_INFO AdaptersInfo = NULL;
    ULONG Address;
    PIP_ADDR_STRING AddrString;
    ULONG dnsLength = 0;
    PULONG dnsServerList = NULL;
    PFIXED_INFO FixedInfo = NULL;
    LONG i;
    ULONG Length;
    PIP_PER_ADAPTER_INFO PerAdapterInfo;
    ULONG tempLength;
    PULONG tempServerList;
    ULONG winsLength;
    PULONG winsServerList = NULL;

    //
    // Read the DNS and WINS server lists.
    // 'GetAdaptersInfo' provides the WINS servers for each adapter,
    // while 'GetPerAdapterInfo' provides the DNS servers for each adapter.
    // While 'GetAdaptersInfo' returns an array of all adapters,
    // 'GetPerAdapterInfo' must be invoked for each individual adapter.
    // Hence we begin with 'GetAdaptersInfo', and enumerate each adapter
    // building the WINS and DNS server lists in parallel.
    //

    do {

        //
        // Retrieve the size of the adapter list
        //

        Length = 0;
        Error = GetAdaptersInfo(NULL, &Length);
    
        if (!Error) {
            break;
        } else if (Error != ERROR_BUFFER_OVERFLOW) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: GetAdaptersInfo=%d",
                Error
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ERROR_SERVER_LIST,
                Error,
                ""
                );
            break;
        }

        //
        // Allocate a buffer to hold the list
        //

        AdaptersInfo = (PIP_ADAPTER_INFO)NH_ALLOCATE(Length);

        if (!AdaptersInfo) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error allocating %d bytes",
                Length
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Length
                );
            break;
        }

        //
        // Retrieve the list
        //

        Error = GetAdaptersInfo(AdaptersInfo, &Length);

        if (Error) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: GetAdaptersInfo=%d",
                Error
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                Error,
                ""
                );
            break;
        }

        //
        // Count the WINS servers
        //

        for (AdapterInfo = AdaptersInfo, winsLength = 1;
             AdapterInfo;
             AdapterInfo = AdapterInfo->Next
             ) {
             
            Address =
                inet_addr(AdapterInfo->PrimaryWinsServer.IpAddress.String);
            if (Address != INADDR_ANY && Address != INADDR_NONE) {
                ++winsLength;
            }
            Address =
                inet_addr(AdapterInfo->SecondaryWinsServer.IpAddress.String);
            if (Address != INADDR_ANY && Address != INADDR_NONE) {
                ++winsLength;
            }
        }

        //
        // Allocate space for the WINS servers
        //

        winsServerList = (PULONG)NH_ALLOCATE(winsLength * sizeof(ULONG));

        if (!winsServerList) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error allocating %d-byte WINS server list",
                winsLength * sizeof(ULONG)
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                winsLength * sizeof(ULONG)
                );
            break;
        }

        //
        // Now fill in the WINS server names from each adapter.
        // In the process, we pick up the DNS server lists for each adapter.
        //

        for (AdapterInfo = AdaptersInfo, Length = 0;
             AdapterInfo;
             AdapterInfo = AdapterInfo->Next
             ) {

            Address =
                inet_addr(AdapterInfo->PrimaryWinsServer.IpAddress.String);
            if (Address != INADDR_ANY && Address != INADDR_NONE) {
                for (i = 0; i < (LONG)Length; i++) {
                    if (Address == winsServerList[i]) { break; }
                }
                if (i >= (LONG)Length) { winsServerList[Length++] = Address; }
            }
            Address =
                inet_addr(AdapterInfo->SecondaryWinsServer.IpAddress.String);
            if (Address != INADDR_ANY && Address != INADDR_NONE) {
                for (i = 0; i < (LONG)Length; i++) {
                    if (Address == winsServerList[i]) { break; }
                }
                if (i >= (LONG)Length) { winsServerList[Length++] = Address; }
            }

            //
            // Now obtain the DNS servers for the adapter.
            //

            Error = GetPerAdapterInfo(AdapterInfo->Index, NULL, &tempLength);
            if (Error != ERROR_BUFFER_OVERFLOW) { continue; }

            //
            // Allocate memory for the per-adapter info
            //

            PerAdapterInfo =
                reinterpret_cast<PIP_PER_ADAPTER_INFO>(
                    NH_ALLOCATE(tempLength)
                    );
            if (!PerAdapterInfo) {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: error allocating %d bytes",
                    tempLength
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    tempLength
                    );
                continue;
            }

            //
            // Retrieve the per-adapter info
            //

            Error =
                GetPerAdapterInfo(
                    AdapterInfo->Index,
                    PerAdapterInfo,
                    &tempLength
                    );
            if (Error) {
                NH_FREE(PerAdapterInfo);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: GetPerAdapterInfo=%d",
                    Error
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                    Error,
                    ""
                    );
                continue;
            }

            //
            // Count the DNS servers for the adapter
            //

            for (AddrString = &PerAdapterInfo->DnsServerList, tempLength = 0;
                 AddrString;
                 AddrString = AddrString->Next
                 ) {

                Address = inet_addr(AddrString->IpAddress.String);
                if (Address != INADDR_ANY && Address != INADDR_NONE) {
                    ++tempLength;
                }
            }

            if (!tempLength) { NH_FREE(PerAdapterInfo); continue; }

            //
            // Allocate space for the adapter's DNS servers
            //

            tempServerList =
                reinterpret_cast<PULONG>(
                    NH_ALLOCATE((dnsLength + tempLength + 1) * sizeof(ULONG))
                    );
            if (!tempServerList) {
                NH_FREE(PerAdapterInfo);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: error allocating %d bytes",
                    (dnsLength + tempLength + 1) * sizeof(ULONG)
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    (dnsLength + tempLength + 1) * sizeof(ULONG)
                    );
                continue;
            }

            //
            // Copy the existing servers
            //

            if (dnsServerList) {
                CopyMemory(
                    tempServerList,
                    dnsServerList,
                    dnsLength * sizeof(ULONG)
                    );
            }

            //
            // Read the new servers into the new server list
            //

            for (AddrString = &PerAdapterInfo->DnsServerList;
                 AddrString;
                 AddrString = AddrString->Next
                 ) {

                Address = inet_addr(AddrString->IpAddress.String);
                if (Address == INADDR_ANY || Address == INADDR_NONE) {
                    continue;
                }

                for (i = 0; i < (LONG)dnsLength; i++) {
                    if (Address == tempServerList[i]) { break; }
                }

                if (i < (LONG)dnsLength) { continue; }

                //
                // The current DNS server goes in the front of the list,
                // while any other server is appended.
                //

                if (PerAdapterInfo->CurrentDnsServer != AddrString) {
                    tempServerList[dnsLength] = Address;
                } else {
                    MoveMemory(
                        tempServerList + sizeof(ULONG),
                        tempServerList,
                        dnsLength * sizeof(ULONG)
                        );
                    tempServerList[0] = Address;
                }

                ++dnsLength;
            }

            tempServerList[dnsLength] = 0;
            NH_FREE(PerAdapterInfo);

            //
            // Replace the existing server list
            //

            

            if (dnsServerList) { NH_FREE(dnsServerList); }
            dnsServerList = tempServerList;
        }

        winsServerList[Length] = 0;

    } while(FALSE);

    if (AdaptersInfo) { NH_FREE(AdaptersInfo); }

    //
    // Store the new server lists
    //

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsQueryServerList: new server list lengths are : DNS (%d) WINS (%d)",
        dnsLength,
        Length
        );

    if (DnsServerList[DnsProxyDns]) { NH_FREE(DnsServerList[DnsProxyDns]); }
    DnsServerList[DnsProxyDns] = dnsServerList;
    if (DnsServerList[DnsProxyWins]) { NH_FREE(DnsServerList[DnsProxyWins]); }
    DnsServerList[DnsProxyWins] = winsServerList;
    }

    return NO_ERROR;

} // DnsQueryServerList

VOID
DnsQueryRegistryICSDomainSuffix(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to read the ICS Domain suffix from the registry.

Arguments:

    none.

Return Value:

    VOID.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION Information = NULL;
    DWORD    dwSize = 0;
    LPVOID   lpMsgBuf;
    BOOL     fSuffixChanged = FALSE;
    BOOL     fUseDefaultSuffix = FALSE;

    //
    // retrieve current suffix string (if any)
    //
    status =
        NhQueryValueKey(
            DnsTcpipParametersKey,
            DnsICSDomainValueName,
            &Information
            );


    if (!NT_SUCCESS(status) || !Information)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsQueryRegistryICSDomainSuffix: error (0x%08x) querying "
            "ICS Domain suffix name",
            status
            );

        //
        // if we did not find it in the registry and we had previously
        // got some suffix - we revert to default string (happens below)
        //
        if ((STATUS_OBJECT_NAME_NOT_FOUND == status) && DnsICSDomainSuffix)
        {
            NH_FREE(DnsICSDomainSuffix);
            DnsICSDomainSuffix = NULL;
        }
            
        //
        // if we have no idea of the string, set our copy to default string
        //
        if (NULL == DnsICSDomainSuffix)
        {
            dwSize = wcslen(DNS_HOMENET_SUFFIX) + 1;

            DnsICSDomainSuffix = reinterpret_cast<PWCHAR>(
                                     NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                                     );
            if (!DnsICSDomainSuffix)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryRegistryICSDomainSuffix: allocation "
                    "failed for DnsICSDomainSuffix"
                    );

                return;
            }

            wcscpy(DnsICSDomainSuffix, DNS_HOMENET_SUFFIX);
            fSuffixChanged = TRUE;
        }
    }
    else
    {
    
        //
        // check to see that what we read is a null terminated string
        //
        
        if (REG_SZ != Information->Type
            || L'\0' != *(PWCHAR) (Information->Data +
                                    (Information->DataLength - sizeof(WCHAR)))) {
            NH_FREE(Information);
            NhTrace(
                TRACE_FLAG_REG,
                "DnsQueryRegistryICSDomainSuffix: Registry contains invalid data"
                );
            return;
        }
        
        //
        // overwrite our current version of suffix string
        //

        dwSize = lstrlenW((PWCHAR)Information->Data);

        if (dwSize)
        {
            //
            // we have a nonzero string
            //
            dwSize++;   // add 1 for terminating null
            
        }
        else
        {
            //
            // the data is a null string - use default suffix
            //
            dwSize = wcslen(DNS_HOMENET_SUFFIX) + 1;
            fUseDefaultSuffix = TRUE;
        }

        if (DnsICSDomainSuffix)
        {
            NH_FREE(DnsICSDomainSuffix);
            DnsICSDomainSuffix = NULL;
        }

        DnsICSDomainSuffix = reinterpret_cast<PWCHAR>(
                                 NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                                 );
        if (!DnsICSDomainSuffix)
        {
            NH_FREE(Information);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryRegistryICSDomainSuffix: allocation "
                "failed for DnsICSDomainSuffix"
                );

            return;
        }

        if (!fUseDefaultSuffix)
        {
            wcscpy(DnsICSDomainSuffix, (PWCHAR) Information->Data);
        }
        else
        {
            wcscpy(DnsICSDomainSuffix, DNS_HOMENET_SUFFIX);
        }
        fSuffixChanged = TRUE;

        NH_FREE(Information);
    }

    if (fSuffixChanged)
    {
        //
        // enumerate existing entries and replace old ones
        // + we must do this because otherwise forward and reverse lookups
        //   are dependent on the way in which the entries are ordered in
        //   the hosts.ics file
        //
        //DnsReplaceOnSuffixChange();
    }

} // DnsQueryRegistryICSDomainSuffix


ULONG
DnsQueryICSDomainSuffix(
    VOID
    )

/*++

Routine Description:

    This routine invokes DnsQueryRegistryICSDomainSuffix and installs
    change notification for this reg key if necessary.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    PUCHAR Buffer;
    ULONG Error;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("DnsQueryICSDomainSuffix");

    if (!DnsTcpipParametersKey)
    {

        RtlInitUnicodeString(&UnicodeString, DnsTcpipParametersString);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    
        //
        // Open the 'Tcpip\Parameters' registry key
        //
    
        status =
            NtOpenKey(
                &DnsTcpipParametersKey,
                KEY_READ,
                &ObjectAttributes
                );
    
        if (!NT_SUCCESS(status))
        {
            Error = RtlNtStatusToDosError(status);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryICSDomainSuffix: error %x opening registry key",
                status
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX,
                Error,
                ""
                );
            return Error;
        }
    }

    //
    // See if we need to install change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the change-notification routine
    // which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeKeyICSDomainEvent && REFERENCE_DNS())
    {

        //
        // Attempt to set up change notification on the key
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeKeyICSDomainEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryICSDomainSuffix: status %08x creating notify-change event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        }
        else
        {
            //
            // Register a wait on the notify-change event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeKeyICSDomainWaitHandle,
                    DnsNotifyChangeKeyICSDomainEvent,
                    DnsNotifyChangeKeyICSDomainCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status))
            {
                NtClose(DnsNotifyChangeKeyICSDomainEvent);
                DnsNotifyChangeKeyICSDomainEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryICSDomainSuffix: status %08x registering wait",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            }
            else
            {
                //
                // Register for change-notification on the key
                //
        
                status =
                    NtNotifyChangeKey(
                        DnsTcpipParametersKey,
                        DnsNotifyChangeKeyICSDomainEvent,
                        NULL,
                        NULL,
                        &DnsNotifyChangeKeyICSDomainIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        FALSE,              // not interested in the subtree
                        NULL,
                        0,
                        TRUE
                        );
        
                if (!NT_SUCCESS(status))
                {
                    RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
                    DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
                    NtClose(DnsNotifyChangeKeyICSDomainEvent);
                    DnsNotifyChangeKeyICSDomainEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryICSDomainSuffix: status %08x (%08x) "
                        "enabling change notify",
                        status
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                        RtlNtStatusToDosError(status),
                        ""
                        );
                }
            }
        }
    }

    DnsQueryRegistryICSDomainSuffix();

    return NO_ERROR;

} // DnsQueryICSDomainSuffix


PDNS_QUERY
DnsRecordQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    )

/*++

Routine Description:

    This routine is invoked to create a pending-query entry for a client's
    DNS query.

Arguments:

    Interfacep - the interface on which to create the record

    QueryBuffer - the DNS request for which to create a record

Return Value:

    PDNS_QUERY - the pending query if created

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    BOOLEAN ConflictFound;
    PDNS_HEADER Headerp;
    PLIST_ENTRY Link;
    USHORT QueryId;
    PDNS_QUERY Queryp;
    ULONG RetryCount = MAXCHAR;
    ULONG Seed = GetTickCount();

    PROFILE("DnsRecordQuery");

    //
    // Attempt to generate a random ID for the query.
    // Assuming we succeed, we leave the loop with 'Link'
    // set to the correct insertion-point for the new query.
    //
    do {

        QueryId = (USHORT)((RtlRandom(&Seed) & 0xffff0000) >> 16);
        ConflictFound = FALSE;
        for (Link = Interfacep->QueryList.Flink; Link != &Interfacep->QueryList;
             Link = Link->Flink) {
            Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
            if (QueryId > Queryp->QueryId) {
                continue;
            } else if (QueryId < Queryp->QueryId) {
                break;
            }
            ConflictFound = TRUE;
            break;
        }
    } while(ConflictFound && --RetryCount);

    if (ConflictFound) { return NULL; }

    //
    // Allocate and initialize the new query
    //

    Queryp = reinterpret_cast<PDNS_QUERY>(NH_ALLOCATE(sizeof(DNS_QUERY)));

    if (!Queryp) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsRecordQuery: allocation failed for DNS query"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DNS_QUERY)
            );
        return NULL;
    }

    Headerp = (PDNS_HEADER)QueryBuffer->Buffer;
    Queryp->QueryId = QueryId;
    Queryp->SourceId = Headerp->Xid;
    Queryp->SourceAddress = QueryBuffer->ReadAddress.sin_addr.s_addr;
    Queryp->SourcePort = QueryBuffer->ReadAddress.sin_port;
    Queryp->Type =
        DNS_PROXY_PORT_TO_TYPE(NhQueryPortSocket(QueryBuffer->Socket));
    Queryp->QueryLength = QueryBuffer->BytesTransferred;
    Queryp->Bufferp = QueryBuffer;
    Queryp->Interfacep = Interfacep;
    Queryp->TimerHandle = NULL;
    Queryp->RetryCount = 0;

    //
    // Insert the new query in the location determined above.
    //

    InsertTailList(Link, &Queryp->Link);
    return Queryp;

} // DnsRecordQuery



ULONG
DnsSendQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp,
    BOOLEAN Resend
    )

/*++

Routine Description:

    This routine is invoked to forward a query to our DNS servers.

Arguments:

    Interfacep - the interface on which to send the query

    Queryp - the DNS request to be sent

    Resend - if TRUE, the buffer is being resent; otherwise, the buffer
        is being sent for the first time.

Return Value:

    ULONG - Win32 status code.
    On success, 'Queryp' may have been deleted.

Environment:

    Invoked with 'Interfacep' locked by the caller, and with a reference made
    to it for the send which occurs here.
    If the routine fails, it is the caller's responsibility to release that
    reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    ULONG i, j;
    PULONG ServerList;
    SOCKET Socket;
    NTSTATUS status;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;
    ULONG TimeoutSeconds;

    PROFILE("DnsSendQuery");

    //
    // For WINS queries, we use a global socket to work around the fact that
    // even though we're bound to the WINS port, responses will only be
    // delivered to the first socket bound to the socket, which is
    // the kernel-mode NetBT driver.
    //

    EnterCriticalSection(&DnsGlobalInfoLock);
    if (Queryp->Type == DnsProxyDns) {
        Socket = Queryp->Bufferp->Socket;
        ServerList = DnsServerList[DnsProxyDns];
    } else {
        Socket = DnsGlobalSocket;
        ServerList = DnsServerList[DnsProxyWins];
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // See if there are any servers to be tried.
    //

    if (!ServerList ||
        !ServerList[0] ||
        Queryp->RetryCount++ > DNS_QUERY_RETRY) {
        if (!ServerList) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: no server list"
                );
        }
        else if (!ServerList[0]) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: no server entries in list"
                );        
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: retry count for query %d "
                "greater than DNS_QUERY_RETRY(%d)",
                Queryp->QueryId,
                DNS_QUERY_RETRY
                );        
        }
        if (REFERENCE_DNS()) {
            //
            // Initiate an attempt to connect the default interface, if any.
            //
            status =
                RtlQueueWorkItem(
                    DnsConnectDefaultInterface,
                    NULL, 
                    WT_EXECUTEINIOTHREAD
                    );
            if (!NT_SUCCESS(status)) { DEREFERENCE_DNS(); }
        }
        NhInformationLog(
            IP_DNS_PROXY_LOG_NO_SERVERS_LEFT,
            0,
            "%I",
            Queryp->SourceAddress
            );
        return ERROR_NO_MORE_ITEMS;
    }

    //
    // Send the query to each server on the list
    //

    for (i = 0; ServerList[i]; i++) {

        for (j = 0; j < Interfacep->BindingCount; j++) {
            if (Interfacep->BindingArray[j].Address == ServerList[i]) {
                break;
            }
        }
        if (j < Interfacep->BindingCount) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: server %s is self, ignoring",
                INET_NTOA(ServerList[i])
                );
            continue;
        }

        if (!DNS_REFERENCE_INTERFACE(Interfacep) ||
            !(Bufferp = NhDuplicateBuffer(Queryp->Bufferp))) {
            continue;
        }

        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSendQuery: sending query %d interface %d to %s",
            (PVOID)((PDNS_HEADER)Bufferp->Buffer)->Xid,
            Interfacep->Index,
            INET_NTOA(ServerList[i])
            );
    
        //
        // Send the message
        //
    
        Error =
            NhWriteDatagramSocket(
                &DnsComponentReference,
                Socket,
                ServerList[i],
                DNS_PROXY_TYPE_TO_PORT(Queryp->Type),
                Bufferp,
                Queryp->QueryLength,
                DnsWriteCompletionRoutine,
                Interfacep,
                (PVOID)Queryp->QueryId
                );
    
        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DnsStatistics.QueriesSent)
                );
        } else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: error %d sending query %d interface %d",
                Error,
                Queryp->QueryId,
                Interfacep->Index
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_QUERY_FAILED,
                Error,
                "%I%I%I",
                Queryp->SourceAddress,
                ServerList[i],
                NhQueryAddressSocket(Bufferp->Socket)
                );
            Error = NO_ERROR;
            NhReleaseBuffer(Bufferp);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
        }
    }

    //
    // Set up the query's timeout.
    // Note that we are now certain that the write-completion routine
    // will be executed. However, if the timeout cannot be set,
    // we want to be assured that the query will still be deleted.
    // Therefore, on failure we delete the query immediately,
    // and the write-completion routine will simply not find it.
    //

    status = STATUS_UNSUCCESSFUL;

    EnterCriticalSection(&DnsGlobalInfoLock);
    TimeoutSeconds = DnsGlobalInfo->TimeoutSeconds;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    if (Queryp->TimerHandle) {

        //
        // Update the timer-queue entry for the query
        //

        status =
            NhUpdateTimer(
                Queryp->TimerHandle,
                TimeoutSeconds * 1000
                );
    } else {

        //
        // Allocate a timer-queue entry context block
        //

        TimeoutContext = reinterpret_cast<PDNS_QUERY_TIMEOUT_CONTEXT>(
                            NH_ALLOCATE(sizeof(*TimeoutContext))
                            );

        if (!TimeoutContext) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: error allocating query %d timeout context",
                Queryp->QueryId
                );
            status = STATUS_UNSUCCESSFUL;
        } else {

            TimeoutContext->Index = Interfacep->Index;
            TimeoutContext->QueryId = Queryp->QueryId;

            //
            // Insert a timer-queue entry to check the status of the query
            //
    
            status =
                NhSetTimer(
                    &DnsComponentReference,
                    &Queryp->TimerHandle,
                    DnspQueryTimeoutCallbackRoutine,
                    TimeoutContext,
                    TimeoutSeconds * 1000
                    );

            if (!NT_SUCCESS(status)) {
                NH_FREE(TimeoutContext);
                Queryp->TimerHandle = NULL;
            }
        }
    }

    //
    // If the above failed, delete the query now.
    //

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSendQuery: status %08x setting timer for query %d",
            status,
            Queryp->QueryId
            );
        DnsDeleteQuery(Interfacep, Queryp);
    }

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsSendQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\h323\h323if.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323if.h

Abstract:

    This module contains declarations for the H.323 transparent proxy's
    interface management.

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:
    
--*/

#ifndef _NATHLP_H323IF_H_
#define _NATHLP_H323IF_H_

//
// Structure:   H323_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of H.323 transparent proxy
// interfaces, sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('H323InterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _H323_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    NET_INTERFACE_TYPE Type; // read-only
    IP_H323_INTERFACE_INFO Info;
    ULONG Flags;
    PIP_ADAPTER_BINDING_INFO BindingInfo;
} H323_INTERFACE, *PH323_INTERFACE;

//
// Flags
//

#define H323_INTERFACE_FLAG_DELETED      0x80000000
#define H323_INTERFACE_DELETED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_DELETED)

#define H323_INTERFACE_FLAG_BOUND        0x40000000
#define H323_INTERFACE_BOUND(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_BOUND)

#define H323_INTERFACE_FLAG_ENABLED      0x20000000
#define H323_INTERFACE_ENABLED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_ENABLED)

#define H323_INTERFACE_FLAG_CONFIGURED   0x10000000
#define H323_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_CONFIGURED)

#define H323_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (H323_INTERFACE_FLAG_BOUND|H323_INTERFACE_FLAG_ENABLED)) \
        == (H323_INTERFACE_FLAG_BOUND|H323_INTERFACE_FLAG_ENABLED))

#define H323_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_H323_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define H323_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, H323_INTERFACE_DELETED)

#define H323_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, H323CleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY H323InterfaceList;
extern CRITICAL_SECTION H323InterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
H323ActivateInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323BindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
H323CleanupInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323ConfigureInterface(
    ULONG Index,
    PIP_H323_INTERFACE_INFO InterfaceInfo
    );

ULONG
H323CreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_H323_INTERFACE_INFO InterfaceInfo,
    PH323_INTERFACE* InterfaceCreated
    );

VOID
H323DeactivateInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323DeleteInterface(
    ULONG Index
    );

ULONG
H323DisableInterface(
    ULONG Index
    );

ULONG
H323EnableInterface(
    ULONG Index
    );

ULONG
H323InitializeInterfaceManagement(
    VOID
    );

PH323_INTERFACE
H323LookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
H323QueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
H323ShutdownInterfaceManagement(
    VOID
    );

VOID
H323SignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
H323UnbindInterface(
    ULONG Index
    );

#endif // _NATHLP_H323IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\dns\rmdns.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdns.c

Abstract:

    This module contains routines for the DNS allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#define DNS_SERVICE_NAME        TEXT("DNS")

COMPONENT_REFERENCE DnsComponentReference;
PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo = NULL;
CRITICAL_SECTION DnsGlobalInfoLock;
SOCKET DnsGlobalSocket = INVALID_SOCKET;
HANDLE DnsNotificationEvent;
ULONG DnsProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS DnsRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_DNS_PROXY,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    DnsRmStartProtocol,
    DnsRmStartComplete,
    DnsRmStopProtocol,
    DnsRmGetGlobalInfo,
    DnsRmSetGlobalInfo,
    NULL,
    NULL,
    DnsRmAddInterface,
    DnsRmDeleteInterface,
    DnsRmInterfaceStatus,
    
    DnsRmGetInterfaceInfo,
    DnsRmSetInterfaceInfo,
    DnsRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    DnsRmMibCreate,
    DnsRmMibDelete,
    DnsRmMibGet,
    DnsRmMibSet,
    DnsRmMibGetFirst,
    DnsRmMibGetNext,
    NULL,
    NULL
};


IP_DNS_PROXY_STATISTICS DnsStatistics;
SUPPORT_FUNCTIONS DnsSupportFunctions;


VOID
DnsCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DNS module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DnsShutdownInterfaceManagement();
    DnsShutdownTableManagement();
    DnsShutdownFileManagement();
    DeleteCriticalSection(&DnsGlobalInfoLock);
    DeleteComponentReference(&DnsComponentReference);

} // DnsCleanupModule


VOID
DnsCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DNS protocol-component
    after a 'StopProtocol'. It runs when the last reference to the  
    DHCP component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    DNS_PROXY_TYPE Type;

    PROFILE("DnsCleanupProtocol");

    if (DnsServerList[DnsProxyDns]) {
        NH_FREE(DnsServerList[DnsProxyDns]);
        DnsServerList[DnsProxyDns] = NULL;
    }
    if (DnsServerList[DnsProxyWins]) {
        NH_FREE(DnsServerList[DnsProxyWins]);
        DnsServerList[DnsProxyWins] = NULL;
    }
    if (DnsICSDomainSuffix)
    {
        NH_FREE(DnsICSDomainSuffix);
        DnsICSDomainSuffix = NULL;
    }
    if (DnsGlobalInfo) { NH_FREE(DnsGlobalInfo); DnsGlobalInfo = NULL; }
    InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 1);
    SetEvent(DnsNotificationEvent);
    ResetComponentReference(&DnsComponentReference);

    NhStopEventLog();
} // DnsCleanupProtocol


BOOLEAN
DnsInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the DNS module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &DnsComponentReference, DnsCleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&DnsGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    if (DnsInitializeFileManagement())  {
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    if (DnsInitializeTableManagement())  {
        DnsShutdownFileManagement();
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }
    
    if (DnsInitializeInterfaceManagement())  {
        DnsShutdownTableManagement();
        DnsShutdownFileManagement();
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    return TRUE;

} // DnsInitializeModule


BOOLEAN
DnsIsDnsEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to determine whether the DNS proxy is enabled.
    It checks the global info which, if found, indicates that the protocol
    is enabled.
    Note that the global info critical section is always initialized in the
    'DllMain' routine, which is why this routine works if the DNS proxy
    is not even installed.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if DNS proxy is enabled, FALSE otherwise.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("DnsIsDnsEnabled");

    if (!REFERENCE_DNS()) { return FALSE; }
    EnterCriticalSection(&DnsGlobalInfoLock);
    if (!DnsGlobalInfo ||
        !(DnsGlobalInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS)) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS_AND_RETURN(FALSE);
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);
    DEREFERENCE_DNS_AND_RETURN(TRUE);

} // DnsIsDnsEnabled


BOOLEAN
DnsIsWinsEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to determine whether the WINS proxy is enabled.
    It checks the global info which, if found, indicates that the protocol
    is enabled.
    Note that the global info critical section is always initialized in the
    'DllMain' routine, which is why this routine works if the DNS proxy
    is not even installed.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if WINS proxy is enabled, FALSE otherwise.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("DnsIsWinsEnabled");

    return FALSE;

} // DnsIsWinsEnabled


BOOL IsServiceRunning(LPCTSTR pSvcName)
{
    BOOL bRet = FALSE;
    SERVICE_STATUS Status;
    SC_HANDLE hService, hScm;

    hScm = OpenSCManager(NULL, NULL, GENERIC_READ);

    if (hScm) {
    
        hService = OpenService(hScm, pSvcName, SERVICE_QUERY_STATUS);

        if (hService) {
            ZeroMemory(&Status, sizeof(Status));

            if (QueryServiceStatus(hService, &Status) && 
                 (SERVICE_STOPPED != Status.dwCurrentState &&
                  SERVICE_STOP_PENDING != Status.dwCurrentState)) {
                bRet = TRUE;
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hScm);

    }
  
    return bRet;
}


ULONG
APIENTRY
DnsRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount    
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    SOCKET GlobalSocket;
    ULONG Size;
    NTSTATUS status;

    PROFILE("DnsRmStartProtocol");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER); }

    NhStartEventLog();

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&DnsGlobalInfoLock);

        Size = sizeof(*DnsGlobalInfo);
    
        DnsGlobalInfo =
            reinterpret_cast<PIP_DNS_PROXY_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!DnsGlobalInfo) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "DnsRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(DnsGlobalInfo, GlobalInfo, Size);

        //
        // If a full DNS server is running on this machine
        // then we need to start DNS Proxy in Disabled mode.
        // If and when the full DNS server is stopped it will reenable the
        // Proxy DNS. 
        //

        if (IsServiceRunning(DNS_SERVICE_NAME)) {
            DnsGlobalInfo->Flags &= ~IP_DNS_PROXY_FLAG_ENABLE_DNS;
        }
            
        //
        // Save the notification event
        //

        DnsNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&DnsSupportFunctions, sizeof(DnsSupportFunctions));
        }
        else {
            CopyMemory(
                &DnsSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        //
        // Query for ICS domain suffix string
        //
        DnsQueryICSDomainSuffix();

        //
        // Build the server list
        //

        DnsQueryServerList();

        //
        // Create the global query-socket
        //

        Error = NhCreateDatagramSocket(0, 0, &GlobalSocket);
        if (Error == NO_ERROR) {
            InterlockedExchangePointer(
                (PVOID*)&DnsGlobalSocket,
                (PVOID)GlobalSocket
                );
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsRmStartProtocol: error %d creating global socket", Error
                );
            Error = NO_ERROR;
        }

        LeaveCriticalSection(&DnsGlobalInfoLock);

        //
        // load entries from the hosts.ics file (if present)
        //
        LoadHostsIcsFile(TRUE);

        InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 0);

    } while (FALSE);

    if (NO_ERROR != Error) {
        NhStopEventLog();
    }

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmStartProtocol


ULONG
APIENTRY
DnsRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // DnsRmStartComplete


ULONG
APIENTRY
DnsRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    SOCKET GlobalSocket;

    PROFILE("DnsRmStopProtocol");

    //
    // Reference the module to make sure it's running
    //

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Save any entries present in our tables
    //
    SaveHostsIcsFile(TRUE);

    //
    // Empty the dns tables to save memory space
    //
    DnsEmptyTables();

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (DnsNotifyChangeKeyWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
        DnsNotifyChangeKeyWaitHandle = NULL;
    }
    if (DnsNotifyChangeKeyEvent) {
        NtClose(DnsNotifyChangeKeyEvent);
        DnsNotifyChangeKeyEvent = NULL;
        DnsNotifyChangeKeyCallbackRoutine(NULL, FALSE);
    }
    if (DnsTcpipInterfacesKey) {
        NtClose(DnsTcpipInterfacesKey);
        DnsTcpipInterfacesKey = NULL;
    }

    if (DnsNotifyChangeAddressWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
        DnsNotifyChangeAddressWaitHandle = NULL;
    }
    if (DnsNotifyChangeAddressEvent) {
        if (CancelIPChangeNotify(&DnsNotifyChangeAddressOverlapped)) {
            if (WAIT_OBJECT_0 != 
                WaitForSingleObject(DnsNotifyChangeAddressEvent, INFINITE)) {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsRmStopProtocol: error %d while waiting on "
                    "DnsNotifyChangeAddressEvent",
                    GetLastError()
                );
            }
        }
        NtClose(DnsNotifyChangeAddressEvent);
        DnsNotifyChangeAddressEvent = NULL;
        DnsNotifyChangeAddressCallbackRoutine(NULL, FALSE);
    }

    //
    // ICSDomain
    //
    if (DnsNotifyChangeKeyICSDomainWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
        DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
    }
    if (DnsNotifyChangeKeyICSDomainEvent) {
        NtClose(DnsNotifyChangeKeyICSDomainEvent);
        DnsNotifyChangeKeyICSDomainEvent = NULL;
        DnsNotifyChangeKeyICSDomainCallbackRoutine(NULL, FALSE);
    }
    if (DnsTcpipParametersKey) {
        NtClose(DnsTcpipParametersKey);
        DnsTcpipParametersKey = NULL;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

    GlobalSocket =
        (SOCKET)InterlockedExchangePointer(
                    (PVOID*)&DnsGlobalSocket, 
                    (PVOID)INVALID_SOCKET
                    );
    NhDeleteDatagramSocket(GlobalSocket);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&DnsComponentReference);

    return DEREFERENCE_DNS() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // DnsRmStopProtocol


ULONG
APIENTRY
DnsRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmAddInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsCreateInterface(
            Index,
            Type,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmAddInterface


ULONG
APIENTRY
DnsRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmDeleteInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsDeleteInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmDeleteInterface


ULONG
APIENTRY
DnsRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("DnsRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // DnsRmGetEventMessage


ULONG
APIENTRY
DnsRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DnsRmGetInterfaceInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsQueryInterface(
            Index,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmGetInterfaceInfo


ULONG
APIENTRY
DnsRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DnsRmSetInterfaceInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        DnsConfigureInterface(
            Index,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmSetInterfaceInfo


ULONG
APIENTRY
DnsRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = DnsRmBindInterface(Index, StatusInfo);
            } else {
                Error = DnsRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = DnsRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = DnsRmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // DnsRmInterfaceStatus


ULONG
DnsRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmBindInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsBindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmBindInterface


ULONG
DnsRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmUnbindInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsUnbindInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmUnbindInterface


ULONG
DnsRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmEnableInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsEnableInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmEnableInterface


ULONG
DnsRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmDisableInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsDisableInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmDisableInterface


ULONG
DnsEnableSuffixQuery(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to reenable the suffix watch.

Arguments:

    None.
    
Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsEnableSuffixQuery");

    //
    // enable ICSDomain key watch
    //
    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    EnterCriticalSection(&DnsGlobalInfoLock);

    DnsQueryICSDomainSuffix();

    LeaveCriticalSection(&DnsGlobalInfoLock);

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsEnableSuffixQuery


ULONG
DnsDisableSuffixQuery(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to disable the suffix watch.

Arguments:

    None.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsDisableSuffixQuery");

    //
    // disable ICSDomain key watch for the period we are disabled
    //
    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (DnsNotifyChangeKeyICSDomainWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
        DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
    }
    if (DnsNotifyChangeKeyICSDomainEvent) {
        NtClose(DnsNotifyChangeKeyICSDomainEvent);
        DnsNotifyChangeKeyICSDomainEvent = NULL;
        DnsNotifyChangeKeyICSDomainCallbackRoutine(NULL, FALSE);
    }
    if (DnsTcpipParametersKey) {
        NtClose(DnsTcpipParametersKey);
        DnsTcpipParametersKey = NULL;
    }

    if (DnsICSDomainSuffix)
    {
        NH_FREE(DnsICSDomainSuffix);
        DnsICSDomainSuffix = NULL;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsDisableSuffixQuery


ULONG
APIENTRY
DnsRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("DnsRmGetGlobalInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&DnsGlobalInfoLock);
    Size = sizeof(*DnsGlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_DNS_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, DnsGlobalInfo, Size);
    LeaveCriticalSection(&DnsGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DNS_AND_RETURN(NO_ERROR);
    
} // DnsRmGetGlobalInfo


ULONG
APIENTRY
DnsRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_DNS_PROXY_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("DnsRmSetGlobalInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*DnsGlobalInfo);
    NewInfo = reinterpret_cast<PIP_DNS_PROXY_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "DnsRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_DNS_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    //
    // If a full DNS server is running on this machine
    // then we need to keep DNS Proxy in the Disabled mode.
    // If and when the full DNS server is stopped it will reenable the
    // Proxy DNS. 

    if (IsServiceRunning(DNS_SERVICE_NAME)) {
        NewInfo->Flags &= ~IP_DNS_PROXY_FLAG_ENABLE_DNS;
    }

    EnterCriticalSection(&DnsGlobalInfoLock);
    OldFlags = DnsGlobalInfo->Flags;
    NH_FREE(DnsGlobalInfo);
    DnsGlobalInfo = NewInfo;
    NewFlags = DnsGlobalInfo->Flags;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // See if the enabled state of either DNS or WINS proxy changed.
    // If so, we need to deactivate and reactivate all interfaces
    //

    if ((NewFlags & IP_DNS_PROXY_FLAG_ENABLE_DNS)
            != (OldFlags & IP_DNS_PROXY_FLAG_ENABLE_DNS)) {
        DnsReactivateEveryInterface();
    }

    DEREFERENCE_DNS_AND_RETURN(NO_ERROR);
    
} // DnsRmSetGlobalInfo


ULONG
APIENTRY
DnsRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
DnsRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The DNS proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_DNS_PROXY_MIB_QUERY Oidp;

    PROFILE("DnsRmMibGet");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !InputData || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        Oidp = (PIP_DNS_PROXY_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_DNS_PROXY_STATISTICS_OID: {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(DnsStatistics)) {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DnsStatistics);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
                else if (!OutputData) {
                    Error = ERROR_INVALID_PARAMETER;
                }
                else {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DnsStatistics);
                    Oidp = (PIP_DNS_PROXY_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_DNS_PROXY_STATISTICS_OID;
                    CopyMemory(
                        Oidp->Data,
                        &DnsStatistics,
                        sizeof(DnsStatistics)
                        );
                    Error = NO_ERROR;
                }
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_DNS_AND_RETURN(Error);
}


ULONG
APIENTRY
DnsRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\h323\h323if.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323if.c

Abstract:

    This module contains code for the H.323 transparent proxy's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop
#include <h323icsp.h>

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY H323InterfaceList;
CRITICAL_SECTION H323InterfaceLock;

//
// FORWARD DECLARATIONS
//

ULONG
H323ActivateInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'H323InterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    ULONG InterfaceCharacteristics;
    H323_INTERFACE_TYPE H323InterfaceType;

    PROFILE("H323ActivateInterface");

    EnterCriticalSection(&H323InterfaceLock);
    if (H323_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        return NO_ERROR;
    }

    InterfaceCharacteristics =
        NatGetInterfaceCharacteristics(
                Interfacep->Index
                );

    if (!InterfaceCharacteristics) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_H323,
            "H323ActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    Error = NO_ERROR;

    if (NAT_IFC_FW(InterfaceCharacteristics)) {
        H323InterfaceType = H323_INTERFACE_PUBLIC_FIREWALLED;
    } else if (NAT_IFC_BOUNDARY(InterfaceCharacteristics)) {
        H323InterfaceType = H323_INTERFACE_PUBLIC;
    } else {
        ASSERT(NAT_IFC_PRIVATE(InterfaceCharacteristics));
        H323InterfaceType = H323_INTERFACE_PRIVATE;
    }

    ACQUIRE_LOCK(Interfacep);

    H323ProxyActivateInterface(
        Interfacep->Index,
        H323InterfaceType,
        Interfacep->BindingInfo
        );

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&H323InterfaceLock);

    return NO_ERROR;

} // H323ActivateInterface


ULONG
H323BindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PH323_INTERFACE Interfacep;

    PROFILE("H323BindInterface");

    EnterCriticalSection(&H323InterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (H323_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&H323InterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding, and copy it
    //

    Interfacep->BindingInfo =
        reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
            NH_ALLOCATE(SIZEOF_IP_BINDING(BindingInfo->AddressCount))
            );
    if (!Interfacep->BindingInfo) {
        RELEASE_LOCK(Interfacep);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: allocation failed for interface %d binding",
            Index
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            SIZEOF_IP_BINDING(BindingInfo->AddressCount)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(
        Interfacep->BindingInfo,
        BindingInfo,
        SIZEOF_IP_BINDING(BindingInfo->AddressCount)
        );

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        Error = H323ActivateInterface(Interfacep);
    }

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323BindInterface


VOID
H323CleanupInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context, with no references
    to the interface.

--*/

{
    PLIST_ENTRY Link;

    PROFILE("H323CleanupInterface");

    if (Interfacep->BindingInfo) {
        NH_FREE(Interfacep->BindingInfo);
        Interfacep->BindingInfo = NULL;
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // H323CleanupInterface


ULONG
H323ConfigureInterface(
    ULONG Index,
    PIP_H323_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error;
    PH323_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("H323ConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323ConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323ConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&H323InterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|H323_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = H323ActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    } else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_H323_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = H323ActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        } else if (!(OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) &&
                    (NewFlags & IP_H323_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                H323DeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323ConfigureInterface


ULONG
H323CreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_H323_INTERFACE_INFO InterfaceInfo,
    OUT PH323_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the H.323 transparent proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PH323_INTERFACE Interfacep;

    PROFILE("H323CreateInterface");

    EnterCriticalSection(&H323InterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (H323LookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323CreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PH323_INTERFACE>(
                    NH_ALLOCATE(sizeof(H323_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "H323CreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(H323_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&H323InterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|H323_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&H323InterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // H323CreateInterface


VOID
H323DeactivateInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'H323InterfaceLock' held by caller.

--*/

{
    ULONG i;
    PLIST_ENTRY Link;

    PROFILE("H323DeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    // TODO: Call h323ics!DeactivateInterface
    H323ProxyDeactivateInterface(Interfacep->Index);

    RELEASE_LOCK(Interfacep);

} // H323DeactivateInterface


ULONG
H323DeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323DeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~H323_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    H323CleanupInterface(Interfacep);

    LeaveCriticalSection(&H323InterfaceLock);

    return NO_ERROR;

} // H323DeleteInterface


ULONG
H323DisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323DisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!H323_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~H323_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (H323_INTERFACE_BOUND(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // H323DisableInterface


ULONG
H323EnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    PH323_INTERFACE Interfacep;

    PROFILE("H323EnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (H323_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        Error = H323ActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323EnableInterface


ULONG
H323InitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("H323InitializeInterfaceManagement");

    InitializeListHead(&H323InterfaceList);
    __try {
        InitializeCriticalSection(&H323InterfaceLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "H323InitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // H323InitializeInterfaceManagement


PH323_INTERFACE
H323LookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PH323_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'H323InterfaceLock'
    held by caller.

--*/

{
    PH323_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("H323LookupInterface");
    for (Link = H323InterfaceList.Flink; Link != &H323InterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, H323_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // H323LookupInterface


ULONG
H323QueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323QueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!H323_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_H323_INTERFACE_INFO)) {
        LeaveCriticalSection(&H323InterfaceLock);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_H323_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_H323_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_H323_INTERFACE_INFO);

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // H323QueryInterface


VOID
H323ShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PH323_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("H323ShutdownInterfaceManagement");
    while (!IsListEmpty(&H323InterfaceList)) {
        Link = RemoveHeadList(&H323InterfaceList);
        Interfacep = CONTAINING_RECORD(Link, H323_INTERFACE, Link);
        if (H323_INTERFACE_ACTIVE(Interfacep)) {
            H323DeactivateInterface(Interfacep);
        }
        H323CleanupInterface(Interfacep);
    }
    DeleteCriticalSection(&H323InterfaceLock);

} // H323ShutdownInterfaceManagement


VOID
H323SignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the H.323
    transparent proxy is neither installed nor running; it operates as expected,
    since the global information and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323SignalNatInterface");

    EnterCriticalSection(&H323GlobalInfoLock);
    if (!H323GlobalInfo) {
        LeaveCriticalSection(&H323GlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&H323GlobalInfoLock);
    EnterCriticalSection(&H323InterfaceLock);
    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        return;
    }
    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        H323DeactivateInterface(Interfacep);
        H323ActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&H323InterfaceLock);

} // H323SignalNatInterface


ULONG
H323UnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323UnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!H323_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~H323_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (H323_INTERFACE_ENABLED(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingInfo);
    Interfacep->BindingInfo = NULL;
    RELEASE_LOCK(Interfacep);

    H323_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // H323UnbindInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\h323\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmh323.h"

#include "h323if.h"
#include "h323log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\h323\h323log.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323log.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   24-May-1999

Revision History:

--*/

#define IP_H323_LOG_BASE                       34000

#define IP_H323_LOG_NAT_INTERFACE_IGNORED      (IP_H323_LOG_BASE+1)
/*
 * The H.323 transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_H323_LOG_ALLOCATION_FAILED          (IP_H323_LOG_BASE+2)
/*
 * The H.323 transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_H323_LOG_END                        (IP_H323_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\h323\rmh323.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmh323.c

Abstract:

    This module contains routines for the H.323 transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <h323icsp.h>

COMPONENT_REFERENCE H323ComponentReference;
PIP_H323_GLOBAL_INFO H323GlobalInfo = NULL;
CRITICAL_SECTION H323GlobalInfoLock;
HANDLE H323NotificationEvent;
ULONG H323ProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS H323RoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_H323,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    H323RmStartProtocol,
    H323RmStartComplete,
    H323RmStopProtocol,
    H323RmGetGlobalInfo,
    H323RmSetGlobalInfo,
    NULL,
    NULL,
    H323RmAddInterface,
    H323RmDeleteInterface,
    H323RmInterfaceStatus,
    
    H323RmGetInterfaceInfo,
    H323RmSetInterfaceInfo,
    H323RmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    H323RmMibCreate,
    H323RmMibDelete,
    H323RmMibGet,
    H323RmMibSet,
    H323RmMibGetFirst,
    H323RmMibGetNext,
    NULL,
    NULL
};

SUPPORT_FUNCTIONS H323SupportFunctions;


VOID
H323CleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the H.323 transparent proxy module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    // TODO: Call h323ics!CleanupModule
    H323ProxyCleanupModule();

    H323ShutdownInterfaceManagement();
    DeleteCriticalSection(&H323GlobalInfoLock);
    DeleteComponentReference(&H323ComponentReference);

} // H323CleanupModule


VOID
H323CleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the H.323 transparent proxy
    protocol-component after a 'StopProtocol'. It runs when the last reference
    to the component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("H323CleanupProtocol");
    if (H323GlobalInfo) { NH_FREE(H323GlobalInfo); H323GlobalInfo = NULL; }

    // TODO: Call h323ics!StopService
    H323ProxyStopService();

    InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 1);
    SetEvent(H323NotificationEvent);
    ResetComponentReference(&H323ComponentReference);

    NhStopEventLog();
} // H323CleanupProtocol


BOOLEAN
H323InitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the H323 module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &H323ComponentReference, H323CleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&H323GlobalInfoLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&H323ComponentReference);
        return FALSE;
    }

    if (H323InitializeInterfaceManagement())  {
        DeleteCriticalSection(&H323GlobalInfoLock);
        DeleteComponentReference(&H323ComponentReference);
        return FALSE;
    }

    // TODO: Call h323ics!InitializeModule
    H323ProxyInitializeModule();

    return TRUE;

} // H323InitializeModule


ULONG
APIENTRY
H323RmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount    
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("H323RmStartProtocol");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER); }

    NhStartEventLog();
    
    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&H323GlobalInfoLock);

        Size = sizeof(*H323GlobalInfo);
    
        H323GlobalInfo
            = reinterpret_cast<PIP_H323_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!H323GlobalInfo) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "H323RmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_H323_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(H323GlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        H323NotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&H323SupportFunctions, sizeof(H323SupportFunctions));
        } else {
            CopyMemory(
                &H323SupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        Error = H323ProxyStartService();

        LeaveCriticalSection(&H323GlobalInfoLock);
        InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 0);

    } while (FALSE);

    if (NO_ERROR != Error) {
        NhStopEventLog();
        EnterCriticalSection(&H323GlobalInfoLock);
        if (NULL != H323GlobalInfo) {
            NH_FREE(H323GlobalInfo);
            H323GlobalInfo = NULL;
        }
        LeaveCriticalSection(&H323GlobalInfoLock);
    }

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmStartProtocol


ULONG
APIENTRY
H323RmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // H323RmStartComplete


ULONG
APIENTRY
H323RmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&H323ComponentReference);

    return DEREFERENCE_H323() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // H323RmStopProtocol


ULONG
APIENTRY
H323RmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmAddInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323CreateInterface(
            Index,
            Type,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmAddInterface


ULONG
APIENTRY
H323RmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmDeleteInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323DeleteInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmDeleteInterface


ULONG
APIENTRY
H323RmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("H323RmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // H323RmGetEventMessage


ULONG
APIENTRY
H323RmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("H323RmGetInterfaceInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323QueryInterface(
            Index,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmGetInterfaceInfo


ULONG
APIENTRY
H323RmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("H323RmSetInterfaceInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        H323ConfigureInterface(
            Index,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmSetInterfaceInfo


ULONG
APIENTRY
H323RmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = H323RmBindInterface(Index, StatusInfo);
            } else {
                Error = H323RmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = H323RmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = H323RmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // H323RmInterfaceStatus


ULONG
H323RmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmBindInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323BindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmBindInterface


ULONG
H323RmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmUnbindInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323UnbindInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmUnbindInterface


ULONG
H323RmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmEnableInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323EnableInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmEnableInterface


ULONG
H323RmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmDisableInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323DisableInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmDisableInterface


ULONG
APIENTRY
H323RmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("H323RmGetGlobalInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&H323GlobalInfoLock);
    Size = sizeof(*H323GlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&H323GlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_H323_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, H323GlobalInfo, Size);
    LeaveCriticalSection(&H323GlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_H323_AND_RETURN(NO_ERROR);
    
} // H323RmGetGlobalInfo


ULONG
APIENTRY
H323RmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_H323_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("H323RmSetGlobalInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*H323GlobalInfo);
    NewInfo = reinterpret_cast<PIP_H323_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "H323RmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_H323_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&H323GlobalInfoLock);
    OldFlags = H323GlobalInfo->Flags;
    NH_FREE(H323GlobalInfo);
    H323GlobalInfo = NewInfo;
    NewFlags = H323GlobalInfo->Flags;
    LeaveCriticalSection(&H323GlobalInfoLock);

    DEREFERENCE_H323_AND_RETURN(NO_ERROR);
    
} // H323RmSetGlobalInfo


ULONG
APIENTRY
H323RmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
H323RmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The transparent proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_H323_MIB_QUERY Oidp;

    PROFILE("H323RmMibGet");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Oidp = (PIP_H323_MIB_QUERY)InputData;
//      switch(Oidp->Oid) {
//          default: {
                NhTrace(
                    TRACE_FLAG_H323,
                    "H323RmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
//              break;
//          }
//      }
    }

    DEREFERENCE_H323_AND_RETURN(Error);
}


ULONG
APIENTRY
H323RmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\buffer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32

struct _NH_BUFFER;

//
// Typedef:     PNH_COMPLETION_ROUTINE
//

typedef
VOID
(*PNH_COMPLETION_ROUTINE)(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    struct _NH_BUFFER* Bufferp
    );


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    NhFixedLengthBufferType,
    NhVariableLengthBufferType
} NH_BUFFER_TYPE;

typedef struct _NH_BUFFER {
    union {
        LIST_ENTRY Link;
        NH_BUFFER_TYPE Type;
    };
    //
    // The socket associated with the buffer's most recent I/O request
    //
    SOCKET Socket;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
} NH_BUFFER, *PNH_BUFFER;

#define NH_ALLOCATE_BUFFER() \
    reinterpret_cast<PNH_BUFFER>(NH_ALLOCATE(sizeof(NH_BUFFER)))
    
#define NH_FREE_BUFFER(b)       NH_FREE(b)


//
// BUFFER-MANAGEMENT ROUTINES (alphabetically)
//

#define NhAcquireBuffer() NhAcquireFixedLengthBuffer()
PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    );

PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    );

PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    );

ULONG
NhInitializeBufferManagement(
    VOID
    );

VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    );

VOID
NhShutdownBufferManagement(
    VOID
    );

#endif // _NATHLP_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\compref.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    compref.h

Abstract:

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_COMPREF_H_
#define _NATHLP_COMPREF_H_

typedef
VOID
(*PCOMPONENT_CLEANUP_ROUTINE)(
    VOID
    );

//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the component's execution.
//

typedef struct _COMPONENT_REFERENCE {
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
#if COMPREF_TRACKING
    struct _COMPREF_RECORD* RecordArray;
    ULONG RecordIndex;
#endif
} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;

#if COMPREF_TRACKING
#define COMPREF_RECORD_COUNT    (1024)
typedef struct _COMPREF_RECORD {
    PCHAR File;
    USHORT Line;
    UCHAR ReferenceCount;
    enum {
        ComprefAcquireRecord,
        ComprefReleaseRecord
    } Type;
} COMPREF_RECORD, *PCOMPREF_RECORD;
#endif


//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    );
#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#if COMPREF_TRACKING

#define REFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)

#define DEREFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord); \
    return retcode

#else

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode

#endif


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    LeaveCriticalSection(&ComponentReference->Lock);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{
    DeleteCriticalSection(&ComponentReference->Lock);
#if COMPREF_TRACKING
    HeapFree(GetProcessHeap(), 0, ComponentReference->RecordArray);
#endif

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    __try {
        InitializeCriticalSection(&ComponentReference->Lock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ComponentReference->RecordArray =
        HeapAlloc(
            GetProcessHeap(), 0, sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
            );
#endif
    return NO_ERROR;

} // InitializeComponentReference



#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    )
{
    BOOLEAN Success;
    ULONG i = InterlockedIncrement(&ComponentReference->RecordIndex);
    i %= COMPREF_RECORD_COUNT;
    ComponentReference->RecordArray[i].File = File;
    ComponentReference->RecordArray[i].Line = (USHORT)Line;
    ComponentReference->RecordArray[i].Type = Type;
    if (Type == ComprefAcquireRecord) {
        Success = AcquireComponentReference(ComponentReference);
    } else {
        Success = ReleaseComponentReference(ComponentReference);
    }
    ComponentReference->RecordArray[i].ReferenceCount =
        (UCHAR)ComponentReference->ReferenceCount;
    return Success;
}

#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference


__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ZeroMemory(
        ComponentReference->RecordArray,
        sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
        );
#endif
    LeaveCriticalSection(&ComponentReference->Lock);
} // ReleaseComponentReference



#endif // _NATHLP_COMPREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\debug.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains declarations for debugging and eventlogging support.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DEBUG_H_
#define _NATHLP_DEBUG_H_

#define TRACE_FLAG_PROFILE      ((ULONG)0x00010000 | TRACE_USE_MASK)
#define TRACE_FLAG_SOCKET       ((ULONG)0x00020000 | TRACE_USE_MASK)
#define TRACE_FLAG_IF           ((ULONG)0x00040000 | TRACE_USE_MASK)
#define TRACE_FLAG_IO           ((ULONG)0x00080000 | TRACE_USE_MASK)
#define TRACE_FLAG_DHCP         ((ULONG)0x00100000 | TRACE_USE_MASK)
#define TRACE_FLAG_BUFFER       ((ULONG)0x00200000 | TRACE_USE_MASK)
#define TRACE_FLAG_INIT         ((ULONG)0x00400000 | TRACE_USE_MASK)
#define TRACE_FLAG_DNS          ((ULONG)0x00800000 | TRACE_USE_MASK)
#define TRACE_FLAG_NAT          ((ULONG)0x01000000 | TRACE_USE_MASK)
#define TRACE_FLAG_REG          ((ULONG)0x02000000 | TRACE_USE_MASK)
#define TRACE_FLAG_TIMER        ((ULONG)0x04000000 | TRACE_USE_MASK)
// 0x08000000 is available
#define TRACE_FLAG_H323         ((ULONG)0x10000000 | TRACE_USE_MASK)
#define TRACE_FLAG_FTP          ((ULONG)0x20000000 | TRACE_USE_MASK)
#define TRACE_FLAG_FWLOG        ((ULONG)0x40000000 | TRACE_USE_MASK)
#define TRACE_FLAG_ALG			((ULONG)0x80000000 | TRACE_USE_MASK)

#if 1
#define PROFILE(f)              NhTrace(TRACE_FLAG_PROFILE, f)
#else
#if DBG
#define PROFILE(f)              NhTrace(TRACE_FLAG_PROFILE, f)
#else
#define PROFILE(f)
#endif
#endif

extern HANDLE NhEventLogHandle;

//
// TRACING ROUTINE DECLARATIONS
//

VOID
NhDump(
    ULONG Flags,
    PUCHAR Buffer,
    ULONG BufferLength,
    ULONG Width
    );

VOID
NhInitializeTraceManagement(
    VOID
    );

VOID
NhShutdownTraceManagement(
    VOID
    );

VOID
NhTrace(
    ULONG Flags,
    PCHAR Format,
    ...
    );

//
// EVENT-LOGGING ROUTINE DECLARATIONS
//

BOOLEAN
NhInitializeEventLogManagement(
    VOID
    );

VOID
NhErrorLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhInformationLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhWarningLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhShutdownEventLogManagement(
    VOID
    );

VOID
NhStartEventLog(
    VOID
    );

VOID
NhStopEventLog(
    VOID
    );
    

#endif // _NATHLP_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\natapip.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    natapip.h

Abstract:

    This module contains private declarations for the NAT's I/O interface
    to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   16-Jun-1999

Revision History:

--*/

#ifndef _NATAPI_NATAPIP_H_
#define _NATAPI_NATAPIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))

#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

#ifndef REFERENCE_OBJECT
#define REFERENCE_OBJECT(x,deleted) \
    (deleted(x) ? FALSE : (InterlockedIncrement(&(x)->ReferenceCount), TRUE))
#endif

#ifndef DEREFERENCE_OBJECT
#define DEREFERENCE_OBJECT(x,cleanup) \
    (InterlockedDecrement(&(x)->ReferenceCount) ? TRUE : (cleanup(x), FALSE))
#endif

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );

#ifdef __cplusplus
}
#endif

#endif // _NATAPI_NATAPIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\natconn.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natconn.h

Abstract:

    This module contains declarations for the NAT's RAS connection management.
    Outgoing RAS client connections may be shared by associating them with
    a router-interface of type ROUTER_IF_TYPE_HOME_ROUTER.
    When such a connection is established by the user, we detect the connection
    and create a corresponding NAT interface with the kernel-mode translator.

Author:

    Abolade Gbadegesin (aboladeg)   2-May-1998

Revision History:

--*/

#ifndef _NATHLP_NATCONN_H_
#define _NATHLP_NATCONN_H_

extern HANDLE NatConnectionNotifyEvent;
extern HANDLE NatConfigurationChangedEvent;

//
// Structure : NAT_UDP_BROADCAST_MAPPING
//

typedef struct _NAT_UDP_BROADCAST_MAPPING
{
    LIST_ENTRY Link;
    USHORT usPublicPort;
    PVOID pvCookie;    
} NAT_UDP_BROADCAST_MAPPING, *PNAT_UDP_BROADCAST_MAPPING;

//
// Structure: NAT_PORT_MAPPING_ENTRY
//

typedef struct _NAT_PORT_MAPPING_ENTRY
{
    LIST_ENTRY Link;
    
    UCHAR ucProtocol;
    USHORT usPublicPort;
    ULONG ulPrivateAddress;
    USHORT usPrivatePort;

    BOOLEAN fNameActive;
    
    BOOLEAN fUdpBroadcastMapping;
    PVOID pvBroadcastCookie;

    GUID *pProtocolGuid;
    IHNetPortMappingProtocol *pProtocol;
    IHNetPortMappingBinding *pBinding;
    
} NAT_PORT_MAPPING_ENTRY, *PNAT_PORT_MAPPING_ENTRY;

//
// Structure: NAT_CONNECTION_ENTRY
//

typedef struct _NAT_CONNECTION_INFO
{
    LIST_ENTRY Link;

    //
    // Information needed to configure kernel driver
    //
    
    PIP_NAT_INTERFACE_INFO pInterfaceInfo;
    PIP_ADAPTER_BINDING_INFO pBindingInfo;
    NAT_INTERFACE Interface;
    ULONG AdapterIndex;

    //
    // HNetCfg interfaces for the connection
    //
    
    IHNetConnection *pHNetConnection;
    IHNetFirewalledConnection *pHNetFwConnection;
    IHNetIcsPublicConnection *pHNetIcsPublicConnection;

    //
    // Cached information describing the connection. Storing
    // this allows us to reduce roundtrips to the store.
    //
    
    HNET_CONN_PROPERTIES HNetProperties;
    GUID Guid;
    LPWSTR wszPhonebookPath;

    //
    // Stored port mapping information
    //

    LIST_ENTRY PortMappingList; // The length of this list is the sum of the counts
    ULONG PortMappingCount;
    ULONG UdpBroadcastPortMappingCount;
} NAT_CONNECTION_ENTRY, *PNAT_CONNECTION_ENTRY;

PNAT_CONNECTION_ENTRY
NatFindConnectionEntry(
    GUID *pGuid
    );

PNAT_PORT_MAPPING_ENTRY
NatFindPortMappingEntry(
    PNAT_CONNECTION_ENTRY pConnection,
    GUID *pGuid
    );

VOID
NatFreePortMappingEntry(
    PNAT_PORT_MAPPING_ENTRY pEntry
    );

PCHAR
NatQuerySharedConnectionDomainName(
    VOID
    );

ULONG
NatStartConnectionManagement(
    VOID
    );

VOID
NatStopConnectionManagement(
    VOID
    );

BOOLEAN
NatUnbindAllConnections(
    VOID
    );

HRESULT
NatpGetTargetAddressForPortMappingEntry(
    BOOLEAN fPublic,
    BOOLEAN fNameActive,
    ULONG BindingAddress,
    IHNetPortMappingBinding *pBinding,    
    OUT ULONG *pPrivateAddress
    );

#endif // _NATHLP_NATCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\nathlpp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    nathlpp.h

Abstract:

    This module contains declarations common to the user-mode components
    of home-networking.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATHLPP_H_
#define _NATHLP_NATHLPP_H_


//
// Object synchronization macros
//

#define ACQUIRE_LOCK(x)         EnterCriticalSection(&(x)->Lock)
#define RELEASE_LOCK(x)         LeaveCriticalSection(&(x)->Lock)

#define REFERENCE_OBJECT(x,deleted) \
    (deleted(x) \
        ? FALSE \
        : (InterlockedIncrement( \
            reinterpret_cast<LPLONG>(&(x)->ReferenceCount) \
            ), TRUE))

#define DEREFERENCE_OBJECT(x,cleanup) \
    (InterlockedDecrement(reinterpret_cast<LPLONG>(&(x)->ReferenceCount)) \
        ? TRUE \
        : (cleanup(x), FALSE))

//
// Memory management macros
//

#define NH_ALLOCATE(s)          HeapAlloc(GetProcessHeap(), 0, (s))
#define NH_FREE(p)              HeapFree(GetProcessHeap(), 0, (p))

//
// Protocol-related constants
//

#define DHCP_PORT_SERVER        0x4300
#define DHCP_PORT_CLIENT        0x4400

#define DNS_PORT_SERVER         0x3500
#define WINS_PORT_SERVER        0x8900

#define FTP_PORT_DATA           0x1400
#define FTP_PORT_CONTROL        0x1500

#define ALG_PORT_DATA           0x1600
#define ALG_PORT_CONTROL        0x1700

//
// DNS suffix string
//

#define DNS_HOMENET_SUFFIX      L"mshome.net"               // default string

#define IS_WILDCARD_MAPPING(pmap)    (                              \
            (pmap)->PublicAddress  == IP_NAT_ADDRESS_UNSPECIFIED && \
            (pmap)->PrivateAddress == htonl(INADDR_LOOPBACK) )

#endif // _NATHLP_NATHLPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\natlog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natlog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   25-Mar-1998

Revision History:

--*/

#define IP_NAT_LOG_BASE                             32000

#define IP_NAT_LOG_UPDATE_ARP_FAILED                (IP_NAT_LOG_BASE+1)
/*
 * The Network Address Translator (NAT) was unable to update the
 * local address-resolution table to respond to requests for
 * IP address %1 and mask %2.
 * Address-resolution may fail to operate for addresses in the given range.
 * This error may indicate a problem with TCP/IP networking,
 * or it may indicate lack of support for address-resolution
 * in the underlying network interface.
 * The data is the error code.
 */

#define IP_NAT_LOG_ALLOCATION_FAILED                (IP_NAT_LOG_BASE+2)
/*
 * The Network Address Translator (NAT) was unable to allocate %1 bytes.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_NAT_LOG_IOCTL_FAILED                     (IP_NAT_LOG_BASE+3)
/*
 * The Network Address Translator (NAT) was unable to request an operation
 * of the kernel-mode translation module.
 * This may indicate misconfiguration, insufficient resources, or
 * an internal error.
 * The data is the error code.
 */

#define IP_NAT_LOG_LOAD_DRIVER_FAILED               (IP_NAT_LOG_BASE+4)
/*
 * The Network Address Translator (NAT) was unable to load
 * the kernel-mode translation module.
 * The data is the error code.
 */

#define IP_NAT_LOG_UNLOAD_DRIVER_FAILED             (IP_NAT_LOG_BASE+5)
/*
 * The Network Address Translator (NAT) was unable to unload
 * the kernel-mode translation module.
 * The data is the error code.
 */

#define IP_NAT_LOG_SHARED_ACCESS_CONFLICT           (IP_NAT_LOG_BASE+6)
/*
 * The Internet Connection Sharing service could not start because
 * another process has taken control of the kernel-mode translation module.
 * This may occur when the Connection Sharing component has been installed
 * in the Routing and Remote Access Manager.
 * If this is the case, please remove the Connection Sharing component 
 * and restart the Internet Connection Sharing service.
 */

#define IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT        (IP_NAT_LOG_BASE+7)
/*
 * The Connection Sharing component could not start because another process
 * has taken control of the kernel-mode translation module.
 * This may occur when Internet Connection Sharing has been enabled
 * for a connection.
 * If this is the case, please disable Internet Connection Sharing
 * for the connection in the Network Connections folder and then
 * restart Routing and Remote Access.
 */

#define IP_NAT_LOG_EXPANSION_FAILED                 (IP_NAT_LOG_BASE+8)
/*
 * The Network Address Translator (NAT) was unable to expand the wildcard 
 * mappings.
 * This may indicate misconfiguration, insufficient resources, or
 * an internal error.
 * The data is the error code.
 */

#define IP_NAT_LOG_END                              (IP_NAT_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\natio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natio.h

Abstract:

    This module contains declarations for the NAT's I/O interface
    to the kernel-mode driver. It also contains the user-mode stubs
    which proxy router-manager requests to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATIO_H_
#define _NATHLP_NATIO_H_

//
// Structure:   NAT_INTERFACE
//
// This structure describes an interface which has been created with the NAT.
// Each interface is inserted into the list of interfaces, sorted by 'Index'.
// Access to the list of interfaces is controlled by 'NatInterfaceLock'.
//

typedef struct _NAT_INTERFACE {
    LIST_ENTRY Link;
    ULONG Index;
    ULONG AdapterIndex;
    ROUTER_INTERFACE_TYPE Type;
    ULONG Flags;
    PIP_NAT_INTERFACE_INFO Info;
} NAT_INTERFACE, *PNAT_INTERFACE;





#define NAT_INTERFACE_FLAG_ADDED_FTP		0x80000000
#define NAT_INTERFACE_ADDED_FTP(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_FTP)

#define NAT_INTERFACE_FLAG_BOUND			0x40000000
#define NAT_INTERFACE_BOUND(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_BOUND)

// 0x20000000 is available

#define NAT_INTERFACE_FLAG_ADDED_H323		0x10000000
#define NAT_INTERFACE_ADDED_H323(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_H323)

#define NAT_INTERFACE_FLAG_ADDED_ALG		0x08000000
#define NAT_INTERFACE_ADDED_ALG(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_ALG)

//
// GLOBAL VARIABLE DECLARATIONS
//

extern HANDLE NatFileHandle;
extern LIST_ENTRY NatInterfaceList;
extern CRITICAL_SECTION NatInterfaceLock;

//
// FUNCTION DECLARATIONS
//

ULONG
NatBindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo,
    ULONG AdapterIndex
    );

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatConfigureDriver(
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatConfigureInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    );

ULONG
NatCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    );

ULONG
NatCreateTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    );

ULONG
NatDeleteInterface(
    ULONG Index
    );

ULONG
NatDeleteTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    );

#define NAT_IF_CHAR_BOUNDARY    0x00000001
#define NAT_IF_CHAR_PRIVATE     0x00000002
#define NAT_IF_CHAR_FW          0x00000004

#define NAT_IFC_BOUNDARY(_Flags) \
    ((_Flags) & NAT_IF_CHAR_BOUNDARY)

#define NAT_IFC_PRIVATE(_Flags) \
    ((_Flags) & NAT_IF_CHAR_PRIVATE)

#define NAT_IFC_FW(_Flags) \
    ((_Flags) & NAT_IF_CHAR_FW)

ULONG
NatGetInterfaceCharacteristics(
    ULONG Index
    );

VOID
NatInstallApplicationSettings(
    VOID
    );

BOOLEAN
NatIsBoundaryInterface(
    ULONG Index,
    PBOOLEAN IsNatInterface OPTIONAL
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

ULONG
NatQueryInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo,
    PULONG InterfaceInfoSize
    );

ULONG
NatQueryInterfaceMappingTable(
    ULONG Index,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    );

ULONG
NatQueryMappingTable(
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    );

ULONG
NatQueryStatisticsInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics,
    PULONG InterfaceStatisticsSize
    );

VOID
NatRemoveApplicationSettings(
    VOID
    );

ULONG
NatUnbindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );

ULONG
NatLookupPortMappingAdapter(
    ULONG AdapterIndex,
    UCHAR Protocol,
    ULONG PublicAddress,
    USHORT PublicPort,
    PIP_NAT_PORT_MAPPING PortMappingp
    );

#endif // _NATHLP_NATIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\range.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    range.h

Abstract:

    This module implements an efficient mapping from an arbitrary range of
    IP addresses to a minimal set of IP address-mask pairs covering the range.

    The key to the approach is to regard the set of all possible IP addresses
    as a full 32-bit deep binary tree. Then a single IP address is a path
    through that tree, and a range of addresses is the area between two paths
    through the tree. We then describe such a path-delineated area by pruning
    full subtrees of the area recursively from left to right.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RANGE_H_
#define _NATHLP_RANGE_H_

typedef
VOID
(*PDECOMPOSE_RANGE_CALLBACK)(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );

VOID
DecomposeRange(
    ULONG StartAddress,
    ULONG EndAddress,
    ULONG Mask,
    PDECOMPOSE_RANGE_CALLBACK Callback,
    PVOID CallbackContext
    );

ULONG
MostGeneralMask(
    ULONG StartAddress,
    ULONG EndAddress
    );

#endif // _NATHLP_RANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmh323.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmh323.h

Abstract:

    This module declares routines for the H.323 transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:

--*/

#ifndef _NATHLP_RMH323_H_
#define _NATHLP_RMH323_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE H323ComponentReference;
extern PIP_H323_GLOBAL_INFO H323GlobalInfo;
extern CRITICAL_SECTION H323GlobalInfoLock;
extern HANDLE H323NotificationEvent;
extern ULONG H323ProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS H323RoutingCharacteristics;
extern SUPPORT_FUNCTIONS H323SupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_H323() \
    REFERENCE_COMPONENT(&H323ComponentReference)

#define REFERENCE_H323_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&H323ComponentReference,retcode)

#define DEREFERENCE_H323() \
    DEREFERENCE_COMPONENT(&H323ComponentReference)

#define DEREFERENCE_H323_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&H323ComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
H323CleanupModule(
    VOID
    );

BOOLEAN
H323InitializeModule(
    VOID
    );

ULONG
APIENTRY
H323RmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmStartComplete(
    VOID
    );

ULONG
APIENTRY
H323RmStopProtocol(
    VOID
    );

ULONG
APIENTRY
H323RmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
H323RmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
H323RmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
H323RmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
H323RmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
H323RmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
H323RmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
H323RmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMH323_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmapi.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmapi.h

Abstract:

    This module contains declarations for the part of the router-manager
    interface which is common to all the protocols in this component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMAPI_H_
#define _NATHLP_RMAPI_H_

typedef enum {
    NhUninitializedMode,
    NhSharedAccessMode,
    NhRoutingProtocolMode,
    NhMaximumMode
} NH_COMPONENT_MODE, *PNH_COMPONENT_MODE;

#define NhIsBoundaryInterface(i,b) NatIsBoundaryInterface((i),(b))
#define NhQuerySharedConnectionDomainName() NatQuerySharedConnectionDomainName()

extern NH_COMPONENT_MODE NhComponentMode;
extern CRITICAL_SECTION NhLock;
extern HMODULE NhpRtrmgrDll;
extern const WCHAR NhTcpipParametersString[];

//
// Application settings (response protocols) handling
//

extern LIST_ENTRY NhApplicationSettingsList;
extern LIST_ENTRY NhDhcpReservationList;
extern DWORD NhDhcpScopeAddress;
extern DWORD NhDhcpScopeMask;

typedef struct _NAT_APP_ENTRY
{
    LIST_ENTRY Link;
    UCHAR Protocol;
    USHORT Port;
    USHORT ResponseCount;
    HNET_RESPONSE_RANGE *ResponseArray;
} NAT_APP_ENTRY, *PNAT_APP_ENTRY;

typedef struct _NAT_DHCP_RESERVATION
{
    LIST_ENTRY Link;
    LPWSTR Name;
    ULONG Address;
} NAT_DHCP_RESERVATION, *PNAT_DHCP_RESERVATION;

typedef DWORD (CALLBACK *MAPINTERFACETOADAPTER)(DWORD);

VOID
NhBuildDhcpReservations(
    VOID
    );

ULONG
NhDialSharedConnection(
    VOID
    );

VOID
NhFreeApplicationSettings(
    VOID
    );

VOID
NhFreeDhcpReservations(
    VOID
    );

BOOLEAN
NhIsDnsProxyEnabled(
    VOID
    );

BOOLEAN
NhIsLocalAddress(
    ULONG Address
    );

BOOLEAN
NhIsWinsProxyEnabled(
    VOID
    );

PIP_ADAPTER_BINDING_INFO
NhQueryBindingInformation(
    ULONG AdapterIndex
    );

NTSTATUS
NhQueryDomainName(
    PCHAR* DomainName
    );

ULONG
NhQueryHostByName(
    PWCHAR pszHostName,
    PWCHAR pszDomainName,
    ULONG  ScopeNetwork,
    ULONG  ScopeMask
    );

NTSTATUS
NhQueryICSDomainSuffix(
    PWCHAR *ppszDomain
    );

NTSTATUS
NhQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    );

VOID
NhSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
NhMapAddressToAdapter(
    ULONG Address
    );

ULONG
NhMapInterfaceToAdapter(
    ULONG Index
    );

extern
ULONG
NhMapInterfaceToRouterIfType(
    ULONG Index
    );

VOID
NhResetComponentMode(
    VOID
    );

BOOLEAN
NhSetComponentMode(
    NH_COMPONENT_MODE ComponentMode
    );

VOID
NhUpdateApplicationSettings(
    VOID
    );

ULONG
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingCharacteristics,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceCharacteristics
    );

#endif // _NATHLP_RMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmalg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmALG.h

Abstract:

    This module declares routines for the ALG transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    JPDup		10-Nov-2000

Revision History:

    Savasg      22-Aug-2001 Added RRAS Support

--*/

#ifndef _NATHLP_RMALG_H_
#define _NATHLP_RMALG_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE                  AlgComponentReference;
extern PIP_ALG_GLOBAL_INFO                  AlgGlobalInfo;
extern CRITICAL_SECTION                     AlgGlobalInfoLock;
extern HANDLE                               AlgNotificationEvent;
extern HANDLE                               AlgTimerQueueHandle;
extern HANDLE                               AlgPortReservationHandle;
extern ULONG                                AlgProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS    AlgRoutingCharacteristics;
extern IP_ALG_STATISTICS                    AlgStatistics;
extern SUPPORT_FUNCTIONS                    AlgSupportFunctions;
extern HANDLE                               AlgTranslatorHandle;

//
// MACRO DECLARATIONS
//

#define REFERENCE_ALG() \
    REFERENCE_COMPONENT(&AlgComponentReference)

#define REFERENCE_ALG_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&AlgComponentReference,retcode)

#define DEREFERENCE_ALG() \
    DEREFERENCE_COMPONENT(&AlgComponentReference)

#define DEREFERENCE_ALG_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&AlgComponentReference, retcode)

#define ALG_PORT_RESERVATION_BLOCK_SIZE 32

//
// FUNCTION DECLARATIONS
//

VOID
AlgCleanupModule(
    VOID
    );

BOOLEAN
AlgInitializeModule(
    VOID
    );

ULONG
APIENTRY
AlgRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
AlgRmStartComplete(
    VOID
    );

ULONG
APIENTRY
AlgRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
AlgRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
AlgRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
AlgRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
AlgRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
AlgRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
AlgRmPortMappingChanged(
    ULONG Index,
    UCHAR Protocol,
    USHORT Port
    );


// Added for RRAS compatibility

ULONG
APIENTRY
AlgRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
AlgRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
AlgRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );


ULONG
APIENTRY
AlgRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
AlgRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
AlgRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
AlgRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
AlgRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
AlgRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMALG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmdhcp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdhcp.h

Abstract:

    This module declares routines for the DHCP allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMDHCP_H_
#define _NATHLP_RMDHCP_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE DhcpComponentReference;
extern PCHAR DhcpDomainName;
extern PIP_AUTO_DHCP_GLOBAL_INFO DhcpGlobalInfo;
extern CRITICAL_SECTION DhcpGlobalInfoLock;
extern HANDLE DhcpNotificationEvent;
extern ULONG DhcpProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS DhcpRoutingCharacteristics;
extern IP_AUTO_DHCP_STATISTICS DhcpStatistics;
extern SUPPORT_FUNCTIONS DhcpSupportFunctions;

extern BOOLEAN NoLocalDns; //whether DNS server is running or going to run on local host

//
// MACRO DECLARATIONS
//

#define REFERENCE_DHCP() \
    REFERENCE_COMPONENT(&DhcpComponentReference)

#define REFERENCE_DHCP_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&DhcpComponentReference,retcode)

#define DEREFERENCE_DHCP() \
    DEREFERENCE_COMPONENT(&DhcpComponentReference)

#define DEREFERENCE_DHCP_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&DhcpComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
DhcpCleanupModule(
    VOID
    );

BOOLEAN
DhcpInitializeModule(
    VOID
    );

ULONG
APIENTRY
DhcpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmStartComplete(
    VOID
    );

ULONG
APIENTRY
DhcpRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
DhcpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
DhcpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
DhcpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
DhcpRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DhcpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DhcpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMDNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\socket.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations for socket-management.
    The routines declared here operate asynchronously on sockets
    associated with an I/O completion port. They are also integrated
    with the component-reference object, which may optionally be used
    by callers to control the number of outstanding entries into a component's
    address-space. (See 'COMPREF.H'.)

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

    Jonathan Burstein (jonburs)     12-April-2001

    Added support for raw datagram sockets.

--*/


#ifndef _NATHLP_SOCKET_H_
#define _NATHLP_SOCKET_H_

#define INET_NTOA(x)    inet_ntoa(*(struct in_addr*)&(x))

ULONG
NhAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhCreateDatagramSocket(
    ULONG Address,
    USHORT Port,
    OUT SOCKET* Socketp
    );

ULONG
NhCreateRawDatagramSocket(
    OUT SOCKET* Socketp
    );

ULONG
NhCreateStreamSocket(
    ULONG Address OPTIONAL, // may be INADDR_NONE
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    );

#define NhDeleteDatagramSocket(s) NhDeleteSocket(s)
#define NhDeleteStreamSocket(s) NhDeleteSocket(s)

VOID
NhDeleteSocket(
    SOCKET Socket
    );

//
// BOOLEAN
// NhIsFatalSocketError(
//     ULONG Error
//     );
//
// Determines whether a request may be reissued on a socket,
// given the error-code from the previous issuance of the request.
// This macro is arranged to branch on the most common error-codes first.
//

#define \
NhIsFatalSocketError( \
    _Error \
    ) \
    ((_Error) != ERROR_OPERATION_ABORTED && \
    ((_Error) == WSAEDISCON || \
     (_Error) == WSAECONNRESET || \
     (_Error) == WSAETIMEDOUT || \
     (_Error) == WSAENETDOWN || \
     (_Error) == WSAENOTSOCK || \
     (_Error) == WSAESHUTDOWN || \
     (_Error) == WSAECONNABORTED))

ULONG
NhNotifyOnCloseStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
    PVOID Context,
    PVOID Context2
    );

VOID
NhQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    );

ULONG
NhQueryAddressSocket(
    SOCKET Socket
    );

ULONG
NhQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

USHORT
NhQueryPortSocket(
    SOCKET Socket
    );

ULONG
NhQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

ULONG
NhReadDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhWriteDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp,
    ULONG Length,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

#endif // _NATHLP_SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmdns.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdns.h

Abstract:

    This module declares routines for the DNS allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMDNS_H_
#define _NATHLP_RMDNS_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE DnsComponentReference;
extern PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo;
extern CRITICAL_SECTION DnsGlobalInfoLock;
extern SOCKET DnsGlobalSocket;
extern HANDLE DnsNotificationEvent;
extern ULONG DnsProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS DnsRoutingCharacteristics;
extern IP_DNS_PROXY_STATISTICS DnsStatistics;
extern SUPPORT_FUNCTIONS DnsSupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_DNS() \
    REFERENCE_COMPONENT(&DnsComponentReference)

#define REFERENCE_DNS_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&DnsComponentReference,retcode)

#define DEREFERENCE_DNS() \
    DEREFERENCE_COMPONENT(&DnsComponentReference)

#define DEREFERENCE_DNS_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&DnsComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
DnsCleanupModule(
    VOID
    );

BOOLEAN
DnsInitializeModule(
    VOID
    );

BOOLEAN
DnsIsDnsEnabled(
    VOID
    );

BOOLEAN
DnsIsWinsEnabled(
    VOID
    );

ULONG
APIENTRY
DnsRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmStartComplete(
    VOID
    );

ULONG
APIENTRY
DnsRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
DnsRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
DnsRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DnsRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
DnsRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
DnsRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmDisableInterface(
    ULONG Index
    );

ULONG
DnsEnableSuffixQuery(
    VOID
    );

ULONG
DnsDisableSuffixQuery(
    VOID
    );

ULONG
APIENTRY
DnsRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DnsRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DnsRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DnsRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMDNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\rmnat.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmnat.h

Abstract:

    This module declares routines for the NAT module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMNAT_H_
#define _NATHLP_RMNAT_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE NatComponentReference;
extern PIP_NAT_GLOBAL_INFO NatGlobalInfo;
extern CRITICAL_SECTION NatGlobalInfoLock;
extern HANDLE NatNotificationEvent;
extern ULONG NatProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS NatRoutingCharacteristics;
extern SUPPORT_FUNCTIONS NatSupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_NAT() \
    REFERENCE_COMPONENT(&NatComponentReference)

#define REFERENCE_NAT_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&NatComponentReference,retcode)

#define DEREFERENCE_NAT() \
    DEREFERENCE_COMPONENT(&NatComponentReference)

#define DEREFERENCE_NAT_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&NatComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
NatCleanupModule(
    VOID
    );

BOOLEAN
NatInitializeModule(
    VOID
    );

ULONG
APIENTRY
NatRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmStartComplete(
    VOID
    );

ULONG
APIENTRY
NatRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
NatRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
NatRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
NatRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
NatRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
NatRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
NatRmUnbindInterface(
    ULONG Index
    );

ULONG
NatRmEnableInterface(
    ULONG Index
    );

ULONG
NatRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
NatRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
NatRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmConnectClient(
    ULONG Index,
    PVOID ClientAddress
    );

ULONG
APIENTRY
NatRmDisconnectClient(
    ULONG Index,
    PVOID ClientAddress
    );

#endif // _NATHLP_RMNAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\inc\timer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    timer.h

Abstract:

    This module contains declarations for manipulating the timer-queue
    which is shared by all the components in this module.

    In addition to being used for protocol-related timers, the queue
    is used for periodically reissuing failed read-requests on sockets.

Author:

    Abolade Gbadegesin (aboladeg)   1-April-1998

Revision History:

--*/

#ifndef _NATHLP_TIMER_H_
#define _NATHLP_TIMER_H_

ULONG
NhInitializeTimerManagement(
    VOID
    );

NTSTATUS
NhSetTimer(
    PCOMPONENT_REFERENCE Component OPTIONAL,
    OUT HANDLE* Handlep OPTIONAL,
    WAITORTIMERCALLBACKFUNC TimerRoutine,
    PVOID Context,
    ULONG DueTime
    );

VOID
NhShutdownTimerManagement(
    VOID
    );

NTSTATUS
NhUpdateTimer(
    HANDLE Handle,
    ULONG DueTime
    );

#endif // _NATHLP_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natapi\natapi.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natapi.c

Abstract:

    This module contains code for API routines which provide translation
    functionality to user-mode clients of the NAT. This functionality
    differs from the 'normal' mode, in which a boundary-interface is designated
    and packets are transparently modified as they cross the boundary.
    This module instead allows an application to stipulate that certain
    modifications be made to a packet on any interface it is received.

Author:

    Abolade Gbadegesin  (aboladeg)  08-May-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

C_ASSERT(NAT_INVALID_IF_INDEX == INVALID_IF_INDEX);

//
// PRIVATE STRUCTURE DECLARATIONS
//

//
// Structure:   NAT_REDIRECT
//
// Encapsulates information about an outstanding redirect-instance.
// For a normal redirect, the structure holds the caller-specified
// completion-parameters and output statistics.
// For a dynamic redirect instance, the structure links this instance
// into the dynamic redirect's instance-list, and contains the notification
// event for the instance.
//

typedef struct _NAT_REDIRECT {
    union {
        struct _NAT_REDIRECT_TAIL {
            IO_STATUS_BLOCK IoStatus;
            PNAT_COMPLETION_ROUTINE CompletionRoutine;
            PVOID CompletionContext;
            IP_NAT_REDIRECT_STATISTICS Statistics;
        };
        struct _NAT_DYNAMIC_REDIRECT_TAIL {
            LIST_ENTRY Link;
            ULONG InstanceId;
            HANDLE Event;
            HANDLE WaitHandle;
            struct _NAT_DYNAMIC_REDIRECT_CONTEXT* Context;
        };
    };
} NAT_REDIRECT, *PNAT_REDIRECT;

//
// Structure:   NAT_DYNAMIC_REDIRECT
//
// Encapsulates information about an outstanding dynamic redirect.
// A dynamic redirect is automatically reissued using the caller's original
// parameters whenever the number of instances drops below a given minimum
// specified by the creator. We maintain a list of all instances of a dynamic
// redirect, and we replenish the list whenever an instance is activated
// or terminated without being activated.
//
// For each dynamic redirect, we maintain a reference-count which is used
// to control its lifetime. We make references to the dynamic redirect when
//  * the redirect is initially created, on behalf of its existence,
//  * an additional instance is issued, on behalf of the notification routine
//      for the instance.
//
// The usual rules for synchronization apply, to wit, to access any fields
// a reference must be held, and to add a reference the lock must be held,
// except at creation-time when the initial reference is made.
//

typedef struct _NAT_DYNAMIC_REDIRECT {
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Flags;
    HANDLE TranslatorHandle;
    ULONG MinimumBacklog;
    LIST_ENTRY InstanceList;
    IP_NAT_CREATE_REDIRECT_EX CreateRedirect;
} NAT_DYNAMIC_REDIRECT, *PNAT_DYNAMIC_REDIRECT;

#define NAT_DYNAMIC_REDIRECT_FLAG_DELETED   0x80000000
#define NAT_DYNAMIC_REDIRECT_DELETED(d) \
    ((d)->Flags & NAT_DYNAMIC_REDIRECT_FLAG_DELETED)

#define NAT_REFERENCE_DYNAMIC_REDIRECT(d) \
    REFERENCE_OBJECT(d, NAT_DYNAMIC_REDIRECT_DELETED)

#define NAT_DEREFERENCE_DYNAMIC_REDIRECT(d) \
    DEREFERENCE_OBJECT(d, NatpCleanupDynamicRedirect)

#define DEFAULT_DYNAMIC_REDIRECT_BACKLOG 5

//
// Structure:   NAT_DYNAMIC_REDIRECT_CONTEXT
//
// Used as the context-parameter for the notification and completion routines
// of each instance of a dynamic redirect.
//

typedef struct _NAT_DYNAMIC_REDIRECT_CONTEXT {
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp;
    ULONG InstanceId;
} NAT_DYNAMIC_REDIRECT_CONTEXT, *PNAT_DYNAMIC_REDIRECT_CONTEXT;


//
// GLOBAL DATA DEFINITIONS
//

LONG DllReferenceAdded = 0;
const WCHAR NatpServicePath[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IPNAT";
ULONG NextRedirectInstanceId = 0;
IO_STATUS_BLOCK UnusedIoStatus;
IP_NAT_REDIRECT_STATISTICS UnusedStatistics;

//
// FORWARD DECLARATIONS
//

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

VOID
NatpCleanupDynamicRedirect(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    );

VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

VOID NTAPI
NatpDynamicRedirectNotificationRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

VOID NTAPI
NatpRedirectCompletionRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );

VOID
NatpCreateDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    );

VOID
NatpDeleteDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp,
    PNAT_REDIRECT Redirectp
    );

BOOLEAN
NatpValidateRedirectParameters(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );


ULONG
NatCancelDynamicRedirect(
    HANDLE DynamicRedirectHandle
    )

/*++

Routine Description:

    This routine is called to cancel the given dynamic redirect.
    It cancels all instances of the dynamic redirect and releases the initial
    reference to the dynamic redirect, thus causing cleanup to occur as soon
    as all active references are released.

Arguments:

    DynamicRedirectHandle - the handle to the dynamic redirect to be cancelled

Return Value:

    ULONG - Win32 status code.

--*/

{
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp =
        (PNAT_DYNAMIC_REDIRECT)DynamicRedirectHandle;

    //
    // Lock the dynamic redirect, mark it 'deleted' to ensure that
    // no more instances are created by our notification routines,
    // and delete all outstanding instances.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    if (NAT_DYNAMIC_REDIRECT_DELETED(DynamicRedirectp)) {
        LeaveCriticalSection(&DynamicRedirectp->Lock);
        return ERROR_INVALID_PARAMETER;
    }
    DynamicRedirectp->Flags |= NAT_DYNAMIC_REDIRECT_FLAG_DELETED;
    while (!IsListEmpty(&DynamicRedirectp->InstanceList)) {
        PNAT_REDIRECT Redirectp =
            CONTAINING_RECORD(
                DynamicRedirectp->InstanceList.Flink,
                NAT_REDIRECT,
                Link
                );
        NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    //
    // Release the initial reference to the dynamic redirect and return.
    //

    NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
    return NO_ERROR;
} // NatCancelDynamicRedirect


ULONG
NatCancelRedirect(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort
    )

/*++

Routine Description:

    This routine is invoked to cancel a redirect for a session.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    * - specify the redirect to be cancelled

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_LOOKUP_REDIRECT CancelRedirect;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CancelRedirect.Flags = 0;
    CancelRedirect.RedirectApcContext = NULL;
    CancelRedirect.Protocol = Protocol;
    CancelRedirect.DestinationAddress = DestinationAddress;
    CancelRedirect.DestinationPort = DestinationPort;
    CancelRedirect.SourceAddress = SourceAddress;
    CancelRedirect.SourcePort = SourcePort;
    CancelRedirect.NewDestinationAddress = NewDestinationAddress;
    CancelRedirect.NewDestinationPort = NewDestinationPort;
    CancelRedirect.NewSourceAddress = NewSourceAddress;
    CancelRedirect.NewSourcePort = NewSourcePort;

    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CANCEL_REDIRECT,
            (PVOID)&CancelRedirect,
            sizeof(CancelRedirect),
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatCancelRedirect


VOID
NatCloseDriver(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This routine is called to close a handle to the NAT driver's device-object.

Arguments:

    FileHandle - the handle to be closed.

Return Value:

    none.

--*/

{
    NtClose(FileHandle);
} // NatCloseDriver


ULONG
NatCreateDynamicFullRedirect(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG RestrictAdapterIndex OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

/*++

Routine Description:

    This routine is invoked to create a redirect which is dynamically
    managed to ensure that there are always at least a specified minimum
    number of instances active. It is suitable for use by transparent proxies,
    which require assurance that all sessions matching a given description
    will be redirected by the kernel-mode translation module.

    The routine creates and initializes a structure which encapsulates all the
    information required to establish an instance of the caller's redirect.
    It then creates a series of instances of the redirect, and returns.
    We rely on notification routines to replace each instance that is
    activated or terminated.

Arguments:

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

    RestrictSourceAddress - optionally specifies the source address to which
        the redirect should be applied

    RestrictAdapterIndex - optionally specifies the adapter index that this
        redirect should be restricted to

    MinimumBacklog - optionally specifies the number of pending redirect
        instances to leave as a backlog

    DynamicRedirectHandlep - on output, receives a handle to the newly-created
        dynamic redirect.

Return Value:

    ULONG - Win32 status code.

--*/

{
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp;
    ULONG Error;
    ULONG i;

    if (!DynamicRedirectHandlep ||
        !NatpValidateRedirectParameters(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            (Flags & NatRedirectFlagRestrictSource) ? RestrictSourceAddress : SourceAddress,
            SourcePort,
            NewDestinationAddress,
            NewDestinationPort,
            NewSourceAddress,
            NewSourcePort,
            RestrictAdapterIndex
            )) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Create and initialize the new dynamic redirect.
    //

    DynamicRedirectp = MALLOC(sizeof(*DynamicRedirectp));
    if (!DynamicRedirectp) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(DynamicRedirectp, sizeof(*DynamicRedirectp));
    __try {
        InitializeCriticalSection(&DynamicRedirectp->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Error = GetExceptionCode();
        FREE(DynamicRedirectp);
        return Error;
    }
    DynamicRedirectp->ReferenceCount = 1;
    InitializeListHead(&DynamicRedirectp->InstanceList);
    DynamicRedirectp->TranslatorHandle = NULL;
    DynamicRedirectp->MinimumBacklog =
        (MinimumBacklog ? MinimumBacklog : DEFAULT_DYNAMIC_REDIRECT_BACKLOG);
    DynamicRedirectp->CreateRedirect.Flags =
        Flags | IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS;
    DynamicRedirectp->CreateRedirect.Protocol = Protocol;
    DynamicRedirectp->CreateRedirect.DestinationAddress = DestinationAddress;
    DynamicRedirectp->CreateRedirect.DestinationPort = DestinationPort;
    DynamicRedirectp->CreateRedirect.SourceAddress = SourceAddress;
    DynamicRedirectp->CreateRedirect.SourcePort = SourcePort;
    DynamicRedirectp->CreateRedirect.NewDestinationAddress =
        NewDestinationAddress;
    DynamicRedirectp->CreateRedirect.NewDestinationPort = NewDestinationPort;
    DynamicRedirectp->CreateRedirect.NewSourceAddress = NewSourceAddress;
    DynamicRedirectp->CreateRedirect.NewSourcePort = NewSourcePort;
    DynamicRedirectp->CreateRedirect.RestrictSourceAddress =
        RestrictSourceAddress;
    DynamicRedirectp->CreateRedirect.RestrictAdapterIndex =
        ((Flags & NatRedirectFlagRestrictAdapter)
            ? RestrictAdapterIndex
            : NAT_INVALID_IF_INDEX);

    //
    // Obtain a private handle to the kernel-mode translation module.
    // It is important that this handle be private because, as noted
    // in 'NatpDeleteDynamicRedirectInstance', we may mistakenly cancel
    // redirects during normal execution, and they had better belong to us.
    //

    if (Error = NatOpenDriver(&DynamicRedirectp->TranslatorHandle)) {
        NatpCleanupDynamicRedirect(DynamicRedirectp);
        return Error;
    }

    //
    // Add a reference to ipnathlp.dll if necessary; this reference
    // will never be released. This is needed to prevent a race condition
    // between the dll unloading during RRAS shutdown and the completion
    // of cleaning up all dynamic redirects and associated registered
    // waits (see bug 448249)
    //

    if (0 == InterlockedExchange(&DllReferenceAdded, 1)) {

        if (NULL == LoadLibraryW(L"ipnathlp.dll")) {

            //
            // For some reason the reference attempt failed. Reset
            // our tracking variable so the next caller through will
            // try this again.
            //

            InterlockedExchange(&DllReferenceAdded, 0);
        }
    }

    //
    // Issue the first set of redirects for the caller's minimum backlog.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    for (i = 0; i < DynamicRedirectp->MinimumBacklog; i++) {
        NatpCreateDynamicRedirectInstance(DynamicRedirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    *DynamicRedirectHandlep = (HANDLE)DynamicRedirectp;
    return NO_ERROR;

} // NatCreateDynamicFullRedirect


ULONG
NatCreateDynamicRedirect(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

{
    return
        NatCreateDynamicFullRedirect(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            0,
            0,
            NewDestinationAddress,
            NewDestinationPort,
            0,
            0,
            RestrictSourceAddress,
            0,
            MinimumBacklog,
            DynamicRedirectHandlep
            );
}


ULONG
NatCreateDynamicRedirectEx(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG RestrictAdapterIndex OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

{
    return
        NatCreateDynamicFullRedirect(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            0,
            0,
            NewDestinationAddress,
            NewDestinationPort,
            0,
            0,
            RestrictSourceAddress,
            RestrictAdapterIndex,
            MinimumBacklog,
            DynamicRedirectHandlep
            );
}


ULONG
NatCreateRedirect(
    HANDLE TranslatorHandle,
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    PNAT_COMPLETION_ROUTINE CompletionRoutine,
    PVOID CompletionContext,
    HANDLE NotifyEvent OPTIONAL
    )

{
    return NatCreateRedirectEx(
                TranslatorHandle,
                Flags,
                Protocol,
                DestinationAddress,
                DestinationPort,
                SourceAddress,
                SourcePort,
                NewDestinationAddress,
                NewDestinationPort,
                NewSourceAddress,
                NewSourcePort,
                0,
                CompletionRoutine,
                CompletionContext,
                NotifyEvent
                );
}


ULONG
NatCreateRedirectEx(
    HANDLE TranslatorHandle,
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL,
    PNAT_COMPLETION_ROUTINE CompletionRoutine,
    PVOID CompletionContext,
    HANDLE NotifyEvent OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to install a redirect for a session.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

    RestrictAdapterIndex - optionally specifies the adapter index that this
        redirect should be restricted to

    Completion* - specifies routine invoked on completion of the session,
        and the context to be passed to the routine

    NotifyEvent - optionally specifies an event to be signalled
        when a session matches the redirect.

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_REDIRECT_EX CreateRedirect;
    PNAT_REDIRECT Redirectp;
    PIO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE CompletionEvent;

    if (!NatpValidateRedirectParameters(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            SourceAddress,
            SourcePort,
            NewDestinationAddress,
            NewDestinationPort,
            NewSourceAddress,
            NewSourcePort,
            RestrictAdapterIndex
            )) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!CompletionRoutine) {
        Redirectp = NULL;
        IoStatus = &UnusedIoStatus;
        CompletionEvent = NULL;
    } else if (IPNATAPI_SET_EVENT_ON_COMPLETION == CompletionRoutine) {
        Redirectp = NULL;
        IoStatus = &UnusedIoStatus;
        CompletionEvent = (HANDLE)CompletionContext;
    } else {
        Redirectp = (PNAT_REDIRECT)MALLOC(sizeof(*Redirectp));
        if (!Redirectp) { return ERROR_NOT_ENOUGH_MEMORY; }
        Redirectp->CompletionRoutine = CompletionRoutine;
        Redirectp->CompletionContext = CompletionContext;
        IoStatus = &Redirectp->IoStatus;
    }

    if (Flags & NatRedirectFlagRestrictSource) {
        CreateRedirect.RestrictSourceAddress = SourceAddress;
        SourceAddress = 0;
    } else {
        CreateRedirect.RestrictSourceAddress = 0;
    }

    CreateRedirect.Flags = Flags;
    CreateRedirect.Protocol = Protocol;
    CreateRedirect.DestinationAddress = DestinationAddress;
    CreateRedirect.DestinationPort = DestinationPort;
    CreateRedirect.SourceAddress = SourceAddress;
    CreateRedirect.SourcePort = SourcePort;
    CreateRedirect.NewDestinationAddress = NewDestinationAddress;
    CreateRedirect.NewDestinationPort = NewDestinationPort;
    CreateRedirect.NewSourceAddress = NewSourceAddress;
    CreateRedirect.NewSourcePort = NewSourcePort;
    CreateRedirect.NotifyEvent = NotifyEvent;
    CreateRedirect.RestrictAdapterIndex =
        ((Flags & NatRedirectFlagRestrictAdapter)
            ? RestrictAdapterIndex
            : NAT_INVALID_IF_INDEX);

    if (!CompletionRoutine
        || IPNATAPI_SET_EVENT_ON_COMPLETION == CompletionRoutine ) {
        
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                CompletionEvent,
                NULL,
                NULL,
                IoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&CreateRedirect,
                sizeof(CreateRedirect),
                (PVOID)&UnusedStatistics,
                sizeof(UnusedStatistics)
                );
    } else {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                NULL,
                NatpRedirectCompletionRoutine,
                Redirectp,
                IoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&CreateRedirect,
                sizeof(CreateRedirect),
                (PVOID)&Redirectp->Statistics,
                sizeof(Redirectp->Statistics)
                );
    }
    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatCreateRedirect


ULONG
NatInitializeTranslator(
    PHANDLE TranslatorHandle
    )

/*++

Routine Description:

    This routine is invoked to prepare for translation by loading the NAT
    and installing all local adapters as interfaces.

Arguments:

    TranslatorHandle - receives the file handle of the NAT driver

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    IP_NAT_GLOBAL_INFO GlobalInfo;

    //
    // Initialize the NAT's global configuration
    //

    ZeroMemory(&GlobalInfo, sizeof(GlobalInfo));
    GlobalInfo.Header.Version = IP_NAT_VERSION;
    GlobalInfo.Header.Size = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);

    //
    // Start the NAT module.
    // This step causes the driver to be loaded.
    //

    Error = NatLoadDriver(TranslatorHandle, &GlobalInfo);
    if (Error) {
        return Error;
    }

    return NO_ERROR;

} // NatInitializeTranslator


ULONG
NatLoadDriver(
    PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    )

/*++

Routine Description:

    This routine is invoked to initialize the NAT's data and start the driver.

Arguments:

    FileHandle - receives the handle for the NAT's file-object

    GlobalInfo - the global information for the NAT.

Return Value:

    ULONG - Win32 status code.

--*/

{
    UNICODE_STRING DeviceName;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    HANDLE WaitEvent;

#if 0
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Request that the service controller load the driver.
    // Note that this will either succeed immediately or fail immediately;
    // there is no 'checkpoint' processing for starting drivers.
    //

    if (!(ScmHandle = OpenSCManager(NULL, NULL, GENERIC_READ))) {
        Error = GetLastError();
    } else {
        if (!(ServiceHandle =
            OpenServiceA(ScmHandle, IP_NAT_SERVICE_NAME, GENERIC_EXECUTE))) {
            Error = GetLastError();
        } else {
            if (!StartService(ServiceHandle, 0, NULL) &&
                (Error = GetLastError()) != ERROR_SERVICE_ALREADY_RUNNING) {
            } else {
                Error = NO_ERROR;
            }
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }
    if (Error) {
        return Error;
    }
}
#else
{
    UNICODE_STRING ServicePath;
    BOOLEAN WasEnabled;

    //
    // Turn on our driver-loading ability
    //

    if (!NatpEnableLoadDriverPrivilege(&WasEnabled)) {
        return ERROR_ACCESS_DENIED;
    }

    RtlInitUnicodeString(&ServicePath, NatpServicePath);

    //
    // Load the driver
    //

    status = NtLoadDriver(&ServicePath);

    //
    // Turn off the privilege
    //

    NatpDisableLoadDriverPrivilege(&WasEnabled);

    //
    // See if the load-attempt succeeded
    //

    if (!NT_SUCCESS(status) && status != STATUS_IMAGE_ALREADY_LOADED) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }
}
#endif

    //
    // Obtain a handle to the NAT's device-object.
    //

    Error = NatOpenDriver(FileHandle);
    if (Error) {
        return Error;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set the global configuration of the NAT
    //

    status =
        NtDeviceIoControlFile(
            *FileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_GLOBAL_INFO,
            (PVOID)GlobalInfo,
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + GlobalInfo->Header.Size,
            NULL,
            0
            );

    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(status)) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }

    return NO_ERROR;

} // NatLoadDriver


ULONG
NatLookupAndQueryInformationSessionMapping(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_SESSION_MAPPING_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine attempts to locate a particular session mapping using either
    its forward key or reverse key, and to query information for the mapping,
    if found.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    Protocol - the IP protocol for the mapping to be located

    Destination* - the destination endpoint for the mapping

    Source* - the source endpoint for the mapping

    Information - on output, receives the requested information

    InformationLength - on input, contains the length of the buffer
        at 'Information'; on output, receives the length of the information
        stored in 'Information', or the length of the buffer required.

    InformationClass - specifies

Return Value:

    ULONG - Win32 status code.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_LOOKUP_SESSION_MAPPING LookupMapping;
    NTSTATUS status;
    HANDLE WaitEvent;

    if (!InformationLength ||
        InformationClass >= NatMaximumSessionMappingInformation) {
        return ERROR_INVALID_PARAMETER;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LookupMapping.Protocol = Protocol;
    LookupMapping.DestinationAddress = DestinationAddress;
    LookupMapping.DestinationPort = DestinationPort;
    LookupMapping.SourceAddress = SourceAddress;
    LookupMapping.SourcePort = SourcePort;
    if (InformationClass == NatKeySessionMappingInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else if (InformationClass == NatStatisticsSessionMappingInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_STATISTICS,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else if (InformationClass == NatKeySessionMappingExInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY_EX,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else {
        CloseHandle(WaitEvent);
        return ERROR_INVALID_PARAMETER;
    }
    CloseHandle(WaitEvent);
    if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }

    switch(InformationClass) {
        case NatKeySessionMappingInformation: {
            *InformationLength = sizeof(NAT_KEY_SESSION_MAPPING_INFORMATION);
            break;
        }
        case NatStatisticsSessionMappingInformation: {
            *InformationLength =
                sizeof(NAT_STATISTICS_SESSION_MAPPING_INFORMATION);
            break;
        }
        case NatKeySessionMappingExInformation: {
            *InformationLength =
                sizeof(NAT_KEY_SESSION_MAPPING_EX_INFORMATION);
            break;
        }
        default: {
            return ERROR_INVALID_PARAMETER;
        }
    }
    return NO_ERROR;
} // NatLookupAndQueryInformationSessionMapping


ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    )

/*++

Routine Description:

    This routine is called to open the NAT driver's device-object.
    It assumes that the caller has loaded the driver already.

Arguments:

    FileHandle - on output, receives the new handle

Return Value:

    ULONG - Win32 status code.

--*/

{
    UNICODE_STRING DeviceName;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;

    //
    // Obtain a handle to the NAT's device-object.
    //

    RtlInitUnicodeString(&DeviceName, DD_IP_NAT_DEVICE_NAME);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status =
        NtOpenFile(
            FileHandle,
            SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatus,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            0
            );
    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }
    return NO_ERROR;
} // NatOpenDriver


VOID
NatpCleanupDynamicRedirect(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    )

/*++

Routine Description:

    This routine is invoked when the last reference to a dynamic redirect
    is released. It is responsible for cleaning up all resources in use
    by the redirect.

Arguments:

    DynamicRedirectp - the dynamic redirect to be cleaned up.

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    ASSERT(IsListEmpty(&DynamicRedirectp->InstanceList));
    if (DynamicRedirectp->TranslatorHandle) {
        NatCloseDriver(DynamicRedirectp->TranslatorHandle);
    }
    DeleteCriticalSection(&DynamicRedirectp->Lock);
    FREE(DynamicRedirectp);
} // NatpCleanupDynamicRedirect


VOID
NatpCreateDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    )

/*++

Routine Description:

    This routine is invoked to submit an additional instance of the given
    dynamic redirect. The redirect is associated with a notification event
    so that this module is notified when the redirect is either activated
    or terminated. In either case, another instance of the redirect will be
    created.

Arguments:

    DynamicRedirectp - the dynamic redirect to be reissued

Return Value:

    none.

Environment:

    Invoked with the dynamic-redirect's lock held by the caller.

--*/

{
    PNAT_REDIRECT Redirectp = NULL;
    NTSTATUS status;
    do {

        //
        // Allocate and initialize a new redirect-instance
        //

        if (!NAT_REFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp)) { break; }
        Redirectp = MALLOC(sizeof(*Redirectp));
        if (!Redirectp) {
            NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
            break;
        }
        ZeroMemory(Redirectp, sizeof(*Redirectp));
        Redirectp->InstanceId = InterlockedIncrement(&NextRedirectInstanceId);
        InsertTailList(&DynamicRedirectp->InstanceList, &Redirectp->Link);

        //
        // Create an event on which to receive notification of the redirect's
        // activation or termination, allocate a notification context block,
        // and register our notification routine for the event.
        //

        if (!(Redirectp->Event = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else if (!(Redirectp->Context =
                    MALLOC(sizeof(*Redirectp->Context)))) {
            break;
        } else {
            Redirectp->Context->DynamicRedirectp = DynamicRedirectp;
            Redirectp->Context->InstanceId = Redirectp->InstanceId;
            if (!RegisterWaitForSingleObject(
                    &Redirectp->WaitHandle,
                    Redirectp->Event,
                    NatpDynamicRedirectNotificationRoutine,
                    Redirectp->Context,
                    INFINITE,
                    WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE
                    )) {
                break;
            }
        }

        //
        // Issue the actual redirect request.
        // Now we will notified either by the kernel-mode translation module
        // when the instance is activated, or by the I/O manager when the
        // I/O control completes or is cancelled.
        //

        DynamicRedirectp->CreateRedirect.NotifyEvent = Redirectp->Event;
        status =
            NtDeviceIoControlFile(
                DynamicRedirectp->TranslatorHandle,
                Redirectp->Event,
                NULL,
                NULL,
                &UnusedIoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&DynamicRedirectp->CreateRedirect,
                sizeof(DynamicRedirectp->CreateRedirect),
                (PVOID)&UnusedStatistics,
                sizeof(UnusedStatistics)
                );
        if (!NT_SUCCESS(status)) {
            if (UnregisterWait(Redirectp->WaitHandle)) {
                FREE(Redirectp->Context);
                NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
            }
            Redirectp->WaitHandle = NULL;
            break;
        }
        return;
    } while(FALSE);
    if (Redirectp) {
        NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
    }
} // NatpCreateDynamicRedirectInstance


VOID
NatpDeleteDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp,
    PNAT_REDIRECT Redirectp
    )

/*++

Routine Description:

    This routine is invoked to delete a given instance of a dynamic redirect.
    The redirect is cancelled, synchronizing with the notification-routine
    for the instance.

Arguments:

    DynamicRedirectp - the dynamic redirect whose instance is to be deleted

    Redirectp - the dynamic redirect instance to be deleted

Return Value:

    none.

Environment:

    Invoked with the dynamic redirect's lock held by the caller.

--*/

{
    //
    // We need to cancel the outstanding redirect, which will have been created
    // if the wait-handle is non-NULL. However, when we issue the cancellation
    // we have no way to know if the instance in question is already being
    // completed by the kernel-mode translation module. If that is the case,
    // our cancellation may affect some other instance issued on this
    // translator-handle. It will not affect any instance issued on any other
    // translator-handle since the kernel-mode translator will not allow
    // redirects issued on one file-object to be cancelled from another
    // file-object.
    //
    // Since we own the translation-handle, though, it is alright for us to
    // erroneously cancel instances in this manner. The notification routine
    // for the cancelled instance will just create a replacement.
    //
    // There is additional point of synchronization to be noted.
    // If the notification routine runs, it is responsible for deleting
    // the notification context and releasing the reference to the dynamic
    // redirect. However, if we unregister our wait and the notification
    // routine never runs, we are responsible for both tasks.
    // The return code from 'UnregisterWait' is therefore used below as an
    // indication of whether the two tasks should be performed here or left
    // for the notification routine to perform.
    //
    // Finally, the instance only needs to be cancelled if its wait-handle
    // is valid, since otherwise the instance must have never been issued.
    //

    if (Redirectp->WaitHandle) {
        if (UnregisterWait(Redirectp->WaitHandle)) {
            FREE(Redirectp->Context);
            NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
        }
        Redirectp->WaitHandle = NULL;
        NatCancelRedirect(
            DynamicRedirectp->TranslatorHandle,
            DynamicRedirectp->CreateRedirect.Protocol,
            DynamicRedirectp->CreateRedirect.DestinationAddress,
            DynamicRedirectp->CreateRedirect.DestinationPort,
            DynamicRedirectp->CreateRedirect.SourceAddress,
            DynamicRedirectp->CreateRedirect.SourcePort,
            DynamicRedirectp->CreateRedirect.NewDestinationAddress,
            DynamicRedirectp->CreateRedirect.NewDestinationPort,
            DynamicRedirectp->CreateRedirect.NewSourceAddress,
            DynamicRedirectp->CreateRedirect.NewSourcePort
            );
    }
    if (Redirectp->Event) {
        CloseHandle(Redirectp->Event); Redirectp->Event = NULL;
    }
    RemoveEntryList(&Redirectp->Link);
    FREE(Redirectp);
} // NatpDeleteDynamicRedirectInstance


VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This routine is invoked to disable the previously-enable 'LoadDriver'
    privilege for the calling thread.

Arguments:

    WasEnabled - on input, indicates whether the privilege was already enabled.

Return Value:

    none.

--*/
{

    NTSTATUS Status;

    //
    // See if we had to enable SE_LOAD_DRIVER_PRIVILEGE
    //

    if (!*WasEnabled) {

        //
        // relinquish "Load-Driver" privileges for this thread
        //

        Status =
            RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                TRUE,
                WasEnabled
                );
    }

    //
    // return the thread to its previous access token
    //

    RevertToSelf();

} // NatpDisableLoadDriverPrivilege


VOID NTAPI
NatpDynamicRedirectNotificationRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked upon activation or termination of one of a
    dynamic redirect's instantiated redirects by an incoming session.
    It attempts to locate the corresponding instance and, if successful,
    closes the wait-handle and event for the instance, and adds another
    instance of the dynamic redirect to replace the one which has been
    activated or terminated.

Arguments:

    Context - contains context information for the notification

    WaitCompleted - indicates whether the wait completed or timed out

Return Value:

    none.

Environment:

    Invoked in the context of a system wait thread.

--*/

{
    PNAT_DYNAMIC_REDIRECT_CONTEXT Contextp =
        (PNAT_DYNAMIC_REDIRECT_CONTEXT)Context;
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp = Contextp->DynamicRedirectp;
    PLIST_ENTRY Link;
    PNAT_REDIRECT Redirectp;

    //
    // Search the dynamic redirect's list of instances for the instance
    // whose event has been signalled, and remove it after clearing the
    // wait-handle to ensure that the deletion-routine does not attempt
    // to cancel the redirect.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    for (Link = DynamicRedirectp->InstanceList.Flink;
         Link != &DynamicRedirectp->InstanceList; Link = Link->Flink) {
        Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, Link);
        if (Redirectp->InstanceId == Contextp->InstanceId) {
            UnregisterWait(Redirectp->WaitHandle);
            Redirectp->WaitHandle = NULL;
            NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
            break;
        }
    }

    FREE(Contextp);

    //
    // If the dynamic redirect has not been deleted,
    // replace the instance deleted above, if any.
    //

    if (!NAT_DYNAMIC_REDIRECT_DELETED(DynamicRedirectp)) {
        NatpCreateDynamicRedirectInstance(DynamicRedirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    //
    // Drop the original reference to the dynamic redirect, and return.
    //

    NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
} // NatpDynamicRedirectNotificationRoutine


BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This routine is invoked to enable the 'LoadDriver' privilege
    of the calling thread.

Arguments:

    WasEnabled - on output indicates whether the privilege was already enabled

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{
    NTSTATUS Status;

    //
    // Obtain the process' access token for the current thread
    //

    Status = RtlImpersonateSelf(SecurityImpersonation);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // request "Load-Driver" privileges for this thread
    //

    Status =
        RtlAdjustPrivilege(
            SE_LOAD_DRIVER_PRIVILEGE,
            TRUE,
            TRUE,
            WasEnabled
            );

    if (!NT_SUCCESS(Status)) {
        RevertToSelf();
        return FALSE;
    }

    return TRUE;

} // NatpEnableLoadDriverPrivilege


VOID NTAPI
NatpRedirectCompletionRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )

/*++

Routine Description:

    This routine is invoked upon completion of a redirect-IRP.

Arguments:

    Context - indicates the redirect which was completed

    IoStatus - contains the final status of the request

    Reserved - unused

Return Value:

    none.

--*/

{
    PNAT_REDIRECT Redirectp = (PNAT_REDIRECT)Context;
    if (Redirectp->CompletionRoutine) {
        Redirectp->CompletionRoutine(
            (HANDLE)Redirectp,
            (BOOLEAN)((IoStatus->Status == STATUS_CANCELLED) ? TRUE : FALSE),
            Redirectp->CompletionContext
            );
    }
    FREE(Redirectp);
} // NatpRedirectCompletionRoutine


BOOLEAN
NatpValidateRedirectParameters(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL
    )

/*++

Routine Description:

    This routine validates redirect parameters

Arguments:

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

Return Value:

    BOOLEAN: TRUE if parameters are OK; FALSE otherwise

--*/

{
    //
    // Make sure no invalid flags are specified
    //

    if (Flags & ~NatRedirectFlagsAll)
    {
        return FALSE;
    }

    //
    // TCP and UDP are the only valid protocols
    //

    if (Protocol != NAT_PROTOCOL_TCP && Protocol != NAT_PROTOCOL_UDP)
    {
        return FALSE;
    }

    //
    // Validate endpoint information. There are two different sets of
    // behavior, based on the presence of NatRedirectFlagSourceRedirect
    //

    if (!(Flags & NatRedirectFlagSourceRedirect))
    {
        //
        // A destination address must be specified, unless
        // NatRedirectFlagPortRedirect is set
        //

        if (!DestinationAddress & !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // There must be a destination port
        //

        if (!DestinationPort)
        {
            return FALSE;
        }

        //
        // Both the replacement destination address and port must be specified
        //

        if (!NewDestinationAddress || !NewDestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement source address and port are both specified or
        // unspecified
        //

        if (!!NewSourceAddress ^ !!NewSourcePort)
        {
            return FALSE;
        }

        //
        // The source port must be unspecified if the source address
        // is unspecified
        //

        if (!SourceAddress && SourcePort)
        {
            return FALSE;
        }

        
        //
        // The replacement source is unspecified then the source port
        // is also unspecified.
        //

        if (!NewSourceAddress && SourcePort)
        {
            return FALSE;
        }

        //
        // If the source address is specified w/o a replacement source,
        // the caller must specify the restrict-source flag indicating
        // that this is a partial redirect restricted to a particular source.
        //

        if (!NewSourceAddress && SourceAddress
            && !(Flags & NatRedirectFlagRestrictSource))
        {
            return FALSE;
        }

        //
        // If the restrict-source flag is specified, the caller is specifiying
        // a partial redirect w/ a source address
        //

        if ((Flags & NatRedirectFlagRestrictSource)
            && (NewSourceAddress || !SourceAddress))
        {
            return FALSE;
        }

        //
        // If the port-redirect flag is specified, the caller is specifying
        // only the destination port, replacement destination address, and
        // replacement destination port
        //

        if ((Flags & NatRedirectFlagPortRedirect)
            && (DestinationAddress || SourceAddress || SourcePort
                || NewSourceAddress || NewSourcePort))
        {
            return FALSE;
        }
    }
    else
    {
        //
        // The source address must be specified, unless
        // NatRedirectFlagPortRedirect is specified
        //

        if (!SourceAddress && !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // The source port must be specified
        //

        if (!SourcePort)
        {
            return FALSE;
        }

        //
        // No destination information may be specified
        //

        if (DestinationAddress || DestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement destination address and port are both specified
        // or unspecified
        //

        if (!!NewDestinationAddress ^ !!NewDestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement source address and port must be specified,
        // unless the port-redirect flag is set
        //

        if ((!NewSourceAddress || !NewSourcePort)
            && !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // If the port-redirect flag is specified, the caller is specifying
        // only the source port, replacement destination address, and
        // replacement destination port
        //

        if ((Flags & NatRedirectFlagPortRedirect)
            && (SourceAddress || DestinationAddress || DestinationPort
                || NewSourceAddress || NewSourcePort))
        {
            return FALSE;
        }

        //
        // The restrict-source-address flag is invalid
        //

        if (Flags & NatRedirectFlagRestrictSource)
        {
            return FALSE;
        }
    }

    //
    // The unidirectional flag is specified only for UDP redirects
    //

    if (Flags & NatRedirectFlagUnidirectional
        && Protocol != NAT_PROTOCOL_UDP)
    {
        return FALSE;
    }

    //
    // If the restrict-adapter-index flag is specified, the caller
    // has given a valid, non-zero (i.e., local) interface index
    //

    if ((Flags & NatRedirectFlagRestrictAdapter)
        && (NAT_INVALID_IF_INDEX == RestrictAdapterIndex
            || LOCAL_IF_INDEX == RestrictAdapterIndex))
    {
        return FALSE;
    }

    return TRUE;
}


ULONG
NatQueryInformationRedirect(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine is called to obtain information about the session
    for a completed redirect.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    * - specify the redirect to be queried

    Information - receives the retrieved information

    InformationLength - specifies the size of 'Information' on input;
        contains the required size on output

    InformationClass - indicates the class of information requested

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    IO_STATUS_BLOCK IoStatus;
    ULONG Length;
    IP_NAT_LOOKUP_REDIRECT QueryRedirect;
    IP_NAT_REDIRECT_STATISTICS RedirectStatistics;
    IP_NAT_REDIRECT_SOURCE_MAPPING RedirectSourceMapping;
    IP_NAT_REDIRECT_DESTINATION_MAPPING RedirectDestinationMapping;
    NTSTATUS status;
    HANDLE WaitEvent;

    if (!InformationLength ||
        InformationClass >= NatMaximumRedirectInformation) {
        return ERROR_INVALID_PARAMETER;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent== NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    QueryRedirect.Flags = 0;
    QueryRedirect.RedirectApcContext = NULL;
    QueryRedirect.Protocol = Protocol;
    QueryRedirect.DestinationAddress = DestinationAddress;
    QueryRedirect.DestinationPort = DestinationPort;
    QueryRedirect.SourceAddress = SourceAddress;
    QueryRedirect.SourcePort = SourcePort;
    QueryRedirect.NewDestinationAddress = NewDestinationAddress;
    QueryRedirect.NewDestinationPort = NewDestinationPort;
    QueryRedirect.NewSourceAddress = NewSourceAddress;
    QueryRedirect.NewSourcePort = NewSourcePort;

    if (InformationClass == NatDestinationMappingRedirectInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_DESTINATION_MAPPING,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectDestinationMapping,
                sizeof(RedirectDestinationMapping)
                );
    } else if (InformationClass == NatSourceMappingRedirectInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectSourceMapping,
                sizeof(RedirectSourceMapping)
                );
    } else {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_STATISTICS,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectStatistics,
                sizeof(RedirectStatistics)
                );
    }

    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }

    switch (InformationClass) {
        case NatByteCountRedirectInformation: {
            PNAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount =
                (PNAT_BYTE_COUNT_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*ByteCount)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                ByteCount->BytesForward = RedirectStatistics.BytesForward;
                ByteCount->BytesReverse = RedirectStatistics.BytesReverse;
            }
            *InformationLength = sizeof(*ByteCount);
            break;
        }
        case NatRejectRedirectInformation: {
            PNAT_REJECT_REDIRECT_INFORMATION Reject =
                (PNAT_REJECT_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*Reject)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                Reject->RejectsForward = RedirectStatistics.RejectsForward;
                Reject->RejectsReverse = RedirectStatistics.RejectsReverse;
            }
            *InformationLength = sizeof(*Reject);
            break;
        }
        case NatDestinationMappingRedirectInformation: {
            PNAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping =
                (PNAT_DESTINATION_MAPPING_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*DestinationMapping)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                DestinationMapping->DestinationAddress =
                    RedirectDestinationMapping.DestinationAddress;
                DestinationMapping->DestinationPort =
                    RedirectDestinationMapping.DestinationPort;
                DestinationMapping->NewDestinationAddress =
                    RedirectDestinationMapping.NewDestinationAddress;
                DestinationMapping->NewDestinationPort =
                    RedirectDestinationMapping.NewDestinationPort;
            }
            *InformationLength = sizeof(*DestinationMapping);
            break;
        }
        case NatSourceMappingRedirectInformation: {
            PNAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping =
                (PNAT_SOURCE_MAPPING_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*SourceMapping)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                SourceMapping->SourceAddress =
                    RedirectSourceMapping.SourceAddress;
                SourceMapping->SourcePort =
                    RedirectSourceMapping.SourcePort;
                SourceMapping->NewSourceAddress =
                    RedirectSourceMapping.NewSourceAddress;
                SourceMapping->NewSourcePort =
                    RedirectSourceMapping.NewSourcePort;
            }
            *InformationLength = sizeof(*SourceMapping);
            break;
        }
        default:
            return ERROR_INVALID_PARAMETER;
    }
    return Error;
} // NatQueryInformationRedirect


ULONG
NatQueryInformationRedirectHandle(
    HANDLE RedirectHandle,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine is invoked to retrieve information about a redirect upon
    completion of the associated I/O request. At this point, the kernel-mode
    driver is no longer aware of the redirect, and hence we read the requested
    information from the output-buffer for the redirect.

Arguments:

    RedirectHandle - identifies the redirect to be queried

    Information - receives the retrieved information

    InformationLength - specifies the size of 'Information' on input;
        contains the required size on output

    InformationClass - indicates the class of information requested

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Length;
    PNAT_REDIRECT Redirectp;

    if (!InformationLength) { return ERROR_INVALID_PARAMETER; }
    Redirectp = (PNAT_REDIRECT)RedirectHandle;
    switch (InformationClass) {
        case NatByteCountRedirectInformation: {
            PNAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount =
                (PNAT_BYTE_COUNT_REDIRECT_INFORMATION)Information;
            Length = sizeof(*ByteCount);
            if (*InformationLength < Length) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                ByteCount->BytesForward = Redirectp->Statistics.BytesForward;
                ByteCount->BytesReverse = Redirectp->Statistics.BytesReverse;
            }
            *InformationLength = Length;
            break;
        }
        case NatRejectRedirectInformation: {
            PNAT_REJECT_REDIRECT_INFORMATION Reject =
                (PNAT_REJECT_REDIRECT_INFORMATION)Information;
            Length = sizeof(*Reject);
            if (*InformationLength < Length) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                Reject->RejectsForward = Redirectp->Statistics.RejectsForward;
                Reject->RejectsReverse = Redirectp->Statistics.RejectsReverse;
            }
            *InformationLength = Length;
            break;
        }
        default:
            return ERROR_INVALID_PARAMETER;
    }
    return Error;
} // NatQueryInformationRedirectHandle


VOID
NatShutdownTranslator(
    HANDLE TranslatorHandle
    )

/*++

Routine Description:

    This routine is invoked to shut down the NAT.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

Return Value:

    none.

--*/

{
    NatUnloadDriver(TranslatorHandle);
} // NatShutdownTranslator


ULONG
NatUnloadDriver(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This routine is invoked to unload the NAT driver as the protocol stops.

Arguments:

    FileHandle - identifies the file-object for the NAT driver

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;

    //
    // Close our file-handle to the driver
    //

    if (FileHandle) { NtClose(FileHandle); }

#if 0
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Notify the service controller that the driver should be stopped.
    // If other processes are using the driver, this control will be ignored.
    //

    ScmHandle = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (ScmHandle) {
        ServiceHandle =
            OpenServiceA(ScmHandle, IP_NAT_SERVICE_NAME, GENERIC_EXECUTE);
        if (ServiceHandle) {
            ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }
}
#else
{
    UNICODE_STRING ServicePath;
    NTSTATUS status;
    BOOLEAN WasEnabled;

    //
    // Turn on our driver-unloading ability
    //

    if (!NatpEnableLoadDriverPrivilege(&WasEnabled)) {
        return ERROR_ACCESS_DENIED;
    }

    RtlInitUnicodeString(&ServicePath, NatpServicePath);

    //
    // Load the driver
    //

    status = NtUnloadDriver(&ServicePath);

    //
    // Turn off the privilege
    //

    NatpDisableLoadDriverPrivilege(&WasEnabled);

    //
    // See if the unload-attempt succeeded
    //

    if (!NT_SUCCESS(status)) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }
}
#endif

    return NO_ERROR;

} // NatUnloadDriver
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natapi\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ipnat.h>
#include <ipnatapi.h>
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <ipfirewall.h>
#include "natapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natapi\portapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    portapi.c

Abstract:

    This module contains code for API routines which provide port-reservation
    functionality to user-mode clients of TCP/IP. This functionality allows
    applications to 'reserve' blocks of TCP/UDP port-numbers for private use,
    preventing any other processes from binding to the reserved port-numbers.

Author:

    Abolade Gbadegesin (aboladeg)   25-May-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>
#include <ntddtcp.h>

//
// PRIVATE STRUCTURE DECLARATIONS
//

typedef struct _NAT_PORT_RESERVATION {
    CRITICAL_SECTION Lock;
    HANDLE TcpipHandle;
    USHORT BlockSize;
    USHORT PortBlockSize;
    LIST_ENTRY PortBlockList;
} NAT_PORT_RESERVATION, *PNAT_PORT_RESERVATION;

typedef struct _NAT_PORT_BLOCK {
    LIST_ENTRY Link;
    ULONG StartHandle;
    RTL_BITMAP Bitmap;
    ULONG BitmapBuffer[0];
} NAT_PORT_BLOCK, *PNAT_PORT_BLOCK;

//
// FORWARD DECLARATIONS
//

ULONG
NatpCreatePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK* PortBlockCreated
    );

VOID
NatpDeletePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK PortBlock
    );


ULONG
NatAcquirePortReservation(
    HANDLE ReservationHandle,
    USHORT PortCount,
    OUT PUSHORT ReservedPortBase
    )

/*++

Routine Description:

    This routine is called to reserve one or more contiguous port-numbers
    from the port-reservation handle supplied.

Arguments:

    ReservationHandle - supplies a port-reservation handle from which to
        acquire port-numbers

    PortCount - specifies the number of port-numbers required

    ReservedPortBase - receives the first port-number reserved,
        in network-order.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    ULONG Index;
    PLIST_ENTRY Link;
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;
    NTSTATUS Status;

    //
    // Fail immediately if the caller has requested more port-numbers
    // than would exist in a completely unallocated block.
    // Otherwise, traverse the list of port-blocks to see if any of the blocks
    // have enough contiguous port-numbers to satisfy the caller's request.
    //

    if (PortCount > PortReservation->BlockSize) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection(&PortReservation->Lock);
    
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PortBlock = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        Index = RtlFindClearBitsAndSet(&PortBlock->Bitmap, PortCount, 0);
        if (Index != (ULONG)-1) {
            *ReservedPortBase =
                RtlUshortByteSwap((USHORT)(PortBlock->StartHandle + Index));
            LeaveCriticalSection(&PortReservation->Lock);
            return NO_ERROR;
        }
    }

    //
    // No port-block had the required number of contiguous port-numbers.
    // Attempt to create a new port-block, and if that succeeds use it
    // to satisfy the caller's request.
    //

    Error = NatpCreatePortBlock(PortReservation, &PortBlock);
    if (NO_ERROR != Error) {
        LeaveCriticalSection(&PortReservation->Lock);
        return Error;
    }

    Index = RtlFindClearBitsAndSet(&PortBlock->Bitmap, PortCount, 0);
    *ReservedPortBase =
        RtlUshortByteSwap((USHORT)(PortBlock->StartHandle + Index));
    LeaveCriticalSection(&PortReservation->Lock);
    return NO_ERROR;
} // NatAcquirePortReservation


ULONG
NatInitializePortReservation(
    USHORT BlockSize,
    OUT PHANDLE ReservationHandle
    )

/*++

Routine Description:

    This routine is called to initialize a handle to the port-reservation
    module. The resulting handle is used to acquire and release ports
    from the dynamically-allocated block.

Arguments:

    BlockSize - indicates the number of ports to request each time
        an additional block is requested from the TCP/IP driver.

    ReservationHandle - on output, receives a handle to be used for
        acquiring and releasing ports.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG BitmapSize;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PNAT_PORT_RESERVATION PortReservation;
    NTSTATUS Status;
    HANDLE TcpipHandle;
    UNICODE_STRING UnicodeString;
    do {

        //
        // Open a handle to the TCP/IP driver.
        // This handle will later be used to issue reservation-requests.
        //

        RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);
        InitializeObjectAttributes(
            &ObjectAttributes, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL
            );
        Status =
            NtCreateFile(
                &TcpipHandle,
                SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
                &ObjectAttributes,
                &IoStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_OPEN_IF,
                0,
                NULL,
                0
                );
        if (!NT_SUCCESS(Status)) { break; }

        //
        // Allocate and initialize a port-reservation context block.
        //

        PortReservation = MALLOC(sizeof(*PortReservation));
        if (!PortReservation) { Status = STATUS_NO_MEMORY; break; }
        if (FALSE == InitializeCriticalSectionAndSpinCount(&PortReservation->Lock, 0)) {
            Status = STATUS_NO_MEMORY;
            break;
        }
        PortReservation->TcpipHandle = TcpipHandle;
        PortReservation->BlockSize = BlockSize;
        BitmapSize = (BlockSize + sizeof(ULONG) * 8 - 1) / (sizeof(ULONG) * 8);
        PortReservation->PortBlockSize =
            (USHORT)FIELD_OFFSET(NAT_PORT_BLOCK, BitmapBuffer[BitmapSize]);
        InitializeListHead(&PortReservation->PortBlockList);
        *ReservationHandle = (HANDLE)PortReservation;
        return NO_ERROR;
    } while(FALSE);
    if (TcpipHandle) { NtClose(TcpipHandle); }
    if (PortReservation) { FREE(PortReservation); }
    return RtlNtStatusToDosError(Status);
} // NatInitializePortReservation


ULONG
NatpCreatePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK* PortBlockCreated
    )

/*++

Routine Description:

    This routine is called to create a new port-block when the existing
    port-numbers have been exhausted.

Arguments:

    PortReservation - the reservation to which the port-block should be added

    PortBlockCreated - on output, receives the new port-block

Return Value:

    ULONG - Win32 error code; return NO_ERROR if successful.


Environment:

    PortReservation->Lock must be held by the caller.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    PLIST_ENTRY Link;
    PNAT_PORT_BLOCK PortBlock;
    TCP_BLOCKPORTS_REQUEST Request;
    ULONG StartHandle;
    NTSTATUS Status;
    HANDLE WaitEvent;

    //
    // Allocate memory for the new port-block and its bitmap of free ports
    //

    PortBlock = MALLOC(PortReservation->PortBlockSize);
    if (!PortBlock) { return ERROR_NOT_ENOUGH_MEMORY; }

    //
    // Request a new block of ports from the TCP/IP driver
    //

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        FREE(PortBlock);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Request.ReservePorts = TRUE;
    Request.NumberofPorts = PortReservation->BlockSize;
    Status =
        NtDeviceIoControlFile(
            PortReservation->TcpipHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_TCP_BLOCK_PORTS,
            &Request,
            sizeof(Request),
            &StartHandle,
            sizeof(StartHandle)
            );
    if (Status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        Status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(Status)) {
        FREE(PortBlock); return RtlNtStatusToDosError(Status);
    }

    //
    // Initialize the new port-block, and insert it in the list of ports.
    //

    PortBlock->StartHandle = StartHandle;
    RtlInitializeBitMap(
        &PortBlock->Bitmap,
        PortBlock->BitmapBuffer,
        PortReservation->BlockSize
        );
    RtlClearAllBits(&PortBlock->Bitmap);
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PNAT_PORT_BLOCK Temp = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        if (PortBlock->StartHandle > Temp->StartHandle) {
            continue;
        } else {
            break;
        }
        ASSERTMSG("NatpCreatePortBlock: duplicate port range\n", TRUE);
    }
    InsertTailList(Link, &PortBlock->Link);
    if (PortBlockCreated) { *PortBlockCreated = PortBlock; }
    return NO_ERROR;
} // NatpCreatePortBlock


VOID
NatpDeletePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK PortBlock
    )

/*++

Routine Description:

    This routine is called to delete a port-block when the port-numbers
    it contains have been released, or when the port-reservation is cleaned up.

Arguments:

    PortReservation - the reservation to which the port-block belongs

    PortBlock - the port block to be deleted

Return Value:

    none.

Environment:

PortReservation->Lock must be held by the caller.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    TCP_BLOCKPORTS_REQUEST Request;
    NTSTATUS Status;
    HANDLE WaitEvent;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return;
    }

    //
    // Release the block of ports to the TCP/IP driver
    //

    Request.ReservePorts = FALSE;
    Request.StartHandle = PortBlock->StartHandle;
    Status =
        NtDeviceIoControlFile(
            PortReservation->TcpipHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_TCP_BLOCK_PORTS,
            &Request,
            sizeof(Request),
            NULL,
            0
            );
    if (Status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        Status = IoStatus.Status;
    }
    RemoveEntryList(&PortBlock->Link);
    FREE(PortBlock);
    CloseHandle(WaitEvent);
} // NatpDeletePortBlock


ULONG
NatReleasePortReservation(
    HANDLE ReservationHandle,
    USHORT ReservedPortBase,
    USHORT PortCount
    )

/*++

Routine Description:

    This routine is called to release all contiguous port-numbers obtained
    in a previous acquisition from the port-reservation handle supplied.

Arguments:

    ReservationHandle - supplies a port-reservation handle to which to
        release port-numbers

    ReservedPortBase - receives the first port-number reserved,
        in network-order.

    PortCount - specifies the number of port-numbers acquired

Return Value:

    ULONG - Win32 status code.

--*/

{
    PLIST_ENTRY Link;
    USHORT PortBase;
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;

    EnterCriticalSection(&PortReservation->Lock);

    //
    // Convert the caller's port-base into host-order,
    // and search the sorted list of port-blocks for the entry
    // from which the acquisition was made.
    //

    PortBase = RtlUshortByteSwap(ReservedPortBase);
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PortBlock = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        if (PortBase < PortBlock->StartHandle) {
            break;
        } else if (PortBase <
                   (PortBlock->StartHandle + PortReservation->BlockSize)) {

            //
            // This should be the block from which the caller's port-numbers
            // were acquired. For good measure, check that the end of the
            // callers range also falls within this block.
            //

            if ((PortBase + PortCount - 1) >=
                (USHORT)(PortBlock->StartHandle + PortReservation->BlockSize)) {

                //
                // The caller has probably supplied an incorrect length,
                // or is releasing an allocation twice, or something.
                //

                LeaveCriticalSection(&PortReservation->Lock);
                return ERROR_INVALID_PARAMETER;
            } else {

                //
                // This is the caller's range. Clear the bits corresponding
                // to the caller's acquisition, and then see if there are
                // any bits left in the bitmap. If not, and if there are
                // other port-blocks, delete this port-block altogether.
                //

                RtlClearBits(
                    &PortBlock->Bitmap,
                    PortBase - PortBlock->StartHandle,
                    PortCount
                    );
                if (RtlFindSetBits(&PortBlock->Bitmap, 1, 0) == (ULONG)-1 &&
                    (PortBlock->Link.Flink != &PortReservation->PortBlockList ||
                     PortBlock->Link.Blink != &PortReservation->PortBlockList)
                    ) {
                    NatpDeletePortBlock(PortReservation, PortBlock);
                }
                LeaveCriticalSection(&PortReservation->Lock);
                return NO_ERROR;
            }
        } else {
            continue;
        }
    }

    LeaveCriticalSection(&PortReservation->Lock);

    //
    // We could not find the port-block from which the caller
    // allegedly acquired this range of port-numbers.
    //

    return ERROR_CAN_NOT_COMPLETE;
} // NatReleasePortReservation


VOID
NatShutdownPortReservation(
    HANDLE ReservationHandle
    )

/*++

Routine Description:

    This routine is called to clean up a handle to the port-reservation module.
    It releases all reservations acquired, and closes the handle to the TCP/IP
    driver.

Arguments:

    ReservationHandle - the handle to be cleaned up

Return Value:

    none.

--*/

{
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;
    while (!IsListEmpty(&PortReservation->PortBlockList)) {
        PortBlock =
            CONTAINING_RECORD(
                PortReservation->PortBlockList.Flink, NAT_PORT_BLOCK, Link
                );
        NatpDeletePortBlock(PortReservation, PortBlock);
    }
    NtClose(PortReservation->TcpipHandle);
    DeleteCriticalSection(&PortReservation->Lock);
    FREE(PortReservation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\csaupdate.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    csaupdate.cpp

Abstract:

    Implementation of CSharedAccessUpdate -- notification sink for
    configuration changes.

Author:

    Jonathan Burstein (jonburs)     20 April 2001

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include "beacon.h"

//
// Define a macro version of ntohs which can be applied to constants,
// and which can thus be computed at compile time.
//

#define NTOHS(p)    ((((p) & 0xFF00) >> 8) | (((UCHAR)(p) << 8)))


//
// H.323/LDAP proxy ports 
//

#define H323_Q931_PORT      NTOHS(1720)
#define H323_LDAP_PORT      NTOHS(389)
#define H323_LDAP_ALT_PORT  NTOHS(1002)

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// Interface methods
//

STDMETHODIMP
CSharedAccessUpdate::ConnectionPortMappingChanged(
    GUID *pConnectionGuid,
    GUID *pPortMappingGuid,
    BOOLEAN fProtocolChanged
    )
{
    BOOLEAN fEnabled;
    BOOLEAN fRebuildDhcpList = TRUE;
    HRESULT hr = S_OK;
    IHNetPortMappingBinding *pBinding;
    PNAT_CONNECTION_ENTRY pConnection;
    PNAT_PORT_MAPPING_ENTRY pPortMapping;
    IHNetPortMappingProtocol *pProtocol;
    ULONG ulError;
    USHORT usNewPort = 0;
    UCHAR ucNewProtocol = 0;
    USHORT usOldPort = 0;
    UCHAR ucOldProtocol = 0;

    PROFILE("ConnectionPortMappingChanged");

    EnterCriticalSection(&NatInterfaceLock);

    do
    {
        pConnection = NatFindConnectionEntry(pConnectionGuid);
        if (NULL == pConnection) { break; }

        //
        // If the connection is not yet bound then there's nothing
        // that we need to do here.
        //

        if (!NAT_INTERFACE_BOUND(&pConnection->Interface)) { break; }

        //
        // Locate the old port mapping entry. This entry won't exist if
        // this port mapping wasn't previously enabled.
        //

        pPortMapping = NatFindPortMappingEntry(pConnection, pPortMappingGuid);

        if (NULL != pPortMapping)
        {
            //
            // Remove this entry from the connection list and
            // delete the old ticket / UDP broadcast entry.
            //

            RemoveEntryList(&pPortMapping->Link);
            
            if (pPortMapping->fUdpBroadcastMapping)
            {
                if (0 != pPortMapping->pvBroadcastCookie)
                {
                    ASSERT(NULL != NhpUdpBroadcastMapper);
                    hr = NhpUdpBroadcastMapper->CancelUdpBroadcastMapping(
                            pPortMapping->pvBroadcastCookie
                            );

                    pPortMapping->pvBroadcastCookie = 0;
                }

                pConnection->UdpBroadcastPortMappingCount -= 1;
            }
            else
            {
                ulError =
                    NatDeleteTicket(
                        pConnection->AdapterIndex,
                        pPortMapping->ucProtocol,
                        pPortMapping->usPublicPort,
                        IP_NAT_ADDRESS_UNSPECIFIED,
                        pPortMapping->usPrivatePort,
                        pPortMapping->ulPrivateAddress
                        );

                pConnection->PortMappingCount -= 1;
            }

            //
            // Store the old protocol / port information so that
            // we can notify H.323 (if necessary) and the ALG manager.
            //

            ucOldProtocol = pPortMapping->ucProtocol;
            usOldPort = pPortMapping->usPublicPort;            

            //
            // Check to see if this mapping is still enabled. (We ignore
            // errors from above.)
            //

            hr = pPortMapping->pBinding->GetEnabled(&fEnabled);
            if (FAILED(hr) || !fEnabled)
            {
                //
                // We'll need to rebuild the DHCP reservation
                // list only if this was a named-based mapping.
                //

                fRebuildDhcpList = pPortMapping->fNameActive;
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }
        else
        {
            //
            // Allocate a new port mapping entry
            //

            pPortMapping =
                reinterpret_cast<PNAT_PORT_MAPPING_ENTRY>(
                    NH_ALLOCATE(sizeof(*pPortMapping))
                    );
            
            if (NULL == pPortMapping)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            ZeroMemory(pPortMapping, sizeof(*pPortMapping));
            pPortMapping->pProtocolGuid =
                reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

            if (NULL != pPortMapping->pProtocolGuid)
            {
                CopyMemory(
                    pPortMapping->pProtocolGuid,
                    pPortMappingGuid,
                    sizeof(GUID));
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            
            //
            // Load the protocol and binding 
            //

            IHNetCfgMgr *pCfgMgr;
            IHNetProtocolSettings *pProtocolSettings;

            hr = NhGetHNetCfgMgr(&pCfgMgr);
            if (SUCCEEDED(hr))
            {
                hr = pCfgMgr->QueryInterface(
                        IID_PPV_ARG(IHNetProtocolSettings, &pProtocolSettings)
                        );
                pCfgMgr->Release();
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocolSettings->FindPortMappingProtocol(
                        pPortMappingGuid,
                        &pPortMapping->pProtocol
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pConnection->pHNetConnection->GetBindingForPortMappingProtocol(
                            pPortMapping->pProtocol,
                            &pPortMapping->pBinding
                            );
                }

                pProtocolSettings->Release();
            }

            if (SUCCEEDED(hr))
            {
                //
                // Check if this protocol is enabled
                //

                hr = pPortMapping->pBinding->GetEnabled(&fEnabled);
            }

            if (FAILED(hr) || !fEnabled)
            {
                //
                // We don't need to rebuild the DHCP reservations.
                //

                fRebuildDhcpList = FALSE;
                NatFreePortMappingEntry(pPortMapping);
                break;
            }

            //
            // Since this is a new entry we always need to load the
            // protocol.
            //

            fProtocolChanged = TRUE;
        }

        //
        // Gather the new information
        //

        if (fProtocolChanged)
        {
            //
            // Need to reload the protocol information
            //

            hr = pPortMapping->pProtocol->GetIPProtocol(&pPortMapping->ucProtocol);

            if (SUCCEEDED(hr))
            {
                hr = pPortMapping->pProtocol->GetPort(&pPortMapping->usPublicPort);
            }

            if (FAILED(hr))
            {
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }

        //
        // Load the binding information
        //

        hr = pPortMapping->pBinding->GetTargetPort(&pPortMapping->usPrivatePort);

        if (SUCCEEDED(hr))
        {
            BOOLEAN fOldNameActive = pPortMapping->fNameActive;
            hr = pPortMapping->pBinding->GetCurrentMethod(&pPortMapping->fNameActive);

            if (!fOldNameActive && !pPortMapping->fNameActive)
            {
                fRebuildDhcpList = FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = NatpGetTargetAddressForPortMappingEntry(
                     pConnection->HNetProperties.fIcsPublic,
                     pPortMapping->fNameActive,
                     pConnection->pBindingInfo->Address[0].Address,
                     pPortMapping->pBinding,
                     &pPortMapping->ulPrivateAddress 
                     );
        }

        if (FAILED(hr))
        {
            NatFreePortMappingEntry(pPortMapping);
            break;
        }

        //
        // Create the ticket / UDP broadcast
        //

        if (NAT_PROTOCOL_UDP == pPortMapping->ucProtocol
            && 0xffffffff == pPortMapping->ulPrivateAddress)
        {
            DWORD dwAddress;
            DWORD dwMask;
            DWORD dwBroadcastAddress;

            if (NhQueryScopeInformation(&dwAddress, &dwMask))
            {
                dwBroadcastAddress = (dwAddress & dwMask) | ~dwMask;
                pPortMapping->fUdpBroadcastMapping = TRUE;

                hr = NhpUdpBroadcastMapper->CreateUdpBroadcastMapping(
                        pPortMapping->usPublicPort,
                        pConnection->AdapterIndex,
                        dwBroadcastAddress,
                        &pPortMapping->pvBroadcastCookie
                        );                        
            }
            else
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                InsertTailList(&pConnection->PortMappingList, &pPortMapping->Link);
                pConnection->UdpBroadcastPortMappingCount += 1;
            }
            else
            {
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }
        else
        {
            ulError =
                NatCreateTicket(
                    pConnection->AdapterIndex,
                    pPortMapping->ucProtocol,
                    pPortMapping->usPublicPort,
                    IP_NAT_ADDRESS_UNSPECIFIED,
                    pPortMapping->usPrivatePort,
                    pPortMapping->ulPrivateAddress
                    );

            if (NO_ERROR == ulError)
            {
                InsertTailList(&pConnection->PortMappingList, &pPortMapping->Link);
                pConnection->PortMappingCount += 1;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ulError);
                NhTrace(
                    TRACE_FLAG_NAT,
                    "ConnectionPortMappingModified: NatCreateTicket=%d",
                    ulError
                    );

                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }

        //
        // Store the old protocol / port information so that
        // we can notify H.323 (if necessary) and the ALG manager.
        //

        ucNewProtocol = pPortMapping->ucProtocol;
        usNewPort = pPortMapping->usPublicPort;  
    }
    while (FALSE);

    //
    // Determine if we need to notify the H.323 proxy or
    // the ALG manager. We must have found a bound connection
    // above to do this.
    //

    if (NULL != pConnection && NAT_INTERFACE_BOUND(&pConnection->Interface))
    {
        //
        // If this connection is bound to the H.323 proxy and either
        // the old or new protocol/port combination is applicable
        // remove and add this connection from the that proxy.
        //

        if (NAT_INTERFACE_ADDED_H323(&pConnection->Interface)
            && (IsH323Protocol(ucOldProtocol, usOldPort)
                || IsH323Protocol(ucNewProtocol, usNewPort)))
        {
            H323RmDeleteInterface(pConnection->Interface.Index);
            pConnection->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_H323;

            ulError =
                H323RmAddInterface(
                    NULL,
                    pConnection->Interface.Index,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );

            if (NO_ERROR == ulError)
            {
                pConnection->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_H323;

                ulError =
                    H323RmBindInterface(
                        pConnection->Interface.Index,
                        pConnection->pBindingInfo
                        );
            }

            if (NO_ERROR == ulError)
            {
                ulError = H323RmEnableInterface(pConnection->Interface.Index);
            }
        }

        //
        // Inform the ALG manager of the changes
        //

        if (0 != ucOldProtocol && 0 != usOldPort)
        {
            AlgRmPortMappingChanged(
                pConnection->Interface.Index,
                ucOldProtocol,
                usOldPort
                );
        }

        if (0 != ucNewProtocol && 0 != usNewPort
            && (ucOldProtocol != ucNewProtocol
                || usOldPort != usNewPort))
        {
            AlgRmPortMappingChanged(
                pConnection->Interface.Index,
                ucNewProtocol,
                usNewPort
                );

        }
        
    }
        
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // We may also need to rebuild the DHCP reservation list
    //
        
    if (fRebuildDhcpList)
    {
        EnterCriticalSection(&NhLock);
        
        NhFreeDhcpReservations();
        NhBuildDhcpReservations();

        LeaveCriticalSection(&NhLock);
    }

    return hr;
}

//
// Private methods
//

BOOLEAN
CSharedAccessUpdate::IsH323Protocol(
    UCHAR ucProtocol,
    USHORT usPort
    )
{
    return (NAT_PROTOCOL_TCP == ucProtocol
            && (H323_Q931_PORT == usPort
                || H323_LDAP_PORT == usPort
                || H323_LDAP_ALT_PORT == usPort));
}


STDMETHODIMP
CSharedAccessUpdate::PortMappingListChanged()
{
    HRESULT hr = S_OK;

    hr = FireNATEvent_PortMappingsChanged();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\csaupdate.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    csaupdate.h

Abstract:

    Declarations for CSharedAccessUpdate -- notification sink for
    configuration changes.

Author:

    Jonathan Burstein (jonburs)     20 April 2001

Revision History:

--*/

#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "saupdate.h"

class ATL_NO_VTABLE CSharedAccessUpdate :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CSharedAccessUpdate, &CLSID_SAUpdate>,
    public ISharedAccessUpdate
{
public:

    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CSharedAccessUpdate)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSharedAccessUpdate)
        COM_INTERFACE_ENTRY(ISharedAccessUpdate)
    END_COM_MAP()

    CSharedAccessUpdate()
    {
    };

    STDMETHODIMP
    ConnectionPortMappingChanged(
        GUID *pConnectionGuid,
        GUID *pPortMappingGuid,
        BOOLEAN fProtocolChanged
        );

    STDMETHODIMP
    PortMappingListChanged();


private:

    BOOLEAN
    IsH323Protocol(
        UCHAR ucProtocol,
        USHORT usPort
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\fwlogger.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    fwlogger.cpp

Abstract:

    Support for firewall logging to a text file.

Author:

    Jonathan Burstein (jonburs)     18 September 2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG

//
// Module state -- interlocked access only. This information
// is only used on debug builds.
//

typedef enum {
    FwUninitialized = 0,
    FwInitialized
} FW_MODULE_STATE;

FW_MODULE_STATE FwpModuleState = FwUninitialized;

#endif // DBG

//
// Globals. If both locks need to be held at the same time,
// g_FwFileLock must be acquired first.
//

CRITICAL_SECTION g_FwLock;
HNET_FW_LOGGING_SETTINGS *g_pSettings;
TRACEHANDLE g_hSession;
HANDLE g_hThread;
BOOLEAN g_fTracingActive;
ULONG g_ulKernelEventsLostAtShutdown;

CRITICAL_SECTION g_FwFileLock;
HANDLE g_hFile;
DWORD g_dwFileOffset;
PFW_LOG_BUFFER g_pCurrentBuffer;
PFW_LOG_BUFFER g_pReserveBuffer;
BOOLEAN g_fIOPending;
HANDLE g_hIOEvent;
ULONG g_ulDroppedEventCount;
ULONG g_ulKernelEventsLost;
HANDLE g_hDroppedEventTimer;

//
// Constants
//

GUID c_ConnectionCreationEventGuid = MSIPNAT_ConnectionCreationEventGuid;
GUID c_ConnectionDeletionEventGuid = MSIPNAT_ConnectionDeletionEventGuid;
GUID c_PacketDroppedEventGuid = MSIPNAT_PacketDroppedEventGuid;

WCHAR c_wszLogSessionName[] = L"FirewallLogSession";
WCHAR c_wszBackupFileExtension[] = L".old";

CHAR c_szConnectionFormat[] = "%04d-%02d-%02d %02d:%02d:%02d %s %s %s %s %u %u - - - - - - - -\r\n";
CHAR c_szTcpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP TCP %s %s %u %u %u %s %u %u %u - - -\r\n";
CHAR c_szUdpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP UDP %s %s %u %u %u - - - - - - -\r\n";
CHAR c_szIcmpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP ICMP %s %s - - %u - - - - %u %u -\r\n";
CHAR c_szDroppedPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP %u %s %s - - %u - - - - - - -\r\n";
CHAR c_szEventsLostFormat[] = "%04d-%02d-%02d %02d:%02d:%02d INFO-EVENTS-LOST - - - - - - - - - - - - %u\r\n";

CHAR c_szAcceptInbound[] = "OPEN-INBOUND";
CHAR c_szAcceptOutbound[] = "OPEN";
CHAR c_szTcp[] = "TCP";
CHAR c_szUdp[] = "UDP";
CHAR c_szLogFileHeader[]
    = "#Verson: 1.0\r\n#Software: Microsoft Internet Connection Firewall\r\n#Time Format: Local\r\n#Fields: date time action protocol src-ip dst-ip src-port dst-port size tcpflags tcpsyn tcpack tcpwin icmptype icmpcode info\r\n\r\n";

//
// Function Prototypes
//

DWORD
FwpAllocateBuffer(
    PFW_LOG_BUFFER *ppBuffer
    );

PEVENT_TRACE_PROPERTIES
FwpAllocateTraceProperties(
    VOID
    );

DWORD
FwpBackupFile(
    LPWSTR pszwPath
    );

VOID
FwpCleanupTraceThreadResources(
    VOID
    );

VOID
CALLBACK
FwpCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED pOverlapped
    );

VOID
WINAPI
FwpConnectionCreationCallback(
    PEVENT_TRACE pEvent
    );

VOID
WINAPI
FwpConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    );

VOID
FwpConvertUtcFiletimeToLocalSystemtime(
    FILETIME *pFiletime,
    SYSTEMTIME *pSystemtime
    );

VOID
CALLBACK
FwpDroppedEventTimerRoutine(
    PVOID pvParameter,
    BOOLEAN fWaitTimeout
    );

DWORD
FwpFlushCurrentBuffer(
    VOID
    );

DWORD
FwpOpenLogFile(
    HANDLE *phFile,
    BOOLEAN *pfNewFile
    );

VOID
WINAPI
FwpPacketDroppedCallback(
    PEVENT_TRACE pEvent
    );

DWORD
FwpLaunchTraceSession(
    HNET_FW_LOGGING_SETTINGS *pSettings,
    TRACEHANDLE *phSession
    );
    

HRESULT
FwpLoadSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    );

DWORD
WINAPI
FwpTraceProcessingThreadRoutine(
    LPVOID pvParam
    );

DWORD
FwpWriteLogHeaderToBuffer(
    PFW_LOG_BUFFER pBuffer
    );


VOID
FwCleanupLogger(
    VOID
    )

/*++

Routine Description:

    This routine is called to cleanup the logging subsystem. All
    resources in use will be freed. After this call, the only valid
    routine in this module is FwInitializeLogger.

Arguments:

    none.
    
Return Value:

    none.

Environment:

    Caller must not be holding g_FwFileLock or g_FwLock

--*/

{
    PROFILE("FwCleanupLogger");

    //
    // Make sure the logging is stopped
    //

    FwStopLogging();
    
    ASSERT(FwInitialized ==
            (FW_MODULE_STATE) InterlockedExchange(
                                    (LPLONG) &FwpModuleState,
                                    (LONG) FwUninitialized
                                    ));

    EnterCriticalSection(&g_FwLock);
    
    ASSERT(NULL == g_hSession);
    ASSERT(NULL == g_hThread);
    ASSERT(INVALID_HANDLE_VALUE == g_hFile);
    
    if (g_pSettings) HNetFreeFirewallLoggingSettings(g_pSettings);

    LeaveCriticalSection(&g_FwLock);
    DeleteCriticalSection(&g_FwLock);
    DeleteCriticalSection(&g_FwFileLock);
    
} // FwCleanupLogger


DWORD
FwInitializeLogger(
    VOID
    )

/*++

Routine Description:

    This routine is called to control to initialize the logging subsystem.
    It must be called before any of the other routines in this module, and
    may not be called again until after a call to FwCleanupLogger.
    
Arguments:

    none.

Return Value:

    DWORD -- Win32 error code

--*/

{
    DWORD dwError = NO_ERROR;
    BOOLEAN fFirstLockInitialized = FALSE;

    PROFILE("FwInitializeLogger");

    ASSERT(FwUninitialized ==
            (FW_MODULE_STATE) InterlockedExchange(
                                    (LPLONG) &FwpModuleState,
                                    (LONG) FwInitialized
                                    ));

    __try
    {
        InitializeCriticalSection(&g_FwLock);
        fFirstLockInitialized = TRUE;
        InitializeCriticalSection(&g_FwFileLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwInitializeLogger: exception %d creating lock",
            dwError = GetExceptionCode()
            );

        if (fFirstLockInitialized)
        {
            DeleteCriticalSection(&g_FwLock);
        }

#if DBG
        InterlockedExchange(
            (LPLONG) &FwpModuleState,
            (LONG) FwUninitialized
            );
#endif
    }

    g_pSettings = NULL;
    g_hSession = NULL;
    g_hThread = NULL;
    g_fTracingActive = FALSE;
    g_ulKernelEventsLostAtShutdown = 0;

    g_hFile = INVALID_HANDLE_VALUE;
    g_dwFileOffset = 0;
    g_pCurrentBuffer = NULL;
    g_pReserveBuffer = NULL;
    g_fIOPending = FALSE;
    g_hIOEvent = NULL;
    g_ulDroppedEventCount = 0;
    g_ulKernelEventsLost = 0;
    g_hDroppedEventTimer = NULL;
                                    
    return dwError;
} // FwInitializeLogger


DWORD
FwpAllocateBuffer(
    PFW_LOG_BUFFER *ppBuffer
    )

/*++

Routine Description:

    Allocates an initializes an FW_LOG_BUFFER structure

Arguments:

    ppBuffer - receives a pointer to the newly-allocated structure

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    PROFILE("FwpAllocateBuffer");
    ASSERT(NULL != ppBuffer);

    *ppBuffer =
        reinterpret_cast<PFW_LOG_BUFFER>(
            NH_ALLOCATE(sizeof(**ppBuffer))
            );

    if (NULL != *ppBuffer)
    {
        ZeroMemory(&(*ppBuffer)->Overlapped, sizeof(OVERLAPPED));
        (*ppBuffer)->pChar = (*ppBuffer)->Buffer;
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;        
    }

    return dwError;
} // FwpAllocateBuffer


PEVENT_TRACE_PROPERTIES
FwpAllocateTraceProperties(
    VOID
    )

/*++

Routine Description:

    Allocates and partially initializes an EVENT_TRACE_PROPERTIES structure.

Arguments:

    none.

Return Value:

    PEVENT_TRACE_PROPERTIES - pointer to the allocated structure. The caller
        must call HeapFree(GetProcessHeap(),...) on this pointer.

--*/

{
    PEVENT_TRACE_PROPERTIES pProperties = NULL;
    ULONG ulSize;

    ulSize = sizeof(*pProperties)
            + ((wcslen(c_wszLogSessionName) + 1) * sizeof(WCHAR));

    pProperties = (PEVENT_TRACE_PROPERTIES) HeapAlloc(
                                                GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                ulSize
                                                );

    if (NULL == pProperties)
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpAllocateTraceProperties: Unable to allocate %d bytes",
            ulSize
            );

        return NULL;
    }

    pProperties->Wnode.BufferSize = ulSize;
    pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pProperties->Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    pProperties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE; 
    pProperties->LoggerNameOffset = sizeof(*pProperties);
    
    return pProperties;
} // FwpAllocateTraceProperties


DWORD
FwpBackupFile(
    LPWSTR pszwPath
    )

/*++

Routine Description:

    Backs-up a file to filename.xxx.old

Arguments:

    pszwPath - path to the file to backup

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fResult;
    LPWSTR wszBuffer;

    ASSERT(NULL != pszwPath);

    //
    // Allocate buffer to hold new filename
    //

    wszBuffer =
        new WCHAR[wcslen(pszwPath) + wcslen(c_wszBackupFileExtension) + 1];

    if (NULL != wszBuffer)
    {
        lstrcpyW(wszBuffer, pszwPath);
        lstrcatW(wszBuffer, c_wszBackupFileExtension);

        fResult = MoveFileEx(pszwPath, wszBuffer, MOVEFILE_REPLACE_EXISTING);

        if (FALSE == fResult)
        {
            dwError = GetLastError();

            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpBackupFile: MoveFileEx = %d",
                dwError
                );
        }
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpBackupFile: Unable to allolcate buffer"
            );
    }
    
    return dwError;
} // FwpBackupFile


VOID
FwpCleanupTraceThreadResources(
    VOID
    )

/*++

Routine Description:

    Cleans up resources used by the trace processing thread:
    * revokes event callbacks
    * waits for IO to complete, if pending
    * closes the log file
    * frees buffers

Arguments:

    none.
    
Return Value:

    none.

Environment:

    The caller must not hold g_FwFileLock or g_FwLock.

--*/

{
    DWORD dwError;
    HANDLE hDroppedEventTimer;
    
    PROFILE("FwpCleanupTraceThreadResources");

    //
    // Unregister the trace callbacks. It is safe to call these even
    // if the callbacks weren't registered to begin with.
    //

    RemoveTraceCallback(&c_PacketDroppedEventGuid);
    RemoveTraceCallback(&c_ConnectionCreationEventGuid);
    RemoveTraceCallback(&c_ConnectionDeletionEventGuid);

    EnterCriticalSection(&g_FwFileLock);

    //
    // Cancel the dropped packet timer
    //

    hDroppedEventTimer = g_hDroppedEventTimer;
    g_hDroppedEventTimer = NULL;

    //
    // Since we're doing a blocking delete of the timer we can't
    // hold the lock when for the call to DeleteTimerQueueTimer --
    // a deadlock could result if the timer routine has been queued but
    // not yet executed when we make the call.
    //

    LeaveCriticalSection(&g_FwFileLock);

    if (NULL != hDroppedEventTimer)
    {
        DeleteTimerQueueTimer(
            NULL,
            hDroppedEventTimer,
            INVALID_HANDLE_VALUE
            );            
    }

    EnterCriticalSection(&g_FwFileLock);

    //
    // If necessary, wait for any pending IO operations to complete
    //

    if (g_fIOPending)
    {   
        g_hIOEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (NULL != g_hIOEvent)
        {
            HANDLE hEvent = g_hIOEvent;
            
            LeaveCriticalSection(&g_FwFileLock);

            dwError = WaitForSingleObject(hEvent, 20 * 1000);

            if (WAIT_OBJECT_0 != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessingRoutine: Wait(g_hIOEvent) = %d/%d",
                    dwError,
                    GetLastError()
                    );

                //
                // It should never take 20 seconds for an IO to complete,
                // so let's get immediate notification of this on debug
                // builds.
                //
                
                ASSERT(WAIT_OBJECT_0 == dwError);
            }

            EnterCriticalSection(&g_FwFileLock);
            CloseHandle(g_hIOEvent);
            g_hIOEvent = NULL;
        }
    }

    g_fIOPending = FALSE;

    //
    // Close the log file
    //

    if (INVALID_HANDLE_VALUE != g_hFile)
    {
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
    }

    g_dwFileOffset = 0;

    //
    // Clean up our buffers
    //

    if (NULL != g_pCurrentBuffer)
    {
        NH_FREE(g_pCurrentBuffer);
        g_pCurrentBuffer = NULL;
    }

    if (NULL != g_pReserveBuffer)
    {
        NH_FREE(g_pReserveBuffer);
        g_pReserveBuffer = NULL;
    }

    //
    // Reset dropped event counts
    //

    g_ulDroppedEventCount = 0;
    g_ulKernelEventsLost = 0;

    LeaveCriticalSection(&g_FwFileLock);
    

} // FwpCleanupTraceThreadResources


VOID
CALLBACK
FwpCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED pOverlapped
    )

/*++

Routine Description:

    Completion routine called by the system thread pool when our
    IO operation is finished. Responsible for updating the file
    position and starting a new IO operation if necessary.

Arguments:

    dwErrorCode - result of the IO operation

    dwBytesTransferred - number of bytes transferred during the operation

    pOverlapped - pointer to the overlapped structure for the operation. We
                  can recover the FW_LOG_BUFFER structure from this pointer.
                  
Return Value:

    none.

--*/

{
    PFW_LOG_BUFFER pBuffer;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Adjust our file offset
    //

    if (ERROR_SUCCESS == dwErrorCode)
    {
        g_dwFileOffset += dwBytesTransferred;
    }
    else
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpCompletionRoutine: dwErrorCode = %d",
            dwErrorCode
            );
    }

    g_fIOPending = FALSE;

    //
    // Reset the buffer that was passed in 
    //

    ASSERT(NULL != pOverlapped);
    
    pBuffer = CONTAINING_RECORD(pOverlapped, FW_LOG_BUFFER, Overlapped);
    ZeroMemory(&pBuffer->Overlapped, sizeof(OVERLAPPED));
    pBuffer->pChar = pBuffer->Buffer;

    //
    // Check if the file is at the size limit
    //

    EnterCriticalSection(&g_FwLock);

    ASSERT(NULL != g_pSettings);

    if (g_dwFileOffset >= g_pSettings->ulMaxFileSize)
    {
        DWORD dwError;
        BOOLEAN fNewFile;
        
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
        
        //
        // If FwpBackupFile fails, FwpOpenFile will still do
        // the right thing.
        //

        FwpBackupFile(g_pSettings->pszwPath);

        g_dwFileOffset = 0;
        dwError = FwpOpenLogFile(&g_hFile, &fNewFile);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpCompletionRoutine: FwpOpenLogFile = %d",
                dwError
                );

            NH_FREE(pBuffer);

            LeaveCriticalSection(&g_FwLock);
            LeaveCriticalSection(&g_FwFileLock);
            
            FwStopLogging();

            return;
        }
        else if (TRUE == fNewFile)
        {
            //
            // Need to write header.
            //

            if (ERROR_SUCCESS == FwpWriteLogHeaderToBuffer(pBuffer))
            {
                PFW_LOG_BUFFER pTempBuffer = g_pCurrentBuffer;
                g_pCurrentBuffer = pBuffer;

                FwpFlushCurrentBuffer();

                g_pCurrentBuffer = pTempBuffer;
                pBuffer = NULL;
            }
            
        }
        else
        {
            g_dwFileOffset = GetFileSize(g_hFile, NULL);

            if ((DWORD)-1 == g_dwFileOffset)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpCompletionRoutine: GetFileSize = %d",
                    GetLastError()
                    );
                    
                NH_FREE(pBuffer);

                LeaveCriticalSection(&g_FwLock);
                LeaveCriticalSection(&g_FwFileLock);

                FwStopLogging();

                return;
            }
        }
    }

    LeaveCriticalSection(&g_FwLock);

    //
    // See if we need to start a new operation.
    //

    if (FALSE == g_fIOPending && NULL != g_pCurrentBuffer)
    {
        if (g_pCurrentBuffer->pChar != g_pCurrentBuffer->Buffer)
        {
            //
            // Current buffer needs to be flushed
            //

            FwpFlushCurrentBuffer();
        }
    }

    //
    // Place buffer into storage. If we're using the buffer
    // to write the log header, it will be NULL at this point
    //

    if (NULL != pBuffer)
    {
        if (NULL == g_pCurrentBuffer)
        {
            g_pCurrentBuffer = pBuffer;
        }
        else if (NULL == g_pReserveBuffer)
        {
            g_pReserveBuffer = pBuffer;
        }
        else
        {
            //
            // Both buffer slots are already in use -- unexpected.
            // Assert and free the extra buffer
            //

            ASSERT(NULL == g_pCurrentBuffer || NULL == g_pReserveBuffer);
            NH_FREE(pBuffer);
        }
    }

    //
    // Check to see if we need to signal the IO finished event
    //

    if (!g_fIOPending && NULL != g_hIOEvent)
    {
        if (!SetEvent(g_hIOEvent))
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpCompletionRoutine: SetEvent = %d",
                GetLastError()
                );
        }
    }

    LeaveCriticalSection(&g_FwFileLock);
    
} // FwpCompletionRoutine


VOID
WINAPI
FwpConnectionCreationCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a connection creation event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_ConnectionCreationEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    PCHAR pszAction;
    PCHAR pszProtocol;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    USHORT usSrcPort;
    USHORT usDstPort;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpConnectionCreationCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_ConnectionCreationEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    if (pEventData->InboundConnection)
    {
        pszAction = c_szAcceptInbound;
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->RemoteAddress));
        usSrcPort = ntohs(pEventData->RemotePort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->LocalAddress));
        usDstPort = ntohs(pEventData->LocalPort);
    }
    else
    {
        pszAction = c_szAcceptOutbound;
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->LocalAddress));
        usSrcPort = ntohs(pEventData->LocalPort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->RemoteAddress));
        usDstPort = ntohs(pEventData->RemotePort);
    }

    pszProtocol =
        NAT_PROTOCOL_TCP == pEventData->Protocol ?
            c_szTcp :
            c_szUdp;           
                    
    
    //
    // Write the event data to the buffer
    //

    cch =
        _snprintf(
            g_pCurrentBuffer->pChar,
            FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
            c_szConnectionFormat,
            stLocalTime.wYear,
            stLocalTime.wMonth,
            stLocalTime.wDay,
            stLocalTime.wHour,
            stLocalTime.wMinute,
            stLocalTime.wSecond,
            pszAction,
            pszProtocol,
            szSrcAddress,
            szDstAddress,
            usSrcPort,
            usDstPort
            );

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);

} // FwpConnectionCreationCallback


VOID
WINAPI
FwpConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a connection deletion event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_ConnectionDeletionEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    PCHAR pszProtocol;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    USHORT usSrcPort;
    USHORT usDstPort;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpConnectionDeletionCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_ConnectionDeletionEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    if (pEventData->InboundConnection)
    {
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->RemoteAddress));
        usSrcPort = ntohs(pEventData->RemotePort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->LocalAddress));
        usDstPort = ntohs(pEventData->LocalPort);
    }
    else
    {
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->LocalAddress));
        usSrcPort = ntohs(pEventData->LocalPort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->RemoteAddress));
        usDstPort = ntohs(pEventData->RemotePort);
    }

    pszProtocol =
        NAT_PROTOCOL_TCP == pEventData->Protocol ?
            c_szTcp :
            c_szUdp;           
                    
    
    //
    // Write the event data to the buffer
    //

    cch =
        _snprintf(
            g_pCurrentBuffer->pChar,
            FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
            c_szConnectionFormat,
            stLocalTime.wYear,
            stLocalTime.wMonth,
            stLocalTime.wDay,
            stLocalTime.wHour,
            stLocalTime.wMinute,
            stLocalTime.wSecond,
            "CLOSE",
            pszProtocol,
            szSrcAddress,
            szDstAddress,
            usSrcPort,
            usDstPort
            );

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);

} // FwpConnectionDeletionCallback


VOID
FwpConvertUtcFiletimeToLocalSystemtime(
    FILETIME *pFiletime,
    SYSTEMTIME *pSystemtime
    )

/*++

Routine Description:

    Converts UTC time in a FILETIME struct to local time in
    a SYSTEMTIME struct
    
Arguments:

    pFiletime - pointer to UTC filetime structure

    pSystemtime - pointer to systemtime structure that is to receive
                  the local time

Return Value:

    none.

--*/

{
    FILETIME ftLocalTime;
    
    ASSERT(NULL != pFiletime);
    ASSERT(NULL != pSystemtime);

    if (!FileTimeToLocalFileTime(pFiletime, &ftLocalTime)
        || !FileTimeToSystemTime(&ftLocalTime, pSystemtime))
    {
        //
        // Conversion failed -- use zero time
        //
        
        ZeroMemory( pSystemtime, sizeof(*pSystemtime));
    }
    
} // FwpConvertUtcFiletimeToLocalSystemtime


VOID
CALLBACK
FwpDroppedEventTimerRoutine(
    PVOID pvParameter,
    BOOLEAN fWaitTimeout
    )

/*++

Routine Description:

    Checks if there are any dropped events, and, if so, writes
    an event to the log.
    
Arguments:

    pvParameter -- NULL if called by the timer. If called directly, a PULONG
        to the number of events dropped by WMI. In the later situation, this
        routine will not query the trace session for the number of dropped
        events.

    fWaitTimeout -- unused

Return Value:

    none.

--*/

{
    ULONG ulKernelEvents = 0;
    PEVENT_TRACE_PROPERTIES pProperties;
    SYSTEMTIME stLocalTime;
    DWORD dwError;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Check to see if we we're given the kernel mode drop count, as
    // would happen during shutdown
    //

    if (NULL != pvParameter)
    {
        ulKernelEvents = *((PULONG)pvParameter);
    }
    else
    {
        //
        // Query the trace session for number of events dropped
        // in kernel mode. If g_hSession is NULL, then we are shutting
        // down and should exit w/o logging -- this call is the result
        // of the timer firing after FwStopLogging has stopped the
        // trace session.
        //

        EnterCriticalSection(&g_FwLock);

        if (NULL != g_hSession)
        {
            pProperties = FwpAllocateTraceProperties();

            if (NULL != pProperties)
            {
                dwError =
                    ControlTrace(
                        g_hSession,
                        NULL,
                        pProperties,
                        EVENT_TRACE_CONTROL_QUERY
                        );

                if (ERROR_SUCCESS == dwError)
                {
                    ulKernelEvents = pProperties->EventsLost;
                }
                else
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpDroppedEventTimerRoutine: ControlTrace = %d",
                        dwError
                        );
                }

                HeapFree(GetProcessHeap(), 0, pProperties);
            }
        }
        else
        {
            //
            // Timer callback after trace session stopped - exit
            //

            LeaveCriticalSection(&g_FwLock);
            LeaveCriticalSection(&g_FwFileLock);
            return;
        }

        LeaveCriticalSection(&g_FwLock);
    }

    //
    // Record the dropped events, if there are any
    //

    if (ulKernelEvents > g_ulKernelEventsLost
        || g_ulDroppedEventCount > 0)
    {

        //
        // Get a buffer to write to.
        //

        if (NULL == g_pCurrentBuffer)
        {
            if (NULL == g_pReserveBuffer)
            {
                if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpDroppedEventTimerRoutine: Unable to allocate buffer"
                        );

                    LeaveCriticalSection(&g_FwFileLock);
                    return;
                }
            }
            else
            {
                g_pCurrentBuffer = g_pReserveBuffer;
                g_pReserveBuffer = NULL;
            }
        }

        ASSERT(NULL != g_pCurrentBuffer);

        //
        // Get the current time
        //

        GetLocalTime(&stLocalTime);

        //
        // Write the dropped packet event to the buffer. The actual number of
        // dropped events that we're logging is:
        //
        // ulKernelEvents - g_ulKernelEventsLost + g_ulDroppedEventCount
        //

        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szEventsLostFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                ulKernelEvents - g_ulKernelEventsLost + g_ulDroppedEventCount
                );

        if (cch > 0)
        {
            //
            // Move the buffer pointer to the end of the data we just wrote.
            // If cch were negative, then there wasn't enough room to write
            // then entire entry; by not adjusting the pointer, we essentially
            // drop this event.
            //

            g_pCurrentBuffer->pChar += cch;

            //
            // Adjust the dropped event counter
            //

            g_ulKernelEventsLost = ulKernelEvents;
            g_ulDroppedEventCount = 0;
        }
        else
        {
            //
            // This doesn't count as a dropped event.
            //
        }

        //
        // If there is no current IO, flush the buffer
        //

        if (FALSE == g_fIOPending)
        {
            FwpFlushCurrentBuffer();
        }
    }

    LeaveCriticalSection(&g_FwFileLock);
    
} // FwpDroppedEventTimerRoutine


DWORD
FwpFlushCurrentBuffer(
    VOID
    )

/*++

Routine Description:

    Writes the current buffer to disk.
    
Arguments:

    none.

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError;
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;
    BOOL fResult;

    EnterCriticalSection(&g_FwFileLock);

    ASSERT(FALSE == g_fIOPending);
    ASSERT(NULL != g_pCurrentBuffer);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.Internal);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.InternalHigh);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.Offset);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.OffsetHigh);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.hEvent);
    
    g_pCurrentBuffer->Overlapped.Offset = g_dwFileOffset;
    dwBytesToWrite = (DWORD)(g_pCurrentBuffer->pChar - g_pCurrentBuffer->Buffer);

    fResult =
        WriteFile(
            g_hFile,
            g_pCurrentBuffer->Buffer,
            dwBytesToWrite,
            &dwBytesWritten,
            &g_pCurrentBuffer->Overlapped
            );

    dwError = GetLastError();

    if (FALSE != fResult || ERROR_IO_PENDING == dwError)
    {
        //
        // The write succeeded or is pending; our completion routine
        // is therefore guaranteed to be called.
        //
        
        g_fIOPending = TRUE;
        g_pCurrentBuffer = g_pReserveBuffer;
        g_pReserveBuffer = NULL;
    }
    else
    {
        //
        // Unexpected error. Reset the buffer for future use.
        //

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpFlushCurrentBuffer: WriteFile = %d",
            dwError
            );

        ZeroMemory(&g_pCurrentBuffer->Overlapped, sizeof(OVERLAPPED));
        g_pCurrentBuffer->pChar = g_pCurrentBuffer->Buffer;
    }
                

    LeaveCriticalSection(&g_FwFileLock);

    return dwError;
} // FwpFlushCurrentBuffer


DWORD
FwpOpenLogFile(
    HANDLE *phFile,
    BOOLEAN *pfNewFile
    )

/*++

Routine Description:

    Opens the file used for logging and associates it with the thread pool's
    IO completion port.

Arguments:

    phFile - receives the file handle for the opened log file.

    pfNewFile - receives TRUE if a new file was created; false otherwise

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError;
    DWORD dwFileSize;

    ASSERT(NULL != phFile);
    ASSERT(NULL != pfNewFile);

    EnterCriticalSection(&g_FwLock);

    ASSERT(NULL != g_pSettings);
    ASSERT(NULL != g_pSettings->pszwPath);

    *pfNewFile = FALSE;
    dwError = ERROR_SUCCESS;

    *phFile =
        CreateFile(
            g_pSettings->pszwPath,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
            );

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        //
        // Check if this is a new or existing file
        //

        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            //
            // Check to see if existing file size is > 95% of
            // our max; if so, backup now and create new file
            //

            dwFileSize = GetFileSize(*phFile, NULL);

            if ((DWORD)-1 == dwFileSize)
            {
                //
                // Unable to get file size. This is quite unexpected...
                //

                dwError = GetLastError();
                CloseHandle(*phFile);
                *phFile = INVALID_HANDLE_VALUE;

                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpOpenLogFile: GetFileSize = %d",
                    dwError
                    );
            }
            else if (dwFileSize > 0.95 * g_pSettings->ulMaxFileSize)
            {
                //
                // Close the current file handle
                //

                CloseHandle(*phFile);

                //
                // Rename the current log file. This call will delete any
                // previous backups. If this fails, we'll just overwrite
                // the current log file.
                //

                FwpBackupFile(g_pSettings->pszwPath);

                //
                // Open again
                //

                *pfNewFile = TRUE;
                *phFile =
                    CreateFile(
                        g_pSettings->pszwPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );

                if (INVALID_HANDLE_VALUE == *phFile)
                {
                    dwError = GetLastError();

                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpOpenLogFile: Error %d creating %S after backup",
                        dwError,
                        g_pSettings->pszwPath
                        );
                }
            }
        }
        else
        {
            *pfNewFile = TRUE;
        }
    }
    else
    {
        dwError = GetLastError();

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpOpenLogFile: Error %d opening %S",
            dwError,
            g_pSettings->pszwPath
            );
    }

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        //
        // Associate the file handle w/ the thread pool completion port
        //

        if (!BindIoCompletionCallback(*phFile, FwpCompletionRoutine, 0))
        {
            dwError = GetLastError();
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
        }
    }
            
    LeaveCriticalSection(&g_FwLock);

    return dwError;
} // FwpOpenLogFile


VOID
WINAPI
FwpPacketDroppedCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a dropped packet event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_PacketDroppedEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpPacketDroppedCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_PacketDroppedEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    lstrcpyA(szSrcAddress, INET_NTOA(pEventData->SourceAddress)); 
    lstrcpyA(szDstAddress, INET_NTOA(pEventData->DestinationAddress));

    //
    // Write the event data to the buffer
    //

    if (NAT_PROTOCOL_TCP == pEventData->Protocol)
    {
        CHAR szBuffer[10];
        UINT i = 0;

        if (pEventData->ProtocolData4 & TCP_FLAG_SYN)
        {
            szBuffer[i++] = 'S';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_FIN)
        {
            szBuffer[i++] = 'F';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_ACK)
        {
            szBuffer[i++] = 'A';
        }
        
        if (pEventData->ProtocolData4 & TCP_FLAG_RST)
        {
            szBuffer[i++] = 'R';
        }
        
        if (pEventData->ProtocolData4 & TCP_FLAG_URG)
        {
            szBuffer[i++] = 'U';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_PSH)
        {
            szBuffer[i++] = 'P';
        }

        if (0 == i)
        {
            //
            // No flags on this packet
            //
            
            szBuffer[i++] = '-';
        }

        szBuffer[i] = NULL;
            
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szTcpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                ntohs(pEventData->SourceIdentifier),
                ntohs(pEventData->DestinationIdentifier),
                pEventData->PacketSize,
                szBuffer,
                ntohl(pEventData->ProtocolData1),
                ntohl(pEventData->ProtocolData2),
                ntohs((USHORT)pEventData->ProtocolData3)
                );
                
    }
    else if (NAT_PROTOCOL_UDP == pEventData->Protocol)
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szUdpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                ntohs(pEventData->SourceIdentifier),
                ntohs(pEventData->DestinationIdentifier),
                pEventData->PacketSize
                );
    }
    else if (NAT_PROTOCOL_ICMP == pEventData->Protocol)
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szIcmpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                pEventData->PacketSize,
                pEventData->ProtocolData1,
                pEventData->ProtocolData2
                );
    }
    else
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szDroppedPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                pEventData->Protocol,
                szSrcAddress,
                szDstAddress,
                pEventData->PacketSize
                );
    }

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);
        
} // FwpPacketDroppedCallback


DWORD
FwpLaunchTraceSession(
    HNET_FW_LOGGING_SETTINGS *pSettings,
    TRACEHANDLE *phSession
    )

/*++

Routine Description:

    This routine is called to start a trace session.

Arguments:

    pSettings - pointer to an fw logging settings structure. Only
                fLogDroppedPackets and fLogConnections are examined,
                and at least one of the two must be true.

    phSession - on success, receives the trace handle for the session

Return Value:

    DWORD -- win32 error code

--*/

{
    DWORD dwError;
    PEVENT_TRACE_PROPERTIES pProperties = NULL;

    PROFILE("FwpLaunchTraceSession");
    ASSERT(NULL != pSettings);
    ASSERT(pSettings->fLogDroppedPackets || pSettings->fLogConnections);
    ASSERT(NULL != phSession);

    do
    {

        //
        // Allocate the tracing properties. We need to include space for
        // the name of the logging session, even though we don't have
        // to copy the string into the properties ourselves
        //

        pProperties = FwpAllocateTraceProperties();

        if (NULL == pProperties)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize the trace properties. When events are coming at a
        // low rate (which is expected), there will be at most a 13 second
        // latency for event delivery. During high event rate periods, our
        // memory usage for trace buffering is capped at 60k.
        //

        pProperties->FlushTimer = 13;
        pProperties->BufferSize = 4;
        pProperties->MaximumBuffers = 15;

        //
        // Start the trace
        //
        
        dwError = StartTrace(phSession, c_wszLogSessionName, pProperties);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpLaunchTraceSession: StartTrace = %d",
                dwError
                );
            *phSession = NULL;
            break;
        }

        //
        // Enable the appropriate events
        //

        if (pSettings->fLogDroppedPackets)
        {
            dwError = EnableTrace(
                        TRUE,
                        0,
                        0,
                        &c_PacketDroppedEventGuid,
                        *phSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLaunchTraceSession: EnableTrace (packets) = %d",
                    dwError
                    );

                //
                // Stop the trace
                //

                ControlTrace(
                    *phSession,
                    NULL,
                    pProperties,
                    EVENT_TRACE_CONTROL_STOP
                    );
                *phSession = NULL;
                break;
            }
        }

        if (pSettings->fLogConnections)
        {
            dwError = EnableTrace(
                        TRUE,
                        0,
                        0,
                        &c_ConnectionCreationEventGuid,
                        *phSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLaunchTraceSession: EnableTrace (connections) = %d",
                    dwError
                    );

                //
                // Stop the trace
                //

                ControlTrace(
                    *phSession,
                    NULL,
                    pProperties,
                    EVENT_TRACE_CONTROL_STOP
                    );
                *phSession = NULL;
                break;
            }
        }
    } while (FALSE);

    if (NULL != pProperties)
    {
        HeapFree(GetProcessHeap(), 0, pProperties);
    }
    
    return dwError;
} // FwpLaunchTraceSession


HRESULT
FwpLoadSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    )

/*++

Routine Description:

    This routine is called to retrieve the firewall logging settings.

Arguments:

    ppSettings - receives a pointer to the settings structure on success.
                 The caller is responsible for calling
                 HNetFreeFirewallLoggingSettings on this pointer.

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IHNetCfgMgr *pCfgMgr;
    IHNetFirewallSettings *pFwSettings;

    PROFILE("FwpLoadSettings");
    ASSERT(NULL != ppSettings);

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (SUCCEEDED(hr))
    {
        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetFirewallSettings, &pFwSettings)
                );

        pCfgMgr->Release();

        if (SUCCEEDED(hr))
        {
            hr = pFwSettings->GetFirewallLoggingSettings(ppSettings);

            pFwSettings->Release();

            if (SUCCEEDED(hr))
            {
                //
                // Make sure that the minimum file size is at least 1024 bytes.
                //

                if ((*ppSettings)->ulMaxFileSize < 1024)
                {
                    (*ppSettings)->ulMaxFileSize = 1024;
                }
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLoadSettings: GetFirewallLoggingSettings = 0x%08x",
                    hr
                    );
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpLoadSettings: QueryInterface = 0x%08x",
                hr
                );
        }
    }
    else
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpLoadSettings: NhGetHNetCfgMgr = 0x%08x",
            hr
            );
    }
    
    return hr;
} // FwpLoadSettings


DWORD
WINAPI
FwpTraceProcessingThreadRoutine(
    LPVOID pvParam
    )

/*++

Routine Description:

    This routine is the entrypoint for our trace processing thread. It
    does the following:
    1) Creates the file that we are logging to
    2) Sets up the trace callback routines
    3) Calls ProcessTrace. This call blocks until the trace session is
       finished (i.e,, FwStopLogging is called)

Arguments:

    pvParam - unused

Return Value:

    DWORD - Win32 error code

--*/

{
    TRACEHANDLE hTraceSession;
    EVENT_TRACE_LOGFILE LogFile;
    BOOLEAN fNewFile;
    DWORD dwError;
    BOOL fSucceeded;
    ULONG ulKernelEventsLostAtShutdown;

    PROFILE("FwpTraceProcessingThreadRoutine");

    EnterCriticalSection(&g_FwFileLock);

    ASSERT(INVALID_HANDLE_VALUE == g_hFile);
    ASSERT(0 == g_dwFileOffset);
    ASSERT(NULL == g_pCurrentBuffer);
    ASSERT(NULL == g_pReserveBuffer);
    ASSERT(FALSE == g_fIOPending);
    ASSERT(NULL == g_hIOEvent);
    ASSERT(0 == g_ulDroppedEventCount);
    ASSERT(NULL == g_hDroppedEventTimer);
    ASSERT(0 == g_ulKernelEventsLost);

    do
    {
        //
        // Create/Open the logfile.
        //

        dwError = FwpOpenLogFile(&g_hFile, &fNewFile);

        if (ERROR_SUCCESS != dwError)
        {
            LeaveCriticalSection(&g_FwFileLock);
            break;
        }

        //
        // Allocate the initial working buffer
        //

        dwError = FwpAllocateBuffer(&g_pCurrentBuffer);
        if (ERROR_SUCCESS != dwError)
        {
            LeaveCriticalSection(&g_FwFileLock);

            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingRoutine: Unable to allocate buffer"
                );
                
            break;
        }

        if (fNewFile)
        {
            //
            // Write the log header
            //

            g_dwFileOffset = 0;
            dwError = FwpWriteLogHeaderToBuffer(g_pCurrentBuffer);

            if (ERROR_SUCCESS == dwError)
            {
                FwpFlushCurrentBuffer();
            }
            else
            {
                //
                // Even though we failed in writing the header, we'll still
                // try to log as much as possible
                //
                
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessinRoutine: FwpWriteLogHeaderToBuffer = %d",
                    dwError
                    );
            }
        }
        else
        {
            //
            // Find the end-of-file position
            //

            g_dwFileOffset = GetFileSize(g_hFile, NULL);

            if ((DWORD)-1 == g_dwFileOffset)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessingRoutine: GetFileSize = %d",
                    GetLastError()
                    );

                LeaveCriticalSection(&g_FwFileLock);
                break;
            }
        }

        //
        // Launch our dropped event timer. When this timer fires,
        // the callback routine will check if any events have
        // been dropped (both in kernel mode and user mode),
        // and, if so, log that fact.
        //

        fSucceeded =
            CreateTimerQueueTimer(
                &g_hDroppedEventTimer,
                NULL,
                FwpDroppedEventTimerRoutine,
                NULL,
                0,
                1000 * 60 * 5, // 5 minutes
                0
                );

        if (FALSE == fSucceeded)
        {
            //
            // Even though we weren't able to create the timer,
            // we'll still try to log as much as possible.
            //
            
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessinRoutine: CreateTimerQueueTimer = %d",
                GetLastError()
                );
        }

        LeaveCriticalSection(&g_FwFileLock);

        //
        // Register our callback routines. We will attempt to continue
        // even if errors occur here.
        //

        dwError = SetTraceCallback(
                    &c_PacketDroppedEventGuid,
                    FwpPacketDroppedCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (packets dropped) = %d",
                dwError
                );
        }

        dwError = SetTraceCallback(
                    &c_ConnectionCreationEventGuid,
                    FwpConnectionCreationCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (connection creation) = %d",
                dwError
                );
        }

        dwError = SetTraceCallback(
                    &c_ConnectionDeletionEventGuid,
                    FwpConnectionDeletionCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (connection deletion) = %d",
                dwError
                );
        }

        //
        // Open the trace stream
        //

        ZeroMemory(&LogFile, sizeof(LogFile));
        LogFile.LoggerName = c_wszLogSessionName;
        LogFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;

        hTraceSession = OpenTrace(&LogFile);
        
        if ((TRACEHANDLE)INVALID_HANDLE_VALUE == hTraceSession)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: OpenTrace = %d",
                GetLastError()
                );

            break;
        }

        //
        // Start processing the trace stream. This call will block until
        // the trace session is closed (i.e., FwStopLogging is called).
        //

        dwError = ProcessTrace(&hTraceSession, 1, NULL, NULL);

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpTraceProcessingThreadRoutine: ProcessTrace = %d",
            dwError
            );

        dwError = CloseTrace(hTraceSession);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: CloseTrace = %d",
                dwError
                );
        }
            
    } while (FALSE);

    //
    // Make sure that all dropped events are properly logged
    //

    EnterCriticalSection(&g_FwLock);
    ulKernelEventsLostAtShutdown = g_ulKernelEventsLostAtShutdown;
    LeaveCriticalSection(&g_FwLock);

    //
    // Since we're shutting down, we pass in the number of lost kernel
    // events. This will prevent the timer routine from attempting to
    // query the stopped trace session
    //

    FwpDroppedEventTimerRoutine((PVOID)&ulKernelEventsLostAtShutdown, FALSE);

    //
    // Cleanup tracing thread resources
    //

    FwpCleanupTraceThreadResources();

    return dwError;
} // FwpTraceProcessingThreadRoutine


DWORD
FwpWriteLogHeaderToBuffer(
    PFW_LOG_BUFFER pBuffer
    )

/*++

Routine Description:

    Writes the log file header to the passed in buffer

Arguments:

    pBuffer - the buffer to write the header to.

Return Value:

    DWORD - Win32 error

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwHeaderSize;
    
    ASSERT(NULL != pBuffer);

    dwHeaderSize = lstrlenA(c_szLogFileHeader);

    if (FW_LOG_BUFFER_REMAINING(pBuffer) < dwHeaderSize)
    {
        dwError = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        RtlCopyMemory(pBuffer->pChar, c_szLogFileHeader, dwHeaderSize);
        pBuffer->pChar += dwHeaderSize;
    }

    return dwError;    
} // FwpWriteLogHeaderToBuffer


VOID
FwStartLogging(
    VOID
    )

/*++

Routine Description:

    This routine is called to start logging operations (depending on
    the current logging settings). It is safe to call this routine when
    logging has already started.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr = S_OK;
    DWORD dwError;
    
    PROFILE("FwStartLogging");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    g_fTracingActive = TRUE;

    if (NULL == g_pSettings)
    {
        hr = FwpLoadSettings(&g_pSettings);
    }

    if (SUCCEEDED(hr))
    {
        if ((g_pSettings->fLogDroppedPackets || g_pSettings->fLogConnections)
            && NULL == g_hSession)
        {
            ASSERT(NULL == g_hThread);

            //
            // Start the tracing session
            //

            dwError = FwpLaunchTraceSession(g_pSettings, &g_hSession);

            if (ERROR_SUCCESS == dwError)
            {
                //
                // Launch the trace processing thread. We're not using
                // any thread-specific crt routines (e.g., strtok) so
                // there's no need to call __beginthreadex
                //

                g_hThread = CreateThread(
                                NULL,       // SD
                                0,          // stack size
                                FwpTraceProcessingThreadRoutine,
                                NULL,       // thread argument
                                0,          // flags
                                NULL        // thread ID
                                );

                if (NULL == g_hThread)
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwStartLogging: CreateThread = %d",
                        GetLastError()
                        );

                    LeaveCriticalSection(&g_FwLock);
                    FwStopLogging();
                    return;
                }               
            }
        }
    }

    LeaveCriticalSection(&g_FwLock);
} // FwStartLogging


VOID
FwStopLogging(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop logging operations. It is safe to call
    this routine when logging is stopped.

Arguments:

    none.

Return Value:

    none.

Environment:

    The caller must not hold g_FwFileLock or g_FwLock.

--*/

{
    DWORD dwError;
    PEVENT_TRACE_PROPERTIES pProperties;
    
    PROFILE("FwStopLogging");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    g_fTracingActive = FALSE;

    //
    // Stop the trace session if it is currently active
    //

    if (NULL != g_hSession)
    {
        pProperties = FwpAllocateTraceProperties();

        if (NULL != pProperties)
        {
            dwError = ControlTrace(
                        g_hSession,
                        0,
                        pProperties,
                        EVENT_TRACE_CONTROL_STOP
                        );

            if (ERROR_SUCCESS == dwError)
            {
                g_hSession = NULL;
                g_ulKernelEventsLostAtShutdown = pProperties->EventsLost;

                if (NULL != g_hThread)
                {
                    HANDLE hThread;
                    
                    //
                    // Wait for thread to exit
                    //

                    hThread = g_hThread;

                    LeaveCriticalSection(&g_FwLock);

                    dwError = WaitForSingleObject(hThread, 45 * 1000);

                    if (WAIT_TIMEOUT == dwError)
                    {
                        NhTrace(
                            TRACE_FLAG_FWLOG,
                            "FwStopLogging: Timeout waiting for thread"
                            );
                            
                        //
                        // The logging thread still hasn't exited; kill
                        // it hard and make sure that all resources are
                        // properly freed...
                        //

                        EnterCriticalSection(&g_FwFileLock);
                        EnterCriticalSection(&g_FwLock);

                        //
                        // TerminateThread is a very dangerous call. However,
                        // since we control the thread we're about to kill,
                        // we can guarantee that this will be safe. In
                        // particular, since we hold both critical sections,
                        // there is no danger of them being orphaned, or of
                        // any of our global data being in an inconsistent
                        // state.
                        //

                        if (!TerminateThread(g_hThread, ERROR_TIMEOUT))
                        {
                            NhTrace(
                                TRACE_FLAG_FWLOG,
                                "FwStopLogging: TerminateThread = %d",
                                GetLastError()
                                );
                        }

                        LeaveCriticalSection(&g_FwLock);
                        LeaveCriticalSection(&g_FwFileLock);

                        //
                        // Cleanup thread resources. It is safe to call this
                        // routine multiple times.
                        //

                        FwpCleanupTraceThreadResources();
  
                    }
                    else if (WAIT_OBJECT_0 != dwError)
                    {
                        NhTrace(
                            TRACE_FLAG_FWLOG,
                            "FwStopLogging: wait for thread = %d/%d",
                            dwError,
                            GetLastError()
                            );
                    }

                    EnterCriticalSection(&g_FwLock);

                    if (NULL != g_hThread)
                    {
                        CloseHandle(g_hThread);
                    }
                    
                    g_hThread = NULL;
                }

                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwStopLogging: Stopped w/ %d events and %d buffers lost",
                    pProperties->EventsLost,
                    pProperties->RealTimeBuffersLost
                    );

                g_ulKernelEventsLostAtShutdown = 0;
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwStopLogging: ControlTrace = %d",
                    dwError
                    );

                //
                // Since the trace session has not yet been stopped,
                // we leave g_hSession unchanged.
                //
            }

            HeapFree(GetProcessHeap(), 0, pProperties);
        }
    }

    LeaveCriticalSection(&g_FwLock);
} // FwStopLogging


VOID
FwUpdateLoggingSettings(
    VOID
    )

/*++

Routine Description:

    This routine is called to notify the logging subsystem that the
    logging settings have changed.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr;
    HNET_FW_LOGGING_SETTINGS *pSettings;
    DWORD dwError;

    PROFILE("FwUpdateLoggingSettings");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    do
    {
        if (FALSE == g_fTracingActive)
        {
            //
            // Since tracing is not currently active, there is no
            // need to retrieve the current settings. Furthermore, free
            // any stored settings that we might have so that stale
            // settings are not used.
            //

            if (g_pSettings)
            {
                HNetFreeFirewallLoggingSettings(g_pSettings);
                g_pSettings = NULL;
            }

            break;
        }

        //
        // Obtain the current settings
        //

        hr = FwpLoadSettings(&pSettings);

        if (FAILED(hr))
        {
            break;
        }

        if (NULL == g_pSettings)
        {
            //
            // Since we don't have any cached settings (previous failure
            // in FwpLoadSettings?) simply store what we just retrieved
            // and call FwStartLogging.
            //

            g_pSettings = pSettings;
            FwStartLogging();
            break;
        }

        if (NULL == g_hSession)
        {
            //
            // There is no log session at the moment. Free the old settings,
            // store the new ones, and call FwStartLogging.
            //

            ASSERT(NULL == g_hThread);

            HNetFreeFirewallLoggingSettings(g_pSettings);
            g_pSettings = pSettings;

            FwStartLogging();
            break;
        }

        //
        // Compare the settings to see what, if anything, has changed
        //

        if (wcscmp(g_pSettings->pszwPath, pSettings->pszwPath))
        {
            //
            // Our log file has changed -- we need to stop and restart
            // everything so that logging is properly moved to the
            // new file.
            //

            LeaveCriticalSection(&g_FwLock);
            FwStopLogging();
            EnterCriticalSection(&g_FwLock);

            if (NULL != g_pSettings)
            {
                HNetFreeFirewallLoggingSettings(g_pSettings);
            }
            
            g_pSettings = pSettings;

            FwStartLogging();
            break;
        }

        //
        // Only possible changes are to enabled events
        //

        if (!!g_pSettings->fLogDroppedPackets
            != !!pSettings->fLogDroppedPackets)
        {
            dwError = EnableTrace(
                        pSettings->fLogDroppedPackets,
                        0,
                        0,
                        &c_PacketDroppedEventGuid,
                        g_hSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwUpdateLoggingSettings: EnableTrace (packets) = %d",
                    dwError
                    );
            }
        }

        if (!!g_pSettings->fLogConnections
            != !!pSettings->fLogConnections)
        {
            dwError = EnableTrace(
                        pSettings->fLogConnections,
                        0,
                        0,
                        &c_ConnectionCreationEventGuid,
                        g_hSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwUpdateLoggingSettings: EnableTrace (connections) = %d",
                    dwError
                    );
            }
        }

        //
        // Free old settings and store new
        //

        HNetFreeFirewallLoggingSettings(g_pSettings);
        g_pSettings = pSettings;
        
    } while (FALSE);

    LeaveCriticalSection(&g_FwLock);
    
} // FwUpdateLoggingSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\cudpbcast.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cudpbcast.h

Abstract:

    Declarations for CUdpBroadcastMapper -- support for mapping
    a public UDP port to the private network's broadcast address.

Author:

    Jonathan Burstein (jonburs)     12 April 2001

Revision History:

--*/

#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "udpbcast.h"

class CUdpBroadcast
{
public:
    LIST_ENTRY Link;
    USHORT usPublicPort;
    DWORD dwInterfaceIndex;
    ULONG ulDestinationAddress;
    HANDLE hDynamicRedirect;

    CUdpBroadcast(
        USHORT usPublicPort,
        DWORD dwInterfaceIndex,
        ULONG ulDestinationAddress
        )
    {
        InitializeListHead(&Link);
        this->usPublicPort = usPublicPort;
        this->dwInterfaceIndex = dwInterfaceIndex;
        this->ulDestinationAddress = ulDestinationAddress;
        hDynamicRedirect = NULL;
    };
};

class ATL_NO_VTABLE CUdpBroadcastMapper :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUdpBroadcastMapper
{
protected:

    //
    // The list of UDP Broadcast Mappings
    //

    LIST_ENTRY m_MappingList;

    //
    // Our UDP listening socket, to which the received
    // UDP packets on the public side will be redirected,
    // and the port of that socket
    //

    SOCKET m_hsUdpListen;
    USHORT m_usUdpListenPort;

    //
    // Our raw UDP socket, used to send the constructed
    // broadcast packet to the private network
    //

    SOCKET m_hsUdpRaw;

    //
    // Handle to the NAT
    //

    HANDLE m_hNat;

    //
    // Pointer to the NAT's component reference (needed
    // for asynch. socket routines
    //

    PCOMPONENT_REFERENCE m_pCompRef;

    //
    // Tracks whether or not we've been shutdown.
    //

    BOOL m_fActive;

    //
    // Tracks whether or not we've posted a read buffer.
    //

    BOOL m_fReadStarted;

    //
    // IP Identifier. This number has no intrinsic meaning --
    // it exists only so we don't send out ever packet w/
    // 0 in this field. Thread safety does not matter when
    //

    USHORT m_usIpId;

public:

    BEGIN_COM_MAP(CUdpBroadcastMapper)
        COM_INTERFACE_ENTRY(IUdpBroadcastMapper)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline Constructor
    //

    CUdpBroadcastMapper()
    {
        InitializeListHead(&m_MappingList);
        m_hsUdpListen = INVALID_SOCKET;
        m_hsUdpRaw = INVALID_SOCKET;
        m_hNat = NULL;
        m_pCompRef = NULL;
        m_fActive = TRUE;
        m_fReadStarted = FALSE;
        m_usIpId = 0;
    };

    //
    // ATL Methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Initialization
    //

    HRESULT
    Initialize(
        PCOMPONENT_REFERENCE pComponentReference
        );

    //
    // IUdpBroadcastMapper methods
    //

    STDMETHODIMP
    CreateUdpBroadcastMapping(
        USHORT usPublicPort,
        DWORD dwPublicInterfaceIndex,
        ULONG ulDestinationAddress,
        VOID **ppvCookie
        );

    STDMETHODIMP
    CancelUdpBroadcastMapping(
        VOID *pvCookie
        );

    STDMETHODIMP
    Shutdown();

protected:

    BOOL
    Active()
    {
        return m_fActive;
    };

    CUdpBroadcast*
    LookupMapping(
        USHORT usPublicPort,
        DWORD dwInterfaceIndex,
        PLIST_ENTRY *ppInsertionPoint
        );

    HRESULT
    StartUdpRead();

    static
    VOID
    UdpReadCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );

    VOID
    ProcessUdpRead(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );    

    HRESULT
    BuildAndSendRawUdpPacket(
        ULONG ulDestinationAddress,
        USHORT usDestinationPort,
        PNH_BUFFER pPacketData
        );

    static
    VOID
    RawWriteCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );

};

#include <packon.h>

typedef struct _IP_HEADER {
    UCHAR VersionAndHeaderLength;
    UCHAR TypeOfService;
    USHORT TotalLength;
    USHORT Identification;
    USHORT OffsetAndFlags;
    UCHAR TimeToLive;
    UCHAR Protocol;
    USHORT Checksum;
    ULONG SourceAddress;
    ULONG DestinationAddress;
} IP_HEADER, *PIP_HEADER;

typedef struct _UDP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    USHORT Length;
    USHORT Checksum;
} UDP_HEADER, *PUDP_HEADER;

#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\cudpbcast.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cudpbcast.cpp

Abstract:

    Implementation of CUdpBroadcastMapper -- support for mapping
    a public UDP port to the private network's broadcast address.

Author:

    Jonathan Burstein (jonburs)     12 April 2001

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// ATL Methods
//

HRESULT
CUdpBroadcastMapper::FinalConstruct()
{
    HRESULT hr = S_OK;
    DWORD dwError;

    //
    // Create our UDP listening socket and obtain
    // its port.
    //

    dwError =
        NhCreateDatagramSocket(
            INADDR_LOOPBACK_NO,
            0,
            &m_hsUdpListen
            );

    if (ERROR_SUCCESS == dwError)
    {
        m_usUdpListenPort = NhQueryPortSocket(m_hsUdpListen);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create our raw UDP send socket
        //

        dwError = NhCreateRawDatagramSocket(&m_hsUdpRaw);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Obtain a handle to the NAT
        //

        dwError = NatOpenDriver(&m_hNat);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    
    return hr;
}

HRESULT
CUdpBroadcastMapper::FinalRelease()
{
    if (INVALID_SOCKET != m_hsUdpListen)
    {
        closesocket(m_hsUdpListen);
    }

    if (INVALID_SOCKET != m_hsUdpRaw)
    {
        closesocket(m_hsUdpRaw);
    }

    if (NULL != m_hNat)
    {
        CloseHandle(m_hNat);
    }

    ASSERT(IsListEmpty(&m_MappingList));

    return S_OK;
}

//
// Initialization
//

HRESULT
CUdpBroadcastMapper::Initialize(
    PCOMPONENT_REFERENCE pComponentReference
    )
{
    HRESULT hr = S_OK;

    if (NULL != pComponentReference)
    {
        m_pCompRef = pComponentReference;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//
// IUdpBroadcastMapper methods
//

STDMETHODIMP
CUdpBroadcastMapper::CreateUdpBroadcastMapping(
    USHORT usPublicPort,
    DWORD dwPublicInterfaceIndex,
    ULONG ulDestinationAddress,
    VOID **ppvCookie
    )
{
    HRESULT hr = S_OK;
    CUdpBroadcast *pMapping;
    CUdpBroadcast *pDuplicate;
    PLIST_ENTRY pInsertionPoint;
    ULONG ulError;

    if (NULL != ppvCookie)
    {
        *ppvCookie = NULL;

        if (0 == usPublicPort
            || 0 == dwPublicInterfaceIndex
            || 0 == ulDestinationAddress)
        {
            hr = E_INVALIDARG;
        }
        else if (!m_fActive)
        {
            //
            // We've already been shutdown
            //

            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {
        pMapping = new CUdpBroadcast(
                        usPublicPort,
                        dwPublicInterfaceIndex,
                        ulDestinationAddress
                        );
        if (NULL == pMapping)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Check for duplicate and insert on list. It's OK for
        // the entry to be on the list before we've created the
        // dynamic redirect for it.
        //

        Lock();

        pDuplicate =
            LookupMapping(
                usPublicPort,
                dwPublicInterfaceIndex,
                &pInsertionPoint
                );

        if (NULL == pDuplicate)
        {
            InsertTailList(pInsertionPoint, &pMapping->Link);
        }
        else
        {
            delete pMapping;
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

        Unlock(); 
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the dynamic redirect for this entry
        //

        ulError =
            NatCreateDynamicAdapterRestrictedPortRedirect(
                NatRedirectFlagReceiveOnly,
                NAT_PROTOCOL_UDP,
                usPublicPort,
                INADDR_LOOPBACK_NO,
                m_usUdpListenPort,
                dwPublicInterfaceIndex,
                0,
                &pMapping->hDynamicRedirect
                );

        if (ERROR_SUCCESS != ulError)
        {
            hr = HRESULT_FROM_WIN32(ulError);

            Lock();
            RemoveEntryList(&pMapping->Link);
            Unlock();
                
            delete pMapping;
        }              
    }

    if (SUCCEEDED(hr))
    {
        //
        // Make sure that we've posted a read on our UDP socket
        //

        hr = StartUdpRead();

        if (SUCCEEDED(hr))
        {
            *ppvCookie = reinterpret_cast<PVOID>(pMapping);
        }
        else
        {
            NatCancelDynamicRedirect(pMapping->hDynamicRedirect);

            Lock();
            RemoveEntryList(&pMapping->Link);
            Unlock();

            delete pMapping;
        }
    }
    
    return hr;
}

STDMETHODIMP
CUdpBroadcastMapper::CancelUdpBroadcastMapping(
    VOID *pvCookie
    )
{
    HRESULT hr = S_OK;
    CUdpBroadcast *pMapping;
    ULONG ulError;

    if (NULL != pvCookie)
    {
        pMapping = reinterpret_cast<CUdpBroadcast*>(pvCookie);

        Lock();
        RemoveEntryList(&pMapping->Link);
        Unlock();

        ASSERT(NULL != pMapping->hDynamicRedirect);

        ulError = NatCancelDynamicRedirect(pMapping->hDynamicRedirect);
        if (ERROR_SUCCESS != ulError)
        {
            hr = HRESULT_FROM_WIN32(ulError);
        }

        delete pMapping;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP
CUdpBroadcastMapper::Shutdown()
{
    InterlockedExchange(
        reinterpret_cast<LPLONG>(&m_fActive),
        FALSE
        );

    //
    // We need to close our read socket handle so that any
    // pending reads complete. We don't need to close our
    // raw send socket since for that completion will never
    // be blocked waiting for an incoming packet.
    //

    Lock();

    if (INVALID_SOCKET != m_hsUdpListen)
    {
        closesocket(m_hsUdpListen);
        m_hsUdpListen = INVALID_SOCKET;
    }

    Unlock();
    
    return S_OK;
}

//
// Protected methods
//

CUdpBroadcast*
CUdpBroadcastMapper::LookupMapping(
    USHORT usPublicPort,
    DWORD dwInterfaceIndex,
    PLIST_ENTRY * ppInsertionPoint
    )
{
    PLIST_ENTRY pLink;
    CUdpBroadcast *pMapping;
    CUdpBroadcast *pMappingToReturn = NULL;

    //
    // The caller should have already locked the object before calling
    // this method to guarantee that what we return will still be
    // valid. However, we'll still grab the lock again to ensure that
    // it's safe to traverse the list.
    //

    Lock();

    for (pLink = m_MappingList.Flink;
         pLink != &m_MappingList;
         pLink = pLink->Flink)
    {
        pMapping = CONTAINING_RECORD(pLink, CUdpBroadcast, Link);

        if (pMapping->usPublicPort < usPublicPort)
        {
            continue;
        }
        else if (pMapping->usPublicPort > usPublicPort)
        {
            break;
        }

        //
        // Primary key matches, check secondary key
        //

        if (pMapping->dwInterfaceIndex < dwInterfaceIndex)
        {
            continue;
        }
        else if (pMapping->dwInterfaceIndex > dwInterfaceIndex)
        {
            break;
        }

        //
        // Found it.
        //

        pMappingToReturn = pMapping;
        break;
    }

    Unlock();

    if (NULL == pMappingToReturn
        && NULL != ppInsertionPoint)
    {
        *ppInsertionPoint = pLink;
    }

    return pMappingToReturn;
}

HRESULT
CUdpBroadcastMapper::StartUdpRead()
{
    HRESULT hr = S_OK;
    ULONG ulError;
    LONG fReadStarted;

    Lock();
    
    if (!m_fReadStarted)
    {
        AddRef();
        ulError =
            NhReadDatagramSocket(
                m_pCompRef,
                m_hsUdpListen,
                NULL,
                UdpReadCompletionRoutine,
                this,
                m_pCompRef
                );

        if (ERROR_SUCCESS == ulError)
        {
            m_fReadStarted = TRUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ulError);
            Release();
        }
    }

    Unlock();

    return hr;
}

VOID
CUdpBroadcastMapper::UdpReadCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        )
{
    CUdpBroadcastMapper *pMapper;
    PCOMPONENT_REFERENCE pCompRef;

    pMapper = reinterpret_cast<CUdpBroadcastMapper*>(pBuffer->Context);
    pCompRef = reinterpret_cast<PCOMPONENT_REFERENCE>(pBuffer->Context2);

    ASSERT(NULL != pMapper);
    ASSERT(NULL != pCompRef);

    //
    // Do the actual work
    //

    pMapper->ProcessUdpRead(ulError, ulBytesTransferred, pBuffer);

    //
    // Release the references obtained on both the object and
    // the component
    //

    pMapper->Release();
    ReleaseComponentReference(pCompRef); 
}

VOID
CUdpBroadcastMapper::ProcessUdpRead(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        )
{
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION MappingInfo;
    ULONG ulBufferSize;
    DWORD dwError;
    CUdpBroadcast *pMapping;
    ULONG ulDestinationAddress = 0;
    
    //
    // If an error occured check to see if we should repost
    // the read. If we're not active release the buffer
    // and exit.
    //

    if (ERROR_SUCCESS != ulError || !Active())
    {
        Lock();
        
        if (Active()
            && !NhIsFatalSocketError(ulError)
            && INVALID_SOCKET != m_hsUdpListen)
        {
            AddRef();
            dwError =
                NhReadDatagramSocket(
                    m_pCompRef,
                    m_hsUdpListen,
                    pBuffer,
                    UdpReadCompletionRoutine,
                    this,
                    m_pCompRef
                    );
            if (ERROR_SUCCESS != dwError)
            {
                Release();
                NhReleaseBuffer(pBuffer);
            }
        }
        else
        {
            NhReleaseBuffer(pBuffer);
        }

        Unlock();

        return;
    }

    //
    // Lookup the original destination address for this packet.
    //

    ulBufferSize = sizeof(MappingInfo); 
    dwError =
        NatLookupAndQueryInformationSessionMapping(
            m_hNat,
            NAT_PROTOCOL_UDP,
            INADDR_LOOPBACK_NO,
            m_usUdpListenPort,
            pBuffer->ReadAddress.sin_addr.s_addr,
            pBuffer->ReadAddress.sin_port,
            &MappingInfo,
            &ulBufferSize,
            NatKeySessionMappingExInformation
            );

    if (ERROR_SUCCESS == dwError)
    {
        //
        // See if we have a port mapping for the original destination,
        // and, if so, get the destination address
        //

        Lock();

        pMapping =
            LookupMapping(
                MappingInfo.DestinationPort,
                MappingInfo.AdapterIndex,
                NULL
                );

        if (NULL != pMapping)
        {
            ulDestinationAddress = pMapping->ulDestinationAddress;
        }

        Unlock();
    }

    if (0 != ulDestinationAddress)
    {
        //
        // Construct the new packet and send it on its way
        //

        BuildAndSendRawUdpPacket(
            ulDestinationAddress,
            MappingInfo.DestinationPort,
            pBuffer
            );
    }

    //
    // If we're still active repost the read, otherwise free the
    // buffer.
    //

    Lock();

    if (Active()
        && INVALID_SOCKET != m_hsUdpListen)
    {
        AddRef();
        dwError =
            NhReadDatagramSocket(
                m_pCompRef,
                m_hsUdpListen,
                pBuffer,
                UdpReadCompletionRoutine,
                this,
                m_pCompRef
                );
        if (ERROR_SUCCESS != dwError)
        {
            Release();
            NhReleaseBuffer(pBuffer);
        }
    }
    else
    {
        NhReleaseBuffer(pBuffer);
    }

    Unlock();
    
}

HRESULT
CUdpBroadcastMapper::BuildAndSendRawUdpPacket(
    ULONG ulDestinationAddress,
    USHORT usDestinationPort,
    PNH_BUFFER pPacketData
    )
{
    HRESULT hr = S_OK;
    PNH_BUFFER pBuffer;
    ULONG ulPacketSize;
    PIP_HEADER pIpHeader;
    UDP_HEADER UNALIGNED *pUdpHeader;
    PUCHAR pucData;
    DWORD dwError;

    //
    // Allocate a buffer large enough for the headers and packet data
    //

    ulPacketSize =
        sizeof(IP_HEADER) + sizeof(UDP_HEADER) + pPacketData->BytesTransferred;

    pBuffer = NhAcquireVariableLengthBuffer(ulPacketSize);

    if (NULL != pBuffer)
    {
        //
        // Locate offsets w/in the buffer
        //

        pIpHeader = reinterpret_cast<PIP_HEADER>(pBuffer->Buffer);
        pUdpHeader =
            reinterpret_cast<UDP_HEADER UNALIGNED *>(pBuffer->Buffer + sizeof(IP_HEADER));
        pucData = pBuffer->Buffer + sizeof(IP_HEADER) + sizeof(UDP_HEADER);

        //
        // Copy over the packet data
        //

        CopyMemory(pucData, pPacketData->Buffer, pPacketData->BytesTransferred);

        //
        // Fill out the IP header
        //

        pIpHeader->VersionAndHeaderLength =
            (4 << 4) | (sizeof(IP_HEADER) / sizeof(ULONG));
        pIpHeader->TypeOfService = 0;
        pIpHeader->TotalLength = htons(static_cast<USHORT>(ulPacketSize));
        pIpHeader->Identification = htons(++m_usIpId);
        pIpHeader->OffsetAndFlags = 0;
        pIpHeader->TimeToLive = 128;
        pIpHeader->Protocol = NAT_PROTOCOL_UDP;
        pIpHeader->Checksum = 0;
        pIpHeader->SourceAddress = pPacketData->ReadAddress.sin_addr.s_addr;
        pIpHeader->DestinationAddress = ulDestinationAddress;

        //
        // Fill out the UDP header
        //

        pUdpHeader->SourcePort = pPacketData->ReadAddress.sin_port;
        pUdpHeader->DestinationPort = usDestinationPort;
        pUdpHeader->Length =
            htons(
                static_cast<USHORT>(
                    sizeof(UDP_HEADER) + pPacketData->BytesTransferred
                    )
                );
        pUdpHeader->Checksum = 0;

        //
        // Send the buffer on its way
        //

        AddRef();
        dwError =
            NhWriteDatagramSocket(
                m_pCompRef,
                m_hsUdpRaw,
                ulDestinationAddress,
                usDestinationPort,
                pBuffer,
                ulPacketSize,
                RawWriteCompletionRoutine,
                this,
                m_pCompRef
                );
        if (ERROR_SUCCESS != dwError)
        {
            Release();
            NhReleaseBuffer(pBuffer);
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

VOID
CUdpBroadcastMapper::RawWriteCompletionRoutine(
    ULONG ulError,
    ULONG ulBytesTransferred,
    PNH_BUFFER pBuffer
    )
{
    CUdpBroadcastMapper *pMapper;
    PCOMPONENT_REFERENCE pCompRef;

    pMapper = reinterpret_cast<CUdpBroadcastMapper*>(pBuffer->Context);
    pCompRef = reinterpret_cast<PCOMPONENT_REFERENCE>(pBuffer->Context2);

    ASSERT(NULL != pMapper);
    ASSERT(NULL != pCompRef);

    //
    // Free the passed-in buffer
    //

    NhReleaseBuffer(pBuffer);
    
    //
    // Release the references obtained on both the object and
    // the component
    //

    pMapper->Release();
    ReleaseComponentReference(pCompRef);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\fwlogger.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    fwlogger.h

Abstract:

    Support for firewall logging to a text file.

Author:

    Jonathan Burstein (jonburs)     18 September 2000

Revision History:

--*/

#pragma once

#include <wmistr.h>
#include <evntrace.h>
#include <ntwmi.h>
#include "natschma.h"

//
// Protocol constants
//

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_PPTP       0x2F

#define TCP_FLAG_FIN            0x0100
#define TCP_FLAG_SYN            0x0200
#define TCP_FLAG_RST            0x0400
#define TCP_FLAG_PSH            0x0800
#define TCP_FLAG_ACK            0x1000
#define TCP_FLAG_URG            0x2000

//
// Structures
//

#define FW_LOG_BUFFER_SIZE 4096 - sizeof(OVERLAPPED) - sizeof(PCHAR)
#define FW_LOG_BUFFER_REMAINING(pBuffer) \
            FW_LOG_BUFFER_SIZE - ((pBuffer)->pChar - (pBuffer)->Buffer)

typedef struct _FW_LOG_BUFFER
{
    OVERLAPPED Overlapped;
    PCHAR pChar;
    CHAR Buffer[FW_LOG_BUFFER_SIZE];
} FW_LOG_BUFFER, *PFW_LOG_BUFFER;

//
// Prototypes
//

VOID
FwCleanupLogger(
    VOID
    );

DWORD
FwInitializeLogger(
    VOID
    );

VOID
FwStartLogging(
    VOID
    );

VOID
FwStopLogging(
    VOID
    );

VOID
FwUpdateLoggingSettings(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\natarp.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natarp.c

Abstract:

    This module contains code for the NAT's user-mode proxy-ARP entry
    management. Proxy-ARP entries are installed on dedicated interfaces
    which have address-translation enabled.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// FORWARD DECLARATIONS
//

VOID
NatpCreateProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );

VOID
NatpDeleteProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );


VOID
NatpCreateProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to remove a proxy-ARP entry.

Arguments:

    Address - the address to remove

    Mask - the mask associated with 'Address'

    Context - context-field holding the entry's interface

Return Value:

    none.

--*/

{
    ULONG Error;
    DEFINE_MIB_BUFFER(Info, MIB_PROXYARP, Entry);
    PROFILE("NatpCreateProxyArpCallback");
    //
    // Install an entry for the range, unless the host-portion is 1 bit wide,
    // in which case the range consists only of an all-zeroes and all-ones host.
    // The stack will refuse to answer ARP queries for either one,
    // so adding such a range would be a waste.
    //
    Info->dwId = PROXY_ARP;
    if (~Mask != 1) {
        Entry->dwAddress = (Address & Mask);
        Entry->dwMask = Mask;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        Error =
            NatSupportFunctions.MIBEntryCreate(
                IPRTRMGR_PID,
                MIB_INFO_SIZE(MIB_PROXYARP),
                Info
                );
        if (Error) {
            CHAR MaskString[16];
            lstrcpyA(MaskString, INET_NTOA(Mask));
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpCreateProxyArpCallback: error %d adding %s/%s",
                Error, INET_NTOA(Address), MaskString
                );
            NhInformationLog(
                IP_NAT_LOG_UPDATE_ARP_FAILED,
                Error,
                "%I%I",
                Address,
                Mask
                );
        }
    }
    //
    // If the mask is not all-ones, also install entries for the all-zeroes
    // and all-ones host-portions of the range; otherwise IP will refuse
    // to answer ARP queries for these.
    //
    if (~Mask) {
        Entry->dwAddress = (Address & Mask);
        Entry->dwMask = 0xffffffff;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryCreate(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Info
            );
        Entry->dwAddress = (Address | ~Mask);
        Entry->dwMask = 0xffffffff;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryCreate(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Info
            );
    }

} // NatpCreateProxyArpCallback


VOID
NatpDeleteProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to remove a proxy-ARP entry.

Arguments:

    Address - the address to remove

    Mask - the mask associated with 'Address'

    Context - context-field holding the entry's interface

Return Value:

    none.

--*/

{
    BYTE Buffer[FIELD_OFFSET(MIB_OPAQUE_QUERY, rgdwVarIndex) + 3*sizeof(DWORD)];
    ULONG Error;
    PMIB_OPAQUE_QUERY Query = (PMIB_OPAQUE_QUERY)Buffer;
    PROFILE("NatpDeleteProxyArpCallback");
    Query->dwVarId = PROXY_ARP;
    Query->rgdwVarIndex[0] = (Address & Mask);
    Query->rgdwVarIndex[1] = Mask;
    Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
    Error =
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
    if (Error) {
        CHAR MaskString[16];
        lstrcpyA(MaskString, INET_NTOA(Mask));
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpDeleteProxyArpCallback: error %d deleting %s/%s",
            Error, INET_NTOA(Address), MaskString
            );
        NhInformationLog(
            IP_NAT_LOG_UPDATE_ARP_FAILED,
            Error,
            "%I%I",
            Address,
            Mask
            );
    }
    //
    // If the mask is not all-ones, also remove the entries for the all-zeroes
    // and all-ones host-portions of the range.
    //
    if (~Mask) {
        Query->rgdwVarIndex[0] = (Address & Mask);
        Query->rgdwVarIndex[1] = 0xffffffff;
        Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
        Query->rgdwVarIndex[0] = (Address | ~Mask);
        Query->rgdwVarIndex[1] = 0xffffffff;
        Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
    }

} // NatpDeleteProxyArpCallback


VOID
NatUpdateProxyArp(
    PNAT_INTERFACE Interfacep,
    BOOLEAN CreateEntries
    )

/*++

Routine Description:

    This routine is invoked to install or remove the proxy-ARP entries
    corresponding to the address-ranges configured on the given interface.

Arguments:

    Interfacep - the interface on which to operate

    CreateEntries - TRUE to install entries, FALSE to remove

Return Value:

    none.

Environment:

    Invoked with the interface list locked by the caller.

--*/

{
    ULONG Count;
    ULONG Error;
    ULONG i;
    PIP_NAT_ADDRESS_RANGE Range;

    PROFILE("NatUpdateProxyArp");

    if (!Interfacep->Info ||
        !NatSupportFunctions.MIBEntryCreate ||
        !NatSupportFunctions.MIBEntryDelete
        ) {
        return;
    }

    //
    // Locate the address-ranges, if any
    //

    Error =
        MprInfoBlockFind(
            &Interfacep->Info->Header,
            IP_NAT_ADDRESS_RANGE_TYPE,
            NULL,
            &Count,
            (PUCHAR*)&Range
            );
    if (Error || NULL == Range) { return; }

    //
    // Now go through the ranges, decomposing each one
    //

    for (i = 0; i < Count; i++) {
        DecomposeRange(
            Range[i].StartAddress,
            Range[i].EndAddress,
            MostGeneralMask(Range[i].StartAddress, Range[i].EndAddress),
            CreateEntries
                ? NatpCreateProxyArpCallback : NatpDeleteProxyArpCallback,
            Interfacep
            );
    }

} // NatUpdateProxyArp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnatapi.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>
#include <netconp.h>
#include <tcguid.h>
#include <wmium.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "rmapi.h"
#include "rmdhcp.h"
#include "rmdns.h"
#include "rmALG.h"
#include "rmh323.h"
#include "rmnat.h"
#include "natapip.h"
#include "natarp.h"
#include "natio.h"
#include "natconn.h"
#include "natlog.h"
#include "svcmain.h"
#include "timer.h"
#include "fwlogger.h"
#include "cudpbcast.h"
#include "csaupdate.h"


#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\natconn.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natconn.c

Abstract:

    This module contains code for the NAT's RAS connection management.
    This includes
    * code to support 'shared-access', in which a RAS client-connection
        serves as the NAT public network.
    * code to support 'on-demand dialing', in which a routing-failure
        results in our attempting to establish a dialup connection
        with the help of the autodial service.

Author:

    Abolade Gbadegesin (aboladeg)   2-May-1998

Revision History:

    Jonathan Burstein (jonburs)     6-July-2000
    Updated to new config APIs

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <dnsapi.h>
#include "beacon.h"

//
// EXTERNAL DECLARATIONS
//

extern "C"
ULONG APIENTRY
RasGetEntryHrasconnW(
    LPCWSTR Phonebook,
    LPCWSTR EntryName,
    LPHRASCONN Hrasconn
    );

extern "C"
ULONG
SetIpForwardEntryToStack(
    PMIB_IPFORWARDROW IpForwardRow
    );

extern "C"
ULONG
NhpAllocateAndGetInterfaceInfoFromStack(
    IP_INTERFACE_NAME_INFO** Table,
    PULONG Count,
    BOOL SortOutput,
    HANDLE AllocationHeap,
    ULONG AllocationFlags
    );

//
// Notifications
//

HANDLE NatConfigurationChangedEvent = NULL;
HANDLE NatpConfigurationChangedWaitHandle = NULL;
HANDLE NatConnectionNotifyEvent = NULL;
HANDLE NatpConnectionNotifyWaitHandle = NULL;
HANDLE NatpEnableRouterEvent = NULL;
OVERLAPPED NatpEnableRouterOverlapped;
HANDLE NatpEnableRouterWaitHandle = NULL;
IO_STATUS_BLOCK NatpRoutingFailureIoStatus;
IP_NAT_ROUTING_FAILURE_NOTIFICATION NatpRoutingFailureNotification;


//
// Connection information
//

LIST_ENTRY NatpConnectionList = {NULL, NULL};
ULONG NatpFirewallConnectionCount = 0;
BOOLEAN NatpSharedConnectionPresent = FALSE;
PCHAR NatpSharedConnectionDomainName = NULL;
LONG NatpNextInterfaceIndex = 1;

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// FORWARD DECLARATIONS
//

HRESULT
NatpAddConnectionEntry(
    IUnknown *pUnk
    );

ULONG
NatpBindConnection(
    PNAT_CONNECTION_ENTRY pConEntry,
    HRASCONN Hrasconn,
    ULONG AdapterIndex OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo OPTIONAL
    );

HRESULT
NatpBuildPortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO pBindingInfo
    );

VOID NTAPI
NatpConfigurationChangedCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
NatpConnectionNotifyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
NatpEnableRouterCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID
NatpFreeConnectionEntry(
    PNAT_CONNECTION_ENTRY pConEntry
    );

VOID
NatpFreePortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry
    );

PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
NatpQueryConnectionAdapter(
    ULONG Index
    );

PIP_NAT_INTERFACE_INFO
NatpQueryConnectionInformation(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
NatpProcessConfigurationChanged(
    VOID
    );

VOID
NatpProcessConnectionNotify(
    VOID
    );

VOID NTAPI
NatpRoutingFailureCallbackRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );

VOID NTAPI
NatpRoutingFailureWorkerRoutine(
    PVOID Context
    );

ULONG
NatpStartSharedConnectionManagement(
    VOID
    );

ULONG
NatpStopSharedConnectionManagement(
    VOID
    );

VOID
NatpUpdateSharedConnectionDomainName(
    ULONG AdapterIndex
    );

BOOLEAN
NatpUnbindConnection(
    PNAT_CONNECTION_ENTRY pConEntry
    );


PNAT_CONNECTION_ENTRY
NatFindConnectionEntry(
    GUID *pGuid
    )

/*++

Routine Description:

    Locates a connection entry by guid

Arguments:

    pGuid - identifies the connection to locate
    
Return Value:

    PNAT_CONNECTION_ENTRY - a pointer to the connection, or NULL
        if not found
    
Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PNAT_CONNECTION_ENTRY pConnection;
    PLIST_ENTRY pLink;

    for (pLink = NatpConnectionList.Flink;
         pLink != &NatpConnectionList;
         pLink = pLink->Flink)
    {
        pConnection = CONTAINING_RECORD(pLink, NAT_CONNECTION_ENTRY, Link);
        if (IsEqualGUID(pConnection->Guid, *pGuid))
        {
            return pConnection;
        }
    }

    return NULL;
} // NatFindConnectionEntry


PNAT_PORT_MAPPING_ENTRY
NatFindPortMappingEntry(
    PNAT_CONNECTION_ENTRY pConnection,
    GUID *pGuid
    )

/*++

Routine Description:

    Locates a port mapping entry for a connection
    
Arguments:

    pConnection - the connection to search 
    
    pGuid - identifies the port mapping entry to locate
    
Return Value:

    PNAT_PORT_MAPPING_ENTRY - a pointer to the port mapping, or NULL
        if not found
    
Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PNAT_PORT_MAPPING_ENTRY pMapping;
    PLIST_ENTRY pLink;

    for (pLink = pConnection->PortMappingList.Flink;
         pLink != &pConnection->PortMappingList;
         pLink = pLink->Flink)
    {
        pMapping = CONTAINING_RECORD(pLink, NAT_PORT_MAPPING_ENTRY, Link);
        if (IsEqualGUID(*pMapping->pProtocolGuid, *pGuid))
        {
            return pMapping;
        }
    }

    return NULL;
} // NatFindPortMappingEntry


VOID
NatFreePortMappingEntry(
    PNAT_PORT_MAPPING_ENTRY pEntry
    )

/*++

Routine Description:

    Frees all resources associated with a port mapping entry. This
    entry must have already been removed from the containing port
    mapping list and destroyed at the kernel / UDP broadcast mapper
    level.

Arguments:

    pEntry - the entry to free

Return Value:

    none.

--*/

{
    ASSERT(NULL != pEntry);
    
    if (NULL != pEntry->pProtocolGuid)
    {
        CoTaskMemFree(pEntry->pProtocolGuid);
    }

    if (NULL != pEntry->pProtocol)
    {
        pEntry->pProtocol->Release();
    }

    if (NULL != pEntry->pBinding)
    {
        pEntry->pBinding->Release();
    }

    NH_FREE(pEntry);
} // NatFreePortMappingEntry


HRESULT
NatpAddConnectionEntry(
    IUnknown *pUnk
    )

/*++

Routine Description:

    Creates a NAT_CONNECTION_ENTRY for a firewalled or Ics public connection.

Arguments:

    pUnk - pointer to an IHNetFirewalledConnection or IHNetIcsPublicConnection.
           This need not be the canonical IUnknown (i.e., it's fine to pass in a
           pointer of either of the above interfaces).

Return Value:

    Standard HRESULT

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    HRESULT hr = S_OK;
    PNAT_CONNECTION_ENTRY pNewEntry = NULL;
    IHNetConnection *pNetCon = NULL;

    //
    // Allocate new entry stucture
    //

    pNewEntry = reinterpret_cast<PNAT_CONNECTION_ENTRY>(
                    NH_ALLOCATE(sizeof(*pNewEntry))
                    );

    if (NULL != pNewEntry)
    {
        RtlZeroMemory(pNewEntry, sizeof(*pNewEntry));
        InitializeListHead(&pNewEntry->Link);
        InitializeListHead(&pNewEntry->PortMappingList);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Get IHNetConnection interface
    //

    if (S_OK == hr)
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IHNetConnection, &pNetCon));

        if (SUCCEEDED(hr))
        {
            pNewEntry->pHNetConnection = pNetCon;
            pNewEntry->pHNetConnection->AddRef();

            HNET_CONN_PROPERTIES *pProps;

            //
            // Get the properties for the connection
            //

            hr = pNetCon->GetProperties(&pProps);

            if (SUCCEEDED(hr))
            {
                //
                // Copy properties into entry
                //

                RtlCopyMemory(
                    &pNewEntry->HNetProperties,
                    pProps,
                    sizeof(*pProps)
                    );

                CoTaskMemFree(pProps);
            }
        }

        if (SUCCEEDED(hr))
        {
            GUID *pGuid;

            //
            // Get the guid of the connectoin
            //

            hr = pNetCon->GetGuid(&pGuid);

            if (SUCCEEDED(hr))
            {
                RtlCopyMemory(&pNewEntry->Guid, pGuid, sizeof(GUID));
                CoTaskMemFree(pGuid);
            }
        }

        if (SUCCEEDED(hr) && !pNewEntry->HNetProperties.fLanConnection)
        {
            //
            // Get the RAS phonebook path. We don't cache the
            // name since that can change over time.
            //

            hr = pNetCon->GetRasPhonebookPath(
                    &pNewEntry->wszPhonebookPath
                    );
        }
    }

    if (SUCCEEDED(hr) && pNewEntry->HNetProperties.fFirewalled)
    {
        //
        // Get the firewall control interface
        //

        hr = pNetCon->GetControlInterface(
                IID_PPV_ARG(IHNetFirewalledConnection, &pNewEntry->pHNetFwConnection)
                );

        if (SUCCEEDED(hr))
        {
            NatpFirewallConnectionCount += 1;
        }
    }

    if (SUCCEEDED(hr) && pNewEntry->HNetProperties.fIcsPublic)
    {
        //
        // Get the ICS public control interface
        //

        hr = pNetCon->GetControlInterface(
                IID_PPV_ARG(IHNetIcsPublicConnection, &pNewEntry->pHNetIcsPublicConnection)
                );

        if (SUCCEEDED(hr))
        {
            //
            // Remember that we now have a shared connection
            //

            NatpSharedConnectionPresent = TRUE;
        }
    }

    if (NULL != pNetCon)
    {
        pNetCon->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Add the new entry to the connection list. Ordering doesn't matter.
        //

        InsertTailList(&NatpConnectionList, &pNewEntry->Link);
    }
    else if (NULL != pNewEntry)
    {
        //
        // Cleanup the partially constructed entry
        //

        NatpFreeConnectionEntry(pNewEntry);
    }

    return hr;
}


ULONG
NatpBindConnection(
    PNAT_CONNECTION_ENTRY pConEntry,
    HRASCONN Hrasconn,
    ULONG AdapterIndex,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is responsible for binding the shared-connection.

Arguments:

    pConEntry - the entry to bind

    Hrasconn - if the connection is a dialup connection,
        contains the handle for the active RAS connection.

    AdapterIndex - if the connection is a LAN connection,
        contains the adapter index for the active LAN connection.

    BindingInfo - if the connection is a LAN connection,
        contains the binding information for the active LAN interface.

Return Value:

    ULONG - Win32 error.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    ULONG Error;
    MIB_IPFORWARDROW IpForwardRow;
    GUID Guid;
    RASPPPIPA RasPppIp;
    ULONG Size;
    PLIST_ENTRY InsertionPoint;
    PLIST_ENTRY Link;
    PNAT_PORT_MAPPING_ENTRY PortMapping;
    HRESULT hr;


    if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
        return NO_ERROR;
    }

    //
    // LAN public interfaces are handled differently than RAS public interfaces.
    // With a LAN interface, the binding information is passed in from
    // 'NatpProcessConnectionNotify'.
    // With a RAS inteface, though, we retrieve the projection-information
    // for the active connection, and map the address to an adapter index.
    //

    if (!pConEntry->HNetProperties.fLanConnection) {

        //
        // Allocate space for the binding info, if this has not yet
        // occured. (This memory will be freed in NatpFreeConnectionEntry.)
        //

        if (NULL == pConEntry->pBindingInfo) {
            
            pConEntry->pBindingInfo =
                reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
                    NH_ALLOCATE(
                        FIELD_OFFSET(IP_ADAPTER_BINDING_INFO, Address)
                        + sizeof(IP_LOCAL_BINDING)
                        )
                    );

            if (NULL == pConEntry->pBindingInfo) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpBindConnection: Unable to allocate binding info"
                    );
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Retrieve the PPP projection information for the interface.
        //

        ZeroMemory(&RasPppIp, sizeof(RasPppIp));
        Size = RasPppIp.dwSize = sizeof(RasPppIp);
        Error =
            RasGetProjectionInfoA(
                Hrasconn,
                RASP_PppIp,
                &RasPppIp,
                &Size
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpBindConnection: RasGetProjectionInfoA=%d",
                Error
                );
            return Error;
        }

        //
        // Convert the projection information to our format
        //

        BindingInfo = pConEntry->pBindingInfo;
        BindingInfo->AddressCount = 1;
        BindingInfo->RemoteAddress = 0;
        BindingInfo->Address[0].Address = inet_addr(RasPppIp.szIpAddress);
        BindingInfo->Address[0].Mask = 0xffffffff;

        //
        // Attempt to find the TCP/IP adapter index for the connection
        //

        AdapterIndex = NhMapAddressToAdapter(BindingInfo->Address[0].Address);
        if (AdapterIndex == (ULONG)-1) {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpBindConnection: MapAddressToAdapter failed"
                );
            return ERROR_NO_SUCH_INTERFACE;
        }

        //
        // Install a default route through the interface, if this is
        // the shared connection. (We don't want to do this for a
        // firewall-only connection.)
        //

        if (pConEntry->HNetProperties.fIcsPublic) {
            ZeroMemory(&IpForwardRow, sizeof(IpForwardRow));
            IpForwardRow.dwForwardNextHop =
                BindingInfo->Address[0].Address;
            IpForwardRow.dwForwardIfIndex = AdapterIndex;
            IpForwardRow.dwForwardType = MIB_IPROUTE_TYPE_DIRECT;
            IpForwardRow.dwForwardProto = PROTO_IP_NAT;
            IpForwardRow.dwForwardMetric1 = 1;

            Error = SetIpForwardEntryToStack(&IpForwardRow);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpBindConnection: SetIpForwardEntryToStack=%d",
                    Error
                    );
                return Error;
            }
        }
    }

    pConEntry->AdapterIndex = AdapterIndex;

    //
    // Make sure the interface type is correct.
    //

    pConEntry->Interface.Type = ROUTER_IF_TYPE_INTERNAL;

    //
    // Set the interface index value. This can be anything except 0
    // (as 0 is reserved for the private connection).
    //

    do
    {
        pConEntry->Interface.Index =
            static_cast<ULONG>(InterlockedIncrement(&NatpNextInterfaceIndex));
    } while (0 == pConEntry->Interface.Index);

    //
    // Build the port mapping list for this connection
    //

    hr = NatpBuildPortMappingList(pConEntry, BindingInfo);
    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection: NatpBuildPortMappingList=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Bind the interface, building its configuration to include
    // any port-mappings configured as part of shared access settings.
    //

    pConEntry->Interface.Info =
        NatpQueryConnectionInformation(pConEntry, BindingInfo);

    if (NULL == pConEntry->Interface.Info) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection[%i]: NatpQueryConnectionInformation failed",
            pConEntry->Interface.Index
            );

        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    Error =
        NatBindInterface(
            pConEntry->Interface.Index,
            &pConEntry->Interface,
            BindingInfo,
            AdapterIndex
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection[%i]: NatBindInterface=%d",
            pConEntry->Interface.Index,
            Error
            );

        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);

        return Error;
    }

    //
    // At this point NAT_INTERFACE_FLAG_BOUND has been set on the
    // interface, so we don't need to clean up the port mapping
    // list on error, as the list will be cleaned up in
    // NatpUnbindConnection.
    //

    //
    // Create UDP broadcast mappings if this is the ICS
    // public connection.
    //

    if (pConEntry->HNetProperties.fIcsPublic
        && 0 != pConEntry->UdpBroadcastPortMappingCount)
    {
        DWORD dwAddress;
        DWORD dwMask;
        DWORD dwBroadcastAddress;

        ASSERT(NULL != NhpUdpBroadcastMapper);
        ASSERT(!IsListEmpty(&pConEntry->PortMappingList));

        if (NhQueryScopeInformation(&dwAddress, &dwMask))
        {
            dwBroadcastAddress = (dwAddress & dwMask) | ~dwMask;
            
            for (Link = pConEntry->PortMappingList.Flink;
                 Link != &pConEntry->PortMappingList;
                 Link = Link->Flink)
            {
                PortMapping =
                    CONTAINING_RECORD(Link, NAT_PORT_MAPPING_ENTRY, Link);

                if (!PortMapping->fUdpBroadcastMapping) { continue; }

                hr = NhpUdpBroadcastMapper->CreateUdpBroadcastMapping(
                        PortMapping->usPublicPort,
                        AdapterIndex,
                        dwBroadcastAddress,
                        &PortMapping->pvBroadcastCookie
                        );

                if (FAILED(hr))
                {
                    //
                    // We'll continue if an error occurs here.
                    //
                    
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NatpBindConnection: CreateUdpBroadcastMapping=0x%08x",
                        hr
                        );
                }
            }
        }
    }

    //
    // Make sure that the interface is on the global list (so that the
    // FTP, ALG, and H.323 proxies will be able to find its configuration).
    //

    if (!NatpLookupInterface(
            pConEntry->Interface.Index,
            &InsertionPoint
            )) {
        InsertTailList(InsertionPoint, &pConEntry->Interface.Link);
    }

    //
    // Add the interface the the ALG proxy, if this has not yet
    // happened.
    //

    if (!NAT_INTERFACE_ADDED_ALG(&pConEntry->Interface)) {
        Error =
            AlgRmAddInterface(
                NULL,
                pConEntry->Interface.Index,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NatpBindConnection: AlgRmAddInterface=%d",
                Error
                );
            return Error;
        }

        pConEntry->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_ALG;
    }

    //
    // Bind and enable the interface for ALG
    //

    Error = AlgRmBindInterface(pConEntry->Interface.Index, BindingInfo);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: AlgRmBindInterface=%d",
            Error
            );
        return Error;
    }

    Error = AlgRmEnableInterface(pConEntry->Interface.Index);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: AlgRmEnableInterface=%d",
            Error
            );
        return Error;
    }

    //
    // Add the interface the the H.323 proxy, if this has not yet
    // happened.
    //

    if (!NAT_INTERFACE_ADDED_H323(&pConEntry->Interface)) {
        Error =
            H323RmAddInterface(
                NULL,
                pConEntry->Interface.Index,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NatpBindConnection: H323RmAddInterface=%d",
                Error
                );
            return Error;
        }

        pConEntry->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_H323;
    }

    //
    // Bind and enable the interface for H323
    //

    Error = H323RmBindInterface(pConEntry->Interface.Index, BindingInfo);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: H323RmBindInterface=%d",
            Error
            );
        return Error;
    }

    Error = H323RmEnableInterface(pConEntry->Interface.Index);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: H323RmEnableInterface=%d",
            Error
            );
        return Error;
    }

    if (pConEntry->HNetProperties.fIcsPublic) {

        //
        // Finally, update the DNS domain name cached for the shared connection.
        //

        NatpUpdateSharedConnectionDomainName(AdapterIndex);
    }

    return NO_ERROR;
} // NatpBindConnection


HRESULT
NatpBuildPortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO pBindingInfo
    )

/*++

Routine Description:

    Builds the list of port mappings for a connection entry

Arguments:

    pConEntry - the entry to build the list for

    pBindingInfo - the binding info for that entry

Return Value:

    Standard HRESULT.

Environment:

    NatInterfaceLock must be held by the caller.
    
--*/

{
    HRESULT hr;
    IHNetPortMappingBinding *pBinding;
    PNAT_PORT_MAPPING_ENTRY pEntry;
    IEnumHNetPortMappingBindings *pEnum;
    PLIST_ENTRY pLink;
    IHNetPortMappingProtocol *pProtocol;
    ULONG ulCount;
    
    PROFILE("NatpBuildPortMappingList");

    hr = pConEntry->pHNetConnection->EnumPortMappings(TRUE, &pEnum);

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBuildPortMappingList: EnumPortMappings 0x%08x",
            hr
            );

        return hr;
    }

    //
    // Process enumeration, creating the port mapping entries.
    //

    do
    {
        hr = pEnum->Next(1, &pBinding, &ulCount);

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            pEntry =
                reinterpret_cast<PNAT_PORT_MAPPING_ENTRY>(
                    NH_ALLOCATE(sizeof(*pEntry))
                    );

            if (NULL != pEntry)
            {
                ZeroMemory(pEntry, sizeof(*pEntry));
                
                //
                // Get the protocol for the binding
                //

                hr = pBinding->GetProtocol(&pProtocol);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                //
                // Fill out the entry
                //

                hr = pProtocol->GetGuid(&pEntry->pProtocolGuid);

                if (SUCCEEDED(hr))
                {
                    hr = pProtocol->GetIPProtocol(&pEntry->ucProtocol);
                }

                if (SUCCEEDED(hr))
                {
                    hr = pProtocol->GetPort(&pEntry->usPublicPort);
                }

                if (SUCCEEDED(hr))
                {
                    hr = pBinding->GetTargetPort(&pEntry->usPrivatePort);
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // We need to know if the name is active in order to
                    // avoid rebuilding the DHCP reservation list more
                    // than necessary.
                    //
                    
                    hr = pBinding->GetCurrentMethod(&pEntry->fNameActive);
                }

                if (SUCCEEDED(hr))
                {

                    hr = NatpGetTargetAddressForPortMappingEntry(
                             pConEntry->HNetProperties.fIcsPublic,
                             pEntry->fNameActive,
                             pBindingInfo->Address[0].Address,
                             pBinding,
                             &pEntry->ulPrivateAddress 
                             );
                }

                if (SUCCEEDED(hr))
                {
                    pEntry->pBinding = pBinding;
                    pEntry->pBinding->AddRef();
                    pEntry->pProtocol = pProtocol;
                    pEntry->pProtocol->AddRef();

                        //
                        // Check to see if this mapping is:
                        // 1) targeted at the broadcast address, and
                        // 2) is UDP.
                        //

                    if (NAT_PROTOCOL_UDP == pEntry->ucProtocol
                        && 0xffffffff == pEntry->ulPrivateAddress)
                    {
                        pEntry->fUdpBroadcastMapping = TRUE;
                        pConEntry->UdpBroadcastPortMappingCount += 1;
                    }
                    else
                    {
                        pConEntry->PortMappingCount += 1;
                    }

                    InsertTailList(&pConEntry->PortMappingList, &pEntry->Link);
                }
                else
                {
                    NatFreePortMappingEntry(pEntry);
                }

                pProtocol->Release();
            }

            //
            // If anything failed above we still want to continue operation --
            // it's preferable to have the firewall running w/ some port
            // mapping entries missing instead of not having the firewall
            // run at all.
            //

            hr = S_OK;

            pBinding->Release();
        }
    } while (SUCCEEDED(hr) && 1 == ulCount);

    pEnum->Release();

    if (FAILED(hr))
    {
        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);
    }

    return hr;
}// NatpBuildPortMappingList


VOID NTAPI
NatpConfigurationChangedCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon a change in the NAT/Firewall
    configuration.
    It may also be invoked when cleanup is in progress.

Arguments:

    Context - unused

    TimedOut - unused

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    BOOLEAN ComInitialized = TRUE;
    HRESULT hr;
    PROFILE("NatpConfigurationChangedCallbackRoutine");

    //
    // See whether cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConfigurationChangedEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference to the component (and release
    // our original reference on failure).
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }

    //
    // Make sure the thread is COM-initialized
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (FAILED(hr))
    {
        ComInitialized = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            ASSERT(FALSE);
            hr = S_OK;

            NhTrace(
                TRACE_FLAG_NAT,
                "NatpConfigurationChangedCallbackRoutine: Unexpectedly in STA."
                );
        }
    }

    //
    // Process connection notifications
    //

    if (SUCCEEDED(hr))
    {
        NatpProcessConfigurationChanged();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

    //
    // Release our original reference to the component.
    //
    
    DEREFERENCE_NAT();

} // NatpConfigurationChangedCallbackRoutine



VOID NTAPI
NatpConnectionNotifyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon connection or disconnection
    of a RAS phonebook entry.
    It may also be invoked when cleanup is in progress.

Arguments:

    Context - unused

    TimedOut - unused

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    BOOLEAN ComInitialized = TRUE;
    HRESULT hr;
    PROFILE("NatpConnectionNotifyCallbackRoutine");

    //
    // See whether cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference to the component (and release
    // our original reference on failure).
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }

    //
    // Make sure the thread is COM-initialized
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (FAILED(hr))
    {
        ComInitialized = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            ASSERT(FALSE);
            hr = S_OK;

            NhTrace(
                TRACE_FLAG_NAT,
                "NatpConnectionNotifyCallbackRoutine: Unexpectedly in STA."
                );
        }
    }

    //
    // Process connection notifications
    //

    if (SUCCEEDED(hr))
    {
        NatpProcessConnectionNotify();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

    //
    // Release our original reference to the component.
    //
    
    DEREFERENCE_NAT();

} // NatpConnectionNotifyCallbackRoutine


VOID NTAPI
NatpEnableRouterCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon completion or cancellation of an outstanding
    request to enable IP forwarding. It determines whether the module is still
    running and, if so, re-enables forwarding. Otherwise, it cancels any
    existing request and returns control immediately.

Arguments:

    none used.

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    ULONG Error;
    HANDLE UnusedHandle;
    PROFILE("NatpEnableRouterCallbackRoutine");

    //
    // See whether cleanup has occurred and, if so, restore forwarding
    // to its original setting. Otherwise, acquire a new reference to the
    // component, and release the original reference.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatpEnableRouterEvent || !REFERENCE_NAT()) {
        UnenableRouter(&NatpEnableRouterOverlapped, NULL);
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }

    DEREFERENCE_NAT();

    //
    // Re-enable forwarding
    //

    ZeroMemory(&NatpEnableRouterOverlapped, sizeof(OVERLAPPED));
    NatpEnableRouterOverlapped.hEvent = NatpEnableRouterEvent;
    Error = EnableRouter(&UnusedHandle, &NatpEnableRouterOverlapped);
    if (Error != ERROR_IO_PENDING) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpEnableRouterCallbackRoutine: EnableRouter=%d", Error
            );
    }
    LeaveCriticalSection(&NatInterfaceLock);
} // NatpEnableRouterCallbackRoutine


VOID
NatpFreeConnectionEntry(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    Frees all resources associated with a connection entry. This entry
    must have already been removed from the connection list.

Arguments:

    pConEntry - the entry to free

Return Value:

    none.

--*/

{
    PROFILE("NatpFreeConnectionEntry");

    if (NULL != pConEntry->pInterfaceInfo)
    {
        NH_FREE(pConEntry->pInterfaceInfo);
    }

    if (NULL != pConEntry->pBindingInfo)
    {
        NH_FREE(pConEntry->pBindingInfo);
    }

    if (NULL != pConEntry->pHNetConnection)
    {
        pConEntry->pHNetConnection->Release();
    }

    if (NULL != pConEntry->pHNetFwConnection)
    {
        pConEntry->pHNetFwConnection->Release();
    }

    if (NULL != pConEntry->pHNetIcsPublicConnection)
    {
        pConEntry->pHNetIcsPublicConnection->Release();
    }

    if (NULL != pConEntry->wszPhonebookPath)
    {
        CoTaskMemFree(pConEntry->wszPhonebookPath);
    }

    NatpFreePortMappingList(pConEntry);

    NH_FREE(pConEntry);

} // NatpFreeConnectionEntry


VOID
NatpFreePortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    Frees the port mapping list for a connection entry. This
    includes cancelling any active UDP broadcast mappings.

Arguments:

    pConEntry - the entry to free

Return Value:

    none.

Environment:

    Invoked w/ NatInterfaceLock held by the caller

--*/

{
    PLIST_ENTRY pLink;
    PNAT_PORT_MAPPING_ENTRY pMapping;
    
    while (!IsListEmpty(&pConEntry->PortMappingList))
    {   
        pLink = RemoveHeadList(&pConEntry->PortMappingList);
        pMapping = CONTAINING_RECORD(pLink, NAT_PORT_MAPPING_ENTRY, Link);

        if (pMapping->fUdpBroadcastMapping &&
            NULL != pMapping->pvBroadcastCookie)
        {
            ASSERT(NULL != NhpUdpBroadcastMapper);
            NhpUdpBroadcastMapper->CancelUdpBroadcastMapping(
                pMapping->pvBroadcastCookie
                );
        }
        
        NatFreePortMappingEntry(pMapping);
    }

    pConEntry->PortMappingCount = 0;
    pConEntry->UdpBroadcastPortMappingCount = 0;
} // NatpFreePortMappingList


HRESULT
NatpGetTargetAddressForPortMappingEntry(
    BOOLEAN fPublic,
    BOOLEAN fNameActive,
    ULONG BindingAddress,
    IHNetPortMappingBinding *pBinding,
    OUT ULONG *pPrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to get the binding address for the port mapping.
    If this is a FW only connection, we return the address from the binding
    info and not the protocol binding. If its a public connection, and the
    target address is a client machine, we return its address. We check to
    see if we can find the clients' current address, if so, we choose it
    instead of the address currently in our store - refresh of the WMI store
    is done as needed.
    

Arguments:

    fPublic - if the interface is public or not

    fNameActive - if the mapping is active by name (TRUE) or IP address (FALSE)

    BindingAddress - binding address from BindingInfo

    pBinding - pointer to port mapping binding

    pPrivateAddress - receives relevant binding address

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;

    //
    // If this is a FW-only connection, use the address from
    // our binding info instead of the protocol binding.
    //

    if (!fPublic)
    {
        *pPrivateAddress = BindingAddress;
    }
    else
    {
        hr = pBinding->GetTargetComputerAddress(pPrivateAddress);

        if (SUCCEEDED(hr))
        {
            if (INADDR_LOOPBACK_NO == *pPrivateAddress)
            {
                //
                // If the port mapping targets the loopback address
                // we want to use the address from the binding
                // info instead.
                //
                *pPrivateAddress = BindingAddress;
            }
            else if (fNameActive)
            {
                PWCHAR pszICSDomainSuffix = NULL;
                NTSTATUS status;
                PWSTR pszName = NULL;
                ULONG CurrentAddress = 0;
                ULONG DhcpScopeAddress = 0;
                ULONG DhcpScopeMask = 0;
                IHNetCfgMgr *pCfgMgr = NULL;
                IHNetIcsSettings *pIcsSettings = NULL;

                do
                {
                    //
                    // Get computer name
                    //
                    hr = pBinding->GetTargetComputerName(
                            &pszName
                            );
                    
                    if (FAILED(hr))
                    {
                        break;
                    }
                
                    //
                    // Get the ICS Domain Suffix (if any)
                    //
                    status = NhQueryICSDomainSuffix(
                                &pszICSDomainSuffix
                                );

                    if (!NT_SUCCESS(status))
                    {
                        //
                        // error in creating the suffix string
                        //
                        break;
                    }

                    hr = NhGetHNetCfgMgr(&pCfgMgr);

                    if (FAILED(hr))
                    {
                        break;
                    }
                    
                    //
                    // Get the ICS settings interface
                    //
                    hr = pCfgMgr->QueryInterface(
                            IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings)
                            );

                    if (FAILED(hr))
                    {
                        break;
                    }

                    //
                    // Get DHCP scope information
                    //
                    hr = pIcsSettings->GetDhcpScopeSettings(
                            &DhcpScopeAddress,
                            &DhcpScopeMask
                            );
                            
                    if (FAILED(hr))
                    {
                        break;
                    }

                    CurrentAddress = NhQueryHostByName(
                                        pszName,
                                        pszICSDomainSuffix,
                                        (DhcpScopeAddress & DhcpScopeMask),
                                        DhcpScopeMask
                                        );

                    //
                    // keep the current address if the following match
                    // (1) its non-zero
                    // (2) it doesnt match what has already been reserved
                    //
                    if (CurrentAddress && (CurrentAddress != *pPrivateAddress))
                    {
                        hr = pIcsSettings->RefreshTargetComputerAddress(
                                pszName,
                                CurrentAddress
                                );

                        if (SUCCEEDED(hr))
                        {
                            NhTrace(
                                TRACE_FLAG_NAT,
                                "NatpGetTargetAddressForPortMappingEntry: "
                                "old address (0x%08x) "
                                "new address (0x%08x) for %S",
                                *pPrivateAddress,
                                CurrentAddress,
                                pszName
                                );

                            *pPrivateAddress = CurrentAddress;
                        }
                    }

                } while (FALSE);

                if (pszName)
                {
                    CoTaskMemFree(pszName);
                }

                if (NULL != pszICSDomainSuffix)
                {
                    NH_FREE(pszICSDomainSuffix);
                }

                if (NULL != pIcsSettings)
                {
                    pIcsSettings->Release();
                }

                if (NULL != pCfgMgr)
                {
                    pCfgMgr->Release();
                }
            }
        }
    }

    return hr;
}


VOID
NatpProcessConfigurationChanged(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to see when the NAT/Firewall configuration
    changes. It unbinds the old interfaces, and binds the new ones.
    It is also responsible for making sure that the autodial service
    is running.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr = NULL;
    IHNetFirewallSettings *pFwSettings;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetFirewalledConnections *pFwEnum;
    IHNetFirewalledConnection *pFwConn;
    IEnumHNetIcsPublicConnections *pIcsEnum;
    IHNetIcsPublicConnection *pIcsConn;
    ULONG ulCount;
    UNICODE_STRING UnicodeString;

    PROFILE("NatpProcessConfigurationChanged");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Start by deleting all of our current connections
    //

    while (!IsListEmpty(&NatpConnectionList))
    {
        Link = RemoveHeadList(&NatpConnectionList);
        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

        NatpUnbindConnection(pConEntry);
        NatpFreeConnectionEntry(pConEntry);
    }

    //
    // Reset other items to initial state
    //

    NatpFirewallConnectionCount = 0;
    NatpSharedConnectionPresent = FALSE;
    if (NULL != NatpSharedConnectionDomainName)
    {
        NH_FREE(NatpSharedConnectionDomainName);
        NatpSharedConnectionDomainName = NULL;
    }

    //
    // Get the configuration manager
    //

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (NhPolicyAllowsFirewall)
    {
        if (SUCCEEDED(hr))
        {
            //
            // Get the firewall settings interface
            //

            hr = pCfgMgr->QueryInterface(
                    IID_PPV_ARG(IHNetFirewallSettings, &pFwSettings)
                    );
        }

        if (SUCCEEDED(hr))
        {
            //
            // Get the enumeration of firewalled connections
            //

            hr = pFwSettings->EnumFirewalledConnections(&pFwEnum);
            pFwSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            // Process the enumeration
            //

            do
            {
                hr = pFwEnum->Next(1, &pFwConn, &ulCount);

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    //
                    // We don't check the return code for NatpAddConnectionEntry.
                    // NatpAddConnectionEntry will clean up gracefully if an
                    // error occurs and will leave the system in a consistent
                    // state, so an error will not prevent us from processing
                    // the rest of the connections.
                    //
                    
                    NatpAddConnectionEntry(pFwConn);
                    pFwConn->Release();
                }
            }
            while (SUCCEEDED(hr) && 1 == ulCount);

            pFwEnum->Release();
        }
    }

    //
    // If we don't yet have a shared connection (i.e., none of the
    // firewalled connections were also IcsPublic), retrieve that
    // enumeration now.
    //

    if (FALSE == NatpSharedConnectionPresent
        && NULL != pCfgMgr
        && NhPolicyAllowsSharing)
    {
        //
        // Get the IcsSettings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings)
                );

        if (SUCCEEDED(hr))
        {
            //
            // Get the enumeration of ICS public connections
            //

            hr = pIcsSettings->EnumIcsPublicConnections(&pIcsEnum);
            pIcsSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            // See if we can get a connection out of the enum
            //

            hr = pIcsEnum->Next(1, &pIcsConn, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // We don't check the return code for NatpAddConnectionEntry.
                // NatpAddConnectionEntry will clean up gracefully if an
                // error occurs and will leave the system in a consistent
                // state, so an error will not prevent us from processing
                // the rest of the connections.
                //
                
                NatpAddConnectionEntry(pIcsConn);
                pIcsConn->Release();
            }

            pIcsEnum->Release();
        }
    }

    if (TRUE == NatpSharedConnectionPresent && NhPolicyAllowsSharing)
    {
        //
        // Make sure shared connection management is started
        //

        NatpStartSharedConnectionManagement();
    }
    else
    {
        //
        // Stop shared connection management
        //

        NatpStopSharedConnectionManagement();
    }

    //
    // Notify the firewall subsystem as to whether it needs to
    // start or stop logging. (These calls are effectively no-ops if
    // the logger is already in the correct state.)
    //

    if (NatpFirewallConnectionCount > 0 && NhPolicyAllowsFirewall)
    {
        FwStartLogging();
    }
    else
    {
        FwStopLogging();
    }

    //
    // Bind connections
    //

    NatpProcessConnectionNotify();

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }

    LeaveCriticalSection(&NatInterfaceLock);

} // NatpProcessConfigurationChanged


VOID
NatpProcessConnectionNotify(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to see if the shared or firewall connections,
    if any, have been connected or disconnected since its last invocation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    BOOLEAN Active;
    ULONG i;
    ULONG AdapterIndex;
    PIP_ADAPTER_BINDING_INFO BindingInfo = NULL;
    ULONG Error;
    HRASCONN Hrasconn;
    GUID Guid;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    BOOLEAN bUPnPEventAlreadyFired = FALSE;

    PROFILE("NatpProcessConnectionNotify");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Walk through the connection list
    //

    for (Link = NatpConnectionList.Flink;
         Link != &NatpConnectionList;
         Link = Link->Flink)
    {

        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

        //
        // If the connection is a LAN connection,
        // it is always active.
        //
        // If the connection is a dialup connection,
        // find out whether the connection is active.
        //


        if (pConEntry->HNetProperties.fLanConnection) {
            Hrasconn = NULL;
            Active = TRUE;

            //
            // The connection is a LAN connection, so we need to detect
            // any changes to its IP address if it is already bound.
            // To do so we retrieve the current binding information
            // and compare it to the active binding information.
            // If the two are different, we unbind the interface and rebind.
            //

            Status =
                RtlStringFromGUID(pConEntry->Guid, &UnicodeString);
            if (NT_SUCCESS(Status)) {
                AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
                RtlFreeUnicodeString(&UnicodeString);
            } else {
                AdapterIndex = (ULONG)-1;
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpProcessConnectionNotify: RtlStringFromGUID failed"
                    );
            }
            if (AdapterIndex == (ULONG)-1) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpProcessConnectionNotify: MapGuidToAdapter failed"
                    );
                Active = FALSE;
            } else {

                BindingInfo = NhQueryBindingInformation(AdapterIndex);
                if (!BindingInfo) {
                    NhTrace(
                        TRACE_FLAG_NAT,
                        "NatpProcessConnectionNotify: QueryBinding failed"
                        );
                    Active = FALSE;
                } else if (0 == BindingInfo->AddressCount) {
                    NhTrace(
                        TRACE_FLAG_NAT,
                        "NatpProcessConnectionNotify: Adapter has no addresses"
                        );
                    Active = FALSE;
                    NH_FREE(BindingInfo);
                    BindingInfo = NULL;
                } else if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {

                    //
                    // The interface is already bound;
                    // compare the retrieved binding to the active binding,
                    // and unbind the connection if they are different.
                    //

                    if (!pConEntry->pBindingInfo ||
                        BindingInfo->AddressCount !=
                        pConEntry->pBindingInfo->AddressCount ||
                        !RtlEqualMemory(
                            &BindingInfo->Address[0],
                            &pConEntry->pBindingInfo->Address[0],
                            sizeof(IP_LOCAL_BINDING)
                            )) {
                        NatpUnbindConnection(pConEntry);

                        if ( pConEntry->HNetProperties.fIcsPublic )
                        {
                           FireNATEvent_PublicIPAddressChanged();
                           bUPnPEventAlreadyFired = TRUE;                       
                        }
                    } else {

                        //
                        // The bindings are the same, and the interface is bound
                        // already, so we won't be needing the newly-retrieved
                        // binding information.
                        //

                        NH_FREE(BindingInfo);
                        BindingInfo = NULL;
                    }
                }
            }
        } else {
            AdapterIndex = (ULONG)-1;
            Hrasconn = NULL;
            
            //
            // Obtain the name of the connection
            //

            HRESULT hr;
            LPWSTR wszEntryName;         

            hr = pConEntry->pHNetConnection->GetName(&wszEntryName);

            if (SUCCEEDED(hr)) {
                Error =
                    RasGetEntryHrasconnW(
                        pConEntry->wszPhonebookPath,
                        wszEntryName,
                        &Hrasconn
                        );
                        
                CoTaskMemFree(wszEntryName);
            }
            
            Active = ((FAILED(hr) || Error || !Hrasconn) ? FALSE : TRUE);

        }

        //
        // Activate or deactivate the shared-connection as needed;
        // when activating a LAN connection, we save the binding information
        // so we can detect address changes later on.
        //

        if (!Active && NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
            NatpUnbindConnection(pConEntry);
            if (pConEntry->HNetProperties.fIcsPublic && 
                (FALSE == bUPnPEventAlreadyFired))
            {
                FireNATEvent_PublicIPAddressChanged();
            }
        } else if (Active && !NAT_INTERFACE_BOUND(&pConEntry->Interface)) {

            //
            // N.B. When a media-sense event occurs and TCP/IP revokes the IP
            // address for a LAN connection, the connection's IP address becomes
            // 0.0.0.0. We treat that as though we don't have an IP address at all,
            // and bypass the binding below. When the IP address is reinstated,
            // we will rebind correctly, since we will then detect the change.
            //

            if (pConEntry->HNetProperties.fLanConnection) {
                if (BindingInfo->AddressCount != 1 ||
                    BindingInfo->Address[0].Address) {
                    NatpBindConnection(pConEntry, Hrasconn, AdapterIndex, BindingInfo);
                }
                if (pConEntry->pBindingInfo) {
                    NH_FREE(pConEntry->pBindingInfo);
                }
                pConEntry->pBindingInfo = BindingInfo;
            } else {
                NatpBindConnection(pConEntry, Hrasconn, AdapterIndex, BindingInfo);
            }
            
            if ( pConEntry->HNetProperties.fIcsPublic &&
                 (FALSE == bUPnPEventAlreadyFired) && 
                 NAT_INTERFACE_BOUND(&pConEntry->Interface))
            {
                FireNATEvent_PublicIPAddressChanged();
            }

        }
    }

    //
    // If we have a shared connection, also need to update the private interface
    //

    if (NatpSharedConnectionPresent && NhPolicyAllowsSharing) {
        NhUpdatePrivateInterface();
    }

    LeaveCriticalSection(&NatInterfaceLock);

} // NatpProcessConnectionNotify


ULONG
NatpQueryConnectionAdapter(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    This routine is invoked to determine the adapter index corresponding
    to a connection, if active.

Arguments:

    pConEntry - the connection entry

Return Value:

    ULONG - the adapter index if found, otherwise (ULONG)-1.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG Error;
    HRASCONN Hrasconn = NULL;
    RASPPPIPA RasPppIp;
    ULONG Size;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;

    if (pConEntry->HNetProperties.fLanConnection) {
        Status = RtlStringFromGUID(pConEntry->Guid, &UnicodeString);
        if (NT_SUCCESS(Status)) {
            AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
            RtlFreeUnicodeString(&UnicodeString);
        }
    } else {
        HRESULT hr;
        LPWSTR wszEntryName;

        hr = pConEntry->pHNetConnection->GetName(&wszEntryName);

        if (SUCCEEDED(hr))
        {
            Error =
                RasGetEntryHrasconnW(
                    pConEntry->wszPhonebookPath,
                    wszEntryName,
                    &Hrasconn
                    );
            if (!Error && Hrasconn) {
                ZeroMemory(&RasPppIp, sizeof(RasPppIp));
                Size = RasPppIp.dwSize = sizeof(RasPppIp);
                Error =
                    RasGetProjectionInfoA(
                        Hrasconn,
                        RASP_PppIp,
                        &RasPppIp,
                        &Size
                        );
                if (!Error) {
                    AdapterIndex =
                        NhMapAddressToAdapter(inet_addr(RasPppIp.szIpAddress));
                }
            }

            CoTaskMemFree(wszEntryName);
        }
    }
    NhTrace(TRACE_FLAG_NAT, "NatpQueryConnectionAdapter: %d", AdapterIndex);
    return AdapterIndex;
} // NatpQueryConnectionAdapter


PIP_NAT_INTERFACE_INFO
NatpQueryConnectionInformation(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to construct the configuration
    of a connection. The configuration consists of basic settings
    (e.g. interface type and flags) as well as extended information loaded
    from the configuration store (e.g. port mappings).

Arguments:

    pConEntry - the connection entry

    BindingInfo - the binding info for the connection

Return Value:

    PIP_NAT_INTERFACE_INFO - the configuration allocated;
        on error, returns NULL

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PIP_NAT_PORT_MAPPING Array = NULL;
    ULONG Count = 0;
    ULONG Error;
    PIP_NAT_INTERFACE_INFO Info;
    PRTR_INFO_BLOCK_HEADER Header;
    HRESULT hr;
    ULONG Length;
    PLIST_ENTRY Link;
    PRTR_INFO_BLOCK_HEADER NewHeader;
    PNAT_PORT_MAPPING_ENTRY PortMapping;

    PROFILE("NatpQueryConnectionInformation");

    //
    // Build the port mapping array from the list
    //

    if (pConEntry->PortMappingCount)
    {
        Array =
            reinterpret_cast<PIP_NAT_PORT_MAPPING>(
                NH_ALLOCATE(pConEntry->PortMappingCount * sizeof(IP_NAT_PORT_MAPPING))
                );

        if (NULL == Array)
        {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpQueryConnectionInformation: Unable to allocate array"
                );
            return NULL;
        }

        for (Link = pConEntry->PortMappingList.Flink;
             Link != &pConEntry->PortMappingList;
             Link = Link->Flink)
        {
            PortMapping = CONTAINING_RECORD(Link, NAT_PORT_MAPPING_ENTRY, Link);

            if (PortMapping->fUdpBroadcastMapping) { continue; }

            Array[Count].PublicAddress = IP_NAT_ADDRESS_UNSPECIFIED;
            Array[Count].Protocol = PortMapping->ucProtocol;
            Array[Count].PublicPort = PortMapping->usPublicPort;
            Array[Count].PrivateAddress = PortMapping->ulPrivateAddress;
            Array[Count].PrivatePort = PortMapping->usPrivatePort;

            Count += 1;
        }

        ASSERT(Count == pConEntry->PortMappingCount);     
    }

    //
    // Create an info-block header and add the port-mapping array
    // as the single entry in the info-block.
    // This info-block header will occupy the 'Header' field
    // of the final 'IP_NAT_INTERFACE_INFO'.
    //

    Error = MprInfoCreate(IP_NAT_VERSION, reinterpret_cast<LPVOID*>(&Header));
    if (Error) {
        if (Array) {
            NH_FREE(Array);
        }
        return NULL;
    }

    if (Count) {
        Error =
            MprInfoBlockAdd(
                Header,
                IP_NAT_PORT_MAPPING_TYPE,
                sizeof(IP_NAT_PORT_MAPPING),
                Count,
                (PUCHAR)Array,
                reinterpret_cast<LPVOID*>(&NewHeader)
                );
        MprInfoDelete(Header); NH_FREE(Array); Header = NewHeader;
        if (Error) {
            return NULL;
        }
    } else if (Array) {
        NH_FREE(Array);
    }

    //
    // For firewalled entries, get ICMP settings
    //

    if (pConEntry->HNetProperties.fFirewalled && NhPolicyAllowsFirewall)
    {
        HNET_FW_ICMP_SETTINGS *pIcmpSettings;
        DWORD dwIcmpFlags = 0;

        hr = pConEntry->pHNetConnection->GetIcmpSettings(&pIcmpSettings);

        if (SUCCEEDED(hr))
        {
            if (pIcmpSettings->fAllowOutboundDestinationUnreachable)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_DEST_UNREACH;
            }

            if (pIcmpSettings->fAllowOutboundSourceQuench)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_SOURCE_QUENCH;
            }

            if (pIcmpSettings->fAllowRedirect)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_REDIRECT;
            }

            if (pIcmpSettings->fAllowInboundEchoRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_ECHO;
            }

            if (pIcmpSettings->fAllowInboundRouterRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_ROUTER;
            }

            if (pIcmpSettings->fAllowOutboundTimeExceeded)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_TIME_EXCEEDED;
            }

            if (pIcmpSettings->fAllowOutboundParameterProblem)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_PARAM_PROBLEM;
            }

            if (pIcmpSettings->fAllowInboundTimestampRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_TIMESTAMP;
            }

            if (pIcmpSettings->fAllowInboundMaskRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_MASK;
            }

            CoTaskMemFree(pIcmpSettings);

            Error =
                MprInfoBlockAdd(
                    Header,
                    IP_NAT_ICMP_CONFIG_TYPE,
                    sizeof(DWORD),
                    1,
                    (PUCHAR)&dwIcmpFlags,
                    reinterpret_cast<LPVOID*>(&NewHeader)
                    );

            if (NO_ERROR == Error)
            {
                MprInfoDelete(Header);
                Header = NewHeader;
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpQueryConnectionInformation: GetIcmpSettings 0x%08x",
                hr
                );

            //
            // This is a 'soft' error -- we'll still continue even if we
            // couldn't get the ICMP settings, as our default stance
            // is more secure than if any of the flags were set.
            //
        }
    }

    //
    // Allocate an 'IP_NAT_INTERFACE_INFO' which is large enough to hold
    // the info-block header which we've just constructed.
    //

    Length = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) + Header->Size;
    Info = reinterpret_cast<PIP_NAT_INTERFACE_INFO>(NH_ALLOCATE(Length));

    if (Info)
    {
        RtlZeroMemory(Info, FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header));

        //
        // Set appropriate flags
        //

        if (pConEntry->HNetProperties.fFirewalled && NhPolicyAllowsFirewall)
        {
            Info->Flags |= IP_NAT_INTERFACE_FLAGS_FW;
        }

        if (pConEntry->HNetProperties.fIcsPublic && NhPolicyAllowsSharing)
        {
            Info->Flags |=
                IP_NAT_INTERFACE_FLAGS_BOUNDARY | IP_NAT_INTERFACE_FLAGS_NAPT;
        }

        //
        // Copy the info-block header into the info structure
        //

        RtlCopyMemory(&Info->Header, Header, Header->Size);
    }

    MprInfoDelete(Header);

    return Info;
} // NatpQuerySharedConnectionInformation


VOID NTAPI
NatpRoutingFailureCallbackRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )

/*++

Routine Description:

    This routine is invoked when a routing-failure notification occurs,
    or when the request is cancelled (e.g. because the request's thread exited).

Arguments:

    Context - unused

    IoStatus - contains the status of the operation

    Reserved - unused

Return Value:

    none.

Environment:

    Invoked with a reference made to the component on our behalf.
    That reference is released here, and if notification is re-requested,
    it is re-acquired.

--*/

{
    CHAR DestinationAddress[32];
    ULONG Error;
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;

    PROFILE("NatpRoutingFailureCallbackRoutine");

    //
    // See if cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference, and release the old one
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }
    DEREFERENCE_NAT();

    lstrcpyA(
        DestinationAddress,
        inet_ntoa(*(PIN_ADDR)&NatpRoutingFailureNotification.DestinationAddress)
        );
    NhTrace(
        TRACE_FLAG_NAT,
        "NatpRoutingFailureCallbackRoutine: %s->%s",
        inet_ntoa(*(PIN_ADDR)&NatpRoutingFailureNotification.SourceAddress),
        DestinationAddress
        );

    //
    // Request an automatic connection if the notification succeeded
    //

    if (NT_SUCCESS(IoStatus->Status)) {

        //
        // First see if this is a known autodial destination,
        // requesting a connection if so.
        //

        ULONG Count;
        ULONG Size;

        Size = 0;
        Error =
            RasGetAutodialAddressA(
                DestinationAddress,
                NULL,
                NULL,
                &Size,
                &Count
                );
        if (Error != ERROR_BUFFER_TOO_SMALL) {

            //
            // This is not a known destination;
            // try the default shared connection, if any
            //

            NhDialSharedConnection();
        } else {

            //
            // Try initiating a normal autodial connection;
            // normal autodial may yet lead to the shared-connection.
            //

            HINSTANCE Hinstance = LoadLibraryA("RASADHLP.DLL");
            if (Hinstance) {
                BOOL (*WSAttemptAutodialAddr)(PSOCKADDR_IN, INT) =
                    (BOOL (*)(PSOCKADDR_IN, INT))
                        GetProcAddress(
                            Hinstance,
                            "WSAttemptAutodialAddr"
                            );
                if (WSAttemptAutodialAddr) {
                    SOCKADDR_IN SockAddr;
                    SockAddr.sin_family = AF_INET;
                    SockAddr.sin_addr.s_addr =
                        NatpRoutingFailureNotification.DestinationAddress;
                    WSAttemptAutodialAddr(&SockAddr, sizeof(SockAddr));
                }
                FreeLibrary(Hinstance);
            }
        }
    }

    //
    // Submit a new request
    //

    EnterCriticalSection(&NatInterfaceLock);
    RequestNotification.Code = NatRoutingFailureNotification;
    NtDeviceIoControlFile(
        NatFileHandle,
        NULL,
        NatpRoutingFailureCallbackRoutine,
        NULL,
        &NatpRoutingFailureIoStatus,
        IOCTL_IP_NAT_REQUEST_NOTIFICATION,
        (PVOID)&RequestNotification,
        sizeof(RequestNotification),
        &NatpRoutingFailureNotification,
        sizeof(NatpRoutingFailureNotification)
        );
    LeaveCriticalSection(&NatInterfaceLock);

} // NatpRoutingFailureCallbackRoutine


VOID NTAPI
NatpRoutingFailureWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine initiates the notification of routing-failures.

Arguments:

    none used.

Return Value:

    none.

Environment:

    Invoked in the context of an alertable I/O worker thread.

--*/

{
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;
    PROFILE("NatpRoutingFailureWorkerRoutine");

    //
    // Request notification of routing-failures
    //

    EnterCriticalSection(&NatInterfaceLock);
    RequestNotification.Code = NatRoutingFailureNotification;
    NtDeviceIoControlFile(
        NatFileHandle,
        NULL,
        NatpRoutingFailureCallbackRoutine,
        NULL,
        &NatpRoutingFailureIoStatus,
        IOCTL_IP_NAT_REQUEST_NOTIFICATION,
        (PVOID)&RequestNotification,
        sizeof(RequestNotification),
        &NatpRoutingFailureNotification,
        sizeof(NatpRoutingFailureNotification)
        );
    LeaveCriticalSection(&NatInterfaceLock);
} // NatpRoutingFailureWorkerRoutine


ULONG
NatpStartSharedConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to install routing failure-notification, and
    to enable the router

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    BOOL SharedAutoDial;
    NTSTATUS status;

    PROFILE("NatpStartSharedConnectionManagement");

    //
    // See if the user has enabled shared-autodial.
    // If so, make sure the autodial service is running,
    // since it will be needed for performing on-demand dialing.
    //
    // (IHNetIcsSettings::GetAutodialEnabled just calls the RAS api below,
    // which is why we're not getting the information that way right now...)
    //

    if (!RasQuerySharedAutoDial(&SharedAutoDial) && SharedAutoDial) {
        SC_HANDLE ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (ScmHandle) {
            SC_HANDLE ServiceHandle =
                OpenService(ScmHandle, TEXT("RasAuto"), SERVICE_ALL_ACCESS);
            if (ServiceHandle) {
                StartService(ServiceHandle, 0, NULL);
                CloseServiceHandle(ServiceHandle);
            }
            CloseServiceHandle(ScmHandle);
        }
    }

    EnterCriticalSection(&NatInterfaceLock);
    if (NatpEnableRouterEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;
    }

    //
    // Acquire a component-reference on behalf of
    // (1) the enable-router callback routine
    // (2) the routing-failure-notification worker routine.
    //

    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        return ERROR_CAN_NOT_COMPLETE;
    } else if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return ERROR_CAN_NOT_COMPLETE;
    }

    do {
        //
        // Start DNS and DHCP modules
        //
        Error = NhStartICSProtocols();
        if (Error) break;

        //
        // Enable IP forwarding:
        // Create an event to be used in the overlapped I/O structure
        // that will be passed to the 'EnableRouter' API routine,
        // set up the overlapped structure, and schedule the request
        // by signalling the event.
        //

        NatpEnableRouterEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatpEnableRouterEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpEnableRouterWaitHandle,
                NatpEnableRouterEvent,
                NatpEnableRouterCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        SetEvent(NatpEnableRouterEvent);

        //
        // Queue a work item in whose context we will make a request
        // for routing-failure notification from the NAT driver.
        // We use a work-item rather than issuing the request directly
        // to avoid having our I/O request cancelled if and when the current
        // (thread pool) thread exits.
        //

        RtlQueueWorkItem(
            NatpRoutingFailureWorkerRoutine,
            NULL,
            WT_EXECUTEINIOTHREAD
            );

        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;

    } while (FALSE);

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }
    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
    }

    LeaveCriticalSection(&NatInterfaceLock);
    DEREFERENCE_NAT();
    DEREFERENCE_NAT();

    return Error;

} // NatpStartSharedConnectionManagement


ULONG
NatpStopSharedConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop the DNS & DHCP modules and also
    to remove the routing failure-notification, and
    to disable the router

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;

    PROFILE("NatpStopSharedConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Stop the DHCP, DNS, QoSWindowAdjustment and Beacon modules
    //
    Error = NhStopICSProtocols();

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }

    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
        NatpEnableRouterCallbackRoutine(NULL, FALSE);
    }

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatpStopSharedConnectionManagement


BOOLEAN
NatpUnbindConnection(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    This routine is invoked to unbind a currently-active connection.

Arguments:

    Index - index into the connection array

Return Value:

    TRUE if the entry was previously bound; FALSE otherwise.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    LIST_ENTRY *pLink;
    PNAT_PORT_MAPPING_ENTRY pMapping;
    
    PROFILE("NatpUnbindConnection");

    if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
        NatUnbindInterface(
            pConEntry->Interface.Index,
            &pConEntry->Interface
            );

        if (NAT_INTERFACE_ADDED_ALG(&pConEntry->Interface)) {
            AlgRmDeleteInterface(pConEntry->Interface.Index);
            pConEntry->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_ALG;
        }

        if (NAT_INTERFACE_ADDED_H323(&pConEntry->Interface)) {
            H323RmDeleteInterface(pConEntry->Interface.Index);
            pConEntry->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_H323;
        }

        RemoveEntryList(&pConEntry->Interface.Link);
        InitializeListHead(&pConEntry->Interface.Link);

        if (pConEntry->Interface.Info) {
            NH_FREE(pConEntry->Interface.Info);
            pConEntry->Interface.Info = NULL;
        }

        //
        // Clean up the port mapping list
        //

        NatpFreePortMappingList(pConEntry);

        return TRUE;
    }
    return FALSE;
} // NatpUnbindConnection


VOID
NatpUpdateSharedConnectionDomainName(
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is called to update the cached DNS domain name, if any,
    for the shared connection.

Arguments:

    AdapterIndex - the index of the adapter for the shared connection

Return Value:

    none.

--*/

{
    PDNS_ADAPTER_INFOA AdapterInformation;
    ANSI_STRING AnsiString;
    ULONG Count;
    ULONG Error;
    ULONG i;
    PDNS_NETWORK_INFOA NetworkInformation = NULL;
    NTSTATUS Status;
    PIP_INTERFACE_NAME_INFO Table = NULL;
    UNICODE_STRING UnicodeString;
    PROFILE("NatpUpdateSharedConnectionDomainName");

    RtlInitAnsiString(&AnsiString, NULL);
    RtlInitUnicodeString(&UnicodeString, NULL);
    EnterCriticalSection(&NatInterfaceLock);
    if (AdapterIndex == (ULONG)-1)
    {
        PLIST_ENTRY Link;
        PNAT_CONNECTION_ENTRY pConEntry;

        //
        // Make sure that the connection list has been initialized; if
        // it hasn't, Flink will be NULL.
        //

        if (!NatpConnectionList.Flink) {
            LeaveCriticalSection(&NatInterfaceLock);
            return;
        }

        //
        // See if we actually have a shared connection
        //

        for (Link = NatpConnectionList.Flink;
             Link != &NatpConnectionList;
             Link = Link->Flink)
        {
            pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

            if (pConEntry->HNetProperties.fIcsPublic)
            {
                AdapterIndex = NatpQueryConnectionAdapter(pConEntry);
                break;
            }
        }

        if (AdapterIndex == (ULONG)-1) {
            LeaveCriticalSection(&NatInterfaceLock);
            return;
        }
    }

    do {

        //
        // Obtain the GUID for the adapter with the given index,
        // by querying TCP/IP for information on all available interfaces.
        // The GUID will then be used to map the shared connection's adapter
        // to a DNS domain name.
        //

        Error =
            NhpAllocateAndGetInterfaceInfoFromStack(
                &Table, &Count, FALSE, GetProcessHeap(), 0
                );
        if (Error != NO_ERROR) { break; }

        for (i = 0; i < Count && Table[i].Index != AdapterIndex; i++) { }
        if (i >= Count) { Error = ERROR_INTERNAL_ERROR; break; }

        Status = RtlStringFromGUID(Table[i].DeviceGuid, &UnicodeString);
        if (!NT_SUCCESS(Status)) { break; }
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
        if (!NT_SUCCESS(Status)) { break; }

        //
        // Query the DNS client for the current network parameters,
        // and search through the network parameters to find the entry
        // for the shared-connection's current adapter.
        //

        NetworkInformation = (PDNS_NETWORK_INFOA)
                             DnsQueryConfigAlloc(
                                    DnsConfigNetworkInfoA,
                                    NULL );
        if (!NetworkInformation) { Error = ERROR_INTERNAL_ERROR; break; }
        for (i = 0; i < NetworkInformation->AdapterCount; i++) {
            AdapterInformation = &NetworkInformation->AdapterArray[i];
            if (lstrcmpiA(
                    AnsiString.Buffer,
                    AdapterInformation->pszAdapterGuidName
                    ) == 0) {
                break;
            }
        }
        if (i >= NetworkInformation->AdapterCount) {
            Error = ERROR_INTERNAL_ERROR;
            break;
        }

        //
        // 'AdapterInformation' is the entry for the shared-connection's
        // current adapter.
        // Clear the previously-cached string, and read in the new value,
        // if any.
        //

        if (NatpSharedConnectionDomainName) {
            NH_FREE(NatpSharedConnectionDomainName);
            NatpSharedConnectionDomainName = NULL;
        }
        if (AdapterInformation->pszAdapterDomain) {
            NatpSharedConnectionDomainName =
                reinterpret_cast<PCHAR>(
                    NH_ALLOCATE(lstrlenA(AdapterInformation->pszAdapterDomain) + 1)
                    );
            if (!NatpSharedConnectionDomainName) {
                Error = ERROR_INTERNAL_ERROR;
                break;
            }
            lstrcpyA(
                NatpSharedConnectionDomainName,
                AdapterInformation->pszAdapterDomain
                );
        }
        Error = NO_ERROR;

    } while(FALSE);

    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }
    if (AnsiString.Buffer) {
        RtlFreeAnsiString(&AnsiString);
    }
    if (NetworkInformation) {
        DnsFreeConfigStructure(
            NetworkInformation,
            //  DnsConfigNetworkInformation );
            DnsConfigNetworkInfoA ); //  <---  jwesth: this seems to be the correct freetype
    }
    if (Table) {
        HeapFree(GetProcessHeap(), 0, Table);
    }
    if (Error) {
        if (NatpSharedConnectionDomainName) {
            NH_FREE(NatpSharedConnectionDomainName);
            NatpSharedConnectionDomainName = NULL;
        }
    }

    LeaveCriticalSection(&NatInterfaceLock);
} // NatpUpdateSharedConnectionDomainName


PCHAR
NatQuerySharedConnectionDomainName(
    VOID
    )

/*++

Routine Description:

    This routine is called to retrieve a copy of the DNS domain name
    cached for the shared connection, if available. Otherwise, it returns
    the primary DNS domain name for the local machine.

Arguments:

    none.

Return Value:

    PCHAR - contains the allocated copy of the DNS domain name.

--*/

{
    PCHAR DomainName;
    PROFILE("NatQuerySharedConnectionDomainName");

    //
    // See if there is a cached domain name for the shared connection.
    // If not, refresh the cache. If there is still no domain name,
    // return a copy of the local machine's primary DNS domain name.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatpSharedConnectionDomainName) {
        NatpUpdateSharedConnectionDomainName((ULONG)-1);
    }
    if (NatpSharedConnectionDomainName) {
        DomainName =
            reinterpret_cast<PCHAR>(
                NH_ALLOCATE(lstrlenA(NatpSharedConnectionDomainName) + 1)
                );
        if (DomainName) {
            lstrcpyA(DomainName, NatpSharedConnectionDomainName);
        }
    } else {
        PCHAR DnsDomainName = (PCHAR) DnsQueryConfigAlloc(
                                        DnsConfigPrimaryDomainName_A,
                                        NULL );
        if (!DnsDomainName) {
            DomainName = NULL;
        } else {
            DomainName =
                reinterpret_cast<PCHAR>(
                    NH_ALLOCATE(lstrlenA(DnsDomainName) + 1)
                    );
            if (DomainName) {
                lstrcpyA(DomainName, DnsDomainName);
            }
            DnsFreeConfigStructure(
                DnsDomainName,
                DnsConfigPrimaryDomainName_A );
        }
    }
    LeaveCriticalSection(&NatInterfaceLock);
    return DomainName;
} // NatQuerySharedConnectionDomainName


ULONG
NatStartConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to install connection change-notification.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    NTSTATUS status;

    PROFILE("NatStartConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);
    if (NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;
    }

    //
    // Initialize the connection list
    //

    InitializeListHead(&NatpConnectionList);

    //
    // Acquire a component-reference on behalf of
    // (1) the connection-notification routine
    // (2) the configuration-changed routine
    //

    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        return ERROR_CAN_NOT_COMPLETE;
    }
    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return ERROR_CAN_NOT_COMPLETE;
    }

    do {
        //
        // Create the connection-notification event, register a wait
        // on the event, and register for connect and disconnect notification.
        // We expect at least one invocation as a result of this registration,
        // hence the reference made to the NAT module above.
        //

        NatConnectionNotifyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatConnectionNotifyEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpConnectionNotifyWaitHandle,
                NatConnectionNotifyEvent,
                NatpConnectionNotifyCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        Error =
            RasConnectionNotification(
                (HRASCONN)INVALID_HANDLE_VALUE,
                NatConnectionNotifyEvent,
                RASCN_Connection|RASCN_Disconnection
                );
        if (Error) { break; }

        //
        // Create the configuartion-change event and register a wait
        // on the event.
        //

        NatConfigurationChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatConfigurationChangedEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpConfigurationChangedWaitHandle,
                NatConfigurationChangedEvent,
                NatpConfigurationChangedCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        LeaveCriticalSection(&NatInterfaceLock);

        //
        // Pick up any existing connections, by signalling the configuration
        // change event. We cannot invoke the function directly
        // because it invokes service-control functions to start autodial,
        // and we could currently be running in a service-controller thread.
        //

        NtSetEvent(NatConfigurationChangedEvent, NULL);
        return NO_ERROR;

    } while(FALSE);

    //
    // A failure occurred; perform cleanup
    //

    if (NatpConnectionNotifyWaitHandle) {
        RtlDeregisterWait(NatpConnectionNotifyWaitHandle);
        NatpConnectionNotifyWaitHandle = NULL;
    }
    if (NatConnectionNotifyEvent) {
        CloseHandle(NatConnectionNotifyEvent);
        NatConnectionNotifyEvent = NULL;
    }
    if (NatpConfigurationChangedWaitHandle) {
        RtlDeregisterWait(NatpConfigurationChangedWaitHandle);
        NatpConfigurationChangedWaitHandle = NULL;
    }
    if (NatConfigurationChangedEvent) {
        CloseHandle(NatConfigurationChangedEvent);
        NatConfigurationChangedEvent = NULL;
    }


    LeaveCriticalSection(&NatInterfaceLock);
    DEREFERENCE_NAT();
    DEREFERENCE_NAT();

    return Error;

} // NatStartConnectionManagement


VOID
NatStopConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the connection-monitoring activity
    initiated by 'NatStartConnectionManagement' above.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked when 'StopProtocol' is received from the IP router-manager.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    PROFILE("NatStopConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Cleanup the wait-handle and event used to receive notification
    // of RAS connections and disconnections.
    //

    if (NatpConnectionNotifyWaitHandle) {
        RtlDeregisterWait(NatpConnectionNotifyWaitHandle);
        NatpConnectionNotifyWaitHandle = NULL;
    }

    if (NatConnectionNotifyEvent) {
        RasConnectionNotification(
            (HRASCONN)INVALID_HANDLE_VALUE,
            NatConnectionNotifyEvent,
            0
            );
        CloseHandle(NatConnectionNotifyEvent);
        NatConnectionNotifyEvent = NULL;
        NatpConnectionNotifyCallbackRoutine(NULL, FALSE);
    }

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }

    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
        NatpEnableRouterCallbackRoutine(NULL, FALSE);
    }

    if (NatpConfigurationChangedWaitHandle) {
        RtlDeregisterWait(NatpConfigurationChangedWaitHandle);
        NatpConfigurationChangedWaitHandle = NULL;
    }

    if (NatConfigurationChangedEvent) {
        CloseHandle(NatConfigurationChangedEvent);
        NatConfigurationChangedEvent = NULL;
        NatpConfigurationChangedCallbackRoutine(NULL, FALSE);
    }

    if (NatpConnectionList.Flink)
    {
        //
        // Make certain that all of our connections are disabled
        //

        NatUnbindAllConnections();

        //
        // Walk through the connection list, freeing all of the entries
        //

        while (!IsListEmpty(&NatpConnectionList))
        {
            Link = RemoveHeadList(&NatpConnectionList);
            pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);
            NatpFreeConnectionEntry(pConEntry);
        }

        //
        // Make sure all ICS protocols are stopped
        //

        NhStopICSProtocols();
    }

    //
    // Clean up the DNS domain name cached for the shared connection.
    //

    if (NatpSharedConnectionDomainName) {
        NH_FREE(NatpSharedConnectionDomainName);
        NatpSharedConnectionDomainName = NULL;
    }

    //
    // Reset tracking variables to initial state
    //

    NatpFirewallConnectionCount = 0;
    NatpSharedConnectionPresent = FALSE;

    LeaveCriticalSection(&NatInterfaceLock);

} // NatStopConnectionManagement


BOOLEAN
NatUnbindAllConnections(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to unbind a currently-active connection.

Arguments:

    Index - index into the connection array

Return Value:

    BOOLEAN - TRUE if any interfaces were unbound.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{

    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    BOOLEAN Result = FALSE;
    PROFILE("NatUnbindAllConnections");

    for (Link = NatpConnectionList.Flink;
         Link != &NatpConnectionList;
         Link = Link->Flink)
    {
        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);
        Result |= NatpUnbindConnection(pConEntry);
    }

    return Result;
} // NatpUnbindConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\natarp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natarp.h

Abstract:

    This module contains declarations for the NAT's user-mode proxy-ARP
    entry management. Proxy-ARP entries are installed on dedicated interfaces
    which have address-translation enabled.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATARP_H_
#define _NATHLP_NATARP_H_

struct _NAT_INTERFACE;

VOID
NatUpdateProxyArp(
    struct _NAT_INTERFACE* Interfacep,
    BOOLEAN AddEntries
    );

#endif // _NATHLP_NATARP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\natio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natio.h

Abstract:

    This module contains declarations for the NAT's I/O interface
    to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>


//
// PRIVATE GLOBAL VARIABLES
//

HANDLE NatFileHandle;
LIST_ENTRY NatInterfaceList;

//
// Controls access to 'NatFileHandle' and 'NatInterfaceList'.
//
CRITICAL_SECTION NatInterfaceLock;

//
// FORWARD DECLARATIONS
//

VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
NatExpandWildcardMappings(
    IN  PIP_NAT_INTERFACE_INFO InInfo,
    IN  PIP_ADAPTER_BINDING_INFO BindingInfo,
    OUT PIP_NAT_INTERFACE_INFO *ExpandedInfo
    );


ULONG
NatBindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo,
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is invoked to bind the NAT to an interface.

Arguments:

    Index - the interface to be bound

    Interfacep - optionally supplies the interface-structure to be bound
        (See 'NATCONN.C' which passes in a static interface-structure).

    BindingInfo - the interface's address-information

    AdapterIndex - optionally specifies the interface's TCP/IP adapter index.
        This is set only for home-router interfaces.

Return Value:

    ULONG - Win32 status code.

--*/

{
    PIP_NAT_CREATE_INTERFACE CreateInterface;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;
    HANDLE WaitEvent;

    PIP_NAT_INTERFACE_INFO ExpandedInfo = NULL;
    ULONG ExpandedSize;

    PROFILE("NatBindInterface");

    Error = NO_ERROR;

    //
    // Look up the interface to be bound
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!Interfacep && !(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (NAT_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Allocate the bind-structure
    //

    Size =
        sizeof(IP_NAT_CREATE_INTERFACE) +
        SIZEOF_IP_BINDING(BindingInfo->AddressCount);

    CreateInterface = reinterpret_cast<PIP_NAT_CREATE_INTERFACE>(
                        NH_ALLOCATE(Size));

    if (!CreateInterface) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: allocation failed for interface %d binding",
            Index
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Interfacep->AdapterIndex =
        (AdapterIndex != (ULONG)-1)
            ? AdapterIndex
            : NhMapInterfaceToAdapter(Interfacep->Index);
    if (Interfacep->AdapterIndex == (ULONG)-1) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: NhMapInterfaceToAdapter failed for %d",
            Index
            );
        return ERROR_INVALID_INDEX;
    }
    CreateInterface->Index = Interfacep->AdapterIndex;
    CopyMemory(
        CreateInterface->BindingInfo,
        BindingInfo,
        SIZEOF_IP_BINDING(BindingInfo->AddressCount)
        );

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: CreateEvent failed [%d] for interface %d",
            GetLastError(),
            Index
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Install the interface
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_INTERFACE,
            (PVOID)CreateInterface,
            Size,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    NH_FREE(CreateInterface);

    if (!NT_SUCCESS(status)) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: status %08x binding interface %d",
            status,
            Index
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
        return Error;
    }


    //
    // If a mapping with 
    // public ip address  = 0
    // private ip address = 127.0.0.1
    // exists, expand that mapping to one mapping for each of the ipaddresses 
    // bound to the interface.
    //
    
    Error = NatExpandWildcardMappings(
                Interfacep->Info,
                BindingInfo,
                &ExpandedInfo);

    if ( Error != NO_ERROR ) {

        ULONG AdapterIndex = Interfacep->AdapterIndex;
        LeaveCriticalSection(&NatInterfaceLock);
    
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: Failed to expand wildcard mappings. Error %d",
            Error
        );

        NhErrorLog(
            IP_NAT_LOG_EXPANSION_FAILED,
            Error,
            ""
            );

        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_INTERFACE,
                (PVOID)&AdapterIndex,
                sizeof(ULONG),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
        
        CloseHandle(WaitEvent);
        return Error;
    }

    //
    // Now set its configuration
    //

    ExpandedInfo->Index = Interfacep->AdapterIndex;
    ExpandedSize =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        ExpandedInfo->Header.Size;

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_INTERFACE_INFO,
            (PVOID)ExpandedInfo,
            ExpandedSize,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    //
    // If new Interface Info was allocated, free it
    //
    if ( ExpandedInfo != Interfacep->Info ) {
        NH_FREE(ExpandedInfo);
        ExpandedInfo = NULL;
    }
    
    if (!NT_SUCCESS(status))  {

        ULONG AdapterIndex = Interfacep->AdapterIndex;
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: status %08x setting info for interface %d (%d)",
            status,
            Index,
            AdapterIndex
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_INTERFACE,
                (PVOID)&AdapterIndex,
                sizeof(ULONG),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
        CloseHandle(WaitEvent);
        return Error;
    }

    Interfacep->Flags |= NAT_INTERFACE_FLAG_BOUND;

    if (Interfacep->Type == ROUTER_IF_TYPE_DEDICATED) {
        NatUpdateProxyArp(Interfacep, TRUE);
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatBindInterface


ULONG
NatConfigureDriver(
    PIP_NAT_GLOBAL_INFO GlobalInfo
    )

/*++

Routine Description:

    This routine is called to update the configuration for the NAT driver.

Arguments:

    GlobalInfo - the new configuration for the NAT.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatConfigureDriver");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureDriver: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Attempt to configure the driver
    //

    EnterCriticalSection(&NatInterfaceLock);
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_GLOBAL_INFO,
            (PVOID)GlobalInfo,
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + GlobalInfo->Header.Size,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureDriver: status %08x setting global info",
            status
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    }

    CloseHandle(WaitEvent);

    return Error;

} // NatConfigureDriver


ULONG
NatConfigureInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is invoked to set the configuration for a NAT interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the configuration for the interface

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    PIP_NAT_INTERFACE_INFO Info;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;

    PROFILE("NatConfigureInterface");

    if (!InterfaceInfo) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: no interface info for %d",
            Index
            );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make a copy of the information
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        InterfaceInfo->Header.Size;

    Info = (PIP_NAT_INTERFACE_INFO)NH_ALLOCATE(Size);

    if (!Info) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: error allocating copy of configuration"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(
        Info,
        InterfaceInfo,
        Size
        );

    //
    // Look up the interface to be configured
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: interface %d not found",
            Index
            );
        NH_FREE(Info);
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // See if the configuration changed
    //

    if ((Size ==
            FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
            Interfacep->Info->Header.Size) &&
        memcmp(InterfaceInfo, Interfacep->Info, Size) == 0
        ) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: no change to interface %d configuration",
            Index
            );
        NH_FREE(Info);
        return NO_ERROR;
    }


    //
    // See if the interface is bound;
    // if so we need to update the kernel-mode driver's configuration.
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {
        status = STATUS_SUCCESS;
    } else {
        HANDLE WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (WaitEvent != NULL) {

            DWORD ExpandedSize = 0;
            PIP_ADAPTER_BINDING_INFO BindingInfo;
            PIP_NAT_INTERFACE_INFO ExpandedInfo = NULL;

            //
            // If both, address and port translation are disabled, 
            // and a mapping with 
            // public ip address  = 0
            // private ip address = 127.0.0.1
            // exists, expand that mapping to one mapping for each of 
            // the ipaddresses bound to the interface.
            //
            
            BindingInfo = NhQueryBindingInformation(Interfacep->AdapterIndex);
            if ( BindingInfo == NULL ) {

                LeaveCriticalSection(&NatInterfaceLock);

                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatConfigureInterface: Failed to Query Binding "
                    "Information. Error %d",
                    Error
                    );

                NhErrorLog(
                    IP_NAT_LOG_EXPANSION_FAILED,
                    Error,
                    ""
                    );

                NH_FREE(Info);
                
                return Error;

            }
            
            Error = NatExpandWildcardMappings(
                        Info,
                        BindingInfo,
                        &ExpandedInfo
                        );
            if ( Error != NO_ERROR ) {

                LeaveCriticalSection(&NatInterfaceLock);

                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatConfigureInterface: Failed to expand wildcard "
                    "mappings. Error %d",
                    Error
                    );

                NhErrorLog(
                    IP_NAT_LOG_EXPANSION_FAILED,
                    Error,
                    ""
                    );

                NH_FREE(Info);
                NH_FREE(BindingInfo);
                
                return Error;
            }

            NH_FREE(BindingInfo);
            BindingInfo = NULL;

            ExpandedInfo->Index = Info->Index = Interfacep->AdapterIndex;
            ExpandedSize = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
                                ExpandedInfo->Header.Size;

            //
            // Attempt to configure the interface
            //

            status =
                NtDeviceIoControlFile(
                    NatFileHandle,
                    WaitEvent,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_IP_NAT_SET_INTERFACE_INFO,
                    (PVOID)ExpandedInfo,
                    ExpandedSize,
                    NULL,
                    0
                    );
            if (status == STATUS_PENDING) {
                WaitForSingleObject(WaitEvent, INFINITE);
                status = IoStatus.Status;
            }

            CloseHandle(WaitEvent);

            //
            // If new Interface Info was allocated during the call to 
            // NatExpandWildcardMappings, free it
            //
            if ( ExpandedInfo != Info ) {
                NH_FREE(ExpandedInfo);
                ExpandedInfo = NULL;
            }


        } else {
            status = STATUS_UNSUCCESSFUL;
            NhTrace(
                TRACE_FLAG_NAT,
                "NatConfigureInterface: CreateEvent failed [%d]",
                GetLastError()
                );
        }

    }

    
    if (!NT_SUCCESS(status)) {
        NH_FREE(Info);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: status %08x setting interface info",
            status
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    } else {
        Error = NO_ERROR;

        //
        // Update proxy ARP entries for LAN interfaces
        //

        if (NAT_INTERFACE_BOUND(Interfacep) &&
            Interfacep->Type == ROUTER_IF_TYPE_DEDICATED
            ) {
            NatUpdateProxyArp(Interfacep, FALSE);
        }

        if (Interfacep->Info) { NH_FREE(Interfacep->Info); }
        Interfacep->Info = Info;

        if (NAT_INTERFACE_BOUND(Interfacep) &&
            Interfacep->Type == ROUTER_IF_TYPE_DEDICATED
            ) {
            NatUpdateProxyArp(Interfacep, TRUE);
        }
    }

    LeaveCriticalSection(&NatInterfaceLock);

    if (NT_SUCCESS(status)) {
        if (InterfaceInfo->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY) {
            NhSignalNatInterface(
                Index,
                TRUE
                );
        } else {
            NhSignalNatInterface(
                Index,
                FALSE
                );
        }
    }

    return Error;

} // NatConfigureInterface


ULONG
NatCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is invoked to create an interface with the NAT driver.

Arguments:

    Index - the index of the new interface

    InterfaceInfo - the configuration for the new interface

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_NAT_INTERFACE_INFO Info;
    PLIST_ENTRY InsertionPoint;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;
    ROUTER_INTERFACE_TYPE IfType;

    PROFILE("NatCreateInterface");

    if (!InterfaceInfo) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: no interface info for %d",
            Index
            );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check for the interface in our table
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (NatpLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: interface %d already exists",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep =
        reinterpret_cast<PNAT_INTERFACE>(NH_ALLOCATE(sizeof(NAT_INTERFACE)));

    if (!Interfacep) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NAT_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Make a copy of the information
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        InterfaceInfo->Header.Size;

    Info = (PIP_NAT_INTERFACE_INFO)NH_ALLOCATE(Size);

    if (!Info) {
        LeaveCriticalSection(&NatInterfaceLock);
        NH_FREE(Interfacep);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: error allocating copy of configuration"
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(
        Info,
        InterfaceInfo,
        Size
        );

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    Interfacep->Index = Index;
    Interfacep->AdapterIndex = (ULONG)-1;
    Interfacep->Type = IfType =
        ((Type == PERMANENT)
            ? ROUTER_IF_TYPE_DEDICATED
            : ROUTER_IF_TYPE_FULL_ROUTER);
    Interfacep->Info = Info;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&NatInterfaceLock);

    if (InterfaceInfo->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY) {
        NhSignalNatInterface(
            Index,
            TRUE
            );
    } else {
        NhSignalNatInterface(
            Index,
            FALSE
            );
    }

    return NO_ERROR;

} // NatCreateInterface


ULONG
NatCreateTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to add a ticket (static port mapping)
    to an interface.

Arguments:

    InterfaceIndex - the interface to which to add the ticket

    Protocol, PublicPort, PublicAddress, PrivatePort, PrivateAddress -
        describes the ticket to be created

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET CreateTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatCreateTicket");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateTicket: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CreateTicket.InterfaceIndex = InterfaceIndex;
    CreateTicket.PortMapping.Protocol = Protocol;
    CreateTicket.PortMapping.PublicPort = PublicPort;
    CreateTicket.PortMapping.PublicAddress = PublicAddress;
    CreateTicket.PortMapping.PrivatePort = PrivatePort;
    CreateTicket.PortMapping.PrivateAddress = PrivateAddress;

    EnterCriticalSection(&NatInterfaceLock);

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_TICKET,
            (PVOID)&CreateTicket,
            sizeof(CreateTicket),
            NULL,
            0
            );

    LeaveCriticalSection(&NatInterfaceLock);
    
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Error = NO_ERROR;
    } else {
        Error = RtlNtStatusToDosError(status);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateTicket: Ioctl = %d",
            Error
            );
    }
    
    CloseHandle(WaitEvent);
    
    return Error;
} // NatCreateTicket


ULONG
NatDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to remove an interface from the NAT.

Arguments:

    Index - the interface to be removed

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatDeleteInterface");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Retrieve the interface to be deleted.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    Error = NO_ERROR;
    if (NAT_INTERFACE_BOUND(Interfacep)) {

        //
        // Delete the interface from the kernel-mode driver
        //

        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_INTERFACE,
                (PVOID)&Interfacep->AdapterIndex,
                sizeof(ULONG),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {
            Error = NO_ERROR;
        } else {
            Error = RtlNtStatusToDosError(status);
            NhErrorLog(
                IP_NAT_LOG_IOCTL_FAILED,
                Error,
                ""
                );
        }
    }
    CloseHandle(WaitEvent);

    //
    // Remove the interface from our list
    //

    RemoveEntryList(&Interfacep->Link);
    if (Interfacep->Info) {
        NH_FREE(Interfacep->Info);
    }
    NH_FREE(Interfacep);

    LeaveCriticalSection(&NatInterfaceLock);

    NhSignalNatInterface(
        Index,
        FALSE
        );

    return Error;

} // NatDeleteInterface


ULONG
NatDeleteTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to remove a ticket (static port mapping)
    from an interface.

Arguments:

    InterfaceIndex - the interface from which to remove the ticket

    Protocol, PublicPort, PublicAddress, PrivatePort, PrivateAddress -
        describes the ticket to be deleted

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET DeleteTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatDeleteTicket");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteTicket: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DeleteTicket.InterfaceIndex = InterfaceIndex;
    DeleteTicket.PortMapping.Protocol = Protocol;
    DeleteTicket.PortMapping.PublicPort = PublicPort;
    DeleteTicket.PortMapping.PublicAddress = PublicAddress;
    DeleteTicket.PortMapping.PrivatePort = PrivatePort;
    DeleteTicket.PortMapping.PrivateAddress = PrivateAddress;

    EnterCriticalSection(&NatInterfaceLock);

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_DELETE_TICKET,
            (PVOID)&DeleteTicket,
            sizeof(DeleteTicket),
            NULL,
            0
            );

    LeaveCriticalSection(&NatInterfaceLock);
    
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Error = NO_ERROR;
    } else {
        Error = RtlNtStatusToDosError(status);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteTicket: Ioctl = %d",
            Error
            );
    }
    
    CloseHandle(WaitEvent);
    
    return Error;
} // NatDeleteTicket



ULONG
NatGetInterfaceCharacteristics(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given interface:
    1) Is a NAT boundary interface
    2) Is a NAT private interface
    3) Has the firewall enabled

    Note that this routine may be invoked even when the NAT
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized in 'DllMain'.

Arguments:

    Index - the interface in question

    IsNatInterface - optionally set to TRUE if the given index
        is at all a NAT interface.

Return Value:

    BOOLEAN - TRUE if the interface is a NAT boundary interface,
        FALSE otherwise.

--*/

{
    ULONG Result = 0;
    PNAT_INTERFACE Interfacep;
    PROFILE("NatGetInterfaceCharacteristics");

    EnterCriticalSection(&NatInterfaceLock);
    
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        return Result;
    }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_FW)) {
        Result = NAT_IF_CHAR_FW;
    }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY)) {
        
        Result |= NAT_IF_CHAR_BOUNDARY;
    } else if (!NAT_IFC_FW(Result)) {

        //
        // As the interface isn't public and isn't firewalled, it must
        // be a private interface (or we wouldn't have a record of it).
        //
        
        Result |= NAT_IF_CHAR_PRIVATE;
    }

    LeaveCriticalSection(&NatInterfaceLock);
    
    return Result;
} // NatGetInterfaceCharacteristics


VOID
NatInstallApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to update the application settings
    (i.e., dynamic tickets) stored with the kernel-mode translation module.

Arguments:

    none

Return Value:

    none.

--*/

{
    PNAT_APP_ENTRY pAppEntry;
    ULONG Count;
    PIP_NAT_CREATE_DYNAMIC_TICKET CreateTicket;
    IO_STATUS_BLOCK IoStatus;
    ULONG Length;
    PLIST_ENTRY Link;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatInstallApplicationSettings");

    //
    // Install a dynamic ticket for each entry in the applications list
    //

    EnterCriticalSection(&NatInterfaceLock);
    EnterCriticalSection(&NhLock);

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NhLock);
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatInstallSharedAccessSettings: CreateEvent failed [%d]",
            GetLastError()
            );
        return;
    }

    for (Link = NhApplicationSettingsList.Flink;
         Link != &NhApplicationSettingsList;
         Link = Link->Flink)
    {

        //
        // Each 'application' has a list of 'responses' which specify
        // the ports on which response-sessions are expected.
        // Enumerate the responses and allocate a ticket-structure
        // large enough to hold the list as an array.
        //

        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);

        Length =
            pAppEntry->ResponseCount * sizeof(CreateTicket->ResponseArray[0]) +
            FIELD_OFFSET(IP_NAT_CREATE_DYNAMIC_TICKET, ResponseArray);

        if (!(CreateTicket =
                reinterpret_cast<PIP_NAT_CREATE_DYNAMIC_TICKET>(
                    NH_ALLOCATE(Length)
                    )))
        { break; }

        //
        // Fill in the ticket structure from the application entry
        // and its list of response-entries.
        //

        CreateTicket->Protocol = pAppEntry->Protocol;
        CreateTicket->Port = pAppEntry->Port;
        CreateTicket->ResponseCount = pAppEntry->ResponseCount;
        
        for (Count = 0; Count < pAppEntry->ResponseCount; Count++)
        {
            CreateTicket->ResponseArray[Count].Protocol =
                pAppEntry->ResponseArray[Count].ucIPProtocol;
            CreateTicket->ResponseArray[Count].StartPort =
                pAppEntry->ResponseArray[Count].usStartPort;
            CreateTicket->ResponseArray[Count].EndPort =
                pAppEntry->ResponseArray[Count].usEndPort;
        }

        //
        // Install the dynamic ticket for this application, and continue.
        //

        status = NtDeviceIoControlFile(
                     NatFileHandle,
                     WaitEvent,
                     NULL,
                     NULL,
                     &IoStatus,
                     IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET,
                     (PVOID)CreateTicket,
                     Length,
                     NULL,
                     0
                     );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
        NH_FREE(CreateTicket);
    }

    LeaveCriticalSection(&NhLock);
    LeaveCriticalSection(&NatInterfaceLock);

    CloseHandle(WaitEvent);
} // NatInstallApplicationSettings


BOOLEAN
NatIsBoundaryInterface(
    ULONG Index,
    PBOOLEAN IsNatInterface OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given interface
    has the NAT enabled and is marked as a boundary interface.
    Note that this routine may be invoked even when the NAT
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized in 'DllMain'.

Arguments:

    Index - the interface in question

    IsNatInterface - optionally set to TRUE if the given index
        is at all a NAT interface.

Return Value:

    BOOLEAN - TRUE if the interface is a NAT boundary interface,
        FALSE otherwise.

--*/

{
    PNAT_INTERFACE Interfacep;
    PROFILE("NatIsBoundaryInterface");

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        if (IsNatInterface) { *IsNatInterface = FALSE; }
        return FALSE;
    }

    if (IsNatInterface) { *IsNatInterface = TRUE; }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY)) {
        LeaveCriticalSection(&NatInterfaceLock);
        return TRUE;
    }
    LeaveCriticalSection(&NatInterfaceLock);
    return FALSE;

} // NatIsBoundaryInterface


PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PNAT_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'NatInterfaceLock'
    held by caller.

--*/

{
    PNAT_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("NatpLookupInterface");

    for (Link = NatInterfaceList.Flink; Link != &NatInterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // NatpLookupInterface


ULONG
NatQueryInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the information for a NAT interface.

Arguments:

    Index - the interface whose information is to be queried

    InterfaceInfo - receives the information

    InterfaceInfoSize - receives the information size

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PNAT_INTERFACE Interfacep;
    ULONG Size;

    PROFILE("NatQueryInterface");

    //
    // Look up the interface to be queried
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Compute the required size
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        Interfacep->Info->Header.Size;

    if (Size >= *InterfaceInfoSize) {
        *InterfaceInfoSize = Size;
        Error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *InterfaceInfoSize = Size;
        CopyMemory(
            InterfaceInfo,
            Interfacep->Info,
            Size
            );
        Error = NO_ERROR;
    }

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatQueryInterface


ULONG
NatQueryInterfaceMappingTable(
    ULONG Index,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the session mappings for an interface.

Arguments:

    EnumerateTable - receives the enumerated mappings

    EnumerateTableSize - indicates the size of 'EnumerateTable'

Return Value:

    ULONG - Win32 error code.

--*/

{
    IP_NAT_ENUMERATE_SESSION_MAPPINGS Enumerate;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG RequiredSize;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryInterfaceMappingTable");

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterfaceMappingTable: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    if (!NAT_INTERFACE_BOUND(Interfacep)) {

        //
        // The interface is not bound, so there aren't any mappings.
        // Indicate zero mappings in the caller's request-buffer.
        //

        LeaveCriticalSection(&NatInterfaceLock);

        RequiredSize =
            FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]);

        if (*EnumerateTableSize < RequiredSize) {
            *EnumerateTableSize = RequiredSize;
            return ERROR_INSUFFICIENT_BUFFER;
        }

        EnumerateTable->Index = Index;
        EnumerateTable->EnumerateContext[0] = 0;
        EnumerateTable->EnumerateCount = 0;
        *EnumerateTableSize = RequiredSize;

        return NO_ERROR;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterfaceMappingTable: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Determine the amount of space required
    //

    Enumerate.Index = Interfacep->AdapterIndex;
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)&Enumerate,
            sizeof(Enumerate)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        *EnumerateTableSize = 0;
        return RtlNtStatusToDosError(status);
    }

    RequiredSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        Enumerate.EnumerateTotalHint * sizeof(IP_NAT_SESSION_MAPPING);

    //
    // If the caller doesn't have enough space for all these mappings, fail
    //

    if (*EnumerateTableSize < RequiredSize) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        *EnumerateTableSize = RequiredSize + 5 * sizeof(IP_NAT_SESSION_MAPPING);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Attempt to read the mappings
    //

    Enumerate.Index = Interfacep->AdapterIndex;
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)EnumerateTable,
            *EnumerateTableSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    CloseHandle(WaitEvent);
    LeaveCriticalSection(&NatInterfaceLock);

    EnumerateTable->Index = Index;
    *EnumerateTableSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        EnumerateTable->EnumerateCount * sizeof(IP_NAT_SESSION_MAPPING);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryInterfaceMappingTable


ULONG
NatQueryMappingTable(
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the session mappings for an interface.

Arguments:

    EnumerateTable - receives the enumerated mappings

    EnumerateTableSize - indicates the size of 'EnumerateTable'

Return Value:

    ULONG - Win32 error code.

--*/

{
    IP_NAT_ENUMERATE_SESSION_MAPPINGS Enumerate;
    IO_STATUS_BLOCK IoStatus;
    ULONG RequiredSize;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryMappingTable");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryMappingTable: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Determine the amount of space required
    //
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)&Enumerate,
            sizeof(Enumerate)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        *EnumerateTableSize = 0;
        return RtlNtStatusToDosError(status);
    }

    RequiredSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        Enumerate.EnumerateTotalHint * sizeof(IP_NAT_SESSION_MAPPING);

    //
    // If the caller doesn't have enough space for all these mappings, fail
    //

    if (*EnumerateTableSize < RequiredSize) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        *EnumerateTableSize = RequiredSize + 5 * sizeof(IP_NAT_SESSION_MAPPING);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Attempt to read the mappings
    //

    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)EnumerateTable,
            *EnumerateTableSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    EnumerateTable->Index = (ULONG)-1;
    *EnumerateTableSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        EnumerateTable->EnumerateCount * sizeof(IP_NAT_SESSION_MAPPING);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryMappingTable


ULONG
NatQueryStatisticsInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics,
    PULONG InterfaceStatisticsSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the statistics for a NAT interface.

Arguments:

    Index - the index of the interface whose statistics are to be retrieved

Return Value:

    ULONG - Win32 error code.

--*/

{
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryStatisticsInterface");

    //
    // Look up the interface to be queried
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryStatisticsInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // If the interface is not bound, supply zero statistics.
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {

        LeaveCriticalSection(&NatInterfaceLock);

        if (*InterfaceStatisticsSize < sizeof(IP_NAT_INTERFACE_STATISTICS)) {
            *InterfaceStatisticsSize = sizeof(IP_NAT_INTERFACE_STATISTICS);
            return ERROR_INSUFFICIENT_BUFFER;
        }

        *InterfaceStatisticsSize = sizeof(IP_NAT_INTERFACE_STATISTICS);
        ZeroMemory(InterfaceStatistics, sizeof(IP_NAT_INTERFACE_STATISTICS));

        return NO_ERROR;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryStatisticsInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Attempt to read the statistics for the interface
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_STATISTICS,
            (PVOID)&Interfacep->AdapterIndex,
            sizeof(ULONG),
            (PVOID)InterfaceStatistics,
            *InterfaceStatisticsSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    if (NT_SUCCESS(status) && IoStatus.Information > *InterfaceStatisticsSize) {
        *InterfaceStatisticsSize = (ULONG)IoStatus.Information;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *InterfaceStatisticsSize = (ULONG)IoStatus.Information;

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryStatisticsInterface


VOID
NatRemoveApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to remove the advanced application settings (i.e.,
    dynamic tickets), and supply the settings to the kernel-mode translation
    module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PNAT_APP_ENTRY pAppEntry;
    IP_NAT_DELETE_DYNAMIC_TICKET DeleteTicket;
    IO_STATUS_BLOCK IoStatus;
    PLIST_ENTRY Link;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatRemoveApplicationSettings");

    //
    // Each 'application' entry in the shared access settings
    // corresponds to a dynamic ticket for the kernel-mode translator.
    // We begin by removing the dynamic tickets for the old settings, if any,
    // and then we free the old settings in preparation for reloading.
    //

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatRemoveSharedAccessSettings: CreateEvent failed [%d]",
            GetLastError()
            );
        return;
    }

    EnterCriticalSection(&NatInterfaceLock);
    EnterCriticalSection(&NhLock);
    
    for (Link = NhApplicationSettingsList.Flink;
         Link != &NhApplicationSettingsList;
         Link = Link->Flink)
    {
        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);
        DeleteTicket.Protocol = pAppEntry->Protocol;
        DeleteTicket.Port = pAppEntry->Port;
        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET,
                (PVOID)&DeleteTicket,
                sizeof(DeleteTicket),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    }
        
    LeaveCriticalSection(&NhLock);
    LeaveCriticalSection(&NatInterfaceLock);

    CloseHandle(WaitEvent);
} // NatRemoveSharedAccessSettings


ULONG
NatUnbindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked to remove a binding from the NAT.

Arguments:

    Index - the interface to be unbound

    Interfacep - optionally supplies the interface-structure to be unbound
        (See 'NATCONN.C' which passes in a static interface-structure).

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatUnbindInterface");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Retrieve the interface to be unbound.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!Interfacep && !(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    Interfacep->Flags &= ~NAT_INTERFACE_FLAG_BOUND;

    if (Interfacep->Type == ROUTER_IF_TYPE_DEDICATED) {
        NatUpdateProxyArp(Interfacep, FALSE);
    }

    //
    // Remove the interface from the kernel-mode driver
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_DELETE_INTERFACE,
            (PVOID)&Interfacep->AdapterIndex,
            sizeof(ULONG),
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    LeaveCriticalSection(&NatInterfaceLock);
    CloseHandle(WaitEvent);

    Error = NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

    if (Error) {
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    }

    return Error;

} // NatUnbindInterface


ULONG
NatLookupPortMappingAdapter(
    ULONG AdapterIndex,
    UCHAR Protocol,
    ULONG PublicAddress,
    USHORT PublicPort,
    PIP_NAT_PORT_MAPPING PortMappingp
    )

/*++

Routine Description:

    This routine is invoked to find a mapping that matches the given adapter,
    protocol, public address and public port number. The routine tries to
    match both port and address mapping.

Arguments:

    AdapterIndex - the adapter to be looked up
    Protocol - protocol used to match a mapping
    PublicAddress - public address used to match a mapping
    PublicPort - public port number used to match a mapping
    PortMappingp - pointer to a caller-supplied storage to save the mapping if
        found

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET LookupTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatLookupPortMappingAdapter");

    Error = NO_ERROR;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatLookupPortMappingAdapter:"
            " CreateEvent failed [%d] for adapter %d",
            GetLastError(),
            AdapterIndex
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LookupTicket.InterfaceIndex = AdapterIndex;
    LookupTicket.PortMapping.Protocol = Protocol;
    LookupTicket.PortMapping.PublicPort = PublicPort;
    LookupTicket.PortMapping.PublicAddress = PublicAddress;
    LookupTicket.PortMapping.PrivatePort = 0;
    LookupTicket.PortMapping.PrivateAddress = 0;

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_LOOKUP_TICKET,
            (PVOID)&LookupTicket,
            sizeof(LookupTicket),
            (PVOID)PortMappingp,
            sizeof(*PortMappingp)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatLookupPortMappingAdapter:"
            " status %08x getting info for adapter %d",
            status,
            AdapterIndex
            );
        Error = RtlNtStatusToDosError(status);
    }

    CloseHandle(WaitEvent);

    return Error;
}


ULONG
NatExpandWildcardMappings(
    IN  PIP_NAT_INTERFACE_INFO InInfo,
    IN  PIP_ADAPTER_BINDING_INFO BindingInfo,
    OUT PIP_NAT_INTERFACE_INFO *ExpandedInfo
    )

/*++

Routine Description:

    This routine is invoked to expand any wildcard(address) mappings, into one 
    mapping per ipaddress bound to the interface

    Assumes that information pointed to by InInfo and BindingInfo does not 
    change during the duration of this function
    
Arguments:

    InInfo        - Pointer to the set of mappings to be expanded

    ExpandedInfo  - On successful completion, ExpandedInfo contains a pointer 
                    to the expanded set of mappings.
                    If there were mappings that needed expansion, the function
                    will allocate the memory for this new set of 
                    mappings. 
                    If no expansion is required, ExpandedInfo will point to the 
                    same location as InInfo.
                    
Return Value:

    ULONG - Win32 status code.
            If there are no wildcard mappings, it returns ERROR_EXTENDED_ERROR

            In case of success: NO_ERROR is returned

--*/

{
    ULONG Error;
    ULONG Size;

    DWORD j, k;
    DWORD MappingSize;
    DWORD CountOldMappings, CountNewMappings, CountWildcardMappings;
    DWORD tempCount;

    PIP_NAT_PORT_MAPPING OldMappings = NULL;
    PIP_NAT_PORT_MAPPING NewMappings = NULL;
    PIP_NAT_INTERFACE_INFO NewInterfaceInfo = NULL;
    PRTR_INFO_BLOCK_HEADER NewHeader = NULL;

    Error = NO_ERROR;

    //
    // If a mapping with 
    // public ip address  = 0
    // private ip address = 127.0.0.1
    // exists, expand that mapping to one mapping for each of the ipaddresses 
    // bound to the interface.
    //

    NewInterfaceInfo = InInfo;
    
    do {

        //
        // We don't do any expansion in case of a private interface
        //
        if ( InInfo->Flags == 0 ) {

            break;
        }

        //
        // If no port mappings exist, break out
        //
        Error = MprInfoBlockFind(
                    (LPVOID)&(InInfo->Header),
                    IP_NAT_PORT_MAPPING_TYPE,
                    &MappingSize,
                    &CountOldMappings,
                    (LPBYTE *)&OldMappings);
                    
        if ( Error != NO_ERROR ) {

            if ( Error == ERROR_NOT_FOUND ) {
                Error = NO_ERROR;
            }
            break;
        }
    
        //
        // Count how many mappings need to be expanded
        //
        CountWildcardMappings = 0;
        for ( j = 0; j < CountOldMappings; j++ ) {

            if ( IS_WILDCARD_MAPPING(&(OldMappings[j])) ) {

                CountWildcardMappings++;
            }
        }

        //
        // If there are no wildcard mappings
        // return ERROR_EXTENDED_ERROR
        //
        if ( CountWildcardMappings == 0 ) {

            break;
        }
       
        //
        // allocate memory to hold the new set of mappings
        // Number of new mappings will be 
        //
        // ( (OldMappings - WildcardMappings) +
        //   (WildcardMappings * "no of bound ipaddresses") )
        //
        CountNewMappings = 
            (CountOldMappings + 
                (CountWildcardMappings * (BindingInfo->AddressCount-1)));

        Size = CountNewMappings * MappingSize;

        NewMappings = (PIP_NAT_PORT_MAPPING)NH_ALLOCATE(Size);
        if ( NewMappings == NULL ) {

            NhTrace(
                TRACE_FLAG_NAT,
                "Failed to allocate buffer for expanded mappings. Size: %d",
                Size
            );

            NhErrorLog(
                IP_NAT_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
            );

            //
            // If we can't get the buffer, forget about expanding the mappings
            // and go on with life.
            //
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        tempCount = 0;
        for ( j = 0; j < CountOldMappings; j++ ) {

            if (IS_WILDCARD_MAPPING(&(OldMappings[j]))) {

                for ( k = 0; k < BindingInfo->AddressCount; k++ ) {

                    CopyMemory(&(NewMappings[tempCount]), &(OldMappings[j]), 
                        sizeof(IP_NAT_PORT_MAPPING));

                    NewMappings[tempCount].PublicAddress  = 
                    NewMappings[tempCount].PrivateAddress = BindingInfo->Address[k].Address;

                    tempCount++;
                }
            }
            else {
                CopyMemory(&(NewMappings[tempCount]), &(OldMappings[j]), 
                        sizeof(IP_NAT_PORT_MAPPING));

                tempCount++;
            }

        }

        if ( tempCount != CountNewMappings ) {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatExpandWildcardMappings: Unexpected number of expanded "
                "mappings: %d. Expected: %d",
                tempCount,
                CountNewMappings
                );

            Error = ERROR_INVALID_DATA;
            break;
        }
        
#if DBG
        {
            char publicAddress[128];
            char privateAddress[128];

            NhTrace(
                TRACE_FLAG_NAT,
                "NatExpandWildcardMappings: Expanded set of "
                "mappings. Total: %d\r\n",
                CountNewMappings
                );
                
            for ( j = 0; j < CountNewMappings; j++ ) {

                _snprintf(
                    publicAddress, 
                    127, 
                    INET_NTOA(NewMappings[j].PublicAddress)
                    );
                    
                _snprintf(
                    privateAddress, 
                    127, 
                    INET_NTOA(NewMappings[j].PrivateAddress)
                    );

                NhTrace(
                    TRACE_FLAG_NAT,
                    "\tProto: %u, PubPort: %hu, PubAdd: %s, "
                    "PrivPort: %hu, PrivAdd: %s\r\n",
                    NewMappings[j].Protocol & 0xFF,
                    ntohs(NewMappings[j].PublicPort),
                    publicAddress,
                    ntohs(NewMappings[j].PrivatePort),
                    privateAddress
                    );
            }
        }
#endif

        //
        // Now create the new header
        //
        Error = 
            MprInfoBlockSet(
                &(InInfo->Header),
                IP_NAT_PORT_MAPPING_TYPE,
                sizeof(IP_NAT_PORT_MAPPING),
                CountNewMappings,
                (LPBYTE)NewMappings,
                (LPVOID *)&NewHeader);

        if ( Error != NO_ERROR ) {
        
            NhTrace(
                TRACE_FLAG_NAT,
                "MprInfoBlockSet failed with error: %d",
                Error
            );

            break;
        }

        //
        // Allocate space for a new IP_NAT_INTERFACE_INFO struct. 
        //

        Size = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) + NewHeader->Size;
        NewInterfaceInfo = (PIP_NAT_INTERFACE_INFO)NH_ALLOCATE(Size);
        if ( NewInterfaceInfo == NULL ) {

            NhTrace(
                TRACE_FLAG_NAT,
                "Failed to allocate buffer for new NatInterfaceInfo. Size: %d",
                Size
            );

            NhErrorLog(
                IP_NAT_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
            );

            //
            // If we can't get the buffer, forget about fixing the mappings
            // and go on with life.
            //

            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Copy the old IP_NAT_INFTERFACE_INFO. Leave out the old header
        //
        CopyMemory(
            NewInterfaceInfo,
            InInfo,
            FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header));

        //
        // Now copy the new header    
        //
        CopyMemory(
            ((BYTE *)NewInterfaceInfo + 
                FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header)),
            NewHeader,
            NewHeader->Size);

    } while (FALSE);


    if ( NewMappings ) { NH_FREE(NewMappings); }
    if ( NewHeader )   { NH_FREE(NewHeader); }
    
    if ( Error == NO_ERROR ) {
        *ExpandedInfo = NewInterfaceInfo;
    }
    else {
        if ( NewInterfaceInfo && NewInterfaceInfo != InInfo ) { 
            NH_FREE(NewInterfaceInfo); 
        }
    }
    
    return Error;
    
} // NatExpandWildcardMappings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\rmnat.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmnat.c

Abstract:

    This module contains routines for the NAT module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

COMPONENT_REFERENCE NatComponentReference;
PIP_NAT_GLOBAL_INFO NatGlobalInfo = NULL;
CRITICAL_SECTION NatGlobalInfoLock;
HANDLE NatNotificationEvent;
ULONG NatProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS NatRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_NAT,
    RF_ROUTING,
    NatRmStartProtocol,
    NatRmStartComplete,
    NatRmStopProtocol,
    NatRmGetGlobalInfo,
    NatRmSetGlobalInfo,
    NULL,
    NULL,
    NatRmAddInterface,
    NatRmDeleteInterface,
    NatRmInterfaceStatus,
    NatRmGetInterfaceInfo,
    NatRmSetInterfaceInfo,
    NatRmGetEventMessage,
    NULL,
    NatRmConnectClient,
    NatRmDisconnectClient,
    NULL,
    NULL,
    NatRmMibCreate,
    NatRmMibDelete,
    NatRmMibGet,
    NatRmMibSet,
    NatRmMibGetFirst,
    NatRmMibGetNext,
    NULL,
    NULL
};
SUPPORT_FUNCTIONS NatSupportFunctions;

//
// FORWARD DECLARATIONS
//


VOID
NatCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the NAT module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DeleteCriticalSection(&NatInterfaceLock);
    DeleteCriticalSection(&NatGlobalInfoLock);
    DeleteComponentReference(&NatComponentReference);

} // NatCleanupModule


VOID
NatCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the NAT protocol-component
    after a 'StopProtocol'.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("NatCleanupProtocol");

    //
    // Stop the NAT driver.
    //

    NatUnloadDriver(NULL);
    if (NatGlobalInfo) { NH_FREE(NatGlobalInfo); NatGlobalInfo = NULL; }

    //
    // Notify the router-manager.
    //

    InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 1);
    SetEvent(NatNotificationEvent);

    //
    // Reset the component reference
    //

    ResetComponentReference(&NatComponentReference);

    //
    // Return the component to the uninitialized mode,
    // whatever the original mode might have been.
    //

    NhResetComponentMode();

    //
    // Free up HNetCfgMgr pointers
    //

    if (NULL != NhGITp)
    {
        HRESULT hr;
        BOOLEAN ComInitialized = FALSE;

        //
        // Make sure COM is initialized
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr))
        {
            ComInitialized = TRUE;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Release the CfgMgr from the GIT
            //

            NhGITp->RevokeInterfaceFromGlobal(NhCfgMgrCookie);
            NhCfgMgrCookie = 0;

            //
            // Release the GIT
            //

            NhGITp->Release();
            NhGITp = NULL;
        }

        if (TRUE == ComInitialized)
        {
            CoUninitialize();
        }
    }

    //
    // Remove our reference, if any, to IPRTRMGR.DLL
    //

    EnterCriticalSection(&NhLock);
    if (NhpRtrmgrDll) {
        FreeLibrary(NhpRtrmgrDll);
        NhpRtrmgrDll = NULL;
    }
    LeaveCriticalSection(&NhLock);

    NhStopEventLog();

} // NatCleanupProtocol


BOOLEAN
NatInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the NAT module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    InitializeListHead(&NatInterfaceList);

    if (InitializeComponentReference(
            &NatComponentReference, NatCleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&NatGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&NatComponentReference);
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&NatInterfaceLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DeleteCriticalSection(&NatGlobalInfoLock);
        DeleteComponentReference(&NatComponentReference);
        return FALSE;
    }

    ZeroMemory(&NatSupportFunctions, sizeof(NatSupportFunctions));

    return TRUE;

} // NatInitializeModule


ULONG
APIENTRY
NatRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("NatRmStartProtocol");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER); }

    NhStartEventLog();

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&NatGlobalInfoLock);

        Size = 
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
            ((PIP_NAT_GLOBAL_INFO)GlobalInfo)->Header.Size;
        NatGlobalInfo = reinterpret_cast<PIP_NAT_GLOBAL_INFO>(NH_ALLOCATE(Size));
        if (!NatGlobalInfo) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "NatRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_NAT_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(NatGlobalInfo, GlobalInfo, Size);
        LeaveCriticalSection(&NatGlobalInfoLock);

        //
        // Save the notification event and the support functions
        //

        NatNotificationEvent = NotificationEvent;

        EnterCriticalSection(&NatInterfaceLock);
        if (!SupportFunctions) {
            ZeroMemory(&NatSupportFunctions, sizeof(NatSupportFunctions));
        } else {
            CopyMemory(
                &NatSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }
        LeaveCriticalSection(&NatInterfaceLock);

        //
        // Attempt to load and start the NAT driver.
        //

        Error = NatLoadDriver(
                    &NatFileHandle,
                    reinterpret_cast<PIP_NAT_GLOBAL_INFO>(GlobalInfo)
                    );

        NhUpdateApplicationSettings();
        NatInstallApplicationSettings();

        InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 0);

    } while (FALSE);

    if (NO_ERROR != Error) {
        NhStopEventLog();
    }

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmStartProtocol


ULONG
APIENTRY
NatRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // NatRmStartComplete


ULONG
APIENTRY
NatRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PLIST_ENTRY Link;
    PNAT_APP_ENTRY pAppEntry;
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    NatStopConnectionManagement();

    EnterCriticalSection(&NhLock);

    //
    // Free application list
    //

    NhFreeApplicationSettings();
    
    LeaveCriticalSection(&NhLock);

    //
    // Close our handle to the driver, thus cancelling all outstanding I/O.
    //

    EnterCriticalSection(&NatInterfaceLock);
    NtClose(NatFileHandle);
    NatFileHandle = NULL;
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&NatComponentReference);

    return DEREFERENCE_NAT() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // NatRmStopProtocol


ULONG
APIENTRY
NatRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmAddInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatCreateInterface(
            Index,
            Type,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmAddInterface


ULONG
APIENTRY
NatRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmDeleteInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatDeleteInterface(
            Index
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmDeleteInterface


ULONG
APIENTRY
NatRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("NatRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // NatRmGetEventMessage


ULONG
APIENTRY
NatRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmGetInterfaceInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatQueryInterface(
            Index,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmGetInterfaceInfo


ULONG
APIENTRY
NatRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmSetInterfaceInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        NatConfigureInterface(
            Index,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmSetInterfaceInfo


ULONG
APIENTRY
NatRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = NatRmBindInterface(Index, StatusInfo);
            } else {
                Error = NatRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = NatRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = NatRmDisableInterface(Index);
            break;
        }

    }

    return Error;
    
} // NatRmInterfaceStatus


ULONG
NatRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmBindInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatBindInterface(
            Index,
            NULL,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo,
            (ULONG)-1
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmBindInterface


ULONG
NatRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmUnbindInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatUnbindInterface(
            Index,
            NULL
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmUnbindInterface


ULONG
NatRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.
    The NAT ignores the invocation.

Arguments:

    none unused.

Return Value:

    NO_ERROR.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("NatRmEnableInterface");

    return NO_ERROR;

} // NatRmEnableInterface


ULONG
NatRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.
    The NAT ignores the invocation.

Arguments:

    none unused.

Return Value:

    NO_ERROR.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("NatRmDisableInterface");

    return NO_ERROR;

} // NatRmDisableInterface


ULONG
APIENTRY
NatRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("NatRmGetGlobalInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER);
    } else if (!NatGlobalInfo) {
        *GlobalInfoSize = 0;
        DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    }

    EnterCriticalSection(&NatGlobalInfoLock);
    Size =
        FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + NatGlobalInfo->Header.Size;
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&NatGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_NAT_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, NatGlobalInfo, Size);
    LeaveCriticalSection(&NatGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount =1;}

    DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    
} // NatRmGetGlobalInfo


ULONG
APIENTRY
NatRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PIP_NAT_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("NatRmSetGlobalInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size =
        FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
        ((PIP_NAT_GLOBAL_INFO)GlobalInfo)->Header.Size;
    NewInfo = reinterpret_cast<PIP_NAT_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_NAT_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    Error =
        NatConfigureDriver(
            NewInfo
            );

    if (Error) {
        NH_FREE(NewInfo);
    } else {
        EnterCriticalSection(&NatGlobalInfoLock);
        NH_FREE(NatGlobalInfo);
        NatGlobalInfo = NewInfo;
        LeaveCriticalSection(&NatGlobalInfoLock);
    }

    NatRemoveApplicationSettings();
    NhUpdateApplicationSettings();
    NatInstallApplicationSettings();

    DEREFERENCE_NAT_AND_RETURN(Error);
    
} // NatRmSetGlobalInfo


ULONG
APIENTRY
NatRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The NAT exposes two items to the MIB; its per-interface statistics,
    and its per-interface mapping table.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    ULONG Index;
    PIP_NAT_MIB_QUERY Oidp;

    PROFILE("NatRmMibGet");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Oidp = (PIP_NAT_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_NAT_INTERFACE_STATISTICS_OID: {
                if (*OutputDataSize <
                        sizeof(*Oidp) + sizeof(IP_NAT_INTERFACE_STATISTICS)) {
                    *OutputDataSize =
                        sizeof(*Oidp) + sizeof(IP_NAT_INTERFACE_STATISTICS);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Index = Oidp->Index[0];
                    Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_NAT_INTERFACE_STATISTICS_OID;
                    *OutputDataSize -= sizeof(*Oidp);
                    Error =
                        NatQueryStatisticsInterface(
                            Index,
                            (PIP_NAT_INTERFACE_STATISTICS)Oidp->Data,
                            OutputDataSize
                            );
                    *OutputDataSize += sizeof(*Oidp);
                }
                break;
            }
            case IP_NAT_INTERFACE_MAPPING_TABLE_OID: {
                if (OutputData && *OutputDataSize < sizeof(*Oidp)
                    + sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS)) {

                    *OutputDataSize = 0;
                    OutputData = NULL;
                }
                
                PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable = NULL;
                Index =  Oidp->Index[0];
                Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                if (Oidp) {
                    Oidp->Oid = IP_NAT_INTERFACE_MAPPING_TABLE_OID;
                    EnumerateTable =
                        (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)Oidp->Data;
                }
                if (*OutputDataSize) { *OutputDataSize -= sizeof(*Oidp); }
                Error =
                    NatQueryInterfaceMappingTable(
                        Index,
                        EnumerateTable,
                        OutputDataSize
                        );
                *OutputDataSize += sizeof(*Oidp);

                break;
            }
            case IP_NAT_MAPPING_TABLE_OID: {
                if (OutputData && *OutputDataSize < sizeof(*Oidp)
                    + sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS)) {

                    *OutputDataSize = 0;
                    OutputData = NULL;
                }
                
                PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable = NULL;
                Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                if (Oidp) {
                    Oidp->Oid = IP_NAT_MAPPING_TABLE_OID;
                    EnumerateTable =
                        (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)Oidp->Data;
                }
                if (*OutputDataSize) { *OutputDataSize -= sizeof(*Oidp); }
                Error =
                    NatQueryMappingTable(
                        EnumerateTable,
                        OutputDataSize
                        );
                *OutputDataSize += sizeof(*Oidp);
                
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_NAT_AND_RETURN(Error);
}


ULONG
APIENTRY
NatRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
NatRmConnectClient(
    ULONG Index,
    PVOID ClientAddress
    )

/*++

Routine Description:

    This routine is called upon establishment of an incoming connection
    by a RAS client.
    We automatically enable NAT access for incoming clients who connect
    over direct-cable/infra-red connections.

Arguments:

    Index - unused

    ClientAddress - unused

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmConnectClient");
    return NO_ERROR;
}


ULONG
APIENTRY
NatRmDisconnectClient(
    ULONG Index,
    PVOID ClientAddress
    )

/*++

Routine Description:

    This routine is called upon disconnection of a RAS client.
    It cleans up NAT access if it was enabled for the disconnected client.

Arguments:

    Index - unused

    ClientAddress - unused

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmDisconnectClient");
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\svcmain.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    svcmain.h

Abstract:

    This module contains declarations for the module's shared-access mode,
    in which the module runs as a service rather than as a routing component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Sep-1998

Revision History:

--*/

#pragma once

#ifndef _NATHLP_SVCMAIN_H_
#define _NATHLP_SVCMAIN_H_

#include "udpbcast.h"

//
// Pointer to the GlobalInterfaceTable for the process
//

extern IGlobalInterfaceTable *NhGITp;

//
// GIT cookie for the IHNetCfgMgr instance
//

extern DWORD NhCfgMgrCookie;

//
// UDP Broadcast mapper
//

extern IUdpBroadcastMapper *NhpUdpBroadcastMapper;


//
// Policy information
//

extern BOOL NhPolicyAllowsFirewall;
extern BOOL NhPolicyAllowsSharing;

//
// Function prototypes
//

HRESULT
NhGetHNetCfgMgr(
    IHNetCfgMgr **ppCfgMgr
    );

ULONG
NhMapGuidToAdapter(
    PWCHAR Guid
    );

BOOLEAN
NhQueryScopeInformation(
    PULONG Address,
    PULONG Mask
    );
    
ULONG
NhStartICSProtocols(
    VOID
    );

ULONG
NhStopICSProtocols(
    VOID
    );

ULONG
NhUpdatePrivateInterface(
    VOID
    );

VOID
ServiceHandler(
    ULONG ControlCode
    );

VOID
ServiceMain(
    ULONG ArgumentCount,
    PWCHAR ArgumentArray[]
    );

#endif // _NATHLP_SVCMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\natsvc\svcmain.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    svcmain.c

Abstract:

    This module contains code for the module's shared-access mode,
    in which the module runs as a service rather than as a routing component.

Author:

    Abolade Gbadegesin (aboladeg)   31-Aug-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <rasman.h>
#include "beacon.h"

HANDLE NhpAddressChangeEvent = NULL;
OVERLAPPED NhpAddressChangeOverlapped;
HANDLE NhpAddressChangeWaitHandle = NULL;
SERVICE_STATUS NhpServiceStatus;
SERVICE_STATUS_HANDLE NhpServiceStatusHandle = 0;
PIP_ADAPTER_BINDING_INFO NhpSharedPrivateLanBindingInfo = NULL;
GUID NhpSharedPrivateLanGuid;
ULONG NhpSharedPrivateLanIndex = (ULONG)-1;
HANDLE NhpStopDhcpEvent = NULL;
HANDLE NhpStopDnsEvent = NULL;
HANDLE NhpStopAlgEvent = NULL;
HANDLE NhpStopH323Event = NULL;
HANDLE NhpStopNatEvent = NULL;
BOOLEAN NhpRasmanReferenced = FALSE;
BOOLEAN NhpFwLoggingInitialized = FALSE;
BOOL NhPolicyAllowsFirewall = TRUE;
BOOL NhPolicyAllowsSharing = TRUE;
BOOLEAN NoLocalDns = TRUE;  //whether DNS server is running or going to run on local host
BOOLEAN NhpNoLocalDhcp = TRUE; //whether DHCP server is running or goint to run on local host
BOOLEAN NhpQoSEnabled = FALSE;
IUdpBroadcastMapper *NhpUdpBroadcastMapper = NULL;
BOOLEAN NhpClassObjectsRegistered = FALSE;


//
// Pointer to the GlobalInterfaceTable for the process
//

IGlobalInterfaceTable *NhGITp = NULL;

//
// GIT cookie for the IHNetCfgMgr instance
//

DWORD NhCfgMgrCookie = 0;

const TCHAR c_szDnsServiceName[] = TEXT("DNS");
const TCHAR c_szDhcpServiceName[] = TEXT("DHCPServer");

ULONG
NhpEnableQoSWindowSizeAdjustment(
    BOOLEAN fEnable
    );

VOID
NhpStartAddressChangeNotification(
    VOID
    );

VOID
NhpStopAddressChangeNotification(
    VOID
    );

VOID
NhpUpdateConnectionsFolder(
    VOID
    );

BOOL
NhpUpdatePolicySettings(
    VOID
    );


HRESULT
NhGetHNetCfgMgr(
    IHNetCfgMgr **ppCfgMgr
    )

/*++

Routine Description:

    This routine obtains a pointer to the home networking configuration
    manager.

Arguments:

    ppCfgMgr - receives the IHNetCfgMgr pointer. The caller must release
               this pointer.

Return Value:

    standard HRESULT

Environment:

COM must be initialized on the calling thread

--*/

{
    HRESULT hr = S_OK;
    
    if (NULL == NhGITp)
    {
        EnterCriticalSection(&NhLock);

        if (NULL == NhGITp)
        {
            IHNetCfgMgr *pCfgMgr;
            
            //
            // Create the global interface table
            //
            
            hr = CoCreateInstance(
                    CLSID_StdGlobalInterfaceTable,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IGlobalInterfaceTable, &NhGITp)
                    );

            if (SUCCEEDED(hr))
            {
                //
                // Create the homenet configuration manager
                //
                
                hr = CoCreateInstance(
                        CLSID_HNetCfgMgr,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IHNetCfgMgr, &pCfgMgr)
                        );

                if (FAILED(hr))
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NhGetHNetCfgMgr: Unable to create HNetCfgMgr (0x%08x)",
                        hr
                        );
                }
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhGetHNetCfgMgr: Unable to create GIT (0x%08x)",
                    hr
                    );
            }

            if (SUCCEEDED(hr))
            {
                //
                // Store the CfgMgr pointer in the GIT
                //

                hr = NhGITp->RegisterInterfaceInGlobal(
                                pCfgMgr,
                                IID_IHNetCfgMgr,
                                &NhCfgMgrCookie
                                );

                pCfgMgr->Release();

                if (FAILED(hr))
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NhGetHNetCfgMgr: Unable to register HNetCfgMgr (0x%08x)",
                        hr
                        );
                }
            }
        }
        
        LeaveCriticalSection(&NhLock);
    }

    if (SUCCEEDED(hr))
    {
        hr = NhGITp->GetInterfaceFromGlobal(
                NhCfgMgrCookie,
                IID_PPV_ARG(IHNetCfgMgr, ppCfgMgr)
                );
    }

    return hr;
} // NhGetHNetCfgMgr


ULONG
NhMapGuidToAdapter(
    PWCHAR Guid
    )

/*++

Routine Description:

    This routine is invoked to map a GUID to an adapter index.
    It does so by querying 'GetInterfaceInfo' for the array of interfaces,
    which contains the GUID and adapter index for each interface.

Arguments:

    Guid - the GUID to be mapped to an adapter index.

Return Value:

    ULONG - the required adapter index

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG i;
    ULONG GuidLength;
    PIP_INTERFACE_INFO Info;
    PWCHAR Name;
    ULONG NameLength;
    ULONG Size;
    PROFILE("NhMapGuidToAdapter");
    Size = 0;
    GuidLength = lstrlenW(Guid);
    if (GetInterfaceInfo(NULL, &Size) == ERROR_INSUFFICIENT_BUFFER) {
        Info = reinterpret_cast<PIP_INTERFACE_INFO>(
                HeapAlloc(GetProcessHeap(), 0, Size)
                );
        if (Info) {
            if (GetInterfaceInfo(Info, &Size) == NO_ERROR) {
                for (i = 0; i < (ULONG)Info->NumAdapters; i++) {
                    NameLength = lstrlenW(Info->Adapter[i].Name);
                    if (NameLength < GuidLength) { continue; }
                    Name = Info->Adapter[i].Name + (NameLength - GuidLength);
                    if (lstrcmpiW(Guid, Name) == 0) {
                        AdapterIndex = Info->Adapter[i].Index;
                        break;
                    }
                }
            }
            HeapFree(GetProcessHeap(), 0, Info);
        }
    }
    return AdapterIndex;
} // NhMapGuidToAdapter


VOID NTAPI
NhpAddressChangeCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked when a change to a local address is signalled.
    It is responsible for updating the bindings of the private and public
    interfaces, and re-requesting change notification.

Arguments:

    none used.

Return Value:

    none.

--*/

{
    PROFILE("NhpAddressChangeCallbackRoutine");
    NtSetEvent(NatConnectionNotifyEvent, NULL);
    NhpStartAddressChangeNotification();

} // NhpAddressChangeCallbackRoutine


VOID
NhpDeletePrivateInterface(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to remove the private interface
    from each shared-access component.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PROFILE("NhpDeletePrivateInterface");

    if (NhpStopDnsEvent) { DnsRmDeleteInterface(0); }
    if (NhpStopDhcpEvent) { DhcpRmDeleteInterface(0); }
    if (NhpStopAlgEvent) { AlgRmDeleteInterface(0); }
    if (NhpStopH323Event) { H323RmDeleteInterface(0); }
    if (NhpStopNatEvent) { NatRmDeleteInterface(0); }
    RtlZeroMemory(&NhpSharedPrivateLanGuid, sizeof(NhpSharedPrivateLanGuid));
} // NhpDeletePrivateInterface


ULONG
NhpEnableQoSWindowSizeAdjustment(
    BOOLEAN fEnable
    )

/*++

Routine Description:

    Instructs PSCHED to enable or disable window size adjustment.

Arguments:

    fEnable -- TRUE if adjustments are to be enabled; FALSE, to be disabled

Return Value:

    ULONG -- Win32 error

--*/

{
    ULONG ulError = ERROR_SUCCESS;
    DWORD dwValue;
    WMIHANDLE hDataBlock = NULL;
    GUID qosGuid;
    
    PROFILE("NhpEnableQoSWindowSizeAdjustment");

    do
    {
        //
        // WmiOpenBlock doesn't take a const guid, se we need to
        // copy the defind value
        //

        CopyMemory(&qosGuid, &GUID_QOS_ENABLE_WINDOW_ADJUSTMENT, sizeof(GUID));

        
        //
        // Obtain a handle to the data block
        //

        ulError =
            WmiOpenBlock(
                &qosGuid,
                GENERIC_WRITE,
                &hDataBlock
                );

        if (ERROR_SUCCESS != ulError)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableQoSWindowSizeAdjustment: WmiOpenBlock = %u",
                ulError
                );
            break;                
        }

        //
        // Set the value for the data block
        //

        dwValue = (fEnable ? 1 : 0);

        ulError = 
            WmiSetSingleInstanceW(
                hDataBlock,
                L"PSCHED",
                0,
                sizeof(dwValue),
                &dwValue
                );

        if (ERROR_SUCCESS != ulError)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableQoSWindowSizeAdjustment: WmiSetSingleInstanceW = %u",
                ulError
                );
            break;                
        }

    } while (FALSE);

    if (NULL != hDataBlock)
    {
        WmiCloseBlock(hDataBlock);
    }

    return ulError;    
} // NhpEnableQoSWindowSizeAdjustment


VOID
NhpStartAddressChangeNotification(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to request notifications of changes
    to local IP addresses. The notifications are signalled on an event
    which is created in this routine, and are acted on in a callback routine
    which is registered in this routine.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error;
    NTSTATUS status;
    HANDLE TcpipHandle;
    PROFILE("NhpStartAddressChangeNotification");

    //
    // Create an event on which to receive notifications
    // and register a callback routine to be invoked if the event is signalled.
    // Then request notification of address changes on the event.
    //

    do {

        EnterCriticalSection(&NhLock);

        if (!NhpAddressChangeEvent) {
            status =
                NtCreateEvent(
                    &NhpAddressChangeEvent,
                    EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE
                    );
            if (!NT_SUCCESS(status)) { break; }
    
            status =
                RtlRegisterWait(
                    &NhpAddressChangeWaitHandle,
                    NhpAddressChangeEvent,
                    NhpAddressChangeCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
            if (!NT_SUCCESS(status)) { break; }
        }
    
        ZeroMemory(&NhpAddressChangeOverlapped, sizeof(OVERLAPPED));
        NhpAddressChangeOverlapped.hEvent = NhpAddressChangeEvent;

        Error = NotifyAddrChange(&TcpipHandle, &NhpAddressChangeOverlapped);
        if (Error != ERROR_IO_PENDING) { break; }

        LeaveCriticalSection(&NhLock);
        return;

    } while(FALSE);

    //
    // A failure has occurred, so cleanup and quit.
    // We proceed in this case without notification of address changes.
    //

    NhpStopAddressChangeNotification();
    LeaveCriticalSection(&NhLock);

} // NhpStartAddressChangeNotification


VOID
NhpStopAddressChangeNotification(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop notification of local IP address changes,
    and to clean up resources used for handling notifications.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhLock);
    if (NhpAddressChangeWaitHandle) {
        RtlDeregisterWait(NhpAddressChangeWaitHandle);
        NhpAddressChangeWaitHandle = NULL;
    }
    if (NhpAddressChangeEvent) {
        NtClose(NhpAddressChangeEvent);
        NhpAddressChangeEvent = NULL;
    }
    LeaveCriticalSection(&NhLock);
} // NhpStopAddressChangeNotification


VOID
NhpUpdateConnectionsFolder(
    VOID
    )

/*++

Routine Description:

    This routine is called to refresh the connections folder UI.

Arguments:

    None.
    
Return Value:

    None.

Environment:

    COM must be initialized on the calling thread.

--*/

{
    HRESULT hr;
    INetConnectionRefresh *pNetConnectionRefresh;

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_PPV_ARG(INetConnectionRefresh, &pNetConnectionRefresh)
            );

    if (SUCCEEDED(hr))
    {
        pNetConnectionRefresh->RefreshAll();
        pNetConnectionRefresh->Release();
    }
} // NhpUpdateConnectionsFolder


BOOL
NhpUpdatePolicySettings(
    VOID
    )

/*++

Routine Description:

    This routine is called to update the group policy settings.

Arguments:

    None.
    
Return Value:

    BOOL -- returns TRUE if the policy settings have changed since
        the previous call.

Environment:

    COM must be initialized on the calling thread.

--*/

{
    INetConnectionUiUtilities *pNetConnUiUtil;
    HRESULT hr;
    BOOL fOldPolicyAllowsFirewall;
    BOOL fOldPolicyAllowsSharing;
    BOOL fPolicyAllowsFirewall;
    BOOL fPolicyAllowsSharing;
    
    hr = CoCreateInstance(
                CLSID_NetConnectionUiUtilities,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG(INetConnectionUiUtilities, &pNetConnUiUtil)
                );

    if (SUCCEEDED(hr))
    {
        fPolicyAllowsFirewall =
            pNetConnUiUtil->UserHasPermission(NCPERM_PersonalFirewallConfig);
        fPolicyAllowsSharing =
            pNetConnUiUtil->UserHasPermission(NCPERM_ShowSharedAccessUi);

        pNetConnUiUtil->Release();
    }
    else
    {
        //
        // On failure assume that policy permits everything.
        //

        fPolicyAllowsFirewall = TRUE;
        fPolicyAllowsSharing = TRUE;

        NhTrace(
            TRACE_FLAG_INIT,
            "NhpUpdatePolicySettings: Unable to create INetConnectionUiUtilities (0x%08x)",
            hr
            );
    }

    //
    // Update global variables w/ new settings
    //

    fOldPolicyAllowsFirewall = 
        InterlockedExchange(
            reinterpret_cast<LPLONG>(&NhPolicyAllowsFirewall),
            static_cast<LONG>(fPolicyAllowsFirewall)
            );

    fOldPolicyAllowsSharing =
        InterlockedExchange(
            reinterpret_cast<LPLONG>(&NhPolicyAllowsSharing),
            static_cast<LONG>(fPolicyAllowsSharing)
            );

    NhTrace(
        TRACE_FLAG_INIT,
        "NhpUpdatePolicySettings: NhPolicyAllowsFirewall=%i, NhPolicyAllowsSharing=%i",
        NhPolicyAllowsFirewall,
        NhPolicyAllowsSharing
        );

    return (fOldPolicyAllowsFirewall != fPolicyAllowsFirewall
            || fOldPolicyAllowsSharing != fPolicyAllowsSharing);

} // NhpUpdatePolicySettings


BOOLEAN
NhQueryScopeInformation(
    PULONG Address,
    PULONG Mask
    )

/*++

Routine Description:

    This routine is called to retrieve information about the current scope
    for automatic addressing.

Arguments:

    Address - receives the address of the scope

    Mask - receives the network mask of the scope

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{
    EnterCriticalSection(&NhLock);
    if (0 == NhDhcpScopeAddress) {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    } 

    *Address = NhDhcpScopeAddress;
    *Mask = NhDhcpScopeMask;
    LeaveCriticalSection(&NhLock);
    return TRUE;

} // NhQueryScopeInformation

ULONG NhpQueryServiceStartType(SC_HANDLE hService, DWORD * pdwStartType)
{
    ASSERT(hService);
    ASSERT(pdwStartType);

    ULONG Error = ERROR_SUCCESS;
    DWORD cbBuf = sizeof (QUERY_SERVICE_CONFIG) +
                              5 * (32 * sizeof(WCHAR));
    LPQUERY_SERVICE_CONFIG  pConfig  = NULL;

    pConfig = (LPQUERY_SERVICE_CONFIG) NH_ALLOCATE(cbBuf);
    if (!pConfig)
        return ERROR_NOT_ENOUGH_MEMORY;

    do {
        if (!QueryServiceConfig(hService, pConfig, cbBuf, &cbBuf))
        {
            Error = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                NH_FREE(pConfig);
                pConfig = (LPQUERY_SERVICE_CONFIG) NH_ALLOCATE(cbBuf);
                if (NULL == pConfig)
                {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }


                if (!QueryServiceConfig(hService, pConfig, cbBuf, &cbBuf))
                {
                    Error = GetLastError();
                    break;
                }
            }
            else
            {
                break;
            }
        }

        Error = ERROR_SUCCESS;
        *pdwStartType = pConfig->dwStartType;

    } while(FALSE);

    if (pConfig)
        NH_FREE(pConfig);

    return Error;
}

BOOL NhpIsServiceRunningOrGoingToRun(SC_HANDLE hScm, LPCTSTR pSvcName)
{
    BOOL bRet = FALSE;
    SC_HANDLE hService = NULL;
    DWORD dwStartType = 0;

    hService = OpenService(hScm, pSvcName, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);

    if (hService)
    {
        SERVICE_STATUS Status;
        ZeroMemory(&Status, sizeof(Status));

        if (ERROR_SUCCESS == NhpQueryServiceStartType(hService, &dwStartType) &&
             SERVICE_AUTO_START == dwStartType)
        {
            bRet = TRUE;
        }
        else if (QueryServiceStatus(hService, &Status) && 
             (SERVICE_RUNNING == Status.dwCurrentState || 
              SERVICE_START_PENDING == Status.dwCurrentState))
        {
            bRet = TRUE;
        }

        CloseServiceHandle(hService);
    }

    return bRet;
}


ULONG
NhpEnableICSDNS(
    VOID
    )
    
/*++

Routine Description:

    This routine enables "ICS DNS".

Arguments:

    none.

Return Value:

    Win32 error.

--*/

{
    ULONG Error = NO_ERROR;

    do
    {
        Error = DnsRmEnableInterface(0);
        if (Error) 
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableICSDNS: DnsRmEnableInterface=%d",
                Error
                );
            break;
        }

        Error = DnsEnableSuffixQuery();
        if (Error) 
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableICSDNS: DnsEnableSuffixQuery=%d",
                Error
                );
            break;
        }        

    } while (FALSE);

    return Error;            
}


ULONG
NhpDisableICSDNS(
    VOID
    )
    
/*++

Routine Description:

    This routine disables "ICS DNS".

Arguments:

    none.

Return Value:

    Win32 error.

--*/

{
    ULONG Error = NO_ERROR;

    do
    {
        Error = DnsRmDisableInterface(0);
        if (Error)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpDisableICSDNS: DnsRmDisableInterface=%d",
                Error
                );
            break;
        }

        Error = DnsDisableSuffixQuery();
        if (Error)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpDisableICSDNS: DnsDisableSuffixQuery=%d",
                Error
                );
            break;
        }
                
    } while (FALSE);

    return Error;
}


ULONG
NhStartICSProtocols(
    VOID
    )
    
/*++

Routine Description:

    This routine starts the DNS and DHCP modules.

Arguments:

    Argument* - count and array of arguments specified to the service

Return Value:

    none.

--*/

{
    ULONG Error = NO_ERROR;
    IP_AUTO_DHCP_GLOBAL_INFO DhcpInfo = {
        IPNATHLP_LOGGING_ERROR,
        0,
        7 * 24 * 60,
        DEFAULT_SCOPE_ADDRESS,
        DEFAULT_SCOPE_MASK,
        0
    };
    IP_DNS_PROXY_GLOBAL_INFO DnsInfo = {
        IPNATHLP_LOGGING_ERROR,
        IP_DNS_PROXY_FLAG_ENABLE_DNS,
        3
    };


    //
    // Get ICS settings to see if these should be started...
    //

    do {

        SC_HANDLE hScm = OpenSCManager(NULL, NULL, GENERIC_READ);
        
        //dont start the DNS module if DNS server is running on local host
        if (hScm) 
        {
            NoLocalDns = !NhpIsServiceRunningOrGoingToRun(hScm, c_szDnsServiceName);
        }

        if (NoLocalDns)
        {
            if (!(NhpStopDnsEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
                Error = GetLastError();
                break;
            } else {

                Error =
                    DnsRmStartProtocol(
                        NhpStopDnsEvent,
                        NULL,
                        &DnsInfo,
                        IP_NAT_VERSION,
                        sizeof(IP_DNS_PROXY_GLOBAL_INFO),
                        1
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NhStartICSProtocols: NhpStartICSDNS=%d",
                        Error
                        );
                    CloseHandle(NhpStopDnsEvent); NhpStopDnsEvent = NULL; break;
                }
            }
        }

        //dont start the DHCP module if DNS server is running on local host
        
        if (hScm) 
        {
            NhpNoLocalDhcp = !NhpIsServiceRunningOrGoingToRun(hScm, c_szDhcpServiceName);
        }

        if (NhpNoLocalDhcp)
        {
            if (!(NhpStopDhcpEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
                break;
            } else {
                NhQueryScopeInformation(
                    &DhcpInfo.ScopeNetwork, &DhcpInfo.ScopeMask
                    );
                DhcpInfo.ScopeNetwork &= DhcpInfo.ScopeMask;
                Error =
                    DhcpRmStartProtocol(
                        NhpStopDhcpEvent,
                        NULL,
                        &DhcpInfo,
                        IP_NAT_VERSION,
                        sizeof(DhcpInfo),
                        1
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "ServiceMain: DhcpRmStartProtocol=%d",
                        Error
                        );
                    CloseHandle(NhpStopDhcpEvent); NhpStopDhcpEvent = NULL; break;
                }
            }
        }


        if (hScm)
            CloseServiceHandle(hScm);

        //
        // Instruct QoS to enable window size adjustments. Any error that
        // occurs here is not propagated, as ICS will still work correctly
        // if this fails.
        //

        ULONG Error2 = NhpEnableQoSWindowSizeAdjustment(TRUE);
        if (ERROR_SUCCESS == Error2)
        {
            NhpQoSEnabled = TRUE;
        }

        //
        // Create the UDP broadcast mapper
        //

        HRESULT hr;
        CComObject<CUdpBroadcastMapper> *pUdpBroadcast;
        
        hr = CComObject<CUdpBroadcastMapper>::CreateInstance(&pUdpBroadcast);
        if (SUCCEEDED(hr))
        {
            pUdpBroadcast->AddRef();

            hr = pUdpBroadcast->Initialize(&NatComponentReference);
            if (SUCCEEDED(hr))
            {
                hr = pUdpBroadcast->QueryInterface(
                        IID_PPV_ARG(IUdpBroadcastMapper, &NhpUdpBroadcastMapper)
                        );
            }

            pUdpBroadcast->Release();
        }

        if (FAILED(hr))
        {
            Error = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Start the Beaconing Service
        //
        
        StartBeaconSvr();
        
        return NO_ERROR;
    } while (FALSE);

    return Error;
}


ULONG
NhStopICSProtocols(
    VOID
    )
    
/*++

Routine Description:

    This routine stops the "ICS" modules (DNS, DHCP, QoSWindow, Beacon etc.)

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error = NO_ERROR;

    //
    // Stop the Beaconing Service
    //

    StopBeaconSvr();

    //
    // Cleanup the UDP broadcast mapper
    //

    if (NULL != NhpUdpBroadcastMapper)
    {
        NhpUdpBroadcastMapper->Shutdown();
        NhpUdpBroadcastMapper->Release();
        NhpUdpBroadcastMapper = NULL;
    }        

    //
    // Instruct QoS to disable window size adjustments
    //

    if (NhpQoSEnabled) {
        NhpEnableQoSWindowSizeAdjustment(FALSE);
        NhpQoSEnabled = FALSE;
    }
    
    //
    // Remove the private interface from each shared-access component
    //

    NhpDeletePrivateInterface();

    //
    // Stop DHCP followed by DNS
    //

    if (NhpStopDhcpEvent) {
        DhcpRmStopProtocol();
        WaitForSingleObject(NhpStopDhcpEvent, INFINITE);
        CloseHandle(NhpStopDhcpEvent); NhpStopDhcpEvent = NULL;
    }
    
    if (NhpStopDnsEvent) {
        DnsRmStopProtocol();
        WaitForSingleObject(NhpStopDnsEvent, INFINITE);
        CloseHandle(NhpStopDnsEvent); NhpStopDnsEvent = NULL;
    }
        
    return Error;
}


ULONG
NhUpdatePrivateInterface(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to add the private interface to each
    shared-access component. It is also invoked when the private interface
    is already added, but some change has occurred which requires that it
    be updated (e.g. IP address change).
    
Arguments:

    none.

Return Value:

    Win32 error.

--*/

{
    ULONG AdapterIndex;
    PIP_ADAPTER_BINDING_INFO BindingInfo;
    ULONG Error;
    ULONG Count;
    GUID *pLanGuid;
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetIcsPrivateConnections *pEnum;
    IHNetIcsPrivateConnection *pIcsConn;
    IHNetConnection *pConn;
    
    IP_NAT_INTERFACE_INFO NatInfo =
    {
        0,
        0,
        { IP_NAT_VERSION, sizeof(RTR_INFO_BLOCK_HEADER), 0, { 0, 0, 0, 0 }}
    };
    UNICODE_STRING UnicodeString;



    PROFILE("NhUpdatePrivateInterface");

    //
    // We begin by reading the GUID from the configuration store,
    // and we then map that GUID to an adapter index.
    // Using that adapter index, we obtain the binding information
    // for the private interface.
    // We can then determine whether a change has occurred
    // by comparing the previous and new GUID and binding information.
    //

    //
    // Get the CfgMgr pointer out of the GIT
    //

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: GetInterfaceFromGlobal=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the ICS settings interface
    //

    hr = pCfgMgr->QueryInterface(IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings));
    pCfgMgr->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QI for IHNetIcsSettings=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the enumeration of the ICS private interfaces
    //

    hr = pIcsSettings->EnumIcsPrivateConnections(&pEnum);
    pIcsSettings->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: EnumIcsPrivateConnections=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the private connection
    //

    hr = pEnum->Next(1, &pIcsConn, &Count);
    pEnum->Release();

    if (FAILED(hr) || 1 != Count)
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: pEnum->Next=0x%08x, Count=%d",
            hr,
            Count
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // QI for the IHNetConnection
    //

    hr = pIcsConn->QueryInterface(IID_PPV_ARG(IHNetConnection, &pConn));
    pIcsConn->Release();

    if (FAILED(hr))
    {   
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QI for IHNetConnection=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the GUID for the connection
    //

    hr = pConn->GetGuid(&pLanGuid);
    pConn->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: GetGuid=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }
        
    //
    // Determine the adapter-index corresponding to the GUID
    //

    RtlStringFromGUID(*pLanGuid, &UnicodeString);
    AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    if (AdapterIndex == (ULONG)-1) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: MapGuidToAdapter"
            );
        CoTaskMemFree(pLanGuid);
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Retrieve the binding information for the adapter
    //

    BindingInfo = NhQueryBindingInformation(AdapterIndex);
    if (!BindingInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QueryBindingInformation failed(2)\n"
            );
        CoTaskMemFree(pLanGuid);
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // See if any change has occurred which requires an update.
    //

    if (RtlEqualMemory(pLanGuid, &NhpSharedPrivateLanGuid, sizeof(GUID)) &&
        AdapterIndex == NhpSharedPrivateLanIndex &&
        NhpSharedPrivateLanBindingInfo &&
        BindingInfo->AddressCount ==
        NhpSharedPrivateLanBindingInfo->AddressCount &&
        BindingInfo->AddressCount &&
        RtlEqualMemory(
            &BindingInfo->Address[0],
            &NhpSharedPrivateLanBindingInfo->Address[0],
            sizeof(IP_LOCAL_BINDING)
            )) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: no changes detected"
            );
        NH_FREE(BindingInfo);
        CoTaskMemFree(pLanGuid);
        return NO_ERROR;
    }

    //
    // A change has occurred which requires an update.
    // First we get rid of any existing private LAN interface,
    // then we add the new interface to each component (NAT, DHCP, DNS proxy)
    // and bind and enable the new interface.
    //

    NhpDeletePrivateInterface();

    do {

        Error =
            NatRmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                &NatInfo,
                IP_NAT_VERSION,
                sizeof(NatInfo),
                1
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: NatRmAddInterface=%d",
                Error
                );
            break;
        }

        if (NhpNoLocalDhcp)
        {
            Error =
                DhcpRmAddInterface(
                    NULL,
                    0,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmAddInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error =
                DnsRmAddInterface(
                    NULL,
                    0,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmAddInterface=%d",
                    Error
                    );
                break;
            }
        }


        Error =
            AlgRmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmAddInterface=%d",
                Error
                );
            break;
        }

        Error =
            H323RmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmAddInterface=%d",
                Error
                );
            break;
        }

        //
        // Bind the private interface of each component
        //

        Error = NatBindInterface(0, NULL, BindingInfo, AdapterIndex);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: NatRmBindInterface=%d",
                Error
                );
            break;
        }

        if (NhpNoLocalDhcp)
        {
            Error = DhcpRmBindInterface(0, BindingInfo);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmBindInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error = DnsRmBindInterface(0, BindingInfo);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmBindInterface=%d",
                    Error
                    );
                break;
            }
        }

        Error = AlgRmBindInterface(0, BindingInfo);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmBindInterface=%d",
                Error
                );
            break;
        }

        Error = H323RmBindInterface(0, BindingInfo);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmBindInterface=%d",
                Error
                );
            break;
        }

        //
        // Enable the private interface for the components.
        // The NAT private interface is always enabled, and therefore
        // requires no additional call.
        //

        if (NhpNoLocalDhcp)
        {
            Error = DhcpRmEnableInterface(0);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmEnableInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error = DnsRmEnableInterface(0);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmEnableInterface=%d",
                    Error
                    );
                break;
            }
        }

        Error = AlgRmEnableInterface(0);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmEnableInterface=%d",
                Error
                );
            break;
        }

        Error = H323RmEnableInterface(0);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmEnableInterface=%d",
                Error
                );
            break;
        }

        //
        // The interface was activated successfully.
        //

        RtlCopyMemory(&NhpSharedPrivateLanGuid, pLanGuid, sizeof(GUID));
        NhpSharedPrivateLanIndex = AdapterIndex;
        CoTaskMemFree(pLanGuid);
        if (NhpSharedPrivateLanBindingInfo) {
            NH_FREE(NhpSharedPrivateLanBindingInfo);
        }
        NhpSharedPrivateLanBindingInfo = BindingInfo;        
        return NO_ERROR;
    
    } while(FALSE);

    NH_FREE(BindingInfo);
    CoTaskMemFree(pLanGuid);
    return Error;

} // NhUpdatePrivateInterface


VOID
ServiceHandler(
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called to control the 'SharedAccess' service.

Arguments:

    ControlCode - indicates the requested operation

Return Value:

    none.

--*/

{
    BOOLEAN ComInitialized = FALSE;
    HRESULT hr;
    
    PROFILE("ServiceHandler");
    if (ControlCode == IPNATHLP_CONTROL_UPDATE_CONNECTION) {

        //
        // Update our policy settings
        //

        NhpUpdatePolicySettings();

        //
        // Signal the configuration-changed event
        //

        NtSetEvent(NatConfigurationChangedEvent, NULL);
        SignalBeaconSvr();
        
    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_SETTINGS) {

        //
        // Update all state which depends on shared access settings
        //

        NatRemoveApplicationSettings();
        NhUpdateApplicationSettings();
        NatInstallApplicationSettings();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_FWLOGGER) {

        FwUpdateLoggingSettings();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_AUTODIAL) {

        NtSetEvent(NatConnectionNotifyEvent, NULL);

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_DNS_DISABLE) {

        NhpDisableICSDNS();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_DNS_ENABLE) {

        NhpEnableICSDNS();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_POLICY) {
    
        if (NhpUpdatePolicySettings()) {
            NtSetEvent(NatConfigurationChangedEvent, NULL);
        }

    } else if (ControlCode == SERVICE_CONTROL_STOP &&
                NhpServiceStatus.dwCurrentState != SERVICE_STOPPED &&
                NhpServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {


        NhpServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        if (NhpServiceStatusHandle) {
            SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        }

        if (NhpClassObjectsRegistered) {
            _Module.RevokeClassObjects();
            NhpClassObjectsRegistered = FALSE;
        }

        NhpStopAddressChangeNotification();

        if (NhpStopNatEvent) {
            NatRmStopProtocol();
            WaitForSingleObject(NhpStopNatEvent, INFINITE);
            CloseHandle(NhpStopNatEvent); NhpStopNatEvent = NULL;
        }

        if (NhpStopAlgEvent) {
            AlgRmStopProtocol();

            WaitForSingleObject(NhpStopAlgEvent, INFINITE);
            CloseHandle(NhpStopAlgEvent); NhpStopAlgEvent = NULL;
        }

        if (NhpStopH323Event) {
            H323RmStopProtocol();
            WaitForSingleObject(NhpStopH323Event, INFINITE);
            CloseHandle(NhpStopH323Event); NhpStopH323Event = NULL;
        }

        EnterCriticalSection(&NhLock);
        NhFreeApplicationSettings();
        if (NhpSharedPrivateLanBindingInfo) {
            NH_FREE(NhpSharedPrivateLanBindingInfo);
            NhpSharedPrivateLanBindingInfo = NULL;
        }
        LeaveCriticalSection(&NhLock);
        NhpServiceStatus.dwCurrentState = SERVICE_STOPPED;
        NhResetComponentMode();

        //
        // Shutdown the firewall logging subsystem
        //

        if (NhpFwLoggingInitialized) {
            FwCleanupLogger();
            NhpFwLoggingInitialized = FALSE;
        }

        //
        // Release our reference to RasMan
        //

        if (NhpRasmanReferenced) {
            RasReferenceRasman(FALSE);
            NhpRasmanReferenced = FALSE;
        }

        //
        // Update the network connections folder (so that the firewall icons
        // will disappear as necessary).
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr)) {
            ComInitialized = TRUE;
        } else if (RPC_E_CHANGED_MODE == hr) {
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            NhpUpdateConnectionsFolder();
        }

        if (TRUE == ComInitialized) {
            CoUninitialize();
        }

        NhStopEventLog();
    }
    if (NhpServiceStatusHandle) {
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
    }
} // ServiceHandler


VOID
ServiceMain(
    ULONG ArgumentCount,
    PWCHAR ArgumentArray[]
    )

/*++

Routine Description:

    This routine is the entrypoint for the connection-sharing service.
    It is responsible for initializing the module and starting operation.

Arguments:

    Argument* - count and array of arguments specified to the service

Return Value:

    none.

--*/

{
    HRESULT hr;
    ULONG Error;
    BOOLEAN ComInitialized = FALSE;
    
    IP_ALG_GLOBAL_INFO AlgInfo = {
        IPNATHLP_LOGGING_ERROR,
        0
    };

    IP_H323_GLOBAL_INFO H323Info = {
        IPNATHLP_LOGGING_ERROR,
        0
    };
    IP_NAT_GLOBAL_INFO NatInfo = {
        IPNATHLP_LOGGING_ERROR,
        0,
        { IP_NAT_VERSION, FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry), 0,
        { 0, 0, 0, 0 }}
    };

    PROFILE("ServiceMain");

    do {
        NhStartEventLog();

        //
        // Initialize service status, register a service control handler,
        // and indicate that the service is starting
        //
    
        ZeroMemory(&NhpServiceStatus, sizeof(NhpServiceStatus));
        NhpServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        NhpServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        NhpServiceStatusHandle =
            RegisterServiceCtrlHandler(
                TEXT("SharedAccess"), ServiceHandler
                );
        if (!NhpServiceStatusHandle) { break; }

        //
        // Attempt to set the component into 'Shared Access' mode.
        // This module implements both shared-access and connection-sharing
        // which are mutually exclusive, so we need to ensure that
        // connection-sharing is not operational before proceeding.
        //

        if (!NhSetComponentMode(NhSharedAccessMode)) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: cannot enable Shared Access mode"
                );
            break;
        }

        //
        // Make sure COM is initialized on this thread
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr))
        {
            ComInitialized = TRUE;
        }
        else
        {
            if (RPC_E_CHANGED_MODE != hr)
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: Unable to initialize COM (0x%08x)",
                    hr
                    );
                break;
            }
            else
            {
                ASSERT(FALSE);
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: Unexpectedly in STA!"
                    );
            }
        }

        //
        // Obtain the current policy settings.
        //

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhpUpdatePolicySettings();

        //
        // Reference RasMan. As we live in the same process as rasman, the
        // normal SC dependency mechanism won't necessarily keep the rasman
        // service alive (119042)
        //

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (ERROR_SUCCESS != (Error = RasReferenceRasman(TRUE))) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: Unable to reference RasMan (0x%08x)",
                Error
                );
            break;
        }

        NhpRasmanReferenced = TRUE;

        //
        // Initialize the firewall logging subsystem
        //

        Error = FwInitializeLogger();
        if (ERROR_SUCCESS != Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: FwInitializeLogger=%d",
                Error
                );
            break;
        }

        NhpFwLoggingInitialized = TRUE;

        //
        // Register the class object for our notification sink
        //

        hr = _Module.RegisterClassObjects(
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                REGCLS_MULTIPLEUSE
                );

        if (FAILED(hr)) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: _Module.RegisterClassObjects=0x%08x",
                hr
                );
            break;
        }

        NhpClassObjectsRegistered = TRUE;

        //
        // Start operations by loading the NAT, Ftp, ALG, and H.323 modules
        //
    
        NhpServiceStatus.dwWaitHint = 30000;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopNatEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                NatRmStartProtocol(
                    NhpStopNatEvent,
                    NULL,
                    &NatInfo,
                    IP_NAT_VERSION,
                    sizeof(NatInfo),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: NatRmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopNatEvent); NhpStopNatEvent = NULL; break;
            }
        }

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopAlgEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                AlgRmStartProtocol(
                    NhpStopAlgEvent,
                    NULL,
                    &AlgInfo,
                    IP_NAT_VERSION,
                    sizeof(AlgInfo),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: AlgRmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopAlgEvent); NhpStopAlgEvent = NULL; break;
            }
        }

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopH323Event = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                H323RmStartProtocol(
                    NhpStopH323Event,
                    NULL,
                    &H323Info,
                    IP_NAT_VERSION,
                    sizeof(H323Info),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: H323RmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopH323Event); NhpStopH323Event = NULL; break;
            }
        }

        //
        // Start connection management. If needed, this will load the DNS and
        // DHCP modules. The Beacon Service is also started.
        //
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        Error = NatStartConnectionManagement();
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: NatStartConnectionManagement=%d",
                Error
                );
            break;
        }
        
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhpStartAddressChangeNotification();

        //
        // Indicate that the service is now up and running.
        //
    
        NhpServiceStatus.dwCurrentState = SERVICE_RUNNING;
        NhpServiceStatus.dwWaitHint = 0;
        NhpServiceStatus.dwCheckPoint = 0;
        NhpServiceStatus.dwControlsAccepted =
            SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_PARAMCHANGE;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhTrace(TRACE_FLAG_INIT, "ServiceMain: service started successfully");

        //
        // Ask the connections folder to update itself.
        //

        NhpUpdateConnectionsFolder();

        //
        // Uninitialize COM
        //

        if (TRUE == ComInitialized)
        {
            CoUninitialize();
        }

        return;
    
    } while(FALSE);

    //
    // A failure occurred; do cleanup
    //

    NhpServiceStatus.dwWaitHint = 0;
    NhpServiceStatus.dwCheckPoint = 0;
    NhTrace(TRACE_FLAG_INIT, "ServiceMain: service could not start");
    StopBeaconSvr();

    //
    // Uninitialize COM
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }
    
    ServiceHandler(SERVICE_CONTROL_STOP);

} // ServiceMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\priority\priority.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\priority\priority.h

Abstract:
    IP Router Manager code

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <dim.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtm.h>
#include <fltdefs.h>
#include <rtinfo.h>
#include <ipinfoid.h>
#include <iprtinfo.h>
#include <iprtprio.h>
#include <priopriv.h>

#define HASH_TABLE_SIZE 17

//
// Block inserted into the hash table of protocol->metric mapping
//

struct RoutingProtocolBlock 
{
    LIST_ENTRY	        RPB_List ;
    PROTOCOL_METRIC     RPB_ProtocolMetric ;
};

typedef struct RoutingProtocolBlock RoutingProtocolBlock ;

//
// pointer to memory holding all the protocol->metric mapping blocks
//

RoutingProtocolBlock *RoutingProtocolBlockPtr ;

//
// Lock for accessing protocol->metric mapping blocks
//

CRITICAL_SECTION PriorityLock ;

//
// Hash table for accessing protocol->metric mappings given the protocolid
//

LIST_ENTRY HashTable[HASH_TABLE_SIZE] ;

//
// Count of number of protocol->metric mappings
//

DWORD NumProtocols ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\priority\priority.c ===
/*++

  
Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\priority\priority.c

Abstract:

    Route Priority DLL

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/

#include    "priority.h"

PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                  dwType,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
{
    DWORD   i;

    if(pInfoHdr == NULL)
    {
        return NULL;
    }

    for(i = 0; i < pInfoHdr->TocEntriesCount; i++)
    {
        if(pInfoHdr->TocEntry[i].InfoType == dwType)
        {
            return &(pInfoHdr->TocEntry[i]);
        }
    }

    return NULL; 
}

VOID
InitHashTable(
    VOID
    )

/*++

Routine Description

    Initializes the hash tables where the priority information is kept

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD i;

    for(i=0; i < HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&HashTable[i]);
    }
}

BOOL
InitPriorityDLL (
    HANDLE  hInst, 
    DWORD   ulCallReason,
    PVOID   pReserved
    )
{
    static BOOL bPriorityLockInitialized = FALSE;

    switch(ulCallReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Not interested in any XXX_THREAD_XXX reasons
            //
            
            DisableThreadLibraryCalls(hInst);
            
            //
            // Initialize Critical Section for routing protocol list
            //
            
            try
            {
                InitializeCriticalSection(&PriorityLock);
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                return FALSE;
            }

            bPriorityLockInitialized = TRUE;

            //
            // Initialize Hash Table
            //
            
            InitHashTable();

            break;
        }
        
        case DLL_PROCESS_DETACH:
        {
            if ( bPriorityLockInitialized )
            {
                DeleteCriticalSection(&PriorityLock);
                bPriorityLockInitialized = FALSE;
            }

            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            break;
        }

    }

    return TRUE;
}

DWORD
ComputeRouteMetric(
    IN DWORD    dwProtoId
    )

/*++

Routine Description

    This is the main function that computes the priority of a route.
    The priority is filled into the

Locks

    Takes the lock guarding the hash table

Arguments

    pRoute  Pointer to route 

Return Value

    DWORD priority for the protocol    

--*/

{
    PLIST_ENTRY             pleNode;
    RoutingProtocolBlock    *pProtoBlk;
    DWORD                   dwMetric;
    
    //
    // Initialize in case the specified protocol is not in the list
    //
    
    dwMetric    = IP_PRIORITY_DEFAULT_METRIC;
    
    EnterCriticalSection(&PriorityLock);

    //
    // Walk the hash bucket for the protocol
    //
    
    for(pleNode  = HashTable[dwProtoId % HASH_TABLE_SIZE].Flink;
        pleNode != &(HashTable[dwProtoId % HASH_TABLE_SIZE]);
        pleNode  = pleNode->Flink) 
    {
        //
        // Cast to appropriate structure
        //
        
        pProtoBlk = CONTAINING_RECORD(pleNode,
                                      RoutingProtocolBlock,
                                      RPB_List);

        //
        // If the info is for the protocol, copy out the priority metric
        //
        
        if(pProtoBlk->RPB_ProtocolMetric.dwProtocolId == dwProtoId)
        {
            dwMetric = pProtoBlk->RPB_ProtocolMetric.dwMetric;
            
            break;
        }
    }

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection(&PriorityLock);
    
    return dwMetric;
}


DWORD
SetPriorityInfo(
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )

/*++

Routine Description

    This function is called by the IP Router Manager to set the priority
    information in the DLL. The structure and contents of this information
    are opaque to all but the setup and this DLL

Locks

    Takes the hash table lock since the information is changing

Arguments

    pInfoHdr    Pointer to the InfoBlock header

Return Value

    NO_ERROR                Everything worked OK
    ERROR_NOT_ENOUGH_MEMORY Couldnt allocate memory

--*/

{
    DWORD                   i;
    PLIST_ENTRY             pleListHead;
    PPRIORITY_INFO          pInfo;
    RoutingProtocolBlock    *currentblock;
    PRTR_TOC_ENTRY          pToc;
 
    pToc = GetPointerToTocEntry(IP_PROT_PRIORITY_INFO,
                                pInfoHdr);

    //
    // No info means leave things as they are
    //
    
    if(!pToc)
    {
        return NO_ERROR;
    }

    pInfo = (PPRIORITY_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                pToc);
    
    if(!pInfo)
    {
        return NO_ERROR;
    }

    //
    // *** Exclusion Begin ***
    //
    
    EnterCriticalSection(&PriorityLock);

    //
    // If we already have the hash table populated - free the whole table.
    //
    
    if(RoutingProtocolBlockPtr) 
    {
        HeapFree(GetProcessHeap(),
                 0,
                 RoutingProtocolBlockPtr);
        
        InitHashTable();
    }
    
    if(pToc->InfoSize == 0)
    {
        //
        // Means delete all the info - which is done above
        //
        
        LeaveCriticalSection(&PriorityLock);
        
        return NO_ERROR;
    }

    //
    // Allocate enough RoutingProtocolBlocks to hold the newly specified info
    //
    
    RoutingProtocolBlockPtr =
        HeapAlloc(GetProcessHeap(), 
                  HEAP_ZERO_MEMORY,
                  pInfo->dwNumProtocols * sizeof (RoutingProtocolBlock));
    
    if(RoutingProtocolBlockPtr == NULL)
    {
        //
        // *** Exclusion End ***
        //
        
        LeaveCriticalSection (&PriorityLock);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Keep a count of the number of protocols
    //
    
    NumProtocols = pInfo->dwNumProtocols;

    //
    // Go thru pInfo and add each protocol and metric to the hash table
    //
    
    currentblock = RoutingProtocolBlockPtr;
    
    for(i=0; i < NumProtocols; i++) 
    {
        currentblock->RPB_ProtocolMetric.dwProtocolId = 
            pInfo->ppmProtocolMetric[i].dwProtocolId;
        
        currentblock->RPB_ProtocolMetric.dwMetric     = 
            pInfo->ppmProtocolMetric[i].dwMetric;
        
        pleListHead = &HashTable[pInfo->ppmProtocolMetric[i].dwProtocolId % HASH_TABLE_SIZE];
        
        InsertTailList(pleListHead,
                       &currentblock->RPB_List);
        
        currentblock++;
    }

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection (&PriorityLock);

    return NO_ERROR;
}

DWORD
GetPriorityInfo(
    IN  PVOID   pvBuffer,
    OUT PDWORD  pdwBufferSize
    )

/*++

Routine Description

    Called by router manager to get a copy of our priority information

Locks

    Takes the table lock to ensure consistency

Arguments

    pvBuffer        Pointer to buffer into which info is to be written
    pdwBufferSize   [IN]  Size of the buffer pointed to by pvBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Return Value

    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize

--*/

{
    DWORD           i, dwSizeReqd;
    PPRIORITY_INFO  ppiPriorityInfo;
    RoutingProtocolBlock *currentblock;

    ppiPriorityInfo = pvBuffer;
    
    //
    // *** Exclusion Begin ***
    //
    
    EnterCriticalSection (&PriorityLock);

    dwSizeReqd = SIZEOF_PRIORITY_INFO(NumProtocols);

    if(dwSizeReqd > *pdwBufferSize)
    {
        *pdwBufferSize = dwSizeReqd;

        //
        // *** Exclusion End ***
        //
        
        LeaveCriticalSection (&PriorityLock);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwBufferSize = dwSizeReqd;
    
    //
    // Go thru pinfo and get each protocol and metric 
    //
    
    currentblock = RoutingProtocolBlockPtr;
    
    for(i=0; i < NumProtocols; i++) 
    {
        ppiPriorityInfo->ppmProtocolMetric[i].dwProtocolId = 
            currentblock->RPB_ProtocolMetric.dwProtocolId;

        ppiPriorityInfo->ppmProtocolMetric[i].dwMetric =     
            currentblock->RPB_ProtocolMetric.dwMetric;

        currentblock++;
    }

    ppiPriorityInfo->dwNumProtocols = NumProtocols;

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection(&PriorityLock);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\api.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: api.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// router manager API implementations
//============================================================================

#include "pchrip.h"
#pragma hdrstop



//
// Definition of sole global variable for IPRIP
//

IPRIP_GLOBALS ig;



//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// This is the DLL entrypoint handler. It calls DllStartup
// to initialize locking and event queue and to create IPRIP's heap,
// and calls DllCleanup to delete the lock and event queue.
//----------------------------------------------------------------------------

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    ) {

    BOOL bErr;


    bErr = FALSE;

    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            bErr = DllStartup();
            break;

        case DLL_PROCESS_DETACH:

            bErr = DllCleanup();
            break;

        default:

            bErr = TRUE;
            break;
    }

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllStartup
//
// Initializes IPRIP's function lock, event queue, and global heap.
//----------------------------------------------------------------------------

BOOL
DllStartup(
    ) {

    BOOL bErr;
    DWORD dwErr;


    bErr = TRUE;

    do { // error breakout loop

        ZeroMemory(&ig, sizeof(IPRIP_GLOBALS));


        //
        // create the global critical section and set IPRIP's status
        //

        try {
            InitializeCriticalSection(&ig.IG_CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            bErr = FALSE;
            break;
        }

        ig.IG_Status = IPRIP_STATUS_STOPPED;


        //
        // attempt to create a private heap for IPRIP
        //

        ig.IG_IpripGlobalHeap = HeapCreate(0, 0, 0);

        if (ig.IG_IpripGlobalHeap == NULL) {

            bErr = FALSE;
            break;
        }


        //
        // create the router manager message queue
        //


        ig.IG_EventQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_EventQueue == NULL) {

            bErr = FALSE;
            break;
        }


        //
        // initialize the Router Manager event queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_EventQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            bErr = FALSE;
            break;
        }


    } while(FALSE);

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllCleanup
//
// Deletes the global heap, event queue, and function lock.
//----------------------------------------------------------------------------

BOOL
DllCleanup(
    ) {

    BOOL bErr;


    bErr = TRUE;


    do { // error breakout loop

        //
        // destroy the router manager event queue
        //

        if (ig.IG_EventQueue != NULL) {

            if (LOCKED_LIST_CREATED(ig.IG_EventQueue)) {

                DELETE_LOCKED_LIST(
                    ig.IG_EventQueue, EVENT_QUEUE_ENTRY, EQE_Link
                    );
            }

            RIP_FREE(ig.IG_EventQueue);
        }


        if (ig.IG_IpripGlobalHeap != NULL) {
            HeapDestroy(ig.IG_IpripGlobalHeap);
        }



        //
        // delete the global critical section
        //

        DeleteCriticalSection(&ig.IG_CS);


        RouterLogDeregister(ig.IG_LogHandle);
        if (ig.IG_TraceID != INVALID_TRACEID) {
            TraceDeregister(ig.IG_TraceID);
        }
        
    } while(FALSE);


    return bErr;
}




//----------------------------------------------------------------------------
// Function:    ProtocolStartup
//
// This is called by StartProtocol. Initializes data structures,
// creates IPRIP threads.
//----------------------------------------------------------------------------

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PVOID pConfig
    ) {

    WSADATA wd;
    HANDLE hThread;
    BOOL bCleanupWinsock;
    DWORD dwErr, dwSize, dwThread;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;
    SYSTEM_INFO sysInfo;



    EnterCriticalSection(&ig.IG_CS);

    ig.IG_TraceID = TraceRegister("IPRIP2");
    ig.IG_LogHandle = RouterLogRegister("IPRIP2");


    //
    // make certain RIP is not already running
    //

    if (ig.IG_Status != IPRIP_STATUS_STOPPED) {

        TRACE0(START, "ERROR: StartProtocol called with IPRIP already running");
        LOGWARN0(IPRIP_ALREADY_STARTED, NO_ERROR);

        LeaveCriticalSection(&ig.IG_CS);
        return ERROR_CAN_NOT_COMPLETE;
    }



    bCleanupWinsock = FALSE;


    do { // break-out construct



        TRACE0(ENTER, "IPRIP is starting up");


        //
        // save the Router Manager notification event
        //

        ig.IG_EventEvent = hEventEvent;


        //
        // find the size of the global configuration passed in
        //

        pgcsrc = (PIPRIP_GLOBAL_CONFIG)pConfig;

        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // allocate a block to hold the configuration
        //

        ig.IG_Config = pgcdst = RIP_ALLOC(dwSize);

        if (pgcdst == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for global config",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the supplied configuration
        //

        CopyMemory(pgcdst, pgcsrc, dwSize);
        ig.IG_LogLevel = pgcsrc->GC_LoggingLevel;


        //
        // attempt to start Winsock
        //

        dwErr = (DWORD)WSAStartup(MAKEWORD(1,1), &wd);

        if (dwErr != 0) {

            TRACE1(START, "error %d starting Windows Sockets.", dwErr);
            LOGERR0(WSASTARTUP_FAILED, dwErr);

            break;
        }

        bCleanupWinsock = TRUE;


        //
        // attempt to create synchronization object for global config
        //

        dwErr = CreateReadWriteLock(&ig.IG_RWL);
        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d creating read-write lock", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);

            break;
        }


        //
        // register a timer queue with Ntdll timer thread
        //

        ig.IG_TimerQueueHandle = CreateTimerQueue();

        if ( !ig.IG_TimerQueueHandle) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering time queue with NtdllTimer thread",
                dwErr
                );
            LOGERR0(CREATE_TIMER_QUEUE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for an interface table
        //

        ig.IG_IfTable = RIP_ALLOC(sizeof(IF_TABLE));
        if (ig.IG_IfTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for interface table",
                dwErr, sizeof(IF_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the interface table
        //

        dwErr = CreateIfTable(ig.IG_IfTable);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing interface table", dwErr);
            LOGERR0(CREATE_IF_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the peer statistics table
        //

        ig.IG_PeerTable = RIP_ALLOC(sizeof(PEER_TABLE));

        if (ig.IG_PeerTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for peer table",
                dwErr, sizeof(PEER_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the peer statistics table
        //

        dwErr = CreatePeerTable(ig.IG_PeerTable);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing peer statistics table", dwErr);
            LOGERR0(CREATE_PEER_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the binding table
        //

        ig.IG_BindingTable = RIP_ALLOC(sizeof(BINDING_TABLE));

        if (ig.IG_BindingTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for binding table",
                dwErr, sizeof(PEER_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the binding table
        //

        dwErr = CreateBindingTable(ig.IG_BindingTable);
        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d creating binding table", dwErr);
            LOGERR0(CREATE_BINDING_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the send queue
        //

        ig.IG_SendQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_SendQueue == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for send-queue",
                dwErr, sizeof(LOCKED_LIST)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the send queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_SendQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "exception %d initializing send queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the receive queue
        //

        ig.IG_RecvQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_RecvQueue == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for receive queue",
                dwErr, sizeof(LOCKED_LIST)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the receive queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_RecvQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "exception %d initializing receive queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);

            break;
        }


        //
        // Determine the number of CPUs
        //

        GetSystemInfo(&sysInfo);
        ig.IG_MaxProcessInputWorkItems = sysInfo.dwNumberOfProcessors;
        if ( ig.IG_MaxProcessInputWorkItems == 0 || 
                ig.IG_MaxProcessInputWorkItems > MAXPROCESSINPUTWORKITEMS ) {
            ig.IG_MaxProcessInputWorkItems = MAXPROCESSINPUTWORKITEMS;
        }

        //
        // create event signalled by WinSock when input arrives
        // and register it with the NtdllWait thread
        //

        ig.IG_IpripInputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (ig.IG_IpripInputEvent == NULL) {

            dwErr = GetLastError();
            TRACE1(START, "error %d creating event to signal input", dwErr);
            LOGERR0(CREATE_EVENT_FAILED, dwErr);

            break;
        }

         
        if (! RegisterWaitForSingleObject(
                  &ig.IG_IpripInputEventHandle,
                  ig.IG_IpripInputEvent,
                  CallbackFunctionNetworkEvents,
                  NULL,
                  INFINITE,
                  (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                  )) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering input event with NtdllWait thread",
                dwErr);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);

            break;
        }


        //
        // initialize the count of threads which are active in IPRIP
        // (includes IpripThread and worker threads),
        // and create the semaphore released by each thread when it is done
        //

        ig.IG_ActivityCount = 0;

        ig.IG_ActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);

        if (ig.IG_ActivitySemaphore == NULL) {

            dwErr = GetLastError();
            TRACE1(
                START, "error %d creating semaphore for IPRIP threads", dwErr
                );
            LOGERR0(CREATE_SEMAPHORE_FAILED, dwErr);

            break;
        }



        //
        // register with RTMv2
        //

        ig.IG_RtmEntityInfo.RtmInstanceId = 0;
        ig.IG_RtmEntityInfo.AddressFamily = AF_INET;
        ig.IG_RtmEntityInfo.EntityId.EntityProtocolId = PROTO_IP_RIP;
        ig.IG_RtmEntityInfo.EntityId.EntityInstanceId = 0;
        
        dwErr = RtmRegisterEntity(
                    &ig.IG_RtmEntityInfo, NULL,
                    ProcessRtmNotification,
                    FALSE, &ig.IG_RtmProfile,
                    &ig.IG_RtmHandle
                    );

        if (dwErr != NO_ERROR ) {
        
            TRACE1(START, "error %d registering with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);

            break;
        }

        dwErr = RtmRegisterForChangeNotification(
                    ig.IG_RtmHandle,
                    RTM_VIEW_MASK_UCAST,
                    RTM_CHANGE_TYPE_BEST,
                    NULL,
                    &ig.IG_RtmNotifHandle
                    );

        if (dwErr != NO_ERROR ) {
        
            TRACE1(START, "error %d registering for change with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);

            break;
        }

                    
        //
        // set IPRIP's status to running now, before we attempt
        // to queue the MIB display work-item;
        // QueueRipWorker() will check the status,
        // and it will refuse to queue any work-items
        // unless the status is IPRIP_STATUS_RUNNING
        //

        ig.IG_Status = IPRIP_STATUS_RUNNING;


#if CONFIG_DBG

        //
        // queue work item to display IPRIP's MIB tables periodically
        //

        ig.IG_MibTraceID = TraceRegisterEx("IPRIPMIB", TRACE_USE_CONSOLE);

        if (ig.IG_MibTraceID != INVALID_TRACEID) {
        
            //
            // create the persistent timer for the timer queue
            //

            if (!CreateTimerQueueTimer(
                    &ig.IG_MibTimerHandle, ig.IG_TimerQueueHandle,
                    WorkerFunctionMibDisplay, NULL,
                    0, 10000, 0)) {

                dwErr = GetLastError();
                
                TRACE1(START, "error %d creating MIB display timer", dwErr);
            }
        }

#endif
        //
        // Increase the refernce on iprip2, so we won't get unloaded when 
        // iprtrmgr calls FreeLibrary for iprip2. This reference will be 
        // removed by calling FreeLibrary, after we are done completely.
        // If LoadLibrary fails, we still continue as this is not a fatal error, 
        // and can only lead to a small window where rtrmgr unloads iprip2, while 
        // the WorkerFunctionFinishStopProtocol has not yet finished.
        // ig.IG_DllHandle = LoadLibrary(TEXT("iprip2.dll"));
        //

        ig.IG_DllHandle = LoadLibrary(TEXT("iprip2.dll"));
        
        TRACE0(START, "IPRIP has started successfully");
        LOGINFO0(IPRIP_STARTED, NO_ERROR);

        LeaveCriticalSection(&ig.IG_CS);

        return NO_ERROR;


    } while (FALSE);



    //
    // something went wrong, so we cleanup.
    // Note that we needn't worry about the main thread,
    // since when we finally leave this critical section it will find
    // that the status is IPRIP_STATUS_STOPPED, and it will immediately quit
    //

    TRACE0(START, "IPRIP failed to start");

    ProtocolCleanup(bCleanupWinsock);


    LeaveCriticalSection(&ig.IG_CS);

    return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
}



//----------------------------------------------------------------------------
// Function: ProtocolCleanup
//
// This function deallocates allocated memory, closes open handles, and
// cleans up the global struct. It leaves IPRIP in clean state, so that
// it should be possible to do StartProtocol again with no memory leaks.
//----------------------------------------------------------------------------

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    ) {

    DWORD dwErr;
    
    // EnterCriticalSection(&ig.IG_CS);


#ifdef CONFIG_DBG
    TraceDeregister(ig.IG_MibTraceID);
    ig.IG_MibTraceID = INVALID_TRACEID;
#endif


    if ( ig.IG_RtmNotifHandle != NULL ) {
    
        dwErr = RtmDeregisterFromChangeNotification(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle
                    );

        if ( dwErr != NO_ERROR ) {

            TRACE1(STOP, "error %d deregistering change notification", dwErr);
        }    
    }

    if (ig.IG_RtmHandle != NULL) {
    
        dwErr = RtmDeregisterEntity(ig.IG_RtmHandle);

        if ( dwErr != NO_ERROR ) {

            TRACE1(STOP, "error %d deregistering from RTM", dwErr);
        }    
    }
        

    if (ig.IG_ActivitySemaphore != NULL) {

        CloseHandle(ig.IG_ActivitySemaphore);
        ig.IG_ActivitySemaphore = NULL;
    }


    if (ig.IG_IpripInputEvent != NULL) {

        CloseHandle(ig.IG_IpripInputEvent);
        ig.IG_IpripInputEvent = NULL;
    }



    if (ig.IG_RecvQueue != NULL) {

        if (LOCKED_LIST_CREATED(ig.IG_RecvQueue)) {

            FlushRecvQueue(ig.IG_RecvQueue);

            DELETE_LOCKED_LIST(ig.IG_RecvQueue, RECV_QUEUE_ENTRY, RQE_Link);
        }

        RIP_FREE(ig.IG_RecvQueue);
        ig.IG_RecvQueue = NULL;
    }


    if (ig.IG_SendQueue != NULL) {

        if (LOCKED_LIST_CREATED(ig.IG_SendQueue)) {

            FlushSendQueue(ig.IG_SendQueue);

            DELETE_LOCKED_LIST(ig.IG_SendQueue, SEND_QUEUE_ENTRY, SQE_Link);
        }

        RIP_FREE(ig.IG_SendQueue);
        ig.IG_SendQueue = NULL;
    }


    if (ig.IG_BindingTable != NULL) {
        if (BINDING_TABLE_CREATED(ig.IG_BindingTable)) {
            DeleteBindingTable(ig.IG_BindingTable);
        }

        RIP_FREE(ig.IG_BindingTable);
        ig.IG_BindingTable = NULL;
    }


    if (ig.IG_PeerTable != NULL) {

        if (PEER_TABLE_CREATED(ig.IG_PeerTable)) {
            DeletePeerTable(ig.IG_PeerTable);
        }

        RIP_FREE(ig.IG_PeerTable);
        ig.IG_PeerTable = NULL;
    }


    if (ig.IG_IfTable != NULL) {

        if (IF_TABLE_CREATED(ig.IG_IfTable)) {
            DeleteIfTable(ig.IG_IfTable);
        }

        RIP_FREE(ig.IG_IfTable);
        ig.IG_IfTable = NULL;
    }


    if (READ_WRITE_LOCK_CREATED(&ig.IG_RWL)) {
        DeleteReadWriteLock(&ig.IG_RWL);
    }


    if (bCleanupWinsock) {
        WSACleanup();
    }


    if (ig.IG_Config != NULL) {

        RIP_FREE(ig.IG_Config);
        ig.IG_Config = NULL;
    }


    ig.IG_Status = IPRIP_STATUS_STOPPED;

    // LeaveCriticalSection(&ig.IG_CS);

    return NO_ERROR;

}




//----------------------------------------------------------------------------
// Function:    RegisterProtocol
//
// Returns protocol ID and functionality for IPRIP
//----------------------------------------------------------------------------

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    if(pRoutingChar->dwProtocolId != MS_IP_RIP)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Since we are not a service advertiser (and IPX thing)
    //

    pServiceChar->fSupportedFunctionality = 0;

    if((pRoutingChar->fSupportedFunctionality & (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES)) !=
       (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES))
    {
        return ERROR_NOT_SUPPORTED;
    }

    pRoutingChar->fSupportedFunctionality = (RF_ROUTING | RF_DEMAND_UPDATE_ROUTES);

   pRoutingChar->fSupportedFunctionality = RF_ROUTING;

   pRoutingChar->pfnStartProtocol      = StartProtocol;
   pRoutingChar->pfnStartComplete      = StartComplete;
   pRoutingChar->pfnStopProtocol       = StopProtocol;
   pRoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
   pRoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
   pRoutingChar->pfnQueryPower         = NULL;
   pRoutingChar->pfnSetPower           = NULL;

   pRoutingChar->pfnAddInterface       = AddInterface;
   pRoutingChar->pfnDeleteInterface    = DeleteInterface;
   pRoutingChar->pfnInterfaceStatus    = InterfaceStatus;
   pRoutingChar->pfnGetInterfaceInfo   = GetInterfaceConfigInfo;
   pRoutingChar->pfnSetInterfaceInfo   = SetInterfaceConfigInfo;

   pRoutingChar->pfnGetEventMessage    = GetEventMessage;

   pRoutingChar->pfnUpdateRoutes       = DoUpdateRoutes;

   pRoutingChar->pfnConnectClient      = NULL;
   pRoutingChar->pfnDisconnectClient   = NULL;

   pRoutingChar->pfnGetNeighbors       = NULL;
   pRoutingChar->pfnGetMfeStatus       = NULL;

   pRoutingChar->pfnMibCreateEntry     = MibCreate;
   pRoutingChar->pfnMibDeleteEntry     = MibDelete;
   pRoutingChar->pfnMibGetEntry        = MibGet;
   pRoutingChar->pfnMibSetEntry        = MibSet;
   pRoutingChar->pfnMibGetFirstEntry   = MibGetFirst;
   pRoutingChar->pfnMibGetNextEntry    = MibGetNext;

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    StartProtocol
//
// creates events, tables and queues used by IPRIP, registers with RTM,
// and starts threads.
//----------------------------------------------------------------------------

DWORD
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    ig.IG_SupportFunctions = *SupportFunctions;
    
    return ProtocolStartup(NotificationEvent, GlobalInfo);
}


//----------------------------------------------------------------------------
// Function:    StartComplete
//
// Invoked by RouterManager to inform protocol that startup (init + interface
// additions are complete).  Protocol is expected to wait for this before
// starting protocol specfic behavior
//----------------------------------------------------------------------------

DWORD
APIENTRY 
StartComplete(
    VOID
    )
{
    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    StopProtocol
//
// This function is onvoked by Router Manager. It informs the main thread
// that it should exit, and then queues a work-item which waits for it
// to exit as well as any active or queued work-items.
//----------------------------------------------------------------------------

DWORD
APIENTRY
StopProtocol(
    VOID
    ) {

    LONG lThreadCount;



    EnterCriticalSection(&ig.IG_CS);


    //
    // cannot stop if already stopped
    //

    if (ig.IG_Status != IPRIP_STATUS_RUNNING) {

        LeaveCriticalSection(&ig.IG_CS);
        return ERROR_CAN_NOT_COMPLETE;
    }



    TRACE0(ENTER, "entering StopProtocol");


    //
    // set IPRIP's status to STOPPING;
    // this prevents any more work-items from being queued,
    // and it prevents the ones already queued from executing
    //

    ig.IG_Status = IPRIP_STATUS_STOPPING;


    //
    // find out how many threads are active in IPRIP;
    // we will have to wait for this many threads to exit
    // before we clean up RIP's resources
    //

    lThreadCount = ig.IG_ActivityCount;

    TRACE1(STOP, "%d threads are active in IPRIP", lThreadCount);


    LeaveCriticalSection(&ig.IG_CS);


    //
    // queue the stopprotocol work-item, and return PENDING to Router Manager
    //

    QueueUserWorkItem(
        (LPTHREAD_START_ROUTINE)WorkerFunctionFinishStopProtocol,
        (PVOID)UlongToPtr(lThreadCount), 0
        );



    TRACE0(LEAVE, "leaving StopProtocol");

    return ERROR_PROTOCOL_STOP_PENDING;
}



//----------------------------------------------------------------------------
// Function:    GetGlobalInfo
//
// Copies to the given buffer the global information currently in use by
// IPRIP.
//----------------------------------------------------------------------------

DWORD WINAPI
GetGlobalInfo (
    PVOID   OutGlobalInfo,
    PULONG  GlobalInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }


    TRACE2(ENTER, "entering GetGlobalInfo: 0x%08x 0x%08x", OutGlobalInfo, GlobalInfoSize);


    dwErr = NO_ERROR;


    ACQUIRE_GLOBAL_LOCK_SHARED();


    do {


        //
        // check the arguments
        //

        if (GlobalInfoSize == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pgcsrc = ig.IG_Config;
        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // check the buffer size
        //

        if (*GlobalInfoSize < dwSize || OutGlobalInfo == NULL) {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
            pgcdst = (PIPRIP_GLOBAL_CONFIG)OutGlobalInfo;

            *StructureVersion    = 1;
            *StructureSize       = dwSize;
            *StructureCount      = 1;

            CopyMemory(pgcdst, pgcsrc, dwSize);
        }

        *GlobalInfoSize = dwSize;

    } while(FALSE);

    RELEASE_GLOBAL_LOCK_SHARED();


    TRACE1(LEAVE, "leaving GetGlobalInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetGlobalInfo
//
// Changes IPRIP's global configuration to the supplied values.
//----------------------------------------------------------------------------

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering SetGlobalInfo: 0x%08x", GlobalInfo);

    dwErr = NO_ERROR;


    ACQUIRE_GLOBAL_LOCK_EXCLUSIVE();


    do {

        //
        // check the argument
        //

        if (GlobalInfo == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pgcsrc = (PIPRIP_GLOBAL_CONFIG)GlobalInfo;


        //
        // find the size of the new global config
        //

        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // allocate space for the private copy of the config
        //

        pgcdst = (PIPRIP_GLOBAL_CONFIG)RIP_ALLOC(dwSize);

        if (pgcdst == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for global config",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy from the buffer
        //

        CopyMemory(pgcdst, pgcsrc, dwSize);
        InterlockedExchange(&ig.IG_LogLevel, pgcsrc->GC_LoggingLevel);

        if (ig.IG_Config != NULL) { RIP_FREE(ig.IG_Config); }

        ig.IG_Config = pgcdst;


    } while(FALSE);


    RELEASE_GLOBAL_LOCK_EXCLUSIVE();


    TRACE1(LEAVE, "leaving SetGlobalInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    AddInterface
//
// This function is called to add an interface with the given configuration
// to IPRIP. The interface is created inactive.
//----------------------------------------------------------------------------

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering AddInterface: %d %d 0x%08x", InterfaceIndex, InterfaceType, InterfaceInfo
        );



    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = CreateIfEntry(ig.IG_IfTable, InterfaceIndex, InterfaceType, InterfaceInfo, NULL);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving AddInterface: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeleteInterface
//
// This removes the interface with the given index, deactivating it if
// necessary.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering DeleteInterface: %d", dwIndex);


    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = DeleteIfEntry(ig.IG_IfTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving DeleteInterface: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetEventMessage
//
// Dequeues a message for Router Manager from IPRIP's event queue.
//----------------------------------------------------------------------------

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT PMESSAGE pResult
    ) {

    DWORD dwErr;



    //
    // note that GetEventMessage does not use the
    // ENTER_RIP_API()/LEAVE_RIP_API() mechanism,
    // since it may be called after RIP has stopped, when the
    // Router Manager is retrieving the ROUTER_STOPPED message
    //

    TRACE2(ENTER, "entering GetEventMessage: 0x%08x 0x%08x", pEvent, pResult);


    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);


    dwErr = DequeueEvent(ig.IG_EventQueue, pEvent, pResult);


    RELEASE_LIST_LOCK(ig.IG_EventQueue);



    TRACE1(LEAVE, "leaving GetEventMessage: %d", dwErr);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetInterfaceConfigInfo
//
// Copies to the caller's buffer the configuration for the interface
// with the specified index.
//----------------------------------------------------------------------------

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG picsrc, picdst;


    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering GetInterfaceConfigInfo: %d 0x%08x 0x%08x",
        InterfaceIndex, OutInterfaceInfo, InterfaceInfoSize
        );



    dwErr = NO_ERROR;

    do {

        //
        // check the arguments
        //

        if (InterfaceInfoSize == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pTable = ig.IG_IfTable;


        ACQUIRE_IF_LOCK_SHARED();


        //
        // find the interface specified
        //

        pite = GetIfByIndex(pTable, InterfaceIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else {


            //
            // get the size of the interface config
            //

            picsrc = pite->ITE_Config;
            dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);


            //
            // check the buffer size
            //

            if (*InterfaceInfoSize < dwSize) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {


                picdst = (PIPRIP_IF_CONFIG)OutInterfaceInfo;


                //
                // copy the interface config, and set the IP address
                //

                CopyMemory(picdst, picsrc, dwSize);


                *StructureVersion    = 1;
                *StructureSize       = dwSize;
                *StructureCount      = 1;

                picdst->IC_State = 0;

                if (IF_IS_ENABLED(pite)) {
                    picdst->IC_State |= IPRIP_STATE_ENABLED;
                }

                if (IF_IS_BOUND(pite)) {
                    picdst->IC_State |= IPRIP_STATE_BOUND;
                }
            }

            *InterfaceInfoSize = dwSize;

        }


        RELEASE_IF_LOCK_SHARED();

    } while(FALSE);



    TRACE1(LEAVE, "leaving GetInterfaceConfigInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetInterfaceConfigInfo
//
// This sets the configuration for the interface with the given index.
//----------------------------------------------------------------------------

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    DWORD dwErr;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(
        ENTER, "entering SetInterfaceConfigInfo: %d, 0x%08x", InterfaceIndex, InterfaceInfo
        );



    dwErr = NO_ERROR;

    do {


        if (InterfaceInfo == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pTable = ig.IG_IfTable;

        ACQUIRE_IF_LOCK_EXCLUSIVE();


        dwErr = ConfigureIfEntry(pTable, InterfaceIndex, InterfaceInfo);


        RELEASE_IF_LOCK_EXCLUSIVE();

    } while(FALSE);



    TRACE1(LEAVE, "leaving SetInterfaceConfigInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;

}

DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    )
{
    DWORD   dwResult;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    switch(StatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO    pBindInfo;

            pBindInfo = (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if(pBindInfo->AddressCount)
            {
                dwResult = BindInterface(InterfaceIndex,
                                         pBindInfo);
            }
            else
            {
                dwResult = UnBindInterface(InterfaceIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            dwResult = EnableInterface(InterfaceIndex);

            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            dwResult = DisableInterface(InterfaceIndex);

            break;

        }

        default:
        {
            RTASSERT(FALSE);

            dwResult = ERROR_INVALID_PARAMETER;
        }
    }

    LEAVE_RIP_API();

    return dwResult;
}



//---------------------------------------------------------------------------
// Function:    BindInterface
//
// This function is called to supply the binding information
// for an interface
//---------------------------------------------------------------------------

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE2(ENTER, "entering BindInterface: %d 0x%08x", dwIndex, pBinding);


    if (pBinding == NULL) {

        TRACE0(IF, "error: binding struct pointer is NULL");
        TRACE1(LEAVE, "leaving BindInterface: %d", ERROR_INVALID_PARAMETER);

        return ERROR_INVALID_PARAMETER;
    }



    //
    // now bind the interface in the interface table
    //


    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = BindIfEntry(pTable, dwIndex, pBinding);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving BindInterface: %d", dwErr);

    return dwErr;
}




//---------------------------------------------------------------------------
// Function:    UnBindInterface
//
// This function removes the binding for an interface.
//---------------------------------------------------------------------------

DWORD
APIENTRY
UnBindInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;

    TRACE1(ENTER, "entering UnBindInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;


    //
    // unbind the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = UnBindIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();


    TRACE1(LEAVE, "leaving UnBindInterface: %d", dwErr);


    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnableInterface
//
// This function starts IPRIP activity over the interface with
// the given index, using the given binding information.
//----------------------------------------------------------------------------

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE1(ENTER, "entering EnableInterface: %d", dwIndex);



    pTable = ig.IG_IfTable;


    //
    // activate the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = EnableIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving EnableInterface: %d", dwErr);

    return dwErr;

}



//----------------------------------------------------------------------------
// Function:    DisableInterface
//
// This function stops IPRIP activity on an interface, also removing
// routes associated with the interface from RTM and purging the network
// of such routes.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE1(ENTER, "entering DisableInterface: %d", dwIndex);



    pTable = ig.IG_IfTable;


    //
    // stop activity on the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = DisableIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving DisableInterface: %d", dwIndex);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DoUpdateRoutes
//
// This function begins a demand-update of routes, by queuing a work-item
// which will send out requests on the specified interface.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering DoUpdateRoutes: %d", dwIndex);


    //
    // queue the work-item; perhaps we could call the function directly,
    // but using a worker-thread lets us return to Router Manager right away
    //

    dwErr = QueueRipWorker(
                WorkerFunctionStartDemandUpdate,
                (PVOID)UlongToPtr(dwIndex)
                );


    TRACE1(LEAVE,"leaving DoUpdateRoutes(), errcode %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibCreate
//
// This function does nothing, since IPRIP does not support creation of
// interface objects via SNMP. However, this could be implemented as a call
// to CreateIfEntry() followed by a call to ActivateIfEntry(), and the input
// data would have to contain the interface's index, configuration,
// and binding.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibCreate: %d 0x%08x", dwInputSize, pInputData);


    dwErr = ERROR_CAN_NOT_COMPLETE;


    TRACE1(LEAVE, "leaving MibCreate: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibDelete
//
// This function does nothing, since IPRIP does not support deletion of
// interface objects via SNMP. This could be implemented as a call to
// DeactivateIfEntry() followed by a call to DeleteIfEntry(), and the
// input data would have to contain the interface's index
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibDelete: %d 0x%08x", dwInputSize, pInputData);


    dwErr = ERROR_CAN_NOT_COMPLETE;


    TRACE1(LEAVE, "leaving MibDelete: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibSet
//
// The function sets global or interface configuration.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_SET_INPUT_DATA pimsid;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibSet: %d 0x%08x", dwInputSize, pInputData);


    dwErr = NO_ERROR;

    do { // breakout loop

        if (pInputData == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        if (dwInputSize < sizeof(IPRIP_MIB_SET_INPUT_DATA)) {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        pimsid = (PIPRIP_MIB_SET_INPUT_DATA)pInputData;

        switch (pimsid->IMSID_TypeID) {

            case IPRIP_GLOBAL_CONFIG_ID: {

                PIPRIP_GLOBAL_CONFIG pigc;


                if (pimsid->IMSID_BufferSize < sizeof(IPRIP_GLOBAL_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                dwErr = SetGlobalInfo(pimsid->IMSID_Buffer,1,0,1);

                if (dwErr == NO_ERROR) {

                    MESSAGE msg = {0, 0, 0};

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue, SAVE_GLOBAL_CONFIG_INFO, msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }

                break;
            }

            case IPRIP_IF_CONFIG_ID: {

                DWORD dwSize;
                PIF_TABLE pTable;
                PIPRIP_IF_CONFIG pic;
                PIF_TABLE_ENTRY pite;

                if (pimsid->IMSID_BufferSize < sizeof(IPRIP_IF_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pic = (PIPRIP_IF_CONFIG)pimsid->IMSID_Buffer;


                pTable = ig.IG_IfTable;


                ACQUIRE_IF_LOCK_EXCLUSIVE();


                //
                // retrieve the interface to be configured
                //

                pite = GetIfByIndex(
                            pTable, pimsid->IMSID_IfIndex
                            );
                if (pite == NULL) {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else {

                    dwErr = ConfigureIfEntry(pTable, pite->ITE_Index, pic);
                }


                //
                // notify Router Manager
                //

                if (dwErr == NO_ERROR) {

                    MESSAGE msg = {0, 0, 0};

                    msg.InterfaceIndex = pite->ITE_Index;

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue, SAVE_INTERFACE_CONFIG_INFO, msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }

                RELEASE_IF_LOCK_EXCLUSIVE();


                break;
            }

            default: {
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }

    } while(FALSE);


    TRACE1(LEAVE, "leaving MibSet: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibGetInternal
//
// Forward declaration of internal implementation function
//----------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    );


//----------------------------------------------------------------------------
// Function:    MibGet
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGet: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_EXACT);

    }


    TRACE1(LEAVE, "leaving MibGet: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetFirst
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats. It differs from
// MibGet() in that it always returns the FIRST entry in whichever table
// is being queried. There is only one entry in the global stats and config
// tables, but the interface config, interface stats, and peer stats tables
// are sorted by IP address; this function returns the first entry from these.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;


    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetFirst: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {
        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_FIRST);
    }


    TRACE1(LEAVE, "leaving MibGetFirst: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetNext
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats. It differs from both
// MibGet() and MibGetFirst(0 in that it always returns the entry AFTER the
// specified in the specified table. Thus, in the interface config, interface
// stats, and peer stats tables, this function supplies the entry after the
// one with the address passed in.
//
// If the end of the table being queried has been reached, this function will
// return the FIRST entry from the NEXT table, where "NEXT" here means the
// table whose ID is one greater than the ID passed in.
// Thus calling MibGetNext() for the last entry in the interface
// stats table (ID==2) will return the first entry in the interface config
// table (ID==3).
//
// In any case, this function writes the required size to pdwOutputSize and
// writes the ID of the object that WOULD have been returned into the output
// buffer.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr, dwOutSize = 0, dwBufSize = 0;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetNext: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwOutSize = *pdwOutputSize;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_NEXT);


        if (dwErr == ERROR_NO_MORE_ITEMS) {

            //
            // need to wrap to the first entry in the next table,
            // if there is a next table
            //

            TRACE1(
                CONFIG, "MibGetNext is wrapping to table %d",
                pimgid->IMGID_TypeID + 1
                );

            *pdwOutputSize = dwOutSize;

            //
            // wrap to next table by incrementing the type ID
            //

            ++pimgid->IMGID_TypeID;
            if (pimgid->IMGID_TypeID <= IPRIP_PEER_STATS_ID) {
            
                dwErr = MibGetInternal(
                            pimgid, pimgod, pdwOutputSize, GETMODE_FIRST
                            );
            }
            --pimgid->IMGID_TypeID;
        }
    }


    TRACE1(LEAVE, "leaving MibGetNext: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetInternal
//
// This handles the actual structure access required to read MIB data.
// Each table supported by IPRIP supports three modes of querying;
// EXACT, FIRST, and NEXT, which correspond to the functions MibGet(),
// MibGetFirst(), and MibGetNext() respectively.
//----------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    ) {


    DWORD dwErr, dwBufferSize, dwSize;
    ULONG ulVersion, ulSize, ulCount;


    dwErr = NO_ERROR;



    //
    // first we use pdwOutputSize to compute the size of the buffer
    // available for storing returned structures (the size of IMGOD_Buffer)
    //

    if (pimgod == NULL) {
        dwBufferSize = 0;
    }
    else {
        if (*pdwOutputSize < sizeof(IPRIP_MIB_GET_OUTPUT_DATA)) {
            dwBufferSize = 0;
        }
        else {
            dwBufferSize = *pdwOutputSize - sizeof(IPRIP_MIB_GET_OUTPUT_DATA) + 1;
        }
    }

    *pdwOutputSize = 0;


    //
    // determine which type of data is to be returned
    //

    switch (pimgid->IMGID_TypeID) {

        case IPRIP_GLOBAL_STATS_ID: {


            //
            // the global stats structure is constant size.
            // there is only one instance, so if the mode is GETMODE_NEXT
            // we always return ERROR_NO_MORE_ITEMS
            //


            PIPRIP_GLOBAL_STATS pigsdst, pigssrc;


            //
            // set the output size required for this entry,
            // as well as the type of data to be returned
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_GLOBAL_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_GLOBAL_STATS_ID; }


            //
            // only GETMODE_EXACT and GETMODE_FIRST are valid for
            // the global stats object, since there is only one entry
            //

            if (dwGetMode == GETMODE_NEXT) {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }


            if (pimgod == NULL) { dwErr = ERROR_INSUFFICIENT_BUFFER; break; }


            //
            // check that the output buffer is big enough
            //

            if (dwBufferSize < sizeof(IPRIP_GLOBAL_STATS)) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // since access to this structure is not synchronized,
                // we must copy it field by field
                //

                pigssrc = &ig.IG_Stats;
                pigsdst = (PIPRIP_GLOBAL_STATS)pimgod->IMGOD_Buffer;

                pigsdst->GS_SystemRouteChanges = pigssrc->GS_SystemRouteChanges;
                pigsdst->GS_TotalResponsesSent = pigssrc->GS_TotalResponsesSent;
            }


            break;
        }



        case IPRIP_GLOBAL_CONFIG_ID: {

            //
            // the global config struct is variable length,
            // so we wait until it has been retrieved
            // before we set the size.
            // furthermore, there is only one global config object,
            // so GETMODE_NEXT doesn't make any sense
            //

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_GLOBAL_CONFIG_ID; }

            if (dwGetMode == GETMODE_NEXT) {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }



            //
            // Use GetGlobalInfo to retrieve the global information.
            // It will decide whether the buffer is large enough,
            // and if not will set the required size. Then all we need do
            // is write out the size set by GetGlobalInfo() and
            // relay its return-value to the caller
            //

            if (pimgod == NULL) {
                dwErr = GetGlobalInfo(NULL, &dwBufferSize, &ulVersion, &ulSize, &ulCount);
            }
            else {

                dwErr = GetGlobalInfo(
                            pimgod->IMGOD_Buffer, &dwBufferSize, &ulVersion, &ulSize, &ulCount
                            );
            }

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             dwBufferSize;

            break;
        }



        case IPRIP_IF_STATS_ID: {


            //
            // the interface statistics struct is fixed-length.
            // there may be multiple instances.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_STATS pissrc, pisdst;



            //
            // set the size needed right away
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_IF_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_STATS_ID; }


            pTable = ig.IG_IfTable;


            ACQUIRE_IF_LOCK_SHARED();


            //
            // retrieve the interface whose stats are to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was not found, it may mean
            // the specified index was invalid, or it may mean
            // that the GETMODE_NEXT was called on the last interface
            // in which case ERROR_NO_MORE_ITEMS was returned.
            // In any case, we make sure dwErr indicates an error
            // and then return the value.
            //
            // if the interface was found but no output buffer was passed,
            // indicate in the error that memory needs to be allocated.
            //
            // otherwise, copy the stats struct of the interface
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else
            if (pimgod == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // set the index of the interface returned
                //

                pimgod->IMGOD_IfIndex = pite->ITE_Index;


                //
                // if the buffer is large enough, copy over the stats
                //

                if (dwBufferSize < sizeof(IPRIP_IF_STATS)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // since access to this structure is not synchronized,
                    // we must copy it field by field
                    //

                    pissrc = &pite->ITE_Stats;
                    pisdst = (PIPRIP_IF_STATS)pimgod->IMGOD_Buffer;

                    pisdst->IS_State = 0;

                    if (IF_IS_ENABLED(pite)) {
                        pisdst->IS_State |= IPRIP_STATE_ENABLED;
                    }

                    if (IF_IS_BOUND(pite)) {
                        pisdst->IS_State |= IPRIP_STATE_BOUND;
                    }


                    pisdst->IS_SendFailures =
                            pissrc->IS_SendFailures;
                    pisdst->IS_ReceiveFailures =
                            pissrc->IS_ReceiveFailures;
                    pisdst->IS_RequestsSent =
                            pissrc->IS_RequestsSent;
                    pisdst->IS_RequestsReceived =
                            pissrc->IS_RequestsReceived;
                    pisdst->IS_ResponsesSent =
                            pissrc->IS_ResponsesSent;
                    pisdst->IS_RequestsReceived =
                            pissrc->IS_RequestsReceived;
                    pisdst->IS_ResponsesReceived =
                            pissrc->IS_ResponsesReceived;
                    pisdst->IS_BadResponsePacketsReceived =
                            pissrc->IS_BadResponsePacketsReceived;
                    pisdst->IS_BadResponseEntriesReceived =
                            pissrc->IS_BadResponseEntriesReceived;
                    pisdst->IS_TriggeredUpdatesSent =
                            pissrc->IS_TriggeredUpdatesSent;
                }
            }

            RELEASE_IF_LOCK_SHARED();


            break;
        }



        case IPRIP_IF_CONFIG_ID: {

            //
            // the interface configuration is variable-length.
            // thus we must actually retrieve the requested interface
            // before we know how large a buffer is needed.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_CONFIG picsrc, picdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_CONFIG_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_IF_LOCK_SHARED();


            //
            // retrieve the interface whose config is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned.
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else {

                //
                // compute the size of the interface config retrieved,
                // and write it over the caller's supplied size
                //

                picsrc = pite->ITE_Config;
                dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);
                *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                                 dwSize;


                //
                // if no buffer was specified, indicate one should be allocated
                //

                if (pimgod == NULL) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {


                    //
                    // if the buffer is not large enough,
                    // indicate that it should be enlarged
                    //

                    if (dwBufferSize < dwSize) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // copy the configuration
                        //

                        picdst = (PIPRIP_IF_CONFIG)pimgod->IMGOD_Buffer;

                        CopyMemory(picdst, picsrc, dwSize);
                        ZeroMemory(
                            picdst->IC_AuthenticationKey, IPRIP_MAX_AUTHKEY_SIZE
                            );

                        picdst->IC_State = 0;

                        if (IF_IS_ENABLED(pite)) {
                            picdst->IC_State |= IPRIP_STATE_ENABLED;
                        }

                        if (IF_IS_BOUND(pite)) {
                            picdst->IC_State |= IPRIP_STATE_BOUND;
                        }
                    }


                    pimgod->IMGOD_IfIndex = pite->ITE_Index;
                }
            }

            RELEASE_IF_LOCK_SHARED();

            break;
        }



        case IPRIP_IF_BINDING_ID: {

            //
            // the interface binding is variable-length
            // thus we must actually retrieve the requested interface
            // before we know how large a buffer is needed.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_BINDING pibsrc, pibdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_BINDING_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_IF_LOCK_SHARED();

            //
            // retrieve the interface whose binding is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned.
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else {

                //
                // compute the size of the interface binding retrieved,
                // and write it over the caller's supplied size
                //

                pibsrc = pite->ITE_Binding;
                dwSize = (pibsrc ? IPRIP_IF_BINDING_SIZE(pibsrc)
                                 : sizeof(IPRIP_IF_BINDING));
                *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                                 dwSize;


                //
                // if no buffer was specified, indicate one should be allocated
                //

                if (pimgod == NULL) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {


                    //
                    // if the buffer is not large enough,
                    // indicate that it should be enlarged
                    //

                    if (dwBufferSize < dwSize) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // copy the binding
                        //

                        pibdst = (PIPRIP_IF_BINDING)pimgod->IMGOD_Buffer;

                        if (pibsrc) { CopyMemory(pibdst, pibsrc, dwSize); }
                        else { pibdst->IB_AddrCount = 0; }

                        pibdst->IB_State = 0;

                        if (IF_IS_ENABLED(pite)) {
                            pibdst->IB_State |= IPRIP_STATE_ENABLED;
                        }

                        if (IF_IS_BOUND(pite)) {
                            pibdst->IB_State |= IPRIP_STATE_BOUND;
                        }
                    }


                    pimgod->IMGOD_IfIndex = pite->ITE_Index;
                }
            }

            RELEASE_IF_LOCK_SHARED();

            break;
        }

        case IPRIP_PEER_STATS_ID: {


            //
            // the peer statistics struct is fixed-length.
            //

            DWORD dwAddress;
            PPEER_TABLE pTable;
            PPEER_TABLE_ENTRY ppte;
            PIPRIP_PEER_STATS ppssrc, ppsdst;


            //
            // set the output size right away
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_PEER_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_PEER_STATS_ID; }


            pTable = ig.IG_PeerTable;
            dwAddress = pimgid->IMGID_PeerAddress;


            ACQUIRE_PEER_LOCK_SHARED();


            //
            // retrieve the peer specified
            //

            ppte = GetPeerByAddress(pTable, dwAddress, dwGetMode, &dwErr);



            //
            // if no struct was returned, it means that either
            // an invalid address was specifed, or GETMODE_NExT
            // was attempted on the last peer.
            // In either case, we return an error code.
            //
            // if no buffer was specifed, return ERROR_INSUFFICIENT_BUFFER
            // to indicate to the caller that a buffer should be allocated
            //

            if (ppte == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else
            if (pimgod == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // save the address of the peer retrieved
                //

                pimgod->IMGOD_PeerAddress = ppte->PTE_Address;


                //
                // if the buffer is not large enough,
                // return an error to indicate it should be enlarged
                //

                if (dwBufferSize < sizeof(IPRIP_PEER_STATS)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // since access to this structure is not synchronized,
                    // we must copy it field by field
                    //

                    ppssrc = &ppte->PTE_Stats;
                    ppsdst = (PIPRIP_PEER_STATS)pimgod->IMGOD_Buffer;

                    ppsdst->PS_LastPeerRouteTag =
                            ppssrc->PS_LastPeerRouteTag;
                    ppsdst->PS_LastPeerUpdateTickCount =
                            ppssrc->PS_LastPeerUpdateTickCount;
                    ppsdst->PS_LastPeerUpdateVersion =
                            ppssrc->PS_LastPeerUpdateVersion;
                    ppsdst->PS_BadResponsePacketsFromPeer =
                            ppssrc->PS_BadResponsePacketsFromPeer;
                    ppsdst->PS_BadResponseEntriesFromPeer =
                            ppssrc->PS_BadResponseEntriesFromPeer;
                }
            }

            RELEASE_PEER_LOCK_SHARED();


            break;

        }

        default: {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nathlp\test\nhtest.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <mswsock.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ipnatapi.h>

HANDLE Event;


VOID
ReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    printf(
        "ReadCompletionRoutine: e=%u, b=%u, '%s'\n",
        ErrorCode, BytesTransferred, Bufferp->Buffer
        );
    NhReleaseBuffer(Bufferp);
    SetEvent(Event);
}

VOID
WriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    printf(
        "WriteCompletionRoutine: e=%u, b=%u, %08x\n",
        ErrorCode, BytesTransferred, Bufferp
        );
    NhReleaseBuffer(Bufferp);
    SetEvent(Event);
}


VOID
AcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    SOCKET AcceptedSocket;
    SOCKET ListeningSocket;
    printf(
        "AcceptCompletionRoutine: e=%u, b=%u\n",
        ErrorCode, BytesTransferred
        );
    ListeningSocket = (SOCKET)Bufferp->Context;
    AcceptedSocket = (SOCKET)Bufferp->Context2;
    ErrorCode =
        setsockopt(
            AcceptedSocket,
            SOL_SOCKET,
            SO_UPDATE_ACCEPT_CONTEXT,
            (PCHAR)&ListeningSocket,
            sizeof(ListeningSocket)
            );
    if (ErrorCode == SOCKET_ERROR) {
        printf("error %d updating accept context\n", WSAGetLastError());
        NhReleaseBuffer(Bufferp);
        SetEvent(Event);
    } else {
        ErrorCode =
            NhReadStreamSocket(
                NULL,
                AcceptedSocket,
                Bufferp,
                NH_BUFFER_SIZE,
                0,
                ReadCompletionRoutine,
                NULL,
                NULL
                );
        if (ErrorCode != NO_ERROR) {
            printf("error %d reading from accepted socket\n", ErrorCode);
            NhReleaseBuffer(Bufferp);
            SetEvent(Event);
        }
    }
}

VOID
TestApiCompletionRoutine(
    HANDLE RedirectHandle,
    BOOLEAN Cancelled,
    PVOID CompletionContext
    )
{
    NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
    ULONG Error;
    ULONG Length = sizeof(ByteCount);
    printf("TestApiCompletionRoutine=%x,%d\n", RedirectHandle, Cancelled);
    Error =
        NatQueryInformationRedirectHandle(
            RedirectHandle,
            &ByteCount,
            &Length,
            NatByteCountRedirectInformation
            );
    printf(
        "TestApiCompletionRoutine=%d,bc={%I64d,%I64d},l=%d\n",
        Error, ByteCount.BytesForward, ByteCount.BytesReverse, Length
        );
}


VOID
TestRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreateRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            inet_addr(argv[7]),
            htons((USHORT)atol(argv[8])),
            inet_addr(argv[9]),
            htons((USHORT)atol(argv[10])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreateRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)atol(argv[8])),
                    inet_addr(argv[9]),
                    htons((USHORT)atol(argv[10])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            inet_addr(argv[7]),
                            htons((USHORT)atol(argv[8])),
                            inet_addr(argv[9]),
                            htons((USHORT)atol(argv[10])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationRedirect=%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)atol(argv[8])),
                    inet_addr(argv[9]),
                    htons((USHORT)atol(argv[10]))
                    );
            printf("NatCancelRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePartialRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePartialRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePortRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePortRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                NAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping;
                ULONG Length;
                CHAR src[32], newsrc[32], dst[32], newdst[32];
                Length = sizeof(SourceMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                Length = sizeof(DestinationMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &DestinationMapping,
                    &Length,
                    NatDestinationMappingRedirectInformation
                    );
                lstrcpyA(
                    dst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.DestinationAddress)
                    );
                lstrcpyA(
                    newdst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.NewDestinationAddress)
                    );
                printf("redirect activated: %s:%s->%s:%s\n", src, dst, newsrc, newdst);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPortRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            htons((USHORT)atol(argv[3])),
                            inet_addr(argv[4]),
                            htons((USHORT)atol(argv[5])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPortRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5]))
                    );
            printf("NatCancelPortRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestReceiveOnlyPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePortRedirect(
            TranslatorHandle,
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePortRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                NAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping;
                ULONG Length;
                CHAR src[32], newsrc[32], dst[32], newdst[32];
                Length = sizeof(SourceMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                Length = sizeof(DestinationMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &DestinationMapping,
                    &Length,
                    NatDestinationMappingRedirectInformation
                    );
                lstrcpyA(
                    dst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.DestinationAddress)
                    );
                lstrcpyA(
                    newdst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.NewDestinationAddress)
                    );
                printf("redirect activated: %s:%s->%s:%s\n", src, dst, newsrc, newdst);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPortRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            htons((USHORT)atol(argv[3])),
                            inet_addr(argv[4]),
                            htons((USHORT)atol(argv[5])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPortRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5]))
                    );
            printf("NatCancelPortRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestReceiveOnlyDynamicPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE DynamicRedirectHandle;

    Error =
        NatCreateDynamicPartialRedirect(
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            atol(argv[7]),
            &DynamicRedirectHandle
            );
    printf("NatCreateDynamicPartialRedirect=%d\n", Error);
    if (!Error) {
        printf("Press <Enter> to cancel the dynamic redirect...");
        while (!_kbhit()) { Sleep(1000); }
        Error = NatCancelDynamicPartialRedirect(DynamicRedirectHandle);
        printf("NatCancelDynamicPartialRedirect=%d\n", Error);
    }
    printf("done\n");
}


VOID
TestReceiveOnlyDynamicPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE DynamicRedirectHandle;

    Error =
        NatCreateDynamicPortRedirect(
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            atol(argv[6]),
            &DynamicRedirectHandle
            );
    printf("NatCreateDynamicPortRedirect=%d\n", Error);
    if (!Error) {
        printf("Press <Enter> to cancel the dynamic redirect...");
        while (!_kbhit()) { Sleep(1000); }
        Error = NatCancelDynamicPortRedirect(DynamicRedirectHandle);
        printf("NatCancelDynamicPortRedirect=%d\n", Error);
    }
    printf("done\n");
}


VOID
TestRestrictedPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreateRestrictedPartialRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            inet_addr(argv[7]),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreateRestrictedPartialRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestDuplicateRedirect(
    int argc,
    char* argv[]
    )
{
#define REDIRECT_COUNT 5
    ULONG Count;
    ULONG Error;
    HANDLE EventHandle[REDIRECT_COUNT];
    ULONG i;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    for (i = 0, Count = 0; i < REDIRECT_COUNT; i++) {
        EventHandle[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        Error =
            NatCreateRedirect(
                TranslatorHandle,
                0,
                (UCHAR)atol(argv[2]),
                inet_addr(argv[3]),
                htons((USHORT)atol(argv[4])),
                0,
                0,
                inet_addr(argv[5]),
                htons((USHORT)atol(argv[6])),
                inet_addr(argv[7]),
                htons((USHORT)(atol(argv[8]) + i)),
                TestApiCompletionRoutine,
                NULL,
                EventHandle[i]
                );
        printf("NatCreateRedirect=%d\n", Error);
        if (!Error) { ++Count; }
    }
    for (;;) {
        ULONG Error2;
        Error =
            WaitForMultipleObjectsEx(
                REDIRECT_COUNT,
                EventHandle,
                FALSE,
                1000,
                TRUE
                );
        printf("WaitForSingleObjectEx=%d\n", Error);
        if (Error == WAIT_IO_COMPLETION) {
            if (!--Count) { break; }
        } else if ((Error - WAIT_OBJECT_0) < REDIRECT_COUNT) {
            NAT_KEY_SESSION_MAPPING_INFORMATION Key;
            ULONG Length = sizeof(Key);
            CHAR src[32], newsrc[32];
            i = Error - WAIT_OBJECT_0;
            Error2 =
                NatLookupAndQueryInformationSessionMapping(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)(atol(argv[8]) + i)),
                    &Key,
                    &Length,
                    NatKeySessionMappingInformation
                    );
            lstrcpyA(
                src,
                inet_ntoa(*(PIN_ADDR)&Key.SourceAddress)
                );
            lstrcpyA(
                newsrc,
                inet_ntoa(*(PIN_ADDR)&Key.NewSourceAddress)
                );
            printf("redirect activated[%d]: %s->%s\n", Error2, src, newsrc);
        }
        if (_kbhit()) {
            switch(getchar()) {
                case 'q': { break; }
                case 's': {
                    NAT_STATISTICS_SESSION_MAPPING_INFORMATION Statistics;
                    for (i = 0; i < REDIRECT_COUNT; i++) {
                        ULONG Length = sizeof(Statistics);
                        Error2 =
                            NatLookupAndQueryInformationSessionMapping(
                                TranslatorHandle,
                                (UCHAR)atol(argv[2]),
                                inet_addr(argv[5]),
                                htons((USHORT)atol(argv[6])),
                                inet_addr(argv[7]),
                                htons((USHORT)(atol(argv[8]) + i)),
                                &Statistics,
                                &Length,
                                NatStatisticsSessionMappingInformation
                                );
                        printf(
                            "NatLookupAndQueryInformationSessionMapping=%d,{%I64d,%I64d}\n",
                            Error2,
                            Statistics.BytesForward,
                            Statistics.BytesReverse
                            );
                    }
                    // fall-through
                }
                default: continue;
            }
            break;
        }
    }
    if (Error != WAIT_IO_COMPLETION) {
        for (i = 0; i < REDIRECT_COUNT; i++) {
            Error =
                NatCancelRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    0,
                    0,
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)(atol(argv[8]) + i))
                    );
            printf("NatCancelRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}



VOID
TestDatagramIo(
    int argc,
    char* argv[]
    )
{
    SOCKET Socket;
    NhInitializeTraceManagement();
    NhInitializeBufferManagement();
    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (lstrcmpiA(argv[1], "-s") == 0) {
        NhCreateDatagramSocket(
            inet_addr(argv[2]),
            htons(1000),
            &Socket
            );
        NhReadDatagramSocket(
            NULL,
            Socket,
            NULL,
            ReadCompletionRoutine,
            NULL,
            NULL
            );
    } else if (lstrcmpiA(argv[1], "-c") == 0) {
        PNH_BUFFER Bufferp;
        NhCreateDatagramSocket(
            inet_addr(argv[2]),
            0,
            &Socket
            );
        Bufferp = NhAcquireBuffer();
        lstrcpyA(Bufferp->Buffer, "client-to-server message");
        NhWriteDatagramSocket(
            NULL,
            Socket,
            inet_addr(argv[3]),
            htons(1000),
            Bufferp,
            lstrlenA(Bufferp->Buffer),
            WriteCompletionRoutine,
            NULL,
            NULL
            );
    }
    WaitForSingleObject(Event, INFINITE);
    NhDeleteDatagramSocket(Socket);
}


VOID
TestStreamIo(
    int argc,
    char* argv[]
    )
{
    SOCKET AcceptedSocket;
    ULONG Error;
    SOCKET ListeningSocket;
    NhInitializeTraceManagement();
    NhInitializeBufferManagement();
    Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    Error = NhCreateStreamSocket(INADDR_ANY, htons(1000), &ListeningSocket);
    if (Error != NO_ERROR) {
        printf("error %d creating listening socket\n", Error);
    } else {
        Error = NhCreateStreamSocket(INADDR_NONE, 0, &AcceptedSocket);
        if (Error != NO_ERROR) {
            printf("error %d creating accepted socket\n", Error);
        } else {
            Error = listen(ListeningSocket, SOMAXCONN);
            if (Error == SOCKET_ERROR) {
                printf("error %d listening on socket\n", WSAGetLastError());
            } else {
                Error =
                    NhAcceptStreamSocket(
                        NULL,
                        ListeningSocket,
                        AcceptedSocket,
                        NULL,
                        AcceptCompletionRoutine,
                        (PVOID)ListeningSocket,
                        (PVOID)AcceptedSocket
                        );
                if (Error != NO_ERROR) {
                    printf("error %d accepting on socket\n", WSAGetLastError());
                } else {
                    WaitForSingleObject(Event, INFINITE);
                }
            }
            NhDeleteStreamSocket(AcceptedSocket);
        }
        NhDeleteStreamSocket(ListeningSocket);
    }
}


VOID
TestNotification(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;
    IP_NAT_ROUTING_FAILURE_NOTIFICATION RoutingFailureNotification;
    NTSTATUS status;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    printf("waiting for notification...");
    RequestNotification.Code = NatRoutingFailureNotification;
    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            NULL,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_REQUEST_NOTIFICATION,
            (PVOID)&RequestNotification,
            sizeof(RequestNotification),
            &RoutingFailureNotification,
            sizeof(RoutingFailureNotification)
            );
    if (status == STATUS_PENDING) {
        NtWaitForSingleObject(TranslatorHandle, FALSE, NULL);
        status = IoStatus.Status;
    }
    {
        CHAR address[32];
        lstrcpyA(
            address,
            inet_ntoa(*(PIN_ADDR)&RoutingFailureNotification.DestinationAddress)
            );
        printf(
            "status=%x,destination=%s,source=%s\n", status, address,
            inet_ntoa(*(PIN_ADDR)&RoutingFailureNotification.SourceAddress)
            );
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestIoCompletionPartialRedirect(
    int argc,
    char* argv[]
    )
{
    IP_NAT_CREATE_REDIRECT CreateRedirect;
    ULONG Error;
    FILE_COMPLETION_INFORMATION CompletionInformation;
    HANDLE IoCompletionHandle;
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_REDIRECT_STATISTICS RedirectStatistics;
    NTSTATUS status;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    status =
        NtCreateIoCompletion(
            &IoCompletionHandle,
            IO_COMPLETION_ALL_ACCESS,
            NULL,
            0
            );
    if (!NT_SUCCESS(status)) {
        printf("NtCreateIoCompletion=%x\n", status);
        return;
    }

    CompletionInformation.Port = IoCompletionHandle;
    CompletionInformation.Key = (PVOID)0xAB01ADE9;
    status =
        NtSetInformationFile(
            TranslatorHandle,
            &IoStatus,
            &CompletionInformation,
            sizeof(CompletionInformation),
            FileCompletionInformation
            );
    if (!NT_SUCCESS(status)) {
        printf("NtSetInformationFile=%x\n", status);
        return;
    }

    ZeroMemory(&CreateRedirect, sizeof(CreateRedirect));
    CreateRedirect.Flags =
        IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS|
        IP_NAT_REDIRECT_FLAG_IO_COMPLETION;
    CreateRedirect.Protocol = (UCHAR)atol(argv[2]);
    CreateRedirect.DestinationAddress = inet_addr(argv[3]);
    CreateRedirect.DestinationPort = htons((USHORT)atol(argv[4]));
    CreateRedirect.NewDestinationAddress = inet_addr(argv[5]);
    CreateRedirect.NewDestinationPort = htons((USHORT)atol(argv[6]));

    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            Event,
            NULL,
            (PVOID)0x12345678,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_REDIRECT,
            &CreateRedirect,
            sizeof(CreateRedirect),
            &RedirectStatistics,
            sizeof(RedirectStatistics)
            );
    if (status != STATUS_PENDING) {
        printf("NtDeviceIoControlFile=%x\n", status);
    } else {
        PVOID ApcContext;
        PVOID KeyContext;
        LARGE_INTEGER Timeout;
        Timeout.LowPart = (1000 * 1000 * 10);
        Timeout.HighPart = 0;
        Timeout = RtlLargeIntegerNegate(Timeout);
        IoStatus.Status = STATUS_CANCELLED;
        for (;;) {
            status =
                NtRemoveIoCompletion(
                    IoCompletionHandle,
                    &KeyContext,
                    &ApcContext,
                    &IoStatus,
                    &Timeout
                    );
            printf("NtRemoveIoCompletion=%x\n", status);
            if (status == STATUS_SUCCESS &&
                IoStatus.Status != STATUS_PENDING) {
                //
                // Redirect completed.
                //
                printf("redirect %x:%x completed\n", KeyContext, ApcContext);
                break;
            } else if (status == STATUS_SUCCESS &&
                       IoStatus.Status == STATUS_PENDING) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                //
                // Redirect is activated.
                //
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf(
                    "redirect %x:%x activated: %s->%s\n",
                    KeyContext, ApcContext, src, newsrc
                    );
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (status != STATUS_SUCCESS) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    NtClose(IoCompletionHandle);
    printf("done\n");
}


VOID
TestPortReservation(
    int argc,
    char* argv[]
    )
{
    HANDLE ReservationHandle;
    for (;;) {
        enum {
            PrInitialize,
            PrAcquire,
            PrRelease,
            PrQuit
        } PrOption;
        NTSTATUS Status;
        printf("Options:\n");
        printf("%d - initialize\n", PrInitialize);
        printf("%d - acquire ports\n", PrAcquire);
        printf("%d - release ports\n", PrRelease);
        printf("%d - quit\n", PrQuit);
        printf("> ");
        scanf("%d", &PrOption);
        switch(PrOption) {
            case PrInitialize: {
                USHORT BlockSize;
                printf("enter block size: ");
                scanf("%u", &BlockSize);
                Status =
                    NatInitializePortReservation(BlockSize, &ReservationHandle);
                if (NT_SUCCESS(Status)) {
                    printf("succeeded.\n");
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrAcquire: {
                USHORT PortBase;
                USHORT PortCount;
                printf("enter port count: ");
                scanf("%u", &PortCount);
                Status =
                    NatAcquirePortReservation(
                        ReservationHandle, PortCount, &PortBase
                        );
                if (NT_SUCCESS(Status)) {
                    printf("succeeded: base port %d\n", ntohs(PortBase));
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrRelease: {
                USHORT PortBase;
                USHORT PortCount;
                printf("enter base port: ");
                scanf("%u", &PortBase);
                printf("enter port count: ");
                scanf("%u", &PortCount);
                Status =
                    NatReleasePortReservation(
                        ReservationHandle, ntohs(PortBase), PortCount
                        );
                if (NT_SUCCESS(Status)) {
                    printf("succeeded\n", ntohs(PortBase));
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrQuit: {
                NatShutdownPortReservation(ReservationHandle);
                break;
            }
        }
    }
}


int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    WSADATA wd;
    WSAStartup(MAKEWORD(2,2), &wd);
    if (!lstrcmpiA(argv[1], "-accept") && argc == 2) {
        TestStreamIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-c") && argc == 4) {
        TestDatagramIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-s") && argc == 3) {
        TestDatagramIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-n") && argc == 2) {
        TestNotification(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-r") && argc == 11) {
        TestRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-p") && argc == 7) {
        TestPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-port") && argc == 6) {
        TestPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvport") && argc == 6) {
        TestReceiveOnlyPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rp") && argc == 8) {
        TestRestrictedPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-m") && argc == 9) {
        TestDuplicateRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-iop") && argc == 7) {
        TestIoCompletionPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-portreservation") && argc == 2) {
        TestPortReservation(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvdynport") && argc == 7) {
        TestReceiveOnlyDynamicPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvdynp") && argc == 7) {
        TestReceiveOnlyDynamicPartialRedirect(argc, argv);
    } else {
        printf("'nhtest -accept' to test connection-acceptance\n");
        printf("'nhtest -c <client-addr> <server-addr>' to start client\n");
        printf("'nhtest -s <server-addr>' to start server\n");
        printf("'nhtest -n' to wait for notification of routing-failure\n");
        printf("'nhtest -r <p> <da> <dp> <sa> <sp> <da> <dp> <sa> <sp>'\n");
        printf("    creates a full-redirect and waits for activation.\n");
        printf("'nhtest -p <p> <da> <dp> <da> <dp>'\n");
        printf("    creates a partial-redirect and waits for activation.\n");
        printf("'nhtest -port <p> <dp> <da> <dp>'\n");
        printf("    creates a port-redirect and waits for activation.\n");
        printf("'nhtest -rcvport <p> <dp> <da> <dp>'\n");
        printf("    creates a port-redirect for received-packets only\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -rp <p> <da> <dp> <da> <dp> <sa>'\n");
        printf("    creates a restricted partial-redirect\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -m <p> <da> <dp> <da> <dp> <sa> <sp>'\n");
        printf("    creates multiple redirects with the same parameters,\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -iop <p> <da> <dp> <da> <dp>'\n");
        printf("    creates a restricted partial-redirect,\n");
        printf("    associates it with an I/O completion port,\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -portreservation'\n");
        printf("    launches interactive port-reservation API test shell\n");
        printf("'nhtest -rcvdynport <p> <dp> <da> <dp> <backlog>'\n");
        printf("    creates a dynamic port-redirect for received-packets\n");
        printf("    only and waits for interruption.\n");
        printf("'nhtest -rcvdynp <p> <da> <dp> <da> <dp> <backlog>'\n");
        printf("    creates a dynamic partial-redirect for received-packets\n");
        printf("    only and waits for interruption.\n");
    }
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\defs.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: defs.h
//
// History:
//      Abolade Gbadegesin  Aug-7-1995  Created.
//
// Contains miscellaneous definitions and declarations
//============================================================================


#ifndef _DEFS_H_
#define _DEFS_H_


//
// type definitions for IPRIP network packet templates
//

#pragma pack(1)


typedef struct _IPRIP_HEADER {

    BYTE    IH_Command;
    BYTE    IH_Version;
    WORD    IH_Reserved;

} IPRIP_HEADER, *PIPRIP_HEADER;



typedef struct _IPRIP_ENTRY {

    WORD    IE_AddrFamily;
    WORD    IE_RouteTag;
    DWORD   IE_Destination;
    DWORD   IE_SubnetMask;
    DWORD   IE_Nexthop;
    DWORD   IE_Metric;

} IPRIP_ENTRY, *PIPRIP_ENTRY;



typedef struct _IPRIP_AUTHENT_ENTRY {

    WORD    IAE_AddrFamily;
    WORD    IAE_AuthType;
    BYTE    IAE_AuthKey[IPRIP_MAX_AUTHKEY_SIZE];

} IPRIP_AUTHENT_ENTRY, *PIPRIP_AUTHENT_ENTRY;



#pragma pack()



#define ADDRFAMILY_REQUEST      0
#define ADDRFAMILY_INET         ntohs(AF_INET)
#define ADDRFAMILY_AUTHENT      0xFFFF
#define MIN_PACKET_SIZE         (sizeof(IPRIP_HEADER) + sizeof(IPRIP_ENTRY))
#define MAX_PACKET_SIZE         512
#define MAX_PACKET_ENTRIES                                                  \
            ((MAX_PACKET_SIZE - sizeof(IPRIP_HEADER)) / sizeof(IPRIP_ENTRY))
#define MAX_UPDATE_REQUESTS     3

//
// this structure exists so that a RIP packet can be copied
// via structure-assignment rather than having to call CopyMemory
//

typedef struct _IPRIP_PACKET {

    BYTE        IP_Packet[MAX_PACKET_SIZE];

} IPRIP_PACKET, *PIPRIP_PACKET;


//
// definitions for IPRIP packet fields
//

#define IPRIP_PORT              520
#define IPRIP_REQUEST           1
#define IPRIP_RESPONSE          2
#define IPRIP_INFINITE          16
#define IPRIP_MULTIADDR         ((DWORD)0x090000E0)


//
// Constant for recv buffer size of sockets bound to RIP port
//
#define RIPRECVBUFFERSIZE           65536


//
// Maximum number of work items that will be enqueued
//
#define MAXPROCESSINPUTWORKITEMS    8


//
// Time conversion constants and macros
//

#define SYSTIME_UNITS_PER_MSEC  (1000 * 10)
#define SYSTIME_UNITS_PER_SEC   (1000 * SYSTIME_UNITS_PER_MSEC)


//
// macro to get system time in 100-nanosecond units
//

#define RipQuerySystemTime(p)   NtQuerySystemTime((p))


//
// macros to convert time between 100-nanosecond, 1millsec, and 1 sec units
//

#define RipSystemTimeToMillisecs(p) {                                       \
    DWORD _r;                                                               \
    *(p) = RtlExtendedLargeIntegerDivide(*(p), SYSTIME_UNITS_PER_MSEC, &_r);\
}

#define RipMillisecsToSystemTime(p)                                         \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_PER_MSEC)   

#define RipSecsToSystemTime(p)                                              \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_PER_SEC)   

#define RipSecsToMilliSecs(p)                                               \
            (p) * 1000

//
// Network classification constants and macros
//

#define CLASSA_MASK         ((DWORD)0x000000ff)
#define CLASSB_MASK         ((DWORD)0x0000ffff)
#define CLASSC_MASK         ((DWORD)0x00ffffff)
#define CLASSD_MASK         ((DWORD)0x000000e0)
#define CLASSE_MASK         ((DWORD)0xffffffff)

#define CLASSA_ADDR(a)      (((*((PBYTE)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)      (((*((PBYTE)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)      (((*((PBYTE)&(a))) & 0xe0) == 0xc0)
#define CLASSD_ADDR(a)      (((*((PBYTE)&(a))) & 0xf0) == 0xe0)

//
// NOTE: 
// This check for class E addresses doesn't weed out the address range from
// 248.0.0.0 to 255.255.255.254
//
#define CLASSE_ADDR(a)      ((((*((PBYTE)&(a)))& 0xf0) == 0xf0) &&  \
                             ((a) != 0xffffffff))

#define IS_LOOPBACK_ADDR(a) (((a) & 0xff) == 0x7f)

//
// Checks if the address is a broadcast
// Determines the class of the address passed in, and then uses the net mask
// corresponding to that class to determine if it is a broadcast address.
// Also identifies an all 1's address as a broadcast address.
// This macro can't be used for identifying subnet directed broadcasts
//
#define IS_BROADCAST_ADDR(a)                                                \
            ((a) == INADDR_BROADCAST ||                                     \
             (CLASSA_ADDR(a) && (((a) & ~CLASSA_MASK) == ~CLASSA_MASK)) ||  \
             (CLASSB_ADDR(a) && (((a) & ~CLASSB_MASK) == ~CLASSB_MASK)) ||  \
             (CLASSC_ADDR(a) && (((a) & ~CLASSC_MASK) == ~CLASSC_MASK))) 

//
// Checks if the address is a directed broadcast
// The ~mask == TRUE check makes sure that host addresses with a mask
// of all ones, don't get classified as directed broadcasts
// But this also means that anytime the mask is all 1's (which is what 
// NETCLASS_MASK macro returns, if the address passed in is not an A, B, C or
// D class address) the IS_DIRECTED_BROADCAST macro will return 0
//
#define IS_DIRECTED_BROADCAST_ADDR(a, mask)                              \
             ( (~(mask)) && (((a) & ~(mask)) == ~(mask)) )

//
// checks if an address is 255.255.255.255
//
#define IS_LOCAL_BROADCAST_ADDR(a)                                       \
             ( (a) == INADDR_BROADCAST )


#define HOSTADDR_MASK       0xffffffff

#define NETCLASS_MASK(a)                                        \
            (CLASSA_ADDR(a) ? CLASSA_MASK :                     \
            (CLASSB_ADDR(a) ? CLASSB_MASK :                     \
            (CLASSC_ADDR(a) ? CLASSC_MASK :                     \
            (CLASSD_ADDR(a) ? CLASSD_MASK : CLASSE_MASK))))


//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

#define IPV4_ADDR_LEN       32
#define IPV4_SOURCE_MASK    0xFFFFFFFF

#endif // _DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\iprip.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: iprip.h
//
// History:
//      Abolade Gbadegesin  Aug-7-1995  Created.
//
// Contains type definitions and declarations for IP RIP.
//============================================================================

#ifndef _IPRIP_H_
#define _IPRIP_H_



//
// various codes describing states of IPRIP.
//

typedef enum _IPRIP_STATUS_CODE {
    IPRIP_STATUS_STARTING   = 100,
    IPRIP_STATUS_RUNNING    = 101,
    IPRIP_STATUS_STOPPING   = 102,
    IPRIP_STATUS_STOPPED    = 103
} IPRIP_STATUS_CODE, *PIPRIP_STATUS_CODE;



//
// type:    IPRIP_GLOBALS
//
//
// The critical section IPRIP_GLOBALS::IG_CS protects the fields IG_Status,
// IG_ActivityCount, IG_ActivitySemaphore, IG_InterruptReason, and
// IG_InterruptSocket
//
// The read-write lock IPRIP_GLOBALS::IG_RWL protects the field IG_Config
//
// When more than one field must be locked, the order
// of locking must be as follows (locks for fields listed on the same line
// should never be held by the same thread at once):
//      IG_IfTable.IT_RWL
//      IG_PeerTable.PT_RWL
//      IG_IfTable.IT_CS
//      IG_BindingTable.BT_RWL
//      IG_RWL
//      IG_TimerQueue  IG_EventQueue  IG_SendQueue  IG_RecvQueue
//      IG_CS
//
// It is assumed that the field IG_SendQueueSize will only
// be accessed while the send queue is locked, and thus
// it is protected implicitly by the send-queue critical section.
//
// Likewise, it is assumed that the field IG_RecvQueueSize will only
// be accessed while the recv-queue is locked, and thus
// it is protected implicitly by the recv-queue critical section.
//

typedef struct _IPRIP_GLOBALS {

    CRITICAL_SECTION    IG_CS;
    IPRIP_STATUS_CODE   IG_Status;
    READ_WRITE_LOCK     IG_RWL;
    DWORD               IG_TraceID;
    IPRIP_GLOBAL_STATS  IG_Stats;
    PIPRIP_GLOBAL_CONFIG IG_Config;
    PIF_TABLE           IG_IfTable;
    PPEER_TABLE         IG_PeerTable;
    PBINDING_TABLE      IG_BindingTable;
    DWORD               IG_LogLevel;
    HANDLE              IG_LogHandle;
    HANDLE              IG_RtmHandle;
    HANDLE              IG_RtmNotifHandle;
    RTM_ENTITY_INFO     IG_RtmEntityInfo;
    RTM_REGN_PROFILE    IG_RtmProfile;
    HANDLE              IG_TimerQueueHandle;
    PLOCKED_LIST        IG_EventQueue;
    PLOCKED_LIST        IG_SendQueue;
    LONG                IG_SendQueueSize;
    PLOCKED_LIST        IG_RecvQueue;
    LONG                IG_RecvQueueSize;
    HANDLE              IG_EventEvent;
    HANDLE              IG_IpripInputEvent;
    HANDLE              IG_IpripInputEventHandle;
    HANDLE              IG_IpripGlobalHeap;
    LONG                IG_ActivityCount;
    HANDLE              IG_ActivitySemaphore;
    DWORD               IG_MibTraceID;
    HANDLE              IG_MibTimerHandle;
    DWORD               IG_MaxProcessInputWorkItems;
    LONG                IG_NumProcessInputWorkItems;
    HANDLE              IG_DllHandle;
    
    SUPPORT_FUNCTIONS   IG_SupportFunctions;
} IPRIP_GLOBALS, *PIPRIP_GLOBALS;



//
// external declaration of the global IPRIP struct
//

extern IPRIP_GLOBALS ig;



//
// memory-allocation constants and macros
//

#define GLOBAL_HEAP     ig.IG_IpripGlobalHeap
#define RIP_ALLOC(size) HeapAlloc(GLOBAL_HEAP, 0, size)
#define RIP_FREE(ptr)   HeapFree(GLOBAL_HEAP, 0, ptr)



//
// macros invoked when entering API or worker functions
//

#define ENTER_RIP_API()         EnterRipAPI()
#define ENTER_RIP_WORKER()      EnterRipWorker()


//
// macro invoked when leaving API or worker functions
//

#define LEAVE_RIP_API()         LeaveRipWorker()
#define LEAVE_RIP_WORKER()      LeaveRipWorker()



//
// macros used for locking and unlocking protected structures
//

#define ACQUIRE_GLOBAL_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_RWL)

#define RELEASE_GLOBAL_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_RWL)

#define ACQUIRE_GLOBAL_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_RWL)

#define RELEASE_GLOBAL_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_RWL)


#define ENTER_GLOBAL_SECTION() \
        EnterCriticalSection(&ig.IG_CS)

#define LEAVE_GLOBAL_SECTION() \
        LeaveCriticalSection(&ig.IG_CS)


#define ACQUIRE_IF_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_IfTable->IT_RWL)

#define RELEASE_IF_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_IfTable->IT_RWL)

#define ACQUIRE_IF_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_IfTable->IT_RWL)

#define RELEASE_IF_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_IfTable->IT_RWL)


#define ENTER_IF_SECTION() \
        EnterCriticalSection(&ig.IG_IfTable->IT_CS)

#define LEAVE_IF_SECTION() \
        LeaveCriticalSection(&ig.IG_IfTable->IT_CS)


#define ACQUIRE_PEER_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_PeerTable->PT_RWL)

#define RELEASE_PEER_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_PeerTable->PT_RWL)

#define ACQUIRE_PEER_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_PeerTable->PT_RWL)

#define RELEASE_PEER_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_PeerTable->PT_RWL)


#define ACQUIRE_BINDING_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_BindingTable->BT_RWL)

#define RELEASE_BINDING_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_BindingTable->BT_RWL)

#define ACQUIRE_BINDING_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_BindingTable->BT_RWL)

#define RELEASE_BINDING_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_BindingTable->BT_RWL)


//
// constants and macros used for tracing 
//

#define IPRIP_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPRIP_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPRIP_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPRIP_TRACE_TIMER           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPRIP_TRACE_IF              ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPRIP_TRACE_ROUTE           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPRIP_TRACE_SEND            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPRIP_TRACE_RECEIVE         ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPRIP_TRACE_CONFIG          ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPRIP_TRACE_START           ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_STOP            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_REQUEST         ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_RESPONSE        ((DWORD)0x08000000 | TRACE_USE_MASK)


#define TRACEID         ig.IG_TraceID


#define TRACE0(l,a)             \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d, e, f)

#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)



//
// Event logging macros
//

#define LOGLEVEL        ig.IG_LogLevel
#define LOGHANDLE       ig.IG_LogHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


// Error logging

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[1] = { (a) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,1,_asz,(err)); \
        }
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }


// Warning logging

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[1] = { (a) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,1,_asz,(err)); \
        }
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


// Information logging

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[1] = { (a) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,1,_asz,(err)); \
        }
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }



//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )


//
// external declaration of the main thread
//

DWORD
IpripThread(
    PVOID pParam
    );


//
//
//

DWORD
QueueRipWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    );

BOOL
EnterRipAPI(
    );

BOOL
EnterRipWorker(
    );

VOID
LeaveRipWorker(
    );

#endif // _IPRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\api.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: api.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains definitions for the API entry-points used by Router Manager.
//============================================================================

#ifndef _API_H_
#define _API_H_



BOOL 
DllStartup(
    );

BOOL
DllCleanup(
    );

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PVOID pConfig
    );

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    );



//
// function declarations for router manager interface:
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

DWORD
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
APIENTRY 
StartComplete(
    VOID
    );

DWORD
APIENTRY
StopProtocol(
    VOID
    );

DWORD WINAPI
GetGlobalInfo (
    PVOID OutGlobalInfo,
    PULONG GlobalInfoSize,
    PULONG   StructureVersion,
    PULONG   StructureSize,
    PULONG   StructureCount
    );

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    );

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    );

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    );

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    );

DWORD
APIENTRY
UnBindInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );


#endif // _API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\makefile.inc ===
$(O)\ipripmsg.mc: log.h
    mapmsg NET IPRIPLOG_BASE log.h > $(O)\ipripmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\log.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    log.h
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in IPRIP's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define IPRIPLOG_BASE                           30000

#define IPRIPLOG_INIT_CRITSEC_FAILED            (IPRIPLOG_BASE + 1)
/*
 * IPRIPv2 was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPRIPLOG_HEAP_CREATE_FAILED             (IPRIPLOG_BASE + 2)
/*
 * IPRIPv2 was unable to create a heap.
 * The data is the error code.
 */

#define IPRIPLOG_HEAP_ALLOC_FAILED              (IPRIPLOG_BASE + 3)
/*
 * IPRIPv2 was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_ALREADY_STARTED          (IPRIPLOG_BASE + 4)
/*
 * IPRIPv2 received a start request when it was already running.
 */

#define IPRIPLOG_WSASTARTUP_FAILED              (IPRIPLOG_BASE + 5)
/*
 * IPRIPv2 was unable to start Windows Sockets.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_RWL_FAILED              (IPRIPLOG_BASE + 6)
/*
 * IPRIPv2 was unable to create a synchronization object.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_EVENT_FAILED            (IPRIPLOG_BASE + 7)
/*
 * IPRIPv2 was unable to create an event.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_IF_TABLE_FAILED         (IPRIPLOG_BASE + 8)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about configured network interfaces.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_PEER_TABLE_FAILED       (IPRIPLOG_BASE + 9)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about neighboring IPRIP routers.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_BINDING_TABLE_FAILED    (IPRIPLOG_BASE + 10)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about local IP addresses.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SEMAPHORE_FAILED        (IPRIPLOG_BASE + 11)
/*
 * IPRIPv2 was unable to create a semaphore.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SOCKET_FAILED           (IPRIPLOG_BASE + 12)
/*
 * IPRIPv2 was unable to create a socket.
 * The data is the error code.
 */

#define IPRIPLOG_RTM_REGISTER_FAILED            (IPRIPLOG_BASE + 13)
/*
 * IPRIPv2 was unable to register with the Routing Table Manager.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_THREAD_FAILED           (IPRIPLOG_BASE + 14)
/*
 * IPRIPv2 was unable to create a thread.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_STARTED                  (IPRIPLOG_BASE + 15)
/*
 * IPRIPv2 has started successfully.
 */

#define IPRIPLOG_BIND_IF_FAILED                 (IPRIPLOG_BASE + 16)
/*
 * IPRIPv2 could not bind to IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define IPRIPLOG_QUEUE_WORKER_FAILED            (IPRIPLOG_BASE + 17)
/*
 * IPRIPv2 could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPRIPLOG_ADD_ROUTE_FAILED_1             (IPRIPLOG_BASE + 18)
/*
 * IPRIPv2 was unable to add a route to the Routing Table Manager.
 * The route is to network %1 with next-hop %3.
 * The data is the error code.
 */

#define IPRIPLOG_SELECT_FAILED                  (IPRIPLOG_BASE + 19)
/*
 * IPRIPv2 received an error in a call to select().
 * This may indicate underlying network problems.
 * The data is the error code.
 */

#define IPRIPLOG_RECVFROM_FAILED                (IPRIPLOG_BASE + 20)
/*
 * IPRIPv2 was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_PACKET_TOO_SMALL               (IPRIPLOG_BASE + 21)
/*
 * IPRIPv2 received a packet which was smaller than the minimum size
 * allowed for IPRIP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IPRIPLOG_PACKET_VERSION_INVALID         (IPRIPLOG_BASE + 22)
/*
 * IPRIPv2 received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define IPRIPLOG_PACKET_HEADER_CORRUPT          (IPRIPLOG_BASE + 23)
/*
 * IPRIPv2 received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IPRIPLOG_SENDTO_FAILED                  (IPRIPLOG_BASE + 24)
/*
 * IPRIPv2 was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define IPRIPLOG_RESPONSE_FILTERED              (IPRIPLOG_BASE + 25)
/*
 * IPRIPv2 discarded a response packet from a neighbor with IP address %1.
 * IPRIPv2 is not configured to accept packets from the above neighbor.
 */

#define IPRIPLOG_PACKET_VERSION_MISMATCH        (IPRIPLOG_BASE + 26)
/*
 * IPRIPv2 discarded a version %1 packet received on the interface
 * with IP address %2 from a neighbor with IP address %3.
 * The above interface is configured to accept only version %4 packets.
 */

#define IPRIPLOG_AUTHENTICATION_FAILED          (IPRIPLOG_BASE + 27)
/*
 * IPRIPv2 discarded a packet received on the interface with IP address %1
 * from a neighboring router with IP address %2, because the packet
 * failed authentication.
 */

#define IPRIPLOG_ROUTE_CLASS_INVALID            (IPRIPLOG_BASE + 28)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2 which was advertised
 * by a neighbor with IP address %3. The route's network class is invalid.
 */

#define IPRIPLOG_LOOPBACK_ROUTE_INVALID         (IPRIPLOG_BASE + 29)
/*
 * IPRIPv2 is ignoring a route to the loopback network %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3.
 */

#define IPRIPLOG_BROADCAST_ROUTE_INVALID        (IPRIPLOG_BASE + 30)
/*
 * IPRIPv2 is ignoring a route to the broadcast network %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3.
 */

#define IPRIPLOG_HOST_ROUTE_INVALID             (IPRIPLOG_BASE + 31)
/*
 * IPRIPv2 is ignoring a host route to %1 with next-hop %2 which was
 * advertised by a neighbor with IP address %3, because the interface
 * on which the route was received is configured to reject host routes.
 */

#define IPRIPLOG_DEFAULT_ROUTE_INVALID          (IPRIPLOG_BASE + 32)
/*
 * IPRIPv2 is ignoring a default route with next-hop %2 which was
 * advertised by a neighbor with IP address %3, because the interface
 * on which the route was received is configured to reject default routes.
 */

#define IPRIPLOG_ROUTE_FILTERED                 (IPRIPLOG_BASE + 33)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2 which was advertised
 * by a neighbor with IP address %3, because the interface on which
 * the route was received has a filter configured which excluded this route.
 */

#define IPRIPLOG_ADD_ROUTE_FAILED_2             (IPRIPLOG_BASE + 34)
/*
 * IPRIPv2 was unable to add a route to the Routing Table Manager.
 * The route is to %1 with next-hop %2 and it was received from a neighbor
 * with IP address %3.
 * The data is the error code.
 */

#define IPRIPLOG_RTM_ENUMERATE_FAILED           (IPRIPLOG_BASE + 35)
/*
 * IPRIPv2 was unable to enumerate the routes in the Routing Table Manager.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_STOPPED                  (IPRIPLOG_BASE + 36)
/*
 * IPRIPv2 has stopped.
 */

#define IPRIPLOG_NEW_ROUTE_LEARNT_1             (IPRIPLOG_BASE + 37)
/*
 * IPRIPv2 has learnt of a new route. The route is to network %1
 * with next-hop %2, and the route was learnt from the neighbor
 * with IP address %3.
 */

#define IPRIPLOG_ROUTE_NEXTHOP_CHANGED          (IPRIPLOG_BASE + 38)
/*
 * IPRIPv2 has changed the next-hop of the route to %1.
 * The new next-hop is %2.
 */

#define IPRIPLOG_ROUTE_METRIC_CHANGED           (IPRIPLOG_BASE + 39)
/*
 * IPRIPv2 has learnt of a change in metric for its route to %1 
 * with next-hop %2. The new metric is %3.
 */

#define IPRIPLOG_NEW_ROUTE_LEARNT_2             (IPRIPLOG_BASE + 40)
/*
 * IPRIPv2 has learnt of a new route. The route is to network %1
 * with next-hop %2.
 */

#define IPRIPLOG_ROUTE_EXPIRED                  (IPRIPLOG_BASE + 41)
/*
 * IPRIPv2 has timed-out its route to %1 with next-hop %2,
 * since no neighboring routers announced the route.
 * The route will now be marked for deletion.
 */

#define IPRIPLOG_ROUTE_DELETED                  (IPRIPLOG_BASE + 42)
/*
 * IPRIPv2 has deleted its route to %1 with next-hop %2,
 * since the route timed-out and no neighboring routers announced the route.
 */

#define IPRIPLOG_ROUTE_ENTRY_IGNORED            (IPRIPLOG_BASE + 43)
/*
 * IPRIPv2 is ignoring a route on the local interface with IP address %1.
 * The route is to the network %1 and it was received from a neighbor
 * with IP address %2.
 * The route is being ignored because it contains some invalid information.
 */

#define IPRIPLOG_ROUTE_METRIC_INVALID           (IPRIPLOG_BASE + 44)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3,
 * since the route was advertised with an invalid metric.
 * The data is the metric.
 */

#define IPRIPLOG_ENUM_NETWORK_EVENTS_FAILED     (IPRIPLOG_BASE + 45)
/*
 * IPRIPv2 was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_INPUT_RECORD_ERROR             (IPRIPLOG_BASE + 46)
/*
 * IPRIPv2 detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IPRIPLOG_EVENTSELECT_FAILED             (IPRIPLOG_BASE + 47)
/*
 * IPRIPv2 was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SOCKET_FAILED_2         (IPRIPLOG_BASE + 48)
/*
 * IPRIPv2 was unable to create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_ENABLE_BROADCAST_FAILED        (IPRIPLOG_BASE + 49)
/*
 * IPRIPv2 could not enable broadcasting on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_BIND_FAILED                    (IPRIPLOG_BASE + 50)
/*
 * IPRIPv2 could not bind to port 520 on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_SET_MCAST_IF_FAILED            (IPRIPLOG_BASE + 51)
/*
 * IPRIPv2 could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_JOIN_GROUP_FAILED              (IPRIPLOG_BASE + 52)
/*
 * IPRIPv2 could not join the multicast group 224.0.0.9
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_INVALID_PORT                   (IPRIPLOG_BASE + 53)
/*
 * IPRIPv2 discarded a response packet from a neighbor with IP address %1.
 * The packet was not sent from the standard IP RIP port (520).
 */

#define IPRIPLOG_REGISTER_WAIT_FAILED           (IPRIPLOG_BASE + 54)
/*
 * IPRIPv2 could not register an event with the Ntdll wait thread.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_TIMER_QUEUE_FAILED      (IPRIPLOG_BASE + 55)
/*
 * IPRIPv2 could not register a timer queue with the Ntdll thread.
 * The data is the error code.
 */

#define IPRIPLOG_INVALID_IF_CONFIG              (IPRIPLOG_BASE + 56)
/*
 * IPRIPV2 could not be enabled on the interface.
 * Parameter %1 has an invalid value %2.
 */

 #define IPRIPLOG_PREVIOUS_SENDTO_FAILED        (IPRIPLOG_BASE + 57)
/*
 * Peer with IP address %1 was unable to receive RIP message sent out
 * from interface with IP address %2.
 * The peer might be rebooting, or Routing and Remote Access service
 * might not be running on the peer.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\pchrip.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchrip.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Precompiled header for IPRIP
//============================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <rtmv2.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ipriprm.h>
#include "defs.h"
#include "sync.h"
#include "route.h"
#include "queue.h"
#include "table.h"
#include "work.h"
#include "api.h"
#include "iprip.h"
#include "log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\queue.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// timer queue, change queue, and event message queue implementation
//============================================================================

#include "pchrip.h"
#pragma hdrstop



//----------------------------------------------------------------------------
// Function:    EnqueueSendEntry
//
// This function adds an entry to the end of the queue of changed routes.
// It assumes the queue is already locked, and since it needs to check
// the maximum queue size, it assumes the global config is locked for
// reading or writing
//----------------------------------------------------------------------------
DWORD
EnqueueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead, ple;
    PSEND_QUEUE_ENTRY psqe;
    RIP_IP_ROUTE rir;
    

    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) {
        psqe = NULL;
    }
    else {

        ple = phead->Blink;
        psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);
    }


    if (psqe == NULL || psqe->SQE_Count >= MAX_PACKET_ENTRIES) {

        //
        // we'll need to allocate a new entry
        // check that the max queue size is not exceeded
        //

        if ((DWORD)ig.IG_SendQueueSize >= ig.IG_Config->GC_MaxSendQueueSize) {

            TRACE2(
                SEND,
                "dropping route: send queue size is %d bytes and max is %d bytes",
                ig.IG_SendQueueSize, ig.IG_Config->GC_MaxSendQueueSize
                );

            return ERROR_INSUFFICIENT_BUFFER;
        }


        psqe = RIP_ALLOC(sizeof(SEND_QUEUE_ENTRY));
        if (psqe == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for send queue entry",
                dwErr, sizeof(SEND_QUEUE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            return dwErr;
        }

        psqe->SQE_Count = 0;
        InsertTailList(phead, &psqe->SQE_Link);
    
        ig.IG_SendQueueSize += sizeof(SEND_QUEUE_ENTRY);
    }


    *(psqe->SQE_Routes + psqe->SQE_Count) = *pRoute;
    ++psqe->SQE_Count;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DequeueSendEntry
//
// This function removes an entry from the head of the queue of changed routes
// assuming the queue is already locked
//----------------------------------------------------------------------------
DWORD
DequeueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    ) {

    PLIST_ENTRY phead, ple;
    PSEND_QUEUE_ENTRY psqe;

    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = phead->Flink;
    psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);

    --psqe->SQE_Count;
    *pRoute = *(psqe->SQE_Routes + psqe->SQE_Count);

    if (psqe->SQE_Count == 0) {

        RemoveEntryList(&psqe->SQE_Link);
        RIP_FREE(psqe);

        ig.IG_SendQueueSize -= sizeof(SEND_QUEUE_ENTRY);
        if (ig.IG_SendQueueSize < 0) { ig.IG_SendQueueSize = 0; }
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FlushSendQueue
//
// This function removes all entries from the send-queue. It assumes
// that the queue is locked.
//----------------------------------------------------------------------------
DWORD
FlushSendQueue(
    PLOCKED_LIST pQueue
    ) {

    PLIST_ENTRY ple, phead;
    PSEND_QUEUE_ENTRY psqe;

    phead = &pQueue->LL_Head;

    while (!IsListEmpty(phead)) {

        ple = RemoveHeadList(phead);
        psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);

        RIP_FREE(psqe);
    }

    ig.IG_SendQueueSize = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnqueueRecvEntry
//
// assumes that recv queue is locked and that global config is locked
// for reading or writing
//----------------------------------------------------------------------------
DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead;
    PRECV_QUEUE_ENTRY prqe;


    //
    // check that the max queue size is not exceeded
    //

    if ((DWORD)ig.IG_RecvQueueSize >= ig.IG_Config->GC_MaxRecvQueueSize) {

        TRACE2(
            RECEIVE,
            "dropping route: recv queue size is %d bytes and max is %d bytes",
            ig.IG_RecvQueueSize, ig.IG_Config->GC_MaxRecvQueueSize
            );

        return ERROR_INSUFFICIENT_BUFFER;
    }


    phead = &pQueue->LL_Head;

    prqe = RIP_ALLOC(sizeof(RECV_QUEUE_ENTRY));
    if (prqe == NULL) {

        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocating %d bytes for receive queue entry",
            dwErr, sizeof(RECV_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    prqe->RQE_Routes = pRoutes;
    prqe->RQE_Command = dwCommand;

    InsertTailList(phead, &prqe->RQE_Link);

    ig.IG_RecvQueueSize += sizeof(RECV_QUEUE_ENTRY);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DequeueRecvEntry
//
// Retrieves the first item in the receive-queue.
// Assumes that recv queue is locked 
//----------------------------------------------------------------------------
DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD pdwCommand,
    PBYTE *ppRoutes
    ) {

    PLIST_ENTRY ple, phead;
    PRECV_QUEUE_ENTRY prqe;


    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) { return ERROR_NO_MORE_ITEMS; }

    ple = RemoveHeadList(phead);

    prqe = CONTAINING_RECORD(ple, RECV_QUEUE_ENTRY, RQE_Link);

    *ppRoutes = prqe->RQE_Routes;
    *pdwCommand = prqe->RQE_Command;

    RIP_FREE(prqe);

    ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);
    if (ig.IG_RecvQueueSize < 0) { ig.IG_RecvQueueSize = 0; }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FlushRecvQueue
//
// Removes all entries from the receive queue.
// Assumes that the queue is locked.
//----------------------------------------------------------------------------
DWORD
FlushRecvQueue(
    PLOCKED_LIST pQueue
    ) {

    PLIST_ENTRY ple, phead;
    PRECV_QUEUE_ENTRY prqe;

    phead = &pQueue->LL_Head;

    while (!IsListEmpty(phead)) {

        ple = RemoveHeadList(phead);
        prqe = CONTAINING_RECORD(ple, RECV_QUEUE_ENTRY, RQE_Link);

        RIP_FREE(prqe->RQE_Routes);
        RIP_FREE(prqe);
    }

    ig.IG_RecvQueueSize = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnqueueEvent
//
// This function adds an entry to the end of the queue of
// Router Manager events. It assumes the queue is locked.
//----------------------------------------------------------------------------
DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS Event,
    MESSAGE Result
    ) {


    DWORD dwErr;
    PLIST_ENTRY phead;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;

    peqe = RIP_ALLOC(sizeof(EVENT_QUEUE_ENTRY));
    if (peqe == NULL) {

        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocating %d bytes for event quue entry",
            dwErr, sizeof(EVENT_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    peqe->EQE_Event = Event;
    peqe->EQE_Result = Result;

    InsertTailList(phead, &peqe->EQE_Link);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DequeueEvent
//
// This function removes an entry from the head of the queue
// of Router Manager events. It assumes the queue is locked
//----------------------------------------------------------------------------
DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEvent,
    PMESSAGE pResult
    ) {

    PLIST_ENTRY phead, ple;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;
    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = RemoveHeadList(phead);
    peqe = CONTAINING_RECORD(ple, EVENT_QUEUE_ENTRY, EQE_Link);

    *pEvent = peqe->EQE_Event;
    *pResult = peqe->EQE_Result;

    RIP_FREE(peqe);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\queue.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used for various queues.
//============================================================================

#ifndef _QUEUE_H_
#define _QUEUE_H_


//
// type definitions for send queue
//

typedef struct _SEND_QUEUE_ENTRY {

    LIST_ENTRY      SQE_Link;
    DWORD           SQE_Count;
    RIP_IP_ROUTE    SQE_Routes[MAX_PACKET_ENTRIES];

} SEND_QUEUE_ENTRY, *PSEND_QUEUE_ENTRY;


DWORD
EnqueueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    );

DWORD
DequeueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    );

DWORD
FlushSendQueue(
    PLOCKED_LIST pQueue
    );



//
// type definitions for the receive queue
//

typedef struct _RECV_QUEUE_ENTRY {

    LIST_ENTRY  RQE_Link;
    PBYTE       RQE_Routes;
    DWORD       RQE_Command;

} RECV_QUEUE_ENTRY, *PRECV_QUEUE_ENTRY;


DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    );

DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD dwCommand,
    PBYTE *ppRoutes
    );


DWORD
FlushRecvQueue(
    PLOCKED_LIST pQueue
    );



//
// type definitions for event message queue
//

typedef struct _EVENT_QUEUE_ENTRY {

    LIST_ENTRY              EQE_Link;
    ROUTING_PROTOCOL_EVENTS EQE_Event;
    MESSAGE                 EQE_Result;

} EVENT_QUEUE_ENTRY, *PEVENT_QUEUE_ENTRY;


DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS Event,
    MESSAGE Result
    );

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEvent,
    PMESSAGE pResult
    );



#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\route.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used for internal route structures.
//============================================================================


#ifndef _ROUTE_H_
#define _ROUTE_H_

typedef struct _PROTOCOL_SPECIFIC_DATA {

    DWORD   PSD_Data[4];
    
} PROTOCOL_SPECIFIC_DATA, *PPROTOCOL_SPECIFIC_DATA;


typedef struct _IP_NETWORK {

    DWORD   N_NetNumber;
    DWORD   N_NetMask;
    
} IP_NETWORK, *PIP_NETWORK;


typedef struct _IP_SPECIFIC_DATA {

    DWORD   FSD_Metric;
    DWORD   FSD_Metric1;
    
} IP_SPECIFIC_DATA, *PIP_SPECIFIC_DATA;


typedef struct _RIP_IP_ROUTE {

    DWORD                   RR_RoutingProtocol;
    DWORD                   RR_InterfaceID;
    PROTOCOL_SPECIFIC_DATA  RR_ProtocolSpecificData;
    IP_NETWORK              RR_Network;
    IP_NETWORK              RR_NextHopAddress;
    IP_SPECIFIC_DATA        RR_FamilySpecificData;

    RTM_DEST_HANDLE         hDest;

} RIP_IP_ROUTE, *PRIP_IP_ROUTE;


DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo, OPTIONAL
    IN  PRTM_DEST_INFO      pInDestInfo,  OPTIONAL
    OUT PRIP_IP_ROUTE       pRoute
    );

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h
// through the structure RTL_RESOURCE and several functions.
// However, that implementation has the potential for starving
// a thread trying to acquire write accesss, if there are a large
// number of threads interested in acquiring read access.
// Such a scenario is avoided in the implementation given in this
// header. However, a mapping is also given to the RTL_RESOURCE
// functionality, so that IPRIP can be compiled to use either form
//

#ifdef RIP_RWL

//
// use IPRIP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


#define ACQUIRE_READ_LOCK(pRWL)                                             \
    AcquireReadLock(pRWL)

#define RELEASE_READ_LOCK(pRWL)                                             \
    ReleaseReadLock(pRWL)

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
    AcquireWriteLock(pRWL)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
    ReleaseWriteLock(pRWL)

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
    (ReleaseReadLock(pRWL), AcquireWriteLock(pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (ReleaseWriteLock(pRWL), AcquireReadLock(pRWL))


#else // i.e. !RIP_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // RIP_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          LL_Head;
    CRITICAL_SECTION    LL_Lock;
    DWORD               LL_Created;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)                                             \
            InitializeListHead(&(pLL)->LL_Head);                            \
            InitializeCriticalSection(&(pLL)->LL_Lock);                     \
            (pLL)->LL_Created = 0x12345678

#define LOCKED_LIST_CREATED(pLL)                            \
            ((pLL)->LL_Created == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                \
            PLIST_ENTRY _ple;                               \
            (pLL)->LL_Created = 0;                          \
            DeleteCriticalSection(&(pLL)->LL_Lock);         \
            while (!IsListEmpty(&(pLL)->LL_Head)) {         \
                _ple = RemoveHeadList(&(pLL)->LL_Head);     \
                RIP_FREE(CONTAINING_RECORD(_ple,type,field));\
            }                                               \
        }

#define ACQUIRE_LIST_LOCK(pLL)                              \
            EnterCriticalSection(&(pLL)->LL_Lock)

#define RELEASE_LIST_LOCK(pLL)                              \
            LeaveCriticalSection(&(pLL)->LL_Lock)


#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\riptest.cxx ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    riptest.cxx
//
// History:
//  Abolade Gbadegesin  Oct-16-1995     Created.
//
// Code for RIP test program
//============================================================================

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#define FD_SETSIZE      256
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <ipexport.h>
#include <ipinfo.h>
#include <llinfo.h>

#include <rtm.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ipriprm.h>
#include <iprtrmib.h>
#include <dim.h>
#include <mprapi.h>
#include <iphlpapi.h>

#include "defs.h"


#include "riptest.h"

DWORD g_TraceID;

RIPTEST_IF_CONFIG g_cfg;

RIPTEST_IF_CONFIG g_def = {
    50,             // 50 routes
    0x000000c0,     // starting with 192.0.0.0
    0x0000ffff,     // using netmask 255.255.0.0
    0x00000000,     // and a next hop of 0
    0x00000000,     // and a route-tag of 0
    0xffffffff,     // sent to the broadcast address
    0,              // don't use a timeout to remove routes
    2,              // send version 2 packets
    0,              // random-sized packets
    100,            // use 100-millisecond packet gap
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", // all-zeroes authentication key
    IPRIP_AUTHTYPE_NONE,                // no authentication
    262144          // and set the send and recv buffers to this size
};


DWORD g_seed;
RIPTEST_IF_BINDING g_bind;



REG_OPTION g_options[] = {

    {
        STR_ROUTECOUNT,
        sizeof(DWORD),
        &g_cfg.RIC_RouteCount,
        &g_def.RIC_RouteCount,
        RegGetDWORD 
    },
    {
        STR_ROUTESTART,
        sizeof(DWORD),
        &g_cfg.RIC_RouteStart,
        &g_def.RIC_RouteStart,
        RegGetAddress
    },
    {
        STR_ROUTEMASK,
        sizeof(DWORD),
        &g_cfg.RIC_RouteMask,
        &g_def.RIC_RouteMask,
        RegGetAddress
    },
    {
        STR_ROUTENEXTHOP,
        sizeof(DWORD),
        &g_cfg.RIC_RouteNexthop,
        &g_def.RIC_RouteNexthop,
        RegGetAddress
    },
    {
        STR_ROUTETAG,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTag,
        &g_def.RIC_RouteTag,
        RegGetDWORD
    },
    {
        STR_ROUTETARGET,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTarget,
        &g_def.RIC_RouteTarget,
        RegGetAddress
    },
    {
        STR_ROUTETIMEOUT,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTimeout,
        &g_def.RIC_RouteTimeout,
        RegGetDWORD
    },
    {
        STR_PACKETVERSION,
        sizeof(DWORD),
        &g_cfg.RIC_PacketVersion,
        &g_def.RIC_PacketVersion,
        RegGetDWORD
    },
    {
        STR_PACKETENTRYCOUNT,
        sizeof(DWORD),
        &g_cfg.RIC_PacketEntryCount,
        &g_def.RIC_PacketEntryCount,
        RegGetDWORD
    },
    {
        STR_PACKETGAP,
        sizeof(DWORD),
        &g_cfg.RIC_PacketGap,
        &g_def.RIC_PacketGap,
        RegGetDWORD
    },
    {
        STR_AUTHKEY,
        IPRIP_MAX_AUTHKEY_SIZE,
        g_cfg.RIC_AuthKey,
        g_def.RIC_AuthKey,
        RegGetBinary
    },
    {
        STR_AUTHTYPE,
        sizeof(DWORD),
        &g_cfg.RIC_AuthType,
        &g_def.RIC_AuthType,
        RegGetDWORD
    },
    {
        STR_SOCKBUFSIZE,
        sizeof(DWORD),
        &g_cfg.RIC_SockBufSize,
        &g_def.RIC_SockBufSize,
        RegGetDWORD
    }
};




INT __cdecl
main(
    INT iArgc,
    PSTR ppszArgv[]
    )
{

    WSADATA wd;
    DWORD dwErr;

    //
    // must be at least one argument
    //

    if (iArgc != 2) {

        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }


    //
    // see if the user is just asking for instructions
    //

    if (strcmp(ppszArgv[1], "-?") == 0 || strcmp(ppszArgv[1], "/?") == 0) {

        PrintUsage();
        return 0;
    }


    //
    // first and only argument is name of interface
    //

    mbstowcs(g_bind.RIB_Netcard, ppszArgv[1], mbstowcs(NULL, ppszArgv[1], -1));


    //
    // register with the Tracing DLL
    //

    g_TraceID = PRINTREGISTER("RipTest");

    //
    // startup Winsock
    //

    dwErr = WSAStartup(MAKEWORD(1, 1), &wd);

    if (dwErr != NO_ERROR) {
        PRINTDEREGISTER(g_TraceID);
        return (INT)dwErr;
    }


    //
    // get the binding for the interface over which to send routes
    //

    dwErr = RegGetIfBinding();

    if (dwErr != NO_ERROR) {

        WSACleanup();
        PRINTDEREGISTER(g_TraceID);
        return (INT)dwErr;
    }



    //
    // seed the random number generator 
    //

    g_seed = GetTickCount();

    srand(g_seed);


    while (TRUE) {

        PRINT0("\n\nbeginning test cycle...");
    
        //
        // get the parameters for the interface,
        // and quit if an error occurred or the defaults were written
        //
    
        dwErr = RegGetConfig();
        if (dwErr != NO_ERROR) { break; }
    
    
        //
        // run one test cycle
        //

        dwErr = RipTest();

        PRINT0("completed test cycle...");
    }

    WSACleanup();

    PRINTDEREGISTER(g_TraceID);

    return dwErr;
}



DWORD
RegGetIfBinding(
    VOID
    )
{
#if 1
    PMIB_IPADDRTABLE AddrTable = NULL;
    DWORD dwErr;
    DWORD dwPrefixLength = lstrlen("\\DEVICE\\TCPIP_");
    DWORD dwSize;
    DWORD i;
    DWORD j;
    PIP_INTERFACE_INFO IfTable = NULL;

    //
    // Load the address table and interface table
    //

    do {

        dwSize = 0;

        dwErr = GetInterfaceInfo(IfTable, &dwSize);
    
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            PRINT1("error %d obtaining interface-table size", dwErr);
            break;
        }
    
        IfTable = (PIP_INTERFACE_INFO)HeapAlloc(GetProcessHeap(), 0, dwSize);

        if (!IfTable) {
            dwErr = GetLastError();
            PRINT2("error %d allocating %d-byte for interfaces", dwErr, dwSize);
            dwErr = ERROR_INSUFFICIENT_BUFFER; break;
        }
    
        dwErr = GetInterfaceInfo(IfTable, &dwSize);

        if (dwErr != NO_ERROR) {
            PRINT1("error %d getting interface table", dwErr);
            break;
        }

        dwSize = 0;

        dwErr = GetIpAddrTable(AddrTable, &dwSize, FALSE);
    
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            PRINT1("error %d obtaining address-table size", dwErr);
            break;
        }
    
        AddrTable = (PMIB_IPADDRTABLE)HeapAlloc(GetProcessHeap(), 0, dwSize);

        if (!AddrTable) {
            dwErr = GetLastError();
            PRINT2("error %d allocating %d-byte for addresses", dwErr, dwSize);
            dwErr = ERROR_INSUFFICIENT_BUFFER; break;
        }
    
        dwErr = GetIpAddrTable(AddrTable, &dwSize, FALSE);

        if (dwErr != NO_ERROR) {
            PRINT1("error %d getting address table", dwErr);
            break;
        }
    
    } while(FALSE);

    if (dwErr != NO_ERROR) {
        if (IfTable) { HeapFree(GetProcessHeap(), 0, IfTable); }
        if (AddrTable) { HeapFree(GetProcessHeap(), 0, AddrTable); }
        return dwErr;
    }

    //
    // Find the user's interface in the interface-table
    //

    dwErr = ERROR_INVALID_PARAMETER;
    for (i = 0; i < (DWORD)IfTable->NumAdapters; i++) {
        PRINT2("%d: %ls", IfTable->Adapter[i].Index, IfTable->Adapter[i].Name+dwPrefixLength);
        if (lstrcmpiW(
                IfTable->Adapter[i].Name+dwPrefixLength, g_bind.RIB_Netcard
                ) != 0) {
            continue;
        }

        //
        // We've found the interface.
        // Now look in the address-table for its address.
        //

        for (j = 0; j < AddrTable->dwNumEntries; j++) {
            PRINT2("%d: %s", AddrTable->table[j].dwIndex, INET_NTOA(AddrTable->table[j].dwAddr));
            if (AddrTable->table[j].dwIndex != IfTable->Adapter[i].Index) {
                continue;
            }

            //
            // We've found the address.
            //

            g_bind.RIB_Address = AddrTable->table[j].dwAddr;
            g_bind.RIB_Netmask = AddrTable->table[j].dwMask;
            dwErr = NO_ERROR;
            break;
        }

        if (j >= AddrTable->dwNumEntries) {
            PRINT0("the address for the interface could not be found");
        }

        break;
    }

    if (i >= (DWORD)IfTable->NumAdapters) {
        PRINT0("the interface specified could not be found");
    }

    HeapFree(GetProcessHeap(), 0, IfTable);
    HeapFree(GetProcessHeap(), 0, AddrTable);
    return dwErr;
#else
    HKEY hkeyNetcard;
    PSTR pszAddress, pszNetmask;
    CHAR szNetcard[256], szValue[256];
    DWORD dwErr, dwType, dwSize, dwEnableDhcp;

    //
    // open the TCP/IP parameters key for the interface specified
    //

    strcpy(szNetcard, STR_SERVICES);
    strcat(szNetcard, g_bind.RIB_Netcard);
    strcat(szNetcard, STR_PARAMSTCP);

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, szNetcard, 0, KEY_ALL_ACCESS, &hkeyNetcard
                );

    if (dwErr != NO_ERROR) {

        PRINT2("error %d opening registry key %s", dwErr, szNetcard);
        return dwErr;
    }


    do {


        //
        // read the dhcp key to see whether DHCP is enabled
        //
    
        dwSize = sizeof(DWORD);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, STR_ENABLEDHCP, NULL,
                    &dwType, (PBYTE)&dwEnableDhcp, &dwSize
                    );
    
        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, STR_ENABLEDHCP, szNetcard
                );
            break;
        }


        if (dwEnableDhcp) {
            pszAddress = STR_DHCPADDR;
            pszNetmask = STR_DHCPMASK;
        }
        else {
            pszAddress = STR_ADDRESS;
            pszNetmask = STR_NETMASK;
        }

    
        //
        // read the IP address and convert it  
        //

        dwSize = sizeof(szValue);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, pszAddress, NULL,
                    &dwType, (PBYTE)szValue, &dwSize
                    );

        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, pszAddress, szNetcard
                );
            break;
        }

        g_bind.RIB_Address = inet_addr(szValue);

        PRINT2("%s == %s", pszAddress, szValue);


        //
        // read the network mask and convert it
        //

        dwSize = sizeof(szValue);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, pszNetmask, NULL,
                    &dwType, (PBYTE)szValue, &dwSize
                    );

        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, pszNetmask, szNetcard
                );
            break;
        }

        g_bind.RIB_Netmask = inet_addr(szValue);

        PRINT2("%s == %s", pszNetmask, szValue);

    } while(FALSE);


    RegCloseKey(hkeyNetcard);

    return dwErr;
#endif
}



DWORD
RegGetConfig(
    VOID
    )
{

    CHAR szRipTest[256];
    DWORD dwErr, dwCreated;
    PREG_OPTION pro, proend;
    HKEY hkeyRipTest, hkeyIf;
    DWORD dwNetmask, dwPrefixLength;
    DWORD dwCount, dwLowestAddress, dwHighestAddress;


    //
    // create the RipTest key in case it doesn't exist
    //

    strcpy(szRipTest, STR_SERVICES);
    strcat(szRipTest, STR_RIPTEST);

    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE, szRipTest, 0, NULL, 0,
                KEY_ALL_ACCESS, NULL, &hkeyRipTest, &dwCreated
                );

    if (dwErr != NO_ERROR) {

        PRINT2("error %d creating registry key %s", dwErr, szRipTest);
        return dwErr;
    }


    //
    // create the key for the interface in case it doesn't exist
    //

    dwErr = RegCreateKeyExW(
                hkeyRipTest, g_bind.RIB_Netcard, 0, NULL, 0,
                KEY_ALL_ACCESS, NULL, &hkeyIf, &dwCreated
                );
    
    RegCloseKey(hkeyRipTest);

    if (dwErr != NO_ERROR) {

        PRINT3(
            "error %d creating subkey %S under registry key %s",
            dwErr, g_bind.RIB_Netcard, szRipTest
            );
        return dwErr;
    }


    PRINT0("loading options from registry: ");

    proend = g_options + (sizeof(g_options) / sizeof(REG_OPTION));

    for (pro = g_options; pro < proend; pro++) {

        //
        // read or initialize the option
        //

        pro->RO_GetOpt(hkeyIf, pro);
    }

    RegCloseKey(hkeyIf);



    //
    // if the defaults were used, give the user a chance to change them
    //

    if (dwCreated == REG_CREATED_NEW_KEY) {

        PRINT0("Default parameters have been written to the registry.");
        PRINT2("Please check the key %s\\%S,", szRipTest, g_bind.RIB_Netcard);
        PRINT0("modify the values if necessary, and run RIPTEST again.\n");

        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // check the route parameters for errors:
    //
    // make sure the class of the route is valid
    //

    dwLowestAddress = g_cfg.RIC_RouteStart;

    if (IS_LOOPBACK_ADDR(dwLowestAddress) ||
        CLASSD_ADDR(dwLowestAddress) || CLASSE_ADDR(dwLowestAddress)) {

        PRINT1(
            "ERROR: route %s is of an invalid network class",
            INET_NTOA(dwLowestAddress)
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure that from the specified starting address,
    // there are enough routes in the network class to generate
    // the configured number of routes
    //

    dwCount = g_cfg.RIC_RouteCount;
    dwNetmask = g_cfg.RIC_RouteMask;
    dwPrefixLength = PREFIX_LENGTH(dwNetmask);

    dwLowestAddress &= dwNetmask;
    dwHighestAddress = NTH_ADDRESS(dwLowestAddress, dwPrefixLength, dwCount);

    if (IS_LOOPBACK_ADDR(dwHighestAddress) ||
        NETCLASS_MASK(dwLowestAddress) != NETCLASS_MASK(dwHighestAddress)) {

        PRINT1(
            "ERROR: starting route %s is too near the end of its network class",
            INET_NTOA(dwLowestAddress)
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure that the authentication type is a supported value
    //

    if (g_cfg.RIC_AuthType != IPRIP_AUTHTYPE_NONE &&
        g_cfg.RIC_AuthType != IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        PRINT1(
            "ERROR: authentication type %d is not supported",
            g_cfg.RIC_AuthType
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure the number of packet entries isn't out-of-range
    //

    if (g_cfg.RIC_PacketEntryCount > 25) {

        PRINT1(
            "ERROR: packet-enty count %d is too large",
            g_cfg.RIC_PacketEntryCount
            );
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}



DWORD
RegGetAddress(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    CHAR szValue[256];
    DWORD dwErr, dwType, dwSize;

    //
    // attempt to read the value
    //

    dwSize = sizeof(szValue);

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, (PBYTE)szValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        strcpy(szValue, INET_NTOA(*(PDWORD)pOpt->RO_DefVal));
        dwSize = strlen(szValue) + 1;
        dwType = REG_SZ;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, (PBYTE)szValue, dwSize
                    );
    }


    //
    // by now the value in the registry should be in szValue
    //

    *(PDWORD)pOpt->RO_OptVal = inet_addr(szValue);

    PRINT2("%20s == %s", pOpt->RO_Name, szValue);

    return dwErr;
}



DWORD
RegGetDWORD(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    DWORD dwErr, dwValue, dwType, dwSize;


    //
    // attempt to read the value
    //

    dwSize = sizeof(DWORD);

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, (PBYTE)&dwValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        dwValue = *(PDWORD)pOpt->RO_DefVal;
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, (PBYTE)&dwValue, dwSize
                    );
    }


    //
    // by now the value in the registry should be in dwValue
    //

    *(PDWORD)pOpt->RO_OptVal = dwValue;

    PRINT2("%20s == %d", pOpt->RO_Name, dwValue);

    return dwErr;
}



DWORD
RegGetBinary(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    PBYTE pValue;
    DWORD dwErr, dwType, dwSize;


    //
    // attempt to read the value
    //

    dwSize = pOpt->RO_Size;
    pValue = (PBYTE)pOpt->RO_OptVal;

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, pValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        pValue = (PBYTE)pOpt->RO_DefVal;
        dwSize = pOpt->RO_Size;
        dwType = REG_BINARY;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, pValue, dwSize
                    );

        RtlCopyMemory(pOpt->RO_OptVal, pOpt->RO_DefVal, pOpt->RO_Size);
    }

    {
        PBYTE pb, pbend;
        CHAR *psz, szValue[256], szDigits[] = "0123456789ABCDEF";
    
        psz = szValue;
        pbend = (PBYTE)pOpt->RO_OptVal + pOpt->RO_Size;

        for (pb = (PBYTE)pOpt->RO_OptVal; pb < pbend; pb++) {
            *psz++ = szDigits[*pb / 16];
            *psz++ = szDigits[*pb % 16];
            *psz++ = ':';
        }
        if (psz != szValue) { --psz; }
        *psz = '\0';

        PRINT2("%20s == %s", pOpt->RO_Name, szValue);
    }

    return dwErr;
}



//
// main stress function
//
DWORD
RipTest(
    VOID
    )
{

    SOCKET sock;
    SOCKADDR_IN sinaddr;
    DWORD dwErr, dwMetric;
    IPForwardEntry *ifelist = NULL;
    LIST_ENTRY rtrlist, *ple;
    PRIPTEST_ROUTER_INFO prrs;



    InitializeListHead(&rtrlist);

    do {

        //
        // create and set up socket to be used for route transmission
        //
    
        dwErr = InitializeSocket(&sock, RIPTEST_PORT);
    
        if (dwErr != NO_ERROR) {
            break;
        }
    
        //
        // transmit single route request on non-RIP port,
        // and build a list of responding routers
        //
    
        dwErr = DiscoverRouters(sock, &rtrlist);
    
        if (dwErr != NO_ERROR) { closesocket(sock); break; }
    
    
        //
        // generate the list of routes as configured
        //
    
        dwErr = GenerateRoutes(&ifelist);
    
        if (dwErr != NO_ERROR) { closesocket(sock); break; }
        
        //
        // re-initialize the socket, this time to the RIP port
        //
    
        closesocket(sock);

        dwErr = InitializeSocket(&sock, IPRIP_PORT);
        if (dwErr == SOCKET_ERROR) {
            break;
        }
    
    
    
        for (dwMetric = 8; (INT)dwMetric >= 2; dwMetric -= 3) {
    
            //
            // transmit the route table with the specified metric
            //

            dwErr = TransmitRoutes(sock, dwMetric, ifelist);


            //
            // give the router time to process the advertisements:
            // we allow 30 milliseconds per route, with a minimum of 15 seconds
            //

            Sleep(max(15000, 30 * g_cfg.RIC_RouteCount));


            //
            // make connections to Router on each of the responding machines,
            // and use MIB api functions to retrieve the route table.
            // Verify that the routes transmitted are present, 
            // and add the servers to the displayed statistics
            //
        
            dwErr = VerifyRouteTables(dwMetric, &rtrlist, ifelist);
        }

        if (g_cfg.RIC_RouteTimeout != 0) {

            //
            // use timeout to clear routes
            //

            PRINT1(
                "waiting %d milliseconds for routes to timeout",
                max(15000, g_cfg.RIC_RouteTimeout * 1000)
                );
            Sleep(max(15000, g_cfg.RIC_RouteTimeout * 1000));
        }
        else {

            //
            // send updates to clean up the routes
            //
    
            PRINT0("sending announcements to purge routes advertised");

            dwErr = TransmitRoutes(sock, 16, ifelist);
    
            Sleep(max(15000, 30 * g_cfg.RIC_RouteCount));
        }

        closesocket(sock);

    } while(FALSE);


    //
    // cleanup the server list
    //

    while (!IsListEmpty(&rtrlist)) {

        ple = RemoveHeadList(&rtrlist);
        prrs = CONTAINING_RECORD(ple, RIPTEST_ROUTER_INFO, RRS_Link);

        HeapFree(GetProcessHeap(), 0, prrs);
    }


    if (ifelist != NULL) { HeapFree(GetProcessHeap(), 0, ifelist); }

    return dwErr;
}



DWORD
InitializeSocket(
    SOCKET *psock,
    WORD wPort
    )
{

    SOCKET sock;
    DWORD dwErr, dwOption;


    // 
    // create the socket
    //

    sock = socket(AF_INET, SOCK_DGRAM, 0);

    if (sock == INVALID_SOCKET) {

        dwErr = WSAGetLastError();
        PRINT1("error %d creating socket", dwErr);
        return dwErr;
    }


    //
    // enable address sharing
    //

    dwOption = 1;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT1("error %d enabling address re-use on socket", dwErr);
    }


    //
    // enlarge the receive buffer
    //

    dwOption = g_cfg.RIC_SockBufSize;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT2("error %d enlarging recv buffer to %d bytes", dwErr, dwOption);
    }


    //
    // enlarge the send buffer
    //

    dwOption = g_cfg.RIC_SockBufSize;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_SNDBUF,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT2("error %d enlarging send buffer to %d bytes", dwErr, dwOption);
    }   


    do {

        SOCKADDR_IN sinaddr;


        if (g_cfg.RIC_RouteTarget != IPRIP_MULTIADDR) {

            //
            // enable broadcasting
            //
            dwOption = 1;
            dwErr = setsockopt(
                        sock,
                        SOL_SOCKET,
                        SO_BROADCAST,
                        (PCCH)&dwOption,
                        sizeof(DWORD)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d enabling broadcast on socket", dwErr);
                break;
            }
    

            //
            // bind the socket to the RIPTEST port
            //

            sinaddr.sin_family = AF_INET;
            sinaddr.sin_port = htons(wPort);
            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = bind(sock, (PSOCKADDR)&sinaddr, sizeof(SOCKADDR_IN));

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d binding socket", dwErr);
                break;
            }

            dwErr = NO_ERROR;
        }
        else {

            struct ip_mreq imOption;


            //
            // bind to the specified port
            //

            sinaddr.sin_family = AF_INET;
            sinaddr.sin_port = htons(wPort);
            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = bind(sock, (PSOCKADDR)&sinaddr, sizeof(SOCKADDR_IN));

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d binding socket", dwErr);
                break;
            }

            //
            // set the outgoing interface for multicasts
            //

            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = setsockopt(
                        sock,
                        IPPROTO_IP,
                        IP_MULTICAST_IF,
                        (PCCH)&sinaddr.sin_addr,
                        sizeof(IN_ADDR)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d setting multicast interface", dwErr);
                break;
            }


            //
            // join the RIP multicast group
            //

            imOption.imr_multiaddr.s_addr = IPRIP_MULTIADDR;
            imOption.imr_interface.s_addr = g_bind.RIB_Address;

            dwErr = setsockopt(
                        sock,
                        IPPROTO_IP,
                        IP_ADD_MEMBERSHIP,
                        (PCCH)&imOption,
                        sizeof(struct ip_mreq)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d joining multicast group", dwErr);
                break;
            }

            dwErr = NO_ERROR;
        }

    } while(FALSE);

    if (dwErr != NO_ERROR) { closesocket(sock); }
    else { *psock = sock; }

    return dwErr;
}



DWORD
DiscoverRouters(
    SOCKET sock,
    PLIST_ENTRY rtrlist
    )
{

    INT iLength;
    PIPRIP_ENTRY pie;
    PIPRIP_HEADER phdr;
    SOCKADDR_IN sindest;
    DWORD dwErr, dwSize;
    PIPRIP_AUTHENT_ENTRY pae;
    BYTE pbuf[MAX_PACKET_SIZE];

    INT iErr;
    FD_SET fs;
    TIMEVAL tv;
    DWORD dwTicks, dwTicksBefore, dwTicksAfter;


    PRINT0("attempting to discover neighboring routers...");

    //
    // construct the RIP packet
    //

    phdr = (PIPRIP_HEADER)pbuf;
    pie = (PIPRIP_ENTRY)(phdr + 1);
    pae = (PIPRIP_AUTHENT_ENTRY)(phdr + 1);

    phdr->IH_Command = IPRIP_REQUEST;
    phdr->IH_Version = (CHAR)g_cfg.RIC_PacketVersion;
    phdr->IH_Reserved = 0;


    //
    // setup the authentication entry if necessary;
    // note that the code allows authentication in RIPv1 packets
    //

    if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae->IAE_AddrFamily = ADDRFAMILY_AUTHENT;
        pae->IAE_AuthType = (WORD)g_cfg.RIC_AuthType;
        RtlCopyMemory(
            pae->IAE_AuthKey,
            g_cfg.RIC_AuthKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        ++pie;
    }


    //
    // setup the single packet entry; we request a meaningless address
    //

    pie->IE_AddrFamily = htons(AF_INET);
    pie->IE_RouteTag = 0;
    pie->IE_Destination = 0xccddeeff;
    pie->IE_SubnetMask = 0;
    pie->IE_Nexthop = 0;
    pie->IE_Metric = htonl(IPRIP_INFINITE);


    dwSize = (ULONG) ((PBYTE)(pie + 1) - pbuf);


    //
    // send the route request to the RIP port
    //

    PRINT1("\tsending REQUEST to %s", INET_NTOA(g_cfg.RIC_RouteTarget));

    sindest.sin_family = AF_INET;
    sindest.sin_port = htons(IPRIP_PORT);
    sindest.sin_addr.s_addr = g_cfg.RIC_RouteTarget;

    iLength = sendto(
                sock, (PCCH)pbuf, dwSize, 0,
                (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                );
    if (iLength == SOCKET_ERROR || (DWORD)iLength < dwSize) {

        dwErr = WSAGetLastError();
        PRINT1("error %d sending route request", dwErr);
        return dwErr;
    }



    //
    // wait a while before collecting responses
    //

    Sleep(10000);


    //
    // repeatedly receive for the next 10 seconds
    //

    tv.tv_sec = 10;
    tv.tv_usec = 0;


    //
    // this loop executes until 10 seconds have elapsed
    //

    while (tv.tv_sec > 0) {

        FD_ZERO(&fs);
        FD_SET(sock, &fs);

        //
        // get the tick count beofre starting select
        //

        dwTicksBefore = GetTickCount();


        //
        // enter the call to select
        //

        iErr = select(0, &fs, NULL, NULL, &tv);


        //
        // compute the elapsed time
        //

        dwTicksAfter = GetTickCount();

        if (dwTicksAfter < dwTicksBefore) {
            dwTicks = dwTicksAfter + ((DWORD)-1 - dwTicksBefore);
        }
        else {
            dwTicks = dwTicksAfter - dwTicksBefore;
        }

        //
        // update the timeout
        //

        if (tv.tv_usec < (INT)(dwTicks % 1000) * 1000) {

            //
            // borrow a second from the tv_sec field
            //

            --tv.tv_sec;
            tv.tv_usec += 1000000;
        }

        tv.tv_usec -= (dwTicks % 1000) * 1000;
        tv.tv_sec -= (dwTicks / 1000);



        //  
        // process any incoming packets there might be
        //

        if (iErr != 0 && iErr != SOCKET_ERROR && FD_ISSET(sock, &fs)) {

            INT addrlen;
            SOCKADDR_IN sinsrc;
            PRIPTEST_ROUTER_INFO prs;


            //
            // receive the packet
            //

            addrlen = sizeof(sinsrc);

            iLength = recvfrom(
                        sock, (PCHAR)pbuf, MAX_PACKET_SIZE, 0,
                        (PSOCKADDR)&sinsrc, &addrlen
                        );
            if (iLength == 0 || iLength == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d receiving packet", dwErr);
                continue;
            }


            //
            // create a list entry for the responding router
            //

            dwErr = CreateRouterStatsEntry(
                        rtrlist, sinsrc.sin_addr.s_addr, &prs
                        );

            if (dwErr == NO_ERROR) {
                PRINT2(
                    "\treceived RESPONSE from %s (%s)",
                    INET_NTOA(sinsrc.sin_addr), prs->RRS_DnsName
                    );
            }
        }
    }

    if (rtrlist->Flink == rtrlist) {
        PRINT0("\tno neighboring routers discovered");
    }

    return NO_ERROR;
}



DWORD
GenerateRoutes(
    IPForwardEntry **pifelist
    )
{

    CHAR szAddress[20];
    IPForwardEntry *ifelist, *ife;
    DWORD dwRouteCount, dwNetworkCount;
    DWORD dwStartOffset, dwLowestAddress, dwHighestAddress;
    DWORD dw, dwErr, dwAddress, dwNexthop, dwSubnetMask, dwPrefixLength;


    dwNexthop = g_cfg.RIC_RouteNexthop;
    dwSubnetMask = g_cfg.RIC_RouteMask;
    dwPrefixLength = PREFIX_LENGTH(dwSubnetMask);


    //
    // find the last address in the start-address's network class
    //

    dwLowestAddress = g_cfg.RIC_RouteStart;

    dwHighestAddress =
        (CLASSA_ADDR(dwLowestAddress) ? inet_addr("126.255.255.255") :
        (CLASSB_ADDR(dwLowestAddress) ? inet_addr("191.255.255.255") :
        (CLASSC_ADDR(dwLowestAddress) ? inet_addr("223.255.255.255") : 0)));


    //
    // figure out how many networks the range can be split into
    // using the specified network mask
    //

    dwLowestAddress &= dwSubnetMask;
    dwNetworkCount = ((ntohl(dwHighestAddress) >> (32 - dwPrefixLength)) -
                      (ntohl(dwLowestAddress) >> (32 - dwPrefixLength)));


    //
    // choose a starting address for this iteration:
    // we have at most K routes, and we are sending n routes,
    // so the starting route must be at an offset of between 0 and (K - n)
    //

    dwRouteCount = g_cfg.RIC_RouteCount;

    dwStartOffset = RANDOM(&g_seed, 0, (dwNetworkCount - dwRouteCount));


    //
    // allocate the array of routes
    //

    *pifelist =
    ifelist = (IPForwardEntry *)HeapAlloc(
                                GetProcessHeap(), 0,
                                dwRouteCount * sizeof(IPForwardEntry)
                                );
    if (ifelist == NULL) {
        dwErr = GetLastError();
        PRINT2(
            "error %d allocating %d bytes for route list",
            dwErr, dwRouteCount * sizeof(IPForwardEntry)
            );
        return dwErr;
    }

    RtlZeroMemory(ifelist, dwRouteCount * sizeof(IPForwardEntry));


    //
    // fill the table with routes
    //

    for (dw = dwStartOffset; dw < (dwStartOffset + dwRouteCount); dw++) {

        dwAddress = NTH_ADDRESS(dwLowestAddress, dwPrefixLength, dw);

        ife = ifelist + (dw - dwStartOffset);
        ife->dwForwardDest = dwAddress;
        ife->dwForwardMask = dwSubnetMask;
        ife->dwForwardNextHop = dwNexthop;
    }


    return NO_ERROR;
}



DWORD
TransmitRoutes(
    SOCKET sock,
    DWORD dwMetric,
    IPForwardEntry *ifelist
    )
{

    INT iLength;
    WORD wRouteTag;
    PIPRIP_HEADER pih;
    SOCKADDR_IN sindest;
    PIPRIP_ENTRY pie, pistart, piend;
    PIPRIP_AUTHENT_ENTRY pae;
    IPForwardEntry *ife, *ifend;
    BYTE pbuf[2 * MAX_PACKET_SIZE];
    DWORD dwErr, dwEntryCount;


    //
    // setup the message's header
    //

    pih = (PIPRIP_HEADER)pbuf;
    pae = (PIPRIP_AUTHENT_ENTRY)(pih + 1);
    pistart = (PIPRIP_ENTRY)(pih + 1);


    pih->IH_Command = IPRIP_RESPONSE;
    pih->IH_Version = (CHAR)g_cfg.RIC_PacketVersion;
    pih->IH_Reserved = 0;


    //
    // setup the authentication entry if necessary;
    // note that the code allows authentication in RIPv1 packets
    //

    if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae->IAE_AddrFamily = ADDRFAMILY_AUTHENT;
        pae->IAE_AuthType = (WORD)g_cfg.RIC_AuthType;
        RtlCopyMemory(
            pae->IAE_AuthKey,
            g_cfg.RIC_AuthKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        ++pistart;
    }


    //
    // pick off the configured number of routes to put in the packet
    //

    if (g_cfg.RIC_PacketEntryCount != 0) {

        dwEntryCount = g_cfg.RIC_PacketEntryCount;
    }
    else {

        //
        // choose a random number of entries
        //

        if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_NONE) {
            dwEntryCount = RANDOM(&g_seed, 1, 25);
        }
        else {
            dwEntryCount = RANDOM(&g_seed, 1, 24);
        }
    }


    wRouteTag = LOWORD(g_cfg.RIC_RouteTag);

    sindest.sin_family = AF_INET;
    sindest.sin_port = htons(IPRIP_PORT);
    sindest.sin_addr.s_addr = g_cfg.RIC_RouteTarget;

    {
        DWORD dwCount;
        CHAR szDest[20], szFirst[20], szLast[20];
    
        dwCount = g_cfg.RIC_RouteCount;
        strcpy(szDest, INET_NTOA(sindest.sin_addr));
        strcpy(szFirst, INET_NTOA(ifelist->dwForwardDest));
        strcpy(szLast, INET_NTOA((ifelist + dwCount - 1)->dwForwardDest));
    
        PRINT5(
            "sending %d routes (%s - %s) to %s using metric %d",
            dwCount, szFirst, szLast, szDest, dwMetric
            );
    }


    //
    // loop filling the buffer with packets and sending it when its full
    //

    piend = pistart + dwEntryCount;
    ifend = ifelist + g_cfg.RIC_RouteCount;

    for (ife = ifelist, pie = pistart; ife < ifend; ife++, pie++) {

        //
        // send the current buffer if it is full
        //

        if (pie >= piend) {

            //
            // sleep for the specified packet-gap
            //

            Sleep(g_cfg.RIC_PacketGap);


            iLength = sendto(
                        sock, (PCCH)pbuf, (ULONG)((PBYTE)pie - pbuf), 0,
                        (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                        );
            if (iLength == SOCKET_ERROR || iLength < ((PBYTE)piend - pbuf)) {

                dwErr = WSAGetLastError();
                PRINT2(
                    "error %d sending packet to %s",
                    dwErr, INET_NTOA(sindest.sin_addr)
                    );
            }


            if (g_cfg.RIC_PacketEntryCount != 0) {
        
                dwEntryCount = g_cfg.RIC_PacketEntryCount;
            }
            else {
        
                //
                // choose a random number of entries
                //
        
                if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_NONE) {
                    dwEntryCount = RANDOM(&g_seed, 1, 25);
                }
                else {
                    dwEntryCount = RANDOM(&g_seed, 1, 24);
                }
            }

            piend = pistart + dwEntryCount;
            pie = pistart;
        }


        //
        // add another entry
        //

        pie->IE_AddrFamily = htons(AF_INET);
        pie->IE_Destination = ife->dwForwardDest;
        pie->IE_Metric = htonl(dwMetric);
        pie->IE_RouteTag = htons(wRouteTag);
        pie->IE_Nexthop = ife->dwForwardNextHop;
        pie->IE_SubnetMask = ife->dwForwardMask;

    }

    //
    // if there is anything left, send it
    //

    if (pie > pistart) {
        iLength = sendto(
                    sock, (PCCH)pbuf, (ULONG)((PBYTE)pie - pbuf), 0,
                    (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                    );
    }

    return NO_ERROR;
}



DWORD
VerifyRouteTables(
    DWORD dwMetric,
    PLIST_ENTRY rtrlist,
    IPForwardEntry *ifelist
    )
{

    PLIST_ENTRY ple;
    MIB_OPAQUE_QUERY roq;
    MIB_OPAQUE_INFO *proi;
    WCHAR pwsRouter[256];
    MIB_SERVER_HANDLE hRouter;
    PRIPTEST_ROUTER_INFO prrs;
    MIB_IPFORWARDTABLE *ifrlist;
    IPForwardEntry *ife, *ifend;
    MIB_IPFORWARDROW *ifr, *ifrend;
    DWORD dwInvalidMetrics, dwRoutesMissing;
    DWORD dwErr, dwNumEntries, dwInSize, dwOutSize;


    //
    // go through the list of routers, connecting to the Router
    // on each machine and querying its routing table
    //

    for (ple = rtrlist->Flink; ple != rtrlist; ple = ple->Flink) {

        prrs = CONTAINING_RECORD(ple, RIPTEST_ROUTER_INFO, RRS_Link);

        PRINT1("-----STATS FOR %s-----", prrs->RRS_DnsName);

        //
        // initialize the query arguments
        //

        mbstowcs(pwsRouter, prrs->RRS_DnsName, strlen(prrs->RRS_DnsName) + 1);

        roq.dwVarId = IP_FORWARDTABLE;
        dwInSize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);
        proi = NULL;
        dwOutSize = 0;


        //
        // perform the query
        //

        dwErr = MprAdminMIBServerConnect(pwsRouter, &hRouter);

        if (dwErr != NO_ERROR) {
            continue;
        }

        dwErr = MprAdminMIBEntryGet(
                    hRouter, PID_IP, IPRTRMGR_PID,
                    (PVOID)&roq, dwInSize, (PVOID *)&proi, &dwOutSize
                    );


        if (dwErr != NO_ERROR) {

            PRINT2(
                "error %d querying route table on server %s",
                dwErr, prrs->RRS_DnsName
                );
            MprAdminMIBServerDisconnect(hRouter);
            continue;
        }
        else
        if (proi == NULL) {

            PRINT1(
                "empty route table retrieved from server %s",
                prrs->RRS_DnsName
                );
            MprAdminMIBServerDisconnect(hRouter);
            continue;
        }



        //
        // look through the table of routes retrieved,
        // to verify thats the routes advertised are among them
        //

        dwRoutesMissing = 0;
        dwInvalidMetrics = 0;

        ifrlist = (PMIB_IPFORWARDTABLE)(proi->rgbyData);

        dwNumEntries = ifrlist->dwNumEntries;
        ifend = ifelist + g_cfg.RIC_RouteCount;

        for (ife = ifelist; ife < ifend; ife++) {

            //
            // each time we find an advertised route,
            // we swap it to the end of the table; 
            // thus, the size of the table that we need to search
            // decreases with the number of routes we have found
            //

            ifrend = ifrlist->table + dwNumEntries;

            for (ifr = ifrlist->table; ifr < ifrend; ifr++) {

                if (ife->dwForwardDest == ifr->dwForwardDest) {

                    if (ifr->dwForwardMetric1 == (dwMetric + 1)) {
                        ife->dwForwardMetric5 = ROUTE_STATUS_OK;
                    }
                    else {

                        //
                        // set the status for this route
                        //

                        ++dwInvalidMetrics;
                        ife->dwForwardMetric5 = ROUTE_STATUS_METRIC;

                        PRINT3(
                            "\troute to %s has metric %d, expected %d",
                            INET_NTOA(ife->dwForwardDest),
                            ife->dwForwardMetric1, dwMetric + 1
                            );
                    }


                    //
                    // overwrite with the item at the end of the table;
                    // if we are at the end of the table, do nothing
                    //

                    if (ifr != (ifrend - 1)) { *ifr = *(ifrend - 1); }
                    --dwNumEntries;

                    break;
                }
            }


            //
            // if the item wasn't found, mark it as such
            //

            if (ifr >= ifrend) {

                ++dwRoutesMissing;
                ife->dwForwardMetric5 = ROUTE_STATUS_MISSING;

                PRINT1("\troute to %s missing", INET_NTOA(ife->dwForwardDest));
            }
        }


        MprAdminMIBBufferFree(proi);
        MprAdminMIBServerDisconnect(hRouter);

        PRINT2("%20s == %d", "routes missing", dwRoutesMissing);
        PRINT2("%20s == %d", "invalid metrics", dwInvalidMetrics);
    }

    return NO_ERROR;
}



DWORD
CreateRouterStatsEntry(
    PLIST_ENTRY rtrlist,
    DWORD dwAddress,
    PRIPTEST_ROUTER_INFO *pprrs
    )
{

    DWORD dwErr;
    PHOSTENT phe;
    PRIPTEST_ROUTER_INFO prrs;


    phe = gethostbyaddr((const char *)&dwAddress, sizeof(DWORD), PF_INET);

    if (phe == NULL) {
        dwErr = WSAGetLastError();
        PRINT2(
            "error %d retrieving name for host %s", dwErr, INET_NTOA(dwAddress)
            );
        return dwErr;
    }

    prrs = (PRIPTEST_ROUTER_INFO)HeapAlloc(
                                    GetProcessHeap(), 0,
                                    sizeof(RIPTEST_ROUTER_INFO)
                                    );
    if (prrs == NULL) {
        dwErr = GetLastError();
        PRINT2(
            "error %d allocating %d bytes for router stats",
            dwErr, sizeof(RIPTEST_ROUTER_INFO)
            );
        return dwErr;
    }


    RtlZeroMemory(prrs, sizeof(RIPTEST_ROUTER_INFO));

    prrs->RRS_Address = dwAddress;
    strcpy(prrs->RRS_DnsName, phe->h_name);

    InsertHeadList(rtrlist, &prrs->RRS_Link);

    if (pprrs != NULL) { *pprrs = prrs; }

    return NO_ERROR;
}



DWORD
PrintUsage(
    VOID
    )
{

    printf("usage:  riptest [adapter_guid]");
    printf("\n\te.g. riptest {73C2D5F0-A352-11D1-9043-0060089FC48B}\n");
    printf("\n\tThe first time RIPTEST is run, it sets up the registry");
    printf("\n\twith defaults for the specified adapter.");
    printf("\n");

    return NO_ERROR;
}


} // end extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\riptest.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    riptest.h
//
// History:
//  Abolade Gbadegesin  Oct-16-1995     Created
//
// Declarations for the RIP test program.
//============================================================================


//
// These strings are used to access the registry
//

#define STR_SERVICES        "System\\CurrentControlSet\\Services\\"
#define STR_RIPTEST         "RipTest"
#define STR_PARAMSTCP       "\\Parameters\\Tcpip"

#define STR_ENABLEDHCP      "EnableDhcp"
#define STR_ADDRESS         "IPAddress"
#define STR_NETMASK         "SubnetMask"
#define STR_DHCPADDR        "DhcpIPAddress"
#define STR_DHCPMASK        "DhcpSubnetMask"

#define STR_ROUTECOUNT      "RouteCount"
#define STR_ROUTESTART      "RouteStart"
#define STR_ROUTEMASK       "RouteMask"
#define STR_ROUTENEXTHOP    "RouteNexthop"
#define STR_ROUTETAG        "RouteTag"
#define STR_ROUTETARGET     "RouteTarget"
#define STR_ROUTETIMEOUT    "RouteTimeout"
#define STR_PACKETVERSION   "PacketVersion"
#define STR_PACKETENTRYCOUNT "PacketEntryCount"
#define STR_PACKETGAP       "PacketGap"
#define STR_AUTHKEY         "AuthKey"
#define STR_AUTHTYPE        "AuthType"
#define STR_SOCKBUFSIZE     "SockBufSize"


//
// these definitions are used for socket setup
//
#define RIP_PORT            520
#define RIPTEST_PORT        521

//
// the field ire_metric5 is used as a status field, with these values
//

#define ROUTE_STATUS_OK         0
#define ROUTE_STATUS_METRIC     1
#define ROUTE_STATUS_MISSING    2


//
//
//

typedef MIB_IPFORWARDROW IPForwardEntry;

//
// This type is for a generic registry-access function.
// Such a function reads the given key, and if the option
// specified is found, it reads it. Otherwise, it uses the default
// and writes the default value to the registry.
//

struct _REG_OPTION;

typedef
DWORD
(*REG_GETOPT_FUNCTION)(
    HKEY hKey, 
    struct _REG_OPTION *pOpt
    );



//
// This type is for a generic RIPTEST option.
//
//  RO_Name     used to retrieve the value from its registry key
//  RO_Size     for strings and binary values; gives maximum size
//  RO_OptVal   contains the option's value 
//  RO_DefVal   contains the default value for the option
//  RO_GetOpt   contains the function used to retrieve this value
//

typedef struct _REG_OPTION {

    PSTR        RO_Name;
    DWORD       RO_Size;
    PVOID       RO_OptVal;
    PVOID       RO_DefVal;
    REG_GETOPT_FUNCTION RO_GetOpt;

} REG_OPTION, *PREG_OPTION;



//
// This type is used to hold all RIPTEST's parameters for a given interface
//  

typedef struct _RIPTEST_IF_CONFIG {

    DWORD       RIC_RouteCount;
    DWORD       RIC_RouteStart;
    DWORD       RIC_RouteMask;
    DWORD       RIC_RouteNexthop;
    DWORD       RIC_RouteTag;
    DWORD       RIC_RouteTarget;
    DWORD       RIC_RouteTimeout;
    DWORD       RIC_PacketVersion;
    DWORD       RIC_PacketEntryCount;
    DWORD       RIC_PacketGap;
    BYTE        RIC_AuthKey[IPRIP_MAX_AUTHKEY_SIZE];
    DWORD       RIC_AuthType;
    DWORD       RIC_SockBufSize;

} RIPTEST_IF_CONFIG, *PRIPTEST_IF_CONFIG;


//
// structure used to store binding for an interface
//

typedef struct _RIPTEST_IF_BINDING {

    DWORD       RIB_Address;
    DWORD       RIB_Netmask;
    WCHAR       RIB_Netcard[128];

} RIPTEST_IF_BINDING, *PRIPTEST_IF_BINDING;


//
// struct used to store information for a responding router 
//

typedef struct _RIPTEST_ROUTER_INFO {

    DWORD       RRS_Address;
    CHAR        RRS_DnsName[64];

    LIST_ENTRY  RRS_Link;

} RIPTEST_ROUTER_INFO, *PRIPTEST_ROUTER_INFO;


//
// macros used to compute prefix length of a network mask:
// the prefix length is the nubmer of bits set in the mask, assuming
// that the mask is contiguous
//

#define PREFIX_LENGTH(a)   PREFIX_LENGTH32(a)

#define PREFIX_LENGTH32(a)    \
    (((a) & 0x00000100) ? PREFIX_LENGTH16((a) >> 16) + 16   \
                        : PREFIX_LENGTH16(a))

#define PREFIX_LENGTH16(a)  \
    (((a) & 0x0001) ? PREFIX_LENGTH8((a) >> 8) + 8  \
                    : PREFIX_LENGTH8(a))

#define PREFIX_LENGTH8(a)   \
    (((a) & 0x01) ? 8 : \
    (((a) & 0x02) ? 7 : \
    (((a) & 0x04) ? 6 : \
    (((a) & 0x08) ? 5 : \
    (((a) & 0x10) ? 4 : \
    (((a) & 0x20) ? 3 : \
    (((a) & 0x40) ? 2 : \
    (((a) & 0x80) ? 1 : 0))))))))


//
//
//

#define NTH_ADDRESS(addr, preflen, n)   \
    htonl(((ntohl(addr) >> (32 - (preflen))) + (n)) << (32 - (preflen)))

//
//
//

#if 1
#define RANDOM(seed, min, max)  \
    ((min) +    \
    (DWORD)((DOUBLE)rand() / ((DOUBLE)RAND_MAX + 1) * \
            ((max) - (min) + 1)))
#else
#define RANDOM(seed, min, max)  \
    ((min) +    \
    (DWORD)((DOUBLE)RtlRandom(seed) / ((DOUBLE)MAXLONG + 1) * \
            ((max) - (min) + 1)))
#endif


//
// IP address conversion macro
//
#define INET_NTOA(addr) inet_ntoa( *(PIN_ADDR)&(addr) )


//
// macros used to generate tracing output
//

#ifdef RTUTILS

#define PRINTREGISTER(a)  TraceRegister(a)
#define PRINTDEREGISTER(a)  TraceDeregister(a)

#define PRINT0(a) \
        TracePrintf(g_TraceID,a)
#define PRINT1(a,b) \
        TracePrintf(g_TraceID,a,b)
#define PRINT2(a,b,c) \
        TracePrintf(g_TraceID,a,b,c)
#define PRINT3(a,b,c,d) \
        TracePrintf(g_TraceID,a,b,c,d)
#define PRINT4(a,b,c,d,e) \
        TracePrintf(g_TraceID,a,b,c,d,e)
#define PRINT5(a,b,c,d,e,f) \
        TracePrintf(g_TraceID,a,b,c,d,e,f)

#else

#define PRINTREGISTER(a) INVALID_TRACEID
#define PRINTDEREGISTER(a) 

#define PRINT0(a) \
        printf("\n"a)
#define PRINT1(a,b) \
        printf("\n"a,b)
#define PRINT2(a,b,c) \
        printf("\n"a,b,c)
#define PRINT3(a,b,c,d) \
        printf("\n"a,b,c,d)
#define PRINT4(a,b,c,d,e) \
        printf("\n"a,b,c,d,e)
#define PRINT5(a,b,c,d,e,f) \
        printf("\n"a,b,c,d,e,f)

#endif


//
// functions used to access options in the registry
//

DWORD
RegGetConfig(
    VOID
    );

DWORD
RegGetAddress(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetDWORD(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetBinary(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetIfBinding(
    VOID
    );

DWORD
InitializeSocket(
    SOCKET *psock,
    WORD wPort
    );

DWORD
GenerateRoutes(
    IPForwardEntry **pifelist
    );

DWORD
DiscoverRouters(
    SOCKET sock,
    PLIST_ENTRY rtrlist
    );

DWORD
TransmitRoutes(
    SOCKET sock,
    DWORD dwMetric,
    IPForwardEntry *ifelist
    );

DWORD
VerifyRouteTables(
    DWORD dwMetric,
    PLIST_ENTRY rtrlist,
    IPForwardEntry *ifelist
    );

DWORD
CreateRouterStatsEntry(
    PLIST_ENTRY rtrlist,
    DWORD dwAddress,
    PRIPTEST_ROUTER_INFO *pprrs
    );

DWORD
PrintUsage(
    VOID
    );

DWORD
RipTest(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\table.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: table.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
//      V Raman             Oct-3-1996
//                          Added code to create/delete/wait on
//                          ITE_DeactivateEvent.  Also added code to set
//                          ITE_Flags when deactivate is pending.
//
//      V Raman             Oct-27-1996
//                          Removed deactivate event and made 
//                          DeactivateInterface synchronous
//                          
// interface table and peer table implementation
//============================================================================

#include "pchrip.h"
#pragma hdrstop


DWORD CreateIfSocket(PIF_TABLE_ENTRY pITE);
DWORD DeleteIfSocket(PIF_TABLE_ENTRY pITE);
DWORD InsertIfByAddress(PIF_TABLE pTable, PIF_TABLE_ENTRY pITE);
DWORD InsertPeerByAddress(PPEER_TABLE pTable, PPEER_TABLE_ENTRY pPTE);
DWORD AddNeighborToIfConfig(DWORD dwRemoteAddress, PIF_TABLE_ENTRY pite);



//----------------------------------------------------------------------------
// Function:    CreateIfTable
//
// initializes an interface table
//----------------------------------------------------------------------------

DWORD
CreateIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead, plstart, plend;


    //
    // initialize the multiple-reader/single-writer synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->IT_RWL);
    if (dwErr != NO_ERROR) {
        TRACE1(IF, "error %d creating read-write-lock", dwErr);
        return dwErr;
    }


    //
    // initialize the hash table
    //

    plstart = pTable->IT_HashTableByIndex;
    plend = plstart + IF_HASHTABLE_SIZE;
    for (phead = plstart; phead < plend; phead++) {
        InitializeListHead(phead);
    }

    //
    // initialize the lists ordered by address and by index
    //

    InitializeListHead(&pTable->IT_ListByAddress);
    InitializeListHead(&pTable->IT_ListByIndex);


    //
    // initialize the table's critical section
    //

    try {
        InitializeCriticalSection(&pTable->IT_CS);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }


    //
    // Create timers for full updates and for triggered updates
    //

    if (!CreateTimerQueueTimer(
            &pTable->IT_FinishFullUpdateTimer,
            ig.IG_TimerQueueHandle,
            WorkerFunctionFinishFullUpdate, NULL,
            10000000, 10000000, 0
            )) {

        dwErr = GetLastError();
        TRACE1(IF, "error %d creating finish full update timer", dwErr);
        return dwErr;
    }            
    
    if (!CreateTimerQueueTimer(
            &pTable->IT_FinishTriggeredUpdateTimer,
            ig.IG_TimerQueueHandle,
            WorkerFunctionFinishTriggeredUpdate, NULL,
            10000000, 10000000, 0
            )) {

        dwErr = GetLastError();
        TRACE1(IF, "error %d creating finish triggered update timer", dwErr);
        return dwErr;
    }            


    //
    // initialize remainder of struct
    //

    if (dwErr == NO_ERROR) {

        pTable->IT_Created = 0x12345678;
        pTable->IT_Flags = 0;

        pTable->IT_LastUpdateTime.LowPart =
        pTable->IT_LastUpdateTime.HighPart = 0;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfTable
//
// frees resources used by an interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwIndex;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, plend, phead;


    //
    // free memory for all existing interfaces
    //

    plend = pTable->IT_HashTableByIndex + IF_HASHTABLE_SIZE;
    for (ple = plend - IF_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            pite = CONTAINING_RECORD(phead, IF_TABLE_ENTRY, ITE_HTLinkByIndex);

            if (IF_IS_BOUND(pite)) {

                DeleteIfSocket(pite);

                if (IF_IS_ENABLED(pite)) {
                    RemoveEntryList(&pite->ITE_LinkByAddress);
                }

                RIP_FREE(pite->ITE_Binding);
            }
            
            RIP_FREE(pite->ITE_Config);
            RIP_FREE(pite);
        }
    }


    //
    // delete synchronization objects
    //

    DeleteCriticalSection(&pTable->IT_CS);
    DeleteReadWriteLock(&pTable->IT_RWL);

    pTable->IT_Created = 0;
    pTable->IT_Flags = 0;
    
    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    CreateIfEntry
//
// inserts an entry into the interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIPRIP_IF_CONFIG pConfig,
    PIF_TABLE_ENTRY *ppEntry
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    PIPRIP_IF_CONFIG picsrc, picdst;

    if (ppEntry != NULL) { *ppEntry = NULL; }

    dwErr = NO_ERROR;


    do {

        //
        // fail if the interface exists
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite != NULL) {

            pite = NULL;
            TRACE1(IF, "interface %d already exists", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // allocate memory for the new interface
        //

        pite = RIP_ALLOC(sizeof(IF_TABLE_ENTRY));

        if (pite == NULL) {

            dwErr = GetLastError();
            TRACE3(
                ANY, "error %d allocating %d bytes for interface %d",
                dwErr, sizeof(IF_TABLE_ENTRY), dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize interface fields
        //
    
        pite->ITE_Index = dwIndex;
        pite->ITE_Type = dwIfType;
    
        //
        // Change semantics to come up in UNBOUND-DISABLED state
        //
 
        //pite->ITE_Flags = ITEFLAG_ENABLED;
        pite-> ITE_Flags = 0;
        
        pite->ITE_Config = NULL;
        pite->ITE_Binding = NULL;
        pite->ITE_Sockets = NULL;
        pite->ITE_FullOrDemandUpdateTimer = NULL;

        picsrc = (PIPRIP_IF_CONFIG)pConfig;
        dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);
        

        //
        // validate the configuration parameters
        //

        dwErr = ValidateIfConfig(pConfig);
        if (dwErr != NO_ERROR) {
            TRACE1(IF, "invalid config specified for interface %d", dwIndex);
            break;
        }


        //
        // allocate space to hold the interface configuration
        //

        pite->ITE_Config = picdst = RIP_ALLOC(dwSize);

        if (picdst == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for interface %d config",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the configuration
        //

        CopyMemory(picdst, picsrc, dwSize);


        //
        // initialize the binding information and interface stats
        //

        pite->ITE_Binding = NULL;
        ZeroMemory(&pite->ITE_Stats, sizeof(IPRIP_IF_STATS));
    

        //
        // insert the interface in the hash table
        //

        InsertHeadList(
            pTable->IT_HashTableByIndex + IF_HASHVALUE(dwIndex),
            &pite->ITE_HTLinkByIndex
            );


        //
        // insert the interface in the list ordered by index
        //

        phead = &pTable->IT_ListByIndex;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            PIF_TABLE_ENTRY ptemp;

            ptemp = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
            if (pite->ITE_Index < ptemp->ITE_Index) { break; }
        }

        InsertTailList(ple, &pite->ITE_LinkByIndex);

        if (ppEntry != NULL) { *ppEntry = pite; }
    
    } while(FALSE);


    if (dwErr != NO_ERROR && pite != NULL) {
        if (pite->ITE_Config != NULL) { RIP_FREE(pite->ITE_Config); }
        RIP_FREE(pite);
    }
    
    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfEntry
//
// removes an entry from the interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    PIF_TABLE_ENTRY pite;

    //
    // find the interface if it exists
    //

    pite = GetIfByIndex(pTable, dwIndex);

    if (pite == NULL) {
        TRACE1(IF, "could not find interface %d", dwIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // cleanup the socket depending on its state
    //

    if (IF_IS_BOUND(pite)) {

        DeleteIfSocket(pite);

        if (IF_IS_ENABLED(pite)) {
            RemoveEntryList(&pite->ITE_LinkByAddress);
        }

        RIP_FREE(pite->ITE_Binding);
    }


    //
    // remove it from the list ordered by index
    // as well as from the hash table
    //

    RemoveEntryList(&pite->ITE_LinkByIndex);
    RemoveEntryList(&pite->ITE_HTLinkByIndex);


    RIP_FREE(pite->ITE_Config);
    RIP_FREE(pite);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    ValidateIfConfig
//
// Checks the parameters in an IPRIP_IF_CONFIG structure.
//----------------------------------------------------------------------------

DWORD
ValidateIfConfig(
    PIPRIP_IF_CONFIG pic
    ) {

    CHAR    szStr[12];
    
    if (pic->IC_Metric > IPRIP_INFINITE) {

        TRACE1(
            IF, "Invalid interface metric %d specified", 
            pic->IC_Metric
            );
            
        _ltoa(pic->IC_Metric, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Metric", szStr, ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }


    if (pic->IC_UpdateMode != IPRIP_UPDATE_PERIODIC &&
        pic->IC_UpdateMode != IPRIP_UPDATE_DEMAND) {

        TRACE1(
            IF, "Invalid update mode %d specified", 
            pic->IC_UpdateMode
            );
            
        _ltoa(pic->IC_UpdateMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Update Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AcceptMode != IPRIP_ACCEPT_DISABLED &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP1 &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP1_COMPAT &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP2) {

        TRACE1(
            IF, "Invalid accept mode %d specified", 
            pic->IC_AcceptMode
            );
            
        _ltoa(pic->IC_AcceptMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Accept Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1 &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1_COMPAT &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP2) {

        TRACE1(
            IF, "Invalid announce mode %d specified", 
            pic->IC_AnnounceMode
            );
            
        _ltoa(pic->IC_AnnounceMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Announce Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AuthenticationType != IPRIP_AUTHTYPE_NONE &&
        pic->IC_AuthenticationType != IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        TRACE1(
            IF, "Invalid authentication type %d specified", 
            pic->IC_AuthenticationType
            );
            
        _ltoa(pic->IC_AuthenticationType, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Authentication Type", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED &&
        pic->IC_UnicastPeerMode != IPRIP_PEER_ALSO &&
        pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

        TRACE1(
            IF, "Invalid unicast peer mode %d specified", 
            pic->IC_UnicastPeerMode
            );
            
        _ltoa(pic->IC_UnicastPeerMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "unicast peer mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AcceptFilterMode != IPRIP_FILTER_DISABLED &&
        pic->IC_AcceptFilterMode != IPRIP_FILTER_INCLUDE &&
        pic->IC_AcceptFilterMode != IPRIP_FILTER_EXCLUDE) {

        TRACE1(
            IF, "Invalid accept filter mode %d specified", 
            pic->IC_AcceptFilterMode
            );
            
        _ltoa(pic->IC_AcceptFilterMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Accept filter mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AnnounceFilterMode != IPRIP_FILTER_DISABLED &&
        pic->IC_AnnounceFilterMode != IPRIP_FILTER_INCLUDE &&
        pic->IC_AnnounceFilterMode != IPRIP_FILTER_EXCLUDE) {

        TRACE1(
            IF, "Invalid announce filter mode %d specified", 
            pic->IC_AnnounceFilterMode
            );
            
        _ltoa(pic->IC_AnnounceFilterMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Announce filter mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    BindIfEntry
//
// Updates the binding information for the specified interface.
// Assumes interface table is locked for writing
//----------------------------------------------------------------------------

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    ) {

    DWORD i, j, dwErr = NO_ERROR, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PIP_ADAPTER_BINDING_INFO piabi;
    BOOL bFound;

    pib = NULL;

    do {

        //
        // retrieve the interface entry
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // If the interface is already bound, check to see if he is giving
        // us a different binding. If he is, then it is an error. Otherwise
        // we shall be obliging and not complain too much
        //

        if (IF_IS_BOUND(pite)) {
           
            TRACE1(IF, "interface %d is already bound", dwIndex);
 
            pib = pite->ITE_Binding;

            if(pib->IB_AddrCount != pBinding->AddressCount)
            {
                TRACE1(IF, "interface %d is bound and has different binding",dwIndex);

                dwErr = ERROR_INVALID_PARAMETER;

                break;
            }

            paddr = IPRIP_IF_ADDRESS_TABLE(pib);

            for(i = 0; i < pBinding->AddressCount; i++)
            {
                bFound = FALSE;
            
                for(j = 0; j < pib->IB_AddrCount; j++)
                {
                    if((paddr[j].IA_Address == pBinding->Address[i].Address) &&
                       (paddr[j].IA_Netmask == pBinding->Address[i].Mask))
                    {
                        bFound = TRUE;
                        
                        break;
                    }
                }

                if(!bFound)
                {
                    TRACE1(IF,"interface %d is bound and has different binding",dwIndex);

                    dwErr = ERROR_INVALID_PARAMETER;
            
                    break;
                }
            }

            //
            // At this time we have dwErr as either NO_ERROR or
            // ERROR_INVALID_PARAMETER. Either case we can break here
            // since we are done
            //

            break;
        }


        //
        // make sure there is at least one address
        //

        if (pBinding->AddressCount == 0) { break; }

        dwSize = sizeof(IPRIP_IF_BINDING) +
                    pBinding->AddressCount * sizeof(IPRIP_IP_ADDRESS);


        //
        // allocate memory to store the binding
        // in our format
        //

        pib = RIP_ALLOC(dwSize);

        if (pib == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for binding on interface %d",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // convert the binding into our format
        //

        pib->IB_AddrCount = pBinding->AddressCount;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);
        
        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            paddr->IA_Address = pBinding->Address[i].Address;
            paddr->IA_Netmask = pBinding->Address[i].Mask;
        }


        //
        // save the binding in the interface entry
        //

        pite->ITE_Binding = pib;


#if 0
        //
        // for demand dial interfaces add neighbor
        //

        if ( pite-> ITE_Type == DEMAND_DIAL ) {

            dwErr = AddNeighborToIfConfig( pBinding-> RemoteAddress, pite );

            if ( dwErr != NO_ERROR ) { break ; }
        }
#endif

        //
        // create sockets for interface's addresses
        //

        dwErr = CreateIfSocket(pite);

        if (dwErr != NO_ERROR) {

            TRACE2(
                IF, "error %d creating sockets for interface %d", dwErr, dwIndex
                );

            break;
        }


        //
        // mark the interface as being bound
        //

        pite->ITE_Flags |= ITEFLAG_BOUND;

    
        //
        // we save the binding information in a private table
        // so it can be quickly accessed and searched when we are
        // trying to guess subnet masks given IP addresses;
        //
    
        ACQUIRE_BINDING_LOCK_EXCLUSIVE();
    
        dwErr = CreateBindingEntry(ig.IG_BindingTable, pib);
    
        RELEASE_BINDING_LOCK_EXCLUSIVE();
    

        //
        // if interface is also enabled, it is now active
        // so queue activation work-item
        //

        if (IF_IS_ENABLED(pite)) {

            //
            // place interface on the list of active interfaces
            //

            dwErr = InsertIfByAddress(pTable, pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );

                pite->ITE_Flags &= ~ITEFLAG_BOUND;

                DeleteIfSocket(pite);

                break;
            }


            //
            // queue the work-item to send initial request
            //

            dwErr = QueueRipWorker(
                        WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                        );
        
            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d queuing work-item for interface %d",
                    dwErr, dwIndex
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                RemoveEntryList(&pite->ITE_LinkByAddress);

                pite->ITE_Flags &= ~ITEFLAG_BOUND;

                DeleteIfSocket(pite);

                break;
            }
        }

    } while(FALSE);


    if (dwErr != NO_ERROR) {

        if (pib) { RIP_FREE(pib); }

        if (pite) { pite->ITE_Binding = NULL; }
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    UnBindIfEntry
//
// removes the binding for the specified interface.
// assumes the interface table is locked for writing.
//----------------------------------------------------------------------------

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;


    do {

        //
        // retrieve the interface specified
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // quit if the interface is already unbound 
        //

        if (IF_IS_UNBOUND(pite)) {

            dwErr = ERROR_INVALID_PARAMETER;
            TRACE1(
                IF, "interface %d is already unbound", dwIndex
                );

            break;
        }


        //
        // clear the "bound" flag
        //

        pite->ITE_Flags &= ~ITEFLAG_BOUND;


        //
        // if the interface isn't enabled, close the socket for the interface;
        // if the interface is enabled, that means it was active
        // and we must queue the deactivation work-item
        //

        if (!IF_IS_ENABLED(pite)) {

            DeleteIfSocket(pite);

            ACQUIRE_BINDING_LOCK_EXCLUSIVE();
        
            dwErr = DeleteBindingEntry(ig.IG_BindingTable, pite->ITE_Binding);
        
            RELEASE_BINDING_LOCK_EXCLUSIVE();

            RIP_FREE(pite->ITE_Binding);
            pite->ITE_Binding = NULL;
        }
        else {

            //
            // the interface was active, so deactivate it
            //
            // remove from active list
            //

            RemoveEntryList(&pite->ITE_LinkByAddress);
        

            WorkerFunctionDeactivateInterface( (PVOID)UlongToPtr(dwIndex));

            //
            // close the socket ourselves if required
            //

            if ( pite-> ITE_Binding ) {
                
                DeleteIfSocket(pite);

                ACQUIRE_BINDING_LOCK_EXCLUSIVE();

                dwErr = DeleteBindingEntry(
                            ig.IG_BindingTable, pite->ITE_Binding
                            );
            
                RELEASE_BINDING_LOCK_EXCLUSIVE();

                RIP_FREE(pite->ITE_Binding);
                pite->ITE_Binding = NULL;
            }

            else {

                dwErr = NO_ERROR;
            }
            
        }
        
    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    EnableIfEntry
//
// configures an interface for RIP activity, including setting up
// a socket and linking the interface into the list ordered by address.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, phead;
    PIF_TABLE_ENTRY pite;

    do {


        //
        // retrieve the interface
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {

            TRACE1(IF, "could not find interface %d",dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // quit if the interface is already enabled
        // 

        if (IF_IS_ENABLED(pite)) {

            TRACE1(IF, "interface %d is already enabled", dwIndex);
            dwErr = NO_ERROR;

            break;
        }
    
    
        pite->ITE_Flags |= ITEFLAG_ENABLED;
    

        //
        // if interface is already bound, it is now active,
        // so queue the interface activation work-item
        //

        if (IF_IS_BOUND(pite)) {


            //
            // place interface on the list of active interfaces
            //

            dwErr = InsertIfByAddress(pTable, pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );
    
                pite->ITE_Flags &= ~ITEFLAG_ENABLED;

                break;
            }


            //
            // queue the work-item to send initial request
            //

            dwErr = QueueRipWorker(
                        WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                        );
        
            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d queuing work-item for interface %d",
                    dwErr, dwIndex
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                RemoveEntryList(&pite->ITE_LinkByAddress);
        
                pite->ITE_Flags &= ~ITEFLAG_ENABLED;

                break;
            }

        }

        dwErr = NO_ERROR;
        
    } while(FALSE);
    
    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    ConfigureIfEntry
//
// modifies the configuration for an already-existing interface
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIPRIP_IF_CONFIG pConfig
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG picsrc, picdst;

    dwErr = NO_ERROR;


    do {

        //
        // retrieve the interface to be configured
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {
            TRACE1(IF, "could not find interface %d", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    

        //
        // get the size of the new configuration
        //

        picsrc = (PIPRIP_IF_CONFIG)pConfig;
        dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);

    
        //
        // validate the new configuration
        //

        dwErr = ValidateIfConfig(picsrc);

        if (dwErr != NO_ERROR) {

            TRACE1(IF, "invalid config specified for interface %d", dwIndex);

            break;
        }
    

        //
        // allocate space to hold the new configuration
        //

        picdst = RIP_ALLOC(dwSize);
        if (picdst == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for interface %d config",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the new configuration, and free the old one
        //

        CopyMemory(picdst, picsrc, dwSize);

        if (pite->ITE_Config != NULL) { RIP_FREE(pite->ITE_Config); }
        pite->ITE_Config = picdst;



        //
        // if the interface is bound, re-initialize the interface
        //
    
        if (IF_IS_BOUND(pite)) {

            //
            // close the sockets and set them up again
            //

            dwErr = DeleteIfSocket(pite);

            dwErr = CreateIfSocket(pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d creating sockets for interface %d",
                    dwErr, dwIndex
                    );

                break;
            }
    


            //
            // re-activate the interface if it is active
            //

            if (IF_IS_ENABLED(pite)) {

                //
                // queue the work-item to activate the interface
                //

                dwErr = QueueRipWorker(
                            WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                            );

                if (dwErr != NO_ERROR) {

                    TRACE2(
                        IF, "error %d queueing work-item for interface %d",
                        dwErr, dwIndex
                        );
                    LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                    break;
                }
            }
    
        }
    
        dwErr = NO_ERROR;

    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DisableIfEntry
//
// stops RIP activity on an interface, removing the interface
// from the list of interfaces ordered by address.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;

    do {


        //
        // retrieve the interface to be disabled
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {
            TRACE1(IF, "could not find interface %d", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    

        //
        // quit if already disabled
        //

        if (IF_IS_DISABLED(pite)) {
            TRACE1(IF, "interface %d is already disabled", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // clear the enabled flag 
        //

        pite->ITE_Flags &= ~ITEFLAG_ENABLED;


        //
        // if this interface was not bound, clearing the flag is enough;
        // if the interface was bound (and therefore active),
        // deactivate it here
        //

        if (IF_IS_BOUND(pite)) {

            //
            // remove from active list
            //

            RemoveEntryList(&pite->ITE_LinkByAddress);
    

            //
            // execute the work-item to send final updates
            //

            WorkerFunctionDeactivateInterface( (PVOID) UlongToPtr(dwIndex) );
        }
        
        dwErr = NO_ERROR;

    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    CreateIfSocket
//
// creates sockets for an interface, setting it up according to
// the configuration including in the interface control block.
// this assumes the table containing the interface is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pite
    ) {

    SOCKADDR_IN sinsock;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwOption, dwIndex;
    LPSTR lpszAddr;

    
    pic = pite->ITE_Config;
    pib = pite->ITE_Binding;
    dwIndex = pite->ITE_Index;

    //
    // allocate an array of sockets
    //

    pite->ITE_Sockets = RIP_ALLOC(pib->IB_AddrCount * sizeof(SOCKET));
    if (pite->ITE_Sockets == NULL) {

        dwErr = GetLastError();
        TRACE3(
            IF, "error %d allocating %d bytes for interface %d sockets",
            dwErr, pib->IB_AddrCount * sizeof(SOCKET), dwIndex
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    //
    // initialize the array of sockets
    //

    for (i = 0; i < pib->IB_AddrCount; i++) {
        pite->ITE_Sockets[i] = INVALID_SOCKET;
    }


    //
    // create sockets for each address in the binding
    //

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);
    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {


        //
        // create the socket
        //

        pite->ITE_Sockets[i] = WSASocket(
                                AF_INET, SOCK_DGRAM, 0, NULL, 0, 0
                                );

        if (pite->ITE_Sockets[i] == INVALID_SOCKET) {

            dwErr = WSAGetLastError();
            lpszAddr = INET_NTOA(paddr->IA_Address);

            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d creating socket for interface %d (%s)",
                    dwErr, dwIndex, lpszAddr
                    );
                LOGERR1(CREATE_SOCKET_FAILED_2, lpszAddr, dwErr);
            }
            break;
        }

        //
        // try to increase the recv buffer size
        //

        dwOption = RIPRECVBUFFERSIZE;

        dwErr = setsockopt(
                    pite->ITE_Sockets[i], SOL_SOCKET, SO_RCVBUF,
                    (PBYTE)&dwOption, sizeof(dwOption)
                    );

        if (dwErr == SOCKET_ERROR) {

            dwErr = WSAGetLastError();

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d setting SO_RCVBUF for interface %d (%s)",
                    dwErr, dwIndex, INET_NTOA(paddr->IA_Address)
                    );
            }
        }

        //
        // try to allow re-use of this address
        //

        dwOption = 1;

        dwErr = setsockopt(
                    pite->ITE_Sockets[i], SOL_SOCKET, SO_REUSEADDR,
                    (PBYTE)&dwOption, sizeof(dwOption)
                    );

        if (dwErr == SOCKET_ERROR) {

            dwErr = WSAGetLastError();

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d setting re-use flag for interface %d (%s)",
                    dwErr, dwIndex, INET_NTOA(paddr->IA_Address)
                    );
            }
        }


        //
        // enable broadcasting if not exclusively RIP2 mode,
        // or if there are any unicast peers configured
        //

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1 ||
            pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1_COMPAT ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1 ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1_COMPAT ||
            (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED &&
             pic->IC_UnicastPeerCount != 0)) {
    

            //
            // make sure broadcasting is enabled for this socket
            //

            dwOption = 1;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], SOL_SOCKET, SO_BROADCAST,
                        (PBYTE)&dwOption, sizeof(dwOption)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {        
                    TRACE3(
                        IF, "error %d enabling broadcast on interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(ENABLE_BROADCAST_FAILED, lpszAddr, dwErr);
                }
                break;
            }
        }



        //
        // bind the socket to the RIP port
        //

        sinsock.sin_family = AF_INET;
        sinsock.sin_port = htons(IPRIP_PORT);
        sinsock.sin_addr.s_addr = paddr->IA_Address;
    
        dwErr = bind(
                    pite->ITE_Sockets[i], (LPSOCKADDR)&sinsock,
                    sizeof(SOCKADDR_IN)
                    );

        if (dwErr == SOCKET_ERROR) {

            dwErr = WSAGetLastError();
            
            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d binding on socket for interface %d (%s)",
                    dwErr, dwIndex, lpszAddr
                    );
                LOGERR1(BIND_FAILED, lpszAddr, dwErr);
            }
            break;
        }



        //
        // enable multicasting if not exclusively RIP1/RIP1-compatible mode
        //

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_RIP2 ||
            pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1_COMPAT ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP2) {

            struct ip_mreq imOption;
        

            //
            // set the interface from which multicasts must be sent
            //

            sinsock.sin_addr.s_addr = paddr->IA_Address;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], IPPROTO_IP, IP_MULTICAST_IF,
                        (PBYTE)&sinsock.sin_addr, sizeof(IN_ADDR)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        IF, "error %d setting interface %d (%s) as multicast",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(SET_MCAST_IF_FAILED, lpszAddr, dwErr);
                }
                break;
            }


            //
            // join the IPRIP multicast group
            //

            imOption.imr_multiaddr.s_addr = IPRIP_MULTIADDR;
            imOption.imr_interface.s_addr = paddr->IA_Address;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], IPPROTO_IP, IP_ADD_MEMBERSHIP,
                        (PBYTE)&imOption, sizeof(imOption)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                
                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        IF, "error %d enabling multicast on interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(JOIN_GROUP_FAILED, lpszAddr, dwErr);
                }
                break;
            }
        }

        dwErr = NO_ERROR;
    }


    if (i < pib->IB_AddrCount) {

        //
        // something failed if we are here
        //
    
        DeleteIfSocket(pite);
    }


    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfSocket
//
// closes the sockets used by an interface, if any.
// assumes that the interface is active, and that the interface table
// is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pite
    ) {

    DWORD i;

    for (i = 0; i < pite->ITE_Binding->IB_AddrCount; i++) {

        if (pite->ITE_Sockets[i] != INVALID_SOCKET) {
    
            if (closesocket(pite->ITE_Sockets[i]) == SOCKET_ERROR) {
                TRACE1(IF, "error %d closing socket", WSAGetLastError());
            }
    
            pite->ITE_Sockets[i] = INVALID_SOCKET;
        }
    }


    RIP_FREE(pite->ITE_Sockets);
    pite->ITE_Sockets = NULL;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetIfByIndex
//
// returns the interface with the given index.
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    PIF_TABLE_ENTRY pite = NULL;
    PLIST_ENTRY phead, ple;

    phead = pTable->IT_HashTableByIndex + IF_HASHVALUE(dwIndex);

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_HTLinkByIndex);

        if (pite->ITE_Index == dwIndex) {
            break;
        }
    }

    if (ple == phead) { return NULL; }
    else { return pite; }
}




//----------------------------------------------------------------------------
// Function:    GetIfByAddress
//
// returns the interface bound to the given address.
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    DWORD i;
    PIPRIP_IF_BINDING pib;
    PLIST_ENTRY phead, pfl;
    PIPRIP_IP_ADDRESS paddr;
    PIF_TABLE_ENTRY pite, piterec;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    phead = &pTable->IT_ListByAddress;
    pite = NULL;


    //
    // return record at head of list if mode is GetFirst
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (phead->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL; 
        }
        else {
            pfl = phead->Flink;
            return CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);
        }
    }


    //
    // search for the entry 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        piterec = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pib = piterec->ITE_Binding;

        paddr = IPRIP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            if (dwAddress == paddr->IA_Address) { pite = piterec; break; }
        }

        if (pite) { break; }
    }



    //
    // return record after the one found if mode is GetNext
    //

    if (dwGetMode == GETMODE_NEXT && pite != NULL) {
        pfl = &pite->ITE_LinkByAddress;

        //
        // if entry found is last one, return NULL,
        // otherwise, return the following entry
        //

        if (pfl->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            pite = NULL;
        }
        else {
            pfl = pfl->Flink;
            pite = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);
        }
    }


    //
    // if the interface wasn't found, this will still be NULL
    //

    return pite;
}



//----------------------------------------------------------------------------
// Function:    GetIfByListIndex
//
// This function is similar to GetIfByAddress in that it supports
// three modes of retrieval, but it is different in that it looks
// in the list of interfaces sorted by index.
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwIndex,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    phead = &pTable->IT_ListByIndex;
    pite = NULL;

    //
    // return record at head of list if mode is GETMODE_FIRST;
    // if list is empty, return NULL.
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (phead->Flink == phead) { 
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL; 
        }
        else {
            ple = phead->Flink;
            return CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    //
    // get the entry requested
    //

    pite = GetIfByIndex(pTable, dwIndex);


    //
    // if mode is GETMODE_NEXT, return the item after the one retrieved
    //

    if (dwGetMode == GETMODE_NEXT && pite != NULL) {

        ple = &pite->ITE_LinkByIndex;

        //
        // if entry found is last one, return NULL,
        // otherwise return the following entry
        //

        if (ple->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            pite = NULL;
        }
        else {
            ple = ple->Flink;
            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    return pite;
}



//----------------------------------------------------------------------------
// Function:    InsertIfByAddress
//
// inserts the given interface into the list of interfaces sorted by address.
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
InsertIfByAddress(
    PIF_TABLE pTable,
    PIF_TABLE_ENTRY pITE
    ) {

    INT cmp;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IP_ADDRESS paddr;
    DWORD dwAddress, dwITEAddress;
    PLIST_ENTRY phead, pfl;

    phead = &pTable->IT_ListByAddress;

    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding);
    dwAddress = paddr->IA_Address;


    //
    // search for the insertion point 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        pite = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);

        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding);

        dwITEAddress = paddr->IA_Address;

        if (INET_CMP(dwAddress, dwITEAddress, cmp) < 0) { break; }
        else if (cmp == 0) { return ERROR_ALREADY_EXISTS; }
    }

    InsertTailList(pfl, &pITE->ITE_LinkByAddress);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddNeighborToIfConfig
//
// Adds a unicast neighbor to an interface config block.
//----------------------------------------------------------------------------

DWORD
AddNeighborToIfConfig(
    DWORD               dwRemoteAddress,
    PIF_TABLE_ENTRY     pite
    ) {


    BOOL                bFound  = FALSE;
    
    DWORD               dwErr   = (DWORD) -1,
                        dwSize  = 0,
                        dwCnt   = 0;
                        
    PDWORD              pdwAddr = NULL;
    
    PIPRIP_IF_CONFIG    pic     = NULL,
                        picNew  = NULL;


    do
    {
        pic = pite-> ITE_Config;

        
        //
        // verify neighbor is not aready present
        //

        pdwAddr = IPRIP_IF_UNICAST_PEER_TABLE( pic );

        for ( dwCnt = 0; dwCnt < pic-> IC_UnicastPeerCount; dwCnt++ )
        {
            if ( dwRemoteAddress == pdwAddr[ dwCnt ] )
            {
                bFound = TRUE;
                break;
            }
        }


        //
        // entry exits, enable unicast peer mode and quit
        //

        if ( bFound )
        {
            LPSTR lpszAddr = INET_NTOA( dwRemoteAddress );

            pic-> IC_UnicastPeerMode = IPRIP_PEER_ALSO;

            dwErr = NO_ERROR;
            
            if (lpszAddr != NULL) {
                TRACE2(
                    IF, 
                    "Unicast neighbor %s already present in configuration on interface %d",
                     lpszAddr, pite-> ITE_Index
                );
            }            
            break;
        }

        
        //
        // allocate new config block
        //

        dwSize = IPRIP_IF_CONFIG_SIZE( pic ) + sizeof( DWORD );
    
        picNew = RIP_ALLOC( dwSize );

        if ( picNew == NULL )
        {
            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for configuration on interface %d",
                dwErr, dwSize, pite-> ITE_Index
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy base structure
        //
        
        CopyMemory( picNew, pic, sizeof( IPRIP_IF_CONFIG ) );


        //
        // copy uicast peer table
        //

        CopyMemory( 
            IPRIP_IF_UNICAST_PEER_TABLE( picNew ),
            IPRIP_IF_UNICAST_PEER_TABLE( pic ),
            pic-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        
        //
        // add new neighbor and set unicast neighbor mode
        //
        
        pdwAddr = IPRIP_IF_UNICAST_PEER_TABLE( picNew );

        pdwAddr[ picNew-> IC_UnicastPeerCount++ ] = dwRemoteAddress;

        picNew-> IC_UnicastPeerMode = IPRIP_PEER_ALSO;
        

        //
        // Copy accept and annouce filters
        //

        CopyMemory(
            IPRIP_IF_ACCEPT_FILTER_TABLE( picNew ),
            IPRIP_IF_ACCEPT_FILTER_TABLE( pic ),
            pic-> IC_AcceptFilterCount * sizeof( IPRIP_IP_ADDRESS )
        );

        CopyMemory(
            IPRIP_IF_ANNOUNCE_FILTER_TABLE( picNew ),
            IPRIP_IF_ANNOUNCE_FILTER_TABLE( pic ),
            pic-> IC_AnnounceFilterCount * sizeof( IPRIP_IP_ADDRESS )
        );


        //
        // save the new config 
        //
        
        pite-> ITE_Config = picNew;
        
        RIP_FREE( pic );

        dwErr = NO_ERROR;


    } while ( FALSE );

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    CreatePeerTable
//
// initializes the given peer table
//----------------------------------------------------------------------------

DWORD
CreatePeerTable(
    PPEER_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, plstart, plend;

    //
    // initialize the hash table of peers
    //

    plstart = pTable->PT_HashTableByAddress;
    plend = plstart + PEER_HASHTABLE_SIZE;

    for (ple = plstart; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    //
    // initialize the list of peers ordered by address
    //

    InitializeListHead(&pTable->PT_ListByAddress);


    //
    // initialize the multiple-read/single-write synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->PT_RWL);
    if (dwErr == NO_ERROR) {
        pTable->PT_Created = 0x12345678;
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeletePeerTable
//
// frees the resources used by the given peer table
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeletePeerTable(
    PPEER_TABLE pTable
    ) {

    PLIST_ENTRY ple, phead;
    PPEER_TABLE_ENTRY ppte;


    //
    // empty the hash table of peer stats structures
    //

    phead = &pTable->PT_ListByAddress;
    while (!IsListEmpty(phead)) {
        ple = RemoveHeadList(phead);
        ppte = CONTAINING_RECORD(ple, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        RIP_FREE(ppte);
    }


    //
    // delete the table's synchronization object
    //

    DeleteReadWriteLock(&pTable->PT_RWL);

    pTable->PT_Created = 0;
    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    CreatePeerEntry
//
// creates an entry in the given table for a peer with the given address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreatePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    PPEER_TABLE_ENTRY *ppEntry
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, phead;
    PPEER_TABLE_ENTRY ppte;

    if (ppEntry != NULL) { *ppEntry = NULL; }

    //
    // make sure the entry does not already exist
    //

    ppte = GetPeerByAddress(pTable, dwAddress, GETMODE_EXACT, NULL);
    if (ppte != NULL) {
        if (ppEntry != NULL) { *ppEntry = ppte; }
        return NO_ERROR;
    }


    //
    // allocate memory for the new peer entry
    //

    ppte = RIP_ALLOC(sizeof(PEER_TABLE_ENTRY));

    if (ppte == NULL) {

        LPSTR lpszAddr = INET_NTOA(dwAddress);

        dwErr = GetLastError();

        if (lpszAddr != NULL) {
            TRACE3(
                IF, "error %d allocating %d bytes for peer %s entry",
                dwErr, sizeof(PEER_TABLE_ENTRY), lpszAddr
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
        }
        return dwErr;
    }


    //
    // initialize the fields
    //

    ppte->PTE_Address = dwAddress;
    ZeroMemory(&ppte->PTE_Stats, sizeof(IPRIP_PEER_STATS));


    //
    // insert the peer stats entry in the hash table
    //

    phead = pTable->PT_HashTableByAddress + PEER_HASHVALUE(dwAddress);
    InsertHeadList(phead, &ppte->PTE_HTLinkByAddress);


    //
    // insert the entry in the list sorted by address
    //

    dwErr = InsertPeerByAddress(pTable, ppte);

    if (ppEntry != NULL) { *ppEntry = ppte; }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeletePeerEntry
//
// deletes the entry for the peer with the given address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeletePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress
    ) {

    PPEER_TABLE_ENTRY ppte;

    //
    // quit if the entry cannot be found
    //

    ppte = GetPeerByAddress(pTable, dwAddress, GETMODE_EXACT, NULL);
    if (ppte == NULL) { return ERROR_INVALID_PARAMETER; }


    //
    // remove the entry from the hash-table 
    // and from the list sorted by address
    //

    RemoveEntryList(&ppte->PTE_LinkByAddress);
    RemoveEntryList(&ppte->PTE_HTLinkByAddress);

    RIP_FREE(ppte);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetPeerByAddress
//
// returns the entry for the peer with the given address
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PPEER_TABLE_ENTRY
GetPeerByAddress(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    PLIST_ENTRY phead, pfl;
    PPEER_TABLE_ENTRY ppte, ppterec;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }


    //
    // return head of list if in GetFirst mode
    //

    if (dwGetMode == GETMODE_FIRST) {
        phead = &pTable->PT_ListByAddress;
        if (phead->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL;
        }
        else {
            pfl = phead->Flink;
            return CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        }
    }



    phead = pTable->PT_HashTableByAddress + PEER_HASHVALUE(dwAddress);
    ppte = NULL;


    //
    // search for the entry
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {
        ppterec = CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_HTLinkByAddress);
        if (ppterec->PTE_Address == dwAddress) { ppte = ppterec; break; }
    }



    //
    // return entry after the one found if in GetNext mode
    //

    if (dwGetMode == GETMODE_NEXT && ppte != NULL) {
        phead = &pTable->PT_ListByAddress;
        pfl = &ppte->PTE_LinkByAddress;

        //
        // return NULL if entry is last one
        //

        if (pfl->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL;
        }
        else {
            pfl = pfl->Flink;
            return CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        }
    }


    //
    // if the peer wasn't found, this will still be NULL
    //

    return ppte;
}



//----------------------------------------------------------------------------
// Function:    InsertPeerByAddress
//
// inserts the given entry into the list of peers sorted by address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
InsertPeerByAddress(
    PPEER_TABLE pTable,
    PPEER_TABLE_ENTRY pPTE
    ) {

    INT cmp;
    PPEER_TABLE_ENTRY ppte;
    DWORD dwAddress, dwPTEAddress;
    PLIST_ENTRY phead, pfl;


    dwAddress = pPTE->PTE_Address;

    phead = &pTable->PT_ListByAddress;


    //
    // search for the peer entry
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        ppte = CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);

        dwPTEAddress = ppte->PTE_Address;

        if (INET_CMP(dwAddress, dwPTEAddress, cmp) < 0) { break; }
        else if (cmp == 0) { return ERROR_ALREADY_EXISTS; }
    }

    InsertTailList(pfl, &pPTE->PTE_LinkByAddress);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateRouteTable
//
// Initializes a route table. Note that no synchronization is provided.
//----------------------------------------------------------------------------

DWORD
CreateRouteTable(
    PROUTE_TABLE pTable
    ) {

    PLIST_ENTRY plstart, plend, ple;


    //
    // initialize the hash table buckets
    //

    plstart = pTable->RT_HashTableByNetwork;
    plend = plstart + ROUTE_HASHTABLE_SIZE;

    for (ple = plstart; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    pTable->RT_Created = 0x12345678;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteRouteTable
//
// Removes all entries from a route table and frees resources used.
//----------------------------------------------------------------------------

DWORD
DeleteRouteTable(
    PROUTE_TABLE pTable
    ) {

    PROUTE_TABLE_ENTRY prte;
    PLIST_ENTRY ple, plend, phead;


    //
    // empty the hash-table buckets
    //

    plend = pTable->RT_HashTableByNetwork + ROUTE_HASHTABLE_SIZE;

    for (ple = plend - ROUTE_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            prte = CONTAINING_RECORD(phead, ROUTE_TABLE_ENTRY, RTE_Link);

            RIP_FREE(prte);
        }
    }
            


    pTable->RT_Created = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    WriteSummaryRoutes
//
// Writes to RTM all entries which are marked as summary routes.
//----------------------------------------------------------------------------

DWORD
WriteSummaryRoutes(
    PROUTE_TABLE pTable,
    HANDLE hRtmHandle
    ) {

    DWORD dwFlags, dwErr;
    PRIP_IP_ROUTE prir;
    PROUTE_TABLE_ENTRY prte;
    PLIST_ENTRY ple, phead, plstart, plend;

    BOOL bRelDest = FALSE, bRelRoute = FALSE;
    RTM_NET_ADDRESS rna;
    RTM_DEST_INFO rdi;
    PRTM_ROUTE_INFO prri;

    CHAR szNetwork[20], szNetmask[20];
                        
    
    //
    // allocate route info structure
    //
    
    prri = RIP_ALLOC(
            RTM_SIZE_OF_ROUTE_INFO( ig.IG_RtmProfile.MaxNextHopsInRoute )
            );

    if (prri == NULL)
    {
        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocated %d bytes in WriteSummaryRoutes",
            dwErr, RTM_SIZE_OF_ROUTE_INFO(ig.IG_RtmProfile.MaxNextHopsInRoute)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }
    

    //
    // go through each bucket writing routes
    //

    plstart = pTable->RT_HashTableByNetwork;
    plend = plstart + ROUTE_HASHTABLE_SIZE;

    for (phead = plstart; phead < plend; phead++) {
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            prte = CONTAINING_RECORD(ple, ROUTE_TABLE_ENTRY, RTE_Link);
            prir = &prte->RTE_Route;

            bRelDest = bRelRoute = FALSE;

            
            do {
                
                //
                // if a valid route exists do not overwrite it with
                // a summary route
                //

                RTM_IPV4_SET_ADDR_AND_MASK( 
                    &rna, prir-> RR_Network.N_NetNumber,
                    prir-> RR_Network.N_NetMask
                    );
                
                dwErr = RtmGetExactMatchDestination(
                            hRtmHandle, &rna, RTM_BEST_PROTOCOL,
                            RTM_VIEW_MASK_UCAST, &rdi
                            );

                if (dwErr == NO_ERROR)
                {
                    bRelDest = TRUE;
                    
                    //
                    // Get info for the best route to this destination
                    //

                    dwErr = RtmGetRouteInfo(
                                hRtmHandle, rdi.ViewInfo[0].Route,
                                prri, NULL
                                );

                    if (dwErr != NO_ERROR)
                    {
                        TRACE1(
                            ANY, "error %d getting route info in"
                            "WriteSummaryRoutes", dwErr
                            );

                        break;
                    }

                    bRelRoute = TRUE;

                    
                    //
                    // Check if this route is active.  If it is skip
                    // adding an inactive summary route
                    //

                    if (!(prri-> Flags & RTM_ROUTE_FLAGS_INACTIVE)) {
                    
                        lstrcpy(szNetwork, INET_NTOA(prir-> RR_Network.N_NetNumber));
                        lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));

                        TRACE2(
                            ROUTE,
                            "Route %s %s not overwritten in summary route addition",
                            szNetwork, szNetmask
                        );
                        
                        break;
                    }
                }


                //
                // you reach here only if you don't have an active
                // route to the summary route's destination
                //
                
                //
                // if this is a summary entry (i.e. is a RIP route
                // with the summary entry set)
                //

                if (prir->RR_RoutingProtocol == PROTO_IP_RIP &&
                    GETROUTEFLAG(prir) == ROUTEFLAG_SUMMARY) {

                    LPSTR lpszAddr;
                    
                    COMPUTE_ROUTE_METRIC(prir);

                    dwErr = AddRtmRoute(
                                hRtmHandle, prir, NULL, prte->RTE_TTL,
                                prte->RTE_HoldTTL, FALSE
                                );

                    lpszAddr = INET_NTOA(prir-> RR_Network.N_NetNumber);
                    if (lpszAddr != NULL) { 
                        lstrcpy(szNetwork, lpszAddr );
                        lpszAddr = INET_NTOA(prir-> RR_Network.N_NetMask);
                        if (lpszAddr != NULL) {
                            lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));
#if ROUTE_DBG
                            TRACE2(
                                ROUTE, "Adding summary route %s %s", szNetwork, 
                                szNetmask
                            );
#endif
                            if (dwErr != NO_ERROR) {
                            
                                LPSTR lpszNexthop = 
                                        INET_NTOA(prir->RR_NextHopAddress.N_NetNumber);
                                if (lpszNexthop != NULL) {
                                    TRACE4(
                                        ROUTE,
                                        "error %d writing summary route to %s:%s via %s",
                                        dwErr,  szNetwork, szNetmask, lpszNexthop
                                        );
                                    LOGWARN2(
                                        ADD_ROUTE_FAILED_1, szNetwork, lpszNexthop, dwErr
                                        );
                                }
                            }
                        }
                    }
                }
                
            } while (FALSE);


            if (dwErr != NO_ERROR) {

                //
                // in case one of the INET_NTOA statements failed above, just
                // trace the fact that there was an error
                //
                
                TRACE1(
                    ROUTE,
                    "error %d writing summary route",
                    dwErr
                    );
            }
            
            //
            // release handles as required
            //
            
            if (bRelRoute) {
            
                dwErr = RtmReleaseRouteInfo(hRtmHandle, prri);

                if (dwErr != NO_ERROR) {

                    TRACE1(
                        ANY, "error %d releasing route info in"
                        " WriteSummaryRoutes", dwErr
                        );
                }
            }

            if (bRelDest) {

                dwErr = RtmReleaseDestInfo(hRtmHandle, &rdi);
                
                if (dwErr != NO_ERROR) {

                    TRACE1(
                        ANY, "error %d releasing route info in"
                        " WriteSummaryRoutes", dwErr
                        );
                }
            }
        }
    }

    if (prri) { RIP_FREE(prri); }
    
    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateRouteEntry
//
// Makes an entry in the route table for the given route.
//----------------------------------------------------------------------------

DWORD
CreateRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute,
    DWORD dwTTL,
    DWORD dwHoldTTL
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple;
    PROUTE_TABLE_ENTRY prte;

    //
    // see if the entry  exists first
    //

    if ((prte = GetRouteByRoute(pTable, pRoute)) != NULL) {

        //
        // just update the metric if the new route has a lower one
        //

        if (GETROUTEMETRIC(&prte->RTE_Route) > GETROUTEMETRIC(pRoute)) {
            SETROUTEMETRIC(&prte->RTE_Route, GETROUTEMETRIC(pRoute));
        }

        return NO_ERROR;
    }


    //
    // allocate space for the new route
    //

    prte = RIP_ALLOC(sizeof(ROUTE_TABLE_ENTRY));
    if (prte == NULL) {

        dwErr = GetLastError();
        TRACE2( 
            ANY, "error %d allocating %d bytes for route table entry",
            dwErr, sizeof(ROUTE_TABLE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    //
    // initialize the entry's fields and copy the actual route structure
    //

    prte->RTE_TTL = dwTTL;
    prte->RTE_HoldTTL = dwHoldTTL;
    CopyMemory(&prte->RTE_Route, pRoute, sizeof(RIP_IP_ROUTE));


    //
    // insert the route in the hash table
    //

    ple = pTable->RT_HashTableByNetwork +
          ROUTE_HASHVALUE(pRoute->RR_Network.N_NetNumber);

    InsertHeadList(ple, &prte->RTE_Link);


#if ROUTE_DBG
    {
        LPSTR lpszAddr;
        char szNet[20], szMask[20];

        lpszAddr = INET_NTOA(pRoute-> RR_Network.N_NetNumber);
        if (lpszAddr != NULL) {
            lstrcpy(szNet, lpszAddr);

            lpszAddr = INET_NTOA(pRoute-> RR_Network.N_NetMask);
            if (lpszAddr != NULL) {
                lstrcpy(szMask, lpszAddr);

                lpszAddr = INET_NTOA(pRoute-> RR_NextHopAddress.N_NetNumber);
                if (lpszAddr != NULL) {
                    TRACE4(
                        ROUTE, "Creating summary route : Route %s %s via %s"
                        "on interface %d",
                        szNet, szMask, lpszAddr, pRoute-> RR_InterfaceID
                        );
                }
            }
        }
    }
    
#endif

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteRouteEntry
//
// Remove the entry which matches the given route.
//----------------------------------------------------------------------------

DWORD
DeleteRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    ) {

    PROUTE_TABLE_ENTRY prte;

    //
    // find the route to be deleted
    //

    prte = GetRouteByRoute(pTable, pRoute);
    if (prte == NULL) { return ERROR_INVALID_PARAMETER; }


    //
    // remove it from the hash table and free the memory it used
    //

    RemoveEntryList(&prte->RTE_Link);

    RIP_FREE(prte);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetRouteByRoute
//
// Searches for the route entry which matches the given route, if any,
// and returns a pointer to it if it is found.
//----------------------------------------------------------------------------

PROUTE_TABLE_ENTRY
GetRouteByRoute(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwNetNumber;
    PLIST_ENTRY phead, pfl;
    PROUTE_TABLE_ENTRY prte, prterec;


    //
    // get the net number to be found and find the corresponding bucket
    //

    prte = NULL;
    dwNetNumber = pRoute->RR_Network.N_NetNumber;

    phead = pTable->RT_HashTableByNetwork + ROUTE_HASHVALUE(dwNetNumber);


    //
    // search the bucket for the route 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {
        prterec = CONTAINING_RECORD(pfl, ROUTE_TABLE_ENTRY, RTE_Link);
        if (prterec->RTE_Route.RR_Network.N_NetNumber == dwNetNumber) {
            prte = prterec; break;
        }
    }


    //
    // if the route wasn't found, this will still be NULL
    //

    return prte;
}





//----------------------------------------------------------------------------
// Function:    CreateBindingTable
//
// Initializes a table of bindings.
//----------------------------------------------------------------------------

DWORD
CreateBindingTable(
    PBINDING_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY plend, ple;


    //
    // initialize the hash table of bindings
    //

    plend = pTable->BT_HashTableByNetwork + BINDING_HASHTABLE_SIZE;
    for (ple = plend - BINDING_HASHTABLE_SIZE; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    //
    // initialize the table's synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->BT_RWL);

    if (dwErr == NO_ERROR) {
        pTable->BT_Created = 0x12345678;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteBindingTable
//
// Cleans up resources used by a binding table.
//----------------------------------------------------------------------------

DWORD
DeleteBindingTable(
    PBINDING_TABLE pTable
    ) {

    PBINDING_TABLE_ENTRY pbte;
    PLIST_ENTRY plend, ple, phead;


    //
    // destroy the synchronization object
    //

    DeleteReadWriteLock(&pTable->BT_RWL);


    //
    // empty the hash-table buckets
    //

    plend = pTable->BT_HashTableByNetwork + BINDING_HASHTABLE_SIZE;

    for (ple = plend - BINDING_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            pbte = CONTAINING_RECORD(phead, BINDING_TABLE_ENTRY, BTE_Link);

            RIP_FREE(pbte);
        }
    }
            

    pTable->BT_Created = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateBindingEntry
//
// Adds a binding to the table.
// assumes the binding table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    ) {

    INT cmp;
    PLIST_ENTRY ple, phead;
    PIPRIP_IP_ADDRESS paddr;
    PBINDING_TABLE_ENTRY pbte;
    DWORD i, dwErr, dwAddress, dwNetmask, dwNetwork;


    //
    // go through the IP addresses in the interface binding,
    // adding each to the binding table
    //

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
    
        dwAddress = paddr->IA_Address;
        dwNetmask = paddr->IA_Netmask;


        //
        // compute the network part of the binding
        //
    
        dwNetwork = (dwAddress & NETCLASS_MASK(dwAddress));
    
    
        //
        // get the hash bucket to which the binding belongs,
        // and find the insertion point in the bucket 
        //
    
        phead = pTable->BT_HashTableByNetwork + BINDING_HASHVALUE(dwNetwork);
    
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
            pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);
    
            INET_CMP(dwNetwork, pbte->BTE_Network, cmp);
            if (cmp < 0) { break; }
            else
            if (cmp > 0) { continue; }
    
            //
            // the network parts are equal; further compare
            // against the IP address fields
            //
    
            INET_CMP(dwAddress, pbte->BTE_Address, cmp);
            if (cmp < 0) { break; }
            else
            if (cmp > 0) { continue; }
    
            //
            // the addresses are also equal; return an error
            //
    
            return ERROR_ALREADY_EXISTS;
        }
    
    
        //
        // we now have the insertion point, so create the new item
        //
    
        pbte = RIP_ALLOC(sizeof(BINDING_TABLE_ENTRY));
        if (pbte == NULL) {
    
            dwErr = GetLastError();
            TRACE2(
                IF, "error %d allocating %d bytes for binding entry",
                dwErr, sizeof(BINDING_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
    
            return dwErr;
        }
    
    
        pbte->BTE_Address = dwAddress;
        pbte->BTE_Network = dwNetwork;
        pbte->BTE_Netmask = dwNetmask;
    
    
        //
        // insert the entry
        //
    
        InsertTailList(ple, &pbte->BTE_Link);
    
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteBindingEntry
//
// Removes a binding from the table.
// assumes the binding table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    ) {


    PLIST_ENTRY ple, phead;
    PIPRIP_IP_ADDRESS paddr;
    PBINDING_TABLE_ENTRY pbte;
    DWORD i, dwNetwork, dwAddress, dwNetmask;

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

        dwAddress = paddr->IA_Address;
        dwNetmask = paddr->IA_Netmask;


        //
        // get the hash bucket to be searched
        //
    
        dwNetwork = (dwAddress & NETCLASS_MASK(dwAddress));
    
        phead = pTable->BT_HashTableByNetwork + BINDING_HASHVALUE(dwNetwork);
    
    
        //
        // search the bucket for the binding specified
        //
    
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
            pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);
    
            if (dwAddress != pbte->BTE_Address ||
                dwNetmask != pbte->BTE_Netmask) {
                continue;
            }
    
    
            //
            // the entry to be deleted has been found;
            // remove it from the list and free its memory
            //
    
            RemoveEntryList(&pbte->BTE_Link);
    
            RIP_FREE(pbte);

            break;
        }
    }


    return NO_ERROR;
}




//---------------------------------------------------------------------------
// Function:    GuessSubnetMask
//
// This function attempts to deduce the subnet mask of an IP address
// based on the configured addresses and masks on the local host.
// assumes the binding table is locked for reading or writing
//---------------------------------------------------------------------------

DWORD
GuessSubnetMask(
    DWORD dwAddress,
    PDWORD pdwNetclassMask
    ) {

    INT cmp;
    PLIST_ENTRY ple, phead;
    PBINDING_TABLE_ENTRY pbte;
    DWORD dwNetwork, dwNetmask, dwGuessMask;


    //
    // the mask for a default route (0.0.0.0) is zero
    //

    if (dwAddress == 0) {
        if (pdwNetclassMask != NULL) { *pdwNetclassMask = 0; }
        return 0;
    }



    //
    // the mask for the broadcast route is all-ones (255.255.255.255)
    //

    if (dwAddress == INADDR_BROADCAST) {
        if (pdwNetclassMask != NULL) { *pdwNetclassMask = INADDR_BROADCAST; }
        return INADDR_BROADCAST;
    }


    //
    // otherwise, we start with the network-class mask
    //

    dwGuessMask = dwNetmask = NETCLASS_MASK(dwAddress);
    if (pdwNetclassMask != NULL) { *pdwNetclassMask = dwNetmask; }


    //
    // if the route is a network route, we're done
    //

    if ((dwAddress & ~dwNetmask) == 0) { return dwNetmask; }


    //
    // otherwise, search through the bindings table
    // to see if one is on the same network as this address
    //

    dwNetwork = (dwAddress & dwNetmask);

    phead = ig.IG_BindingTable->BT_HashTableByNetwork +
            BINDING_HASHVALUE(dwNetwork);

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);

        INET_CMP(dwNetwork, pbte->BTE_Network, cmp);

        if (cmp < 0) { break; }
        else
        if (cmp > 0) { continue; }


        //
        // this entry is on the same network as the address passed in
        // so see if the entry's netmask matches the address;
        // if it does, we're done; otherwise, save this mask
        // as a guess, and keep looking.
        // note that this exhaustive search is the only way we can
        // reliably guess masks for supernets
        //

        if ((dwAddress & pbte->BTE_Netmask) ==
            (pbte->BTE_Address & pbte->BTE_Netmask)) {

            return pbte->BTE_Netmask;
        }

        dwGuessMask = pbte->BTE_Netmask;
    }


    //
    // return whatever has been our best guess so far
    //

    return dwGuessMask;
}


DWORD
AddRtmRoute(
    RTM_ENTITY_HANDLE   hRtmHandle,
    PRIP_IP_ROUTE       prir,
    RTM_NEXTHOP_HANDLE  hNextHop        OPTIONAL,
    DWORD               dwTimeOut,
    DWORD               dwHoldTime,
    BOOL                bActive
    )
/*++

Routine Description :

    This function adds a route to the RTMv2 database.  In addition it
    creates the nexthop if one is not specified (via hNextHop), based
    on the next hop i/f and address specified in the RIP route.


Parameters :

    hRtmHandle  - Entity registration handle

    prir        - RIP route to be added

    hNextHop    - Handle to the next hop to be used for the route

    dwTimeout   - Route timeout interval

    dwHoldTime  - Route holddown interval (after delete)

    bActive     - TRUE if the route being added is an active route,
                  FALSE otherwise (in RIP's case for summary routes)


Return Value :

    NO_ERROR    - Success

    Rtm error code - Otherwise


Environment :

    Invoked from ProcessRouteEntry and WriteSummaryRoutes
    
--*/
{
    BOOL bRelDest = FALSE;
    
    DWORD dwErr, dwChangeFlags = 0;
    
    RTM_DEST_INFO rdi;
    
    RTM_NEXTHOP_INFO rni;

    RTM_ROUTE_INFO rri;

    RTM_NET_ADDRESS rna;

    CHAR szNetwork[20], szNetmask[20], szNextHop[20], szNextHopmask[20];
        
    
    do {
    
        //
        // char strings used to print IP address/mask info
        // Used in error cases only
        //
        
        lstrcpy(szNetwork, INET_NTOA(prir-> RR_Network.N_NetNumber));
        lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));
        lstrcpy(szNextHop, INET_NTOA(prir-> RR_NextHopAddress.N_NetNumber));
        lstrcpy(szNextHopmask, INET_NTOA(prir-> RR_NextHopAddress.N_NetMask));

        
        //
        // Zero out the next hop and route memory
        //

        ZeroMemory(&rni, sizeof(RTM_NEXTHOP_INFO));
        ZeroMemory(&rri, sizeof(RTM_ROUTE_INFO));
        
        
        if (hNextHop == NULL) {
        
            //
            // Find next hop.
            //

            rni.InterfaceIndex = prir-> RR_InterfaceID;
            
            RTM_IPV4_SET_ADDR_AND_MASK(
                &rni.NextHopAddress, prir-> RR_NextHopAddress.N_NetNumber,
                IPV4_SOURCE_MASK
                );

            //
            // Save the nexthop mask in the entity specific info
            //
            
            *((PDWORD)&rni.EntitySpecificInfo) = prir-> RR_NextHopAddress.N_NetMask;
            

            rni.NextHopOwner = hRtmHandle;
            
            dwErr = RtmFindNextHop(hRtmHandle, &rni, &hNextHop, NULL);

            if (dwErr == ERROR_NOT_FOUND) {
            
                //
                // Next hop not found.  Create one
                //
                
                dwErr = RtmAddNextHop(
                            hRtmHandle, &rni, &hNextHop, &dwChangeFlags
                            );

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ROUTE, "error %d creating next hop %s %s",
                        dwErr, szNextHop, szNextHopmask
                    );

                    break;
                }
            }

            else if (dwErr != NO_ERROR) {
            
                TRACE3(
                    ANY, "error %d finding next hop %s %s", dwErr,
                    szNextHop, szNextHopmask
                    );

                break;
            }
        }


        //
        // Build route info structure
        //

        RTM_IPV4_SET_ADDR_AND_MASK(
            &rna, prir-> RR_Network.N_NetNumber, prir-> RR_Network.N_NetMask
            );
            
        rri.PrefInfo.Metric = prir-> RR_FamilySpecificData.FSD_Metric1;
        
        rri.BelongsToViews = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

        //
        // set entity specific info
        //

        SETRIPTAG(&rri, GETROUTETAG(prir));
        SETRIPFLAG(&rri, GETROUTEFLAG(prir));

    
        //
        // Set next hop info
        //

        rri.NextHopsList.NumNextHops = 1;
        rri.NextHopsList.NextHops[0] = hNextHop;

        rri.Neighbour = hNextHop;

        
        //
        // Call into router manager to set preference info
        //

        ig.IG_SupportFunctions.ValidateRoute(PROTO_IP_RIP, &rri, &rna);


        //
        // if this is an inactive route, 
        //  - set route flag to inactive.
        //  - set the views for route to none
        //

        if ( !bActive ) {

            rri.Flags1 = 0;
            rri.Flags = RTM_ROUTE_FLAGS_INACTIVE;
            rri.BelongsToViews = 0;
        }
        
        
        //
        // Add route to dest, convert timeout to milliseconds 
        //

        dwChangeFlags = RTM_ROUTE_CHANGE_FIRST;
        
        dwErr = RtmAddRouteToDest(
                    hRtmHandle, NULL, &rna, &rri, dwTimeOut * 1000, NULL,
                    0, NULL, &dwChangeFlags
                    );

        if ( dwErr != NO_ERROR ) {
        
            TRACE4(
                ANY, "error %d adding route %s %s via %s",
                dwErr, szNetwork, szNetmask, szNextHop
                );

            break;
        }


        if ( bActive )
        {
            //
            // Hold destination if this is an active route
            //

            dwErr = RtmGetExactMatchDestination(
                        hRtmHandle, &rna, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_UCAST, &rdi
                        );

            if ( dwErr != NO_ERROR ) {
            
                TRACE3(
                    ANY, "error %d getting just added destination %s:%s",
                    dwErr, szNetwork, szNetmask
                    );

                break;
            }

            bRelDest = TRUE;
            
            dwErr = RtmHoldDestination(
                        hRtmHandle, rdi.DestHandle, RTM_VIEW_MASK_UCAST, 
                        dwHoldTime * 1000
                        );

            if ( dwErr != NO_ERROR ) {
            
                TRACE3(
                    ANY, "error %d failed to hold destination %s %s",
                    dwErr, szNetwork, szNetmask
                    );

                break;
            }
        }
        
    } while(FALSE);


    //
    // release acquired handles
    //
    
    if ( bRelDest ) {
    
        dwErr = RtmReleaseDestInfo( hRtmHandle, &rdi );

        if ( dwErr != NO_ERROR ) {
        
            TRACE3(
                ANY, "error %d failed to relase just added destination %s %s",
                dwErr, szNetwork, szNetmask
                );
        }
        
    }

    return dwErr;
}



DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo    OPTIONAL,
    IN  PRTM_DEST_INFO      pInDestInfo     OPTIONAL,
    OUT PRIP_IP_ROUTE       pRoute
    )
    
/*++

Routine Description:

    Wrapper for filling out the OSPF_RTMv2_ROUTE by retrieving various
    RTM infos.

Arguments:

    hRoute
    pInRouteInfo
    pInDestInfo
    pRoute

Return Value:

    RTM error code

--*/

{
    DWORD               dwErr;
    RTM_ROUTE_INFO      RouteInfo, *pRouteInfo;
    RTM_ENTITY_INFO     EntityInfo, *pEntityInfo;
    RTM_DEST_INFO       DestInfo, *pDestInfo;
    RTM_NEXTHOP_INFO    NextHopInfo, *pNextHopInfo;


    pRouteInfo   = NULL;
    pEntityInfo  = NULL;
    pDestInfo    = NULL;
    pNextHopInfo = NULL;
    


    do
    {
        ZeroMemory(pRoute, sizeof(RIP_IP_ROUTE));
        
        //
        // If the user hasnt already given us the route info, get it
        //

        if ( pInRouteInfo == NULL )
        {
            dwErr = RtmGetRouteInfo(
                        ig.IG_RtmHandle, hRoute, &RouteInfo, NULL
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetRouteInfo\n", dwErr
                    );

                break;
            }

            pRouteInfo = &RouteInfo;
        }
        
        else
        {
            pRouteInfo = pInRouteInfo;
        }


        //
        // If the user hasnt given us the dest info, get it
        //

        if ( pInDestInfo == NULL )
        {
            dwErr = RtmGetDestInfo(
                        ig.IG_RtmHandle, pRouteInfo->DestHandle,
                        0, RTM_VIEW_MASK_UCAST, &DestInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetDestInfo\n", dwErr
                    );

                break;
            }

            pDestInfo = &DestInfo;
        }
        
        else
        {
            pDestInfo = pInDestInfo;
        }


        //
        // Get owner info if the protocol is not us
        //

        if ( pRouteInfo-> RouteOwner != ig.IG_RtmHandle )
        {
            dwErr = RtmGetEntityInfo(
                        ig.IG_RtmHandle, pRouteInfo->RouteOwner, &EntityInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetEntityInfo\n", 
                    dwErr
                    );

                break;
            }

            pEntityInfo = &EntityInfo;
        }
        
        
        //
        // Get the info about the first next hop
        //

        dwErr = RtmGetNextHopInfo(
                    ig.IG_RtmHandle,
                    pRouteInfo->NextHopsList.NextHops[0],
                    &NextHopInfo
                    );
    
        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "GetRouteInfo: Error %d from RtmGetEntityInfo\n", 
                dwErr
                );

            break;
        }

        pNextHopInfo = &NextHopInfo;


        //
        // Now copy out all the info.
        // First, the route info
        //

        pRoute-> RR_FamilySpecificData.FSD_Metric1 =
        pRoute-> RR_FamilySpecificData.FSD_Metric  = 
            pRouteInfo-> PrefInfo.Metric;


        //
        // copy out the protocol id from the entity info
        //

        if ( pEntityInfo != NULL )
        {
            pRoute-> RR_RoutingProtocol = pEntityInfo->EntityId.EntityProtocolId;
        }

        else
        {
            //
            // this is a RIP route
            //

            pRoute-> RR_RoutingProtocol = PROTO_IP_RIP;
            SETROUTEFLAG(pRoute, GETRIPFLAG(pRouteInfo));
            SETROUTETAG(pRoute, GETRIPTAG(pRouteInfo));
        }

        
        //
        // Copy out the dest info
        //
    
        RTM_IPV4_GET_ADDR_AND_MASK( 
            pRoute->RR_Network.N_NetNumber, 
            pRoute->RR_Network.N_NetMask, 
            &(pDestInfo->DestAddress) 
            );

        pRoute-> hDest = pDestInfo-> DestHandle;

        
        //
        // Copy out the next hop info
        //

        RTM_IPV4_GET_ADDR_AND_MASK( 
            pRoute->RR_NextHopAddress.N_NetNumber, 
            pRoute->RR_NextHopAddress.N_NetMask, 
            &(pNextHopInfo->NextHopAddress) 
            );
            
        //
        // retrive saved next hop mask
        //
        
        pRoute-> RR_NextHopAddress.N_NetMask = 
            *((PDWORD)&pNextHopInfo-> EntitySpecificInfo);
            

        pRoute-> RR_InterfaceID = pNextHopInfo->InterfaceIndex;

#if 0
        {
            char szNet[20], szMask[20], szNextHop[20], szNextHopMask[20];

            lstrcpy(szNet, INET_NTOA(pRoute-> RR_Network.N_NetNumber));
            lstrcpy(szMask, INET_NTOA(pRoute-> RR_Network.N_NetMask));
            lstrcpy(szNextHop, INET_NTOA(pRoute-> RR_NextHopAddress.N_NetNumber));
            lstrcpy(szNextHopMask, INET_NTOA(pRoute-> RR_NextHopAddress.N_NetMask));

            TRACE5(
                ROUTE, "GetRouteInfo : Route %s %s via %s %s on interface %d",
                szNet, szMask, szNextHop, szNextHopMask,
                pRoute-> RR_InterfaceID
                );

            TRACE3(
                ROUTE, "Has metric %d, flag %x, tag %d",
                GETROUTEMETRIC(pRoute), GETROUTEFLAG(pRoute),
                GETROUTETAG(pRoute)
                );

            TRACE2(
                ROUTE, "Protocol %d, original flag %d",
                pRoute-> RR_RoutingProtocol, GETRIPFLAG(pRouteInfo)
                );
        }
#endif

    } while( FALSE );
    
    
    //
    // Release the relevant infos
    //

    if ( pNextHopInfo != NULL )
    {
        RtmReleaseNextHopInfo( ig.IG_RtmHandle, pNextHopInfo );
    }

    if ( pEntityInfo != NULL )
    {
        RtmReleaseEntityInfo( ig.IG_RtmHandle, pEntityInfo );
    }


    //
    // Release the route and dest infos only if we were not passed them
    // in AND we successfully retrieved them
    //
    
    if ( ( pInDestInfo == NULL ) && ( pDestInfo != NULL ) )
    {
        RtmReleaseDestInfo( ig.IG_RtmHandle, pDestInfo );
    }


    if( ( pInRouteInfo == NULL ) && ( pRouteInfo != NULL ) )
    {
        RtmReleaseRouteInfo( ig.IG_RtmHandle, pRouteInfo );
    }
    
    return NO_ERROR;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    sync.c
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// Synchronization routines used by IPRIP.
//============================================================================


#include "pchrip.h"




//----------------------------------------------------------------------------
// Function:    QueueRipWorker  
//
// This function is called to queue a RIP function in a safe fashion;
// if cleanup is in progress or if RIP has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueRipWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    ) {

    DWORD dwErr = NO_ERROR;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status != IPRIP_STATUS_RUNNING) {

        //
        // cannot queue a work function when RIP has quit or is quitting
        //

        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        BOOL bSuccess;
        
        ++ig.IG_ActivityCount;

        bSuccess = QueueUserWorkItem(
                        (LPTHREAD_START_ROUTINE)pFunction,
                        pContext, 0
                        );

        if (!bSuccess) {
            dwErr = GetLastError();
            --ig.IG_ActivityCount;
        }
    }

    LeaveCriticalSection(&ig.IG_CS);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnterRipAPI
//
// This function is called to when entering a RIP api, as well as
// when entering the input thread and timer thread.
// It checks to see if RIP has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterRipAPI(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPRIP_STATUS_RUNNING) {

        //
        // RIP is running, so the API may continue
        //

        ++ig.IG_ActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // RIP is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterRipWorker
//
// This function is called when entering a RIP worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if RIP has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterRipWorker(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPRIP_STATUS_RUNNING) {

        //
        // RIP is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (ig.IG_Status == IPRIP_STATUS_STOPPING) {

        //
        // RIP is not running, but it was, so the function must stop.
        // 

        --ig.IG_ActivityCount;

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // RIP probably never started. quit quietly
        //

        bEntered = FALSE;
    }


    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    LeaveRipWorker
//
// This function is called when leaving a RIP API or worker function.
// It decrements the activity count, and if it detects that RIP has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveRipWorker(
    ) {

    EnterCriticalSection(&ig.IG_CS);

    --ig.IG_ActivityCount;

    if (ig.IG_Status == IPRIP_STATUS_STOPPING) {

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);
    }


    LeaveCriticalSection(&ig.IG_CS);

}




//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}




//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}




//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\table.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: table.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
//      V Raman             Oct-3-1996  
//                          Added Deactivate Event to IF_TABLE_ENTRY
//
//      V Raman             Oct-27-1996
//                          Removed Deactivate Event in IF_TABLE_ENTRY
//                          and made interface deactivation synchronous
//
// Contains structures and macros used for table management.
//============================================================================

#ifndef _TABLE_H_
#define _TABLE_H_


#define GETMODE_EXACT   0
#define GETMODE_FIRST   1
#define GETMODE_NEXT    2


//
// TYPE DEFINITIONS FOR INTERFACE MANAGEMENT
//



//
// struct:      IF_TABLE_ENTRY
//
// declares the components of an interface table entry
//
//

typedef struct _IF_TABLE_ENTRY {

    LIST_ENTRY          ITE_LinkByAddress;
    LIST_ENTRY          ITE_LinkByIndex;
    LIST_ENTRY          ITE_HTLinkByIndex;
    NET_INTERFACE_TYPE  ITE_Type;
    DWORD               ITE_Index;
    DWORD               ITE_Flags;
    HANDLE              ITE_FullOrDemandUpdateTimer;
    IPRIP_IF_STATS      ITE_Stats;
    PIPRIP_IF_CONFIG    ITE_Config;
    PIPRIP_IF_BINDING   ITE_Binding;
    SOCKET             *ITE_Sockets;

} IF_TABLE_ENTRY, *PIF_TABLE_ENTRY;



#define ITEFLAG_ENABLED                 ((DWORD)0x00000001)
#define ITEFLAG_BOUND                   ((DWORD)0x00000002)
#define ITEFLAG_FULL_UPDATE_PENDING     ((DWORD)0x00000004)
#define ITEFLAG_FULL_UPDATE_INQUEUE     ((DWORD)0x00000008)

#define IF_IS_ENABLED(i)    \
            ((i)->ITE_Flags & ITEFLAG_ENABLED) 
#define IF_IS_BOUND(i)      \
            ((i)->ITE_Flags & ITEFLAG_BOUND)
#define IF_IS_ACTIVE(i)     \
            (IF_IS_BOUND(i) && IF_IS_ENABLED(i))

#define IF_IS_DISABLED(i)   !IF_IS_ENABLED(i)
#define IF_IS_UNBOUND(i)    !IF_IS_BOUND(i)
#define IF_IS_INACTIVE(i)   !IF_IS_ACTIVE(i)

#define IF_FULL_UPDATE_PENDING(i) \
            ((i)->ITE_Flags & ITEFLAG_FULL_UPDATE_PENDING)
#define IF_FULL_UPDATE_INQUEUE(i) \
            ((i)->ITE_Flags & ITEFLAG_FULL_UPDATE_INQUEUE)




//
// macros and definitions used by interface tables
//

#define IF_HASHTABLE_SIZE       29
#define IF_HASHVALUE(i)         ((i) % IF_HASHTABLE_SIZE)



//
// struct:      IF_TABLE
//
// declares the structure of an interface table. consists of a hash-table
// of IF_TABLE_ENTRY structures hashed on interface index, and a list
// of all activated interfaces ordered by IP address
//
// The IT_CS section is used to synchronize the generation of updates;
// it is acquired when updates are started and finished on interfaces
// in this table, and thus it protects the flags field.
//
// The IT_RWL section is used to synchronize modifications to the table;
// it must be acquired exclusively when entries are being added or deleted
// from the table, and when the states of entries are being changed.
// (e.g. binding, unbinding, enabling and disabling entries).
//
// IT_RWL must be acquired non-exclusively on all other acceses.
//
// When IT_RWL and IT_CS must both be acquired, IT_RWL must be acquired first.
//

typedef struct _IF_TABLE {

    DWORD               IT_Created;
    DWORD               IT_Flags;
    LARGE_INTEGER       IT_LastUpdateTime;
    HANDLE              IT_FinishTriggeredUpdateTimer;
    HANDLE              IT_FinishFullUpdateTimer;
    CRITICAL_SECTION    IT_CS;
    READ_WRITE_LOCK     IT_RWL;
    LIST_ENTRY          IT_ListByAddress;
    LIST_ENTRY          IT_ListByIndex;
    LIST_ENTRY          IT_HashTableByIndex[IF_HASHTABLE_SIZE];

} IF_TABLE, *PIF_TABLE;


//
// constants and macros used for the flags field
//

#define IPRIP_FLAG_FULL_UPDATE_PENDING          ((DWORD)0x00000001)
#define IPRIP_FLAG_TRIGGERED_UPDATE_PENDING     ((DWORD)0x00000002)

#define IPRIP_FULL_UPDATE_PENDING(t)            \
    ((t)->IT_Flags & IPRIP_FLAG_FULL_UPDATE_PENDING)

#define IPRIP_TRIGGERED_UPDATE_PENDING(t)       \
    ((t)->IT_Flags & IPRIP_FLAG_TRIGGERED_UPDATE_PENDING)


DWORD
CreateIfTable(
    PIF_TABLE pTable
    );

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    );

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIPRIP_IF_CONFIG pConfig,
    PIF_TABLE_ENTRY *ppEntry
    );

DWORD
DeleteIfEntry(
    PIF_TABLE pIfTable,
    DWORD dwIndex
    );

DWORD
ValidateIfConfig(
    PIPRIP_IF_CONFIG pic
    );

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    );

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIPRIP_IF_CONFIG pConfig
    );

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );


#define IF_TABLE_CREATED(pTable) ((pTable)->IT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR THE PEER STATISTICS HASH TABLE
//

//
// struct:      PEER_TABLE_ENTRY
//
// declares the structure of each entry in the peer table
//
typedef struct _PEER_TABLE_ENTRY {

    LIST_ENTRY          PTE_LinkByAddress;
    LIST_ENTRY          PTE_HTLinkByAddress;
    DWORD               PTE_Address;
    IPRIP_PEER_STATS    PTE_Stats;

} PEER_TABLE_ENTRY, *PPEER_TABLE_ENTRY;



//
// macros and definitions used by peer statistics tables
//

#define PEER_HASHTABLE_SIZE     29
#define PEER_HASHVALUE(a)                                                   \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % PEER_HASHTABLE_SIZE)



//
// struct:      PEER_TABLE
//
// this table contains the entries for keeping statistics about each peer.
// it consists of a hash-table of peer stats (for fast direct access to
// a specific entry) and a list of peer stats entries ordered by address
// (for easy enumeration via MibGetNext)
//

typedef struct _PEER_TABLE {

    READ_WRITE_LOCK PT_RWL;
    DWORD           PT_Created;
    LIST_ENTRY      PT_ListByAddress;
    LIST_ENTRY      PT_HashTableByAddress[PEER_HASHTABLE_SIZE];

} PEER_TABLE, *PPEER_TABLE;


DWORD
CreatePeerTable(
    PPEER_TABLE pTable
    );

DWORD
DeletePeerTable(
    PPEER_TABLE pTable
    );

DWORD
CreatePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    PPEER_TABLE_ENTRY *ppEntry
    );

DWORD
DeletePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress
    );

PPEER_TABLE_ENTRY
GetPeerByAddress(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );


#define  PEER_TABLE_CREATED(pTable)  ((pTable)->PT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR THE ROUTE TABLE USED FOR NETWORK SUMMARY
//

//
// struct:      ROUTE_TABLE_ENTRY
//
// declares the structure of each entry in the route table
//
typedef struct _ROUTE_TABLE_ENTRY {

    LIST_ENTRY      RTE_Link;
    DWORD           RTE_TTL;
    DWORD           RTE_HoldTTL;
    RIP_IP_ROUTE    RTE_Route;

} ROUTE_TABLE_ENTRY, *PROUTE_TABLE_ENTRY;

//
// declares the structure of the protocol specific data
//

//
// macros and definitions used by the route table
//

//
// These flags are used in the ProtocolSpecificData array
// to distinguish routes pending expiration from routes pending removal,
// and to store the route tag for each route.
// The first DWORD in the PSD_Data array is treated here as a byte-array;
// the first two bytes are used to store the route tag;
// the third byte is used to store the route flag
//

#define PSD(route)                  (route)->RR_ProtocolSpecificData.PSD_Data
#define PSD_TAG0                    0
#define PSD_TAG1                    1
#define PSD_FLAG                    2

#define ROUTEFLAG_SUMMARY           ((BYTE)0x03)


#define SETROUTEFLAG(route, flag)   (((PBYTE)&PSD(route))[PSD_FLAG] = (flag))

#define GETROUTEFLAG(route)         ((PBYTE)&PSD(route))[PSD_FLAG]


#define SETROUTETAG(route, tag) \
        ((PBYTE)&PSD(route))[PSD_TAG0] = LOBYTE(tag), \
        ((PBYTE)&PSD(route))[PSD_TAG1] = HIBYTE(tag)

#define GETROUTETAG(route) \
        MAKEWORD(((PBYTE)&PSD(route))[PSD_TAG0],((PBYTE)&PSD(route))[PSD_TAG1])


#define SETROUTEMETRIC(route, metric)   \
        (route)->RR_FamilySpecificData.FSD_Metric1 = (metric)

#define GETROUTEMETRIC(route)   \
        (route)->RR_FamilySpecificData.FSD_Metric1


#define COMPUTE_ROUTE_METRIC(route) \
        (route)->RR_FamilySpecificData.FSD_Metric = \
        (route)->RR_FamilySpecificData.FSD_Metric1



//
// Macros to manipulate entity specific info in RTMv2 routes
//

#define ESD(route)                  (route)->EntitySpecificInfo
#define ESD_TAG0                    0
#define ESD_TAG1                    1
#define ESD_FLAG                    2

#define SETRIPFLAG(route, flag)     (((PBYTE)&ESD(route))[ESD_FLAG] = (flag))
    
#define GETRIPFLAG(route)           ((PBYTE)&ESD(route))[ESD_FLAG]

#define SETRIPTAG(route, tag)   \
        ((PBYTE)&ESD(route))[ESD_TAG0] = LOBYTE(tag), \
        ((PBYTE)&ESD(route))[ESD_TAG1] = HIBYTE(tag)

#define GETRIPTAG(route) \
        MAKEWORD(((PBYTE)&ESD(route))[ESD_TAG0],((PBYTE)&ESD(route))[ESD_TAG1])



#define ROUTE_HASHTABLE_SIZE  29
#define ROUTE_HASHVALUE(a)                                                  \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % ROUTE_HASHTABLE_SIZE)


//
// struct:      ROUTE_TABLE
//
// declares the structure of a route table, which consists of a hash-table
// of routes hashed on the destination network. Note that no synchronization
// is included since this structure is only used during full-updates, to
// store summary routes, and at most one thread may be sending a full-update
// at any given time.
//

typedef struct _ROUTE_TABLE {

    DWORD       RT_Created;
    LIST_ENTRY  RT_HashTableByNetwork[ROUTE_HASHTABLE_SIZE];

} ROUTE_TABLE, *PROUTE_TABLE;


DWORD
CreateRouteTable(
    PROUTE_TABLE pTable
    );

DWORD
DeleteRouteTable(
    PROUTE_TABLE pTable
    );

DWORD
WriteSummaryRoutes(
    PROUTE_TABLE pTable,
    HANDLE hRtmHandle
    );

DWORD
CreateRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute,
    DWORD dwTTL,
    DWORD dwHoldTTL
    );

DWORD
DeleteRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    );

PROUTE_TABLE_ENTRY
GetRouteByRoute(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    );

#define ROUTE_TABLE_CREATED(pTable)     ((pTable)->RT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR BINDING TABLE
//


//
// struct:      BINDING_TABLE_ENTRY
//
// this entry contains a single binding.
// a binding entry consists of an IP address, a network number (found
// using the network class mask, not the subnet mask),
// and a subnet mask.
// All of the above are available when an interface is bound.
// When a route arrives and its mask is to be guessed, its network number
// can be computed (using the routes network class mask); we then search
// the binding table for matching networks, and for each one we compare 
//     (stored subnet mask) AND (interface IP address)
// to
//     (stored subnet mask) AND (incoming route IP address).
// When we find a match, (stored subnet mask) is our guess.
//

typedef struct _BINDING_TABLE_ENTRY {

    DWORD       BTE_Address;
    DWORD       BTE_Network;
    DWORD       BTE_Netmask;
    LIST_ENTRY  BTE_Link;

} BINDING_TABLE_ENTRY, *PBINDING_TABLE_ENTRY;



#define BINDING_HASHTABLE_SIZE  29
#define BINDING_HASHVALUE(a)                                                \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % BINDING_HASHTABLE_SIZE)


//
// struct:      BINDING_TABLE
// 
// this table is used to store binding information that is used to guess
// the subnet masks of incoming routes. it contains the bindings of all
// interfaces which have been added to IPRIP, in an array to speed up access
//

typedef struct _BINDING_TABLE {

    READ_WRITE_LOCK     BT_RWL;
    DWORD               BT_Created;
    LIST_ENTRY          BT_HashTableByNetwork[BINDING_HASHTABLE_SIZE];

} BINDING_TABLE, *PBINDING_TABLE;


#define BINDING_TABLE_CREATED(b)    ((b)->BT_Created == 0x12345678)

DWORD
CreateBindingTable(
    PBINDING_TABLE pTable
    );

DWORD
DeleteBindingTable(
    PBINDING_TABLE pTable
    );

DWORD
CreateBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    );

DWORD
DeleteBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    );

DWORD
GuessSubnetMask(
    DWORD dwAddress,
    PDWORD pdwNetclassMask
    );

DWORD
AddRtmRoute(
    RTM_ENTITY_HANDLE   hRtmHandle,
    PRIP_IP_ROUTE       prir,
    RTM_NEXTHOP_HANDLE  hNextHop            OPTIONAL,
    DWORD               dwTimeOut,
    DWORD               dwHoldTime,
    BOOL                bActive
    );

DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo    OPTIONAL,
    IN  PRTM_DEST_INFO      pInDestInfo     OPTIONAL,
    OUT PRIP_IP_ROUTE       pRoute
    );

#endif // _TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\load.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    testdll.c

Abstract:

    Sample SNMP subagent.

--*/

#include "precomp.h"
#pragma hdrstop


#if defined( MIB_DEBUG )

DWORD               g_dwTraceId     = INVALID_TRACEID;

#endif

MIB_SERVER_HANDLE   g_hMIBServer    = ( MIB_SERVER_HANDLE) NULL;

//
// Critical section to protect MIB server handle
//

CRITICAL_SECTION    g_CS;

//
// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  
//

DWORD g_uptimeReference = 0;

//
// Handle to Subagent Framework 
//

SnmpTfxHandle g_tfxHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Subagent entry points                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DWORD       dwRes   = (DWORD) -1;

#if defined( MIB_DEBUG )

    //
    // tracing for DEBUG
    //
    
    g_dwTraceId = TraceRegister( "IPRIPMIB" );
#endif

    g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
    
    //
    // Verify router service is running
    //

    if ( !MprAdminIsServiceRunning( NULL ) )
    {
        TRACE0( "Router Service not running" );
    }

    else {
        //
        // Connect to router.  In case of error, set
        // connection handle to NULL.  Connection can
        // be established later.
        //
        
        dwRes = MprAdminMIBServerConnect(
                    NULL,
                    &g_hMIBServer
                );

        if ( dwRes != NO_ERROR )
        {
            g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
            
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", dwRes
            );
            return FALSE;
        }    
    }

    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    g_tfxHandle = SnmpTfxOpen(1,&v_msiprip2);

    // validate handle
    if (g_tfxHandle == NULL) {
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_msiprip2.viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved
)
{
    
    BOOL bRetVal = TRUE;

    switch ( fdwReason )
    {
        case DLL_PROCESS_ATTACH :
        {
            DisableThreadLibraryCalls( hInstDLL );


            try {
                InitializeCriticalSection( &g_CS );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                bRetVal = FALSE;
                break;
            }

            break;
        }
        
        case DLL_PROCESS_DETACH :
        {
            //
            // Disconnect from router
            //

            if ( g_hMIBServer )
            {
                MprAdminMIBServerDisconnect( g_hMIBServer );
            }

            DeleteCriticalSection( &g_CS );
            
#if defined( MIB_DEBUG )

            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TraceDeregister( g_dwTraceId );
            }
#endif              
            break;
         }
         
         default :
         {
            break;
         }
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\defs.h ===
#ifndef __DEFS_H__
#define __DEFS_H__

//------------------------------------------------------------------------------
// Global config default values
//------------------------------------------------------------------------------

#define     IPRIP_DEF_LOG_LEVEL             d_globalLoggingLevel_none
#define     IPRIP_DEF_SEND_Q_SIZE           1024 * 1024
#define     IPRIP_DEF_RECV_Q_SIZE           1024 * 1024
#define     IPRIP_DEF_MIN_TRIG_UPDATE_INTR  5
#define     IPRIP_DEF_PEER_FILTER_MODE      d_globalPeerFilterMode_disable

#define     IP_ADDRESS_LEN  4

//------------------------------------------------------------------------------
// Interface Config default values
//------------------------------------------------------------------------------
#define     MAX_PROTOCOL_FLAG_VALUE         (DWORD) 0x1ff


//------------------------------------------------------------------------------
// Memory allocation/deallocation macros
//------------------------------------------------------------------------------

#define     RIP_MIB_ALLOC( x )          HeapAlloc( GetProcessHeap(), 0, (x) )
#define     RIP_MIB_FREE( x )           HeapFree( GetProcessHeap(), 0, (x) )

//------------------------------------------------------------------------------
// Macro to simplify use of DIM MIB functions
//------------------------------------------------------------------------------
#define     CONNECT_TO_ROUTER(res)                                          \
    (res) = ( g_hMIBServer ) ? NO_ERROR : ConnectToRouter()

#define     MIB_GET(type, w, x, y, z, res)                                  \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntry ## type(                                   \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_RIP,                                              \
                    (LPVOID) (w),                                           \
                    (x),                                                    \
                    (LPVOID *) (y),                                         \
                    (z)                                                     \
                );                                                          \
    }                                                                       \
}


#define     RIP_MIB_SET(x, y, res)                                          \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntrySet(                                        \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_RIP,                                              \
                    (LPVOID) (x),                                           \
                    (y)                                                     \
                );                                                          \
    }                                                                       \
}

#define     RIP_MIB_GET(w, x, y, z, res)                                    \
{                                                                           \
    MIB_GET(Get, w, x, y, z, res)                                           \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_ENTRY_NOT_FOUND;                                      \
    }                                                                       \
}
    
#define     RIP_MIB_GETFIRST(w, x, y, z, res)                               \
{                                                                           \
    MIB_GET(GetFirst, w, x, y, z, res)                                      \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
} 
   
#define     RIP_MIB_GETNEXT(w, x, y, z, res)                                \
{                                                                           \
    MIB_GET(GetNext, w, x, y, z, res)                                       \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
}


//------------------------------------------------------------------------------
// Macros to simplify opertions on peer address tables
//------------------------------------------------------------------------------
#define     FIND_PEER_ENTRY(Item, Count, Table, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD   __dwTmp;                                                    \
        if ( !InetCmp( (Item), (Table)[ __dwInd ], __dwTmp ) ) { break; }   \
    }                                                                       \
    (Index) = __dwInd;                                                      \
}

#define     DELETE_PEER_ENTRY(Index, Count, Src, Dst)                       \
{                                                                           \
    DWORD   __dwSrc = 0, __dwDst = 0;                                       \
    for ( ; __dwSrc < (Count); __dwSrc++ )                                  \
    {                                                                       \
        if ( __dwSrc == (Index) ) { continue; }                             \
        (Dst)[ __dwDst++ ] = (Src)[ __dwSrc ];                              \
    }                                                                       \
}

//------------------------------------------------------------------------------
// Macros to simplify opertions on IP address table
//------------------------------------------------------------------------------
#define     FIND_IP_ADDRESS(Addr, Count, Table, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD __dwTmp;                                                      \
        if ( !InetCmp(                                                      \
                (Addr).IA_Address,                                          \
                (Table)[ __dwInd].IA_Address,                               \
                __dwTmp                                                     \
              ) &&                                                          \
             !InetCmp(                                                      \
                (Addr).IA_Netmask,                                          \
                (Table)[__dwInd].IA_Netmask,                                \
                __dwTmp                                                     \
              ) )                                                           \
        { break; }                                                          \
    }                                                                       \
    Index = __dwInd;                                                        \
}

//------------------------------------------------------------------------------
// Macros to simplify opertions on peer statistcs tables
//------------------------------------------------------------------------------
#define     GetPeerStatsInfo                    GetInterfaceInfo

//------------------------------------------------------------------------------
// Macros to simplify operations on filter tables
//------------------------------------------------------------------------------

#define     RIP_MIB_ACCEPT_FILTER           1

#define     RIP_MIB_ANNOUNCE_FILTER         2

#define     FIND_FILTER(pFilt, Count, pFiltLst, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD __dwTmp;                                                      \
        if ( !InetCmp(                                                      \
                (pFilt)-> RF_LoAddress,                                     \
                (pFiltLst)[ __dwInd].RF_LoAddress,                          \
                __dwTmp                                                     \
              ) &&                                                          \
             !InetCmp(                                                      \
                (pFilt)-> RF_HiAddress,                                     \
                (pFiltLst)[__dwInd].RF_HiAddress,                           \
                __dwTmp                                                     \
              ) )                                                           \
        { break; }                                                          \
    }                                                                       \
    Index = __dwInd;                                                        \
}

#define     DELETE_FILTER(Index, Count, Src, Dst) \
    DELETE_PEER_ENTRY(Index, Count, Src, Dst)


//------------------------------------------------------------------------------
// Macros to convert between Asn and Win32 data types
//------------------------------------------------------------------------------

#define SetAsnInteger(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);             \
	    (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnInteger(dstBuf,val){                     \
    (dstBuf)->asnType = ASN_INTEGER;                        \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnCounter(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);     \
        (dstBuf)->asnValue.counter = (AsnCounter)(val);     \
    }                                                       \
}

#define SetAsnGauge(dstBuf,val){                            \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_GAUGE);       \
        (dstBuf)->asnValue.gauge = (AsnGauge)(val);         \
    }                                                       \
}

#define SetAsnTimeTicks(dstBuf,val){                        \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS);   \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val);     \
    }                                                       \
}

#define SetAsnOctetString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);         \
        (dstBuf)->asnValue.string.length = len;             \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;          \
    }                                                       \
}

#define SetAsnIPAddr( dstBuf, val )                             \
{                                                               \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if( (dstBuf)->asnValue.address.stream)                  \
        {                                                       \
            (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;\
        }                                                       \
    }                                                           \
}

#define SetAsnIPAddress(dstBuf,buffer,val){                     \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define ForceSetAsnIPAddress(dstBuf,buffer,val){                \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}

#define SetAsnUshort(dstBuf,buffer,val){                   \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);        \
        (dstBuf)->asnValue.string.length = 2;              \
        (buffer)[0] = (BYTE)(val&0xFF);                    \
        (buffer)[1] = (BYTE)((val>>8)&0xFF);               \
        (dstBuf)->asnValue.string.stream = (BYTE *)buffer; \
        (dstBuf)->asnValue.string.dynamic = FALSE;         \
    }                                                      \
}
#define SetAsnDispString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING); \
        (dstBuf)->asnValue.string.length = strlen(src);    \
        if ((dstBuf)->asnValue.string.length>len)          \
        {                                                  \
            (dstBuf)->asnValue.string.length = len;        \
            (dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,\
                                                            (dstBuf)->asnValue.string.length);\
            (dstBuf)->asnValue.string.dynamic = FALSE;     \
        }                                                  \
    }                                                      \
}

#define SetToZeroOid(dstBuf,buffer){                       \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OBJECTIDENTIFIER);   \
        (dstBuf)->asnValue.object.idLength = NULL_OID_LEN; \
        (dstBuf)->asnValue.object.ids = buffer;            \
        (dstBuf)->asnValue.object.ids[0]   = 0;            \
        (dstBuf)->asnValue.object.ids[1]   = 0;            \
    }                                                      \
}

#define GetAsnInteger(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnTimeTicks(srcBuf, defval) \
    ( ( (srcBuf)-> asnType ) ? (srcBuf)-> asnValue.ticks : (defval) )

#define GetAsnOctetString(dst,srcBuf)                                                   \
    (((srcBuf)->asnType)?		                                                        \
     (memcpy(dst,(srcBuf)->asnValue.string.stream,(srcBuf)->asnValue.string.length))    \
     :NULL)	

#define GetAsnIPAddress(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))	

                
#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))



//------------------------------------------------------------------------------
// IP address / port comparison macros
//------------------------------------------------------------------------------

//
// LONG
// Cmp(DWORD dwFirst, DWORD dwSecond, LONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((LONG)((lResult) = ((dwFirst) - (dwSecond))))

//
// LONG
// PortCmp(DWORD wPort1, DWORD wPort2, LONG lResult)
//

#define PortCmp(dwPort1, dwPort2,lResult) ((LONG)((lResult) = ((ntohs((WORD)dwPort1)) - (ntohs((WORD)dwPort2)))))

// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                    \
    ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
            (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
             (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
              (((dwIpAddr1) & 0xff000000) - ((dwIpAddr2) & 0xff000000))))))                  


//------------------------------------------------------------------------------
// Debug tracing macros
//------------------------------------------------------------------------------

#ifdef MIB_DEBUG
#define TRACE0(Z)             TracePrintf(g_dwTraceId,Z)
#define TRACE1(Y,Z)           TracePrintf(g_dwTraceId,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_dwTraceId,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_dwTraceId,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_dwTraceId,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_dwTraceId,U,W,X,Y,Z)

#define TRACEW0(Z)            TracePrintfW(g_dwTraceId,Z)

#define TraceEnter(X)         TracePrintf(g_dwTraceId,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_dwTraceId,"Leaving " X "\n")

#define TraceError(X) \
    TracePrintf( g_dwTraceId, "MprAdminMIB API returned : %d", (X) ); 

#define TraceError1(x)                              \
{                                                   \
    LPWSTR  __lpwszErr = NULL;                      \
                                                    \
    TRACE1( "MprAdminMIB API returned : %d", (x) ); \
    MprAdminGetErrorString( (x), &__lpwszErr );     \
                                                    \
    if ( __lpwszErr )                               \
    {                                               \
        TRACEW0( __lpwszErr );                      \
        LocalFree( __lpwszErr );                    \
    }                                               \
}                                               

#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TRACEW0(Z)            
#define TraceEnter(X) 
#define TraceLeave(X)
#define TraceError(x)
#endif


#define EnterReader(X)
#define ReleaseLock(X)
#define ReaderToWriter(X)
#define EnterWriter(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\work.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: work.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// worker function implementations
//============================================================================

#include "pchrip.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

VOID
ProcessSocket(
    DWORD dwAddrIndex,
    PIF_TABLE_ENTRY pite,
    PIF_TABLE pTable
    );

VOID
EnqueueStartFullUpdate(
    PIF_TABLE_ENTRY pite,
    LARGE_INTEGER qwLastFullUpdateTime
    );

DWORD
EnqueueDemandUpdateCheck(
    PUPDATE_CONTEXT pwc
    );

VOID
EnqueueDemandUpdateMessage(
    DWORD dwInterfaceIndex,
    DWORD dwError
    );

DWORD
CountInterfaceRoutes(
    DWORD dwInterfaceIndex
    );

BOOL
ProcessResponseEntry(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    DWORD dwSource,
    PIPRIP_ENTRY pIE,
    PIPRIP_PEER_STATS pPS
    );

DWORD
SendRouteOnIfList(
    UPDATE_BUFFER pBufList[],
    DWORD dwBufCount,
    DWORD dwSendMode,
    PROUTE_TABLE pSummaryTable,
    PRIP_IP_ROUTE pRoute
    );



//----------------------------------------------------------------------------
// Macro:   RTM_ROUTE_FROM_IPRIP_ENTRY
// Macro:   IPRIP_ENTRY_FROM_RTM_ROUTE
//
// These two macros are used to transfer data from an RTM route struct
// to an IPRIPv2 packet route entry, and vice versa.
// The first two bytes of an RTM route's ProtocolSpecificData array are used
// to store the route tag contained in the IPRIP packet route-entry
//----------------------------------------------------------------------------

#define RTM_ROUTE_FROM_IPRIP_ENTRY(r,i)                                     \
    (r)->RR_RoutingProtocol = PROTO_IP_RIP;                                       \
    SETROUTEMETRIC((r), ntohl((i)->IE_Metric));                             \
    (r)->RR_Network.N_NetNumber = (i)->IE_Destination;                      \
    (r)->RR_Network.N_NetMask = (i)->IE_SubnetMask;                         \
    (r)->RR_NextHopAddress.N_NetNumber = (i)->IE_Nexthop;                   \
    (r)->RR_NextHopAddress.N_NetMask = (i)->IE_SubnetMask;                  \
    SETROUTETAG((r), ntohs((i)->IE_RouteTag))

#define IPRIP_ENTRY_FROM_RTM_ROUTE(i,r)                                     \
    (i)->IE_AddrFamily = htons(AF_INET);                                    \
    (i)->IE_Metric = htonl(GETROUTEMETRIC(r));                              \
    (i)->IE_Destination = (r)->RR_Network.N_NetNumber;                      \
    (i)->IE_SubnetMask = (r)->RR_Network.N_NetMask;                         \
    (i)->IE_Nexthop = (r)->RR_NextHopAddress.N_NetNumber



//----------------------------------------------------------------------------
// Macro:   IS_ROUTE_IN_ACCEPT_FILTER
// Macro:   IS_ROUTE_IN_ANNOUNCE_FILTER
//
// The following three macros are used to search for a route
// in the accept filters and announce filters configured for an interface
// The last two macros invoke the first macro which executes the inner loop,
// since the inner loop is identical in both cases.
//----------------------------------------------------------------------------

#define IS_ROUTE_IN_FILTER(route,ret)                       \
    (ret) = 0;                                              \
    for ( ; _pfilt < _pfiltend; _pfilt++) {                 \
        _filt = _pfilt->RF_LoAddress;                       \
        if (INET_CMP(route, _filt, _cmp) == 0) { (ret) = 1; break; }    \
        else if (_cmp > 0) {                                \
            _filt = _pfilt->RF_HiAddress;                   \
            if (INET_CMP(route, _filt, _cmp) <= 0) { (ret) = 1; break; }\
        }                                                   \
    }

#define IS_ROUTE_IN_ACCEPT_FILTER(ic,route,ret) {           \
    INT _cmp;                                               \
    DWORD _filt;                                            \
    PIPRIP_ROUTE_FILTER _pfilt, _pfiltend;                  \
    _pfilt = IPRIP_IF_ACCEPT_FILTER_TABLE(ic);              \
    _pfiltend = _pfilt + (ic)->IC_AcceptFilterCount;        \
    IS_ROUTE_IN_FILTER(route,ret);                          \
}

#define IS_ROUTE_IN_ANNOUNCE_FILTER(ic,route,ret) {         \
    INT _cmp;                                               \
    DWORD _filt;                                            \
    PIPRIP_ROUTE_FILTER _pfilt, _pfiltend;                  \
    _pfilt = IPRIP_IF_ANNOUNCE_FILTER_TABLE(ic);            \
    _pfiltend = _pfilt + (ic)->IC_AnnounceFilterCount;      \
    IS_ROUTE_IN_FILTER(route,ret);                          \
}




//----------------------------------------------------------------------------
// Macro:   IS_PEER_IN_FILTER
//
// macro used to search the peer filters
//----------------------------------------------------------------------------

#define IS_PEER_IN_FILTER(gc,peer,ret) {                        \
    PDWORD _pdwPeer, _pdwPeerEnd;                               \
    (ret) = 0;                                                  \
    _pdwPeer = IPRIP_GLOBAL_PEER_FILTER_TABLE(gc);              \
    _pdwPeerEnd = _pdwPeer + (gc)->GC_PeerFilterCount;          \
    for ( ; _pdwPeer < _pdwPeerEnd; _pdwPeer++) {               \
        if (*_pdwPeer == (peer)) { (ret) = 1; break; }          \
    }                                                           \
}





//----------------------------------------------------------------------------
// UPDATE BUFFER MANAGEMENT
//
// The following types and functions are used to simplify
// the transmission of routes. The system consists of the struct
// UPDATE_BUFFER, which includes a function table and a byte buffer,
// and a number of three-function update buffer routine sets.
// The sets each contain a routine to start an update buffer,
// to add a route to an update buffer, and to finish an update buffer.
//
// There are separate versions for RIPv1 mode and RIPv2 mode. The function
// InitializeUpdateBuffer sets up the function table in an update buffer
// depending on the configuration for the interface with which the buffer
// is associated. This set-up eliminates the need to check the interface
// configuration every time an entry must be added; instead, the config
// is checked a single time to set up the function table, and afterward
// the function generating the update merely calls the functions in the table.
//
// The setup also depends on the mode in which the information is being sent.
// The address to which the information is being sent is stored in the
// update buffer, since this will be required every time a route is added.
// However, when a full-update is being generated on an interface operating
// in RIPv2 mode, the destination address stored is 224.0.0.9, but the
// actual destination network is the network of the out-going interface.
// Therefore, this address is also stored since it will be needed for
// split-horizon/poison-reverse/subnet-summary processing
//----------------------------------------------------------------------------

//
// these are the modes in which routes may be transmitted
//

#define SENDMODE_FULL_UPDATE        0
#define SENDMODE_TRIGGERED_UPDATE   1
#define SENDMODE_SHUTDOWN_UPDATE    2
#define SENDMODE_GENERAL_REQUEST    3
#define SENDMODE_GENERAL_RESPONSE1  4
#define SENDMODE_GENERAL_RESPONSE2  5
#define SENDMODE_SPECIFIC_RESPONSE1 6
#define SENDMODE_SPECIFIC_RESPONSE2 7



//
// this function set is for interfaces with announcements disabled
//

DWORD
StartBufferNull(
    PUPDATE_BUFFER pUB
    ) { return NO_ERROR; }

DWORD
AddEntryNull(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) { return NO_ERROR; }

DWORD
FinishBufferNull(
    PUPDATE_BUFFER pUB
    ) { return NO_ERROR; }


//
// this function-set is for RIPv1 interfaces
//

DWORD
StartBufferVersion1(
    PUPDATE_BUFFER pUB
    );
DWORD
AddEntryVersion1(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    );
DWORD
FinishBufferVersion1(
    PUPDATE_BUFFER pUB
    );


//
// this function-set is for RIPv2 interfaces
//

DWORD
StartBufferVersion2(
    PUPDATE_BUFFER pUB
    );
DWORD
AddEntryVersion2(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    );
DWORD
FinishBufferVersion2(
    PUPDATE_BUFFER pUB
    );




//----------------------------------------------------------------------------
// Function:    InitializeUpdateBuffer
//
// this function sets up the update-buffer, writing in the functions to use
// for restarting the buffer, adding entries, and finishing the buffer.
// It also stores the destination address to which the packet is being sent,
// as well as the network and netmask for the destination
// This assumes the binding table is locked.
//----------------------------------------------------------------------------

DWORD
InitializeUpdateBuffer(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    PUPDATE_BUFFER pUB,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwCommand
    ) {


    DWORD dwAnnounceMode;
    PIPRIP_IP_ADDRESS paddr;

    pUB->UB_Length = 0;


    //
    // save the pointer to the interface
    //

    pUB->UB_ITE = pITE;
    pUB->UB_AddrIndex = dwAddrIndex;
    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding) + dwAddrIndex;
    pUB->UB_Socket = pITE->ITE_Sockets[dwAddrIndex];
    pUB->UB_Address = paddr->IA_Address;
    pUB->UB_Netmask = paddr->IA_Netmask;


    //
    // save the command
    //

    pUB->UB_Command = dwCommand;


    //
    // store the absolute address to which this packet is destined,
    // which may differ from the address passed to sendto()
    // e.g. RIPv2 packets are destined for the interface's network,
    // but the address passed to sendto() is 224.0.0.9
    // if the destination passed in is 0, use the broadcast address
    // on the outgoing interface as the destination
    //

    if (dwDestination == 0) {

        if(paddr->IA_Netmask == 0xffffffff)
        {
            TRACE0(SEND,"MASK ALL ONES");

            pUB->UB_DestAddress = (paddr->IA_Address | ~(NETCLASS_MASK(paddr->IA_Address)));
        }
        else
        {
            pUB->UB_DestAddress = (paddr->IA_Address | ~paddr->IA_Netmask);
        }

        pUB->UB_DestNetmask = paddr->IA_Netmask;
    }
    else {

        pUB->UB_DestAddress = dwDestination;
        pUB->UB_DestNetmask = GuessSubnetMask(pUB->UB_DestAddress, NULL);
    }


    //
    // decide on the announce mode;
    // if the mode is DISABLED, we still send responses to SPECIFIC requests
    // on the interface, so set the mode to RIPv1/v2 if sending a specific
    // response on a disabled interface
    //

    dwAnnounceMode = pITE->ITE_Config->IC_AnnounceMode;

    if (dwAnnounceMode == IPRIP_ANNOUNCE_DISABLED) {
        if (dwSendMode == SENDMODE_SPECIFIC_RESPONSE1) {
            dwAnnounceMode = IPRIP_ANNOUNCE_RIP1;
        }
        else
        if (dwSendMode == SENDMODE_SPECIFIC_RESPONSE2) {
            dwAnnounceMode = IPRIP_ANNOUNCE_RIP2;
        }
    }


    //
    // set up the function table and destination address, which
    // depend on the announce-mode of the interface and on the sort
    // of information being transmitted
    //

    switch (dwAnnounceMode) {

        //
        // in RIP1 mode, packets are RIP1, broadcast
        //

        case IPRIP_ANNOUNCE_RIP1:

            pUB->UB_AddRoutine = AddEntryVersion1;
            pUB->UB_StartRoutine = StartBufferVersion1;
            pUB->UB_FinishRoutine = FinishBufferVersion1;

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;
            pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;

            break;



        //
        // in RIP1-compatible mode, packets are RIP2, broadcast,
        // except in the case of a general response to a RIP1 router,
        // in which case the packets are RIP1, unicast
        //

        case IPRIP_ANNOUNCE_RIP1_COMPAT:

            if (dwSendMode == SENDMODE_GENERAL_RESPONSE1) {

                pUB->UB_AddRoutine = AddEntryVersion1;
                pUB->UB_StartRoutine = StartBufferVersion1;
                pUB->UB_FinishRoutine = FinishBufferVersion1;
            }
            else {

                pUB->UB_AddRoutine = AddEntryVersion2;
                pUB->UB_StartRoutine = StartBufferVersion2;
                pUB->UB_FinishRoutine = FinishBufferVersion2;
            }

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;
            pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;

            break;


        //
        // in RIP2 mode, packets are RIP2, multicast, except in the case
        // of a general/specific responses, in which cases messages are unicast;
        // note that a RIP2-only router never sends a general response to
        // a request from a RIP1 router.
        //

        case IPRIP_ANNOUNCE_RIP2:

            pUB->UB_AddRoutine = AddEntryVersion2;
            pUB->UB_StartRoutine = StartBufferVersion2;
            pUB->UB_FinishRoutine = FinishBufferVersion2;

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;


            //
            // if sending to a specific destination, as a reponse
            // to a request or as a full update to a unicast peer,
            // set the IP address of the destination.
            // Else send to multicast address.
            //

            if ( dwDestination != 0 ) {
                pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;
            }
            else {
                pUB->UB_Destination.sin_addr.s_addr = IPRIP_MULTIADDR;
            }

            break;


        default:

            TRACE2(
                IF, "invalid announce mode on interface %d (%s)",
                pITE->ITE_Index, INET_NTOA(paddr->IA_Address)
                );

            pUB->UB_AddRoutine = AddEntryNull;
            pUB->UB_StartRoutine = StartBufferNull;
            pUB->UB_FinishRoutine = FinishBufferNull;

            return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    SendUpdateBuffer
//
// This function is invoked by the add-entry and finsih-buffer functions
// to send the contents of an update-buffer.
//----------------------------------------------------------------------------

DWORD
SendUpdateBuffer(
    PUPDATE_BUFFER pbuf
    ) {

    INT iLength;
    DWORD dwErr;

    TRACE1(SEND,"SENDING TO %s",INET_NTOA(pbuf->UB_Destination.sin_addr.s_addr));

    iLength = sendto(
                pbuf->UB_Socket, pbuf->UB_Buffer, pbuf->UB_Length, 0,
                (PSOCKADDR)&pbuf->UB_Destination, sizeof(SOCKADDR_IN)
                );

    if (iLength == SOCKET_ERROR || (DWORD)iLength < pbuf->UB_Length) {

        //
        // an error occurred
        //

        CHAR szDest[20], *lpszAddr;

        dwErr = WSAGetLastError();
        lstrcpy(szDest, INET_NTOA(pbuf->UB_Destination.sin_addr));
        lpszAddr = INET_NTOA(pbuf->UB_Address);

        TRACE4(
            SEND, "error %d sending update to %s on interface %d (%s)",
            dwErr, szDest, pbuf->UB_ITE->ITE_Index, lpszAddr
            );
        LOGWARN2(SENDTO_FAILED, lpszAddr, szDest, dwErr);

        InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_SendFailures);
    }
    else {

        if (pbuf->UB_Command == IPRIP_REQUEST) {
            InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_RequestsSent);
        }
        else {
            InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_ResponsesSent);
        }

        dwErr = NO_ERROR;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    StartBufferVersion1
//
// This starts a RIPv1 update-buffer, zeroing reserved fields,
// setting the version, and setting the command field
//----------------------------------------------------------------------------

DWORD
StartBufferVersion1(
    PUPDATE_BUFFER pUB
    ) {

    PIPRIP_HEADER pHdr;

    //
    // set up the header
    //

    pHdr = (PIPRIP_HEADER)pUB->UB_Buffer;
    pHdr->IH_Version = 1;
    pHdr->IH_Command = (BYTE)pUB->UB_Command;
    pHdr->IH_Reserved = 0;

    pUB->UB_Length = sizeof(IPRIP_HEADER);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddEntryVersion1
//
// This adds an entry to a RIPv1 buffer, first sending the buffer if it is full
//----------------------------------------------------------------------------

DWORD
AddEntryVersion1(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) {

    PIPRIP_ENTRY pie;

    //
    // if the buffer is full, transmit its contents and restart it
    //

    if ((pUB->UB_Length + sizeof(IPRIP_ENTRY)) > MAX_PACKET_SIZE) {

        SendUpdateBuffer(pUB);

        StartBufferVersion1(pUB);
    }


    //
    // point to the end of the buffer
    //

    pie = (PIPRIP_ENTRY)(pUB->UB_Buffer + pUB->UB_Length);

    IPRIP_ENTRY_FROM_RTM_ROUTE(pie, pRIR);


    //
    // zero out fields which are reserved in RIP1
    //

    pie->IE_SubnetMask = 0;
    pie->IE_RouteTag = 0;
    pie->IE_Nexthop = 0;

    pUB->UB_Length += sizeof(IPRIP_ENTRY);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FinishBufferVersion1
//
// this sends the contents of a RIPv1 buffer, if any
//----------------------------------------------------------------------------

DWORD
FinishBufferVersion1(
    PUPDATE_BUFFER pUB
    ) {


    //
    // send the buffer if it contains any entries
    //

    if (pUB->UB_Length > sizeof(IPRIP_HEADER)) {
        SendUpdateBuffer(pUB);
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    StartBufferVersion2
//
// this starts a RIPv2 buffer
//----------------------------------------------------------------------------

DWORD
StartBufferVersion2(
    PUPDATE_BUFFER pUB
    ) {

    PIPRIP_HEADER pHdr;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_AUTHENT_ENTRY pae;


    //
    // setup header
    //

    pHdr = (PIPRIP_HEADER)pUB->UB_Buffer;
    pHdr->IH_Version = 2;
    pHdr->IH_Command = (BYTE)pUB->UB_Command;
    pHdr->IH_Reserved = 0;

    pUB->UB_Length = sizeof(IPRIP_HEADER);


    //
    // see if we need to set up the authentication entry
    //

    pic = pUB->UB_ITE->ITE_Config;

    if (pic->IC_AuthenticationType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae = (PIPRIP_AUTHENT_ENTRY)(pUB->UB_Buffer + sizeof(IPRIP_HEADER));

        pae->IAE_AddrFamily = htons(ADDRFAMILY_AUTHENT);
        pae->IAE_AuthType = htons((WORD)pic->IC_AuthenticationType);

        CopyMemory(
            pae->IAE_AuthKey,
            pic->IC_AuthenticationKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        pUB->UB_Length += sizeof(IPRIP_AUTHENT_ENTRY);
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddEntryVersion2
//
// this adds an entry to RIPv2 buffer, first sending the buffer if it is full
//----------------------------------------------------------------------------

DWORD
AddEntryVersion2(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) {

    PIPRIP_ENTRY pie;


    //
    // send the contents if the buffer is full
    //

    if (pUB->UB_Length + sizeof(IPRIP_ENTRY) > MAX_PACKET_SIZE) {

        SendUpdateBuffer(pUB);

        StartBufferVersion2(pUB);
    }


    pie = (PIPRIP_ENTRY)(pUB->UB_Buffer + pUB->UB_Length);

    IPRIP_ENTRY_FROM_RTM_ROUTE(pie, pRIR);

    //
    // for RIP routes, we assume that the route tag will be set
    // in the RTM route struct already;
    // for non-RIP routes, we write the route tag
    // for the outgoing interface in the packet entry
    //

    if (pRIR->RR_RoutingProtocol == PROTO_IP_RIP) {
        pie->IE_RouteTag = htons(GETROUTETAG(pRIR));
    }
    else {
        pie->IE_RouteTag = htons(pUB->UB_ITE->ITE_Config->IC_RouteTag);
    }

    pUB->UB_Length += sizeof(IPRIP_ENTRY);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    FinishBufferVersion2
//
// this sends the contents of a RIPv2 buffer, if any
//----------------------------------------------------------------------------

DWORD
FinishBufferVersion2(
    PUPDATE_BUFFER pUB
    ) {

    //
    // the size above which we send depends on whether or not there
    // is an authentication entry
    //

    if (pUB->UB_ITE->ITE_Config->IC_AuthenticationType == IPRIP_AUTHTYPE_NONE) {

        if (pUB->UB_Length > sizeof(IPRIP_HEADER)) {
            SendUpdateBuffer(pUB);
        }
    }
    else {

        //
        // there is an authentication entry, so unless there
        // is also a route entry, we will not send this last buffer
        //

        if (pUB->UB_Length > (sizeof(IPRIP_HEADER) +
                              sizeof(IPRIP_AUTHENT_ENTRY))) {
            SendUpdateBuffer(pUB);
        }
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// ROUTE ENUMERATION ROUTINES
//
// The following definitions simplify the enumeration of routes
// when routing information is being sent from a single source on multiple
// interfaces, for instance when a triggered update is going out on all
// interfaces, or when a full-update is being sent, or when a number
// of interfaces are being shutdown. the function InitializeGetRoute looks at
// the mode in which it is supposed to send routes, and based on that
// builds a table of functions which will be used to enumerate the routes.
// In the case of a full-update, the enumeration functions would
// go to RTM to get the information; in the case of a triggered-update, they
// would dequeue routes from the send-queue.
//----------------------------------------------------------------------------


// the following are the type definitions of the functions
// in each get-route function group

typedef DWORD (*PGETROUTE_START)(PVOID *);
typedef DWORD (*PGETROUTE_NEXT)(PVOID *, PRIP_IP_ROUTE);
typedef DWORD (*PGETROUTE_FINISH)(PVOID *);



// The following three functions handle RTM route enumeration

DWORD
RtmGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    );
DWORD
RtmGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    );
DWORD
RtmGetRouteFinish(
    RTM_ENUM_HANDLE hEnumHandle
    );



// The following three functions handle full-update route enumeration
//  (a full-update enumerates routes from RTM)

#define FullUpdateGetRouteStart         RtmGetRouteStart
#define FullUpdateGetRouteNext          RtmGetRouteNext
#define FullUpdateGetRouteFinish        RtmGetRouteFinish



// The following three functions handle triggered-update route enumeration
//  (a triggered-update enumerates routes from the send-queue)

DWORD
TriggeredUpdateGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    );
DWORD
TriggeredUpdateGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    );
DWORD
TriggeredUpdateGetRouteFinish(
    RTM_ENUM_HANDLE hEnumHandle
    );



// The following three functions handle shutdown-update route enumeration.
//  On shutdown, routes are enumerated from RTM, but their metrics
//  are set to IPRIP_INFINITE-1 before being returned

#define ShutdownUpdateGetRouteStart     RtmGetRouteStart
DWORD ShutdownUpdateGetRouteNext(RTM_ENUM_HANDLE hEnumHandle, PRIP_IP_ROUTE pRoute);
#define ShutdownUpdateGetRouteFinish    RtmGetRouteFinish



// The following three functions handle general-response route enumeration
// a general response enumerates routes from RTM

#define GeneralResponseGetRouteStart    RtmGetRouteStart
#define GeneralResponseGetRouteNext     RtmGetRouteNext
#define GeneralResponseGetRouteFinish   RtmGetRouteFinish




//----------------------------------------------------------------------------
// Function:    InitializeGetRoute
//
// This functions sets up a get-route function group given the send-mode
//----------------------------------------------------------------------------

DWORD
InitializeGetRoute(
    DWORD dwSendMode,
    PGETROUTE_START *ppGS,
    PGETROUTE_NEXT *ppGN,
    PGETROUTE_FINISH *ppGF
    ) {


    switch (dwSendMode) {

        case SENDMODE_FULL_UPDATE:
            *ppGS = FullUpdateGetRouteStart;
            *ppGN = FullUpdateGetRouteNext;
            *ppGF = FullUpdateGetRouteFinish;
            break;

        case SENDMODE_TRIGGERED_UPDATE:
            *ppGS = TriggeredUpdateGetRouteStart;
            *ppGN = TriggeredUpdateGetRouteNext;
            *ppGF = TriggeredUpdateGetRouteFinish;
            break;

        case SENDMODE_SHUTDOWN_UPDATE:
            *ppGS = ShutdownUpdateGetRouteStart;
            *ppGN = ShutdownUpdateGetRouteNext;
            *ppGF = ShutdownUpdateGetRouteFinish;
            break;

        case SENDMODE_GENERAL_RESPONSE1:
        case SENDMODE_GENERAL_RESPONSE2:
            *ppGS = GeneralResponseGetRouteStart;
            *ppGN = GeneralResponseGetRouteNext;
            *ppGF = GeneralResponseGetRouteFinish;
            break;

        default:
            return ERROR_INVALID_PARAMETER;
            break;
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteStart
//
// starts an enumeration of RTM routes; includes only and all best routes
// the enumeration handle is written into ppEnumerator
//----------------------------------------------------------------------------

DWORD
RtmGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    ) {
    
    DWORD dwErr;
    RTM_NET_ADDRESS rna;


    RTM_IPV4_MAKE_NET_ADDRESS( &rna, 0 , 0 );

    dwErr = RtmCreateDestEnum(
                ig.IG_RtmHandle, RTM_VIEW_MASK_ANY, 
                RTM_ENUM_START | RTM_ENUM_ALL_DESTS, &rna,
                RTM_BEST_PROTOCOL, phEnumHandle
                );

    if (dwErr != NO_ERROR) {
    
        TRACE1( ROUTE, "error %d when creating enumeration handle", dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteNext
//
// continues an enumeration of RTM routes
//----------------------------------------------------------------------------

DWORD
RtmGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    BOOL bRelDest = FALSE, bRelUcast = FALSE;
    
    DWORD dwErr, dwNumDests = 1;

    RTM_DEST_INFO rdi, rdiTemp;
        
    char szNetwork[20], szNextHop[20];


    
    do {
    
        //
        // Get next route
        //

        do {
            dwErr = RtmGetEnumDests(
                        ig.IG_RtmHandle, hEnumHandle, &dwNumDests, &rdiTemp
                        );

            if (dwErr == ERROR_NO_MORE_ITEMS) {

                if (dwNumDests < 1) {
                
                    break;
                }

                dwErr = NO_ERROR;
            }

            else if (dwErr != NO_ERROR) {
            
                TRACE1(ANY, "error %d enumeratings dests", dwErr);
                break;
            }

            bRelDest = TRUE;


            //
            // Get route info for unicast view only
            //

            dwErr = RtmGetDestInfo(
                        ig.IG_RtmHandle, rdiTemp.DestHandle, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_UCAST, &rdi
                        );

            if (dwErr != NO_ERROR) {
            
                TRACE1(ANY, "error %d getting ucast info dests", dwErr);
                break;
            }

            bRelUcast = TRUE;


            //
            // Check if any route info is present in the UCAST view
            //

            if ( ( rdi.ViewInfo[0].HoldRoute == NULL ) &&
                 ( rdi.ViewInfo[0].Route == NULL ) )
            {
                //
                // This destination has no info in the UCAST view
                // Release all handles and get next route
                //
                
                dwErr = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdi);

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ANY, "error %d releasing UCAST dest %s/%d", dwErr,
                        szNetwork, rdi.DestAddress.NumBits
                        );
                }

                dwErr = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdiTemp);

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ANY, "error %d releasing dest %s/%d", dwErr,
                        szNetwork, rdi.DestAddress.NumBits
                        );
                }

                bRelDest = bRelUcast = FALSE;
                
                continue;
            }
                 
            
            //
            // convert to RIP internal representation, if hold down route present
            // use it as opposed to the best route.
            //

            dwErr = GetRouteInfo(
                        rdi.ViewInfo[0].HoldRoute ? rdi.ViewInfo[0].HoldRoute :
                                                    rdi.ViewInfo[0].Route,
                        NULL, &rdi, pRoute
                        );
                        
        } while (FALSE);
        

        if (dwErr != NO_ERROR) { 
        
            break; 
        }
            

        lstrcpy(szNetwork, INET_NTOA(pRoute->RR_Network.N_NetNumber));
        lstrcpy(szNextHop, INET_NTOA(pRoute->RR_NextHopAddress.N_NetNumber));
        

        //
        // set metrics as appropriate
        //
        
        if ( rdi.ViewInfo[0].HoldRoute != NULL ) {
        
            //
            // help down routes are always advertized with 
            // metric 16
            //

#if ROUTE_DBG
            TRACE2(
                ROUTE, "Holddown route %s/%d", szNetwork,
                rdi.DestAddress.NumBits
                );
#endif
            SETROUTEMETRIC(pRoute, IPRIP_INFINITE);
        }
        
        else if (pRoute-> RR_RoutingProtocol != PROTO_IP_RIP) {
        
            //
            // non-RIP routes are advertised with metric 2
            // TBD: This will need to be re-evaluated if/when we
            //      have a route redistribution policy
            //

            SETROUTEMETRIC(pRoute, 2);
        }
        
    } while ( FALSE );


    //
    // release handles as appropriate
    //
    
    if (bRelUcast) {
    
        DWORD dwErrTemp;
        
        dwErrTemp = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdi);

        if (dwErrTemp != NO_ERROR) {
        
            TRACE3(
                ANY, "error %d releasing UCAST dest %s/%d", dwErrTemp,
                szNetwork, rdi.DestAddress.NumBits
                );
        }
    }
    

    if (bRelDest) {
    
        DWORD dwErrTemp;
        
        dwErrTemp = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdiTemp);

        if (dwErrTemp != NO_ERROR) {
        
            TRACE3(
                ANY, "error %d releasing dest %s/%d", dwErrTemp,
                szNetwork, rdi.DestAddress.NumBits
                );
        }
    }

#if ROUTE_DBG

    if (dwErr == NO_ERROR) {
    
        TRACE4(
            ROUTE, "Enumerated route %s/%d via %s with metric %d",
            szNetwork, rdi.DestAddress.NumBits,
            szNextHop, GETROUTEMETRIC(pRoute)
            );
    }
#endif
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteFinish
//
// terminates an enumeration of RTM routes
//----------------------------------------------------------------------------

DWORD
RtmGetRouteFinish(
    RTM_ENUM_HANDLE EnumHandle
    ) {

    DWORD dwErr;
    
    dwErr = RtmDeleteEnumHandle( ig.IG_RtmHandle, EnumHandle );

    if (dwErr != NO_ERROR) {

        TRACE1( ANY, "error %d closing enumeration handle", dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    ShutdownUpdateGetRouteNext
//
// continues an enumeration of RTM routes for a shutdown-update.
// same as RtmGetRouteNext, except that metrics are set to IPRIP_INFINITE - 1
//----------------------------------------------------------------------------

DWORD
ShutdownUpdateGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;


    //
    // during a shutdown, all non-infinite metrics are set to 15
    //

    dwErr = RtmGetRouteNext(hEnumHandle, pRoute);

    if (dwErr == NO_ERROR && GETROUTEMETRIC(pRoute) != IPRIP_INFINITE) {
        SETROUTEMETRIC(pRoute, IPRIP_INFINITE - 1);
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteStart
//
// starts an enumeration of routes from the send queue
// for a triggered update. nothing to do, since the caller
// of SendRoutes should have locked the send queue already
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteStart(
    PRTM_ENUM_HANDLE pEnumHandle
    ) {

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteNext
//
// continues an enumeration of routes from the send-queue
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteNext(
    RTM_ENUM_HANDLE EnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;


    dwErr = DequeueSendEntry(ig.IG_SendQueue, pRoute);

    if (dwErr == NO_ERROR && pRoute->RR_RoutingProtocol != PROTO_IP_RIP) {

        //
        // non-RIP routes are advertised with metric 2
        // TBD: This will need to be re-evaluated if/when we
        //      have a route redistribution policy
        //

        SETROUTEMETRIC(pRoute, 2);
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteFinish
//
// terminates an enumeration of routes from the send-queue
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteFinish(
    RTM_ENUM_HANDLE EnumHandle
    ) {

    return NO_ERROR;
}






//----------------------------------------------------------------------------
// Function:    SendRoutes
//
// This function sends triggered updates, full-updates, shutdown-updates, and
// responses to general requests; the processing for all such output is the
// same. The source of routing information is different, however, and this
// difference is abstracted away using the route enumeration function groups
// described above.
// In the case of sending a response to a general or specific request,
// the response should be sent on a single interface using a single IP address,
// using a particular type of RIP packet; the caller can specify which
// IP address to use by setting the argument dwAddrIndex to the index of the
// desired address in the interface's IP address table, and the caller can
// specify the type of packet to use by setting the argument dwAnnounceMode
// to the corresponding IPRIP_ANNOUNCE_* constant. These arguments are only
// used for responses to requests.
//
// assumes the interface table is locked
//----------------------------------------------------------------------------

DWORD
SendRoutes(
    PIF_TABLE_ENTRY pIfList[],
    DWORD dwIfCount,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwAddrIndex
    ) {


    RTM_ENUM_HANDLE Enumerator;
    RIP_IP_ROUTE route;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwBufCount;
    PDWORD pdwPeer, pdwPeerEnd;
    PIF_TABLE_ENTRY *ppite, *ppitend = NULL;
    PUPDATE_BUFFER pbuf, pbufend, pBufList;
    PROUTE_TABLE_ENTRY prte;
    ROUTE_TABLE summaryTable;
    PGETROUTE_START pfnGetRouteStart;
    PGETROUTE_NEXT pfnGetRouteNext;
    PGETROUTE_FINISH pfnGetRouteFinish;
    PLIST_ENTRY plstart, plend, phead, ple;


    //
    // if no interfaces, go no further
    //

    if (dwIfCount == 0) { return ERROR_NO_DATA; }


    //
    // initialize the route enumeration function table
    //

    dwErr = InitializeGetRoute(
                dwSendMode,
                &pfnGetRouteStart,
                &pfnGetRouteNext,
                &pfnGetRouteFinish
                );

    if (dwErr != NO_ERROR) { return ERROR_INVALID_PARAMETER; }


    dwErr = NO_ERROR;
    Enumerator = NULL;


    //
    // create table for summary routes
    //

    dwErr = CreateRouteTable(&summaryTable);

    if (dwErr != 0) {

        TRACE1(SEND, "error %d initializing summary table", dwErr);

        return dwErr;
    }



    dwErr = NO_ERROR;

    pBufList = NULL;


    do { // breakout loop


        //
        // the following discussion does not apply when sending routes
        // to specific destinations:
        // since unicast peers may be configured on some interfaces,
        // we need to allocate update buffers for those peers as well.
        //
        // also, we will not allocate update buffers for RIPv1 interfaces
        // on which broadcast is disabled (such interfaces should have
        // at least one unicast peer configured instead.)
        //
        // Thus, the number of update buffers may not be equal to
        // the number of interfaces, and in the worst case (i.e. where
        // all interfaces are RIPv1 and have broadcast disabled and have
        // no unicast peers configured) there may be no update buffers at all.
        //

        if (dwDestination != 0) {

            //
            // sending to a specific destination; this only happens when
            // there is a single interface in the list, for instance when
            // sending a response to a general request
            //

            dwBufCount = dwIfCount;
        }
        else {

            //
            // we are sending a full-update, triggered-update, or
            // a shutdown-update, and thus routes may be sent by
            // broadcast/multicast as well as to unicast peers
            //

            dwBufCount = 0;
            ppitend = pIfList + dwIfCount;

            for (ppite = pIfList; ppite < ppitend; ppite++) {

                pic = (*ppite)->ITE_Config;
                pib = (*ppite)->ITE_Binding;

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {
                    dwBufCount += pib->IB_AddrCount;
                }

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED) {
                    dwBufCount += pic->IC_UnicastPeerCount;
                }
            }
        }


        if (dwBufCount == 0) { break; }


        //
        // allocate the update buffers for all interfaces
        //

        pBufList = RIP_ALLOC(dwBufCount * sizeof(UPDATE_BUFFER));

        if (pBufList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error %d allocating %d bytes for update buffers",
                dwErr, dwBufCount * sizeof(UPDATE_BUFFER)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the update buffers allocated; in the case of
        // sending to a specific destination, initialize a buffer
        // for each interface; in the case of sending updates, also
        // initialize buffers for unicast peers.
        //

        pbuf = pBufList;
        pbufend = pBufList + dwBufCount;
        ppitend = pIfList + dwIfCount;


        ACQUIRE_BINDING_LOCK_SHARED();


        for (ppite = pIfList; ppite < ppitend; ppite++) {


            if (dwDestination != 0) {

                //
                // sending to a specific destination
                //

                InitializeUpdateBuffer(
                    *ppite, dwAddrIndex, pbuf, dwSendMode, dwDestination,
                    IPRIP_RESPONSE
                    );

                pbuf->UB_StartRoutine(pbuf);

                ++pbuf;
            }
            else {


                //
                // sending updates on multiple interfaces
                //

                pic = (*ppite)->ITE_Config;
                pib = (*ppite)->ITE_Binding;


                //
                // if broadcast or multicast is enabled on the interface,
                // and it is not configured to send only to listed peers,
                // initialize the broadcast/multicast update buffer
                //

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

                    for (i = 0; i < pib->IB_AddrCount; i++) {

                        InitializeUpdateBuffer(
                            *ppite, i, pbuf, dwSendMode, dwDestination,
                            IPRIP_RESPONSE
                            );

                        pbuf->UB_StartRoutine(pbuf);

                        ++pbuf;
                    }
                }



                if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED) {

                    //
                    // initialize update buffers for unicast peers, if any
                    //

                    pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
                    pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;


                    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {

                        //
                        // Note: forcing peers to be on first address
                        //

                        InitializeUpdateBuffer(
                            *ppite, 0, pbuf, dwSendMode, *pdwPeer,
                            IPRIP_RESPONSE
                            );

                        pbuf->UB_StartRoutine(pbuf);

                        ++pbuf;
                    }
                }
            }
        }

        RELEASE_BINDING_LOCK_SHARED();


        //
        // start the route enumeration
        //

        if ( pfnGetRouteStart(&Enumerator) == NO_ERROR ) {
        
            //
            // enumerate and transmit the routes
            //

            while (pfnGetRouteNext(Enumerator, &route) == NO_ERROR) {

                //
                // for each route, send it on each update buffer,
                // subject to split-horizon/poison-reverse/subnet-summary
                // pass in the summary table pointer to store summarized routes
                //

                dwErr = SendRouteOnIfList(
                            pBufList, dwBufCount, dwSendMode, &summaryTable, &route
                            );
            }



            //
            // terminate the route enumeration
            //

            pfnGetRouteFinish(Enumerator);


            //
            // now send all routes which were summarized
            //

            plstart = summaryTable.RT_HashTableByNetwork;
            plend = plstart + ROUTE_HASHTABLE_SIZE;


            for (phead = plstart; phead < plend; phead++) {

                for (ple = phead->Flink; ple != phead; ple = ple->Flink) {


                    prte = CONTAINING_RECORD(ple, ROUTE_TABLE_ENTRY, RTE_Link);


                    //
                    // shouldn't summarize when sending summary table contents
                    // so we pass NULL instead of a summary table pointer
                    //

                    SendRouteOnIfList(
                        pBufList, dwBufCount, dwSendMode, NULL, &prte->RTE_Route
                        );

                }
            }

            //
            // finally, write the summarized routes to RTM
            //

            WriteSummaryRoutes(&summaryTable, ig.IG_RtmHandle);

        }
    } while(FALSE);



    //
    // free the allocated update buffers, if any
    //

    if (pBufList != NULL) {

        pbufend = pBufList + dwBufCount;


        for (pbuf = pBufList; pbuf < pbufend; pbuf++) {


            //
            // send whatever might remain in the update buffer
            //

            pbuf->UB_FinishRoutine(pbuf);
        }


        RIP_FREE(pBufList);
    }


    //
    // delete the summary table
    //

    DeleteRouteTable(&summaryTable);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    SendRouteOnIfList
//
// this function sends a single route on all interfaces in the given
// interface list, using the update buffers in the given update buffer list
//----------------------------------------------------------------------------

DWORD
SendRouteOnIfList(
    UPDATE_BUFFER pBufList[],
    DWORD dwBufCount,
    DWORD dwSendMode,
    PROUTE_TABLE pSummaryTable,
    PRIP_IP_ROUTE pRoute
    ) {


    RIP_IP_ROUTE route;
    DWORD dwFound, dwTTL;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PUPDATE_BUFFER pbuf, pbufend;
    DWORD dwDestNetwork, dwNexthopNetwork;
    DWORD dwDestNetclassAddr, dwDestNetclassMask;
    DWORD dwRouteNetclassAddr, dwRouteNetclassMask;
    DWORD dwRouteNetwork, dwRouteNetmask, dwRouteProtocol;

#if ROUTE_DBG
    CHAR szDest[32];
    CHAR szDestMask[32];
    CHAR szNexthop[32];
    CHAR szNexthopMask[32];
    CHAR szRoute[32];
    CHAR szRouteMask[32];


    //
    // set up variables used for error and information messages
    //

    lstrcpy(szRoute, INET_NTOA(pRoute->RR_Network.N_NetNumber));
    lstrcpy(szRouteMask, INET_NTOA(pRoute->RR_Network.N_NetMask));
    lstrcpy(szNexthop, INET_NTOA(pRoute->RR_NextHopAddress.N_NetNumber));
    lstrcpy(szNexthopMask, INET_NTOA(pRoute->RR_NextHopAddress.N_NetMask));

#endif


    //
    // we never send summary routes if they are read from RTM;
    // we only send them if they are generated in the process
    // of advertising actual routes on this iteration;
    // we can tell the difference by checking whether we are still
    // generating summary routes (i.e. if pSummaryTable is non-NULL);
    // if we aren't it is time to start sending summary routes
    //

    if (pSummaryTable != NULL && pRoute->RR_RoutingProtocol == PROTO_IP_RIP &&
        GETROUTEFLAG(pRoute) == ROUTEFLAG_SUMMARY) {

        return NO_ERROR;
    }


    //
    // get the route's network and netmask, and compute
    // the route's network class address and the network class mask;
    // to support supernetting, we double-check the class mask
    // and use the supernet mask if necessary
    //

    dwRouteProtocol = pRoute->RR_RoutingProtocol;
    dwRouteNetwork = pRoute->RR_Network.N_NetNumber;
    dwRouteNetmask = pRoute->RR_Network.N_NetMask;
    dwRouteNetclassMask = NETCLASS_MASK(dwRouteNetwork);

    if (dwRouteNetclassMask > dwRouteNetmask) {
        dwRouteNetclassMask = dwRouteNetmask;
    }

    dwRouteNetclassAddr = (dwRouteNetwork & dwRouteNetclassMask);


    //
    // go through each update buffer
    //

    pbufend = pBufList + dwBufCount;

    for (pbuf = pBufList; pbuf < pbufend; pbuf++) {


        pite = pbuf->UB_ITE;
        pic = pite->ITE_Config;


        //
        // if this is a broadcast route entry, skip it
        // The first condition uses the netmask information for this route, 
        // stored in route table, to determine if it is a broadcast route
        // The second condition uses the netmask which is computed based 
        // on the address class
        // The third condition checks if it is an all 1's broadcast
        //

        if ( IS_DIRECTED_BROADCAST_ADDR(dwRouteNetwork, dwRouteNetmask) ||
             IS_DIRECTED_BROADCAST_ADDR(dwRouteNetwork, dwRouteNetclassMask) ||
             IS_LOCAL_BROADCAST_ADDR(dwRouteNetwork) ) {

             continue;
        }


        //
        // if this is the multicast route entry, skip it
        //

        if ( CLASSD_ADDR( dwRouteNetwork ) || CLASSE_ADDR( dwRouteNetwork ) ) {
            continue;
        }


        //
        // If this is a loopback route, skip it.
        //

        if ( IS_LOOPBACK_ADDR( dwRouteNetwork ) ) {

            continue;
        }


        //
        // if this is the rotue to the outgoing interface's network,
        // (e.g. the route to 10.1.1.0 on interface 10.1.1.1/255.255.255.0)
        // don't include it in the update
        // (clearly, we shouldn't AND the default-route's netmask (0)
        // with anything and expect this to work
        //

        if (dwRouteNetmask &&
            dwRouteNetwork == (pbuf->UB_Address & dwRouteNetmask)) {
            continue;
        }


        //
        // if announcing host routes is disabled on the interface
        // and this is a host route, skip it
        //

        if (dwRouteNetmask == HOSTADDR_MASK &&
            IPRIP_FLAG_IS_DISABLED(pic, ANNOUNCE_HOST_ROUTES)) {

            continue;
        }


        //
        // if announcing default routes is disabled
        // and this is a default route, skip it
        //

        if (dwRouteNetwork == 0 &&
            IPRIP_FLAG_IS_DISABLED(pic, ANNOUNCE_DEFAULT_ROUTES)) {

            continue;
        }


        //
        // now put the route through the announce filters
        //

        if (pic->IC_AnnounceFilterMode != IPRIP_FILTER_DISABLED) {

            //
            // discard if we are including all routes and this route is listed
            // as an exception, or if we are excluding all routes and
            // this route is not listed as an exception
            //

            IS_ROUTE_IN_ANNOUNCE_FILTER(pic, dwRouteNetwork, dwFound);

            if ((pic->IC_AnnounceFilterMode == IPRIP_FILTER_INCLUDE &&
                    !dwFound) ||
                (pic->IC_AnnounceFilterMode == IPRIP_FILTER_EXCLUDE &&
                    dwFound)) {
                continue;
            }
        }



        //
        // SUBNET-SUMMARY PROCESSING:
        //
        // if the route is not on the network we are sending this to or
        // if the route's mask is longer than that of the network we are
        // sending to, or if the route is a network route, add it to the
        // summary table instead of sending it immediately.
        // default routes are excepted from summarization
        //


        route = *pRoute;


        if (pSummaryTable != NULL && dwRouteNetwork != 0) {


            //
            // get the destination address to which the update is being
            // sent for this interface; double-check the netclass mask
            // to accomodate supernets
            //

            dwDestNetclassAddr = pbuf->UB_DestAddress;
            dwDestNetclassMask = NETCLASS_MASK(dwDestNetclassAddr);

            if (dwDestNetclassMask > pbuf->UB_DestNetmask) {
                dwDestNetclassMask = pbuf->UB_DestNetmask;
            }

            dwDestNetclassAddr = (dwDestNetclassAddr & dwDestNetclassMask);


            if ((dwRouteNetwork == dwRouteNetclassAddr &&
                 dwRouteNetmask == dwRouteNetclassMask) ||
                dwDestNetclassAddr != dwRouteNetclassAddr) {

                if ((pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1) ||
                    !IPRIP_FLAG_IS_ENABLED(pic, NO_SUBNET_SUMMARY)) {

                    //
                    // either the route is a network route,
                    // or the update is going to a network different
                    // from that of the route
                    //

                    //
                    // create an entry in the summary table instead of sending;
                    //

                    route.RR_Network.N_NetNumber = dwRouteNetclassAddr;
                    route.RR_Network.N_NetMask = dwRouteNetclassMask;

                    if ((dwRouteNetwork != dwRouteNetclassAddr) ||
                        (dwRouteNetmask != dwRouteNetclassMask)) {
                        route.RR_RoutingProtocol = PROTO_IP_RIP;
                        SETROUTEFLAG(&route, ROUTEFLAG_SUMMARY);
                        SETROUTETAG(&route, pic->IC_RouteTag);
                    }


                    CreateRouteEntry(
                        pSummaryTable, &route, pic->IC_RouteExpirationInterval,
                        pic->IC_RouteRemovalInterval
                        );

                    continue;
                }
            }
            else
            if (pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1 &&
                dwRouteNetmask != HOSTADDR_MASK &&
                pbuf->UB_Netmask < dwRouteNetmask) {


                //
                // this is neither a host route nor a default route,
                // and the subnet-mask on the outgoing interface is shorter
                // than that of the route, so the route's network must be
                // truncated lest it be considered a host route by the routers
                // who will receive this update
                // only do this in RIP1 mode, since in RIP2 mode
                // we can include the netmask in the route entry
                //

                route.RR_Network.N_NetNumber &= pbuf->UB_Netmask;
                route.RR_Network.N_NetMask = pbuf->UB_Netmask;
                route.RR_RoutingProtocol = PROTO_IP_RIP;
                SETROUTEFLAG(&route, ROUTEFLAG_SUMMARY);
                SETROUTETAG(&route, pic->IC_RouteTag);

                CreateRouteEntry(
                    pSummaryTable, &route, pic->IC_RouteExpirationInterval,
                    pic->IC_RouteRemovalInterval
                    );

                continue;
            }
        }


        //
        // Summary route checks
        //
        //  Summary routes are to sent only on those interfaces that 
        //  require them i.e. Interfaces on which the annouce mode is
        //  RIP1 or on which summarization has been explicity turned on
        //

        if (pSummaryTable == NULL &&
            ((GETROUTEFLAG(&route) & ROUTEFLAG_SUMMARY) == ROUTEFLAG_SUMMARY) &&
            pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1 &&
            IPRIP_FLAG_IS_ENABLED(pic, NO_SUBNET_SUMMARY)) {

            //
            // This is a summary route, and the interface over which it is
            // to be sent does not require summary routes to be sent on it
            //

            continue;
        }

        
        //
        // SPLIT-HORIZON/POISON-REVERSE PROCESSING:
        //

        //
        // note that we only do split-horizon/poison-reverse on RIP routes
        //

        //
        // Modification : Split-horizon/poison-reverse done for all routes
        //
        // if (dwRouteProtocol != PROTO_IP_RIP ||
        //    IPRIP_FLAG_IS_DISABLED(pic, SPLIT_HORIZON))

        if (IPRIP_FLAG_IS_DISABLED(pic, SPLIT_HORIZON)) {
            //
            // add the entry as-is:
            // sender should use us as the nexthop to this destination
            //

            route.RR_NextHopAddress.N_NetNumber = 0;
            route.RR_NextHopAddress.N_NetMask = 0;

            pbuf->UB_AddRoutine(pbuf, &route);
        }
        else
        if (IPRIP_FLAG_IS_DISABLED(pic, POISON_REVERSE)) {


            //
            // if the route is being sent to the network from which
            // the route was learnt, exclude the route altogether
            //

            dwDestNetwork = (pbuf->UB_DestAddress & pbuf->UB_DestNetmask);
            dwNexthopNetwork = (route.RR_NextHopAddress.N_NetNumber &
                                route.RR_NextHopAddress.N_NetMask);

            //
            // Check if the route next hop is on the same network as the
            // socket from which this RIP response is being sent.
            // If so, do not include this route in the update.
            // Otherwise, we may still need to do poison-reverse
            // since the next-hop may be the other end of a point-to-point link
            // (endpoints of such links can be on different networks)
            // in which case the first test would succeed (different networks)
            // but we'd still be required to perform split-horizon.
            // Therefore if the outgoing interface is the one from which
            // the route was learnt, we do not include this route in the update.
            //

            if (dwNexthopNetwork == dwDestNetwork ||
                (pbuf->UB_ITE->ITE_Type == DEMAND_DIAL &&
                 route.RR_InterfaceID == pbuf->UB_ITE->ITE_Index)) {
                continue;
            }
            else {

                //
                // sending to a different network, so sender should use
                // us as the nexthop to this destination
                //

                route.RR_NextHopAddress.N_NetNumber = 0;
                route.RR_NextHopAddress.N_NetMask = 0;
            }

            pbuf->UB_AddRoutine(pbuf, &route);
        }
        else {


            //
            // if the route is being sent to the network from which
            // the route was learnt, include the route with infinite metric
            //


            dwDestNetwork = (pbuf->UB_DestAddress & pbuf->UB_DestNetmask);
            dwNexthopNetwork = (route.RR_NextHopAddress.N_NetNumber &
                                route.RR_NextHopAddress.N_NetMask);


            if (dwNexthopNetwork == dwDestNetwork ||
                (pbuf->UB_ITE->ITE_Type == DEMAND_DIAL &&
                 route.RR_InterfaceID == pbuf->UB_ITE->ITE_Index)) {

                //
                // if a route is advertised with infinite metric due to
                // poison-reverse and it would still be advertised with
                // infinite metric in a triggered update, save bandwidth
                // by excluding the route
                //

                if (dwSendMode == SENDMODE_TRIGGERED_UPDATE) {
                    continue;
                }
                else {
                    SETROUTEMETRIC(&route, IPRIP_INFINITE);
                }

            }
            else {

                //
                // sending to a different network, so sender should use
                // us as the nexthop to this destination
                //

                route.RR_NextHopAddress.N_NetNumber = 0;
                route.RR_NextHopAddress.N_NetMask = 0;
            }

            pbuf->UB_AddRoutine(pbuf, &route);
        }


        //
        // hold advertized destinations
        //

        if ((dwSendMode == SENDMODE_FULL_UPDATE) ||
            (dwSendMode == SENDMODE_GENERAL_RESPONSE1) ||
            (dwSendMode == SENDMODE_GENERAL_RESPONSE2)) {

            //
            // use the hold interval from the interface over which the
            // route is over.
            //

            if (pite->ITE_Index == route.RR_InterfaceID) {
            
                DWORD dwErr;
                
                dwErr = RtmHoldDestination(
                            ig.IG_RtmHandle, route.hDest, RTM_VIEW_MASK_UCAST,
                            pic-> IC_RouteRemovalInterval * 1000
                            );

                if (dwErr != NO_ERROR) {

                    TRACE1(ANY, "error %d holding dest", dwErr);
                }
            }
        }
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    SendGeneralRequest
//
// This function transmits RIP requests on interface to all neighbors in
// the interfaces neighbor list. A request is also sent via broadcast or
// multicast is the neighbor list is not used exclusively.
//----------------------------------------------------------------------------

DWORD
SendGeneralRequest(
    PIF_TABLE_ENTRY pite
    ) {

    DWORD i, dwErr;
    PIPRIP_ENTRY pie;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PDWORD pdwPeer, pdwPeerEnd;


    pic = pite->ITE_Config;
    pib = pite->ITE_Binding;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    ACQUIRE_BINDING_LOCK_SHARED();


    do {    // error breakout loop


        //
        // broadcast/multicast a request if not using neighbor-list only
        //

        if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

            for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

                UPDATE_BUFFER ub;

                //
                // initialize the update buffer
                //

                dwErr = InitializeUpdateBuffer(
                            pite, i, &ub, SENDMODE_GENERAL_REQUEST, 0,
                            IPRIP_REQUEST
                            );

                ub.UB_StartRoutine(&ub);


                //
                // set up the general request entry
                //

                pie = (PIPRIP_ENTRY)(ub.UB_Buffer + ub.UB_Length);

                pie->IE_AddrFamily = ADDRFAMILY_REQUEST;
                pie->IE_RouteTag = 0;
                pie->IE_Destination = 0;
                pie->IE_SubnetMask = 0;
                pie->IE_Nexthop = 0;
                pie->IE_Metric = htonl(IPRIP_INFINITE);

                ub.UB_Length += sizeof(IPRIP_ENTRY);


                //
                // send the buffer
                //

                ub.UB_FinishRoutine(&ub);
            }
        }


        //
        // if the list of peers is not in use, we are done
        //

        if (pic->IC_UnicastPeerMode == IPRIP_PEER_DISABLED) { break; }


        //
        // send requests to all the configured peers
        //

        pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
        pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;

        for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {

            UPDATE_BUFFER ub;

            //
            // initialize the update buffer
            // Note: we are forcing the peers onto the first address
            //

            dwErr = InitializeUpdateBuffer(
                        pite, 0, &ub, SENDMODE_GENERAL_REQUEST, *pdwPeer,
                        IPRIP_REQUEST
                        );

            ub.UB_StartRoutine(&ub);


            //
            // set up the general request entry
            //

            pie = (PIPRIP_ENTRY)(ub.UB_Buffer + ub.UB_Length);

            pie->IE_AddrFamily = ADDRFAMILY_REQUEST;
            pie->IE_RouteTag = 0;
            pie->IE_Destination = 0;
            pie->IE_SubnetMask = 0;
            pie->IE_Nexthop = 0;
            pie->IE_Metric = htonl(IPRIP_INFINITE);

            ub.UB_Length += sizeof(IPRIP_ENTRY);


            //
            // send the buffer
            //

            ub.UB_FinishRoutine(&ub);
        }

    } while(FALSE);


    RELEASE_BINDING_LOCK_SHARED();

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AuthenticatePacket
//
// Given a RIP packet and an interface configuration block, this function
// accepts or rejects the packet based on the authentication settings
// of the interface and the authentication content of the packet.
//----------------------------------------------------------------------------

DWORD
AuthenticatePacket(
    PBYTE pbuf,
    PIPRIP_AUTHENT_ENTRY pae,
    PIPRIP_IF_CONFIG pic,
    PIPRIP_IF_STATS pis,
    PIPRIP_PEER_STATS pps,
    PIPRIP_ENTRY *ppie
    ) {

    DWORD dwErr;

    dwErr = NO_ERROR;

    if (pic->IC_AuthenticationType == IPRIP_AUTHTYPE_NONE) {

        //
        // interface is not configured for authentication,
        // so discard authenticated packets
        //

        if (pae->IAE_AddrFamily == htons(ADDRFAMILY_AUTHENT)) {

            if (pis != NULL) {
                InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            }

            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            dwErr = ERROR_ACCESS_DENIED;
        }
    }
    else {

        //
        // interface is using authentication,
        // so discard unauthenticated packets
        // and packets using different authentication schemes
        //

        if (pae->IAE_AddrFamily != htons(ADDRFAMILY_AUTHENT) ||
            pae->IAE_AuthType != htons((WORD)pic->IC_AuthenticationType)) {

            if (pis != NULL) {
                InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            }

            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            dwErr = ERROR_ACCESS_DENIED;
        }
        else {

            //
            // interface and packet are using the same authentication:
            // check that the packet passes validation
            //

            switch(pic->IC_AuthenticationType) {

                case IPRIP_AUTHTYPE_SIMPLE_PASSWORD:

                    //
                    // for simple passwords, just compare the keys
                    //

                    dwErr = (DWORD)memcmp(
                                pae->IAE_AuthKey, pic->IC_AuthenticationKey,
                                IPRIP_MAX_AUTHKEY_SIZE
                                );

                    if (dwErr != 0) { dwErr = ERROR_ACCESS_DENIED; }
                    break;

                case IPRIP_AUTHTYPE_MD5:

                    //
                    // TBD: unimplemented unless required.
                    //

                    break;
            }


            //
            // advance the "first entry" pointer
            //

            if (dwErr == NO_ERROR) { ++(*ppie); }
        }
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionProcessInput
//
// This function is responsible for processing input.
// If any peer filters exist, it applies them to the routes received
// and passes the packets on to the processing functions.
//----------------------------------------------------------------------------

VOID
WorkerFunctionProcessInput(
    PVOID pContext
    ) {

    PINPUT_CONTEXT pwc;
    DWORD dwErr, dwCommand, dwPktsProcessed;
    PIPRIP_GLOBAL_CONFIG pigc;
    BOOL bListEmpty;
    
    if (!ENTER_RIP_WORKER()) { return; }


    TRACE0(ENTER, "entering WorkerFunctionProcessInput");

    dwPktsProcessed = 0;
    do {

        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);
        dwErr = DequeueRecvEntry(ig.IG_RecvQueue, &dwCommand, (PBYTE *)&pwc);
        RELEASE_LIST_LOCK(ig.IG_RecvQueue);

        if (dwErr != NO_ERROR) {

            if ( dwErr != ERROR_NO_MORE_ITEMS ) {
                TRACE1(RECEIVE, "error %d dequeueing received packet", dwErr);
            }

            break;
        }

        dwPktsProcessed++;
        
        //
        // call the processing function for this type of packet
        //

        if (dwCommand == IPRIP_REQUEST) {
            ProcessRequest(pwc);
        }
        else
        if (dwCommand == IPRIP_RESPONSE) {

            DWORD dwSource, dwFound = 0;

            dwSource = pwc->IC_InputSource.sin_addr.s_addr;


            //
            // make sure the packet is from the RIP port
            //

            if (pwc->IC_InputSource.sin_port != htons(IPRIP_PORT)) {

                LPSTR lpszAddr = INET_NTOA(dwSource);
                TRACE2(
                    RECEIVE, "invalid port in RESPONSE from %s on interface %d",
                    lpszAddr, pwc->IC_InterfaceIndex
                    );
                LOGINFO1(INVALID_PORT, lpszAddr, NO_ERROR);

                RIP_FREE(pwc);
                continue;
            }


            //
            // put the packet through the peer filters since it is a response
            //

            ACQUIRE_GLOBAL_LOCK_SHARED();

            pigc = ig.IG_Config;

            if (dwCommand == IPRIP_RESPONSE &&
                pigc->GC_PeerFilterMode != IPRIP_FILTER_DISABLED) {


                //
                // discard if this is not from a trusted peer:
                // this is so if we are including only listed peers and this peer
                // is not listed, or if we are excluding all listed peers
                // and this peer is listed
                //

                IS_PEER_IN_FILTER(pigc, dwSource, dwFound);


                if ((!dwFound &&
                     pigc->GC_PeerFilterMode == IPRIP_FILTER_INCLUDE) ||
                    (dwFound &&
                     pigc->GC_PeerFilterMode == IPRIP_FILTER_EXCLUDE)) {

                    LPSTR lpszAddr = INET_NTOA(dwSource);
                    TRACE2(
                        RECEIVE,
                        "FILTER: dropping RESPONSE from %s on interface %d",
                        lpszAddr, pwc->IC_InterfaceIndex
                        );
                    LOGINFO1(RESPONSE_FILTERED, lpszAddr, NO_ERROR);

                    RELEASE_GLOBAL_LOCK_SHARED();

                    RIP_FREE(pwc);
                    continue;
                }
            }

            RELEASE_GLOBAL_LOCK_SHARED();

            ProcessResponse(pwc);
        }

    } while(TRUE);


    //
    // Decrement the total number of workitems currently running.
    //
    
    InterlockedDecrement(&ig.IG_NumProcessInputWorkItems);

    //
    // It is possible that ProcessSocket() enqueued new packets for processing 
    // between the time we last checked for more packets and the time we 
    // decremented the number of ProcessInputWorkItems.
    // So, if this was the last workitem, we should check if there are any 
    // remaining enqueued packets to be processed. If yes, we enqueue a 
    // workitem to process those packets
    //
    
    if ( ig.IG_NumProcessInputWorkItems == 0 ) {

        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);
        bListEmpty = IsListEmpty(&ig.IG_RecvQueue->LL_Head);
        RELEASE_LIST_LOCK(ig.IG_RecvQueue);
        
        if ( !bListEmpty  ) {
            dwErr = QueueRipWorker(WorkerFunctionProcessInput, NULL);
            if (dwErr != NO_ERROR) {
                TRACE1(
                    RECEIVE,
                    "WorkerFunctionProcessInput: error %d queueing work-item",
                    dwErr
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);
            }
            else {
                InterlockedIncrement(&ig.IG_NumProcessInputWorkItems);
            }
            
        }
        
    }    

    TRACE1(
        LEAVE, 
        "leaving WorkerFunctionProcessInput. Packets processed: %d",
        dwPktsProcessed
        );
            
    LEAVE_RIP_WORKER();

    return;
}




//----------------------------------------------------------------------------
// Function:    ProcessRequest
//
// This function handles the processing of an incoming request packet.
//----------------------------------------------------------------------------

VOID
ProcessRequest(
    PVOID pContext
    ) {

    PBYTE pbuf;
    DWORD dwSize;
    CHAR szSource[20];
    PIPRIP_IF_STATS pis;
    PIPRIP_ENTRY pie;
    PIPRIP_HEADER pih;
    PIPRIP_AUTHENT_ENTRY pae;
    PIF_TABLE pTable;
    PINPUT_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    PPEER_TABLE_ENTRY ppte;
    PIPRIP_PEER_STATS pps;


    TRACE0(ENTER, "entering ProcessRequest");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();



    do { // breakout loop


        //
        // retrieve the interface on which the request arrived
        //

        pwc = (PINPUT_CONTEXT)pContext;

        pite = GetIfByIndex(pTable, pwc->IC_InterfaceIndex);

        if (pite == NULL || IF_IS_INACTIVE(pite)) {

            TRACE1(
                REQUEST, "processing request: interface %d not found",
                pwc->IC_InterfaceIndex
                );

            break;
        }



        pic = pite->ITE_Config;
        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding) + pwc->IC_AddrIndex;
        pbuf = pwc->IC_InputPacket.IP_Packet;
        pih = (PIPRIP_HEADER)pbuf;
        pie = (PIPRIP_ENTRY)(pbuf + sizeof(IPRIP_HEADER));
        pae = (PIPRIP_AUTHENT_ENTRY)pie;
        pis = NULL;
        pps = NULL;


        lstrcpy(szSource, INET_NTOA(pwc->IC_InputSource.sin_addr));


        //
        // make sure this is a packet we can respond to;
        // discard if this is a v1 packet and this interface is v2-only or
        // if this is a v2-packet and this interface is v1-only
        //

        if ((pih->IH_Version != 2 &&
             pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP2)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE2(
                REQUEST, "discarding non-v2 request on RIPv2 interface %d (%s)",
                pite->ITE_Index, lpszAddr
                );
            wsprintf(szVersion, "%d", pih->IH_Version);
            LOGINFO4(
                PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "2", 0
                );

            break;
        }
        else
        if ((pih->IH_Version != 1 &&
             pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE2(
                REQUEST, "discarding RIPv2 request on RIPv1 interface %d (%s)",
                pite->ITE_Index, lpszAddr
                );
            wsprintf(szVersion, "%d", pih->IH_Version);
            LOGINFO4(
                PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "1", 0
                );

            break;
        }



        //
        // version 2 packets call for authentication processing;
        //

        if (pih->IH_Version == 2) {

            DWORD dwErr;

            dwErr = AuthenticatePacket(pbuf, pae, pic, pis, pps, &pie);

            if (dwErr == ERROR_ACCESS_DENIED) {

                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                TRACE3(
                    REQUEST, "dropping packet from %s on interface %d (%s): authentication failed",
                    szSource, pite->ITE_Index, lpszAddr
                    );
                LOGWARN2(AUTHENTICATION_FAILED, lpszAddr, szSource, NO_ERROR);

                break;
            }
        }



        //
        // find the total remaining size of the packet
        //

        dwSize = (DWORD)(((ULONG_PTR)pbuf + pwc->IC_InputLength) - (ULONG_PTR)pie);



        //
        // see which kind of request this is
        //

        if (pie->IE_AddrFamily == ADDRFAMILY_REQUEST &&
            pie->IE_Metric == htonl(IPRIP_INFINITE) &&
            dwSize == sizeof(IPRIP_ENTRY)) {


            //
            // GENERAL REQUEST:
            //
            // send all routes on the interface
            //


            if (pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED ||
                pwc->IC_InputSource.sin_port != htons(IPRIP_PORT)) {


                TRACE3(
                    REQUEST, "responding to GENERAL REQUEST from %s on interface %d (%s)",
                    szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                    );


                //
                // send version 2 packets in response to version 2 requests
                // and send version 1 packets in response to all other requests
                //

                if (pih->IH_Version != 2) {

                    SendRoutes(
                        &pite, 1, SENDMODE_GENERAL_RESPONSE1,
                        pwc->IC_InputSource.sin_addr.s_addr, pwc->IC_AddrIndex
                        );
                }
                else {

                    SendRoutes(
                        &pite, 1, SENDMODE_GENERAL_RESPONSE2,
                        pwc->IC_InputSource.sin_addr.s_addr, pwc->IC_AddrIndex
                        );
                }

                InterlockedIncrement(&ig.IG_Stats.GS_TotalResponsesSent);
            }
        }
        else
        if (pic->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED &&
            pwc->IC_InputSource.sin_port == htons(IPRIP_PORT)) {

            //
            // SPECIFIC REQUEST:
            // We are in silent mode and the request came from port 520,
            // so we are not allowed to respond.
            //

            TRACE3(
                REQUEST, "ignoring SPECIFIC REQUEST from %s on interface %d (%s)",
                szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                );
        }
        else {

            IP_NETWORK net;
            UPDATE_BUFFER ub;
            RIP_IP_ROUTE route;
            PIPRIP_ENTRY piend;
            RTM_NET_ADDRESS rna;
            RTM_DEST_INFO rdi;
            DWORD dwErr;


            //
            // SPECIFIC REQUEST:
            // have to look up each destination in the packet
            // and fill in our metric for it if it exists in RTM
            //


            TRACE3(
                REQUEST, "responding to SPECIFIC REQUEST from %s on interface %d (%s)",
                szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                );



            //
            // acquire the binding-table lock since InitializeUpdateBuffer
            // needs to call GuessSubnetMask to generate a broadcast address
            // to which the response will be sent
            //

            ACQUIRE_BINDING_LOCK_SHARED();

            if (pih->IH_Version != 2) {
                InitializeUpdateBuffer(
                    pite, pwc->IC_AddrIndex, &ub, SENDMODE_SPECIFIC_RESPONSE1,
                    pwc->IC_InputSource.sin_addr.s_addr, IPRIP_RESPONSE
                    );
            }
            else {
                InitializeUpdateBuffer(
                    pite, pwc->IC_AddrIndex, &ub, SENDMODE_SPECIFIC_RESPONSE2,
                    pwc->IC_InputSource.sin_addr.s_addr, IPRIP_RESPONSE
                    );
            }


            //
            // we must reply to the port from which the message was sent
            //

            ub.UB_Destination = pwc->IC_InputSource;


            //
            // start the update buffer
            //

            ub.UB_StartRoutine(&ub);


            //
            // query RTM for each route entry in packet
            //

            piend = (PIPRIP_ENTRY)(pbuf + pwc->IC_InputLength);
            for ( ; pie < piend; pie++) {


                //
                // ignore unrecognized address families
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {
                    continue;
                }


                net.N_NetNumber = pie->IE_Destination;

                if (pih->IH_Version == 2 && pie->IE_SubnetMask != 0) {
                    net.N_NetMask = pie->IE_SubnetMask;
                }
                else {
                    net.N_NetMask = GuessSubnetMask(net.N_NetNumber, NULL);
                }


                //
                // lookup best route to the requested destination
                // and get the metric
                //
                
                RTM_IPV4_SET_ADDR_AND_MASK(
                    &rna, net.N_NetNumber, net.N_NetMask
                    );
                
                dwErr = RtmGetExactMatchDestination(
                            ig.IG_RtmHandle, &rna, RTM_BEST_PROTOCOL,
                            RTM_VIEW_MASK_UCAST, &rdi
                            );

                if (dwErr != NO_ERROR) {
                    pie->IE_Metric = htonl(IPRIP_INFINITE);
                }
            
                else
                {
                    //
                    // if there is no best route to this destination
                    // metric is INFINITE
                    //
                    
                    if (rdi.ViewInfo[0].Route == NULL) {
                        pie->IE_Metric = htonl(IPRIP_INFINITE);
                    }

                    else {
                    
                        dwErr = GetRouteInfo(
                                    rdi.ViewInfo[0].Route, NULL, &rdi, &route
                                    );
                                    
                        if (dwErr != NO_ERROR) {
                            pie->IE_Metric = htonl(IPRIP_INFINITE);
                        }

                        else {
                            
                            //
                            // non-RIP routes are advertised with metric 2
                            //

                            pie->IE_Metric = (route.RR_RoutingProtocol == PROTO_IP_RIP ?
                                              htonl(GETROUTEMETRIC(&route)) : htonl(2));
                        }
                    }

                    
                    //
                    // release the dest info
                    //
                    
                    dwErr = RtmReleaseDestInfo(ig.IG_RtmHandle, &rdi);

                    if (dwErr != NO_ERROR)
                    {
                        char szNet[20], szMask[20];

                        lstrcpy(szNet, INET_NTOA(route.RR_Network.N_NetNumber));
                        lstrcpy(szMask, INET_NTOA(route.RR_Network.N_NetMask));

                        TRACE3(
                            ROUTE, "error %d releasing dest %s:%s", dwErr,
                            szNet, szMask
                            );
                    }
                }


                RTM_ROUTE_FROM_IPRIP_ENTRY(&route, pie);


                ub.UB_AddRoutine(&ub, &route);
            }

            RELEASE_BINDING_LOCK_SHARED();


            //
            // send the buffer now
            //

            ub.UB_FinishRoutine(&ub);

            InterlockedIncrement(&ig.IG_Stats.GS_TotalResponsesSent);
        }

    } while(FALSE);



    RELEASE_IF_LOCK_SHARED();

    RIP_FREE(pContext);



    TRACE0(LEAVE, "leaving ProcessRequest");

}





//----------------------------------------------------------------------------
// Function:    ProcessResponse
//
// this function process an incoming IPRIP response packet
//----------------------------------------------------------------------------

VOID
ProcessResponse(
    PVOID pContext
    ) {

    DWORD dwSource;
    PBYTE pPacket;
    PIPRIP_IF_STATS pis;
    PIF_TABLE pTable;
    PIPRIP_HEADER pih;
    BOOL bTriggerUpdate;
    PIPRIP_ENTRY pie, piend;
    PIPRIP_AUTHENT_ENTRY pae;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    PINPUT_CONTEXT pwc;
    PPEER_TABLE pPeers;
    PPEER_TABLE_ENTRY ppte;
    PIPRIP_PEER_STATS pps;
    CHAR szSource[20], szNetwork[20];
    LPSTR lpszTemp = NULL;


    TRACE0(ENTER, "entering ProcessResponse");



    bTriggerUpdate = FALSE;
    pTable = ig.IG_IfTable;
    pPeers = ig.IG_PeerTable;


    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        pwc = (PINPUT_CONTEXT)pContext;



        //
        // get pointer to receiving interface
        //

        pite = GetIfByIndex(pTable, pwc->IC_InterfaceIndex);

        if (pite == NULL || IF_IS_INACTIVE(pite)) {

            TRACE1(
                RESPONSE, "processing response: interface %d not found",
                pwc->IC_InterfaceIndex
                );

            break;
        }


        ZeroMemory(szSource, sizeof(szSource));
        ZeroMemory(szNetwork, sizeof(szNetwork));

        dwSource = pwc->IC_InputSource.sin_addr.s_addr;
        lpszTemp = INET_NTOA(dwSource);
        if (lpszTemp != NULL) { lstrcpy(szSource, lpszTemp); }
        else { ZeroMemory(szSource, sizeof(szSource)); }
        

        //
        // get pointer to peer struct for sender
        //

        ACQUIRE_PEER_LOCK_SHARED();

        ppte = GetPeerByAddress(pPeers, dwSource, GETMODE_EXACT, NULL);

        if (ppte != NULL) { pps = &ppte->PTE_Stats; }
        else { pps = NULL; }

        RELEASE_PEER_LOCK_SHARED();


        pis = &pite->ITE_Stats;
        pic = pite->ITE_Config;
        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding) + pwc->IC_AddrIndex;
        pPacket = pwc->IC_InputPacket.IP_Packet;
        pih = (PIPRIP_HEADER)pPacket;
        pie = (PIPRIP_ENTRY)(pPacket + sizeof(IPRIP_HEADER));
        pae = (PIPRIP_AUTHENT_ENTRY)pie;


        //
        // make sure our configuration allows us to handle this packet
        //

        if ((pih->IH_Version != 2 &&
             pic->IC_AcceptMode == IPRIP_ACCEPT_RIP2)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);

            InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            if (lpszAddr != NULL) {
                TRACE2(
                    RESPONSE, "dropping non-v2 packet on RIPv2 interface %d (%s)",
                    pite->ITE_Index, lpszAddr
                    );
                wsprintf(szVersion, "%d", pih->IH_Version);
                LOGWARN4(
                    PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "2", 0
                    );
            }
            
            break;
        }
        else
        if ((pih->IH_Version != 1 &&
             pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);

            InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            if (lpszAddr != NULL) {
                TRACE2(
                    RESPONSE, "dropping RIPv2 packet on RIPv1 interface %d (%s)",
                    pite->ITE_Index, lpszAddr
                    );
                wsprintf(szVersion, "%d", pih->IH_Version);
                LOGWARN4(
                    PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "1", 0
                    );
            }
            break;
        }



        //
        // version 2 packets call for authentication processing;
        //

        if (pih->IH_Version == 2) {

            DWORD dwErr;

            dwErr = AuthenticatePacket(pPacket, pae, pic, pis, pps, &pie);

            if (dwErr == ERROR_ACCESS_DENIED) {

                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RESPONSE, "dropping packet from %s on interface %d (%s): authentication failed",
                        szSource, pite->ITE_Index, lpszAddr
                        );
                    LOGWARN2(AUTHENTICATION_FAILED, lpszAddr, szSource, NO_ERROR);
                }
                break;
            }
        }



        //
        // need to lock the binding table since GuessSubnetMask will be called
        // inside ProcessResponseEntry
        // need to lock the global config since EnqueueSendEntry will be called
        // inside ProcessResponseEntry
        //

        ACQUIRE_BINDING_LOCK_SHARED();

        ACQUIRE_GLOBAL_LOCK_SHARED();


        //
        // process each entry; reserved fields must be checked for non-RIPv2
        //


        piend = (PIPRIP_ENTRY)(pPacket + pwc->IC_InputLength);

        if (pih->IH_Version == 1) {

            for ( ; pie < piend; pie++) {

                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET) ||
                    pie->IE_RouteTag != 0 || pie->IE_SubnetMask != 0 ||
                    pie->IE_Nexthop != 0) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }
                    continue;
                }


                //
                // entry is alright, process it
                //

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }
        else
        if (pih->IH_Version == 2) {

            //
            // this is a RIPv2 packet, so the reserved fields in entries
            // may optionally contain information about the route;
            //


            for ( ; pie < piend; pie++) {


                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }

                    continue;
                }


                //
                // entry is alright, process it
                //

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }
        else {

            //
            // this packet's version is greater than 2, so we ignore
            // the contents of the reserved fields
            //


            for ( ; pie < piend; pie++) {


                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }

                    continue;
                }


                //
                // entry is alright, clear reserved fields and process
                //

                pie->IE_Nexthop = 0;
                pie->IE_RouteTag = 0;
                pie->IE_SubnetMask = 0;

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }

        RELEASE_GLOBAL_LOCK_SHARED();

        RELEASE_BINDING_LOCK_SHARED();


        //
        // generate a triggered update if necessary
        //

        if (bTriggerUpdate) {
            QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);
        }

    } while(FALSE);


    RELEASE_IF_LOCK_SHARED();


    RIP_FREE(pContext);


    TRACE0(LEAVE, "leaving ProcessResponse");
}




//----------------------------------------------------------------------------
// Function:    ProcessResponseEntry
//
// this function processes the given response packet entry, received
// on the given interface from the given source.
// If a triggered update is necessary, this function returns TRUE.
//----------------------------------------------------------------------------

BOOL
ProcessResponseEntry(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    DWORD dwSource,
    PIPRIP_ENTRY pIE,
    PIPRIP_PEER_STATS pPS
    ) {

    IP_NETWORK in;
    PIPRIP_IF_STATS pis;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    CHAR szSource[32];
    CHAR szNetmask[32];
    CHAR szNexthop[32];
    CHAR szNetwork[32];
    BOOL bRouteExists, bRelRoute = FALSE;
    RIP_IP_ROUTE route;
    DWORD dwNetclassMask, dwNexthop, dwRipMetric;
    DWORD dwErr = NO_ERROR, dwFlags, dwFound, dwNetwork, dwNetmask;
    LPSTR lpszAddr;

    RTM_NET_ADDRESS rna;
    PRTM_ROUTE_INFO prri = NULL;
    RTM_ROUTE_HANDLE hRtmRoute;

    

//    TRACE0(ENTER, "entering ProcessResponseEntry");


    pis = &pITE->ITE_Stats;
    pic = pITE->ITE_Config;
    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding) + dwAddrIndex;


    //
    // read destination and figure out subnet mask
    // if mask is not given in the packet
    //

    dwNetwork = pIE->IE_Destination;
    if (pIE->IE_SubnetMask == 0) {

        dwNetmask = GuessSubnetMask(dwNetwork, &dwNetclassMask);
    }
    else {

        //
        // double-check the netclass mask, to accomodate supernets
        //

        dwNetmask = pIE->IE_SubnetMask;
        dwNetclassMask = NETCLASS_MASK(dwNetwork);

        if (dwNetclassMask > dwNetmask) {
            dwNetclassMask = dwNetmask;
        }
    }

#if 1
    dwNexthop = dwSource;
#else
    // BUG 205349: using the nexthop field results in flapping
    // when more than two routers are on the same network.
    // The full fix is to distinguish between the source of the route
    // and the nexthop of the route.
    //
    // read the next-hop field;
    // if it is zero or it is not on the same subnet
    // as the receiving interface, ignore it and use the address
    // of the source as the next-hop.
    // otherwise, use the address specified in the packet
    // as the next-hop.
    //

    if (!pIE->IE_Nexthop ||
        (pIE->IE_Nexthop & paddr->IA_Netmask) !=
        (paddr->IA_Address & paddr->IA_Netmask)) { dwNexthop = dwSource; }
    else { dwNexthop = pIE->IE_Nexthop; }
#endif


    //
    // set up variables used for error and information messages
    //

    lpszAddr = INET_NTOA(dwSource);
    if (lpszAddr != NULL) { lstrcpy(szSource, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }
    
    lpszAddr = INET_NTOA(dwNetwork);
    if (lpszAddr != NULL) { lstrcpy(szNetwork, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    lpszAddr = INET_NTOA(dwNetmask);
    if (lpszAddr != NULL) { lstrcpy(szNetmask, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    lpszAddr = INET_NTOA(dwNexthop);
    if (lpszAddr != NULL) { lstrcpy(szNexthop, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    if (pPS != NULL) {
        InterlockedExchange(
            &pPS->PS_LastPeerRouteTag, (DWORD)ntohs(pIE->IE_RouteTag)
            );
    }


    do { // breakout loop


        //
        // make sure metric is in rational range
        //

        dwRipMetric = ntohl(pIE->IE_Metric);
        if (dwRipMetric > IPRIP_INFINITE) {

            TRACE4(
                RESPONSE,
                "metric == %d, ignoring route to %s via %s advertised by %s",
                dwRipMetric, szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                ROUTE_METRIC_INVALID,szNetwork, szNexthop, szSource, dwRipMetric
                );

            break;
        }


        //
        // make sure route is to valid address type
        //

        if (CLASSD_ADDR(dwNetwork) || CLASSE_ADDR(dwNetwork)) {

            TRACE3(
                RESPONSE,
                "invalid class, ignoring route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGINFO3(
                ROUTE_CLASS_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // make sure route is not to loopback address
        //

        if (IS_LOOPBACK_ADDR(dwNetwork)) {

            TRACE3(
                RESPONSE,
                "ignoring loopback route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                LOOPBACK_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // make sure route it is not a broadcast route
        // The first condition uses the netmask information received in the
        // advertisement
        // The second condition uses the netmask which is computed based 
        // on the address class
        // The third condition checks for the all 1's broadcast
        //

        if ( IS_DIRECTED_BROADCAST_ADDR(dwNetwork, dwNetmask) ||
             IS_DIRECTED_BROADCAST_ADDR(dwNetwork, dwNetclassMask) ||
             IS_LOCAL_BROADCAST_ADDR(dwNetwork) ) {

            TRACE3(
                RESPONSE,
                "ignoring broadcast route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                BROADCAST_ROUTE_INVALID, szNetwork, szNexthop, szSource, 0
                );

            break;
        }


        //
        // discard host routes if the receiving interface
        // is not configured to accept host routes
        //

        //
        // At this stage the broadcast routes have already been weeded out.
        // So it is safe to assume that 
        // if Network address width is greater than the Netmask address 
        // width, then it is a host route.
        // Or, 
        // if the dwNetmask is 255.255.255.255 then it is a host route.
        //
        if ( ((dwNetwork & ~dwNetmask) != 0) || (dwNetmask == HOSTADDR_MASK) ) {

            //
            // This is a host-route; see whether we can accept it.
            //

            if (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_HOST_ROUTES)) {

                //
                // The host route can be accepted.
                // Set the mask to all-ones to ensure that
                // the route can be added to the stack.
                //

                dwNetmask = HOSTADDR_MASK;
            }
            else {

                //
                // The host-route must be rejected.
                //

                TRACE3(
                    RESPONSE,
                    "ignoring host route to %s via %s advertised by %s",
                    szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    HOST_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                    );

                break;
            }
        }


        //
        // discard default routes if the receiving interface
        // is not configured to accept default routes
        //

        if (dwNetwork == 0 &&
            IPRIP_FLAG_IS_DISABLED(pic, ACCEPT_DEFAULT_ROUTES)) {

            TRACE3(
                RESPONSE,
                "ignoring default route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGINFO3(
                DEFAULT_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // put the route through the accept filters
        //

        if (pic->IC_AcceptFilterMode != IPRIP_FILTER_DISABLED) {

            //
            // discard the route if the receiving interface is including
            // all routes but this route is listed as an exception, or if
            // the receiving interface is excluding all routes and this
            // route is not listed as an exception
            //

            IS_ROUTE_IN_ACCEPT_FILTER(pic, dwNetwork, dwFound);

            if ((pic->IC_AcceptFilterMode == IPRIP_FILTER_INCLUDE && !dwFound)||
                (pic->IC_AcceptFilterMode == IPRIP_FILTER_EXCLUDE && dwFound)) {

                TRACE3(
                    RESPONSE,
                    "ignoring filtered route to %s via %s advertised by %s",
                    szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    ROUTE_FILTERED, szNetwork, szNexthop, szSource, NO_ERROR
                    );

                break;
            }
        }


        //
        // see if the route already exists in RTM's table
        //

        in.N_NetNumber = dwNetwork;
        in.N_NetMask = dwNetmask;
        RTM_IPV4_SET_ADDR_AND_MASK( &rna, dwNetwork, dwNetmask );

        prri = RIP_ALLOC( RTM_SIZE_OF_ROUTE_INFO( 
                            ig.IG_RtmProfile.MaxNextHopsInRoute
                            ) );

        if ( prri == NULL ) {
        
            dwErr = GetLastError();

            TRACE2(
                ANY, "ProcessResponseEntry: error %d while allocating %d bytes",
                dwErr, 
                RTM_SIZE_OF_ROUTE_INFO(ig.IG_RtmProfile.MaxNextHopsInRoute) 
                );

            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }
        
        prri-> RouteOwner = ig.IG_RtmHandle;
        
        dwErr = RtmGetExactMatchRoute(
                    ig.IG_RtmHandle, &rna, RTM_MATCH_OWNER, prri, 0,
                    RTM_VIEW_MASK_ANY, &hRtmRoute
                    );

        if ((dwErr != NO_ERROR) || (hRtmRoute == NULL)) {
            bRouteExists = FALSE;
        }

        else{
            bRelRoute = TRUE;

            dwErr = GetRouteInfo(
                        hRtmRoute, prri, NULL, &route
                        );
                        
            if (dwErr != NO_ERROR) {
                bRouteExists = FALSE;
                break;
            }

            else {
                bRouteExists = TRUE;
            }

        }


        //
        // add the cost of this interface to the metric
        //

        dwRipMetric = min(IPRIP_INFINITE, dwRipMetric + pic->IC_Metric);
        if (dwRipMetric >= IPRIP_INFINITE && !bRouteExists) {

            TRACE4(
                RESPONSE,
                "metric==%d, ignoring route to %s via %s advertised by %s",
                IPRIP_INFINITE, szNetwork, szNexthop, szSource
                );

            break;
        }


        //
        // ROUTE ADDITION/UPDATE/REMOVAL:
        //

        if (!bRouteExists) {

            //
            // NEW ROUTE:
            //
            // set up struct to pass to RTM
            //

            ZeroMemory(&route, sizeof(route));
            route.RR_RoutingProtocol = PROTO_IP_RIP;
            route.RR_Network = in;
            SETROUTEMETRIC(&route, dwRipMetric);
            route.RR_InterfaceID = pITE->ITE_Index;
            route.RR_NextHopAddress.N_NetNumber = dwNexthop;
            route.RR_NextHopAddress.N_NetMask = paddr->IA_Netmask;
            SETROUTETAG(&route, ntohs(pIE->IE_RouteTag));


            //
            // add route to RTM
            //

            COMPUTE_ROUTE_METRIC(&route);
#if ROUTE_DBG
            TRACE3(
                RESPONSE,
                "Adding route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
            );
#endif

            dwErr = AddRtmRoute(
                        ig.IG_RtmHandle, &route, NULL,
                        pic->IC_RouteExpirationInterval, 
                        pic->IC_RouteRemovalInterval,
                        TRUE
                        );
            if (dwErr != NO_ERROR) {

                TRACE4(
                    RESPONSE,
                    "error %d adding route to %s via %s advertised by %s",
                    dwErr, szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    ADD_ROUTE_FAILED_2, szNetwork, szNexthop, szSource, dwErr
                    );

                break;
            }

            InterlockedIncrement(&ig.IG_Stats.GS_SystemRouteChanges);
            LOGINFO3(
                NEW_ROUTE_LEARNT_1, szNetwork, szNexthop, szSource, NO_ERROR
                );
        }
        else {

            DWORD dwTimer = 0, dwChangeFlags = 0;
            BOOL bTriggerUpdate = FALSE, bActive = TRUE;


            //
            // EXISTING ROUTE:
            //
            // reset time-to-live, and mark route as expiring,
            // if this advertisement is from the same source
            // as the existing route, and the existing route's metric
            // is not already INFINITE; thus, if a route has been
            // advertised as unreachable, we don't reset its time-to-live
            // just because we hear an advertisement for the route
            //

            if (dwNexthop == route.RR_NextHopAddress.N_NetNumber &&
                GETROUTEMETRIC(&route) != IPRIP_INFINITE) {

                dwTimer = pic->IC_RouteExpirationInterval;

                //
                // if existing route was a summary route, make sure
                // set the validity flag before you mark it as a
                // non summary route. Fix for bug #81544
                //

                if ( GETROUTEFLAG( &route ) == ROUTEFLAG_SUMMARY ) {

                    CHAR szRouteNetwork[20], szRouteNetmask[20];
                    LPSTR lpszAddrTemp = INET_NTOA(route.RR_Network.N_NetNumber);

                    if (lpszAddrTemp != NULL) {
                        lstrcpy(szRouteNetwork, lpszAddrTemp);

                        lpszAddrTemp = INET_NTOA(route.RR_Network.N_NetMask);
                        if (lpszAddrTemp != NULL) {
                            lstrcpy(szRouteNetmask, lpszAddrTemp);

                            TRACE2(
                                RESPONSE,
                                "%s %s summary route to valid route",
                                szRouteNetwork, szRouteNetmask
                            );
                        }
                    }
                    
                    SETROUTEFLAG( &route, ~ROUTEFLAG_SUMMARY );
                }
            }


            //
            // we only need to do further processing if
            // (a) the advertised route is from the same source as
            //      the existing route and the metrics are different, or
            // (b) the advertised route has a better metric
            //

            if ((dwNexthop == route.RR_NextHopAddress.N_NetNumber &&
                 dwRipMetric != GETROUTEMETRIC(&route)) ||
                (dwRipMetric < GETROUTEMETRIC(&route))) {


                //
                // if the next-hop's differ, adopt the new next-hop
                //

                if (dwNexthop != route.RR_NextHopAddress.N_NetNumber) {

                    route.RR_NextHopAddress.N_NetNumber = dwNexthop;
                    route.RR_NextHopAddress.N_NetMask = paddr->IA_Netmask;

                    InterlockedIncrement(&ig.IG_Stats.GS_SystemRouteChanges);
                    LOGINFO2(
                        ROUTE_NEXTHOP_CHANGED, szNetwork, szNexthop, NO_ERROR
                        );
                }
                else {

                    CHAR szMetric[12];

                    wsprintf(szMetric, "%d", dwRipMetric);
                    LOGINFO3(
                        ROUTE_METRIC_CHANGED, szNetwork, szNexthop, szMetric, 0
                        );
                }


                //
                // check the metric to decide the new time-to-live
                //

                if (dwRipMetric == IPRIP_INFINITE) {

                    //
                    // Delete the route
                    //

#if ROUTE_DBG
                    TRACE2(
                        ROUTE, "Deleting route to %s:%s", szNetwork, szNetmask
                        );
#endif

                    dwTimer = 0;

                    dwErr = RtmReferenceHandles(
                                ig.IG_RtmHandle, 1, &hRtmRoute
                                );

                    if (dwErr != NO_ERROR) {
                        TRACE3(
                            ANY, "error %d referencing route to %s:%s", dwErr,
                            szNetwork, szNetmask
                            );

                        break;
                    }

                    dwErr = RtmDeleteRouteToDest(
                                ig.IG_RtmHandle, hRtmRoute,
                                &dwChangeFlags
                                );

                    if (dwErr != NO_ERROR) {
                        TRACE3(
                            ANY, "error %d deleting route to %s:%s", dwErr,
                            szNetwork, szNetmask
                            );
                    }

                    break;
                }
                
                else {

                    //
                    // set the expiration flag and use the expiration TTL
                    //

                    dwTimer = pic->IC_RouteExpirationInterval;
                }


                //
                // use the advertised metric, and set the interface ID,
                // adapter index, and route tag
                //

                SETROUTEMETRIC(&route, dwRipMetric);
                route.RR_InterfaceID = pITE->ITE_Index;
//                route.RR_FamilySpecificData.FSD_AdapterIndex =
//                                            pITE->ITE_Binding.AdapterIndex;
                SETROUTETAG(&route, ntohs(pIE->IE_RouteTag));


                //
                // always require a triggered update if we reach here
                //

                bTriggerUpdate = TRUE;
            }

            if (dwTimer != 0) {

                COMPUTE_ROUTE_METRIC(&route);

#if ROUTE_DBG

                TRACE4(
                    RESPONSE,
                    "Editing route to %s via %s advertised by %s, metric %d",
                    szNetwork, szNexthop, szSource, dwRipMetric
                );
#endif

                dwErr = AddRtmRoute(
                            ig.IG_RtmHandle, &route, NULL, dwTimer, 
                            pic-> IC_RouteRemovalInterval, TRUE
                            );

                if (dwErr != NO_ERROR) {

                    TRACE4(
                        RESPONSE,
                        "error %d adding route to %s via %s advertised by %s",
                        dwErr, szNetwork, szNexthop, szSource
                        );
                    LOGINFO3(
                        ADD_ROUTE_FAILED_2,szNetwork,szNexthop,szSource, dwErr
                        );
                }
            }
        }

    } while(FALSE);


    //
    // if some sort of error occured, increment stats appropriately
    //

    if (dwErr != NO_ERROR ) {
        InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
        if (pPS != NULL) {
            InterlockedIncrement(&pPS->PS_BadResponseEntriesFromPeer);
        }
    }


    //
    // Release the dest info structure
    //

    if (bRelRoute) {

        dwErr = RtmReleaseRoutes(ig.IG_RtmHandle,
                                    1,
                                    &hRtmRoute);
        if (dwErr != NO_ERROR) {
            TRACE2(
                ANY, "error %d releasing route for dest %s", dwErr, szNetwork
                );
        }

        dwErr = RtmReleaseRouteInfo(ig.IG_RtmHandle, prri);
        if (dwErr != NO_ERROR) {
            TRACE2(
                ANY, "error %d releasing dest %s", dwErr, szNetwork
                );
        }

    }

    if ( prri ) {
        RIP_FREE(prri);
    }

    //
    // always return FALSE.  This way no RIP route add/delete/operations
    // will set of the triggered update mechanism.  This mech. is set of
    // by route change notifications recevied from RTMv2
    //
    
    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartFullUpdate
//
// this function initiates a full-update. It checks to see if a full-update
// is already pending, and if not, it sets the full-update-pending flag and
// schedules the full-update work item. Then it sets a flag on its interface
// indicating a full-update should be generated on the interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartFullUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    DWORD dwIndex;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;


    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartFullUpdate");



    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    do { // breakout loop


        //
        // retrieve the interface on which the full-update will be sent
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(
                SEND, "starting full-update: interface %d not found", dwIndex
                );

            break;
        }



        //
        // if the interface is no longer active, do nothing
        //

        if (IF_IS_INACTIVE(pite)) {

            pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;

            break;
        }



        //
        // do nothing if a full-update is already pending
        //

        if (IF_FULL_UPDATE_PENDING(pite)) { break; }


        //
        // only do full-updates on periodic-update interfaces
        // and don't do full-updates on interfaces configured to be silent;
        //

        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            pite->ITE_Config->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED) {

            pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;

            break;
        }


        //
        // set the full update flags on the interface;
        //

        pite->ITE_Flags |= ITEFLAG_FULL_UPDATE_PENDING;



        //
        // if there is no full-update pending,
        // queue the full-update finishing function
        //

        if (!IPRIP_FULL_UPDATE_PENDING(pTable)) {

            DWORD dwRand;
            
            //
            // set the global full-update-pending flag
            //

            pTable->IT_Flags |= IPRIP_FLAG_FULL_UPDATE_PENDING;


            //
            // we need a random interval between 1 and 5 seconds
            //

            dwRand = GetTickCount();
            dwRand = RtlRandom(&dwRand);
            dwRand = 1000 + (DWORD)((double)dwRand / MAXLONG * (4.0 * 1000));

            //
            // Schedule a full update
            //

            if (!ChangeTimerQueueTimer(
                    ig.IG_TimerQueueHandle, pTable->IT_FinishFullUpdateTimer,
                    dwRand, 10000000)) {

                TRACE1(
                    SEND, "error %d setting finish full update timer",
                    GetLastError()
                    );
            }
        }

    } while(FALSE);

    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartFullUpdate");

    LEAVE_RIP_API();
}


//----------------------------------------------------------------------------
// Function:    EnqueueStartFullUpdate
//
// This function is called to enqueue the next start-full-update event
// for the given interface. The interface's state is updated as necessary.
// It assumes that the following locks have been acquired:
//  IT_RWL - shared
//  IT_CS - exclusive
//  TimerQueue lock - exclusive
//----------------------------------------------------------------------------

VOID
EnqueueStartFullUpdate(
    PIF_TABLE_ENTRY pite,
    LARGE_INTEGER qwLastFullUpdateTime
    ) {

    //
    // set last-full-update time
    //


    if (!ChangeTimerQueueTimer(
            ig.IG_TimerQueueHandle, pite->ITE_FullOrDemandUpdateTimer,
            RipSecsToMilliSecs(pite->ITE_Config->IC_FullUpdateInterval),
            10000000
            )) {

        TRACE1(
            SEND, "error %d updating start full update timer", 
            GetLastError()
            );
    
        pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;
    }
}


//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishFullUpdate
//
// This function sends a full-update on every interface which has the
// full-update pending flag set, and schedules the next full-update on each
// interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishFullUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PLIST_ENTRY ple, phead;
    DWORD dwErr, dwIndex, dwIfCount;
    LARGE_INTEGER qwCurrentTime;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishFullUpdate");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    pIfList = NULL;

    ppite = NULL;

    do {

        //
        // first count how many there are
        //

        dwIfCount = 0;
        phead = &pTable->IT_ListByAddress;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {

                pic = pite->ITE_Config;

                if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                    pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                    ++dwIfCount;
                }
            }
        }


        if (dwIfCount == 0) {

            TRACE0(SEND, "finishing full-update: no interfaces");
            break;
        }


        //
        // then make memory for the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));

        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error code %d allocating %d bytes for interface list",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
            //
            // enqueue the next full-update for each interface
            //
            RipQuerySystemTime(&qwCurrentTime);
            pTable->IT_LastUpdateTime = qwCurrentTime;
            for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
                pite=CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);
                if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {
                    pic = pite->ITE_Config;
                    if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                        EnqueueStartFullUpdate(pite, qwCurrentTime);
                    }
                }
            }
            break;
        }


        //
        // and copy the interface pointers to the memory allocated
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {

                pic = pite->ITE_Config;

                if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                    pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                    *ppite++ = pite;
                }
            }
        }



        //
        // send the updates
        //

        TRACE1(SEND, "sending full-updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_FULL_UPDATE, 0, 0);



        //
        // enqueue the next full-update for each interface
        //

        RipQuerySystemTime(&qwCurrentTime);
        pTable->IT_LastUpdateTime = qwCurrentTime;
        for (ppite = pIfList; ppite < ppitend; ppite++) {
            EnqueueStartFullUpdate(*ppite, qwCurrentTime);
        }


        //
        // free the memory allocated for the interface pointers
        //

        RIP_FREE(pIfList);

    } while(FALSE);


    //
    // clear the full-update pending flags
    //

    phead = &pTable->IT_ListByAddress;
    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_PENDING;
    }

    pTable->IT_Flags &= ~IPRIP_FLAG_FULL_UPDATE_PENDING;

    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();



    TRACE0(LEAVE, "leaving WorkerFunctionFinishFullUpdate");

    LEAVE_RIP_API();

}



//----------------------------------------------------------------------------
// Function:    FinishTriggeredUpdate
//
// This function is responsible for sending out a triggered update
// on all interfaces which have triggered updates enabled.
// No triggered updates are sent on interfaces which already have
// a full-update pending.
// Assumes interface table is locked for reading or writing,
// and update-lock (IT_CS) is held.
//----------------------------------------------------------------------------

VOID
FinishTriggeredUpdate(
    ) {

    PIF_TABLE pTable;
    PIPRIP_IF_STATS pis;
    DWORD dwErr, dwIfCount;
    PIPRIP_IF_CONFIG pic = NULL;
    PLIST_ENTRY ple, phead;
    LARGE_INTEGER qwCurrentTime;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;



    pTable = ig.IG_IfTable;

    //
    // we lock the send queue now so that no routes are added
    // until the existing ones are transmitted
    //

    ACQUIRE_LIST_LOCK(ig.IG_SendQueue);


    do { // breakout loop


        //
        // count the interfaces on which the triggered update will be sent
        //

        dwIfCount = 0;
        phead = &pTable->IT_ListByAddress;


        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) && !IF_FULL_UPDATE_PENDING(pite) &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES)) {

                ++dwIfCount;
            }
        }


        if (dwIfCount == 0) {
            TRACE0(SEND, "finishing triggered-update: no interfaces");
            break;
        }


        //
        // allocate memory to hold the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));
        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error code %d allocating %d bytes for interface list",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }



        //
        // copy the interface pointers to the allocated memory
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) && !IF_FULL_UPDATE_PENDING(pite) &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES)) {

                *ppite++ = pite;
            }
        }


        //
        // send the triggered-update routes
        //

        TRACE1(SEND, "sending triggered-updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_TRIGGERED_UPDATE, 0, 0);



        //
        // update the statistics for each interface
        //

        for (ppite = pIfList; ppite < ppitend; ppite++) {
            pis = &(*ppite)->ITE_Stats;
            InterlockedIncrement(&pis->IS_TriggeredUpdatesSent);
        }


        //
        // update the last time at which an update was sent
        //

        RipQuerySystemTime(&pTable->IT_LastUpdateTime);


        //
        // free the memory allocated for the interfaces
        //

        RIP_FREE(pIfList);

    } while (FALSE);


    //
    // make sure send-queue is empty
    //

    FlushSendQueue(ig.IG_SendQueue);

    RELEASE_LIST_LOCK(ig.IG_SendQueue);

    pTable->IT_Flags &= ~IPRIP_FLAG_TRIGGERED_UPDATE_PENDING;

    return;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartTriggeredUpdate
//
// This function checks to see if the minimum interval between triggered
// updates has elapsed, and if so, sends a triggered update. Otherwise,
// it schedules the triggered update to be sent, and sets flags to indicate
// that a triggered update is pending
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartTriggeredUpdate(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    LARGE_INTEGER qwCurrentTime, qwSoonestTriggerTime;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartTriggeredUpdate");



    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);



    //
    // if triggered update is not pending, queue a triggered update
    //

    if (!IPRIP_TRIGGERED_UPDATE_PENDING(pTable)) {


        //
        // figure out when is the soonest time a triggered update
        // can be sent, based on the configured minimum interval
        // between triggered updates (in seconds) and the last time
        // a triggered update was generated (in 100-nanosecond units)
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        qwSoonestTriggerTime.HighPart = 0;
        qwSoonestTriggerTime.LowPart =
                        ig.IG_Config->GC_MinTriggeredUpdateInterval;
        RipSecsToSystemTime(&qwSoonestTriggerTime);

        RELEASE_GLOBAL_LOCK_SHARED();


        qwSoonestTriggerTime = RtlLargeIntegerAdd(
                                    qwSoonestTriggerTime,
                                    pTable->IT_LastUpdateTime
                                    );

        RipQuerySystemTime(&qwCurrentTime);


        //
        // figure out if clock has been set backward, by comparing
        // the current time against the last update time
        //

        if (RtlLargeIntegerLessThan(
                qwCurrentTime, pTable->IT_LastUpdateTime
                )) {

            //
            // Send triggered update anyway, since there is no way
            // to figure out the if minimum time between updates has
            // elapsed
            //

            FinishTriggeredUpdate();
        }

        else if (RtlLargeIntegerLessThan(qwCurrentTime, qwSoonestTriggerTime)) {

            //
            // must defer the triggered update
            //
            qwSoonestTriggerTime = RtlLargeIntegerSubtract(
                                        qwSoonestTriggerTime, qwCurrentTime
                                        );

            RipSystemTimeToMillisecs(&qwSoonestTriggerTime);

            if (!ChangeTimerQueueTimer(
                    ig.IG_TimerQueueHandle,
                    pTable->IT_FinishTriggeredUpdateTimer,
                    qwSoonestTriggerTime.LowPart, 10000000
                    )) {

                TRACE1(
                    SEND, "error %d updating finish update timer",
                    GetLastError()
                    );
            }

            else {
                pTable->IT_Flags |= IPRIP_FLAG_TRIGGERED_UPDATE_PENDING;
            }
        }
        else {

            //
            // the minimum time between triggered updates has elapsed,
            // so send the triggered update now
            //

            FinishTriggeredUpdate();
        }
    }


    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartTriggeredUpdate");

    LEAVE_RIP_WORKER();
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishTriggeredUpdate
//
// This function generates a triggered update on all interfaces which
// do not have triggered updates disabled.
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishTriggeredUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishTriggeredUpdate");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    FinishTriggeredUpdate();


    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionFinishTriggeredUpdate");

    LEAVE_RIP_API();
    return;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartDemandUpdate
//
// This function initiates a demand-update on the speficied interface,
// sending a general request on the interface. It then schedules a work-item
// to report back to Router Manager when the update is done
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartDemandUpdate(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    RIP_IP_ROUTE route;
    PUPDATE_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    DWORD dwErr, dwIndex;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartDemandUpdate");



    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        //
        // retrieve the interface on which to perform the demand update
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(SEND, "demand-update: interface %d not found", dwIndex);
            break;
        }


        //
        // make sure interface is active and has demand-updates enabled
        //

        if (IF_IS_INACTIVE(pite)) {
            TRACE1(SEND, "demand-update: interface %d not active", dwIndex);
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }
        else
        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_DEMAND) {
            TRACE1(SEND, "demand-updates disabled on interface %d ", dwIndex);
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // setup the update context
        //

        pwc = RIP_ALLOC(sizeof(UPDATE_CONTEXT));

        if (pwc == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error %d allocating %d bytes",
                dwErr, sizeof(UPDATE_CONTEXT)
                );
            EnqueueDemandUpdateMessage(dwIndex, dwErr);
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        pwc->UC_InterfaceIndex = dwIndex;
        pwc->UC_RetryCount = 1;
        pwc->UC_RouteCount = 0;


        //
        // Create a timer for the demand update checks
        //
        
        if (!CreateTimerQueueTimer(
                &pite->ITE_FullOrDemandUpdateTimer,
                ig.IG_TimerQueueHandle,
                WorkerFunctionFinishDemandUpdate, (PVOID)pwc,
                5000, 5000, 0
                )) {
            EnqueueDemandUpdateMessage(dwIndex, GetLastError());
        }

        
        //
        // request routing tables from neighbors
        //

        SendGeneralRequest(pite);

    } while (FALSE);


    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartDemandUpdate");

    LEAVE_RIP_WORKER();
}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishDemandUpdate
//
// This function queues a message informing the Router Manager that
// the demand-update requested is complete
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishDemandUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;
    PUPDATE_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    DWORD dwErr, dwIndex, dwRouteCount;

    if (pContext == NULL) { return; }

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishDemandUpdate");


    //
    // get the update context
    //

    pwc = (PUPDATE_CONTEXT)pContext;
    dwIndex = pwc->UC_InterfaceIndex;

    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();


    do {

        //
        // retrieve the interface being updated
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // report failure if the interface is no longer active
        //

        if (!IF_IS_ACTIVE(pite)) {
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // get a count of the routes now on the interface
        //

        dwRouteCount = CountInterfaceRoutes(dwIndex);



        //
        // if there are still no routes, send another request
        // unless we have sent the maximum number of requests
        //

        if (dwRouteCount == 0 && ++pwc->UC_RetryCount < MAX_UPDATE_REQUESTS) {

            SendGeneralRequest(pite);

            break;
        }



        //
        // if the number of routes has not changed in the last 5 seconds,
        // tell the router manager that the update is complete;
        // otherwise, update the route count and enqueue another check
        //

        if (pwc->UC_RouteCount == dwRouteCount) {

            EnqueueDemandUpdateMessage(dwIndex, NO_ERROR);
            RIP_FREE(pwc);
            
            if (!DeleteTimerQueueTimer(
                    ig.IG_TimerQueueHandle, pite->ITE_FullOrDemandUpdateTimer,
                    NULL)) {

                TRACE1(
                    SEND, "error %d deleting demand update timer", 
                    GetLastError()
                    );
            }

            pite->ITE_FullOrDemandUpdateTimer = NULL;
        }
        else {

            pwc->UC_RouteCount = dwRouteCount;
        }


    } while(FALSE);


    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionFinishDemandUpdate");

    LEAVE_RIP_API();
}



//----------------------------------------------------------------------------
// Function:    CountInterfaceRoutes
//
//  Returns a count of the RIP routes associated with the specified interface
//----------------------------------------------------------------------------

DWORD
CountInterfaceRoutes(
    DWORD dwInterfaceIndex
    ) {

    HANDLE          hRouteEnum;
    PHANDLE         phRoutes = NULL;
    DWORD           dwHandles, dwFlags, i, dwErr, dwCount = 0;


    dwErr = RtmCreateRouteEnum(
                    ig.IG_RtmHandle, NULL, RTM_VIEW_MASK_UCAST, 
                    RTM_ENUM_OWN_ROUTES, NULL, RTM_MATCH_INTERFACE, 
                    NULL, dwInterfaceIndex, &hRouteEnum
                    );

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "CountInterfaceRoutes : error %d creating enum handle",
            dwErr
            );
        
        return 0;
    }


    //
    // allocate handle array large enough to hold max handles in an
    // enum
    //
        
    phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE));

    if ( phRoutes == NULL ) {

        dwErr = GetLastError();

        TRACE2(
            ANY, "CountInterfaceRoutes: error %d while allocating %d bytes"
            " to hold max handles in an enum",
            dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );

        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return 0;
    }


    do
    {
        dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
        
        dwErr = RtmGetEnumRoutes(
                    ig.IG_RtmHandle, hRouteEnum, &dwHandles, phRoutes
                    );

        for ( i = 0; i < dwHandles; i++ )
        {
            //
            // Release all route handles
            //
            
            dwErr = RtmReleaseRoutes(ig.IG_RtmHandle, 1, &phRoutes[i]);

            if (dwErr != NO_ERROR) {
                TRACE1(
                    ANY, "CountInterfaceRoutes : error %d releasing routes",
                    dwErr
                    );
            }
        }

        dwCount += dwHandles;
        
    } while (dwErr == NO_ERROR);


    //
    // close enum handle
    //
    
    dwErr = RtmDeleteEnumHandle(ig.IG_RtmHandle, hRouteEnum);

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "CountInterfaceRoutes : error %d closing enum handle", dwErr
            );
    }

    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    return dwCount;
}




//----------------------------------------------------------------------------
// Function:    EnqueueDemandUpdateMessage
//
// This function posts a message to IPRIP's Router Manager event queue
// indicating the status of a demand update request.
//----------------------------------------------------------------------------

VOID
EnqueueDemandUpdateMessage(
    DWORD dwInterfaceIndex,
    DWORD dwError
    ) {

    MESSAGE msg;
    PUPDATE_COMPLETE_MESSAGE pmsg;


    //
    // set up an UPDATE_COMPLETE message
    //

    pmsg = &msg.UpdateCompleteMessage;
    pmsg->UpdateType = RF_DEMAND_UPDATE_ROUTES;
    pmsg->UpdateStatus = dwError;
    pmsg->InterfaceIndex = dwInterfaceIndex;

    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
    EnqueueEvent(ig.IG_EventQueue, UPDATE_COMPLETE, msg);
    SetEvent(ig.IG_EventEvent);
    RELEASE_LIST_LOCK(ig.IG_EventQueue);
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionProcessRtmMessage
//
// This function handles messages from RTM about new or expired routes.
//----------------------------------------------------------------------------

VOID
WorkerFunctionProcessRtmMessage(
    PVOID pContext
    ) {

    DWORD dwErr, dwFlags, dwNumDests, dwSize;
    PIF_TABLE pTable;
    BOOL bTriggerUpdate, bDone = FALSE;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;

    RIP_IP_ROUTE route;
    PRTM_DEST_INFO prdi;
    CHAR szNetwork[32], szNexthop[32];
    

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionProcessRtmMessage");


    pTable = ig.IG_IfTable;


    //
    // allocate a buffer for retrieving the dest info
    //
    
    dwSize = RTM_SIZE_OF_DEST_INFO( ig.IG_RtmProfile.NumberOfViews );

    prdi = (PRTM_DEST_INFO) RIP_ALLOC( dwSize );

    if ( prdi == NULL ) {
    
        dwErr = GetLastError();
        TRACE2(
            ROUTE, "error %d allocating %d bytes for dest info buffers",
            dwErr, dwSize
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);
        LEAVE_RIP_WORKER();
        return;
    }


    //
    // Acquire locks
    //
    
    ACQUIRE_IF_LOCK_SHARED();

    ACQUIRE_GLOBAL_LOCK_SHARED();

    ACQUIRE_LIST_LOCK(ig.IG_SendQueue);


    bTriggerUpdate = FALSE;


    //
    // loop dequeueing messages until RTM says there are no more left
    //

    while (!bDone) {

        //
        // Retrieve route changes
        //

        dwNumDests = 1;

        dwErr = RtmGetChangedDests(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle, &dwNumDests, prdi
                    );

        if ((dwErr != NO_ERROR) && (dwErr != ERROR_NO_MORE_ITEMS)) {
        
            TRACE1(ROUTE, "error %d retrieving changed dests", dwErr);
            break;
        }


        //
        // check if there are any more changed dests
        //
        
        if (dwErr == ERROR_NO_MORE_ITEMS) { bDone = TRUE; }

        if (dwNumDests < 1) { break; }


        if ((prdi-> ViewInfo[0].HoldRoute != NULL) ||
            (prdi-> ViewInfo[0].Route != NULL)) {
            
            ZeroMemory(&route, sizeof(RIP_IP_ROUTE));

            //
            // For each route change check if you have a held down route.
            // if so get the info for the held down route since that is
            // the one to be advertized.
            //
            //  N.B. RIP summary routes are not advertized via the route
            //       change processing mechanism.
            //

            dwErr = GetRouteInfo(
                        (prdi-> ViewInfo[0].HoldRoute != NULL) ?
                        prdi-> ViewInfo[0].HoldRoute : prdi-> ViewInfo[0].Route,
                        NULL, prdi, &route
                        );
                        
            if (dwErr == NO_ERROR) {

                //
                // do not advertize RIP summary routes
                //

                if ((route.RR_RoutingProtocol != PROTO_IP_RIP) ||
                    (GETROUTEFLAG(&route) & ROUTEFLAG_SUMMARY) !=
                        ROUTEFLAG_SUMMARY) {
                        
                    //
                    // held down routes are advertized with INFINITE metric
                    //
                    
                    if (prdi-> ViewInfo[0].HoldRoute != NULL) {
                        SETROUTEMETRIC(&route, IPRIP_INFINITE);
                    }
                    
                    EnqueueSendEntry( ig.IG_SendQueue, &route );
                    bTriggerUpdate = TRUE;
                }
#if ROUTE_DBG
                else if (route.RR_RoutingProtocol == PROTO_IP_RIP) {

                    TRACE0(ROUTE, "Ignoring route change caused by RIP summary route");
                }
#endif
            }
        }

        //
        // release the destination info
        //

        dwErr = RtmReleaseChangedDests(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle, 1, prdi
                    );

        if (dwErr != NO_ERROR) {
            TRACE1(ANY, "error %d releasing changed dests", dwErr);
        }
    }


    if (prdi) { RIP_FREE(prdi); }

    
    //
    // queue a triggered update now if necessary
    //

    if (bTriggerUpdate) {
        QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);
    }


    RELEASE_LIST_LOCK(ig.IG_SendQueue);

    RELEASE_GLOBAL_LOCK_SHARED();

    RELEASE_IF_LOCK_SHARED();



    TRACE0(LEAVE, "leaving WorkerFunctionProcessRtmMessage");

    LEAVE_RIP_WORKER();

}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionActivateInterface
//
// This function sends out the initial general request on an interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionActivateInterface(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    UPDATE_BUFFER ub;
    PIPRIP_ENTRY pEntry;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    SOCKADDR_IN sinDest;
    DWORD i, dwErr, dwIndex;
    LARGE_INTEGER qwCurrentTime;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionActivateInterface");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        //
        // retrieve the interface to be activated
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(IF, "activating interface: interface %d not found", dwIndex);
            break;
        }

        pic = pite->ITE_Config;
        pib = pite->ITE_Binding;

        //
        // If binding is NULL, assume that interface has been
        // deativated.  This check has been introduced as a consequence
        // of WorkerFunctionDeactivateInterface being made synchronous.
        // As a result, by the time this function is invoked an interface
        // that was in the process of being activated could have been
        // deactivated.
        //
        // The change to synchronous deactivate was made
        // to accomadate demand dial interfaces that could get connected
        // and disconnected immeditately, causing the above behaviour
        //

        if ( pib == NULL ) {

            TRACE1( IF, "activating interface %d: Binding not found", dwIndex );
            break;
        }

        paddr = IPRIP_IF_ADDRESS_TABLE(pib);


        //
        // request input notification on the interface's sockets
        //

        if (pic->IC_AcceptMode != IPRIP_ACCEPT_DISABLED) {

            for (i = 0; i < pib->IB_AddrCount; i++) {

                dwErr = WSAEventSelect(
                            pite->ITE_Sockets[i], ig.IG_IpripInputEvent,
                            FD_READ
                            );

                if (dwErr != NO_ERROR) {

                    LPSTR lpszAddr = INET_NTOA(paddr[i].IA_Address);
                    if (lpszAddr != NULL) {
                        TRACE3(
                            IF, "WSAEventSelect returned %d for interface %d (%s)",
                            dwErr, dwIndex, lpszAddr
                            );
                        LOGERR1(EVENTSELECT_FAILED, lpszAddr, 0);
                    }
                }
            }
        }


        //
        // if interface is silent or interface does demand-udpates,
        // no initial request is sent on it
        //

        if (pic->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED) {

            //
            // configured to be silent, do nothing
            //

            break;
        }


        //
        // send general request to neighboring routers
        //

        SendGeneralRequest(pite);


        //
        // create timer for periodic updates, if required.
        //
        
        EnterCriticalSection(&pTable->IT_CS);
        
        if (pite->ITE_FullOrDemandUpdateTimer == NULL) { 

            if (!CreateTimerQueueTimer(
                        &pite->ITE_FullOrDemandUpdateTimer,
                        ig.IG_TimerQueueHandle, 
                        WorkerFunctionStartFullUpdate, pContext,
                        RipSecsToMilliSecs(pic->IC_FullUpdateInterval),
                        10000000, 0
                        )) {
                dwErr = GetLastError();
                TRACE1(IF, "error %d returned by CreateTimerQueueTimer", dwErr);
                break;
            }
            else {
                pite->ITE_Flags |= ITEFLAG_FULL_UPDATE_INQUEUE;
            }
        }
        else {
            RipQuerySystemTime(&qwCurrentTime);
            EnqueueStartFullUpdate(pite, qwCurrentTime);
        }

        LeaveCriticalSection(&pTable->IT_CS);
        
    } while(FALSE);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionActivateInterface");

    LEAVE_RIP_WORKER();

}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionDeactivateInterface
//
// This function generates shutdown update on the given interface, and
// removes from RTM all RIP-learnt routes associated with the interface.
// Assumes the interface table has already been exclusively locked
//----------------------------------------------------------------------------

VOID
WorkerFunctionDeactivateInterface(
    PVOID pContext
    ) {

    UPDATE_BUFFER ub;
    PIF_TABLE pTable;
    RIP_IP_ROUTE route;
    HANDLE hEnumerator;
    PHANDLE phRoutes = NULL;
    BOOL bTriggerUpdate;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwFlags, dwIndex, dwHandles;


    TRACE0(ENTER, "entering WorkerFunctionDeactivateInterface");


    dwIndex = PtrToUlong(pContext);

    bTriggerUpdate = FALSE;
    pTable = ig.IG_IfTable;


    do { // breakout loop


        //
        // find the interface to be deactivated
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {

            TRACE1(
                IF, "de-activating interface: interface %d not found", dwIndex
                );

            break;
        }


        pib = pite->ITE_Binding;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);


        //
        // if graceful shutdown is on and demand-update is off,
        // send the graceful-shutdown update
        //

        if (pite->ITE_Config->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
            IPRIP_FLAG_IS_ENABLED(pite->ITE_Config, GRACEFUL_SHUTDOWN)) {

            //
            // transmit all RTM routes with non-infinite metrics set to 15
            //

            if (pite->ITE_Config->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {

                SendRoutes(&pite, 1, SENDMODE_SHUTDOWN_UPDATE, 0, 0);
            }
        }



        //
        // this function is called either because an interface
        // that was active (bound and enabled) is either no longer enabled
        // or is no longer bound. We complete the deactivation differently
        // depending on which of these is the case
        //

        if (!IF_IS_BOUND(pite) ) {

            //
            // the interface was bound, but isn't anymore.
            // close the socket for the interface
            //

            DeleteIfSocket(pite);

            ACQUIRE_BINDING_LOCK_EXCLUSIVE();

            dwErr = DeleteBindingEntry(ig.IG_BindingTable, pite->ITE_Binding);

            RELEASE_BINDING_LOCK_EXCLUSIVE();

            RIP_FREE(pite->ITE_Binding);
            pite->ITE_Binding = NULL;
        }
        else {

            //
            // the interface was enabled, but isn't anymore.
            // tell WinSock to stop notifying us of input
            //

            for (i = 0; i < pib->IB_AddrCount; i++) {
                WSAEventSelect(pite->ITE_Sockets[i], ig.IG_IpripInputEvent, 0);
            }
        }

        //
        // if full updates pending/queued on this interface, cancel them.
        //

        pite-> ITE_Flags &= ~ITEFLAG_FULL_UPDATE_PENDING;
        pite-> ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;


        //
        // if we're announcing routes over this interface,
        // delete the periodic announcement timer
        //
        
        if (pite->ITE_Config->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
            pite->ITE_Config->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {

            if (!DeleteTimerQueueTimer(
                    ig.IG_TimerQueueHandle, 
                    pite->ITE_FullOrDemandUpdateTimer,
                    NULL)) {

                TRACE1(
                    ANY, "error %d deleting update timer", GetLastError()
                    );
            }

            pite->ITE_FullOrDemandUpdateTimer = NULL;
        }
        

        //
        // we're done if graceful shutdown is disabled
        // or if this is a demand-update interface
        //

        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            IPRIP_FLAG_IS_DISABLED(pite->ITE_Config, GRACEFUL_SHUTDOWN)) {
            break;
        }


        //
        // move the routes learnt on this interface to the send-queue
        // and set their metrics to 16
        //

        dwErr = RtmCreateRouteEnum(
                    ig.IG_RtmHandle, NULL, RTM_VIEW_MASK_ANY, 
                    RTM_ENUM_OWN_ROUTES, NULL, RTM_MATCH_INTERFACE, NULL, 
                    pite->ITE_Index, &hEnumerator
                    );

        if (dwErr != NO_ERROR) {
            TRACE1(
                ANY, "WorkerFunctionDeactivateInterface: error %d creating"
                " enum handle", dwErr
                );
            
            break;
        }


        //
        // allocate handle array large enough to hold max handles in an
        // enum
        //
        
        phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum*sizeof(HANDLE));

        if ( phRoutes == NULL ) {

            dwErr = GetLastError();

            TRACE2(
                ANY, "WorkerFunctionDeactivateInterface: error %d "
                "while allocating %d bytes to hold max handles in an enum",
                dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        //
        // find all RIP routes learnt on this interface
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        ACQUIRE_LIST_LOCK(ig.IG_SendQueue);

        do {
        
            dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
            
            dwErr = RtmGetEnumRoutes(
                        ig.IG_RtmHandle, hEnumerator, &dwHandles, phRoutes
                        );

            for ( i = 0; i < dwHandles; i++ ) {
            
                if (GetRouteInfo(
                        phRoutes[i], NULL, NULL, &route
                        ) == NO_ERROR) {
                    //
                    // set the route's metric to infinite
                    //

                    SETROUTEMETRIC(&route, IPRIP_INFINITE);


                    //
                    // add the route to the send-queue
                    //

                    EnqueueSendEntry(ig.IG_SendQueue, &route);
                    bTriggerUpdate = TRUE;
                }
                            

                if (RtmDeleteRouteToDest(
                        ig.IG_RtmHandle, phRoutes[i], &dwFlags
                        ) != NO_ERROR) {
                        
                    //
                    // If delete is successful, this is automatic
                    //
                    
                    if (RtmReleaseRoutes(
                            ig.IG_RtmHandle, 1, &phRoutes[i]
                            ) != NO_ERROR) {
                            
                        TRACE1(
                            ANY, "WorkerFunctionDeactivateInterface: "
                            "error %d releasing route handles", dwErr
                            );
                    }
                }
            }
            
        } while ( dwErr == NO_ERROR );


        //
        // close the enm handle
        //
        
        dwErr = RtmDeleteEnumHandle(ig.IG_RtmHandle, hEnumerator);

        if (dwErr != NO_ERROR) {
            TRACE1(
                ANY, "WorkerFunctionDeactivateInterface: error %d "
                "closing enum handle", dwErr
                );
        }


        RELEASE_LIST_LOCK(ig.IG_SendQueue);

        RELEASE_GLOBAL_LOCK_SHARED();


        //
        // queue a triggered-update work-item for the other active interfaces
        //

        if (bTriggerUpdate) {

            dwErr = QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);

            if (dwErr != NO_ERROR) {

                TRACE1(
                    IF, "error %d queueing triggered update work-item", dwErr
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);
            }
        }

    } while(FALSE);


    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    TRACE0(LEAVE, "leaving WorkerFunctionDeactivateInterface");

}

//----------------------------------------------------------------------------
// Function:    FreeLibraryThread
//
// This thread is spawned by WorkerFunctionFinishStopProtocol to FreeLibrary
// iprip2. This call to FreeLibrary should bring the ref on iprip2.dll to 0 and 
// thus unload it. The FreeLibraryAndExitThread cannot be called from a worker 
// thread, so this seperate thread is started to make the call.
//----------------------------------------------------------------------------


DWORD
FreeLibraryThread(
    PVOID pContext
    )
{
    //
    // Give time to the WorkerFunctionFinishStopProtocol function to complete
    //
    Sleep(10);

    if (ig.IG_DllHandle) {
        FreeLibraryAndExitThread(ig.IG_DllHandle, 0);
    }

    return 0;
}


//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishStopProtocol
//
// This function is called when IPRIP is stopping; it sends out shutdown
// updates on all interfaces and removes all RIP routes from RTM
//----------------------------------------------------------------------------
VOID
WorkerFunctionFinishStopProtocol(
    PVOID pContext
    ) {

    MESSAGE msg = {0, 0, 0};
    LONG lThreadCount;
    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PLIST_ENTRY ple, phead;
    DWORD dwErr, dwIfCount;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;
    HANDLE WaitHandle;

    TRACE0(ENTER, "entering WorkerFunctionFinishStopProtocol");



    //
    // NOTE: since this is called while the router is stopping,
    // there is no need for it to use ENTER_RIP_WORKER()/LEAVE_RIP_WORKER()
    //

    lThreadCount = PtrToUlong(pContext);


    //
    // waits for input thread and timer thread to stop,
    // and also waits for API callers and worker functions to finish
    //

    while (lThreadCount-- > 0) {
        WaitForSingleObject(ig.IG_ActivitySemaphore, INFINITE);
    }



    //
    // deregister the events set with NtdllWait thread and delete the
    // timer queue registered with NtdllTimer thread.
    // These calls should not be inside IG_CS lock and must be done
    // after all the threads have stopped.
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_IpripInputEventHandle, NULL) ;
    if (WaitHandle) {
        UnregisterWaitEx( WaitHandle, INVALID_HANDLE_VALUE ) ;
    }

    
    if (ig.IG_TimerQueueHandle) {
        DeleteTimerQueueEx(ig.IG_TimerQueueHandle, INVALID_HANDLE_VALUE);
    }


    //
    // we enter the critical section and leave, just to be sure that
    // all threads have quit their calls to LeaveRipWorker()
    //

    EnterCriticalSection(&ig.IG_CS);
    LeaveCriticalSection(&ig.IG_CS);


    TRACE0(STOP, "all threads stopped, now performing graceful shutdown");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    //
    // send out graceful shutdown updates on all active interfaces
    //

    do {


        phead = &pTable->IT_ListByAddress;


        //
        // first count the interfaces on which graceful shutdown is enabled
        //

        dwIfCount = 0;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) &&
                pite->ITE_Binding &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN)) {

                ++dwIfCount;
            }
        }


        if (dwIfCount == 0) { break; }


        //
        // allocate space for the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));

        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                STOP, "shutdown: error %d allocating %d bytes for interfaces",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the interface pointers into the space allocated
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) &&
                pite->ITE_Binding &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN)) {

                *ppite++ = pite;
            }
        }


        //
        // pass the array of interfaces to SendRoutes
        //

        TRACE1(STOP, "sending shutdown updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_SHUTDOWN_UPDATE, 0, 0);



        //
        // free the array of interfaces
        //

        RIP_FREE(pIfList);

    } while(FALSE);


    RELEASE_IF_LOCK_EXCLUSIVE();


    //
    // delete all IPRIP routes from RTM
    //

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) 
    {
        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        BlockDeleteRoutesOnInterface(
            ig.IG_RtmHandle, pite-> ITE_Index
            );
    }


    //
    // cleanup the global structures
    //

    TRACE0(STOP, "IPRIP is cleaning up resources");


    ProtocolCleanup(TRUE);

    LOGINFO0(IPRIP_STOPPED, NO_ERROR);


    //
    // let the Router Manager know that we are done
    //

    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
    EnqueueEvent(ig.IG_EventQueue, ROUTER_STOPPED, msg);
    SetEvent(ig.IG_EventEvent);
    RELEASE_LIST_LOCK(ig.IG_EventQueue);

    if (ig.IG_DllHandle) {
        HANDLE hThread;
        hThread = CreateThread(0,0,FreeLibraryThread, NULL, 0, NULL);
        if (hThread != NULL)
            CloseHandle(hThread);
    }

    return;

}


VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintPeerStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );

#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}



VOID
WorkerFunctionMibDisplay(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    COORD c;
    HANDLE hConsole = NULL;
    DWORD dwErr, dwTraceID;
    DWORD dwExactSize, dwInSize, dwOutSize;
    IPRIP_MIB_GET_INPUT_DATA imgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;
    LARGE_INTEGER qwNextDisplay, qwCurrentTime;

    if (!ENTER_RIP_API()) { return; }


    TraceGetConsole(ig.IG_MibTraceID, &hConsole);


    if (hConsole == NULL) {
        LEAVE_RIP_WORKER();
        return;
    }



    ClearScreen(hConsole);

    c.X = c.Y = 0;


    dwInSize = sizeof(imgid);
    imgid.IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
    pimgod = NULL;


    //
    // get size of the first entry in the first table
    //

    dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);


    if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

        //
        // allocate a buffer, and set its size
        //

        pimgod = RIP_ALLOC(dwOutSize);


        //
        // perform the query again
        //

        dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);

    }



    //
    // now that we have the first element in the first table,
    // we can enumerate the elements in the remaining tables using GetNext
    //

    while (dwErr == NO_ERROR) {


        //
        // print the current element and set up the query
        // for the next element (the display functions  change imgid
        // so that it can be used to query the next element)
        //

        switch(pimgod->IMGOD_TypeID) {
            case IPRIP_GLOBAL_STATS_ID:
                PrintGlobalStats(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_GLOBAL_CONFIG_ID:
                PrintGlobalConfig(hConsole,&c, &imgid, pimgod);
                break;

            case IPRIP_IF_CONFIG_ID:
                PrintIfConfig(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_IF_BINDING_ID:
                PrintIfBinding(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_IF_STATS_ID:
                PrintIfStats(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_PEER_STATS_ID:
                PrintPeerStats(hConsole, &c, &imgid, pimgod);
                break;

            default:
                break;
        }


        RIP_FREE(pimgod);
        pimgod = NULL;
        dwOutSize = 0;


        //
        // move to the next line on the console
        //

        ++c.Y;


        //
        // query the next MIB element
        //

        dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);



        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            //
            // allocate a new buffer, and set its size
            //

            pimgod = RIP_ALLOC(dwOutSize);

            //
            // perform the query again
            //

            dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);

        }
    }


    //
    // if memory was allocated, free it now
    //

    if (pimgod != NULL) { RIP_FREE(pimgod); }

    LEAVE_RIP_API();
}



#define WriteLine(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200];                                                          \
    _dw = StringCchPrintf(_sz, 200, fmt, arg);                              \
    if ( SUCCEEDED(_dw) ) {                                                 \
        WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);             \
        ++(c).Y;                                                            \
    }                                                                       \
}



VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_GLOBAL_STATS pgs;

    pgs = (PIPRIP_GLOBAL_STATS)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole, *pc, "System Route Changes:             %d",
        pgs->GS_SystemRouteChanges
        );
    WriteLine(
        hConsole, *pc, "Total Responses Sent:             %d",
        pgs->GS_TotalResponsesSent
        );

    pimgid->IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
}



VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_GLOBAL_CONFIG pgc;
    PDWORD pdwPeer, pdwPeerEnd;
    CHAR szFilter[32];
    LPSTR lpszAddr = NULL;

    pgc = (PIPRIP_GLOBAL_CONFIG)pimgod->IMGOD_Buffer;

    switch (pgc->GC_PeerFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szFilter, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szFilter, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szFilter, "exclude all"); break;
        default:
            lstrcpy(szFilter, "invalid"); break;
    }

    WriteLine(
        hConsole, *pc, "Logging Level:                    %d",
        pgc->GC_LoggingLevel
        );
    WriteLine(
        hConsole, *pc, "Max Receive Queue Size:           %d bytes",
        pgc->GC_MaxRecvQueueSize
        );
    WriteLine(
        hConsole, *pc, "Max Send Queue Size:              %d bytes",
        pgc->GC_MaxSendQueueSize
        );
    WriteLine(
        hConsole, *pc, "Min Triggered Update interval:    %d seconds",
        pgc->GC_MinTriggeredUpdateInterval
        );
    WriteLine(
        hConsole, *pc, "Peer Filter Mode:                 %s",
        szFilter
        );

    WriteLine(
        hConsole, *pc, "Peer Filter Count:                %d",
        pgc->GC_PeerFilterCount
        );

    pdwPeer = IPRIP_GLOBAL_PEER_FILTER_TABLE(pgc);
    pdwPeerEnd = pdwPeer + pgc->GC_PeerFilterCount;
    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {
        lpszAddr = INET_NTOA(*pdwPeer);
        if (lpszAddr != NULL) {
            WriteLine(
                hConsole, *pc, "                                  %s",
                lpszAddr       
                );
        }
    }

    pimgid->IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
}



VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_IF_STATS pis;

    pis = (PIPRIP_IF_STATS)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Send Failures:                    %d",
        pis->IS_SendFailures
        );
    WriteLine(
        hConsole, *pc, "Receive  Failures:                %d",
        pis->IS_ReceiveFailures
        );
    WriteLine(
        hConsole, *pc, "Requests Sent:                    %d",
        pis->IS_RequestsSent
        );
    WriteLine(
        hConsole, *pc, "Requests Received:                %d",
        pis->IS_RequestsReceived
        );
    WriteLine(
        hConsole, *pc, "Responses Sent:                   %d",
        pis->IS_ResponsesSent
        );
    WriteLine(
        hConsole, *pc, "Responses Received:               %d",
        pis->IS_ResponsesReceived
        );
    WriteLine(
        hConsole, *pc, "Bad Response Packets Received:    %d",
        pis->IS_BadResponsePacketsReceived
        );
    WriteLine(
        hConsole, *pc, "Bad Response Entries Received:    %d",
        pis->IS_BadResponseEntriesReceived
        );
    WriteLine(
        hConsole, *pc, "Triggered Updates Sent:           %d",
        pis->IS_TriggeredUpdatesSent
        );

    pimgid->IMGID_TypeID = IPRIP_IF_STATS_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}



VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_IF_CONFIG pic;
    PDWORD pdwPeer, pdwPeerEnd;
    PIPRIP_ROUTE_FILTER pfilt, pfiltend;
    CHAR szAuthType[24], szAuthKey[64];
    CHAR szPeer[20], szAccept[20], szAnnounce[20], szFilter[64];
    CHAR szUpdateMode[24], szAcceptMode[24], szAnnounceMode[24];
    LPSTR lpszAddr = NULL;

    pic = (PIPRIP_IF_CONFIG)pimgod->IMGOD_Buffer;

    switch (pic->IC_UpdateMode) {
        case IPRIP_UPDATE_PERIODIC:
            lstrcpy(szUpdateMode, "periodic");
            break;
        case IPRIP_UPDATE_DEMAND:
            lstrcpy(szUpdateMode, "demand");
            break;
        default:
            lstrcpy(szUpdateMode, "invalid");
            break;
    }

    switch (pic->IC_AcceptMode) {
        case IPRIP_ACCEPT_DISABLED:
            lstrcpy(szAcceptMode, "disabled");
            break;
        case IPRIP_ACCEPT_RIP1:
            lstrcpy(szAcceptMode, "RIP1");
            break;
        case IPRIP_ACCEPT_RIP1_COMPAT:
            lstrcpy(szAcceptMode, "RIP1 compatible");
            break;
        case IPRIP_ACCEPT_RIP2:
            lstrcpy(szAcceptMode, "RIP2");
            break;
        default:
            lstrcpy(szAcceptMode, "invalid");
            break;
    }

    switch(pic->IC_AnnounceMode) {
        case IPRIP_ANNOUNCE_DISABLED:
            lstrcpy(szAnnounceMode, "disabled");
            break;
        case IPRIP_ANNOUNCE_RIP1:
            lstrcpy(szAnnounceMode, "RIP1");
            break;
        case IPRIP_ANNOUNCE_RIP1_COMPAT:
            lstrcpy(szAnnounceMode, "RIP1 compatible");
            break;
        case IPRIP_ANNOUNCE_RIP2:
            lstrcpy(szAnnounceMode, "RIP2");
            break;
        default:
            lstrcpy(szAnnounceMode, "invalid");
            break;
    }

    switch (pic->IC_AuthenticationType) {
        case IPRIP_AUTHTYPE_NONE:
            lstrcpy(szAuthType, "none");
            break;
        case IPRIP_AUTHTYPE_SIMPLE_PASSWORD:
            lstrcpy(szAuthType, "simple password");
            break;
        case IPRIP_AUTHTYPE_MD5:
            lstrcpy(szAuthType, "MD5");
            break;
        default:
            lstrcpy(szAuthType, "invalid");
            break;
    }

    {
        PSTR psz;
        CHAR szDigits[] = "0123456789ABCDEF";
        PBYTE pb, pbend;

        psz = szAuthKey;
        pbend = pic->IC_AuthenticationKey + IPRIP_MAX_AUTHKEY_SIZE;
        for (pb = pic->IC_AuthenticationKey; pb < pbend; pb++) {
            *psz++ = szDigits[*pb / 16];
            *psz++ = szDigits[*pb % 16];
            *psz++ = '-';
        }

        *(--psz) = '\0';
    }

    switch (pic->IC_UnicastPeerMode) {
        case IPRIP_PEER_DISABLED:
            lstrcpy(szPeer, "disabled"); break;
        case IPRIP_PEER_ALSO:
            lstrcpy(szPeer, "also"); break;
        case IPRIP_PEER_ONLY:
            lstrcpy(szPeer, "only"); break;
        default:
            lstrcpy(szPeer, "invalid"); break;
    }

    switch (pic->IC_AcceptFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szAccept, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szAccept, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szAccept, "exclude all"); break;
        default:
            lstrcpy(szAccept, "invalid"); break;
    }

    switch (pic->IC_AnnounceFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szAnnounce, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szAnnounce, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szAnnounce, "exclude all"); break;
        default:
            lstrcpy(szAnnounce, "invalid"); break;
    }


    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Metric:                           %d",
        pic->IC_Metric
        );
    WriteLine(
        hConsole, *pc, "Update Mode:                      %s",
        szUpdateMode
        );
    WriteLine(
        hConsole, *pc, "Accept Mode:                      %s",
        szAcceptMode
        );
    WriteLine(
        hConsole, *pc, "Announce Mode:                    %s",
        szAnnounceMode
        );
    WriteLine(
        hConsole, *pc, "Accept Host Routes:               %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_HOST_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Announce Host Routes:             %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ANNOUNCE_HOST_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Accept Default Routes:            %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_DEFAULT_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Announce Default Routes:          %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ANNOUNCE_DEFAULT_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Split Horizon:                    %s",
        (IPRIP_FLAG_IS_ENABLED(pic, SPLIT_HORIZON) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Poison Reverse:                   %s",
        (IPRIP_FLAG_IS_ENABLED(pic, POISON_REVERSE) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Graceful Shutdown:                %s",
        (IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Triggered Updates:                %s",
        (IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Overwrite Static Routes:          %s",
        (IPRIP_FLAG_IS_ENABLED(pic, OVERWRITE_STATIC_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Route Expiration Interval:        %d seconds",
        pic->IC_RouteExpirationInterval
        );
    WriteLine(
        hConsole, *pc, "Route Removal Interval:           %d seconds",
        pic->IC_RouteRemovalInterval
        );
    WriteLine(
        hConsole, *pc, "Full Update Interval:             %d seconds",
        pic->IC_FullUpdateInterval
        );
    WriteLine(
        hConsole, *pc, "Authentication Type:              %s",
        szAuthType
        );
    WriteLine(
        hConsole, *pc, "Authentication Key:               %s",
        szAuthKey
        );
    WriteLine(
        hConsole, *pc, "Route Tag:                        %d",
        pic->IC_RouteTag
        );
    WriteLine(
        hConsole, *pc, "Unicast Peer Mode:                %s",
        szPeer
        );
    WriteLine(
        hConsole, *pc, "Accept Filter Mode:               %s",
        szAccept
        );
    WriteLine(
        hConsole, *pc, "Announce Filter Mode:             %s",
        szAnnounce
        );
    WriteLine(
        hConsole, *pc, "Unicast Peer Count:               %d",
        pic->IC_UnicastPeerCount
        );
    pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
    pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;
    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {
        lpszAddr = INET_NTOA(*pdwPeer);
        if (lpszAddr != NULL) {
            WriteLine(
                hConsole, *pc, "                                  %s",
                lpszAddr
                );
        }
    }

    WriteLine(
        hConsole, *pc, "Accept Filter Count:              %d",
        pic->IC_AcceptFilterCount
        );
    pfilt = IPRIP_IF_ACCEPT_FILTER_TABLE(pic);
    pfiltend = pfilt + pic->IC_AcceptFilterCount;
    for ( ; pfilt < pfiltend; pfilt++) {
        lpszAddr = INET_NTOA(pfilt->RF_LoAddress);
        if (lpszAddr != NULL) {
            lstrcpy(szFilter, lpszAddr);
            strcat(szFilter, " - ");
            lpszAddr = INET_NTOA(pfilt->RF_HiAddress);
            if (lpszAddr != NULL) {
                strcat(szFilter, INET_NTOA(pfilt->RF_HiAddress));
                WriteLine(
                    hConsole, *pc, "                                  %s",
                    szFilter
                    );
            }
        }
    }

    WriteLine(
        hConsole, *pc, "Announce Filter Count:            %d",
        pic->IC_AnnounceFilterCount
        );
    pfilt = IPRIP_IF_ANNOUNCE_FILTER_TABLE(pic);
    pfiltend = pfilt + pic->IC_AnnounceFilterCount;
    for ( ; pfilt < pfiltend; pfilt++) {
        lpszAddr = INET_NTOA(pfilt->RF_LoAddress);
        if (lpszAddr != NULL) {
            lstrcpy(szFilter, lpszAddr);
            strcat(szFilter, " - ");
            lpszAddr = INET_NTOA(pfilt->RF_HiAddress);
            if (lpszAddr != NULL) {
                strcat(szFilter, INET_NTOA(pfilt->RF_HiAddress));
                WriteLine(
                    hConsole, *pc, "                                  %s",
                    szFilter
                    );
            }
        }
    }

    pimgid->IMGID_TypeID = IPRIP_IF_CONFIG_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}


VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    DWORD i;
    CHAR szAddr[64];
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    LPSTR lpszAddr = NULL;

    pib = (PIPRIP_IF_BINDING) pimgod->IMGOD_Buffer;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Address Count:                    %d",
        pib->IB_AddrCount
        );
    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
        lpszAddr = INET_NTOA(paddr->IA_Address);

        if (lpszAddr != NULL) {
            lstrcpy(szAddr, lpszAddr);
            lstrcat(szAddr, " - ");

            lpszAddr = INET_NTOA(paddr->IA_Netmask);
            if (lpszAddr != NULL) {
                lstrcat(szAddr, lpszAddr);
                WriteLine(
                    hConsole, *pc, "Address Entry:                    %s",
                    szAddr
                    );
            }
        }
    }
    
    pimgid->IMGID_TypeID = IPRIP_IF_BINDING_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}


VOID
PrintPeerStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_PEER_STATS pps;
    LPSTR lpszAddr = INET_NTOA(pimgod->IMGOD_PeerAddress);


    pps = (PIPRIP_PEER_STATS)pimgod->IMGOD_Buffer;

    if (lpszAddr != NULL) {
        WriteLine(
            hConsole, *pc, "Peer Address:                     %s",
            lpszAddr
            );
    }
    else {
        WriteLine(
            hConsole, *pc, "Peer Address: Failed inet_ntoa conv %s",
            ""
            );
    }
    
    WriteLine(
        hConsole, *pc, "Last Peer Route Tag:              %d",
        pps->PS_LastPeerRouteTag
        );
    WriteLine(
        hConsole, *pc, "Last Peer Update Tick-Count       %d ticks",
        pps->PS_LastPeerUpdateTickCount
        );
    WriteLine(
        hConsole, *pc, "Bad Response Packets From Peer:   %d",
        pps->PS_BadResponsePacketsFromPeer
        );
    WriteLine(
        hConsole, *pc, "Bad Response Entries From Peer:   %d",
        pps->PS_BadResponseEntriesFromPeer
        );

    pimgid->IMGID_TypeID = IPRIP_PEER_STATS_ID;
    pimgid->IMGID_PeerAddress = pimgod->IMGOD_PeerAddress;
}



//----------------------------------------------------------------------------
// Function:    CallbackFunctionNetworkEvents
//
// This function queues a worker function to process the input packets.
// It registers a ntdll wait event at the end so that only one thread can
// be processing the input packets.
//----------------------------------------------------------------------------

VOID
CallbackFunctionNetworkEvents (
    PVOID   pContext,
    BOOLEAN NotUsed
    ) {

    HANDLE WaitHandle;

    //
    // enter/leaveRipApi should be called to make sure that rip dll is around
    //

    if (!ENTER_RIP_API()) { return; }


    //
    // set the pointer to NULL, so that Unregister wont be called
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_IpripInputEventHandle, NULL);

    if (WaitHandle)
        UnregisterWaitEx( WaitHandle, NULL ) ;



    QueueRipWorker(WorkerFunctionNetworkEvents,pContext);


    LEAVE_RIP_API();
}


//----------------------------------------------------------------------------
// Function:    ProcessNetworkEvents
//
// This function enumerates the input events on each interface
// and processes any incoming input packets
//----------------------------------------------------------------------------

VOID
WorkerFunctionNetworkEvents (
    PVOID   pContext
    ) {

    DWORD i, dwErr;
    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    WSANETWORKEVENTS wsane;
    PIPRIP_IP_ADDRESS paddr;
    LPSTR lpszAddr = NULL;


    if (!ENTER_RIP_WORKER()) { return; }

    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    //
    // go through the list of active interfaces
    // processing sockets which are read-ready
    //

    phead = &pTable->IT_ListByAddress;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pic = pite->ITE_Config;

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_DISABLED) { continue; }

        pib = pite->ITE_Binding;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

            if (pite->ITE_Sockets[i] == INVALID_SOCKET) { continue; }


            //
            // enumerate network events to see whether
            // any packets have arrived on this interface
            //

            dwErr = WSAEnumNetworkEvents(pite->ITE_Sockets[i], NULL, &wsane);
            if (dwErr != NO_ERROR) {

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RECEIVE, "error %d checking for input on interface %d (%s)",
                        dwErr, pite->ITE_Index, lpszAddr
                        );
                    LOGWARN1(ENUM_NETWORK_EVENTS_FAILED, lpszAddr, dwErr);
                }
                continue;
            }


            //
            // see if the input bit is set
            //

            if (!(wsane.lNetworkEvents & FD_READ)) { continue; }


            //
            // the input flag is set, now see if there was an error
            //

            if (wsane.iErrorCode[FD_READ_BIT] != NO_ERROR) {

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RECEIVE, "error %d in input record for interface %d (%s)",
                        wsane.iErrorCode[FD_READ_BIT], pite->ITE_Index, lpszAddr
                        );
                    LOGWARN1(INPUT_RECORD_ERROR, lpszAddr, dwErr);
                }
                continue;
            }


            //
            // there is no error, so process the socket
            //

            ProcessSocket(i, pite, pTable);

        }
    }

    RELEASE_IF_LOCK_SHARED();


    //
    // if dll is not stopping, register input event with NtdllWait thread again
    //
    if (ig.IG_Status != IPRIP_STATUS_STOPPING) {

        
        if (! RegisterWaitForSingleObject(
                  &ig.IG_IpripInputEventHandle,
                  ig.IG_IpripInputEvent,
                  CallbackFunctionNetworkEvents,
                  NULL,
                  INFINITE,
                  (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                  )) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering input event with NtdllWait thread",
                dwErr);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);
        }
    }


    LEAVE_RIP_WORKER();
}




//----------------------------------------------------------------------------
// Function:            ProcessSocket
//
// This function receives the message on the given socket and queues it
// for processing if the configuration on the receiving interface allows it.
//----------------------------------------------------------------------------

VOID
ProcessSocket(
    DWORD dwAddrIndex,
    PIF_TABLE_ENTRY pite,
    PIF_TABLE pTable
    ) {

    SOCKET sock;
    PPEER_TABLE pPeers;
    IPRIP_PACKET pkt;
    PBYTE pInputPacket;
    CHAR szSrcAddr[20];
    CHAR szLocalAddr[20];
    LPSTR lpszTempAddr = NULL;
    PIPRIP_HEADER pih;
    PINPUT_CONTEXT pwc;
    PIPRIP_IF_STATS pis;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PIPRIP_PEER_STATS pps;
    PPEER_TABLE_ENTRY ppte;
    DWORD dwErr, dwSrcaddr;
    SOCKADDR_IN sinInputSource;
    INT i, iInputLength, iAddrLength;
    DWORD dwPacketsEnqueued = 0, dwWorkItemsEnqueued = 0, dwRetries = 0;

    pis = &pite->ITE_Stats;
    pic = pite->ITE_Config;
    sock = pite->ITE_Sockets[dwAddrIndex];
    pib = pite->ITE_Binding;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib) + dwAddrIndex;
    pPeers = ig.IG_PeerTable;

    iAddrLength = sizeof(SOCKADDR_IN);
    
    do {

        pwc = NULL;

        pInputPacket = pkt.IP_Packet;


        //
        // read the incoming packet
        //

        iInputLength = recvfrom(
                          sock, pInputPacket, MAX_PACKET_SIZE, 0,
                          (PSOCKADDR)&sinInputSource, &iAddrLength
                          );

        if (iInputLength == 0 || iInputLength == SOCKET_ERROR) {

            dwErr = WSAGetLastError();

            //
            // If there is not more data to be received we should 
            // break out of the loop as there is no more data to be read.
            // This should not increment IS_ReceiveFailures
            //
            // All other errors should be looged, and IS_ReceiveFailures 
            // should be incremented. Then break out of the loop
            //

            if ( iInputLength == SOCKET_ERROR && dwErr == WSAEWOULDBLOCK ) {

                //
                // Allow time for more packets to come in
                //
                Sleep(0);
                
                if ( dwRetries < 3 ) {
                    dwRetries++;
                    continue;
                }
            }
            else {

                lpszTempAddr  = INET_NTOA(paddr->IA_Address);
                if ( lpszTempAddr ) {
                    lstrcpyn(szLocalAddr, lpszTempAddr, sizeof(szLocalAddr));
                }
                else {
                    ZeroMemory(szLocalAddr, sizeof(szLocalAddr));
                }
                
                lpszTempAddr = INET_NTOA(sinInputSource.sin_addr.s_addr);
                if ( lpszTempAddr ) {
                    lstrcpyn(szSrcAddr, lpszTempAddr, sizeof(szSrcAddr));
                }
                else {
                    ZeroMemory(szSrcAddr, sizeof(szSrcAddr));
                }

                if ( dwErr != WSAECONNRESET ) {
                    TRACE3(
                        RECEIVE, 
                        "error %d receiving packet on interface %d (%s)",
                        dwErr, pite->ITE_Index, szLocalAddr
                        );

                    LOGERR1(RECVFROM_FAILED, szLocalAddr, dwErr);

                    InterlockedIncrement(&pis->IS_ReceiveFailures);
                }
                else {
                    TRACE3(
                        RECEIVE, 
                        "A previous RIP message sent to peer %s from "
                        "interface %d (%s) generated an ICMP Port "
                        "Unreachable error",
                        szSrcAddr,
                        pite->ITE_Index,
                        szLocalAddr
                        );

                    LOGWARN2(PREVIOUS_SENDTO_FAILED, 
                        szSrcAddr, 
                        szLocalAddr, 
                        dwErr);
                }

            }

            break;
        }

        //
        // After successfully receiving a packet, reset the dwRetries to 0
        //
        dwRetries = 0;

        dwSrcaddr = sinInputSource.sin_addr.s_addr;

        //
        // Set the local and remote address strings
        //
        lpszTempAddr  = INET_NTOA(paddr->IA_Address);
        if ( lpszTempAddr ) {
            lstrcpyn(szLocalAddr, lpszTempAddr, sizeof(szLocalAddr));
        }
        else {
            ZeroMemory(szLocalAddr, sizeof(szLocalAddr));
        }

        lpszTempAddr = INET_NTOA(dwSrcaddr);
        if ( lpszTempAddr ) {
            lstrcpyn(szSrcAddr, lpszTempAddr, sizeof(szSrcAddr));
        }
        else {
            ZeroMemory(szSrcAddr, sizeof(szSrcAddr));
        }

        //
        // ignore the packet if it is from a local address
        //

        if (GetIfByAddress(pTable, dwSrcaddr, GETMODE_EXACT, NULL) != NULL) {

            continue;
        }


#if DBG

        TRACE4(
            RECEIVE, "received %d-byte packet from %s on interface %d (%s)",
            iInputLength, szSrcAddr, pite->ITE_Index, szLocalAddr
            );

#endif

        //
        // the packet must contain at least one entry
        //

        if (iInputLength < MIN_PACKET_SIZE) {

            TRACE4(
                RECEIVE,
                "%d-byte packet from %s on interface %d (%s) is too small",
                iInputLength, szSrcAddr, pite->ITE_Index, szLocalAddr
                );
            LOGWARN2(PACKET_TOO_SMALL, szLocalAddr, szSrcAddr, NO_ERROR);

            continue;
        }


        //
        // find out which peer sent this, or create a new peer
        //

        ACQUIRE_PEER_LOCK_EXCLUSIVE();

        dwErr = CreatePeerEntry(pPeers, dwSrcaddr, &ppte);
        if (dwErr == NO_ERROR) {
            pps = &ppte->PTE_Stats;
        }
        else {

            pps = NULL;

            //
            // not a serious error, so go on
            //

            TRACE2(
                RECEIVE, "error %d creating peer statistics entry for %s",
                dwErr, szSrcAddr
                );
        }

        RELEASE_PEER_LOCK_EXCLUSIVE();


        ACQUIRE_PEER_LOCK_SHARED();



        //
        // place a template over the packet
        //

        pih = (PIPRIP_HEADER)pInputPacket;


        //
        // update the peer statistics
        //

        if (pps != NULL) {
            InterlockedExchange(
                &pps->PS_LastPeerUpdateTickCount, GetTickCount()
                );
            InterlockedExchange(
                &pps->PS_LastPeerUpdateVersion, (DWORD)pih->IH_Version
                );
        }


        //
        // discard if the version is invalid, or if the packet is
        // a RIPv1 packet and the reserved field in the header is non-zero
        //

        if (pih->IH_Version == 0) {

            TRACE3(
                RECEIVE, "invalid version packet from %s on interface %d (%s)",
                szSrcAddr, pite->ITE_Index, szLocalAddr
                );
            LOGWARNDATA2(
                PACKET_VERSION_INVALID, szLocalAddr, szSrcAddr,
                iInputLength, pInputPacket
                );
            
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }


            RELEASE_PEER_LOCK_SHARED();

            continue;
        }
        else
        if (pih->IH_Version == 1 && pih->IH_Reserved != 0) {

            TRACE3(
                RECEIVE, "invalid packet header from %s on interface %d (%s)",
                szSrcAddr, pite->ITE_Index, szLocalAddr
                );
            LOGWARNDATA2(
                PACKET_HEADER_CORRUPT, szLocalAddr, szSrcAddr,
                iInputLength, pInputPacket
                );
            
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }


            RELEASE_PEER_LOCK_SHARED();

            continue;
        }


        RELEASE_PEER_LOCK_SHARED();



        //
        // make sure command field is valid, and
        // update statistics on received packets
        // Discard the packet if command field is
        // invalid
        //

        if (pih->IH_Command == IPRIP_REQUEST) {

            InterlockedIncrement(&pis->IS_RequestsReceived);
        }
        else
        if (pih->IH_Command == IPRIP_RESPONSE) {

            InterlockedIncrement(&pis->IS_ResponsesReceived);
        }
        else {

            continue;
        }



        //
        // allocate and initialize a work-context to be queued
        // and update the receive queue size
        //

        pwc = RIP_ALLOC(sizeof(INPUT_CONTEXT));

        if (pwc == NULL) {

            TRACE4(
                RECEIVE,
                "error %d allocating %d bytes for packet on interface %d (%s)",
                GetLastError(), sizeof(INPUT_CONTEXT), pite->ITE_Index,
                szLocalAddr
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            //
            // If we weren't able to allocate memory, we might as well
            // break out of the loop, instead of receiving more packets
            // and then again running into out of memory condition.
            // Hope that by the time ProcessSocket is called next, some
            // resources will be available
            //
            break;
        }


        pwc->IC_InterfaceIndex = pite->ITE_Index;
        pwc->IC_AddrIndex = dwAddrIndex;
        pwc->IC_InputSource = sinInputSource;
        pwc->IC_InputLength = iInputLength;
        pwc->IC_InputPacket = pkt;


        //
        // enqueue the packet and source-address as a recv-queue entry
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

        dwErr = EnqueueRecvEntry(
                    ig.IG_RecvQueue, pih->IH_Command, (PBYTE)pwc
                    );

        RELEASE_LIST_LOCK(ig.IG_RecvQueue);

        RELEASE_GLOBAL_LOCK_SHARED();


        if (dwErr != NO_ERROR) {

            TRACE4(
                RECEIVE,
                "error %d queueing data for packet from %s on interface %d (%s)",
                dwErr, szSrcAddr, pite->ITE_Index, szLocalAddr
                );

            //
            // If we weren't able to enqueue the recv entry, we might as well
            // break out of the loop, instead of receiving more packets.
            //

            break;
        }

        dwPacketsEnqueued++;


        //
        // enqueue the work-item to process the packet
        // We enqueue a new workitem only if the number of currently enqueued 
        // workitems goes below the number of processors. This is to avoid 
        // enqueueing one workitem for each packet and thus having a large amount 
        // of queued workitems. These large number of queued workitems can 
        // block other workitems, like the ones that are supposed to receive 
        // RIP packets.
        //

        if ( ig.IG_NumProcessInputWorkItems < 
                        (LONG)ig.IG_MaxProcessInputWorkItems ) {

            dwErr = QueueRipWorker(WorkerFunctionProcessInput, NULL);

            if (dwErr != NO_ERROR) {

                PLIST_ENTRY phead;

                TRACE4(
                    RECEIVE,
                    "error %d queueing work-item for packet from %s on interface %d (%s)",
                    dwErr, szSrcAddr, pite->ITE_Index, szLocalAddr
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                //
                // remove the data that was queued for processing
                //

                ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

                phead = &ig.IG_RecvQueue->LL_Head;
                RemoveTailList(phead);
                ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);

                RELEASE_LIST_LOCK(ig.IG_RecvQueue);

                //
                // If we weren't able to enqueue the work item, we might as well
                // break out of the loop, instead of receiving more packets.
                //

                break;
            }
            else {
                InterlockedIncrement(&ig.IG_NumProcessInputWorkItems);
                dwWorkItemsEnqueued++;
            }

        }

    } while(TRUE);


    TRACE2(
        RECEIVE, "Packets Queued: %d. WorkItems Queued: %d",
        dwPacketsEnqueued, dwWorkItemsEnqueued
        );

    //
    // some cleanup is required if an error brought us here
    //

    if (pwc != NULL) { RIP_FREE(pwc); }

    return;
}

DWORD
ProcessRtmNotification(
    RTM_ENTITY_HANDLE    hRtmHandle,    // not used
    RTM_EVENT_TYPE       retEventType,
    PVOID                pvContext1,    // not used
    PVOID                pvContext2     // not used
    ) {


    DWORD dwErr;

    
    TRACE1(ROUTE, "ENTERED ProcessRtmNotification, event %d", retEventType );

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }


    //
    // only route change notifications are processed
    //
    
    if (retEventType == RTM_CHANGE_NOTIFICATION) {
    
        QueueRipWorker(WorkerFunctionProcessRtmMessage, (PVOID)retEventType);

        dwErr = NO_ERROR;
    }

    else { 
        dwErr = ERROR_NOT_SUPPORTED; 
    }
    
    LEAVE_RIP_API();
    
    TRACE1(ROUTE, "LEAVING ProcessRtmNotification %d", dwErr);
    
    return dwErr;
}



DWORD
BlockDeleteRoutesOnInterface (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex
    )
/*++

Routine Description :

    This routine deletes all the routes learnt by the protocol
    over the specified interface.


Parameters :

    hRtmHandle  - Entity registration handle

    dwIfIndex   - Interface over which routes are to be deleted


Return Value :

    
--*/
{
    HANDLE           hRtmEnum;
    PHANDLE          phRoutes = NULL;
    DWORD            dwHandles, dwFlags, i, dwErr;



    dwErr = RtmCreateRouteEnum(
                hRtmHandle, NULL, RTM_VIEW_MASK_ANY, RTM_ENUM_OWN_ROUTES,
                NULL, RTM_MATCH_INTERFACE, NULL, dwIfIndex, &hRtmEnum
                );

    if ( dwErr != NO_ERROR ) {
        TRACE1(
            ANY, "BlockDeleteRoutesOnInterface: Error %d creating handle",
            dwErr
            );
        
        return dwErr;
    }


    //
    // allocate handle array large enough to hold max handles in an
    // enum
    //
        
    phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE));

    if ( phRoutes == NULL ) {

        dwErr = GetLastError();

        TRACE2(
            ANY, "BlockDeleteRoutesOnInterface: error %d while "
            "allocating %d bytes to hold max handles in an enum",
            dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );

        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    do {
        dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
        
        dwErr = RtmGetEnumRoutes(
                    hRtmHandle, hRtmEnum, &dwHandles, phRoutes
                    );

        for ( i = 0; i < dwHandles; i++ )
        {
            if ( RtmDeleteRouteToDest(
                    hRtmHandle, phRoutes[i], &dwFlags
                    ) != NO_ERROR ) {
                //
                // If delete is successful, this is automatic
                //

                TRACE2(
                    ANY, "BlockDeleteRoutesOnInterface : error %d deleting"
                    " routes on interface %d", dwErr, dwIfIndex
                    );

                dwErr = RtmReleaseRoutes(hRtmHandle, 1, &phRoutes[i]);

                if (dwErr != NO_ERROR) {
                    TRACE1(ANY, "error %d releasing route", dwErr);
                }
            }
        }
        
    } while (dwErr == NO_ERROR);


    //
    // close enum handles
    //
    
    dwErr = RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "BlockDeleteRoutesOnInterface : error %d closing enum handle",
            dwErr
            );
    }

    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\mibentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.c

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#include "precomp.h"
#pragma hdrstop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_msiprip2[]                          = {1,3,6,1,4,1,311,1,11};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_global[]                              = {1,0};
static UINT ids_globalSystemRouteChanges[]            = {1,1,0};
static UINT ids_globalTotalResponseSends[]            = {1,2,0};
static UINT ids_globalLoggingLevel[]                  = {1,3,0};
static UINT ids_globalMaxRecQueueSize[]               = {1,4,0};
static UINT ids_globalMaxSendQueueSize[]              = {1,5,0};
static UINT ids_globalMinTriggeredUpdateInterval[]    = {1,6,0};
static UINT ids_globalPeerFilterMode[]                = {1,7,0};
static UINT ids_globalPeerFilterCount[]               = {1,8,0};
static UINT ids_globalPeerFilterTable[]               = {1,9,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_globalPeerFilterEntry[]               = {1,9,1};
static UINT ids_globalPFAddr[]                        = {1,9,1,1};
static UINT ids_globalPFTag[]                         = {1,9,1,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_interface[]                           = {2,0};
static UINT ids_ifStatsTable[]                        = {2,1,0};
static UINT ids_ifConfigTable[]                       = {2,2,0};
static UINT ids_ifUnicastPeersTable[]                 = {2,3,0};
static UINT ids_ifAcceptRouteFilterTable[]            = {2,4,0};
static UINT ids_ifAnnounceRouteFilterTable[]          = {2,5,0};
static UINT ids_ifBindingTable[]                      = {2,6,0};
static UINT ids_ifAddressTable[]                      = {2,7,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifStatsEntry[]                        = {2,1,1};
static UINT ids_ifSEIndex[]                           = {2,1,1,1};
static UINT ids_ifSEState[]                           = {2,1,1,2};
static UINT ids_ifSESendFailures[]                    = {2,1,1,3};
static UINT ids_ifSEReceiveFailures[]                 = {2,1,1,4};
static UINT ids_ifSERequestSends[]                    = {2,1,1,5};
static UINT ids_ifSERequestReceiveds[]                = {2,1,1,6};
static UINT ids_ifSEResponseSends[]                   = {2,1,1,7};
static UINT ids_ifSEResponseReceiveds[]               = {2,1,1,8};
static UINT ids_ifSEBadResponsePacketReceiveds[]      = {2,1,1,9};
static UINT ids_ifSEBadResponseEntriesReceiveds[]     = {2,1,1,10};
static UINT ids_ifSETriggeredUpdateSends[]            = {2,1,1,11};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifConfigEntry[]                       = {2,2,1};
static UINT ids_ifCEIndex[]                           = {2,2,1,1};
static UINT ids_ifCEState[]                           = {2,2,1,2};
static UINT ids_ifCEMetric[]                          = {2,2,1,3};
static UINT ids_ifCEUpdateMode[]                      = {2,2,1,4};
static UINT ids_ifCEAcceptMode[]                      = {2,2,1,5};
static UINT ids_ifCEAnnounceMode[]                    = {2,2,1,6};
static UINT ids_ifCEProtocolFlags[]                   = {2,2,1,7};
static UINT ids_ifCERouteExpirationInterval[]         = {2,2,1,8};
static UINT ids_ifCERouteRemovalInterval[]            = {2,2,1,9};
static UINT ids_ifCEFullUpdateInterval[]              = {2,2,1,10};
static UINT ids_ifCEAuthenticationType[]              = {2,2,1,11};
static UINT ids_ifCEAuthenticationKey[]               = {2,2,1,12};
static UINT ids_ifCERouteTag[]                        = {2,2,1,13};
static UINT ids_ifCEUnicastPeerMode[]                 = {2,2,1,14};
static UINT ids_ifCEAcceptFilterMode[]                = {2,2,1,15};
static UINT ids_ifCEAnnounceFilterMode[]              = {2,2,1,16};
static UINT ids_ifCEUnicastPeerCount[]                = {2,2,1,17};
static UINT ids_ifCEAcceptFilterCount[]               = {2,2,1,18};
static UINT ids_ifCEAnnounceFilterCount[]             = {2,2,1,19};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifUnicastPeersEntry[]                 = {2,3,1};
static UINT ids_ifUPIfIndex[]                         = {2,3,1,1};
static UINT ids_ifUPAddress[]                         = {2,3,1,2};
static UINT ids_ifUPTag[]                             = {2,3,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAcceptRouteFilterEntry[]            = {2,4,1};
static UINT ids_ifAcceptRFIfIndex[]                   = {2,4,1,1};
static UINT ids_ifAcceptRFLoAddress[]                 = {2,4,1,2};
static UINT ids_ifAcceptRFHiAddress[]                 = {2,4,1,3};
static UINT ids_ifAcceptRFTag[]                       = {2,4,1,4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAnnounceRouteFilterEntry[]          = {2,5,1};
static UINT ids_ifAnnounceRFIfIndex[]                  = {2,5,1,1};
static UINT ids_ifAnnounceRFLoAddress[]               = {2,5,1,2};
static UINT ids_ifAnnounceRFHiAddress[]               = {2,5,1,3};
static UINT ids_ifAnnounceRFTag[]                     = {2,5,1,4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifBindingEntry[]                      = {2,6,1};
static UINT ids_ifBindingIndex[]                      = {2,6,1,1};
static UINT ids_ifBindingState[]                      = {2,6,1,2};
static UINT ids_ifBindingCounts[]                     = {2,6,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAddressEntry[]                      = {2,7,1};
static UINT ids_ifAEIfIndex[]                         = {2,7,1,1};
static UINT ids_ifAEAddress[]                         = {2,7,1,2};
static UINT ids_ifAEMask[]                            = {2,7,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_peer[]                                = {3,0};    
static UINT ids_ifPeerStatsTable[]                    = {3,1,0};    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifPeerStatsEntry[]                    = {3,1,1};    
static UINT ids_ifPSAddress[]                         = {3,1,1,1};    
static UINT ids_ifPSLastPeerRouteTag[]                = {3,1,1,2};    
static UINT ids_ifPSLastPeerUpdateTickCount[]         = {3,1,1,3};    
static UINT ids_ifPSLastPeerUpdateVersion[]           = {3,1,1,4};    
static UINT ids_ifPSPeerBadResponsePackets[]          = {3,1,1,5};    
static UINT ids_ifPSPeerBadResponseEntries[]          = {3,1,1,6};    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_msiprip2[] = {
    MIB_GROUP(global),
        MIB_COUNTER(globalSystemRouteChanges),
        MIB_COUNTER(globalTotalResponseSends),
        MIB_INTEGER_RW(globalLoggingLevel),
        MIB_INTEGER_RW(globalMaxRecQueueSize),
        MIB_INTEGER_RW(globalMaxSendQueueSize),
        MIB_TIMETICKS_RW(globalMinTriggeredUpdateInterval),
        MIB_INTEGER_RW(globalPeerFilterMode),
        MIB_INTEGER(globalPeerFilterCount),
        MIB_TABLE_ROOT(globalPeerFilterTable),
            MIB_TABLE_ENTRY(globalPeerFilterEntry),
                MIB_IPADDRESS_RW(globalPFAddr),
                MIB_INTEGER(globalPFTag),
    MIB_GROUP(interface),
        MIB_TABLE_ROOT(ifStatsTable), 
            MIB_TABLE_ENTRY(ifStatsEntry),
                MIB_INTEGER(ifSEIndex), 
                MIB_INTEGER(ifSEState),
                MIB_COUNTER(ifSESendFailures),
                MIB_COUNTER(ifSEReceiveFailures),
                MIB_COUNTER(ifSERequestSends), 
                MIB_COUNTER(ifSERequestReceiveds),
                MIB_COUNTER(ifSEResponseSends),
                MIB_COUNTER(ifSEResponseReceiveds),
                MIB_COUNTER(ifSEBadResponsePacketReceiveds),
                MIB_COUNTER(ifSEBadResponseEntriesReceiveds),
                MIB_COUNTER(ifSETriggeredUpdateSends),
        MIB_TABLE_ROOT(ifConfigTable),
            MIB_TABLE_ENTRY(ifConfigEntry),
                MIB_INTEGER(ifCEIndex),
                MIB_INTEGER(ifCEState),
                MIB_INTEGER_RW(ifCEMetric),
                MIB_INTEGER_RW(ifCEUpdateMode),
                MIB_INTEGER_RW(ifCEAcceptMode), 
                MIB_INTEGER_RW(ifCEAnnounceMode),
                MIB_INTEGER_RW(ifCEProtocolFlags),
                MIB_TIMETICKS_RW(ifCERouteExpirationInterval),
                MIB_TIMETICKS_RW(ifCERouteRemovalInterval),
                MIB_TIMETICKS_RW(ifCEFullUpdateInterval),
                MIB_INTEGER_RW(ifCEAuthenticationType),
                MIB_OCTETSTRING_RW_L(ifCEAuthenticationKey,0,16), 
                MIB_INTEGER_RW(ifCERouteTag),
                MIB_INTEGER_RW(ifCEUnicastPeerMode),
                MIB_INTEGER_RW(ifCEAcceptFilterMode),
                MIB_INTEGER_RW(ifCEAnnounceFilterMode),
                MIB_INTEGER(ifCEUnicastPeerCount), 
                MIB_INTEGER(ifCEAcceptFilterCount), 
                MIB_INTEGER(ifCEAnnounceFilterCount), 
        MIB_TABLE_ROOT(ifUnicastPeersTable),
            MIB_TABLE_ENTRY(ifUnicastPeersEntry),
                MIB_INTEGER(ifUPIfIndex),
                MIB_IPADDRESS_RW(ifUPAddress),
                MIB_INTEGER(ifUPTag),
        MIB_TABLE_ROOT(ifAcceptRouteFilterTable), 
            MIB_TABLE_ENTRY(ifAcceptRouteFilterEntry),
                MIB_INTEGER(ifAcceptRFIfIndex),
                MIB_IPADDRESS_RW(ifAcceptRFLoAddress),
                MIB_IPADDRESS_RW(ifAcceptRFHiAddress),
                MIB_INTEGER(ifAcceptRFTag),
        MIB_TABLE_ROOT(ifAnnounceRouteFilterTable),
            MIB_TABLE_ENTRY(ifAnnounceRouteFilterEntry), 
                MIB_INTEGER(ifAnnounceRFIfIndex), 
                MIB_IPADDRESS_RW(ifAnnounceRFLoAddress),
                MIB_IPADDRESS_RW(ifAnnounceRFHiAddress),
                MIB_INTEGER(ifAnnounceRFTag),
        MIB_TABLE_ROOT(ifBindingTable),
            MIB_TABLE_ENTRY(ifBindingEntry),
                MIB_INTEGER(ifBindingIndex),
                MIB_INTEGER(ifBindingState), 
                MIB_COUNTER(ifBindingCounts),
        MIB_TABLE_ROOT(ifAddressTable),
            MIB_TABLE_ENTRY(ifAddressEntry), 
                MIB_INTEGER(ifAEIfIndex),
                MIB_IPADDRESS(ifAEAddress),
                MIB_IPADDRESS(ifAEMask),
    MIB_GROUP(peer),
        MIB_TABLE_ROOT(ifPeerStatsTable),
            MIB_TABLE_ENTRY(ifPeerStatsEntry),
                MIB_IPADDRESS(ifPSAddress),
                MIB_INTEGER(ifPSLastPeerRouteTag),
                MIB_TIMETICKS(ifPSLastPeerUpdateTickCount),
                MIB_INTEGER_L(ifPSLastPeerUpdateVersion,0,255),
                MIB_COUNTER(ifPSPeerBadResponsePackets),
                MIB_COUNTER(ifPSPeerBadResponseEntries),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_msiprip2[] = {
    MIB_TABLE(msiprip2,globalPeerFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifStatsEntry,NULL),
    MIB_TABLE(msiprip2,ifConfigEntry,NULL),
    MIB_TABLE(msiprip2,ifUnicastPeersEntry,NULL),
    MIB_TABLE(msiprip2,ifAcceptRouteFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifAnnounceRouteFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifBindingEntry,NULL),
    MIB_TABLE(msiprip2,ifAddressEntry,NULL),
    MIB_TABLE(msiprip2,ifPeerStatsEntry,NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibView v_msiprip2 = MIB_VIEW(msiprip2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\mibentry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.h

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_global                               0
#define mi_globalSystemRouteChanges             mi_global+1                           
#define mi_globalTotalResponseSends             mi_globalSystemRouteChanges+1
#define mi_globalLoggingLevel                   mi_globalTotalResponseSends+1
#define mi_globalMaxRecQueueSize                mi_globalLoggingLevel+1
#define mi_globalMaxSendQueueSize               mi_globalMaxRecQueueSize+1
#define mi_globalMinTriggeredUpdateInterval     mi_globalMaxSendQueueSize+1
#define mi_globalPeerFilterMode                 mi_globalMinTriggeredUpdateInterval+1
#define mi_globalPeerFilterCount                mi_globalPeerFilterMode+1
#define mi_globalPeerFilterTable                mi_globalPeerFilterCount+1
#define mi_globalPeerFilterEntry                mi_globalPeerFilterTable+1
#define mi_globalPFAddr                         mi_globalPeerFilterEntry+1
#define mi_globalPFTag                          mi_globalPFAddr+1
#define mi_interface                            mi_globalPFTag+1
#define mi_ifStatsTable                         mi_interface+1
#define mi_ifStatsEntry                         mi_ifStatsTable+1 
#define mi_ifSEIndex                            mi_ifStatsEntry+1
#define mi_ifSEState                            mi_ifSEIndex+1 
#define mi_ifSESendFailures                     mi_ifSEState+1
#define mi_ifSEReceiveFailures                  mi_ifSESendFailures+1
#define mi_ifSERequestSends                     mi_ifSEReceiveFailures+1
#define mi_ifSERequestReceiveds                 mi_ifSERequestSends+1 
#define mi_ifSEResponseSends                    mi_ifSERequestReceiveds+1
#define mi_ifSEResponseReceiveds                mi_ifSEResponseSends+1
#define mi_ifSEBadResponsePacketReceiveds       mi_ifSEResponseReceiveds+1
#define mi_ifSEBadResponseEntriesReceiveds      mi_ifSEBadResponsePacketReceiveds+1
#define mi_ifSETriggeredUpdateSends             mi_ifSEBadResponseEntriesReceiveds+1
#define mi_ifConfigTable                        mi_ifSETriggeredUpdateSends+1
#define mi_ifConfigEntry                        mi_ifConfigTable+1
#define mi_ifCEIndex                            mi_ifConfigEntry+1
#define mi_ifCEState                            mi_ifCEIndex+1
#define mi_ifCEMetric                           mi_ifCEState+1
#define mi_ifCEUpdateMode                       mi_ifCEMetric+1
#define mi_ifCEAcceptMode                       mi_ifCEUpdateMode+1
#define mi_ifCEAnnounceMode                     mi_ifCEAcceptMode+1 
#define mi_ifCEProtocolFlags                    mi_ifCEAnnounceMode+1
#define mi_ifCERouteExpirationInterval          mi_ifCEProtocolFlags+1
#define mi_ifCERouteRemovalInterval             mi_ifCERouteExpirationInterval+1
#define mi_ifCEFullUpdateInterval               mi_ifCERouteRemovalInterval+1
#define mi_ifCEAuthenticationType               mi_ifCEFullUpdateInterval+1
#define mi_ifCEAuthenticationKey                mi_ifCEAuthenticationType+1
#define mi_ifCERouteTag                         mi_ifCEAuthenticationKey+1
#define mi_ifCEUnicastPeerMode                  mi_ifCERouteTag+1
#define mi_ifCEAcceptFilterMode                 mi_ifCEUnicastPeerMode+1
#define mi_ifCEAnnounceFilterMode               mi_ifCEAcceptFilterMode+1
#define mi_ifCEUnicastPeerCount                 mi_ifCEAnnounceFilterMode+1
#define mi_ifCEAcceptFilterCount                mi_ifCEUnicastPeerCount+1 
#define mi_ifCEAnnounceFilterCount              mi_ifCEAcceptFilterCount+1 
#define mi_ifUnicastPeersTable                  mi_ifCEAnnounceFilterCount+1 
#define mi_ifUnicastPeersEntry                  mi_ifUnicastPeersTable+1
#define mi_ifUPIfIndex                          mi_ifUnicastPeersEntry+1
#define mi_ifUPAddress                          mi_ifUPIfIndex+1
#define mi_ifUPTag                              mi_ifUPAddress+1
#define mi_ifAcceptRouteFilterTable             mi_ifUPTag+1
#define mi_ifAcceptRouteFilterEntry             mi_ifAcceptRouteFilterTable+1
#define mi_ifAcceptRFIfIndex                    mi_ifAcceptRouteFilterEntry+1
#define mi_ifAcceptRFLoAddress                  mi_ifAcceptRFIfIndex+1
#define mi_ifAcceptRFHiAddress                  mi_ifAcceptRFLoAddress+1
#define mi_ifAcceptRFTag                        mi_ifAcceptRFHiAddress+1
#define mi_ifAnnounceRouteFilterTable           mi_ifAcceptRFTag+1
#define mi_ifAnnounceRouteFilterEntry           mi_ifAnnounceRouteFilterTable+1
#define mi_ifAnnounceRFIfIndex                   mi_ifAnnounceRouteFilterEntry+1 
#define mi_ifAnnounceRFLoAddress                mi_ifAnnounceRFIfIndex+1 
#define mi_ifAnnounceRFHiAddress                mi_ifAnnounceRFLoAddress+1
#define mi_ifAnnounceRFTag                      mi_ifAnnounceRFHiAddress+1
#define mi_ifBindingTable                       mi_ifAnnounceRFTag+1 
#define mi_ifBindingEntry                       mi_ifBindingTable+1
#define mi_ifBindingIndex                       mi_ifBindingEntry+1
#define mi_ifBindingState                       mi_ifBindingIndex+1
#define mi_ifBindingCounts                      mi_ifBindingState+1 
#define mi_ifAddressTable                       mi_ifBindingCounts+1
#define mi_ifAddressEntry                       mi_ifAddressTable+1
#define mi_ifAEIfIndex                          mi_ifAddressEntry+1 
#define mi_ifAEAddress                          mi_ifAEIfIndex+1
#define mi_ifAEMask                             mi_ifAEAddress+1
#define mi_peer                                 mi_ifAEMask+1
#define mi_ifPeerStatsTable                     mi_peer+1
#define mi_ifPeerStatsEntry                     mi_ifPeerStatsTable+1
#define mi_ifPSAddress                          mi_ifPeerStatsEntry+1
#define mi_ifPSLastPeerRouteTag                 mi_ifPSAddress+1
#define mi_ifPSLastPeerUpdateTickCount          mi_ifPSLastPeerRouteTag+1
#define mi_ifPSLastPeerUpdateVersion            mi_ifPSLastPeerUpdateTickCount+1
#define mi_ifPSPeerBadResponsePackets           mi_ifPSLastPeerUpdateVersion+1
#define mi_ifPSPeerBadResponseEntries           mi_ifPSPeerBadResponsePackets+1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_globalPeerFilterEntry                2
#define ni_globalPeerFilterEntry                1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifStatsEntry                         11
#define ni_ifStatsEntry                         1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifConfigEntry                        19
#define ni_ifConfigEntry                        1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifUnicastPeersEntry                  3
#define ni_ifUnicastPeersEntry                  2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAcceptRouteFilterEntry             4
#define ni_ifAcceptRouteFilterEntry             3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAnnounceRouteFilterEntry           4
#define ni_ifAnnounceRouteFilterEntry           3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifBindingEntry                       3
#define ni_ifBindingEntry                       1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAddressEntry                       3
#define ni_ifAddressEntry                       3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifPeerStatsEntry                     6
#define ni_ifPeerStatsEntry                     1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Other definitions                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
                             
#define d_globalLoggingLevel_none                   1
#define d_globalLoggingLevel_error                  2
#define d_globalLoggingLevel_warning                3
#define d_globalLoggingLevel_information            4
#define d_globalPeerFilterMode_disable              1
#define d_globalPeerFilterMode_include              2
#define d_globalPeerFilterMode_exclude              3
#define d_ifSEState_enabled                         1
#define d_ifSEState_bound                           2
#define d_ifCEState_enabled                         1
#define d_ifCEState_bound                           2
#define d_ifCEUpdateMode_periodic                   1
#define d_ifCEUpdateMode_demand                     2
#define d_ifCEAcceptMode_disable                    1
#define d_ifCEAcceptMode_rip1                       2
#define d_ifCEAcceptMode_rip1Compat                 3
#define d_ifCEAcceptMode_rip2                       4
#define d_ifCEAnnounceMode_disable                  1
#define d_ifCEAnnounceMode_rip1                     2
#define d_ifCEAnnounceMode_rip1Compat               3
#define d_ifCEAnnounceMode_rip2                     4
#define d_ifCEAuthenticationType_noAuthentication   1
#define d_ifCEAuthenticationType_simplePassword     2
#define d_ifCEAuthenticationType_md5                3
#define d_ifCEUnicastPeerMode_disable               1
#define d_ifCEUnicastPeerMode_peerAlso              2
#define d_ifCEUnicastPeerMode_peerOnly              3
#define d_ifCEAcceptFilterMode_disable              1
#define d_ifCEAcceptFilterMode_include              2
#define d_ifCEAcceptFilterMode_exclude              3
#define d_ifCEAnnounceFilterMode_disable            1
#define d_ifCEAnnounceFilterMode_include            2
#define d_ifCEAnnounceFilterMode_exclude            3
#define d_ifBindingState_enabled                    1
#define d_ifBindingState_bound                      2

#define d_Tag_create                                1
#define d_Tag_delete                                2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of supported view                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern SnmpMibView v_msiprip2; 

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rip\work.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: work.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and functions for IPRIP's work items.
//============================================================================

#ifndef _WORK_H_
#define _WORK_H_


//
// type definition of an input context
//

typedef struct _INPUT_CONTEXT {

    DWORD           IC_InterfaceIndex;
    DWORD           IC_AddrIndex;
    SOCKADDR_IN     IC_InputSource;
    DWORD           IC_InputLength;
    IPRIP_PACKET    IC_InputPacket;

} INPUT_CONTEXT, *PINPUT_CONTEXT;


//
// type definition of a demand-update context
//

typedef struct _UPDATE_CONTEXT {

    DWORD           UC_InterfaceIndex;
    DWORD           UC_RetryCount;
    DWORD           UC_RouteCount;

} UPDATE_CONTEXT, *PUPDATE_CONTEXT;



//
// these are the type definitions of the three functions 
// that are in each update buffer's function table
//

typedef DWORD (*PSTART_BUFFER_ROUTINE)(PVOID);
typedef DWORD (*PADD_ENTRY_ROUTINE)(PVOID, PRIP_IP_ROUTE);
typedef DWORD (*PFINISH_BUFFER_ROUTINE)(PVOID);


//
// this is the definition of an update buffer. It includes the command
// to be put in the IPRIP packet header, the destination for the buffer,
// and the three update-buffer functions
//

typedef struct _UPDATE_BUFFER {
    PIF_TABLE_ENTRY         UB_ITE;
    DWORD                   UB_AddrIndex;
    DWORD                   UB_Address;
    DWORD                   UB_Netmask;
    SOCKET                  UB_Socket;
    DWORD                   UB_Command;
    DWORD                   UB_Length;
    BYTE                    UB_Buffer[MAX_PACKET_SIZE];
    SOCKADDR_IN             UB_Destination;
    DWORD                   UB_DestAddress;
    DWORD                   UB_DestNetmask;
    PADD_ENTRY_ROUTINE      UB_AddRoutine;
    PSTART_BUFFER_ROUTINE   UB_StartRoutine;
    PFINISH_BUFFER_ROUTINE  UB_FinishRoutine;
} UPDATE_BUFFER, *PUPDATE_BUFFER;


VOID WorkerFunctionNetworkEvents(PVOID pContext);
VOID WorkerFunctionProcessTimer(PVOID pContext);
VOID WorkerFunctionProcessInput(PVOID pContext);
VOID WorkerFunctionStartFullUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionFinishFullUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionStartTriggeredUpdate(PVOID pContext);
VOID WorkerFunctionFinishTriggeredUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionStartDemandUpdate(PVOID pContext);
VOID WorkerFunctionFinishDemandUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionProcessRtmMessage(PVOID pContext);
VOID WorkerFunctionActivateInterface(PVOID pContext);
VOID WorkerFunctionDeactivateInterface(PVOID pContext);
VOID WorkerFunctionFinishStopProtocol(PVOID pContext);
VOID WorkerFunctionMibDisplay(PVOID pContext, BOOLEAN bNotUsed);


DWORD
SendRoutes(
    PIF_TABLE_ENTRY pIfList[],
    DWORD dwIfCount,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwAddrIndex
    );


VOID
ProcessRequest(
    PVOID pContext
    );


VOID
ProcessResponse(
    PVOID pContext
    );

DWORD
ProcessRtmNotification(
    RTM_ENTITY_HANDLE    hRtmHandle,    // not used
    RTM_EVENT_TYPE       retEventType,
    PVOID                pvContext1,    // not used
    PVOID                pvContext2     // not used
    );

VOID
CallbackFunctionProcessRtmMessage (
    PVOID   pContext, // not used
    BOOLEAN NotUsed
    );
    
VOID
CallbackFunctionProcessTimer (
    PVOID   pContext, // not used
    BOOLEAN NotUsed
    );
    
VOID
CallbackFunctionNetworkEvents (
    PVOID   pContext,
    BOOLEAN NotUsed
    );

DWORD
BlockDeleteRoutesOnInterface (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex
    );
    
#endif // _WORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\mibfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Sample subagent instrumentation callbacks.

--*/

#include    "precomp.h"
#pragma     hdrstop

DWORD
ConnectToRouter();

DWORD
GetGlobalConfigInfo(
    OUT PIPRIP_MIB_GET_OUTPUT_DATA *    ppimgod,
    OUT PDWORD                          pdwSize
);

DWORD
SetGlobalInfo(
    IN  AsnAny *                        objectArray
);

DWORD
UpdatePeerFilterTable(
    IN  AsnAny *                        objectArray,
    IN  DWORD                           dwOp
);

DWORD
AddPeerFilterEntry(
    IN  DWORD                           dwPeerAddr,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
DeletePeerFilterEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


DWORD
GetInterfaceInfo( 
    IN  UINT                            actionId,
    IN  PIPRIP_MIB_GET_INPUT_DATA       pimgidInData,
    OUT PIPRIP_MIB_GET_OUTPUT_DATA*     ppimgod,
    OUT PDWORD                          pdwOutSize
);

DWORD
ValidateInterfaceConfig(
    IN  AsnAny *                        objectArray
);

DWORD
SetInterfaceConfig(
    IN  AsnAny *                        objectArray
);

DWORD
UpdateUnicastPeerEntry(
    IN  AsnAny *                        objectArray,
    IN  DWORD                           dwOp
);

DWORD
AddUnicastPeerEntry(
    IN  DWORD                           dwPeer,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
DeleteUnicastPeerEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
UpdateFilterTable(
    IN  DWORD                           dwOp,
    IN  DWORD                           dwIfIndex,
    IN  DWORD                           dwFiltType,
    IN  PIPRIP_ROUTE_FILTER             pirfFilt
);



DWORD
AddFilterEntry(
    IN  DWORD                           dwFiltType,
    IN  PIPRIP_ROUTE_FILTER             pirfFilt,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


DWORD
DeleteFilterEntry(
    IN  DWORD                           dwFiltType,
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes               = (DWORD) -1,
                                    dwStatSize          = 0,
                                    dwConfigSize        = 0;
    
    buf_global*                     pbgBuffer           = NULL;

    PIPRIP_GLOBAL_STATS             pigsGlbStats        = NULL;
    PIPRIP_GLOBAL_CONFIG            pigcGlbConfig       = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodStatData      = NULL;
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodConfigData    = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;
    
    
    
    TraceEnter( "get_global" );

    switch ( actionId )
    {
    case MIB_ACTION_GET:
    case MIB_ACTION_GETFIRST:

        //
        // Retrieve global information in 2 parts.
        //
        //
        // First get global stats
        //
        imgidInData.IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodStatData,
            &dwStatSize,
            dwRes
        );
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }
        
        //
        // Next get global config
        //
        
        imgidInData.IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodConfigData,
            &dwConfigSize,
            dwRes
        );
        
                
        break;
    
    case MIB_ACTION_GETNEXT:
    default:
            TRACE1( "Wrong Action", actionId );
            return MIB_S_INVALID_PARAMETER;
    }

    //
    // if error print error message and free allocations
    //

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );

        if ( pimgodStatData ) { MprAdminMIBBufferFree ( pimgodStatData ); }

        if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

        return dwRes;
    }

    
    //
    // Set the return data.
    //

    //
    // Global Stats Data
    //
    
    pbgBuffer       = (buf_global*) objectArray;

    pigsGlbStats    = (PIPRIP_GLOBAL_STATS) pimgodStatData-> IMGOD_Buffer;
    
    SetAsnCounter( 
        &(pbgBuffer-> globalSystemRouteChanges), 
        pigsGlbStats-> GS_SystemRouteChanges 
    );

    SetAsnCounter(
        &(pbgBuffer-> globalTotalResponseSends),
        pigsGlbStats-> GS_TotalResponsesSent
    );

    //
    // Global config Data
    //
    
    pigcGlbConfig   = (PIPRIP_GLOBAL_CONFIG) pimgodConfigData-> IMGOD_Buffer;
    
    SetAsnInteger(
        &( pbgBuffer-> globalMaxRecQueueSize ),
        pigcGlbConfig-> GC_MaxRecvQueueSize 
    );

    SetAsnInteger(
        &( pbgBuffer-> globalMaxSendQueueSize ),
        pigcGlbConfig-> GC_MaxSendQueueSize
    );

    SetAsnTimeTicks(
        &( pbgBuffer-> globalMinTriggeredUpdateInterval ),
        pigcGlbConfig-> GC_MinTriggeredUpdateInterval
    );

    SetAsnInteger(
        &( pbgBuffer-> globalPeerFilterCount ),
        pigcGlbConfig-> GC_PeerFilterCount 
    );
    
    //
    // +1 added to adjust value to enumeration values in asn.
    // Enumeration in asn cannot have a value of 0. Causes a warning
    // to be generated by the asn compiler.
    //
    
    SetAsnInteger( 
        &(pbgBuffer-> globalLoggingLevel),
        pigcGlbConfig-> GC_LoggingLevel + 1
    );

    SetAsnInteger(
        &( pbgBuffer-> globalPeerFilterMode ),
        pigcGlbConfig-> GC_PeerFilterMode + 1
    );
    

    if ( pimgodStatData ) { MprAdminMIBBufferFree ( pimgodStatData ); }

    if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

    TraceLeave( "get_global" );

    return MIB_S_SUCCESS;
}



UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes           = MIB_S_SUCCESS,
                                    dwLogLevel      = 0,
                                    dwFiltMode      = 0;
    
    sav_global*                     psgBuffer       = (sav_global*) objectArray;
    
    
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
        TraceEnter( " set_global - validate " );
    
        //
        // Verify logging level
        //
        
        dwLogLevel = GetAsnInteger( 
                        &( psgBuffer-> globalLoggingLevel ),
                        0
                     );

        if ( dwLogLevel < d_globalLoggingLevel_none ||
             dwLogLevel > d_globalLoggingLevel_information )
        {
            dwRes = MIB_S_INVALID_PARAMETER;            
            TRACE1( "Invalid Logging level : %d\n", dwLogLevel );
        }

        //
        // Verify Peer Filter Mode 
        //

        dwFiltMode = GetAsnInteger(
                        &( psgBuffer-> globalPeerFilterMode ),
                        0
                     );

        if ( dwFiltMode < d_globalPeerFilterMode_disable ||
             dwFiltMode > d_globalPeerFilterMode_exclude )
        {
            dwRes = MIB_S_INVALID_PARAMETER;            
            TRACE1( "Invalid Peer Filter Mode level : %d\n", dwFiltMode );
        }

        TraceLeave( " set_global - validate " );
       
        break;


    case MIB_ACTION_SET :
    
        TraceEnter( " set_global - set " );
        
        dwRes = SetGlobalInfo( objectArray );

        TraceLeave( " set_global - set " );

        break;


    case MIB_ACTION_CLEANUP :

        TraceEnter( " set_global - cleanup " );

        TraceLeave( " set_global - cleanup " );
        
        break;


    default :
        TraceEnter( " set_global - Wrong action " );

        TraceLeave( " set_global - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }


    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwCurrentAddr = INADDR_NONE,
                                    dwInd       = 0,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    buf_globalPeerFilterEntry*      pbgpfe      = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    
    TraceEnter( "get_globalPeerFilterEntry" );
    
    pbgpfe = (buf_globalPeerFilterEntry*) objectArray;
    
    
    //
    // retrive the peer filter table
    //

    imgidInData.IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
    
    RIP_MIB_GET(
        &imgidInData,
        sizeof( IPRIP_MIB_GET_INPUT_DATA ),
        &pimgodOutData,
        &dwGetSize,
        dwRes
    );
    

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    pigc = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

    if ( !pigc-> GC_PeerFilterCount )
    {
        TRACE0( "No Peer Entries" );
        MprAdminMIBBufferFree( pimgodOutData );
        return MIB_S_NO_MORE_ENTRIES;
    }
    
    pdwAddrTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

    
    //
    // Locate current entry in Peer filter table
    //

    dwCurrentAddr = GetAsnIPAddress( &( pbgpfe-> globalPFAddr ), 0 );

    FIND_PEER_ENTRY( 
        dwCurrentAddr, 
        pigc-> GC_PeerFilterCount, 
        pdwAddrTable,
        dwInd
    );
    

    //
    // get requested entry
    //
    
    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    
    case MIB_ACTION_GET :

        //
        // This is an idempotent case, since retieving a peer address
        // requires the peer address as index.
        // It is only useful to verify the presence of a particular peer.
        // 
        
        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0(  "Peer Entry not found" );
        }

        break;

    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 (if available )
        //
        
        dwInd = 0;
        
        if ( !pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Peer filter entry not found" );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Peer Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwInd++;

        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
            TRACE0( "No more Peer Entries" );
            break;
        }

        break;

    default :

        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }


    //
    // set index for next retrieval
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnIPAddress( 
            &( pbgpfe-> globalPFAddr ),
            &( pbgpfe-> dwPeerFilterAddr ),
            pdwAddrTable[ dwInd ]
        );
    }
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_globalPeerFilterEntry" );

    return dwRes;

}


UINT
set_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes   = MIB_S_SUCCESS,
                                    dwAddr  = INADDR_NONE,
                                    dwOp    = 0;
    
    sav_globalPeerFilterEntry*      psgpfe  = NULL;


    TraceEnter( " set_globalPeerFilterEntry " );

    psgpfe = (sav_globalPeerFilterEntry*) objectArray;
    

    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
    
        //
        // Verify if the specified IP address is valid.
        //

        dwAddr = GetAsnIPAddress( &( psgpfe-> globalPFAddr ), INADDR_NONE );

        if ( !dwAddr || dwAddr == INADDR_NONE )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Peer address specified" );
        }

        //
        // Verify operation tag
        //

        dwRes = GetAsnInteger( &( psgpfe-> globalPFTag ), 0 );

        if ( dwRes != d_Tag_create && dwRes != d_Tag_delete )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Operation specified" );
        }
        
        break;

        
    case MIB_ACTION_SET :

        dwOp = GetAsnInteger( &( psgpfe-> globalPFTag ), 0 );

        dwRes = UpdatePeerFilterTable( objectArray, dwOp );
        
        break;


    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_globalPeerFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( " set_globalPeerFilterEntry " );
    
    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    buf_ifStatsEntry *              pbifse      = NULL;

    PIPRIP_IF_STATS                 piis        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    TraceEnter( "get_ifStatsEntry" );
    
    //
    // Retrieve Specified interface info.
    //

    pbifse                      = (buf_ifStatsEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_STATS_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifse-> ifSEIndex ), 
                                    0
                                  );

    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
   dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
            
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }


    //
    // Set interface stats in return buffer
    //

    piis = (PIPRIP_IF_STATS) (pimgodOutData-> IMGOD_Buffer);

    SetAsnInteger( &( pbifse-> ifSEState ), piis-> IS_State );

    SetAsnCounter( &( pbifse-> ifSESendFailures ), piis-> IS_SendFailures );
    
    SetAsnCounter( &( pbifse-> ifSEReceiveFailures ), piis-> IS_ReceiveFailures );

    SetAsnCounter( &( pbifse-> ifSERequestSends ), piis-> IS_RequestsSent );

    SetAsnCounter( &( pbifse-> ifSEResponseSends ), piis-> IS_ResponsesSent );

    SetAsnCounter( 
        &( pbifse-> ifSEResponseReceiveds ), 
        piis-> IS_ResponsesReceived 
    );

    SetAsnCounter( 
        &( pbifse-> ifSEBadResponsePacketReceiveds ), 
        piis-> IS_BadResponsePacketsReceived
    );

    SetAsnCounter( 
        &( pbifse-> ifSEBadResponseEntriesReceiveds ), 
        piis-> IS_BadResponseEntriesReceived
    );
    
    SetAsnCounter( 
        &( pbifse-> ifSETriggeredUpdateSends ), 
        piis-> IS_TriggeredUpdatesSent
    );

    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifse-> ifSEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );
    

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    TraceLeave( "get_ifStatsEntry" );
    
    return MIB_S_SUCCESS ;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifConfigEntry*              pbifce      = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    BYTE                            pbAuthKey[ IPRIP_MAX_AUTHKEY_SIZE ];
    

    TraceEnter( " get_ifConfigEntry " );

    //
    // retrieve interface config.
    //
    
    pbifce                      = (buf_ifConfigEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( &( pbifce-> ifCEIndex ), 0 );
                                    
    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piic = (PIPRIP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifce-> ifCEState ), piic-> IC_State );

    SetAsnInteger( &( pbifce-> ifCEMetric ), piic-> IC_Metric );

    SetAsnInteger( &( pbifce-> ifCEUpdateMode ), piic-> IC_UpdateMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEAcceptMode ), piic-> IC_AcceptMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEAnnounceMode ), piic-> IC_AnnounceMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEProtocolFlags ), piic-> IC_ProtocolFlags );

    SetAsnTimeTicks( 
        &( pbifce-> ifCERouteExpirationInterval ), 
        piic-> IC_RouteExpirationInterval
    );

    SetAsnTimeTicks( 
        &( pbifce-> ifCERouteRemovalInterval ), 
        piic-> IC_RouteRemovalInterval 
    );

    SetAsnTimeTicks( 
        &( pbifce-> ifCEFullUpdateInterval ), 
        piic-> IC_FullUpdateInterval 
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAuthenticationType ), 
        piic-> IC_AuthenticationType
    );

    SetAsnInteger( &( pbifce-> ifCERouteTag ), piic-> IC_RouteTag );

    SetAsnInteger( 
        &( pbifce-> ifCEUnicastPeerMode ), 
        piic-> IC_UnicastPeerMode + 1 
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAcceptFilterMode ), 
        piic-> IC_AcceptFilterMode  + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAnnounceFilterMode ), 
        piic-> IC_AnnounceFilterMode + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEUnicastPeerCount ), 
        piic-> IC_UnicastPeerCount + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAcceptFilterCount ), 
        piic-> IC_AcceptFilterCount
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAnnounceFilterCount ), 
        piic-> IC_AnnounceFilterCount
    );

    //
    // As per RFC 1724, this field is a write only field.
    // Authentication may not be bypassed by reading the key.
    // The default value to be returned is a null string.
    //
    
    ZeroMemory( pbAuthKey, IPRIP_MAX_AUTHKEY_SIZE );

    SetAsnOctetString(
        &( pbifce-> ifCEAuthenticationKey ),
        pbifce-> pbAuthKey,
        pbAuthKey,
        IPRIP_MAX_AUTHKEY_SIZE
    );
        
    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifce-> ifCEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifConfigEntry " );

    return MIB_S_SUCCESS;
}


UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1;

    TraceEnter( " set_ifConfigEntry " );

    switch ( actionId )
    {
    
    case MIB_ACTION_VALIDATE :
    
        dwRes = ValidateInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_SET :

        dwRes = SetInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_CLEANUP :
    
        dwRes = MIB_S_SUCCESS;
        
        break;


    default :
    
        TRACE0( " set_ifConfigEntry - wrong action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }

    
    TraceLeave( "set_ifConfigEntry" );

    return dwRes ;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwPeer      = INADDR_NONE,
                                    dwInd       = (DWORD) -1;

    PDWORD                          pdwAddrTable= NULL;
    
    buf_ifUnicastPeersEntry*        pbifupe     = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;



    TraceEnter( " get_ifUnicastPeerEntry " );

    //
    // retrieve interface config.
    //
    
    pbifupe                     = (buf_ifUnicastPeersEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( &( pbifupe-> ifUPIfIndex ), 0 );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // Locate peer entry
    //

    dwPeer = GetAsnIPAddress( &( pbifupe-> ifUPAddress ), 0 );
    
    piic = (PIPRIP_IF_CONFIG) ( pimgodOutData-> IMGOD_Buffer );

    pdwAddrTable = IPRIP_IF_UNICAST_PEER_TABLE( piic );

    FIND_PEER_ENTRY(
        dwPeer,
        piic-> IC_UnicastPeerCount,
        pdwAddrTable,
        dwInd
    );
    
    
    //
    // return requested peer entry
    //

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :

        //
        // idempotent case.  Only possible use is to verify 
        // specific peer present.
        //

        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Unicast Peer entry not found" );
        }
        
        break;


    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 if available
        //

        dwInd = 0;
        
        if ( !piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more Peer Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Unicast Peer Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwInd++;

        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more Peer Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );

            break;
        }

        break;
        
    default :
    
        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    }

    //
    // set index value for next retrieval.
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pbifupe-> ifUPIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );

        ForceSetAsnIPAddress( 
            &( pbifupe-> ifUPAddress ),
            &( pbifupe-> dwUnicastPeerAddr ),
            pdwAddrTable[ dwInd ]
        );

    }        
        
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    TraceLeave( "get_ifUnicastPeersEntry " );
    
    return dwRes;
}


UINT
set_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes   = (DWORD) -1,
                                    dwOp    = 0,
                                    dwAddr  = INADDR_NONE;
    
    sav_ifUnicastPeersEntry*        psifupe = NULL;



    TraceEnter( " set_ifUnicastPeersEntry " );

    psifupe = (sav_ifUnicastPeersEntry*) objectArray;
    

    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
    
        //
        // Verify if the specified IP address is valid.
        //

        dwAddr = GetAsnIPAddress( &( psifupe-> ifUPAddress ), INADDR_NONE );

        if ( !dwAddr || dwAddr == INADDR_NONE )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Peer address specified" );
            break;
        }

        //
        // Verify operation tag
        //

        dwRes = GetAsnInteger( &( psifupe-> ifUPTag ), 0 );

        if ( dwRes != d_Tag_create && dwRes != d_Tag_delete )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Operation specified" );
            break;
        }
        
        dwRes = MIB_S_SUCCESS;
        
        break;

        
    case MIB_ACTION_SET :

        dwOp = GetAsnInteger( &( psifupe-> ifUPTag ), 0 );

        dwRes = UpdateUnicastPeerEntry( objectArray, dwOp );
        
        break;


    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifUnicastPeersEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( " set_ifUnicastPeersEntry " );
    
    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes           = (DWORD) -1,
                                    dwIndex         = 0,
                                    dwGetSize       = 0;
                                
    PIPRIP_IF_CONFIG                piic            = NULL;

    PIPRIP_ROUTE_FILTER             pFiltTable      = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData   = NULL;

    buf_ifAcceptRouteFilterEntry *  pgifRF    = NULL;

    IPRIP_ROUTE_FILTER              irf;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( "get_ifAcceptRouteFilterEntry" );

    //
    // retrieve interface Info
    //

    pgifRF = (buf_ifAcceptRouteFilterEntry*) objectArray;

    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger(
                                    &( pgifRF-> ifAcceptRFIfIndex ),
                                    0
                                  );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }
    

    //
    // Find accept filter
    //
    
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( pgifRF-> ifAcceptRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( pgifRF-> ifAcceptRFHiAddress ),
                            INADDR_NONE
                        );

    piic            = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

    pFiltTable      = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
            
    FIND_FILTER(
        &irf,
        piic-> IC_AcceptFilterCount,
        pFiltTable,
        dwIndex
    );
    

    //
    // retrieve requested entry
    //
    
    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :   

        //
        // Idempotent case 
        //

        if ( dwIndex >= piic-> IC_AcceptFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Accept filter not found" );
        }
        
        break;

    case MIB_ACTION_GETFIRST :

        dwIndex = 0;
        
        if ( !piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Accept filters present " );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        if ( dwIndex >= piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Accept filters present " );
        }

        dwIndex++;

        if ( dwIndex >= piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
            TRACE0( "No More Accept filters present " );
        }
        
        break;
        
    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( "get_ifAcceptRouteFilterEntry - Wrong Action " );
        
        break;
        
    }

    //
    // set index for next retrieveal
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger( 
            &( pgifRF-> ifAcceptRFIfIndex ),
            pimgodOutData-> IMGOD_IfIndex 
        );

        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAcceptRFLoAddress ), 
            &( pgifRF-> dwFilterLoAddr ),
            pFiltTable[ dwIndex ].RF_LoAddress
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAcceptRFHiAddress ),
            &( pgifRF-> dwFilterHiAddr ),
            pFiltTable[ dwIndex ].RF_HiAddress
        );
    }
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_ifAcceptRouteFilterEntry" );

    return dwRes;
}


UINT
set_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                       dwRes   = (DWORD) -1,
                                dwIndex = 0,
                                dwTag   = 0;

    sav_ifAcceptRouteFilterEntry* psifRF  = NULL;

    IPRIP_ROUTE_FILTER          irf;

    
    
    TraceEnter( "set_ifAcceptRouteFilterEntry" );

    psifRF = (sav_ifAcceptRouteFilterEntry*) objectArray;

    dwIndex = GetAsnInteger(
                &( psifRF-> ifAcceptRFIfIndex ),
                0
              );
              
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( psifRF-> ifAcceptRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( psifRF-> ifAcceptRFHiAddress ),
                            INADDR_NONE
                        );

    dwTag = GetAsnInteger(
                &( psifRF-> ifAcceptRFTag ),
                0
            );

            
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :

        //
        // Check filter ranges are valid address
        //

        if ( !irf.RF_LoAddress || irf.RF_LoAddress == INADDR_NONE ||
             !irf.RF_HiAddress || irf.RF_HiAddress == INADDR_NONE ||
             ( dwTag != d_Tag_create && dwTag != d_Tag_delete ) )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( "Invalid parameter value " );
        }
        break;

    case MIB_ACTION_SET :

        dwRes = UpdateFilterTable(
                    dwTag,
                    dwIndex,
                    RIP_MIB_ACCEPT_FILTER,
                    &irf
                );
        break;

    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifAcceptRouteFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( "set_ifAcceptRouteFilterEntry" );

    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                               dwRes           = (DWORD) -1,
                                        dwIndex         = 0,
                                        dwGetSize       = 0;
                                        
    IPRIP_ROUTE_FILTER                  irf;

    IPRIP_MIB_GET_INPUT_DATA            imgidInData;

    PIPRIP_IF_CONFIG                    piic            = NULL;

    PIPRIP_ROUTE_FILTER                 pFiltTable      = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA          pimgodOutData   = NULL;

    buf_ifAnnounceRouteFilterEntry *    pgifRF    = NULL;

    
    
    TraceEnter( "get_ifAnnounceRouteFilterEntry" );

    //
    // retrieve interface Info
    //

    pgifRF = (buf_ifAnnounceRouteFilterEntry*) objectArray;

    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger(
                                    &( pgifRF-> ifAnnounceRFIfIndex ),
                                    0
                                  );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }
    
    //
    // find specfied filter
    //
    
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( pgifRF-> ifAnnounceRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( pgifRF-> ifAnnounceRFHiAddress ),
                            INADDR_NONE
                        );

    piic            = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

    pFiltTable      = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
            
    FIND_FILTER(
        &irf,
        piic-> IC_AnnounceFilterCount,
        pFiltTable,
        dwIndex
    );
    
    //
    // get filter info.
    //

    dwRes = MIB_S_SUCCESS;
            
    switch ( actionId )
    {
    case MIB_ACTION_GET :   

        //
        // Idempotent case 
        //

        if ( dwIndex >= piic-> IC_AnnounceFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Announce filter not found" );
        }
        
        break;

    case MIB_ACTION_GETFIRST :

        dwIndex = 0;
        
        if ( !piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Announce filters present " );
        }

        break;

    case MIB_ACTION_GETNEXT :

        if ( dwIndex >= piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Announce filters present " );
        }

        dwIndex++;

        if ( dwIndex >= piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = ERROR_NO_MORE_ITEMS;
            TRACE0( "No More Announce filters present " );
        }
        
        dwRes = MIB_S_SUCCESS;

        break;
        
    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( "get_ifAnnounceRouteFilterEntry - Wrong Action " );
        
        break;
        
    }

    //
    // set up the indices for next retrieval
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pgifRF-> ifAnnounceRFIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAnnounceRFLoAddress ),
            &( pgifRF-> dwFilterLoAddr ),
            pFiltTable[ dwIndex ].RF_LoAddress
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAnnounceRFHiAddress ),
            &( pgifRF-> dwFilterHiAddr ),
            pFiltTable[ dwIndex ].RF_HiAddress
        );
    }

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_ifAnnounceRouteFilterEntry" );

    return dwRes;
    
}    


UINT
set_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                       dwRes   = (DWORD) -1,
                                dwIndex = 0,
                                dwTag   = 0;

    sav_ifAnnounceRouteFilterEntry*    psifRF  = NULL;

    IPRIP_ROUTE_FILTER          irf;

    
    
    TraceEnter( "set_ifAnnounceRouteFilterEntry" );

    psifRF = (sav_ifAnnounceRouteFilterEntry*) objectArray;

    dwIndex = GetAsnInteger(
                &( psifRF-> ifAnnounceRFLoAddress ),
                0
              );
              
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( psifRF-> ifAnnounceRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( psifRF-> ifAnnounceRFHiAddress ),
                            INADDR_NONE
                        );

    dwTag = GetAsnInteger(
                &( psifRF-> ifAnnounceRFTag ),
                0
            );

            
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :

        //
        // Check filter ranges are valid address
        //

        if ( !irf.RF_LoAddress || irf.RF_LoAddress == INADDR_NONE ||
             !irf.RF_HiAddress || irf.RF_HiAddress == INADDR_NONE ||
             ( dwTag != d_Tag_create && dwTag != d_Tag_delete ) )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( "Invalid parameter value " );
        }
        break;

    case MIB_ACTION_SET :

        dwRes = UpdateFilterTable(
                    dwTag,
                    dwIndex,
                    RIP_MIB_ANNOUNCE_FILTER,
                    &irf
                );
        break;

    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifAnnounceRouteFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( "set_ifAnnounceRouteFilterEntry" );

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifBindingEntry*             pbifb       = NULL;

    PIPRIP_IF_BINDING               piib        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( " get_ifBindingEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifb                       = (buf_ifBindingEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifb-> ifBindingIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piib = (PIPRIP_IF_BINDING) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifb-> ifBindingState ), piib-> IB_State + 1 );

    SetAsnCounter( &( pbifb-> ifBindingCounts ), piib-> IB_AddrCount );

    ForceSetAsnInteger(
        &( pbifb-> ifBindingIndex ),
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifBindingEntry " );

    return MIB_S_SUCCESS ;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwIndex     = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifAddressEntry *            pbifae      = NULL;

    PIPRIP_IF_BINDING               piib        = NULL;

    PIPRIP_IP_ADDRESS               pia         = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_IP_ADDRESS                ipa;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( " get_ifAddressEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifae                      = (buf_ifAddressEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifae-> ifAEIfIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // retrieve IPAddress from IP Address table
    //

    ipa.IA_Address  = GetAsnIPAddress(
                        &( pbifae-> ifAEAddress),
                        INADDR_NONE
                      );

    ipa.IA_Netmask  = GetAsnIPAddress(
                        &( pbifae-> ifAEMask),
                        INADDR_NONE
                      );
                      
    piib            = (PIPRIP_IF_BINDING) pimgodOutData-> IMGOD_Buffer;

    pia             = (PIPRIP_IP_ADDRESS) IPRIP_IF_ADDRESS_TABLE( piib );

    FIND_IP_ADDRESS(
        ipa,
        piib-> IB_AddrCount,
        pia,
        dwIndex
    );


    //
    // set appr fields
    //

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :

        //
        // idempotent case.  Only possible use is to verify 
        // specific peer present.
        //

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address entry not found" );
        }
        
        break;


    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 if available
        //

        dwIndex = 0;
        
        if ( !piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwIndex++;

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );

            break;
        }

        dwRes = MIB_S_SUCCESS;
        
        break;
        
    default :
    
        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    }

    //
    // set index for next retieval
    //

    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pbifae-> ifAEIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEAddress ),
            &( pbifae-> dwAddress ),
            pia[ dwIndex ].IA_Address
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEMask ),
            &( pbifae-> dwMask ),
            pia[ dwIndex ].IA_Netmask
        );
    }
    
    if ( pimgodOutData )  { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifAddressEntry " );

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifPeerStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifPeerStatsEntry*           pbifpse     = NULL;

    PIPRIP_PEER_STATS               pips        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( "get_ifPeerStatsEntry" );

    //
    // retrieve interface config.
    //
    
    pbifpse                         = (buf_ifPeerStatsEntry*) objectArray;
    
    imgidInData.IMGID_TypeID        = IPRIP_PEER_STATS_ID;
    
    imgidInData.IMGID_PeerAddress   = (DWORD) GetAsnIPAddress(
                                                &( pbifpse-> ifPSAddress ),
                                                0
                                              );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_PeerAddress )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetPeerStatsInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    pips = (PIPRIP_PEER_STATS) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( 
        &( pbifpse-> ifPSLastPeerRouteTag ), 
        pips-> PS_LastPeerUpdateTickCount 
    );

    SetAsnTimeTicks( 
        &( pbifpse-> ifPSLastPeerUpdateTickCount ), 
        pips-> PS_LastPeerUpdateTickCount 
    );

    SetAsnInteger( 
        &( pbifpse-> ifPSLastPeerUpdateVersion ), 
        pips-> PS_LastPeerUpdateVersion 
    );
    
    SetAsnCounter( 
        &( pbifpse-> ifPSPeerBadResponsePackets ), 
        pips-> PS_BadResponsePacketsFromPeer 
    );
    
    SetAsnCounter( 
        &( pbifpse-> ifPSPeerBadResponseEntries ), 
        pips-> PS_BadResponseEntriesFromPeer 
    );

    //
    // Set index for next retrieval
    //
    
    ForceSetAsnIPAddress(
        &( pbifpse-> ifPSAddress ),
        &( pbifpse-> dwPeerAddr ),
        pimgodOutData-> IMGOD_PeerAddress
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifPeerStatsEntry " );

    return MIB_S_SUCCESS ;
}


DWORD
GetGlobalConfigInfo(
    OUT PIPRIP_MIB_GET_OUTPUT_DATA *    ppimgod,
    OUT PDWORD                          pdwSize
)
{

    DWORD                           dwRes           = (DWORD) -1;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData   = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    
    do
    {
        //
        // retrieve global config 
        //

        imgidInData.IMGID_TypeID    = IPRIP_GLOBAL_CONFIG_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwSize,
            dwRes
        );
        

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        *ppimgod = pimgodOutData;
        
    } while ( FALSE );

    return dwRes;
}

//
// SetGlobalInfo
//
//
//  Sets the global RIP info.
//

DWORD
SetGlobalInfo(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_global*                     psg         = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;


    do
    {
        //
        // Retrieve the global config Data first
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        pigc    = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;
    

        psg     = (sav_global*) objectArray;
        
        //
        // Allocate set info buffer
        //
        
        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_GLOBAL_CONFIG_SIZE( pigc );

        pimsidInData = 
            (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );
        
        if ( pimsidInData == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "SetGlobalData - Mem. alloc failed" );
            break;
        }
        
        //
        // Set config info fields.
        // if the variable is not specified, we
        // set the field to its previous value i.e. an empty assignment.
        //

        pimsidInData-> IMSID_TypeID     = IPRIP_GLOBAL_CONFIG_ID;
        pimsidInData-> IMSID_IfIndex    = (DWORD) -1;

        pimsidInData-> IMSID_BufferSize = IPRIP_GLOBAL_CONFIG_SIZE( pigc );

        pigc-> GC_MaxRecvQueueSize      = GetAsnInteger(
                                            &( psg-> globalMaxRecQueueSize ),
                                            pigc-> GC_MaxRecvQueueSize
                                          );

        pigc-> GC_MaxSendQueueSize      = GetAsnInteger(
                                            &( psg-> globalMaxSendQueueSize ),
                                            pigc-> GC_MaxSendQueueSize
                                          );

        pigc-> GC_MinTriggeredUpdateInterval = GetAsnTimeTicks(
                                    &( psg-> globalMinTriggeredUpdateInterval ),
                                    pigc-> GC_MinTriggeredUpdateInterval
                                 );

        //
        // -1 is subtracted from the enumerated fields to adjust
        // the ASN enumeration values to the actual values.
        // This is required since the enumeration cannot have 
        // a zero value as per the ASN compiler, but one of the
        // actual values for the field in the config is a zero.
        //
        // as a caveat, if the enumerated field is not specified in 
        // this set operation, to preserve the value of the field
        // in the config, we first increment it.  This way on the 
        // -1 operation the value is restored.  
        //
        pigc-> GC_LoggingLevel++;
        pigc-> GC_LoggingLevel          = GetAsnInteger( 
                                            &( psg-> globalLoggingLevel ), 
                                            pigc-> GC_LoggingLevel
                                          ) - 1;

        pigc-> GC_PeerFilterMode++;
        pigc-> GC_PeerFilterMode        = GetAsnInteger(
                                            &( psg-> globalPeerFilterMode ),
                                            pigc-> GC_PeerFilterMode
                                          ) - 1;

        CopyMemory( 
            (PVOID) pimsidInData-> IMSID_Buffer, 
            (PVOID*) pigc, 
            IPRIP_GLOBAL_CONFIG_SIZE( pigc ) 
        );

        //
        // Save the info. in the MIB
        //
        
        RIP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    //
    // Free allocations
    //
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { RIP_MIB_FREE( pimsidInData ); }
    
    return dwRes;
}


DWORD
UpdatePeerFilterTable(
    IN  AsnAny *        objectArray,
    IN  DWORD           dwOp
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwInd       = 0,
                                    dwPeerAddr  = INADDR_NONE,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= 0;                                    

    sav_globalPeerFilterEntry*      psgpfe      = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;


    do
    {
        //
        // Get global info
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

                
        //
        // Find filter entry
        //

        psgpfe      = (sav_globalPeerFilterEntry*) objectArray;

        dwPeerAddr  = GetAsnIPAddress( 
                        &( psgpfe-> globalPFAddr ), 
                        0 
                      );
        

        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        pdwAddrTable= IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        FIND_PEER_ENTRY(
            dwPeerAddr,
            pigc-> GC_PeerFilterCount,
            pdwAddrTable,
            dwInd
        );

        //
        // if operation is filter add
        //
        
        if ( dwOp == d_Tag_create )
        {
            //
            // if peer already present, quit
            //
            
            if ( pigc-> GC_PeerFilterCount &&
                 dwInd < pigc-> GC_PeerFilterCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            else
            {
                dwRes = AddPeerFilterEntry( 
                            dwPeerAddr, 
                            pimgodOutData
                        );
            }

            break;
        }

        //
        // operation is filter delete
        //

        //
        // if peer is not present quit.
        //
        
        if ( !pigc-> GC_PeerFilterCount ||
             dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeletePeerFilterEntry(
                    dwInd,
                    pimgodOutData
                );
                
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
    
}


DWORD
AddPeerFilterEntry(
    IN  DWORD                       dwPeerAddr,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{


    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;

    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;


    
    do
    {
        //
        // Peer needs to be added.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                      IPRIP_GLOBAL_CONFIG_SIZE( pigc ) + sizeof( DWORD );

        pimsid      = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "AddPeerFilterEntry - out of memory" );
            break;
        }

        //
        // Add filter
        //

        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPRIP_GLOBAL_CONFIG_SIZE( pigc ) +
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            IPRIP_GLOBAL_CONFIG_SIZE( pigc )
        );

        pigc = (PIPRIP_GLOBAL_CONFIG) pimsid-> IMSID_Buffer;

        pdwAddrTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );        

        pdwAddrTable[ pigc-> GC_PeerFilterCount ] = dwPeerAddr;

        pigc-> GC_PeerFilterCount++;

        //
        // Update MIB
        //
        
        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }
    
    return dwRes;
}


DWORD
DeletePeerFilterEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
)
{


    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0,
                                    dwSrc       = 0,
                                    dwDst       = 0;

    PDWORD                          pdwSrcTable = NULL,
                                    pdwDstTable = NULL;
    
    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;

    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;


    
    do
    {
        //
        // Peer needs to be added.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                      IPRIP_GLOBAL_CONFIG_SIZE( pigc ) - sizeof( DWORD );

        pimsid      = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "AddPeerFilterEntry - out of memory" );
            break;
        }

        //
        // Delete filter
        //

        //
        // Copy base global config structure
        //
        
        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPRIP_GLOBAL_CONFIG_SIZE( pigc ) -
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            sizeof( IPRIP_GLOBAL_CONFIG )
        );

        //
        // Copy peer table. Skip entry to be deleted
        //
        
        pdwSrcTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        pigc        = ( PIPRIP_GLOBAL_CONFIG ) pimsid-> IMSID_Buffer;

        pdwDstTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        DELETE_PEER_ENTRY(
            dwIndex,
            pigc-> GC_PeerFilterCount,
            pdwSrcTable,
            pdwDstTable
        );
        
        
        pigc-> GC_PeerFilterCount--;

        //
        // Update MIB
        //
        
        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }
    
    return dwRes;
}


DWORD
GetInterfaceInfo( 
    IN  UINT                        actionId,
    IN  PIPRIP_MIB_GET_INPUT_DATA   pimgidInData,
    OUT PIPRIP_MIB_GET_OUTPUT_DATA* ppimgod,
    OUT PDWORD                      pdwOutSize
)
{

    DWORD                       dwRes           = (DWORD) -1;
    
    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData   = NULL;

    
    *ppimgod = NULL;
    

    switch ( actionId )
    {
    case MIB_ACTION_GET :

        RIP_MIB_GET(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if (( dwRes == ERROR_INVALID_PARAMETER ) || 
            ( dwRes == ERROR_NOT_FOUND ))
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
        }

        break;

    case MIB_ACTION_GETFIRST :

        RIP_MIB_GETFIRST(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    case MIB_ACTION_GETNEXT :
    
        RIP_MIB_GETNEXT(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER || pimgodOutData==NULL)
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            break;
        }

        //
        // Get Next wraps to the next table at the end of the
        // entries in the current table.  To flag the end of a table,
        // check the end of the table.
        //
    
        if ( pimgidInData-> IMGID_TypeID != pimgodOutData-> IMGOD_TypeID )
        {
            MprAdminMIBBufferFree( pimgodOutData );
        
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    
    }

    if ( dwRes == NO_ERROR )
    {
        *ppimgod = pimgodOutData;
    }

    return dwRes;
}


DWORD
ValidateInterfaceConfig(
    IN  AsnAny *        objectArray
)
{
    DWORD                   dwRes       = MIB_S_INVALID_PARAMETER,
                            dwMetric    = (DWORD) -1,
                            dwMode      = (DWORD) -1;
    
    sav_ifConfigEntry*      psifce      = (sav_ifConfigEntry*) objectArray;

    
    do
    {
        //
        // verify metric is in [0..16]
        //

        dwMetric = GetAsnInteger( &( psifce-> ifCEMetric ), (DWORD) -1 );

        if ( dwMetric > 16 )
        {
            TRACE1( " Invalid metric (%d) specified ", dwMetric );
            break;            
        }


        //
        // verify update, annouce, accept modes
        //

        dwMode = GetAsnInteger( &( psifce-> ifCEUpdateMode ), (DWORD) -1 );

        if ( dwMode != d_ifCEUpdateMode_periodic &&
             dwMode != d_ifCEUpdateMode_demand )
        {
            TRACE1( " Invalid update mode (%d) specified ", dwMode );
            break;
        }

        dwMode = GetAsnInteger( &( psifce-> ifCEAcceptMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEAcceptMode_disable ||
             dwMode > d_ifCEAcceptMode_rip2 )
        {
            TRACE1( " Invalid Accept mode (%d) specified ", dwMode );
            break;
        }
        
        dwMode = GetAsnInteger( &( psifce-> ifCEAnnounceMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEAnnounceMode_disable ||
             dwMode > d_ifCEAnnounceMode_rip2 )
        {
            TRACE1( " Invalid Announce mode (%d) specified ", dwMode );
            break;
        }

        //
        // Verify protcol flags, authentication type
        //

        dwMode = GetAsnInteger( &( psifce-> ifCEProtocolFlags ), (DWORD) -1 );

        if ( dwMode > MAX_PROTOCOL_FLAG_VALUE )
        {
            TRACE1( " Invalid protocol flags (%d) specified ", dwMode );
            break;
        }
        
        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAuthenticationType ), 
                    (DWORD) -1
                 );

        if ( dwMode < d_ifCEAuthenticationType_noAuthentication ||
             dwMode > d_ifCEAuthenticationType_md5 )
        {
            TRACE1( " Invalid authentication type (%d) specified ", dwMode );
            break;
        }
        
        //
        // Verify Unicast peer, Announce/Accept filter modes
        //
        
        dwMode = GetAsnInteger( &( psifce-> ifCEUnicastPeerMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEUnicastPeerMode_disable ||
             dwMode > d_ifCEUnicastPeerMode_peerOnly )
        {
            TRACE1( " Invalid Unicast Peer mode (%d) specified ", dwMode );
            break;
        }

        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAcceptFilterMode ), 
                    (DWORD) -1 
                 );

        if ( dwMode < d_ifCEAcceptFilterMode_disable ||
             dwMode > d_ifCEAcceptFilterMode_exclude )
        {
            TRACE1( " Invalid Accept Filter mode (%d) specified ", dwMode );
            break;
        }

        
        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAnnounceFilterMode ), 
                    (DWORD) -1 
                 );

        if ( dwMode < d_ifCEAnnounceFilterMode_disable ||
             dwMode > d_ifCEAnnounceFilterMode_exclude )
        {
            TRACE1( " Invalid Announce Filter mode (%d) specified ", dwMode );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
SetInterfaceConfig(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_ifConfigEntry*              psifce      = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    do
    {
        //
        // Retrieve existing interface config
        //

        psifce                      = (sav_ifConfigEntry*) objectArray;

        imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

        imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                        &( psifce-> ifCEIndex ),
                                        (DWORD) -1
                                      );

        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // Update fields
        //

        piic = (PIPRIP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);

        piic-> IC_Metric = GetAsnInteger( 
                                &( psifce-> ifCEMetric ),
                                piic-> IC_Metric
                            );

                                   
        piic-> IC_UpdateMode = GetAsnInteger( 
                                    &( psifce-> ifCEUpdateMode ),
                                    piic-> IC_UpdateMode
                                );

        piic-> IC_AcceptMode = GetAsnInteger(
                                    &( psifce-> ifCEAcceptMode ),
                                    piic-> IC_AcceptMode
                                );

        piic-> IC_AnnounceMode = GetAsnInteger(
                                    &( psifce-> ifCEAnnounceMode ),
                                    piic-> IC_AnnounceMode
                                );

        piic-> IC_ProtocolFlags = GetAsnInteger(
                                    &( psifce-> ifCEProtocolFlags ),
                                    piic-> IC_ProtocolFlags
                                  );
                                
        piic-> IC_RouteExpirationInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCERouteExpirationInterval ),
                                    piic-> IC_RouteExpirationInterval
                                );
                               
        piic-> IC_RouteRemovalInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCERouteRemovalInterval ),
                                    piic-> IC_RouteRemovalInterval
                               );

        piic-> IC_FullUpdateInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCEFullUpdateInterval ),
                                    piic-> IC_FullUpdateInterval
                               );

        piic-> IC_AuthenticationType = GetAsnInteger(
                                    &( psifce-> ifCEAuthenticationType ),
                                    piic-> IC_AuthenticationType
                                  );

        GetAsnOctetString(
            piic-> IC_AuthenticationKey,
            &( psifce-> ifCEAuthenticationKey )
        );

        piic-> IC_RouteTag = (USHORT) GetAsnInteger(
                                    &( psifce-> ifCERouteTag ),
                                    piic-> IC_RouteTag
                                  );
        
        piic-> IC_UnicastPeerMode = GetAsnInteger(
                                    &( psifce-> ifCEUnicastPeerMode ),
                                    piic-> IC_UnicastPeerMode
                                  );

        piic-> IC_AcceptFilterMode = GetAsnInteger(
                                    &( psifce-> ifCEAcceptFilterMode ),
                                    piic-> IC_AcceptFilterMode
                                  );

        piic-> IC_AnnounceFilterMode = GetAsnInteger(
                                    &( psifce-> ifCEAnnounceFilterMode ),
                                    piic-> IC_AnnounceFilterMode
                                  );

        //
        // Save inteface config
        //

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piic );

        pimsidInData = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsidInData )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( " Not enough memory " );
            break;
        }

        pimsidInData-> IMSID_TypeID     = IPRIP_IF_CONFIG_ID;
        
        pimsidInData-> IMSID_IfIndex    = imgidInData.IMGID_IfIndex;

        pimsidInData-> IMSID_BufferSize = IPRIP_IF_CONFIG_SIZE( piic );

        CopyMemory( 
            pimsidInData-> IMSID_Buffer,
            piic,
            pimsidInData-> IMSID_BufferSize
        );

        RIP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { RIP_MIB_FREE( pimsidInData ); }

    return dwRes;
}


DWORD
UpdateUnicastPeerEntry(
    IN  AsnAny *        objectArray,
    IN  DWORD           dwOp
)
{
    DWORD                       dwRes       = (DWORD) -1,
                                dwInd       = 0,
                                dwPeerAddr  = INADDR_NONE,
                                dwGetSize   = 0,
                                dwSetSize   = 0;

    PDWORD                      pdwAddrTable= 0;                                    

    sav_ifUnicastPeersEntry *   psifupe     = NULL;

    PIPRIP_IF_CONFIG            piic        = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid      = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA    imgidInData;


    do
    {
        //
        // Get interface config info
        //
    
        psifupe = (sav_ifUnicastPeersEntry*) objectArray;
        
        imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
        imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                        &( psifupe-> ifUPIfIndex ),
                                        0
                                      );
        
        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // Find Peer entry
        //
        
        dwPeerAddr  = GetAsnIPAddress( &( psifupe-> ifUPAddress ), 0 );

        piic        = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        pdwAddrTable= IPRIP_IF_UNICAST_PEER_TABLE( piic );

        FIND_PEER_ENTRY(
            dwPeerAddr,
            piic-> IC_UnicastPeerCount,
            pdwAddrTable,
            dwInd
        );

        //
        // if operation is filter add
        //
        
        if ( dwOp == d_Tag_create )
        {
            //
            // if peer already present, quit
            //
            
            if ( piic-> IC_UnicastPeerCount &&
                 dwInd < piic-> IC_UnicastPeerCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            else
            {
                dwRes = AddUnicastPeerEntry( 
                            dwPeerAddr, 
                            pimgodOutData
                        );
            }

            break;
        }

        //
        // operation is filter delete
        //

        //
        // if peer is not present quit.
        //
        
        if ( !piic-> IC_UnicastPeerCount ||
             dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeleteUnicastPeerEntry(
                    dwInd,
                    pimgodOutData
                );
                
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
    
}


DWORD
AddUnicastPeerEntry(
    IN  DWORD                       dwPeer,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0;

    PDWORD                      pdwAddrTable    = NULL;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;
    
    do
    {
        //
        // Allocate new info block
        //

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld ) + sizeof( DWORD );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 ( "Memory allocation failed" );
            break;
        }

        //
        // Add unicast peer
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        
        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) +
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        pdwAddrTable = IPRIP_IF_UNICAST_PEER_TABLE( piicNew );

        pdwAddrTable[ piicNew-> IC_UnicastPeerCount ] = dwPeer;

        piicNew-> IC_UnicastPeerCount++;

        //
        // Copy Filters
        //

        CopyMemory(
            (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        CopyMemory(
            (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
            piicOld-> IC_AnnounceFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );
        
        //
        // Set info. in MIB
        //

        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );

    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}

DWORD
DeleteUnicastPeerEntry(
    IN  DWORD                       dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0;

    PDWORD                      pdwSrc          = NULL,
                                pdwDst          = NULL;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;


    do
    {
        // 
        // Compute size of new interface config
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 + 
                    IPRIP_IF_CONFIG_SIZE( piicOld ) - sizeof ( DWORD );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) -
                                      sizeof( DWORD );

        piicNew = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;
        
        //
        // Copy base config info.
        //

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG )
        );


        //
        // Delete specified peer 
        //
        
        pdwSrc = IPRIP_IF_UNICAST_PEER_TABLE( piicOld );

        pdwDst = IPRIP_IF_UNICAST_PEER_TABLE( piicNew );

        DELETE_PEER_ENTRY(
            dwIndex,
            piicOld-> IC_UnicastPeerCount,
            pdwSrc,
            pdwDst
        );

        piicNew-> IC_UnicastPeerCount--;

        //
        // Copy filters
        //
        
        CopyMemory(
            (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        CopyMemory(
            (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
            piicOld-> IC_AnnounceFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );
        
        //
        // Set info. in MIB
        //

        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );

    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}


DWORD
UpdateFilterTable(
    IN  DWORD                   dwOp,
    IN  DWORD                   dwIfIndex,
    IN  DWORD                   dwFiltType,
    IN  PIPRIP_ROUTE_FILTER     pirfFilt
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwGetSize       = 0,
                                dwIndex         = (DWORD) -1,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piic            = NULL;

    PIPRIP_ROUTE_FILTER         pirfLst         = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData   = NULL;

    IPRIP_MIB_GET_INPUT_DATA    imgidInData;


    do
    {
        
        imgidInData.IMGID_TypeID    = IPRIP_GLOBAL_CONFIG_ID;

        imgidInData.IMGID_IfIndex   = dwIfIndex;
        
        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // find filter
        //

        piic = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            dwCount = piic-> IC_AcceptFilterCount;
            
            pirfLst = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
        }

        else
        {
            dwCount = piic-> IC_AnnounceFilterCount;
            
            pirfLst = IPRIP_IF_ANNOUNCE_FILTER_TABLE( piic );
        }

        FIND_FILTER( 
            pirfFilt,
            dwCount,
            pirfLst,
            dwIndex
        );

        if ( dwOp == d_Tag_create )
        {
            //
            // check if filter is already present
            //
            
            if ( dwCount && dwIndex < dwCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            dwRes = AddFilterEntry(
                        dwFiltType,
                        pirfFilt,
                        pimgodOutData
                    );

            break;                    
        }

        //
        // Must be a delete operation
        //

        if ( !dwCount || dwIndex >= dwCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeleteFilterEntry(
                    dwFiltType,
                    dwIndex,
                    pimgodOutData
                );

    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
}


DWORD
AddFilterEntry(
    IN  DWORD                       dwFiltType,
    IN  PIPRIP_ROUTE_FILTER         pirfFilt,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{
    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0,
                                dwIndex         = (DWORD) -1,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;

    PIPRIP_ROUTE_FILTER         pirfLst         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;

    do
    {
        //
        // Compute size of new config and allocate block for it.
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld) + 
                    sizeof( IPRIP_ROUTE_FILTER );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        //
        // set up the new config block.
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) + 
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD ) +
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        //
        // if accept filter is being added, added to end of
        // accept fitler table, and copy the annouce filters
        //
        
        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            pirfLst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            pirfLst[ piicNew-> IC_AcceptFilterCount++ ] = *pirfFilt;

            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
        }

        else
        {
            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
            
            pirfLst = IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew );

            pirfLst[ piicNew-> IC_AnnounceFilterCount++ ] = *pirfFilt;
        }

        //
        // Update the MIB with the new config
        //
        
        RIP_MIB_SET( pimsid, dwSetSize, dwRes );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
        }
        
    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}



DWORD
DeleteFilterEntry(
    IN  DWORD                       dwFiltType,
    IN  DWORD                       dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{
    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;

    PIPRIP_ROUTE_FILTER         pirfSrc         = NULL,
                                pirfDst         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;


    do
    {
        //
        // Compute size of new config and allocate block for it.
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld ) - 
                    sizeof( IPRIP_ROUTE_FILTER );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        //
        // set up the new config block.
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) + 
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            pirfSrc = IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld );

            pirfDst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            DELETE_FILTER( 
                dwIndex, 
                piicOld-> IC_AcceptFilterCount,
                pirfSrc,
                pirfDst
            );
            
            piicNew-> IC_AcceptFilterCount--;

            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
        }

        else
        {
            CopyMemory(
                (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
                piicNew-> IC_AcceptFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
            
            pirfSrc = IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld );

            pirfDst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            DELETE_FILTER( 
                dwIndex, 
                piicOld-> IC_AnnounceFilterCount,
                pirfSrc,
                pirfDst
            );
            
            piicNew-> IC_AnnounceFilterCount--;
        }

        RIP_MIB_SET( pimsid, dwSetSize, dwRes );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
        }
        
    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}


DWORD
ConnectToRouter()
{
    DWORD       dwRes = (DWORD) -1;
    

    EnterCriticalSection( &g_CS );

    do
    {
        MPR_SERVER_HANDLE hTmp;

        if ( g_hMIBServer )
        {
            dwRes = NO_ERROR;
            break;
        }

        dwRes = MprAdminMIBServerConnect( NULL, &hTmp );

        if ( dwRes == NO_ERROR )
        {
            InterlockedExchangePointer(&g_hMIBServer, hTmp );
        }
        else
        {
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", 
                dwRes
            );
        }
        
    } while ( FALSE );

    LeaveCriticalSection( &g_CS );

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\mibfuncs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    Sample subagent instrumentation callbacks.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_global {
    AsnAny globalSystemRouteChanges;        
    AsnAny globalTotalResponseSends;        
    AsnAny globalLoggingLevel;              
    AsnAny globalMaxRecQueueSize;           
    AsnAny globalMaxSendQueueSize;
    AsnAny globalMinTriggeredUpdateInterval;
    AsnAny globalPeerFilterMode;            
    AsnAny globalPeerFilterCount;           
 } buf_global;

typedef struct _sav_global {
    AsnAny globalLoggingLevel;              
    AsnAny globalMaxRecQueueSize;           
    AsnAny globalMaxSendQueueSize;          
    AsnAny globalMinTriggeredUpdateInterval;
    AsnAny globalPeerFilterMode;            
} sav_global;

#define gf_globalSystemRouteChanges                 get_global
#define gf_globalTotalResponseSends                 get_global
#define gf_globalLoggingLevel                       get_global
#define gf_globalMaxRecQueueSize                    get_global
#define gf_globalMaxSendQueueSize                   get_global
#define gf_globalMinTriggeredUpdateInterval         get_global
#define gf_globalPeerFilterMode                     get_global
#define gf_globalPeerFilterCount                    get_global

#define gb_globalSystemRouteChanges                 buf_global
#define gb_globalTotalResponseSends                 buf_global
#define gb_globalLoggingLevel                       buf_global
#define gb_globalMaxRecQueueSize                    buf_global
#define gb_globalMaxSendQueueSize                   buf_global
#define gb_globalMinTriggeredUpdateInterval         buf_global
#define gb_globalPeerFilterMode                     buf_global
#define gb_globalPeerFilterCount                    buf_global

#define sf_globalLoggingLevel                       set_global
#define sf_globalMaxRecQueueSize                    set_global
#define sf_globalMaxSendQueueSize                   set_global
#define sf_globalMinTriggeredUpdateInterval         set_global
#define sf_globalPeerFilterMode                     set_global

#define sb_globalLoggingLevel                       sav_global
#define sb_globalMaxRecQueueSize                    sav_global
#define sb_globalMaxSendQueueSize                   sav_global
#define sb_globalMinTriggeredUpdateInterval         sav_global
#define sb_globalPeerFilterMode                     sav_global

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_globalPeerFilterEntry {
    AsnAny globalPFAddr;
    AsnAny globalPFTag;
    DWORD  dwPeerFilterAddr;
} buf_globalPeerFilterEntry;

typedef struct _sav_globalPeerFilterEntry {
    AsnAny globalPFAddr;
    AsnAny globalPFTag;
} sav_globalPeerFilterEntry;

#define gf_globalPFAddr                    get_globalPeerFilterEntry
#define gf_globalPFTag                     get_globalPeerFilterEntry

#define gb_globalPFAddr                    buf_globalPeerFilterEntry
#define gb_globalPFTag                     buf_globalPeerFilterEntry

#define sf_globalPFAddr                    set_globalPeerFilterEntry
#define sf_globalPFTag                     set_globalPeerFilterEntry

#define sb_globalPFAddr                    sav_globalPeerFilterEntry
#define sb_globalPFTag                     sav_globalPeerFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifStatsEntry {
    AsnAny ifSEIndex;                         
    AsnAny ifSEState;                         
    AsnAny ifSESendFailures;                  
    AsnAny ifSEReceiveFailures;               
    AsnAny ifSERequestSends;                  
    AsnAny ifSERequestReceiveds;              
    AsnAny ifSEResponseSends;                 
    AsnAny ifSEResponseReceiveds;             
    AsnAny ifSEBadResponsePacketReceiveds;    
    AsnAny ifSEBadResponseEntriesReceiveds;   
    AsnAny ifSETriggeredUpdateSends;          
    DWORD  dwIfIndex;
} buf_ifStatsEntry;

#define gf_ifSEIndex                                get_ifStatsEntry
#define gf_ifSEState                                get_ifStatsEntry
#define gf_ifSESendFailures                         get_ifStatsEntry
#define gf_ifSEReceiveFailures                      get_ifStatsEntry
#define gf_ifSERequestSends                         get_ifStatsEntry
#define gf_ifSERequestReceiveds                     get_ifStatsEntry
#define gf_ifSEResponseSends                        get_ifStatsEntry
#define gf_ifSEResponseReceiveds                    get_ifStatsEntry
#define gf_ifSEBadResponsePacketReceiveds           get_ifStatsEntry
#define gf_ifSEBadResponseEntriesReceiveds          get_ifStatsEntry
#define gf_ifSETriggeredUpdateSends                 get_ifStatsEntry

#define gb_ifSEIndex                                buf_ifStatsEntry
#define gb_ifSEState                                buf_ifStatsEntry
#define gb_ifSESendFailures                         buf_ifStatsEntry
#define gb_ifSEReceiveFailures                      buf_ifStatsEntry
#define gb_ifSERequestSends                         buf_ifStatsEntry
#define gb_ifSERequestReceiveds                     buf_ifStatsEntry
#define gb_ifSEResponseSends                        buf_ifStatsEntry
#define gb_ifSEResponseReceiveds                    buf_ifStatsEntry
#define gb_ifSEBadResponsePacketReceiveds           buf_ifStatsEntry
#define gb_ifSEBadResponseEntriesReceiveds          buf_ifStatsEntry
#define gb_ifSETriggeredUpdateSends                 buf_ifStatsEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifConfigEntry {
    AsnAny ifCEIndex;                  
    AsnAny ifCEState;                  
    AsnAny ifCEMetric;                 
    AsnAny ifCEUpdateMode;             
    AsnAny ifCEAcceptMode;             
    AsnAny ifCEAnnounceMode;           
    AsnAny ifCEProtocolFlags;         
    AsnAny ifCERouteExpirationInterval;
    AsnAny ifCERouteRemovalInterval;   
    AsnAny ifCEFullUpdateInterval;     
    AsnAny ifCEAuthenticationType;     
    AsnAny ifCEAuthenticationKey;      
    AsnAny ifCERouteTag;               
    AsnAny ifCEUnicastPeerMode;        
    AsnAny ifCEAcceptFilterMode;      
    AsnAny ifCEAnnounceFilterMode;     
    AsnAny ifCEUnicastPeerCount;       
    AsnAny ifCEAcceptFilterCount;      
    AsnAny ifCEAnnounceFilterCount;    
    DWORD  dwifIndex;
    BYTE   pbAuthKey[IPRIP_MAX_AUTHKEY_SIZE];
} buf_ifConfigEntry;

typedef struct _sav_ifConfigEntry {
    AsnAny ifCEIndex;                  
//    AsnAny ifCEState;                  
    AsnAny ifCEMetric;                 
    AsnAny ifCEUpdateMode;             
    AsnAny ifCEAcceptMode;             
    AsnAny ifCEAnnounceMode;           
    AsnAny ifCEProtocolFlags;         
    AsnAny ifCERouteExpirationInterval;
    AsnAny ifCERouteRemovalInterval;   
    AsnAny ifCEFullUpdateInterval;     
    AsnAny ifCEAuthenticationType;     
    AsnAny ifCEAuthenticationKey;      
    AsnAny ifCERouteTag;               
    AsnAny ifCEUnicastPeerMode;        
    AsnAny ifCEAcceptFilterMode;      
    AsnAny ifCEAnnounceFilterMode;     
} sav_ifConfigEntry;

#define gf_ifCEIndex                            get_ifConfigEntry
#define gf_ifCEState                            get_ifConfigEntry
#define gf_ifCEMetric                           get_ifConfigEntry
#define gf_ifCEUpdateMode                       get_ifConfigEntry
#define gf_ifCEAcceptMode                       get_ifConfigEntry
#define gf_ifCEAnnounceMode                     get_ifConfigEntry
#define gf_ifCEProtocolFlags                    get_ifConfigEntry
#define gf_ifCERouteExpirationInterval          get_ifConfigEntry
#define gf_ifCERouteRemovalInterval             get_ifConfigEntry
#define gf_ifCEFullUpdateInterval               get_ifConfigEntry
#define gf_ifCEAuthenticationType               get_ifConfigEntry
#define gf_ifCEAuthenticationKey                get_ifConfigEntry
#define gf_ifCERouteTag                         get_ifConfigEntry
#define gf_ifCEUnicastPeerMode                  get_ifConfigEntry
#define gf_ifCEAcceptFilterMode                 get_ifConfigEntry
#define gf_ifCEAnnounceFilterMode               get_ifConfigEntry
#define gf_ifCEUnicastPeerCount                 get_ifConfigEntry
#define gf_ifCEAcceptFilterCount                get_ifConfigEntry
#define gf_ifCEAnnounceFilterCount              get_ifConfigEntry

#define gb_ifCEIndex                            buf_ifConfigEntry
#define gb_ifCEState                            buf_ifConfigEntry
#define gb_ifCEMetric                           buf_ifConfigEntry
#define gb_ifCEUpdateMode                       buf_ifConfigEntry
#define gb_ifCEAcceptMode                       buf_ifConfigEntry
#define gb_ifCEAnnounceMode                     buf_ifConfigEntry
#define gb_ifCEProtocolFlags                    buf_ifConfigEntry
#define gb_ifCERouteExpirationInterval          buf_ifConfigEntry
#define gb_ifCERouteRemovalInterval             buf_ifConfigEntry
#define gb_ifCEFullUpdateInterval               buf_ifConfigEntry
#define gb_ifCEAuthenticationType               buf_ifConfigEntry
#define gb_ifCEAuthenticationKey                buf_ifConfigEntry
#define gb_ifCERouteTag                         buf_ifConfigEntry
#define gb_ifCEUnicastPeerMode                  buf_ifConfigEntry
#define gb_ifCEAcceptFilterMode                 buf_ifConfigEntry
#define gb_ifCEAnnounceFilterMode               buf_ifConfigEntry
#define gb_ifCEUnicastPeerCount                 buf_ifConfigEntry
#define gb_ifCEAcceptFilterCount                buf_ifConfigEntry
#define gb_ifCEAnnounceFilterCount              buf_ifConfigEntry

#define sf_ifCEIndex                            set_ifConfigEntry
//#define sf_ifCEState                            set_ifConfigEntry
#define sf_ifCEMetric                           set_ifConfigEntry
#define sf_ifCEUpdateMode                       set_ifConfigEntry
#define sf_ifCEAcceptMode                       set_ifConfigEntry
#define sf_ifCEAnnounceMode                     set_ifConfigEntry
#define sf_ifCEProtocolFlags                    set_ifConfigEntry
#define sf_ifCERouteExpirationInterval          set_ifConfigEntry
#define sf_ifCERouteRemovalInterval             set_ifConfigEntry
#define sf_ifCEFullUpdateInterval               set_ifConfigEntry
#define sf_ifCEAuthenticationType               set_ifConfigEntry
#define sf_ifCEAuthenticationKey                set_ifConfigEntry
#define sf_ifCERouteTag                         set_ifConfigEntry
#define sf_ifCEUnicastPeerMode                  set_ifConfigEntry
#define sf_ifCEAcceptFilterMode                 set_ifConfigEntry
#define sf_ifCEAnnounceFilterMode               set_ifConfigEntry

#define sb_ifCEIndex                            sav_ifConfigEntry     
//#define sb_ifCEState                            sav_ifConfigEntry
#define sb_ifCEMetric                           sav_ifConfigEntry
#define sb_ifCEUpdateMode                       sav_ifConfigEntry
#define sb_ifCEAcceptMode                       sav_ifConfigEntry
#define sb_ifCEAnnounceMode                     sav_ifConfigEntry
#define sb_ifCEProtocolFlags                    sav_ifConfigEntry
#define sb_ifCERouteExpirationInterval          sav_ifConfigEntry
#define sb_ifCERouteRemovalInterval             sav_ifConfigEntry
#define sb_ifCEFullUpdateInterval               sav_ifConfigEntry
#define sb_ifCEAuthenticationType               sav_ifConfigEntry
#define sb_ifCEAuthenticationKey                sav_ifConfigEntry
#define sb_ifCERouteTag                         sav_ifConfigEntry
#define sb_ifCEUnicastPeerMode                  sav_ifConfigEntry
#define sb_ifCEAcceptFilterMode                 sav_ifConfigEntry
#define sb_ifCEAnnounceFilterMode               sav_ifConfigEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifUnicastPeersEntry {
    AsnAny ifUPIfIndex;
    AsnAny ifUPAddress;
    AsnAny ifUPTag;
    DWORD  dwIfIndex;
    DWORD  dwUnicastPeerAddr;
} buf_ifUnicastPeersEntry;

typedef struct _sav_ifUnicastPeersEntry {
    AsnAny ifUPIfIndex;
    AsnAny ifUPAddress;
    AsnAny ifUPTag;
} sav_ifUnicastPeersEntry;
                        
#define gf_ifUPIfIndex                      get_ifUnicastPeersEntry
#define gf_ifUPAddress                      get_ifUnicastPeersEntry
#define gf_ifUPTag                          get_ifUnicastPeersEntry

#define gb_ifUPIfIndex                      buf_ifUnicastPeersEntry
#define gb_ifUPAddress                      buf_ifUnicastPeersEntry
#define gb_ifUPTag                          buf_ifUnicastPeersEntry

#define sf_ifUPIfIndex                      set_ifUnicastPeersEntry
#define sf_ifUPAddress                      set_ifUnicastPeersEntry
#define sf_ifUPTag                          set_ifUnicastPeersEntry

#define sb_ifUPIfIndex                      sav_ifUnicastPeersEntry
#define sb_ifUPAddress                      sav_ifUnicastPeersEntry
#define sb_ifUPTag                          sav_ifUnicastPeersEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAcceptRouteFilterEntry {
    AsnAny ifAcceptRFIfIndex;    
    AsnAny ifAcceptRFLoAddress;  
    AsnAny ifAcceptRFHiAddress;
    AsnAny ifAcceptRFTag;
    DWORD  dwIfIndex;
    DWORD  dwFilterLoAddr;
    DWORD  dwFilterHiAddr;
} buf_ifAcceptRouteFilterEntry;

typedef struct _sav_ifAcceptRouteFilterEntry {
    AsnAny ifAcceptRFIfIndex;    
    AsnAny ifAcceptRFLoAddress;  
    AsnAny ifAcceptRFHiAddress;  
    AsnAny ifAcceptRFTag;
} sav_ifAcceptRouteFilterEntry;

#define gf_ifAcceptRFIfIndex                    get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFLoAddress                  get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFHiAddress                  get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFTag                        get_ifAcceptRouteFilterEntry

#define gb_ifAcceptRFIfIndex                    buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFLoAddress                  buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFHiAddress                  buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFTag                        buf_ifAcceptRouteFilterEntry

#define sf_ifAcceptRFIfIndex                    set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFLoAddress                  set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFHiAddress                  set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFTag                        set_ifAcceptRouteFilterEntry

#define sb_ifAcceptRFIfIndex                    sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFLoAddress                  sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFHiAddress                  sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFTag                        sav_ifAcceptRouteFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAnnounceRouteFilterEntry {
    AsnAny ifAnnounceRFIfIndex;   
    AsnAny ifAnnounceRFLoAddress;
    AsnAny ifAnnounceRFHiAddress;
    AsnAny ifAnnounceRFTag;
    DWORD  dwIfIndex;
    DWORD  dwFilterLoAddr;
    DWORD  dwFilterHiAddr;
} buf_ifAnnounceRouteFilterEntry;

typedef struct _sav_ifAnnounceRouteFilterEntry {
    AsnAny ifAnnounceRFIfIndex;   
    AsnAny ifAnnounceRFLoAddress;
    AsnAny ifAnnounceRFHiAddress;
    AsnAny ifAnnounceRFTag;
} sav_ifAnnounceRouteFilterEntry;

#define gf_ifAnnounceRFIfIndex                   get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFLoAddress                get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFHiAddress                get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFTag                      get_ifAnnounceRouteFilterEntry

#define gb_ifAnnounceRFIfIndex                   buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFLoAddress                buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFHiAddress                buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFTag                      buf_ifAnnounceRouteFilterEntry

#define sf_ifAnnounceRFIfIndex                   set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFLoAddress                set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFHiAddress                set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFTag                      set_ifAnnounceRouteFilterEntry

#define sb_ifAnnounceRFIfIndex                   sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFLoAddress                sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFHiAddress                sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFTag                      sav_ifAnnounceRouteFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifBindingEntry {
    AsnAny ifBindingIndex; 
    AsnAny ifBindingState; 
    AsnAny ifBindingCounts;
    DWORD  dwIfIndex;
} buf_ifBindingEntry;


#define gf_ifBindingIndex                   get_ifBindingEntry
#define gf_ifBindingState                   get_ifBindingEntry
#define gf_ifBindingCounts                  get_ifBindingEntry

#define gb_ifBindingIndex                   buf_ifBindingEntry
#define gb_ifBindingState                   buf_ifBindingEntry
#define gb_ifBindingCounts                  buf_ifBindingEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAddressEntry {
    AsnAny ifAEIfIndex; 
    AsnAny ifAEAddress; 
    AsnAny ifAEMask; 
    DWORD  dwIfIndex;
    DWORD  dwAddress;
    DWORD  dwMask;
    
} buf_ifAddressEntry;

#define gf_ifAEIfIndex                      get_ifAddressEntry
#define gf_ifAEAddress                      get_ifAddressEntry
#define gf_ifAEMask                         get_ifAddressEntry

#define gb_ifAEIfIndex                      buf_ifAddressEntry
#define gb_ifAEAddress                      buf_ifAddressEntry
#define gb_ifAEMask                         buf_ifAddressEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifPeerStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifPeerStatsEntry {
    AsnAny ifPSAddress;                
    AsnAny ifPSLastPeerRouteTag;       
    AsnAny ifPSLastPeerUpdateTickCount;
    AsnAny ifPSLastPeerUpdateVersion;  
    AsnAny ifPSPeerBadResponsePackets; 
    AsnAny ifPSPeerBadResponseEntries; 
    DWORD  dwPeerAddr;

} buf_ifPeerStatsEntry;

#define gf_ifPSAddress                          get_ifPeerStatsEntry  
#define gf_ifPSLastPeerRouteTag                 get_ifPeerStatsEntry
#define gf_ifPSLastPeerUpdateTickCount          get_ifPeerStatsEntry
#define gf_ifPSLastPeerUpdateVersion            get_ifPeerStatsEntry
#define gf_ifPSPeerBadResponsePackets           get_ifPeerStatsEntry
#define gf_ifPSPeerBadResponseEntries           get_ifPeerStatsEntry

#define gb_ifPSAddress                          buf_ifPeerStatsEntry
#define gb_ifPSLastPeerRouteTag                 buf_ifPeerStatsEntry
#define gb_ifPSLastPeerUpdateTickCount          buf_ifPeerStatsEntry
#define gb_ifPSLastPeerUpdateVersion            buf_ifPeerStatsEntry
#define gb_ifPSPeerBadResponsePackets           buf_ifPeerStatsEntry
#define gb_ifPSPeerBadResponseEntries           buf_ifPeerStatsEntry

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\ripagnt\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
        precomp.h

Abstract:
        Precompiled header for the RIP-2 subagent 

Author:
        V Raman ( vraman )

Revision History:

        V Raman Aug-1-1996  Created

--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <winsock.h>
#include <snmp.h>
#include <snmpexts.h>
#include <mprapi.h>
#include <routprot.h>
#include <ipriprm.h>

#if defined( MIB_DEBUG )

#include <rtutils.h>
extern DWORD   g_dwTraceId;

#endif

#include "mibentry.h"
#include "mibfuncs.h"
#include "defs.h"

extern      MIB_SERVER_HANDLE       g_hMIBServer;
extern      CRITICAL_SECTION        g_CS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\access.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\access.h

Abstract:

    Header for access.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

typedef 
DWORD
(ACCESS_FN)(
    DWORD                dwQueryType,
    DWORD                dwInEntrySize,
    PMIB_OPAQUE_QUERY    pInEntry,
    PDWORD               pOutEntrySize,
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL                pbCache
    );

ACCESS_FN AccessIfNumber;
ACCESS_FN AccessIfTable;
ACCESS_FN AccessIfRow;
ACCESS_FN AccessIcmpStats;
ACCESS_FN AccessUdpStats;
ACCESS_FN AccessUdpTable;
ACCESS_FN AccessUdpRow;
ACCESS_FN AccessTcpStats;
ACCESS_FN AccessTcpTable;
ACCESS_FN AccessTcpRow;
ACCESS_FN AccessIpStats;
ACCESS_FN AccessIpAddrTable;
ACCESS_FN AccessIpForwardNumber;
ACCESS_FN AccessIpForwardTable;
ACCESS_FN AccessIpNetTable;
ACCESS_FN AccessIpAddrRow;
ACCESS_FN AccessIpForwardRow;
ACCESS_FN AccessIpNetRow;
ACCESS_FN AccessMcastMfe;
ACCESS_FN AccessMcastMfeStats;
ACCESS_FN AccessMcastMfeStatsEx;
ACCESS_FN AccessProxyArp;
ACCESS_FN AccessBestIf;
ACCESS_FN AccessBestRoute;
ACCESS_FN AccessMcastIfStats;
ACCESS_FN AccessMcastStats;
ACCESS_FN AccessMcastBoundary;
ACCESS_FN AccessMcastScope;
ACCESS_FN AccessIfStatus;
ACCESS_FN AccessDestMatching;
ACCESS_FN AccessDestLonger;
ACCESS_FN AccessDestShorter;
ACCESS_FN AccessRouteMatching;
ACCESS_FN AccessRouteLonger;
ACCESS_FN AccessRouteShorter;
ACCESS_FN AccessIpMatchingRoute;
ACCESS_FN AccessSetRouteState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\allinc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\rtrmgr\allinc.h

Abstract:

    IP Router Manager header for all includes

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __RTRMGR_ALLINC_H__
#define __RTRMGR_ALLINC_H__

#pragma warning(disable:4201)
#pragma warning(disable:4115)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>

#include <ntverp.h>

#pragma warning(default:4115)
#pragma warning(default:4201)

#include <ipexport.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <mstcpip.h>


#include <rtmv2.h>
#include <rtutils.h>
#include <dim.h>
#include <routprot.h>
#include <mprerror.h>
#include <raserror.h>

#include <rtmmgmt.h>

#include <iprtrmib.h>

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#include <ipfltinf.h>
#ifdef KSL_IPINIP
#include <ddipinip.h>
#endif //KSL_IPINIP
#include <ddipmcst.h>
#include <ddwanarp.h>

#include <iphlpstk.h>

#include <mprlog.h>
#include <iputils.h>
#include <fltdefs.h>
#include <rtinfo.h>
#include <ipinfoid.h>

#include <iprtinfo.h>
#include <iprtprio.h>
#include <priopriv.h>
#include <rmmgm.h>
#include <mgm.h>
#include <ipnat.h>

#include <rasman.h>
#include <rasppp.h>
#include <nbtioctl.h>

#include "defs.h"
#include "iprtrmib.h"
#include "rtrdisc.h"
#include "mhrtbt.h"
#include "iprtrmgr.h"
#include "proto.h"
#include "asyncwrk.h"
#include "info.h"
#include "filter.h"
#include "demand.h"
#include "if.h"
#include "map.h"
#include "mcastif.h"
#include "access.h"
#include "locate.h"
#ifdef KSL_IPINIP
#include "ipipcfg.h"
#endif //KSL_IPINIP
#include "route.h"
#include "globals.h"
#include "mcmisc.h"
#include "mbound.h"

#define HAVE_RTMV2 1

#endif // __RTRMGR_ALLINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\asyncwrk.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\asyncwrk.c

Abstract:

    All functions called spooled to a worker function

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    )

/*++

Routine Description


Locks


Arguments


Return Value


--*/

{
    DWORD   dwResult = NO_ERROR;
    BOOL    bRetval;

    
    EnterCriticalSection(&RouterStateLock);
    
    if (RouterState.IRS_State is RTR_STATE_RUNNING)
    {
        RouterState.IRS_RefCount++;

        LeaveCriticalSection(&RouterStateLock);
    }
    else
    {                                    
        LeaveCriticalSection(&RouterStateLock) ;
        
        return ERROR_ROUTER_STOPPED ;
    }                  

   
    bRetval = QueueUserWorkItem(
                             (LPTHREAD_START_ROUTINE)pfnFunction,
                             pvContext,
                             bAlertable ? WT_EXECUTEINIOTHREAD : 0);

    //
    // If we successfully queued the item, dont decrement the count
    //
    
    if(bRetval isnot TRUE)
    {
        dwResult = GetLastError();
        
        Trace1(GLOBAL,
               "QueueAsyncWorker %x",
               pfnFunction);

        EnterCriticalSection(&RouterStateLock);
    
        RouterState.IRS_RefCount--;
        
        LeaveCriticalSection(&RouterStateLock);
    }
        
    return dwResult;
}
    
    
VOID
RestoreStaticRoutes(
    PVOID   pvContext
    )

/*++

Routine Description


Locks


Arguments


Return Value

--*/

{
    PICB                    pIfToRestore, pOldIf;
    PRESTORE_INFO_CONTEXT   pricInfo;
    DWORD                   dwResult, dwSize, dwIndex, dwSeq, i;
    PRTR_INFO_BLOCK_HEADER  pribhIfInfo;
    HANDLE                  hDIM;
    
    TraceEnter("RestoreStaticRoutes");
    
    ENTER_READER(ICB_LIST);

    pricInfo        = (PRESTORE_INFO_CONTEXT)pvContext;

    dwIndex         = pricInfo->dwIfIndex;
    pIfToRestore    = InterfaceLookupByIfIndex(dwIndex);

    HeapFree(IPRouterHeap,
             0,
             pvContext);

    if(pIfToRestore is NULL)
    {
        Trace0(ERR,
               "RestoreStaticRoutes: Could not find ICB");

        TraceLeave("RestoreStaticRoutes");

        EXIT_LOCK(ICB_LIST);

        ExitRouterApi();
        
        return;
    }

    if(pIfToRestore->ritType is ROUTER_IF_TYPE_DEDICATED)
    {
        //
        // Now pick up the routes the stack may have added
        //

        AddAllStackRoutes(pIfToRestore);

        for ( i = 0; i < pIfToRestore->dwNumAddresses; i++)
        {
            AddLoopbackRoute(
                pIfToRestore->pibBindings[i].dwAddress,
                pIfToRestore->pibBindings[i].dwMask
                );
        }
    }

    pOldIf  = pIfToRestore;
    hDIM    = pIfToRestore->hDIMHandle;
    dwSeq   = pIfToRestore->dwSeqNumber;
    
    EXIT_LOCK(ICB_LIST);
        
       
    Trace1(IF,
           "RestoreStaticRoutes: restoring for %S\n",
           pIfToRestore->pwszName);
 
    dwSize = 0;

    dwResult = RestoreInterfaceInfo(hDIM,
                                    PID_IP,
                                    NULL,
                                    &dwSize);

    if(dwResult isnot ERROR_BUFFER_TOO_SMALL)
    {
        //
        // This is the only error code which will give us a good info size
        //

        Trace2(ERR,
               "RestoreStaticRoutes: Error %d trying to get info size from DIM for i/f %d",
               dwResult,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }
                        
    //
    // So now we have the memory size we use double to 
    // avoid any problem
    //
        
    dwSize      = 2 * dwSize;
        
    pribhIfInfo = HeapAlloc(IPRouterHeap,
                            HEAP_ZERO_MEMORY,
                            dwSize);
        
    if(pribhIfInfo is NULL)
    {
        Trace2(ERR,
               "RestoreStaticRoutes: Error allocating %d bytes for info for i/f %d",
               dwSize,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }
        
    dwResult = RestoreInterfaceInfo(hDIM,
                                    PID_IP,
                                    (PVOID)pribhIfInfo,
                                    &dwSize);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "RestoreStaticRoutes: Error %d getting info for i/f %d",
               dwResult,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }

    ENTER_READER(ICB_LIST);

    pIfToRestore = InterfaceLookupByIfIndex(dwIndex);

    if(pIfToRestore is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pribhIfInfo);

        ExitRouterApi();

        return;
    }

    if((pIfToRestore->dwOperationalState <= IF_OPER_STATUS_UNREACHABLE) or
       (pIfToRestore->dwAdminState isnot IF_ADMIN_STATUS_UP))
    {
        Trace3(IF,
               "RestoreStaticRoutes: Not restoring routes on %S because states are %d %d",
               pIfToRestore->pwszName,
               pIfToRestore->dwOperationalState,
               pIfToRestore->dwAdminState);

        EXIT_LOCK(ICB_LIST);
        
        HeapFree(IPRouterHeap,
                 0,
                 pribhIfInfo);

        ExitRouterApi();

        return;
    }

    IpRtAssert(pIfToRestore->dwSeqNumber is dwSeq);
    IpRtAssert(pIfToRestore is pOldIf);
    
    dwResult = SetRouteInfo(pIfToRestore,
                            pribhIfInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "RestoreStaticRoutes. Error %d setting routes for %S",
               dwResult,
               pIfToRestore->pwszName);
    }
    else
    {
        Trace1(IF,
               "RestoreStaticRoutes: Successfully set routes for %S",
               pIfToRestore->pwszName);
    }

    pIfToRestore->bRestoringRoutes = FALSE;

    EXIT_LOCK(ICB_LIST);
    
    HeapFree(IPRouterHeap,
             0,
             pribhIfInfo);

    TraceLeave("RestoreStaticRoutes");
    
    ExitRouterApi();

    return;
}

VOID
ResolveHbeatName(
    PVOID pvContext
    )
{
    PHEARTBEAT_CONTEXT  pInfo;
    HOSTENT             *pHostEntry;
    CHAR                pszGroup[MAX_GROUP_LEN];
    PMCAST_HBEAT_CB     pHbeatCb;
    PICB                picb;
    DWORD               dwResult;

    pInfo = (PHEARTBEAT_CONTEXT) pvContext;
 
    WideCharToMultiByte(CP_ACP,
                        0,
                        pInfo->pwszGroup,
                        -1,
                        pszGroup,
                        MAX_GROUP_LEN,
                        NULL,
                        NULL);

    pHostEntry = gethostbyname(pszGroup);

    if(pHostEntry is NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        Trace2(ERR,
               "ResolveHbeatName: Error %d resolving %S",
               GetLastError(),
               pInfo->pwszGroup);

        ExitRouterApi();

        return;
    }
   
    ENTER_WRITER(ICB_LIST);

    picb = InterfaceLookupByIfIndex(pInfo->dwIfIndex);

    if(picb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        ExitRouterApi();

        return;
    }

    if(picb isnot pInfo->picb)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        ExitRouterApi();

        return;
    }

    pHbeatCb = &picb->mhcHeartbeatInfo;

    pHbeatCb->dwGroup = *((PDWORD)(pHostEntry->h_addr_list[0]));

    HeapFree(IPRouterHeap,
             0,
             pvContext); 

    dwResult = StartMHeartbeat(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ResolveHbeatName: Error %d starting hbeat for %S",
               dwResult,
               picb->pwszName);
    }

    EXIT_LOCK(ICB_LIST);

    ExitRouterApi();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\rtrmgr\access.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\access.c

Abstract:

    All the "access" functions take similar arguments:

    dwQueryType     This is the type of the query and can be
                    ACCESS_GET
                    ACCESS_GET_FIRST,
                    ACCESS_GET_NEXT,
                    ACCESS_SET,
                    ACCESS_CREATE_ENTRY,
                    ACCESS_DELETE_ENTRY
                    
    dwInEntrySize   Size of the input buffer.  The information
                    in the input buffer is dependent on the query type and
                    the information being queried. The input buffer stores
                    the QueryInfo which is a variable sized structure taking
                    an array of instance ids. The dwInEntrySize is used to
                    figure out how many instance ids are in the array (since
                    and explicit count is not given)

    pInEntry        Pointer to the input buffer. This is a MIB_OPAQUE_QUERY
                    structure which contains an integer (dwType) which
                    indicates the object being queried (which is not used
                    since the demuxing based on that has already been done)
                    and a variable length array of integer instance ids
                    The instance id must be completely specified in case of
                    ACCESS_GET,
                    ACCESS_SET,
                    ACCESS_CREATE_ENTRY,
                    ACCESS_DELETE_ENTRY
                    but for the rest only the first 'n' components of
                    the instance id may be specified.
    
    pOutEntrySize   Pointer to the size of the output buffer. If this is 0
                    the caller is querying us for the size of buffer needed
                    If the supplied buffer size is too small, we set this
                    to the minimum required size and return
                    ERROR_INSUFFICIENT_BUFFER;
                    
    pOutEntry       The output buffer which is a MIB_OPAQUE_INFO structure.
                    The function fills in the dwTyoe to indicate the object
                    being returned. That type is used to cast the opaque
                    variable sized buffer following the type
    
    pbCache         Pointer to BOOL which is set to TRUE if the corresponding
                    cache was updated. This is not used currently, but may
                    be used later for optimizations

Revision History:

    Amritansh Raghav          7/8/95  Created

--*/

#include "allinc.h"

DWORD
SetIpForwardRow(
    PMIB_IPFORWARDROW pOldIpForw,
    PMIB_IPFORWARDROW pNewIpForw
    );

DWORD
DeleteIpForwardRow(
    PMIB_IPFORWARDROW pIpForw
    );


DWORD
AccessMcastMfeStatsInternal(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache,
    DWORD               dwStatsFlag
    );

DWORD 
AccessIfNumber(
    DWORD                dwQueryType, 
    DWORD                dwInEntrySize, 
    PMIB_OPAQUE_QUERY    pInEntry, 
    PDWORD               pOutEntrySize, 
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL                pbCache
    )

/*++

Routine Description

    Retrieves the number of interfaces

Locks

    None since g_IfInfo.dwNumberOfInterfaces is InterlockXxx()ed

Arguments

    dwQueryType     ACCESS_GET
    dwInEntrySize   Dont care
    pInEntry        Dont care
    pOutEntrySize   Minimum: MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER)

Return Value

    NO_ERROR

--*/

{
    PMIB_IFNUMBER   pIfNumber;
    DWORD           dwNumInterfaces;

    TraceEnter("AccessIfNumber");

    pIfNumber = (PMIB_IFNUMBER)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIfNumber");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER);

        TraceLeave("AccessIfNumber");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER);
   
    //
    // The variable is only inc/dec using interlocked ops
    // so we dont need to take a lock here
    //
 
    pIfNumber->dwValue  = g_ulNumInterfaces;

    pOutEntry->dwId     = IF_NUMBER; 

    *pbCache = TRUE;

    TraceLeave("AccessIfNumber");
        
    return NO_ERROR;
}


DWORD 
AccessIfTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves the Interface table

Locks

    Takes ICB list lock as READER

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFTABLE)

Return Value

    NO_ERROR

--*/

{
    PMIB_IFTABLE    pIfTable;
    DWORD           count;
    PLIST_ENTRY     currentList;
    PICB            picb;
    DWORD           dwNumInterfaces, dwResult;
   
    TraceEnter("AccessIfTable");

    pIfTable = (PMIB_IFTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIfTable");
        
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        ENTER_READER(ICB_LIST);
        
        dwNumInterfaces = g_ulNumNonClientInterfaces;
        
        if(dwNumInterfaces is 0)
        {
            Trace0(MIB,"AccessIfTable: No valid entries found"); 

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pIfTable->dwNumEntries  = 0;

                pOutEntry->dwId         = IF_TABLE;
                
                dwResult                = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFTABLE);
            
            break;
        }
        
        if(*pOutEntrySize < MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces))
        {
            *pOutEntrySize  = MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces);

            dwResult        = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        pOutEntry->dwId = IF_TABLE;
    
        *pOutEntrySize  = MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces);
        
        for(currentList = ICBList.Flink, count = 0 ; 
            currentList isnot &ICBList;
            currentList = currentList->Flink)
        {
            picb = CONTAINING_RECORD (currentList, ICB, leIfLink) ;
           
            //
            // NOTE WE DO NOT RETURN ANY CLIENT INTERFACES
            //
            
            if((picb->ritType is ROUTER_IF_TYPE_CLIENT) or
               ((picb->ritType is ROUTER_IF_TYPE_INTERNAL) and
                (picb->bBound is FALSE)))
            {
                continue;
            }

            dwResult = GetInterfaceStatistics(picb,
                                              pIfTable->table + count);

            if(dwResult is NO_ERROR)
            {
                count++;
            }
            else
            {
                Trace2(ERR,
                       "AccessIfTable: Error %d getting statistics for %S",
                       dwResult,
                       picb->pwszName);
            }
        }

        pIfTable->dwNumEntries = count;

        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);
        
    *pbCache = TRUE;
    
    TraceLeave("AccessIfTable");
    
    return dwResult;

}


DWORD 
AccessIfRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to set or retrieve an IFRow

Locks

    ICB List lock are READER in caces of queries, WRITER in case of SETs
    
Arguments

    dwQueryType     Can be anything other than ACCESS_DELETE_ENTRY or
                    ACCESS_CREATE_ENTRY. The only field that can be Set is
                    the adminStatus
    pInEntry        Interface index in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFROW)
                    For sets, the OutEntry contains the row to set

Return Value:         

    NO_ERROR

--*/

{
    PICB        picb;
    PMIB_IFROW  pIfRow;
    DWORD       dwNumIndices, dwResult;
    BOOL        bUpdateDIM = FALSE;
    HANDLE      hDimInterface;

    TraceEnter("AccessIfRow");

    pIfRow = (PMIB_IFROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFROW);
        
        TraceLeave("AccessIfRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFROW);
        
    pOutEntry->dwId = IF_ROW;
    
    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            ENTER_READER(ICB_LIST);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIfRow(dwQueryType,
                               dwNumIndices,
                               pInEntry->rgdwVarIndex,
                               &picb,
                               FALSE);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    dwResult = GetInterfaceStatistics(picb,pIfRow);
                    
                    break;
                }
                
                case ACCESS_SET:
                {
                    //
                    // Save the interface handle, so that is can used outside 
                    // the interface locks
                    //
                    
                    hDimInterface = picb->hDIMHandle;
                    
                    dwResult = SetInterfaceStatistics(picb,pIfRow,&bUpdateDIM);
                    
                    break;
                }
                
                default:
                {
                    Trace1(MIB,
                           "AccessIfRow: Wrong query type %d",dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);

    //
    // If the AdminStatus of the interface has been changed,
    // update its status with DIM
    //
    
    if(bUpdateDIM)
    {
        EnableInterfaceWithDIM(
            hDimInterface,
            PID_IP,
            (pIfRow->dwAdminStatus == IF_ADMIN_STATUS_UP) ? TRUE : FALSE
            );
    }
    
    *pbCache = TRUE;
    
    TraceLeave("AccessIfRow");
    
    return dwResult;
    
}

DWORD 
AccessIcmpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get ICMP statistics

Locks

    None, since the stats are not cached
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_ICMP)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_ICMP   pIcmp;
    DWORD       dwResult;

    TraceEnter("AccessIcmpStats");

    pIcmp    = (PMIB_ICMP)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIcmpStats");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_ICMP))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = ICMP_STATS;
        
        dwResult = GetIcmpStatsFromStack(pIcmp);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ICMP);

    *pbCache = TRUE;

    TraceLeave("AccessIcmpStats");
    
    return dwResult;
}

DWORD 
AccessUdpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get UDP statistics

Locks

    None, since the stats are not cached
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_UDPSTATS   pUdpStats;
    DWORD           dwResult;

    TraceEnter("AccessUdpStats");

    pUdpStats = (PMIB_UDPSTATS)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessUdpStats");
    
        return ERROR_INVALID_PARAMETER;
    }
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = UDP_STATS;
    
        *pbCache = TRUE;

        dwResult = GetUdpStatsFromStack(pUdpStats);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS);

    TraceLeave("AccessUdpStats");
    
    return dwResult;
}

DWORD 
AccessUdpTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get UDP Table

Locks

    UDP Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_UDPTABLE(NumUdpEntries)

Return Value:         

    NO_ERROR

--*/

{
    PMIB_UDPTABLE   pUdpTable = (PMIB_UDPTABLE)(pOutEntry->rgbyData);
    DWORD           i,dwResult;

    TraceEnter("AccessUdpTable");
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessUdpTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    dwResult = UpdateCache(UDPCACHE,pbCache);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessUdpTable: Couldnt update Udp Cache. Error %d",dwResult);

        TraceLeave("AccessUdpTable");

        return dwResult;
    }
    
    do
    {
        ENTER_READER(UDPCACHE);
        
        if((g_UdpInfo.pUdpTable is NULL) or 
           (g_UdpInfo.pUdpTable->dwNumEntries is 0))
        {
            Trace0(MIB,"AccessUdpTable: No valid entries found");

   